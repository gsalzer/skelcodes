{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Adjudicator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./lib/ReEncryptionValidator.sol\\\";\\nimport \\\"./lib/SignatureVerifier.sol\\\";\\nimport \\\"./StakingEscrow.sol\\\";\\nimport \\\"./proxy/Upgradeable.sol\\\";\\nimport \\\"../zeppelin/math/SafeMath.sol\\\";\\nimport \\\"../zeppelin/math/Math.sol\\\";\\n\\n\\n/**\\n* @notice Supervises stakers' behavior and punishes when something's wrong.\\n* @dev |v2.1.2|\\n*/\\ncontract Adjudicator is Upgradeable {\\n\\n    using SafeMath for uint256;\\n    using UmbralDeserializer for bytes;\\n\\n    event CFragEvaluated(\\n        bytes32 indexed evaluationHash,\\n        address indexed investigator,\\n        bool correctness\\n    );\\n    event IncorrectCFragVerdict(\\n        bytes32 indexed evaluationHash,\\n        address indexed worker,\\n        address indexed staker\\n    );\\n\\n    // used only for upgrading\\n    bytes32 constant RESERVED_CAPSULE_AND_CFRAG_BYTES = bytes32(0);\\n    address constant RESERVED_ADDRESS = address(0);\\n\\n    StakingEscrow public immutable escrow;\\n    SignatureVerifier.HashAlgorithm public immutable hashAlgorithm;\\n    uint256 public immutable basePenalty;\\n    uint256 public immutable penaltyHistoryCoefficient;\\n    uint256 public immutable percentagePenaltyCoefficient;\\n    uint256 public immutable rewardCoefficient;\\n\\n    mapping (address => uint256) public penaltyHistory;\\n    mapping (bytes32 => bool) public evaluatedCFrags;\\n\\n    /**\\n    * @param _escrow Escrow contract\\n    * @param _hashAlgorithm Hashing algorithm\\n    * @param _basePenalty Base for the penalty calculation\\n    * @param _penaltyHistoryCoefficient Coefficient for calculating the penalty depending on the history\\n    * @param _percentagePenaltyCoefficient Coefficient for calculating the percentage penalty\\n    * @param _rewardCoefficient Coefficient for calculating the reward\\n    */\\n    constructor(\\n        StakingEscrow _escrow,\\n        SignatureVerifier.HashAlgorithm _hashAlgorithm,\\n        uint256 _basePenalty,\\n        uint256 _penaltyHistoryCoefficient,\\n        uint256 _percentagePenaltyCoefficient,\\n        uint256 _rewardCoefficient\\n    ) {\\n        // Sanity checks.\\n        require(_escrow.secondsPerPeriod() > 0 &&  // This contract has an escrow, and it's not the null address.\\n            // The reward and penalty coefficients are set.\\n            _percentagePenaltyCoefficient != 0 &&\\n            _rewardCoefficient != 0);\\n        escrow = _escrow;\\n        hashAlgorithm = _hashAlgorithm;\\n        basePenalty = _basePenalty;\\n        percentagePenaltyCoefficient = _percentagePenaltyCoefficient;\\n        penaltyHistoryCoefficient = _penaltyHistoryCoefficient;\\n        rewardCoefficient = _rewardCoefficient;\\n    }\\n\\n    /**\\n    * @notice Submit proof that a worker created wrong CFrag\\n    * @param _capsuleBytes Serialized capsule\\n    * @param _cFragBytes Serialized CFrag\\n    * @param _cFragSignature Signature of CFrag by worker\\n    * @param _taskSignature Signature of task specification by Bob\\n    * @param _requesterPublicKey Bob's signing public key, also known as \\\"stamp\\\"\\n    * @param _workerPublicKey Worker's signing public key, also known as \\\"stamp\\\"\\n    * @param _workerIdentityEvidence Signature of worker's public key by worker's eth-key\\n    * @param _preComputedData Additional pre-computed data for CFrag correctness verification\\n    */\\n    function evaluateCFrag(\\n        bytes memory _capsuleBytes,\\n        bytes memory _cFragBytes,\\n        bytes memory _cFragSignature,\\n        bytes memory _taskSignature,\\n        bytes memory _requesterPublicKey,\\n        bytes memory _workerPublicKey,\\n        bytes memory _workerIdentityEvidence,\\n        bytes memory _preComputedData\\n    )\\n        public\\n    {\\n        // 1. Check that CFrag is not evaluated yet\\n        bytes32 evaluationHash = SignatureVerifier.hash(\\n            abi.encodePacked(_capsuleBytes, _cFragBytes), hashAlgorithm);\\n        require(!evaluatedCFrags[evaluationHash], \\\"This CFrag has already been evaluated.\\\");\\n        evaluatedCFrags[evaluationHash] = true;\\n\\n        // 2. Verify correctness of re-encryption\\n        bool cFragIsCorrect = ReEncryptionValidator.validateCFrag(_capsuleBytes, _cFragBytes, _preComputedData);\\n        emit CFragEvaluated(evaluationHash, msg.sender, cFragIsCorrect);\\n\\n        // 3. Verify associated public keys and signatures\\n        require(ReEncryptionValidator.checkSerializedCoordinates(_workerPublicKey),\\n                \\\"Staker's public key is invalid\\\");\\n        require(ReEncryptionValidator.checkSerializedCoordinates(_requesterPublicKey),\\n                \\\"Requester's public key is invalid\\\");\\n\\n        UmbralDeserializer.PreComputedData memory precomp = _preComputedData.toPreComputedData();\\n\\n        // Verify worker's signature of CFrag\\n        require(SignatureVerifier.verify(\\n                _cFragBytes,\\n                abi.encodePacked(_cFragSignature, precomp.lostBytes[1]),\\n                _workerPublicKey,\\n                hashAlgorithm),\\n                \\\"CFrag signature is invalid\\\"\\n        );\\n\\n        // Verify worker's signature of taskSignature and that it corresponds to cfrag.proof.metadata\\n        UmbralDeserializer.CapsuleFrag memory cFrag = _cFragBytes.toCapsuleFrag();\\n        require(SignatureVerifier.verify(\\n                _taskSignature,\\n                abi.encodePacked(cFrag.proof.metadata, precomp.lostBytes[2]),\\n                _workerPublicKey,\\n                hashAlgorithm),\\n                \\\"Task signature is invalid\\\"\\n        );\\n\\n        // Verify that _taskSignature is bob's signature of the task specification.\\n        // A task specification is: capsule + ursula pubkey + alice address + blockhash\\n        bytes32 stampXCoord;\\n        assembly {\\n            stampXCoord := mload(add(_workerPublicKey, 32))\\n        }\\n        bytes memory stamp = abi.encodePacked(precomp.lostBytes[4], stampXCoord);\\n\\n        require(SignatureVerifier.verify(\\n                abi.encodePacked(_capsuleBytes,\\n                                 stamp,\\n                                 _workerIdentityEvidence,\\n                                 precomp.alicesKeyAsAddress,\\n                                 bytes32(0)),\\n                abi.encodePacked(_taskSignature, precomp.lostBytes[3]),\\n                _requesterPublicKey,\\n                hashAlgorithm),\\n                \\\"Specification signature is invalid\\\"\\n        );\\n\\n        // 4. Extract worker address from stamp signature.\\n        address worker = SignatureVerifier.recover(\\n            SignatureVerifier.hashEIP191(stamp, byte(0x45)), // Currently, we use version E (0x45) of EIP191 signatures\\n            _workerIdentityEvidence);\\n        address staker = escrow.stakerFromWorker(worker);\\n        require(staker != address(0), \\\"Worker must be related to a staker\\\");\\n\\n        // 5. Check that staker can be slashed\\n        uint256 stakerValue = escrow.getAllTokens(staker);\\n        require(stakerValue > 0, \\\"Staker has no tokens\\\");\\n\\n        // 6. If CFrag was incorrect, slash staker\\n        if (!cFragIsCorrect) {\\n            (uint256 penalty, uint256 reward) = calculatePenaltyAndReward(staker, stakerValue);\\n            escrow.slashStaker(staker, penalty, msg.sender, reward);\\n            emit IncorrectCFragVerdict(evaluationHash, worker, staker);\\n        }\\n    }\\n\\n    /**\\n    * @notice Calculate penalty to the staker and reward to the investigator\\n    * @param _staker Staker's address\\n    * @param _stakerValue Amount of tokens that belong to the staker\\n    */\\n    function calculatePenaltyAndReward(address _staker, uint256 _stakerValue)\\n        internal returns (uint256 penalty, uint256 reward)\\n    {\\n        penalty = basePenalty.add(penaltyHistoryCoefficient.mul(penaltyHistory[_staker]));\\n        penalty = Math.min(penalty, _stakerValue.div(percentagePenaltyCoefficient));\\n        reward = penalty.div(rewardCoefficient);\\n        // TODO add maximum condition or other overflow protection or other penalty condition (#305?)\\n        penaltyHistory[_staker] = penaltyHistory[_staker].add(1);\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n        bytes32 evaluationCFragHash = SignatureVerifier.hash(\\n            abi.encodePacked(RESERVED_CAPSULE_AND_CFRAG_BYTES), SignatureVerifier.HashAlgorithm.SHA256);\\n        require(delegateGet(_testTarget, this.evaluatedCFrags.selector, evaluationCFragHash) ==\\n            (evaluatedCFrags[evaluationCFragHash] ? 1 : 0));\\n        require(delegateGet(_testTarget, this.penaltyHistory.selector, bytes32(bytes20(RESERVED_ADDRESS))) ==\\n            penaltyHistory[RESERVED_ADDRESS]);\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `finishUpgrade`\\n    function finishUpgrade(address _target) public override virtual {\\n        super.finishUpgrade(_target);\\n        // preparation for the verifyState method\\n        bytes32 evaluationCFragHash = SignatureVerifier.hash(\\n            abi.encodePacked(RESERVED_CAPSULE_AND_CFRAG_BYTES), SignatureVerifier.HashAlgorithm.SHA256);\\n        evaluatedCFrags[evaluationCFragHash] = true;\\n        penaltyHistory[RESERVED_ADDRESS] = 123;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ReEncryptionValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./UmbralDeserializer.sol\\\";\\nimport \\\"./SignatureVerifier.sol\\\";\\n\\n/**\\n* @notice Validates re-encryption correctness.\\n*/\\nlibrary ReEncryptionValidator {\\n\\n    using UmbralDeserializer for bytes;\\n\\n\\n    //------------------------------//\\n    //   Umbral-specific constants  //\\n    //------------------------------//\\n\\n    // See parameter `u` of `UmbralParameters` class in pyUmbral\\n    // https://github.com/nucypher/pyUmbral/blob/master/umbral/params.py\\n    uint8 public constant UMBRAL_PARAMETER_U_SIGN = 0x02;\\n    uint256 public constant UMBRAL_PARAMETER_U_XCOORD = 0x03c98795773ff1c241fc0b1cced85e80f8366581dda5c9452175ebd41385fa1f;\\n    uint256 public constant UMBRAL_PARAMETER_U_YCOORD = 0x7880ed56962d7c0ae44d6f14bb53b5fe64b31ea44a41d0316f3a598778f0f936;\\n\\n\\n    //------------------------------//\\n    // SECP256K1-specific constants //\\n    //------------------------------//\\n\\n    // Base field order\\n    uint256 constant FIELD_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\\n\\n    // -2 mod FIELD_ORDER\\n    uint256 constant MINUS_2 = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2d;\\n\\n    // (-1/2) mod FIELD_ORDER\\n    uint256 constant MINUS_ONE_HALF = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7ffffe17;\\n\\n\\n    //\\n\\n    /**\\n    * @notice Check correctness of re-encryption\\n    * @param _capsuleBytes Capsule\\n    * @param _cFragBytes Capsule frag\\n    * @param _precomputedBytes Additional precomputed data\\n    */\\n    function validateCFrag(\\n        bytes memory _capsuleBytes,\\n        bytes memory _cFragBytes,\\n        bytes memory _precomputedBytes\\n    )\\n        internal pure returns (bool)\\n    {\\n        UmbralDeserializer.Capsule memory _capsule = _capsuleBytes.toCapsule();\\n        UmbralDeserializer.CapsuleFrag memory _cFrag = _cFragBytes.toCapsuleFrag();\\n        UmbralDeserializer.PreComputedData memory _precomputed = _precomputedBytes.toPreComputedData();\\n\\n        // Extract Alice's address and check that it corresponds to the one provided\\n        address alicesAddress = SignatureVerifier.recover(\\n            _precomputed.hashedKFragValidityMessage,\\n            abi.encodePacked(_cFrag.proof.kFragSignature, _precomputed.lostBytes[0])\\n        );\\n        require(alicesAddress == _precomputed.alicesKeyAsAddress, \\\"Bad KFrag signature\\\");\\n\\n        // Compute proof's challenge scalar h, used in all ZKP verification equations\\n        uint256 h = computeProofChallengeScalar(_capsule, _cFrag);\\n\\n        //////\\n        // Verifying 1st equation: z*E == h*E_1 + E_2\\n        //////\\n\\n        // Input validation: E\\n        require(checkCompressedPoint(\\n            _capsule.pointE.sign,\\n            _capsule.pointE.xCoord,\\n            _precomputed.pointEyCoord),\\n            \\\"Precomputed Y coordinate of E doesn't correspond to compressed E point\\\"\\n        );\\n\\n        // Input validation: z*E\\n        require(isOnCurve(_precomputed.pointEZxCoord, _precomputed.pointEZyCoord),\\n                \\\"Point zE is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            _capsule.pointE.xCoord,         // E_x\\n            _precomputed.pointEyCoord,      // E_y\\n            _cFrag.proof.bnSig,             // z\\n            _precomputed.pointEZxCoord,     // zE_x\\n            _precomputed.pointEZyCoord),    // zE_y\\n            \\\"Precomputed z*E value is incorrect\\\"\\n        );\\n\\n        // Input validation: E1\\n        require(checkCompressedPoint(\\n            _cFrag.pointE1.sign,          // E1_sign\\n            _cFrag.pointE1.xCoord,        // E1_x\\n            _precomputed.pointE1yCoord),  // E1_y\\n            \\\"Precomputed Y coordinate of E1 doesn't correspond to compressed E1 point\\\"\\n        );\\n\\n        // Input validation: h*E1\\n        require(isOnCurve(_precomputed.pointE1HxCoord, _precomputed.pointE1HyCoord),\\n                \\\"Point h*E1 is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            _cFrag.pointE1.xCoord,          // E1_x\\n            _precomputed.pointE1yCoord,     // E1_y\\n            h,\\n            _precomputed.pointE1HxCoord,    // hE1_x\\n            _precomputed.pointE1HyCoord),   // hE1_y\\n            \\\"Precomputed h*E1 value is incorrect\\\"\\n        );\\n\\n        // Input validation: E2\\n        require(checkCompressedPoint(\\n            _cFrag.proof.pointE2.sign,        // E2_sign\\n            _cFrag.proof.pointE2.xCoord,      // E2_x\\n            _precomputed.pointE2yCoord),      // E2_y\\n            \\\"Precomputed Y coordinate of E2 doesn't correspond to compressed E2 point\\\"\\n        );\\n\\n        bool equation_holds = eqAffineJacobian(\\n            [_precomputed.pointEZxCoord,  _precomputed.pointEZyCoord],\\n            addAffineJacobian(\\n                [_cFrag.proof.pointE2.xCoord, _precomputed.pointE2yCoord],\\n                [_precomputed.pointE1HxCoord, _precomputed.pointE1HyCoord]\\n            )\\n        );\\n\\n        if (!equation_holds){\\n            return false;\\n        }\\n\\n        //////\\n        // Verifying 2nd equation: z*V == h*V_1 + V_2\\n        //////\\n\\n        // Input validation: V\\n        require(checkCompressedPoint(\\n            _capsule.pointV.sign,\\n            _capsule.pointV.xCoord,\\n            _precomputed.pointVyCoord),\\n            \\\"Precomputed Y coordinate of V doesn't correspond to compressed V point\\\"\\n        );\\n\\n        // Input validation: z*V\\n        require(isOnCurve(_precomputed.pointVZxCoord, _precomputed.pointVZyCoord),\\n                \\\"Point zV is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            _capsule.pointV.xCoord,         // V_x\\n            _precomputed.pointVyCoord,      // V_y\\n            _cFrag.proof.bnSig,             // z\\n            _precomputed.pointVZxCoord,     // zV_x\\n            _precomputed.pointVZyCoord),    // zV_y\\n            \\\"Precomputed z*V value is incorrect\\\"\\n        );\\n\\n        // Input validation: V1\\n        require(checkCompressedPoint(\\n            _cFrag.pointV1.sign,         // V1_sign\\n            _cFrag.pointV1.xCoord,       // V1_x\\n            _precomputed.pointV1yCoord), // V1_y\\n            \\\"Precomputed Y coordinate of V1 doesn't correspond to compressed V1 point\\\"\\n        );\\n\\n        // Input validation: h*V1\\n        require(isOnCurve(_precomputed.pointV1HxCoord, _precomputed.pointV1HyCoord),\\n            \\\"Point h*V1 is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            _cFrag.pointV1.xCoord,          // V1_x\\n            _precomputed.pointV1yCoord,     // V1_y\\n            h,\\n            _precomputed.pointV1HxCoord,    // h*V1_x\\n            _precomputed.pointV1HyCoord),   // h*V1_y\\n            \\\"Precomputed h*V1 value is incorrect\\\"\\n        );\\n\\n        // Input validation: V2\\n        require(checkCompressedPoint(\\n            _cFrag.proof.pointV2.sign,        // V2_sign\\n            _cFrag.proof.pointV2.xCoord,      // V2_x\\n            _precomputed.pointV2yCoord),      // V2_y\\n            \\\"Precomputed Y coordinate of V2 doesn't correspond to compressed V2 point\\\"\\n        );\\n\\n        equation_holds = eqAffineJacobian(\\n            [_precomputed.pointVZxCoord,  _precomputed.pointVZyCoord],\\n            addAffineJacobian(\\n                [_cFrag.proof.pointV2.xCoord, _precomputed.pointV2yCoord],\\n                [_precomputed.pointV1HxCoord, _precomputed.pointV1HyCoord]\\n            )\\n        );\\n\\n        if (!equation_holds){\\n            return false;\\n        }\\n\\n        //////\\n        // Verifying 3rd equation: z*U == h*U_1 + U_2\\n        //////\\n\\n        // We don't have to validate U since it's fixed and hard-coded\\n\\n        // Input validation: z*U\\n        require(isOnCurve(_precomputed.pointUZxCoord, _precomputed.pointUZyCoord),\\n                \\\"Point z*U is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            UMBRAL_PARAMETER_U_XCOORD,      // U_x\\n            UMBRAL_PARAMETER_U_YCOORD,      // U_y\\n            _cFrag.proof.bnSig,             // z\\n            _precomputed.pointUZxCoord,     // zU_x\\n            _precomputed.pointUZyCoord),    // zU_y\\n            \\\"Precomputed z*U value is incorrect\\\"\\n        );\\n\\n        // Input validation: U1  (a.k.a. KFragCommitment)\\n        require(checkCompressedPoint(\\n            _cFrag.proof.pointKFragCommitment.sign,     // U1_sign\\n            _cFrag.proof.pointKFragCommitment.xCoord,   // U1_x\\n            _precomputed.pointU1yCoord),                // U1_y\\n            \\\"Precomputed Y coordinate of U1 doesn't correspond to compressed U1 point\\\"\\n        );\\n\\n        // Input validation: h*U1\\n        require(isOnCurve(_precomputed.pointU1HxCoord, _precomputed.pointU1HyCoord),\\n                \\\"Point h*U1 is not a valid EC point\\\"\\n        );\\n        require(ecmulVerify(\\n            _cFrag.proof.pointKFragCommitment.xCoord,   // U1_x\\n            _precomputed.pointU1yCoord,                 // U1_y\\n            h,\\n            _precomputed.pointU1HxCoord,    // h*V1_x\\n            _precomputed.pointU1HyCoord),   // h*V1_y\\n            \\\"Precomputed h*V1 value is incorrect\\\"\\n        );\\n\\n        // Input validation: U2  (a.k.a. KFragPok (\\\"proof of knowledge\\\"))\\n        require(checkCompressedPoint(\\n            _cFrag.proof.pointKFragPok.sign,    // U2_sign\\n            _cFrag.proof.pointKFragPok.xCoord,  // U2_x\\n            _precomputed.pointU2yCoord),        // U2_y\\n            \\\"Precomputed Y coordinate of U2 doesn't correspond to compressed U2 point\\\"\\n        );\\n\\n        equation_holds = eqAffineJacobian(\\n            [_precomputed.pointUZxCoord,  _precomputed.pointUZyCoord],\\n            addAffineJacobian(\\n                [_cFrag.proof.pointKFragPok.xCoord, _precomputed.pointU2yCoord],\\n                [_precomputed.pointU1HxCoord, _precomputed.pointU1HyCoord]\\n            )\\n        );\\n\\n        return equation_holds;\\n    }\\n\\n    function computeProofChallengeScalar(\\n        UmbralDeserializer.Capsule memory _capsule,\\n        UmbralDeserializer.CapsuleFrag memory _cFrag\\n    ) internal pure returns (uint256) {\\n\\n        // Compute h = hash_to_bignum(e, e1, e2, v, v1, v2, u, u1, u2, metadata)\\n        bytes memory hashInput = abi.encodePacked(\\n            // Point E\\n            _capsule.pointE.sign,\\n            _capsule.pointE.xCoord,\\n            // Point E1\\n            _cFrag.pointE1.sign,\\n            _cFrag.pointE1.xCoord,\\n            // Point E2\\n            _cFrag.proof.pointE2.sign,\\n            _cFrag.proof.pointE2.xCoord\\n        );\\n\\n        hashInput = abi.encodePacked(\\n            hashInput,\\n            // Point V\\n            _capsule.pointV.sign,\\n            _capsule.pointV.xCoord,\\n            // Point V1\\n            _cFrag.pointV1.sign,\\n            _cFrag.pointV1.xCoord,\\n            // Point V2\\n            _cFrag.proof.pointV2.sign,\\n            _cFrag.proof.pointV2.xCoord\\n        );\\n\\n        hashInput = abi.encodePacked(\\n            hashInput,\\n            // Point U\\n            bytes1(UMBRAL_PARAMETER_U_SIGN),\\n            bytes32(UMBRAL_PARAMETER_U_XCOORD),\\n            // Point U1\\n            _cFrag.proof.pointKFragCommitment.sign,\\n            _cFrag.proof.pointKFragCommitment.xCoord,\\n            // Point U2\\n            _cFrag.proof.pointKFragPok.sign,\\n            _cFrag.proof.pointKFragPok.xCoord,\\n            // Re-encryption metadata\\n            _cFrag.proof.metadata\\n        );\\n\\n        uint256 h = extendedKeccakToBN(hashInput);\\n        return h;\\n\\n    }\\n\\n    function extendedKeccakToBN (bytes memory _data) internal pure returns (uint256) {\\n\\n        bytes32 upper;\\n        bytes32 lower;\\n\\n        // Umbral prepends to the data a customization string of 64-bytes.\\n        // In the case of hash_to_curvebn is 'hash_to_curvebn', padded with zeroes.\\n        bytes memory input = abi.encodePacked(bytes32(\\\"hash_to_curvebn\\\"), bytes32(0x00), _data);\\n\\n        (upper, lower) = (keccak256(abi.encodePacked(uint8(0x00), input)),\\n                          keccak256(abi.encodePacked(uint8(0x01), input)));\\n\\n        // Let n be the order of secp256k1's group (n = 2^256 - 0x1000003D1)\\n        // n_minus_1 = n - 1\\n        // delta = 2^256 mod n_minus_1\\n        uint256 delta = 0x14551231950b75fc4402da1732fc9bec0;\\n        uint256 n_minus_1 = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140;\\n\\n        uint256 upper_half = mulmod(uint256(upper), delta, n_minus_1);\\n        return 1 + addmod(upper_half, uint256(lower), n_minus_1);\\n    }\\n\\n    /// @notice Tests if a compressed point is valid, wrt to its corresponding Y coordinate\\n    /// @param _pointSign The sign byte from the compressed notation: 0x02 if the Y coord is even; 0x03 otherwise\\n    /// @param _pointX The X coordinate of an EC point in affine representation\\n    /// @param _pointY The Y coordinate of an EC point in affine representation\\n    /// @return true iff _pointSign and _pointX are the compressed representation of (_pointX, _pointY)\\n\\tfunction checkCompressedPoint(\\n\\t\\tuint8 _pointSign,\\n\\t\\tuint256 _pointX,\\n\\t\\tuint256 _pointY\\n\\t) internal pure returns(bool) {\\n\\t\\tbool correct_sign = _pointY % 2 == _pointSign - 2;\\n\\t\\treturn correct_sign && isOnCurve(_pointX, _pointY);\\n\\t}\\n\\n    /// @notice Tests if the given serialized coordinates represent a valid EC point\\n    /// @param _coords The concatenation of serialized X and Y coordinates\\n    /// @return true iff coordinates X and Y are a valid point\\n    function checkSerializedCoordinates(bytes memory _coords) internal pure returns(bool) {\\n        require(_coords.length == 64, \\\"Serialized coordinates should be 64 B\\\");\\n        uint256 coordX;\\n        uint256 coordY;\\n        assembly {\\n            coordX := mload(add(_coords, 32))\\n            coordY := mload(add(_coords, 64))\\n        }\\n\\t\\treturn isOnCurve(coordX, coordY);\\n\\t}\\n\\n    /// @notice Tests if a point is on the secp256k1 curve\\n    /// @param Px The X coordinate of an EC point in affine representation\\n    /// @param Py The Y coordinate of an EC point in affine representation\\n    /// @return true if (Px, Py) is a valid secp256k1 point; false otherwise\\n    function isOnCurve(uint256 Px, uint256 Py) internal pure returns (bool) {\\n        uint256 p = FIELD_ORDER;\\n\\n        if (Px >= p || Py >= p){\\n            return false;\\n        }\\n\\n        uint256 y2 = mulmod(Py, Py, p);\\n        uint256 x3_plus_7 = addmod(mulmod(mulmod(Px, Px, p), Px, p), 7, p);\\n        return y2 == x3_plus_7;\\n    }\\n\\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/4\\n    function ecmulVerify(\\n    \\tuint256 x1,\\n    \\tuint256 y1,\\n    \\tuint256 scalar,\\n    \\tuint256 qx,\\n    \\tuint256 qy\\n    ) internal pure returns(bool) {\\n\\t    uint256 curve_order = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n\\t    address signer = ecrecover(0, uint8(27 + (y1 % 2)), bytes32(x1), bytes32(mulmod(scalar, x1, curve_order)));\\n\\t    address xyAddress = address(uint256(keccak256(abi.encodePacked(qx, qy))) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\t    return xyAddress == signer;\\n\\t}\\n\\n    /// @notice Equality test of two points, in affine and Jacobian coordinates respectively\\n    /// @param P An EC point in affine coordinates\\n    /// @param Q An EC point in Jacobian coordinates\\n    /// @return true if P and Q represent the same point in affine coordinates; false otherwise\\n    function eqAffineJacobian(\\n    \\tuint256[2] memory P,\\n    \\tuint256[3] memory Q\\n    ) internal pure returns(bool){\\n        uint256 Qz = Q[2];\\n        if(Qz == 0){\\n            return false;       // Q is zero but P isn't.\\n        }\\n\\n        uint256 p = FIELD_ORDER;\\n        uint256 Q_z_squared = mulmod(Qz, Qz, p);\\n        return mulmod(P[0], Q_z_squared, p) == Q[0] && mulmod(P[1], mulmod(Q_z_squared, Qz, p), p) == Q[1];\\n\\n    }\\n\\n    /// @notice Adds two points in affine coordinates, with the result in Jacobian\\n    /// @dev Based on the addition formulas from http://www.hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/addition/add-2001-b.op3\\n    /// @param P An EC point in affine coordinates\\n    /// @param Q An EC point in affine coordinates\\n    /// @return R An EC point in Jacobian coordinates with the sum, represented by an array of 3 uint256\\n    function addAffineJacobian(\\n    \\tuint[2] memory P,\\n    \\tuint[2] memory Q\\n    ) internal pure returns (uint[3] memory R) {\\n\\n        uint256 p = FIELD_ORDER;\\n        uint256 a   = P[0];\\n        uint256 c   = P[1];\\n        uint256 t0  = Q[0];\\n        uint256 t1  = Q[1];\\n\\n        if ((a == t0) && (c == t1)){\\n            return doubleJacobian([a, c, 1]);\\n        }\\n        uint256 d = addmod(t1, p-c, p); // d = t1 - c\\n        uint256 b = addmod(t0, p-a, p); // b = t0 - a\\n        uint256 e = mulmod(b, b, p); // e = b^2\\n        uint256 f = mulmod(e, b, p);  // f = b^3\\n        uint256 g = mulmod(a, e, p);\\n        R[0] = addmod(mulmod(d, d, p), p-addmod(mulmod(2, g, p), f, p), p);\\n        R[1] = addmod(mulmod(d, addmod(g, p-R[0], p), p), p-mulmod(c, f, p), p);\\n        R[2] = b;\\n    }\\n\\n    /// @notice Point doubling in Jacobian coordinates\\n    /// @param P An EC point in Jacobian coordinates.\\n    /// @return Q An EC point in Jacobian coordinates\\n    function doubleJacobian(uint[3] memory P) internal pure returns (uint[3] memory Q) {\\n        uint256 z = P[2];\\n        if (z == 0)\\n            return Q;\\n        uint256 p = FIELD_ORDER;\\n        uint256 x = P[0];\\n        uint256 _2y = mulmod(2, P[1], p);\\n        uint256 _4yy = mulmod(_2y, _2y, p);\\n        uint256 s = mulmod(_4yy, x, p);\\n        uint256 m = mulmod(3, mulmod(x, x, p), p);\\n        uint256 t = addmod(mulmod(m, m, p), mulmod(MINUS_2, s, p),p);\\n        Q[0] = t;\\n        Q[1] = addmod(mulmod(m, addmod(s, p - t, p), p), mulmod(MINUS_ONE_HALF, mulmod(_4yy, _4yy, p), p), p);\\n        Q[2] = mulmod(_2y, z, p);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/UmbralDeserializer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n* @notice Deserialization library for Umbral objects\\n*/\\nlibrary UmbralDeserializer {\\n\\n    struct Point {\\n        uint8 sign;\\n        uint256 xCoord;\\n    }\\n\\n    struct Capsule {\\n        Point pointE;\\n        Point pointV;\\n        uint256 bnSig;\\n    }\\n\\n    struct CorrectnessProof {\\n        Point pointE2;\\n        Point pointV2;\\n        Point pointKFragCommitment;\\n        Point pointKFragPok;\\n        uint256 bnSig;\\n        bytes kFragSignature; // 64 bytes\\n        bytes metadata; // any length\\n    }\\n\\n    struct CapsuleFrag {\\n        Point pointE1;\\n        Point pointV1;\\n        bytes32 kFragId;\\n        Point pointPrecursor;\\n        CorrectnessProof proof;\\n    }\\n\\n    struct PreComputedData {\\n        uint256 pointEyCoord;\\n        uint256 pointEZxCoord;\\n        uint256 pointEZyCoord;\\n        uint256 pointE1yCoord;\\n        uint256 pointE1HxCoord;\\n        uint256 pointE1HyCoord;\\n        uint256 pointE2yCoord;\\n        uint256 pointVyCoord;\\n        uint256 pointVZxCoord;\\n        uint256 pointVZyCoord;\\n        uint256 pointV1yCoord;\\n        uint256 pointV1HxCoord;\\n        uint256 pointV1HyCoord;\\n        uint256 pointV2yCoord;\\n        uint256 pointUZxCoord;\\n        uint256 pointUZyCoord;\\n        uint256 pointU1yCoord;\\n        uint256 pointU1HxCoord;\\n        uint256 pointU1HyCoord;\\n        uint256 pointU2yCoord;\\n        bytes32 hashedKFragValidityMessage;\\n        address alicesKeyAsAddress;\\n        bytes5  lostBytes;\\n    }\\n\\n    uint256 constant BIGNUM_SIZE = 32;\\n    uint256 constant POINT_SIZE = 33;\\n    uint256 constant SIGNATURE_SIZE = 64;\\n    uint256 constant CAPSULE_SIZE = 2 * POINT_SIZE + BIGNUM_SIZE;\\n    uint256 constant CORRECTNESS_PROOF_SIZE = 4 * POINT_SIZE + BIGNUM_SIZE + SIGNATURE_SIZE;\\n    uint256 constant CAPSULE_FRAG_SIZE = 3 * POINT_SIZE + BIGNUM_SIZE;\\n    uint256 constant FULL_CAPSULE_FRAG_SIZE = CAPSULE_FRAG_SIZE + CORRECTNESS_PROOF_SIZE;\\n    uint256 constant PRECOMPUTED_DATA_SIZE = (20 * BIGNUM_SIZE) + 32 + 20 + 5;\\n\\n    /**\\n    * @notice Deserialize to capsule (not activated)\\n    */\\n    function toCapsule(bytes memory _capsuleBytes)\\n        internal pure returns (Capsule memory capsule)\\n    {\\n        require(_capsuleBytes.length == CAPSULE_SIZE);\\n        uint256 pointer = getPointer(_capsuleBytes);\\n        pointer = copyPoint(pointer, capsule.pointE);\\n        pointer = copyPoint(pointer, capsule.pointV);\\n        capsule.bnSig = uint256(getBytes32(pointer));\\n    }\\n\\n    /**\\n    * @notice Deserialize to correctness proof\\n    * @param _pointer Proof bytes memory pointer\\n    * @param _proofBytesLength Proof bytes length\\n    */\\n    function toCorrectnessProof(uint256 _pointer, uint256 _proofBytesLength)\\n        internal pure returns (CorrectnessProof memory proof)\\n    {\\n        require(_proofBytesLength >= CORRECTNESS_PROOF_SIZE);\\n\\n        _pointer = copyPoint(_pointer, proof.pointE2);\\n        _pointer = copyPoint(_pointer, proof.pointV2);\\n        _pointer = copyPoint(_pointer, proof.pointKFragCommitment);\\n        _pointer = copyPoint(_pointer, proof.pointKFragPok);\\n        proof.bnSig = uint256(getBytes32(_pointer));\\n        _pointer += BIGNUM_SIZE;\\n\\n        proof.kFragSignature = new bytes(SIGNATURE_SIZE);\\n        // TODO optimize, just two mload->mstore (#1500)\\n        _pointer = copyBytes(_pointer, proof.kFragSignature, SIGNATURE_SIZE);\\n        if (_proofBytesLength > CORRECTNESS_PROOF_SIZE) {\\n            proof.metadata = new bytes(_proofBytesLength - CORRECTNESS_PROOF_SIZE);\\n            copyBytes(_pointer, proof.metadata, proof.metadata.length);\\n        }\\n    }\\n\\n    /**\\n    * @notice Deserialize to correctness proof\\n    */\\n    function toCorrectnessProof(bytes memory _proofBytes)\\n        internal pure returns (CorrectnessProof memory proof)\\n    {\\n        uint256 pointer = getPointer(_proofBytes);\\n        return toCorrectnessProof(pointer, _proofBytes.length);\\n    }\\n\\n    /**\\n    * @notice Deserialize to CapsuleFrag\\n    */\\n    function toCapsuleFrag(bytes memory _cFragBytes)\\n        internal pure returns (CapsuleFrag memory cFrag)\\n    {\\n        uint256 cFragBytesLength = _cFragBytes.length;\\n        require(cFragBytesLength >= FULL_CAPSULE_FRAG_SIZE);\\n\\n        uint256 pointer = getPointer(_cFragBytes);\\n        pointer = copyPoint(pointer, cFrag.pointE1);\\n        pointer = copyPoint(pointer, cFrag.pointV1);\\n        cFrag.kFragId = getBytes32(pointer);\\n        pointer += BIGNUM_SIZE;\\n        pointer = copyPoint(pointer, cFrag.pointPrecursor);\\n\\n        cFrag.proof = toCorrectnessProof(pointer, cFragBytesLength - CAPSULE_FRAG_SIZE);\\n    }\\n\\n    /**\\n    * @notice Deserialize to precomputed data\\n    */\\n    function toPreComputedData(bytes memory _preComputedData)\\n        internal pure returns (PreComputedData memory data)\\n    {\\n        require(_preComputedData.length == PRECOMPUTED_DATA_SIZE);\\n        uint256 initial_pointer = getPointer(_preComputedData);\\n        uint256 pointer = initial_pointer;\\n\\n        data.pointEyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointEZxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointEZyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointE1yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointE1HxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointE1HyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointE2yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointVyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointVZxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointVZyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointV1yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointV1HxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointV1HyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointV2yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointUZxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointUZyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointU1yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointU1HxCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointU1HyCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.pointU2yCoord = uint256(getBytes32(pointer));\\n        pointer += BIGNUM_SIZE;\\n\\n        data.hashedKFragValidityMessage = getBytes32(pointer);\\n        pointer += 32;\\n\\n        data.alicesKeyAsAddress = address(bytes20(getBytes32(pointer)));\\n        pointer += 20;\\n\\n        // Lost bytes: a bytes5 variable holding the following byte values:\\n        //     0: kfrag signature recovery value v\\n        //     1: cfrag signature recovery value v\\n        //     2: metadata signature recovery value v\\n        //     3: specification signature recovery value v\\n        //     4: ursula pubkey sign byte\\n        data.lostBytes = bytes5(getBytes32(pointer));\\n        pointer += 5;\\n\\n        require(pointer == initial_pointer + PRECOMPUTED_DATA_SIZE);\\n    }\\n\\n    // TODO extract to external library if needed (#1500)\\n    /**\\n    * @notice Get the memory pointer for start of array\\n    */\\n    function getPointer(bytes memory _bytes) internal pure returns (uint256 pointer) {\\n        assembly {\\n            pointer := add(_bytes, 32) // skip array length\\n        }\\n    }\\n\\n    /**\\n    * @notice Copy point data from memory in the pointer position\\n    */\\n    function copyPoint(uint256 _pointer, Point memory _point)\\n        internal pure returns (uint256 resultPointer)\\n    {\\n        // TODO optimize, copy to point memory directly (#1500)\\n        uint8 temp;\\n        uint256 xCoord;\\n        assembly {\\n            temp := byte(0, mload(_pointer))\\n            xCoord := mload(add(_pointer, 1))\\n        }\\n        _point.sign = temp;\\n        _point.xCoord = xCoord;\\n        resultPointer = _pointer + POINT_SIZE;\\n    }\\n\\n    /**\\n    * @notice Read 1 byte from memory in the pointer position\\n    */\\n    function getByte(uint256 _pointer) internal pure returns (byte result) {\\n        bytes32 word;\\n        assembly {\\n            word := mload(_pointer)\\n        }\\n        result = word[0];\\n        return result;\\n    }\\n\\n    /**\\n    * @notice Read 32 bytes from memory in the pointer position\\n    */\\n    function getBytes32(uint256 _pointer) internal pure returns (bytes32 result) {\\n        assembly {\\n            result := mload(_pointer)\\n        }\\n    }\\n\\n    /**\\n    * @notice Copy bytes from the source pointer to the target array\\n    * @dev Assumes that enough memory has been allocated to store in target.\\n    * Also assumes that '_target' was the last thing that was allocated\\n    * @param _bytesPointer Source memory pointer\\n    * @param _target Target array\\n    * @param _bytesLength Number of bytes to copy\\n    */\\n    function copyBytes(uint256 _bytesPointer, bytes memory _target, uint256 _bytesLength)\\n        internal\\n        pure\\n        returns (uint256 resultPointer)\\n    {\\n        // Exploiting the fact that '_target' was the last thing to be allocated,\\n        // we can write entire words, and just overwrite any excess.\\n        assembly {\\n            // evm operations on words\\n            let words := div(add(_bytesLength, 31), 32)\\n            let source := _bytesPointer\\n            let destination := add(_target, 32)\\n            for\\n                { let i := 0 } // start at arr + 32 -> first byte corresponds to length\\n                lt(i, words)\\n                { i := add(i, 1) }\\n            {\\n                let offset := mul(i, 32)\\n                mstore(add(destination, offset), mload(add(source, offset)))\\n            }\\n            mstore(add(_target, add(32, mload(_target))), 0)\\n        }\\n        resultPointer = _bytesPointer + _bytesLength;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SignatureVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n* @notice Library to recover address and verify signatures\\n* @dev Simple wrapper for `ecrecover`\\n*/\\nlibrary SignatureVerifier {\\n\\n    enum HashAlgorithm {KECCAK256, SHA256, RIPEMD160}\\n\\n    // Header for Version E as defined by EIP191. First byte ('E') is also the version\\n    bytes25 constant EIP191_VERSION_E_HEADER = \\\"Ethereum Signed Message:\\\\n\\\";\\n\\n    /**\\n    * @notice Recover signer address from hash and signature\\n    * @param _hash 32 bytes message hash\\n    * @param _signature Signature of hash - 32 bytes r + 32 bytes s + 1 byte v (could be 0, 1, 27, 28)\\n    */\\n    function recover(bytes32 _hash, bytes memory _signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(_signature.length == 65);\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            r := mload(add(_signature, 32))\\n            s := mload(add(_signature, 64))\\n            v := byte(0, mload(add(_signature, 96)))\\n        }\\n\\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\\n        if (v < 27) {\\n            v += 27;\\n        }\\n        require(v == 27 || v == 28);\\n        return ecrecover(_hash, v, r, s);\\n    }\\n\\n    /**\\n    * @notice Transform public key to address\\n    * @param _publicKey secp256k1 public key\\n    */\\n    function toAddress(bytes memory _publicKey) internal pure returns (address) {\\n        return address(uint160(uint256(keccak256(_publicKey))));\\n    }\\n\\n    /**\\n    * @notice Hash using one of pre built hashing algorithm\\n    * @param _message Signed message\\n    * @param _algorithm Hashing algorithm\\n    */\\n    function hash(bytes memory _message, HashAlgorithm _algorithm)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        if (_algorithm == HashAlgorithm.KECCAK256) {\\n            result = keccak256(_message);\\n        } else if (_algorithm == HashAlgorithm.SHA256) {\\n            result = sha256(_message);\\n        } else {\\n            result = ripemd160(_message);\\n        }\\n    }\\n\\n    /**\\n    * @notice Verify ECDSA signature\\n    * @dev Uses one of pre built hashing algorithm\\n    * @param _message Signed message\\n    * @param _signature Signature of message hash\\n    * @param _publicKey secp256k1 public key in uncompressed format without prefix byte (64 bytes)\\n    * @param _algorithm Hashing algorithm\\n    */\\n    function verify(\\n        bytes memory _message,\\n        bytes memory _signature,\\n        bytes memory _publicKey,\\n        HashAlgorithm _algorithm\\n    )\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        require(_publicKey.length == 64);\\n        return toAddress(_publicKey) == recover(hash(_message, _algorithm), _signature);\\n    }\\n\\n    /**\\n    * @notice Hash message according to EIP191 signature specification\\n    * @dev It always assumes Keccak256 is used as hashing algorithm\\n    * @dev Only supports version 0 and version E (0x45)\\n    * @param _message Message to sign\\n    * @param _version EIP191 version to use\\n    */\\n    function hashEIP191(\\n        bytes memory _message,\\n        byte _version\\n    )\\n        internal\\n        view\\n        returns (bytes32 result)\\n    {\\n        if(_version == byte(0x00)){  // Version 0: Data with intended validator\\n            address validator = address(this);\\n            return keccak256(abi.encodePacked(byte(0x19), byte(0x00), validator, _message));\\n        } else if (_version == byte(0x45)){  // Version E: personal_sign messages\\n            uint256 length = _message.length;\\n            require(length > 0, \\\"Empty message not allowed for version E\\\");\\n\\n            // Compute text-encoded length of message\\n            uint256 digits = 0;\\n            while (length != 0) {\\n                digits++;\\n                length /= 10;\\n            }\\n            bytes memory lengthAsText = new bytes(digits);\\n            length = _message.length;\\n            uint256 index = digits - 1;\\n            while (length != 0) {\\n                lengthAsText[index--] = byte(uint8(48 + length % 10));\\n                length /= 10;\\n            }\\n\\n            return keccak256(abi.encodePacked(byte(0x19), EIP191_VERSION_E_HEADER, lengthAsText, _message));\\n        } else {\\n            revert(\\\"Unsupported EIP191 version\\\");\\n        }\\n    }\\n\\n    /**\\n    * @notice Verify EIP191 signature\\n    * @dev It always assumes Keccak256 is used as hashing algorithm\\n    * @dev Only supports version 0 and version E (0x45)\\n    * @param _message Signed message\\n    * @param _signature Signature of message hash\\n    * @param _publicKey secp256k1 public key in uncompressed format without prefix byte (64 bytes)\\n    * @param _version EIP191 version to use\\n    */\\n    function verifyEIP191(\\n        bytes memory _message,\\n        bytes memory _signature,\\n        bytes memory _publicKey,\\n        byte _version\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(_publicKey.length == 64);\\n        return toAddress(_publicKey) == recover(hashEIP191(_message, _version), _signature);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/StakingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"../aragon/interfaces/IERC900History.sol\\\";\\nimport \\\"./Issuer.sol\\\";\\nimport \\\"./lib/Bits.sol\\\";\\nimport \\\"./lib/Snapshot.sol\\\";\\nimport \\\"../zeppelin/math/SafeMath.sol\\\";\\nimport \\\"../zeppelin/token/ERC20/SafeERC20.sol\\\";\\n\\n\\n/**\\n* @notice PolicyManager interface\\n*/\\ninterface PolicyManagerInterface {\\n    function register(address _node, uint16 _period) external;\\n    function escrow() external view returns (address);\\n    function ping(\\n        address _node,\\n        uint16 _processedPeriod1,\\n        uint16 _processedPeriod2,\\n        uint16 _periodToSetDefault\\n    ) external;\\n}\\n\\n\\n/**\\n* @notice Adjudicator interface\\n*/\\ninterface AdjudicatorInterface {\\n    function escrow() external view returns (address);\\n}\\n\\n\\n/**\\n* @notice WorkLock interface\\n*/\\ninterface WorkLockInterface {\\n    function escrow() external view returns (address);\\n}\\n\\n\\n/**\\n* @notice Contract holds and locks stakers tokens.\\n* Each staker that locks their tokens will receive some compensation\\n* @dev |v5.4.4|\\n*/\\ncontract StakingEscrow is Issuer, IERC900History {\\n\\n    using AdditionalMath for uint256;\\n    using AdditionalMath for uint16;\\n    using Bits for uint256;\\n    using SafeMath for uint256;\\n    using Snapshot for uint128[];\\n    using SafeERC20 for NuCypherToken;\\n\\n    event Deposited(address indexed staker, uint256 value, uint16 periods);\\n    event Locked(address indexed staker, uint256 value, uint16 firstPeriod, uint16 periods);\\n    event Divided(\\n        address indexed staker,\\n        uint256 oldValue,\\n        uint16 lastPeriod,\\n        uint256 newValue,\\n        uint16 periods\\n    );\\n    event Merged(address indexed staker, uint256 value1, uint256 value2, uint16 lastPeriod);\\n    event Prolonged(address indexed staker, uint256 value, uint16 lastPeriod, uint16 periods);\\n    event Withdrawn(address indexed staker, uint256 value);\\n    event CommitmentMade(address indexed staker, uint16 indexed period, uint256 value);\\n    event Minted(address indexed staker, uint16 indexed period, uint256 value);\\n    event Slashed(address indexed staker, uint256 penalty, address indexed investigator, uint256 reward);\\n    event ReStakeSet(address indexed staker, bool reStake);\\n    event ReStakeLocked(address indexed staker, uint16 lockUntilPeriod);\\n    event WorkerBonded(address indexed staker, address indexed worker, uint16 indexed startPeriod);\\n    event WorkMeasurementSet(address indexed staker, bool measureWork);\\n    event WindDownSet(address indexed staker, bool windDown);\\n    event SnapshotSet(address indexed staker, bool snapshotsEnabled);\\n\\n    struct SubStakeInfo {\\n        uint16 firstPeriod;\\n        uint16 lastPeriod;\\n        uint16 periods;\\n        uint128 lockedValue;\\n    }\\n\\n    struct Downtime {\\n        uint16 startPeriod;\\n        uint16 endPeriod;\\n    }\\n\\n    struct StakerInfo {\\n        uint256 value;\\n        /*\\n        * Stores periods that are committed but not yet rewarded.\\n        * In order to optimize storage, only two values are used instead of an array.\\n        * commitToNextPeriod() method invokes mint() method so there can only be two committed\\n        * periods that are not yet rewarded: the current and the next periods.\\n        */\\n        uint16 currentCommittedPeriod;\\n        uint16 nextCommittedPeriod;\\n        uint16 lastCommittedPeriod;\\n        uint16 lockReStakeUntilPeriod;\\n        uint256 completedWork;\\n        uint16 workerStartPeriod; // period when worker was bonded\\n        address worker;\\n        uint256 flags; // uint256 to acquire whole slot and minimize operations on it\\n\\n        uint256 reservedSlot1;\\n        uint256 reservedSlot2;\\n        uint256 reservedSlot3;\\n        uint256 reservedSlot4;\\n        uint256 reservedSlot5;\\n\\n        Downtime[] pastDowntime;\\n        SubStakeInfo[] subStakes;\\n        uint128[] history;\\n\\n    }\\n\\n    // used only for upgrading\\n    uint16 internal constant RESERVED_PERIOD = 0;\\n    uint16 internal constant MAX_CHECKED_VALUES = 5;\\n    // to prevent high gas consumption in loops for slashing\\n    uint16 public constant MAX_SUB_STAKES = 30;\\n    uint16 internal constant MAX_UINT16 = 65535;\\n\\n    // indices for flags\\n    uint8 internal constant RE_STAKE_DISABLED_INDEX = 0;\\n    uint8 internal constant WIND_DOWN_INDEX = 1;\\n    uint8 internal constant MEASURE_WORK_INDEX = 2;\\n    uint8 internal constant SNAPSHOTS_DISABLED_INDEX = 3;\\n\\n    uint16 public immutable minLockedPeriods;\\n    uint16 public immutable minWorkerPeriods;\\n    uint256 public immutable minAllowableLockedTokens;\\n    uint256 public immutable maxAllowableLockedTokens;\\n    bool public immutable isTestContract;\\n\\n    mapping (address => StakerInfo) public stakerInfo;\\n    address[] public stakers;\\n    mapping (address => address) public stakerFromWorker;\\n\\n    mapping (uint16 => uint256) public lockedPerPeriod;\\n    uint128[] public balanceHistory;\\n\\n    PolicyManagerInterface public policyManager;\\n    AdjudicatorInterface public adjudicator;\\n    WorkLockInterface public workLock;\\n\\n    /**\\n    * @notice Constructor sets address of token contract and coefficients for minting\\n    * @param _token Token contract\\n    * @param _hoursPerPeriod Size of period in hours\\n    * @param _issuanceDecayCoefficient (d) Coefficient which modifies the rate at which the maximum issuance decays,\\n    * only applicable to Phase 2. d = 365 * half-life / LOG2 where default half-life = 2.\\n    * See Equation 10 in Staking Protocol & Economics paper\\n    * @param _lockDurationCoefficient1 (k1) Numerator of the coefficient which modifies the extent\\n    * to which a stake's lock duration affects the subsidy it receives. Affects stakers differently.\\n    * Applicable to Phase 1 and Phase 2. k1 = k2 * small_stake_multiplier where default small_stake_multiplier = 0.5.\\n    * See Equation 8 in Staking Protocol & Economics paper.\\n    * @param _lockDurationCoefficient2 (k2) Denominator of the coefficient which modifies the extent\\n    * to which a stake's lock duration affects the subsidy it receives. Affects stakers differently.\\n    * Applicable to Phase 1 and Phase 2. k2 = maximum_rewarded_periods / (1 - small_stake_multiplier)\\n    * where default maximum_rewarded_periods = 365 and default small_stake_multiplier = 0.5.\\n    * See Equation 8 in Staking Protocol & Economics paper.\\n    * @param _maximumRewardedPeriods (kmax) Number of periods beyond which a stake's lock duration\\n    * no longer increases the subsidy it receives. kmax = reward_saturation * 365 where default reward_saturation = 1.\\n    * See Equation 8 in Staking Protocol & Economics paper.\\n    * @param _firstPhaseTotalSupply Total supply for the first phase\\n    * @param _firstPhaseMaxIssuance (Imax) Maximum number of new tokens minted per period during Phase 1.\\n    * See Equation 7 in Staking Protocol & Economics paper.\\n    * @param _minLockedPeriods Min amount of periods during which tokens can be locked\\n    * @param _minAllowableLockedTokens Min amount of tokens that can be locked\\n    * @param _maxAllowableLockedTokens Max amount of tokens that can be locked\\n    * @param _minWorkerPeriods Min amount of periods while a worker can't be changed\\n    * @param _isTestContract True if contract is only for tests\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        uint32 _hoursPerPeriod,\\n        uint256 _issuanceDecayCoefficient,\\n        uint256 _lockDurationCoefficient1,\\n        uint256 _lockDurationCoefficient2,\\n        uint16 _maximumRewardedPeriods,\\n        uint256 _firstPhaseTotalSupply,\\n        uint256 _firstPhaseMaxIssuance,\\n        uint16 _minLockedPeriods,\\n        uint256 _minAllowableLockedTokens,\\n        uint256 _maxAllowableLockedTokens,\\n        uint16 _minWorkerPeriods,\\n        bool _isTestContract\\n    )\\n        Issuer(\\n            _token,\\n            _hoursPerPeriod,\\n            _issuanceDecayCoefficient,\\n            _lockDurationCoefficient1,\\n            _lockDurationCoefficient2,\\n            _maximumRewardedPeriods,\\n            _firstPhaseTotalSupply,\\n            _firstPhaseMaxIssuance\\n        )\\n    {\\n        // constant `1` in the expression `_minLockedPeriods > 1` uses to simplify the `lock` method\\n        require(_minLockedPeriods > 1 && _maxAllowableLockedTokens != 0);\\n        minLockedPeriods = _minLockedPeriods;\\n        minAllowableLockedTokens = _minAllowableLockedTokens;\\n        maxAllowableLockedTokens = _maxAllowableLockedTokens;\\n        minWorkerPeriods = _minWorkerPeriods;\\n        isTestContract = _isTestContract;\\n    }\\n\\n    /**\\n    * @dev Checks the existence of a staker in the contract\\n    */\\n    modifier onlyStaker()\\n    {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        require(info.value > 0 || info.nextCommittedPeriod != 0);\\n        _;\\n    }\\n\\n    //------------------------Initialization------------------------\\n    /**\\n    * @notice Set policy manager address\\n    */\\n    function setPolicyManager(PolicyManagerInterface _policyManager) external onlyOwner {\\n        // Policy manager can be set only once\\n        require(address(policyManager) == address(0));\\n        // This escrow must be the escrow for the new policy manager\\n        require(_policyManager.escrow() == address(this));\\n        policyManager = _policyManager;\\n    }\\n\\n    /**\\n    * @notice Set adjudicator address\\n    */\\n    function setAdjudicator(AdjudicatorInterface _adjudicator) external onlyOwner {\\n        // Adjudicator can be set only once\\n        require(address(adjudicator) == address(0));\\n        // This escrow must be the escrow for the new adjudicator\\n        require(_adjudicator.escrow() == address(this));\\n        adjudicator = _adjudicator;\\n    }\\n\\n    /**\\n    * @notice Set worklock address\\n    */\\n    function setWorkLock(WorkLockInterface _workLock) external onlyOwner {\\n        // WorkLock can be set only once\\n        require(address(workLock) == address(0) || isTestContract);\\n        // This escrow must be the escrow for the new worklock\\n        require(_workLock.escrow() == address(this));\\n        workLock = _workLock;\\n    }\\n\\n    //------------------------Main getters------------------------\\n    /**\\n    * @notice Get all tokens belonging to the staker\\n    */\\n    function getAllTokens(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].value;\\n    }\\n\\n    /**\\n    * @notice Get all flags for the staker\\n    */\\n    function getFlags(address _staker)\\n        external view returns (\\n            bool windDown,\\n            bool reStake,\\n            bool measureWork,\\n            bool snapshots\\n        )\\n    {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        windDown = info.flags.bitSet(WIND_DOWN_INDEX);\\n        reStake = !info.flags.bitSet(RE_STAKE_DISABLED_INDEX);\\n        measureWork = info.flags.bitSet(MEASURE_WORK_INDEX);\\n        snapshots = !info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX);\\n    }\\n\\n    /**\\n    * @notice Get the start period. Use in the calculation of the last period of the sub stake\\n    * @param _info Staker structure\\n    * @param _currentPeriod Current period\\n    */\\n    function getStartPeriod(StakerInfo storage _info, uint16 _currentPeriod)\\n        internal view returns (uint16)\\n    {\\n        // if the next period (after current) is committed\\n        if (_info.flags.bitSet(WIND_DOWN_INDEX) && _info.nextCommittedPeriod > _currentPeriod) {\\n            return _currentPeriod + 1;\\n        }\\n        return _currentPeriod;\\n    }\\n\\n    /**\\n    * @notice Get the last period of the sub stake\\n    * @param _subStake Sub stake structure\\n    * @param _startPeriod Pre-calculated start period\\n    */\\n    function getLastPeriodOfSubStake(SubStakeInfo storage _subStake, uint16 _startPeriod)\\n        internal view returns (uint16)\\n    {\\n        if (_subStake.lastPeriod != 0) {\\n            return _subStake.lastPeriod;\\n        }\\n        uint32 lastPeriod = uint32(_startPeriod) + _subStake.periods;\\n        if (lastPeriod > uint32(MAX_UINT16)) {\\n            return MAX_UINT16;\\n        }\\n        return uint16(lastPeriod);\\n    }\\n\\n    /**\\n    * @notice Get the last period of the sub stake\\n    * @param _staker Staker\\n    * @param _index Stake index\\n    */\\n    function getLastPeriodOfSubStake(address _staker, uint256 _index)\\n        public view returns (uint16)\\n    {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        SubStakeInfo storage subStake = info.subStakes[_index];\\n        uint16 startPeriod = getStartPeriod(info, getCurrentPeriod());\\n        return getLastPeriodOfSubStake(subStake, startPeriod);\\n    }\\n\\n\\n    /**\\n    * @notice Get the value of locked tokens for a staker in a specified period\\n    * @dev Information may be incorrect for rewarded or not committed surpassed period\\n    * @param _info Staker structure\\n    * @param _currentPeriod Current period\\n    * @param _period Next period\\n    */\\n    function getLockedTokens(StakerInfo storage _info, uint16 _currentPeriod, uint16 _period)\\n        internal view returns (uint256 lockedValue)\\n    {\\n        lockedValue = 0;\\n        uint16 startPeriod = getStartPeriod(_info, _currentPeriod);\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake = _info.subStakes[i];\\n            if (subStake.firstPeriod <= _period &&\\n                getLastPeriodOfSubStake(subStake, startPeriod) >= _period) {\\n                lockedValue += subStake.lockedValue;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Get the value of locked tokens for a staker in a future period\\n    * @dev This function is used by PreallocationEscrow so its signature can't be updated.\\n    * @param _staker Staker\\n    * @param _periods Amount of periods that will be added to the current period\\n    */\\n    function getLockedTokens(address _staker, uint16 _periods)\\n        external view returns (uint256 lockedValue)\\n    {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod.add16(_periods);\\n        return getLockedTokens(info, currentPeriod, nextPeriod);\\n    }\\n\\n    /**\\n    * @notice Get the last committed staker's period\\n    * @param _staker Staker\\n    */\\n    function getLastCommittedPeriod(address _staker) public view returns (uint16) {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        return info.nextCommittedPeriod != 0 ? info.nextCommittedPeriod : info.lastCommittedPeriod;\\n    }\\n\\n    /**\\n    * @notice Get the value of locked tokens for active stakers in (getCurrentPeriod() + _periods) period\\n    * as well as stakers and their locked tokens\\n    * @param _periods Amount of periods for locked tokens calculation\\n    * @param _startIndex Start index for looking in stakers array\\n    * @param _maxStakers Max stakers for looking, if set 0 then all will be used\\n    * @return allLockedTokens Sum of locked tokens for active stakers\\n    * @return activeStakers Array of stakers and their locked tokens. Stakers addresses stored as uint256\\n    * @dev Note that activeStakers[0] in an array of uint256, but you want addresses. Careful when used directly!\\n    */\\n    function getActiveStakers(uint16 _periods, uint256 _startIndex, uint256 _maxStakers)\\n        external view returns (uint256 allLockedTokens, uint256[2][] memory activeStakers)\\n    {\\n        require(_periods > 0);\\n\\n        uint256 endIndex = stakers.length;\\n        require(_startIndex < endIndex);\\n        if (_maxStakers != 0 && _startIndex + _maxStakers < endIndex) {\\n            endIndex = _startIndex + _maxStakers;\\n        }\\n        activeStakers = new uint256[2][](endIndex - _startIndex);\\n        allLockedTokens = 0;\\n\\n        uint256 resultIndex = 0;\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod.add16(_periods);\\n\\n        for (uint256 i = _startIndex; i < endIndex; i++) {\\n            address staker = stakers[i];\\n            StakerInfo storage info = stakerInfo[staker];\\n            if (info.currentCommittedPeriod != currentPeriod &&\\n                info.nextCommittedPeriod != currentPeriod) {\\n                continue;\\n            }\\n            uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);\\n            if (lockedTokens != 0) {\\n                activeStakers[resultIndex][0] = uint256(staker);\\n                activeStakers[resultIndex++][1] = lockedTokens;\\n                allLockedTokens += lockedTokens;\\n            }\\n        }\\n        assembly {\\n            mstore(activeStakers, resultIndex)\\n        }\\n    }\\n\\n    /**\\n    * @notice Checks if `reStake` parameter is available for changing\\n    * @param _staker Staker\\n    */\\n    function isReStakeLocked(address _staker) public view returns (bool) {\\n        return getCurrentPeriod() < stakerInfo[_staker].lockReStakeUntilPeriod;\\n    }\\n\\n    /**\\n    * @notice Get worker using staker's address\\n    */\\n    function getWorkerFromStaker(address _staker) external view returns (address) {\\n        return stakerInfo[_staker].worker;\\n    }\\n\\n    /**\\n    * @notice Get work that completed by the staker\\n    */\\n    function getCompletedWork(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].completedWork;\\n    }\\n\\n    /**\\n    * @notice Find index of downtime structure that includes specified period\\n    * @dev If specified period is outside all downtime periods, the length of the array will be returned\\n    * @param _staker Staker\\n    * @param _period Specified period number\\n    */\\n    function findIndexOfPastDowntime(address _staker, uint16 _period) external view returns (uint256 index) {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        for (index = 0; index < info.pastDowntime.length; index++) {\\n            if (_period <= info.pastDowntime[index].endPeriod) {\\n                return index;\\n            }\\n        }\\n    }\\n\\n    //------------------------Main methods------------------------\\n    /**\\n    * @notice Start or stop measuring the work of a staker\\n    * @param _staker Staker\\n    * @param _measureWork Value for `measureWork` parameter\\n    * @return Work that was previously done\\n    */\\n    function setWorkMeasurement(address _staker, bool _measureWork) external returns (uint256) {\\n        require(msg.sender == address(workLock));\\n        StakerInfo storage info = stakerInfo[_staker];\\n        if (info.flags.bitSet(MEASURE_WORK_INDEX) == _measureWork) {\\n            return info.completedWork;\\n        }\\n        info.flags = info.flags.toggleBit(MEASURE_WORK_INDEX);\\n        emit WorkMeasurementSet(_staker, _measureWork);\\n        return info.completedWork;\\n    }\\n\\n    /**\\n    * @notice Bond worker\\n    * @param _worker Worker address. Must be a real address, not a contract\\n    */\\n    function bondWorker(address _worker) external onlyStaker {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        // Specified worker is already bonded with this staker\\n        require(_worker != info.worker);\\n        uint16 currentPeriod = getCurrentPeriod();\\n        if (info.worker != address(0)) { // If this staker had a worker ...\\n            // Check that enough time has passed to change it\\n            require(currentPeriod >= info.workerStartPeriod.add16(minWorkerPeriods));\\n            // Remove the old relation \\\"worker->staker\\\"\\n            stakerFromWorker[info.worker] = address(0);\\n        }\\n\\n        if (_worker != address(0)) {\\n            // Specified worker is already in use\\n            require(stakerFromWorker[_worker] == address(0));\\n            // Specified worker is a staker\\n            require(stakerInfo[_worker].subStakes.length == 0 || _worker == msg.sender);\\n            // Set new worker->staker relation\\n            stakerFromWorker[_worker] = msg.sender;\\n        }\\n\\n        // Bond new worker (or unbond if _worker == address(0))\\n        info.worker = _worker;\\n        info.workerStartPeriod = currentPeriod;\\n        emit WorkerBonded(msg.sender, _worker, currentPeriod);\\n    }\\n\\n    /**\\n    * @notice Set `reStake` parameter. If true then all staking rewards will be added to locked stake\\n    * Only if this parameter is not locked\\n    * @param _reStake Value for parameter\\n    */\\n    function setReStake(bool _reStake) external {\\n        require(!isReStakeLocked(msg.sender));\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        if (info.flags.bitSet(RE_STAKE_DISABLED_INDEX) == !_reStake) {\\n            return;\\n        }\\n        info.flags = info.flags.toggleBit(RE_STAKE_DISABLED_INDEX);\\n        emit ReStakeSet(msg.sender, _reStake);\\n    }\\n\\n    /**\\n    * @notice Lock `reStake` parameter. Only if this parameter is not locked\\n    * @param _lockReStakeUntilPeriod Can't change `reStake` value until this period\\n    */\\n    function lockReStake(uint16 _lockReStakeUntilPeriod) external {\\n        require(!isReStakeLocked(msg.sender) &&\\n            _lockReStakeUntilPeriod > getCurrentPeriod());\\n        stakerInfo[msg.sender].lockReStakeUntilPeriod = _lockReStakeUntilPeriod;\\n        emit ReStakeLocked(msg.sender, _lockReStakeUntilPeriod);\\n    }\\n\\n    /**\\n    * @notice Deposit tokens from WorkLock contract\\n    * @param _staker Staker address\\n    * @param _value Amount of tokens to deposit\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function depositFromWorkLock(\\n        address _staker,\\n        uint256 _value,\\n        uint16 _periods\\n    )\\n        external\\n    {\\n        require(msg.sender == address(workLock));\\n        StakerInfo storage info = stakerInfo[_staker];\\n        if (!info.flags.bitSet(WIND_DOWN_INDEX) && info.subStakes.length == 0) {\\n            info.flags = info.flags.toggleBit(WIND_DOWN_INDEX);\\n            emit WindDownSet(_staker, true);\\n        }\\n        deposit(_staker, msg.sender, MAX_SUB_STAKES, _value, _periods);\\n    }\\n\\n    /**\\n    * @notice Set `windDown` parameter.\\n    * If true then stake's duration will be decreasing in each period with `commitToNextPeriod()`\\n    * @param _windDown Value for parameter\\n    */\\n    function setWindDown(bool _windDown) external {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        if (info.flags.bitSet(WIND_DOWN_INDEX) == _windDown) {\\n            return;\\n        }\\n        info.flags = info.flags.toggleBit(WIND_DOWN_INDEX);\\n        emit WindDownSet(msg.sender, _windDown);\\n\\n        // duration adjustment if next period is committed\\n        uint16 nextPeriod = getCurrentPeriod() + 1;\\n        if (info.nextCommittedPeriod != nextPeriod) {\\n           return;\\n        }\\n\\n        // adjust sub-stakes duration for the new value of winding down parameter\\n        for (uint256 index = 0; index < info.subStakes.length; index++) {\\n            SubStakeInfo storage subStake = info.subStakes[index];\\n            // sub-stake does not have fixed last period when winding down is disabled\\n            if (!_windDown && subStake.lastPeriod == nextPeriod) {\\n                subStake.lastPeriod = 0;\\n                subStake.periods = 1;\\n                continue;\\n            }\\n            // this sub-stake is no longer affected by winding down parameter\\n            if (subStake.lastPeriod != 0 || subStake.periods == 0) {\\n                continue;\\n            }\\n\\n            subStake.periods = _windDown ? subStake.periods - 1 : subStake.periods + 1;\\n            if (subStake.periods == 0) {\\n                subStake.lastPeriod = nextPeriod;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Activate/deactivate taking snapshots of balances\\n    * @param _enableSnapshots True to activate snapshots, False to deactivate\\n    */\\n    function setSnapshots(bool _enableSnapshots) external {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        if (info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX) == !_enableSnapshots) {\\n            return;\\n        }\\n\\n        uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());\\n        if(_enableSnapshots){\\n            info.history.addSnapshot(info.value);\\n            balanceHistory.addSnapshot(lastGlobalBalance + info.value);\\n        } else {\\n            info.history.addSnapshot(0);\\n            balanceHistory.addSnapshot(lastGlobalBalance - info.value);\\n        }\\n        info.flags = info.flags.toggleBit(SNAPSHOTS_DISABLED_INDEX);\\n\\n        emit SnapshotSet(msg.sender, _enableSnapshots);\\n    }\\n\\n    /**\\n    * @notice Adds a new snapshot to both the staker and global balance histories,\\n    * assuming the staker's balance was already changed\\n    * @param _info Reference to affected staker's struct\\n    * @param _addition Variance in balance. It can be positive or negative.\\n    */\\n    function addSnapshot(StakerInfo storage _info, int256 _addition) internal {\\n        if(!_info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX)){\\n            _info.history.addSnapshot(_info.value);\\n            uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());\\n            balanceHistory.addSnapshot(lastGlobalBalance.addSigned(_addition));\\n        }\\n    }\\n\\n\\n    /**\\n    * @notice Batch deposit. Allowed only initial deposit for each staker\\n    * @param _stakers Stakers\\n    * @param _numberOfSubStakes Number of sub-stakes which belong to staker in _values and _periods arrays\\n    * @param _values Amount of tokens to deposit for each staker\\n    * @param _periods Amount of periods during which tokens will be locked for each staker\\n    */\\n    function batchDeposit(\\n        address[] calldata _stakers,\\n        uint256[] calldata _numberOfSubStakes,\\n        uint256[] calldata _values,\\n        uint16[] calldata _periods\\n    )\\n        external\\n    {\\n        uint256 subStakesLength = _values.length;\\n        require(_stakers.length != 0 &&\\n            _stakers.length == _numberOfSubStakes.length &&\\n            subStakesLength >= _stakers.length &&\\n            _periods.length == subStakesLength);\\n        uint16 previousPeriod = getCurrentPeriod() - 1;\\n        uint16 nextPeriod = previousPeriod + 2;\\n        uint256 sumValue = 0;\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < _stakers.length; i++) {\\n            address staker = _stakers[i];\\n            uint256 numberOfSubStakes = _numberOfSubStakes[i];\\n            uint256 endIndex = j + numberOfSubStakes;\\n            require(numberOfSubStakes > 0 && subStakesLength >= endIndex);\\n            StakerInfo storage info = stakerInfo[staker];\\n            require(info.subStakes.length == 0 && !info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX));\\n            // A staker can't be a worker for another staker\\n            require(stakerFromWorker[staker] == address(0));\\n            stakers.push(staker);\\n            policyManager.register(staker, previousPeriod);\\n\\n            for (; j < endIndex; j++) {\\n                uint256 value =  _values[j];\\n                uint16 periods = _periods[j];\\n                require(value >= minAllowableLockedTokens && periods >= minLockedPeriods);\\n                info.value = info.value.add(value);\\n                info.subStakes.push(SubStakeInfo(nextPeriod, 0, periods, uint128(value)));\\n                sumValue = sumValue.add(value);\\n                emit Deposited(staker, value, periods);\\n                emit Locked(staker, value, nextPeriod, periods);\\n            }\\n            require(info.value <= maxAllowableLockedTokens);\\n            info.history.addSnapshot(info.value);\\n        }\\n        require(j == subStakesLength);\\n        uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());\\n        balanceHistory.addSnapshot(lastGlobalBalance + sumValue);\\n        token.safeTransferFrom(msg.sender, address(this), sumValue);\\n    }\\n\\n    /**\\n    * @notice Implementation of the receiveApproval(address,uint256,address,bytes) method\\n    * (see NuCypherToken contract). Deposit all tokens that were approved to transfer\\n    * @param _from Staker\\n    * @param _value Amount of tokens to deposit\\n    * @param _tokenContract Token contract address\\n    * @notice (param _extraData) Amount of periods during which tokens will be locked\\n    */\\n    function receiveApproval(\\n        address _from,\\n        uint256 _value,\\n        address _tokenContract,\\n        bytes calldata /* _extraData */\\n    )\\n        external\\n    {\\n        require(_tokenContract == address(token) && msg.sender == address(token));\\n\\n        // Copy first 32 bytes from _extraData, according to calldata memory layout:\\n        //\\n        // 0x00: method signature      4 bytes\\n        // 0x04: _from                 32 bytes after encoding\\n        // 0x24: _value                32 bytes after encoding\\n        // 0x44: _tokenContract        32 bytes after encoding\\n        // 0x64: _extraData pointer    32 bytes. Value must be 0x80 (offset of _extraData wrt to 1st parameter)\\n        // 0x84: _extraData length     32 bytes\\n        // 0xA4: _extraData data       Length determined by previous variable\\n        //\\n        // See https://solidity.readthedocs.io/en/latest/abi-spec.html#examples\\n\\n        uint256 payloadSize;\\n        uint256 payload;\\n        assembly {\\n            payloadSize := calldataload(0x84)\\n            payload := calldataload(0xA4)\\n        }\\n        payload = payload >> 8*(32 - payloadSize);\\n        deposit(_from, _from, MAX_SUB_STAKES, _value, uint16(payload));\\n    }\\n\\n    /**\\n    * @notice Deposit tokens and create new sub-stake. Use this method to become a staker\\n    * @param _staker Staker\\n    * @param _value Amount of tokens to deposit\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function deposit(address _staker, uint256 _value, uint16 _periods) external {\\n        deposit(_staker, msg.sender, MAX_SUB_STAKES, _value, _periods);\\n    }\\n\\n    /**\\n    * @notice Deposit tokens and increase lock amount of an existing sub-stake\\n    * @dev This is preferable way to stake tokens because will be fewer active sub-stakes in the result\\n    * @param _index Index of the sub stake\\n    * @param _value Amount of tokens which will be locked\\n    */\\n    function depositAndIncrease(uint256 _index, uint256 _value) external onlyStaker {\\n        require(_index < MAX_SUB_STAKES);\\n        deposit(msg.sender, msg.sender, _index, _value, 0);\\n    }\\n\\n    /**\\n    * @notice Deposit tokens\\n    * @dev Specify either index and zero periods (for an existing sub-stake)\\n    * or index >= MAX_SUB_STAKES and real value for periods (for a new sub-stake), not both\\n    * @param _staker Staker\\n    * @param _payer Owner of tokens\\n    * @param _index Index of the sub stake\\n    * @param _value Amount of tokens to deposit\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function deposit(address _staker, address _payer, uint256 _index, uint256 _value, uint16 _periods) internal {\\n        require(_value != 0);\\n        StakerInfo storage info = stakerInfo[_staker];\\n        // A staker can't be a worker for another staker\\n        require(stakerFromWorker[_staker] == address(0) || stakerFromWorker[_staker] == info.worker);\\n        // initial stake of the staker\\n        if (info.subStakes.length == 0) {\\n            stakers.push(_staker);\\n            policyManager.register(_staker, getCurrentPeriod() - 1);\\n        }\\n        token.safeTransferFrom(_payer, address(this), _value);\\n        info.value += _value;\\n        lock(_staker, _index, _value, _periods);\\n\\n        addSnapshot(info, int256(_value));\\n        if (_index >= MAX_SUB_STAKES) {\\n            emit Deposited(_staker, _value, _periods);\\n        } else {\\n            uint16 lastPeriod = getLastPeriodOfSubStake(_staker, _index);\\n            emit Deposited(_staker, _value, lastPeriod - getCurrentPeriod());\\n        }\\n    }\\n\\n    /**\\n    * @notice Lock some tokens as a new sub-stake\\n    * @param _value Amount of tokens which will be locked\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function lockAndCreate(uint256 _value, uint16 _periods) external onlyStaker {\\n        lock(msg.sender, MAX_SUB_STAKES, _value, _periods);\\n    }\\n\\n    /**\\n    * @notice Increase lock amount of an existing sub-stake\\n    * @param _index Index of the sub-stake\\n    * @param _value Amount of tokens which will be locked\\n    */\\n    function lockAndIncrease(uint256 _index, uint256 _value) external onlyStaker {\\n        require(_index < MAX_SUB_STAKES);\\n        lock(msg.sender, _index, _value, 0);\\n    }\\n\\n    /**\\n    * @notice Lock some tokens as a stake\\n    * @dev Specify either index and zero periods (for an existing sub-stake)\\n    * or index >= MAX_SUB_STAKES and real value for periods (for a new sub-stake), not both\\n    * @param _staker Staker\\n    * @param _index Index of the sub stake\\n    * @param _value Amount of tokens which will be locked\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function lock(address _staker, uint256 _index, uint256 _value, uint16 _periods) internal {\\n        if (_index < MAX_SUB_STAKES) {\\n            require(_value > 0);\\n        } else {\\n            require(_value >= minAllowableLockedTokens && _periods >= minLockedPeriods);\\n        }\\n\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod + 1;\\n        StakerInfo storage info = stakerInfo[_staker];\\n        uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);\\n        uint256 requestedLockedTokens = _value.add(lockedTokens);\\n        require(requestedLockedTokens <= info.value && requestedLockedTokens <= maxAllowableLockedTokens);\\n\\n        // next period is committed\\n        if (info.nextCommittedPeriod == nextPeriod) {\\n            lockedPerPeriod[nextPeriod] += _value;\\n            emit CommitmentMade(_staker, nextPeriod, _value);\\n        }\\n\\n        // if index was provided then increase existing sub-stake\\n        if (_index < MAX_SUB_STAKES) {\\n            lockAndIncrease(info, currentPeriod, nextPeriod, _staker, _index, _value);\\n        // otherwise create new\\n        } else {\\n            lockAndCreate(info, nextPeriod, _staker, _value, _periods);\\n        }\\n    }\\n\\n    /**\\n    * @notice Lock some tokens as a new sub-stake\\n    * @param _info Staker structure\\n    * @param _nextPeriod Next period\\n    * @param _staker Staker\\n    * @param _value Amount of tokens which will be locked\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function lockAndCreate(\\n        StakerInfo storage _info,\\n        uint16 _nextPeriod,\\n        address _staker,\\n        uint256 _value,\\n        uint16 _periods\\n    )\\n        internal\\n    {\\n        uint16 duration = _periods;\\n        // if winding down is enabled and next period is committed\\n        // then sub-stakes duration were decreased\\n        if (_info.nextCommittedPeriod == _nextPeriod && _info.flags.bitSet(WIND_DOWN_INDEX)) {\\n            duration -= 1;\\n        }\\n        saveSubStake(_info, _nextPeriod, 0, duration, _value);\\n\\n        emit Locked(_staker, _value, _nextPeriod, _periods);\\n    }\\n\\n    /**\\n    * @notice Increase lock amount of an existing sub-stake\\n    * @dev Probably will be created a new sub-stake but it will be active only one period\\n    * @param _info Staker structure\\n    * @param _currentPeriod Current period\\n    * @param _nextPeriod Next period\\n    * @param _staker Staker\\n    * @param _index Index of the sub-stake\\n    * @param _value Amount of tokens which will be locked\\n    */\\n    function lockAndIncrease(\\n        StakerInfo storage _info,\\n        uint16 _currentPeriod,\\n        uint16 _nextPeriod,\\n        address _staker,\\n        uint256 _index,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        SubStakeInfo storage subStake = _info.subStakes[_index];\\n        (, uint16 lastPeriod) = checkLastPeriodOfSubStake(_info, subStake, _currentPeriod);\\n\\n        // create temporary sub-stake for current or previous committed periods\\n        // to leave locked amount in this period unchanged\\n        if (_info.currentCommittedPeriod != 0 &&\\n            _info.currentCommittedPeriod <= _currentPeriod ||\\n            _info.nextCommittedPeriod != 0 &&\\n            _info.nextCommittedPeriod <= _currentPeriod)\\n        {\\n            saveSubStake(_info, subStake.firstPeriod, _currentPeriod, 0, subStake.lockedValue);\\n        }\\n\\n        subStake.lockedValue += uint128(_value);\\n        // all new locks should start from the next period\\n        subStake.firstPeriod = _nextPeriod;\\n\\n        emit Locked(_staker, _value, _nextPeriod, lastPeriod - _currentPeriod);\\n    }\\n\\n    /**\\n    * @notice Checks that last period of sub-stake is greater than the current period\\n    * @param _info Staker structure\\n    * @param _subStake Sub-stake structure\\n    * @param _currentPeriod Current period\\n    * @return startPeriod Start period. Use in the calculation of the last period of the sub stake\\n    * @return lastPeriod Last period of the sub stake\\n    */\\n    function checkLastPeriodOfSubStake(\\n        StakerInfo storage _info,\\n        SubStakeInfo storage _subStake,\\n        uint16 _currentPeriod\\n    )\\n        internal view returns (uint16 startPeriod, uint16 lastPeriod)\\n    {\\n        startPeriod = getStartPeriod(_info, _currentPeriod);\\n        lastPeriod = getLastPeriodOfSubStake(_subStake, startPeriod);\\n        // The sub stake must be active at least in the next period\\n        require(lastPeriod > _currentPeriod);\\n    }\\n\\n    /**\\n    * @notice Save sub stake. First tries to override inactive sub stake\\n    * @dev Inactive sub stake means that last period of sub stake has been surpassed and already rewarded\\n    * @param _info Staker structure\\n    * @param _firstPeriod First period of the sub stake\\n    * @param _lastPeriod Last period of the sub stake\\n    * @param _periods Duration of the sub stake in periods\\n    * @param _lockedValue Amount of locked tokens\\n    */\\n    function saveSubStake(\\n        StakerInfo storage _info,\\n        uint16 _firstPeriod,\\n        uint16 _lastPeriod,\\n        uint16 _periods,\\n        uint256 _lockedValue\\n    )\\n        internal\\n    {\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake = _info.subStakes[i];\\n            if (subStake.lastPeriod != 0 &&\\n                (_info.currentCommittedPeriod == 0 ||\\n                subStake.lastPeriod < _info.currentCommittedPeriod) &&\\n                (_info.nextCommittedPeriod == 0 ||\\n                subStake.lastPeriod < _info.nextCommittedPeriod))\\n            {\\n                subStake.firstPeriod = _firstPeriod;\\n                subStake.lastPeriod = _lastPeriod;\\n                subStake.periods = _periods;\\n                subStake.lockedValue = uint128(_lockedValue);\\n                return;\\n            }\\n        }\\n        require(_info.subStakes.length < MAX_SUB_STAKES);\\n        _info.subStakes.push(SubStakeInfo(_firstPeriod, _lastPeriod, _periods, uint128(_lockedValue)));\\n    }\\n\\n    /**\\n    * @notice Divide sub stake into two parts\\n    * @param _index Index of the sub stake\\n    * @param _newValue New sub stake value\\n    * @param _periods Amount of periods for extending sub stake\\n    */\\n    function divideStake(uint256 _index, uint256 _newValue, uint16 _periods) external onlyStaker {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        require(_newValue >= minAllowableLockedTokens && _periods > 0);\\n        SubStakeInfo storage subStake = info.subStakes[_index];\\n        uint16 currentPeriod = getCurrentPeriod();\\n        (, uint16 lastPeriod) = checkLastPeriodOfSubStake(info, subStake, currentPeriod);\\n\\n        uint256 oldValue = subStake.lockedValue;\\n        subStake.lockedValue = uint128(oldValue.sub(_newValue));\\n        require(subStake.lockedValue >= minAllowableLockedTokens);\\n        uint16 requestedPeriods = subStake.periods.add16(_periods);\\n        saveSubStake(info, subStake.firstPeriod, 0, requestedPeriods, _newValue);\\n        emit Divided(msg.sender, oldValue, lastPeriod, _newValue, _periods);\\n        emit Locked(msg.sender, _newValue, subStake.firstPeriod, requestedPeriods);\\n    }\\n\\n    /**\\n    * @notice Prolong active sub stake\\n    * @param _index Index of the sub stake\\n    * @param _periods Amount of periods for extending sub stake\\n    */\\n    function prolongStake(uint256 _index, uint16 _periods) external onlyStaker {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        // Incorrect parameters\\n        require(_periods > 0);\\n        SubStakeInfo storage subStake = info.subStakes[_index];\\n        uint16 currentPeriod = getCurrentPeriod();\\n        (uint16 startPeriod, uint16 lastPeriod) = checkLastPeriodOfSubStake(info, subStake, currentPeriod);\\n\\n        subStake.periods = subStake.periods.add16(_periods);\\n        // if the sub stake ends in the next committed period then reset the `lastPeriod` field\\n        if (lastPeriod == startPeriod) {\\n            subStake.lastPeriod = 0;\\n        }\\n        // The extended sub stake must not be less than the minimum value\\n        require(uint32(lastPeriod - currentPeriod) + _periods >= minLockedPeriods);\\n        emit Locked(msg.sender, subStake.lockedValue, lastPeriod + 1, _periods);\\n        emit Prolonged(msg.sender, subStake.lockedValue, lastPeriod, _periods);\\n    }\\n\\n    /**\\n    * @notice Merge two sub-stakes into one if their last periods are equal\\n    * @dev It's possible that both sub-stakes will be active after this transaction.\\n    * But only one of them will be active until next call `commitToNextPeriod` (in the next period)\\n    * @param _index1 Index of the first sub-stake\\n    * @param _index2 Index of the second sub-stake\\n    */\\n    function mergeStake(uint256 _index1, uint256 _index2) external onlyStaker {\\n        require(_index1 != _index2); // must be different sub-stakes\\n\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        SubStakeInfo storage subStake1 = info.subStakes[_index1];\\n        SubStakeInfo storage subStake2 = info.subStakes[_index2];\\n        uint16 currentPeriod = getCurrentPeriod();\\n\\n        (, uint16 lastPeriod1) = checkLastPeriodOfSubStake(info, subStake1, currentPeriod);\\n        (, uint16 lastPeriod2) = checkLastPeriodOfSubStake(info, subStake2, currentPeriod);\\n        // both sub-stakes must have equal last period to be mergeable\\n        require(lastPeriod1 == lastPeriod2);\\n        emit Merged(msg.sender, subStake1.lockedValue, subStake2.lockedValue, lastPeriod1);\\n\\n        if (subStake1.firstPeriod == subStake2.firstPeriod) {\\n            subStake1.lockedValue += subStake2.lockedValue;\\n            subStake2.lastPeriod = 1;\\n            subStake2.periods = 0;\\n        } else if (subStake1.firstPeriod > subStake2.firstPeriod) {\\n            subStake1.lockedValue += subStake2.lockedValue;\\n            subStake2.lastPeriod = subStake1.firstPeriod - 1;\\n            subStake2.periods = 0;\\n        } else {\\n            subStake2.lockedValue += subStake1.lockedValue;\\n            subStake1.lastPeriod = subStake2.firstPeriod - 1;\\n            subStake1.periods = 0;\\n        }\\n    }\\n\\n    /**\\n    * @notice Withdraw available amount of tokens to staker\\n    * @param _value Amount of tokens to withdraw\\n    */\\n    function withdraw(uint256 _value) external onlyStaker {\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod + 1;\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        // the max locked tokens in most cases will be in the current period\\n        // but when the staker locks more then we should use the next period\\n        uint256 lockedTokens = Math.max(getLockedTokens(info, currentPeriod, nextPeriod),\\n            getLockedTokens(info, currentPeriod, currentPeriod));\\n        require(_value <= info.value.sub(lockedTokens));\\n        info.value -= _value;\\n\\n        addSnapshot(info, - int256(_value));\\n        token.safeTransfer(msg.sender, _value);\\n        emit Withdrawn(msg.sender, _value);\\n\\n        // unbond worker if staker withdraws last portion of NU\\n        if (info.value == 0 &&\\n            info.nextCommittedPeriod == 0 &&\\n            info.worker != address(0))\\n        {\\n            stakerFromWorker[info.worker] = address(0);\\n            info.worker = address(0);\\n            emit WorkerBonded(msg.sender, address(0), currentPeriod);\\n        }\\n    }\\n\\n    /**\\n    * @notice Make a commitment to the next period and mint for the previous period\\n    */\\n    function commitToNextPeriod() external isInitialized {\\n        address staker = stakerFromWorker[msg.sender];\\n        StakerInfo storage info = stakerInfo[staker];\\n        // Staker must have a stake to make a commitment\\n        require(info.value > 0);\\n        // Only worker with real address can make a commitment\\n        require(msg.sender == tx.origin);\\n\\n        uint16 lastCommittedPeriod = getLastCommittedPeriod(staker);\\n        (uint16 processedPeriod1, uint16 processedPeriod2) = mint(staker);\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod + 1;\\n\\n        // the period has already been committed\\n        if (info.nextCommittedPeriod == nextPeriod) {\\n            return;\\n        }\\n\\n        uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);\\n        require(lockedTokens > 0);\\n        lockedPerPeriod[nextPeriod] += lockedTokens;\\n\\n        info.currentCommittedPeriod = info.nextCommittedPeriod;\\n        info.nextCommittedPeriod = nextPeriod;\\n\\n        decreaseSubStakesDuration(info, nextPeriod);\\n\\n        // staker was inactive for several periods\\n        if (lastCommittedPeriod < currentPeriod) {\\n            info.pastDowntime.push(Downtime(lastCommittedPeriod + 1, currentPeriod));\\n        }\\n\\n        policyManager.ping(staker, processedPeriod1, processedPeriod2, nextPeriod);\\n        emit CommitmentMade(staker, nextPeriod, lockedTokens);\\n    }\\n\\n    /**\\n    * @notice Decrease sub-stakes duration if `windDown` is enabled\\n    */\\n    function decreaseSubStakesDuration(StakerInfo storage _info, uint16 _nextPeriod) internal {\\n        if (!_info.flags.bitSet(WIND_DOWN_INDEX)) {\\n            return;\\n        }\\n        for (uint256 index = 0; index < _info.subStakes.length; index++) {\\n            SubStakeInfo storage subStake = _info.subStakes[index];\\n            if (subStake.lastPeriod != 0 || subStake.periods == 0) {\\n                continue;\\n            }\\n            subStake.periods--;\\n            if (subStake.periods == 0) {\\n                subStake.lastPeriod = _nextPeriod;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Mint tokens for previous periods if staker locked their tokens and made a commitment\\n    */\\n    function mint() external onlyStaker {\\n        // save last committed period to the storage if both periods will be empty after minting\\n        // because we won't be able to calculate last committed period\\n        // see getLastCommittedPeriod(address)\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        uint16 previousPeriod = getCurrentPeriod() - 1;\\n        if (info.nextCommittedPeriod <= previousPeriod && info.nextCommittedPeriod != 0) {\\n            info.lastCommittedPeriod = info.nextCommittedPeriod;\\n        }\\n        (uint16 processedPeriod1, uint16 processedPeriod2) = mint(msg.sender);\\n\\n        if (processedPeriod1 != 0 || processedPeriod2 != 0) {\\n            policyManager.ping(msg.sender, processedPeriod1, processedPeriod2, 0);\\n        }\\n    }\\n\\n    /**\\n    * @notice Mint tokens for previous periods if staker locked their tokens and made a commitment\\n    * @param _staker Staker\\n    * @return processedPeriod1 Processed period: currentCommittedPeriod or zero\\n    * @return processedPeriod2 Processed period: nextCommittedPeriod or zero\\n    */\\n    function mint(address _staker) internal returns (uint16 processedPeriod1, uint16 processedPeriod2) {\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 previousPeriod = currentPeriod - 1;\\n        StakerInfo storage info = stakerInfo[_staker];\\n\\n        if (info.nextCommittedPeriod == 0 ||\\n            info.currentCommittedPeriod == 0 &&\\n            info.nextCommittedPeriod > previousPeriod ||\\n            info.currentCommittedPeriod > previousPeriod) {\\n            return (0, 0);\\n        }\\n\\n        uint16 startPeriod = getStartPeriod(info, currentPeriod);\\n        uint256 reward = 0;\\n        bool reStake = !info.flags.bitSet(RE_STAKE_DISABLED_INDEX);\\n\\n        if (info.currentCommittedPeriod != 0) {\\n            reward = mint(info, info.currentCommittedPeriod, currentPeriod, startPeriod, reStake);\\n            processedPeriod1 = info.currentCommittedPeriod;\\n            info.currentCommittedPeriod = 0;\\n            if (reStake) {\\n                lockedPerPeriod[info.nextCommittedPeriod] += reward;\\n            }\\n        }\\n        if (info.nextCommittedPeriod <= previousPeriod) {\\n            reward += mint(info, info.nextCommittedPeriod, currentPeriod, startPeriod, reStake);\\n            processedPeriod2 = info.nextCommittedPeriod;\\n            info.nextCommittedPeriod = 0;\\n        }\\n\\n        info.value += reward;\\n        if (info.flags.bitSet(MEASURE_WORK_INDEX)) {\\n            info.completedWork += reward;\\n        }\\n\\n        addSnapshot(info, int256(reward));\\n        emit Minted(_staker, previousPeriod, reward);\\n    }\\n\\n    /**\\n    * @notice Calculate reward for one period\\n    * @param _info Staker structure\\n    * @param _mintingPeriod Period for minting calculation\\n    * @param _currentPeriod Current period\\n    * @param _startPeriod Pre-calculated start period\\n    */\\n    function mint(\\n        StakerInfo storage _info,\\n        uint16 _mintingPeriod,\\n        uint16 _currentPeriod,\\n        uint16 _startPeriod,\\n        bool _reStake\\n    )\\n        internal returns (uint256 reward)\\n    {\\n        reward = 0;\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake =  _info.subStakes[i];\\n            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);\\n            if (subStake.firstPeriod <= _mintingPeriod && lastPeriod >= _mintingPeriod) {\\n                uint256 subStakeReward = mint(\\n                    _currentPeriod,\\n                    subStake.lockedValue,\\n                    lockedPerPeriod[_mintingPeriod],\\n                    lastPeriod.sub16(_mintingPeriod));\\n                reward += subStakeReward;\\n                if (_reStake) {\\n                    subStake.lockedValue += uint128(subStakeReward);\\n                }\\n            }\\n        }\\n        return reward;\\n    }\\n\\n    //-------------------------Slashing-------------------------\\n    /**\\n    * @notice Slash the staker's stake and reward the investigator\\n    * @param _staker Staker's address\\n    * @param _penalty Penalty\\n    * @param _investigator Investigator\\n    * @param _reward Reward for the investigator\\n    */\\n    function slashStaker(\\n        address _staker,\\n        uint256 _penalty,\\n        address _investigator,\\n        uint256 _reward\\n    )\\n        public isInitialized\\n    {\\n        require(msg.sender == address(adjudicator));\\n        require(_penalty > 0);\\n        StakerInfo storage info = stakerInfo[_staker];\\n        if (info.value <= _penalty) {\\n            _penalty = info.value;\\n        }\\n        info.value -= _penalty;\\n        if (_reward > _penalty) {\\n            _reward = _penalty;\\n        }\\n\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod + 1;\\n        uint16 startPeriod = getStartPeriod(info, currentPeriod);\\n\\n        (uint256 currentLock, uint256 nextLock, uint256 currentAndNextLock, uint256 shortestSubStakeIndex) =\\n            getLockedTokensAndShortestSubStake(info, currentPeriod, nextPeriod, startPeriod);\\n\\n        // Decrease the stake if amount of locked tokens in the current period more than staker has\\n        uint256 lockedTokens = currentLock + currentAndNextLock;\\n        if (info.value < lockedTokens) {\\n           decreaseSubStakes(info, lockedTokens - info.value, currentPeriod, startPeriod, shortestSubStakeIndex);\\n        }\\n        // Decrease the stake if amount of locked tokens in the next period more than staker has\\n        if (nextLock > 0) {\\n            lockedTokens = nextLock + currentAndNextLock -\\n                (currentAndNextLock > info.value ? currentAndNextLock - info.value : 0);\\n            if (info.value < lockedTokens) {\\n               decreaseSubStakes(info, lockedTokens - info.value, nextPeriod, startPeriod, MAX_SUB_STAKES);\\n            }\\n        }\\n\\n        emit Slashed(_staker, _penalty, _investigator, _reward);\\n        if (_penalty > _reward) {\\n            unMint(_penalty - _reward);\\n        }\\n        // TODO change to withdrawal pattern (#1499)\\n        if (_reward > 0) {\\n            token.safeTransfer(_investigator, _reward);\\n        }\\n\\n        addSnapshot(info, - int256(_penalty));\\n\\n    }\\n\\n    /**\\n    * @notice Get the value of locked tokens for a staker in the current and the next period\\n    * and find the shortest sub stake\\n    * @param _info Staker structure\\n    * @param _currentPeriod Current period\\n    * @param _nextPeriod Next period\\n    * @param _startPeriod Pre-calculated start period\\n    * @return currentLock Amount of tokens that locked in the current period and unlocked in the next period\\n    * @return nextLock Amount of tokens that locked in the next period and not locked in the current period\\n    * @return currentAndNextLock Amount of tokens that locked in the current period and in the next period\\n    * @return shortestSubStakeIndex Index of the shortest sub stake\\n    */\\n    function getLockedTokensAndShortestSubStake(\\n        StakerInfo storage _info,\\n        uint16 _currentPeriod,\\n        uint16 _nextPeriod,\\n        uint16 _startPeriod\\n    )\\n        internal view returns (\\n            uint256 currentLock,\\n            uint256 nextLock,\\n            uint256 currentAndNextLock,\\n            uint256 shortestSubStakeIndex\\n        )\\n    {\\n        uint16 minDuration = MAX_UINT16;\\n        uint16 minLastPeriod = MAX_UINT16;\\n        shortestSubStakeIndex = MAX_SUB_STAKES;\\n        currentLock = 0;\\n        nextLock = 0;\\n        currentAndNextLock = 0;\\n\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake = _info.subStakes[i];\\n            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);\\n            if (lastPeriod < subStake.firstPeriod) {\\n                continue;\\n            }\\n            if (subStake.firstPeriod <= _currentPeriod &&\\n                lastPeriod >= _nextPeriod) {\\n                currentAndNextLock += subStake.lockedValue;\\n            } else if (subStake.firstPeriod <= _currentPeriod &&\\n                lastPeriod >= _currentPeriod) {\\n                currentLock += subStake.lockedValue;\\n            } else if (subStake.firstPeriod <= _nextPeriod &&\\n                lastPeriod >= _nextPeriod) {\\n                nextLock += subStake.lockedValue;\\n            }\\n            uint16 duration = lastPeriod - subStake.firstPeriod;\\n            if (subStake.firstPeriod <= _currentPeriod &&\\n                lastPeriod >= _currentPeriod &&\\n                (lastPeriod < minLastPeriod ||\\n                lastPeriod == minLastPeriod && duration < minDuration))\\n            {\\n                shortestSubStakeIndex = i;\\n                minDuration = duration;\\n                minLastPeriod = lastPeriod;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Decrease short sub stakes\\n    * @param _info Staker structure\\n    * @param _penalty Penalty rate\\n    * @param _decreasePeriod The period when the decrease begins\\n    * @param _startPeriod Pre-calculated start period\\n    * @param _shortestSubStakeIndex Index of the shortest period\\n    */\\n    function decreaseSubStakes(\\n        StakerInfo storage _info,\\n        uint256 _penalty,\\n        uint16 _decreasePeriod,\\n        uint16 _startPeriod,\\n        uint256 _shortestSubStakeIndex\\n    )\\n        internal\\n    {\\n        SubStakeInfo storage shortestSubStake = _info.subStakes[0];\\n        uint16 minSubStakeLastPeriod = MAX_UINT16;\\n        uint16 minSubStakeDuration = MAX_UINT16;\\n        while(_penalty > 0) {\\n            if (_shortestSubStakeIndex < MAX_SUB_STAKES) {\\n                shortestSubStake = _info.subStakes[_shortestSubStakeIndex];\\n                minSubStakeLastPeriod = getLastPeriodOfSubStake(shortestSubStake, _startPeriod);\\n                minSubStakeDuration = minSubStakeLastPeriod - shortestSubStake.firstPeriod;\\n                _shortestSubStakeIndex = MAX_SUB_STAKES;\\n            } else {\\n                (shortestSubStake, minSubStakeDuration, minSubStakeLastPeriod) =\\n                    getShortestSubStake(_info, _decreasePeriod, _startPeriod);\\n            }\\n            if (minSubStakeDuration == MAX_UINT16) {\\n                break;\\n            }\\n            uint256 appliedPenalty = _penalty;\\n            if (_penalty < shortestSubStake.lockedValue) {\\n                shortestSubStake.lockedValue -= uint128(_penalty);\\n                saveOldSubStake(_info, shortestSubStake.firstPeriod, _penalty, _decreasePeriod);\\n                _penalty = 0;\\n            } else {\\n                shortestSubStake.lastPeriod = _decreasePeriod - 1;\\n                _penalty -= shortestSubStake.lockedValue;\\n                appliedPenalty = shortestSubStake.lockedValue;\\n            }\\n            if (_info.currentCommittedPeriod >= _decreasePeriod &&\\n                _info.currentCommittedPeriod <= minSubStakeLastPeriod)\\n            {\\n                lockedPerPeriod[_info.currentCommittedPeriod] -= appliedPenalty;\\n            }\\n            if (_info.nextCommittedPeriod >= _decreasePeriod &&\\n                _info.nextCommittedPeriod <= minSubStakeLastPeriod)\\n            {\\n                lockedPerPeriod[_info.nextCommittedPeriod] -= appliedPenalty;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Get the shortest sub stake\\n    * @param _info Staker structure\\n    * @param _currentPeriod Current period\\n    * @param _startPeriod Pre-calculated start period\\n    * @return shortestSubStake The shortest sub stake\\n    * @return minSubStakeDuration Duration of the shortest sub stake\\n    * @return minSubStakeLastPeriod Last period of the shortest sub stake\\n    */\\n    function getShortestSubStake(\\n        StakerInfo storage _info,\\n        uint16 _currentPeriod,\\n        uint16 _startPeriod\\n    )\\n        internal view returns (\\n            SubStakeInfo storage shortestSubStake,\\n            uint16 minSubStakeDuration,\\n            uint16 minSubStakeLastPeriod\\n        )\\n    {\\n        shortestSubStake = shortestSubStake;\\n        minSubStakeDuration = MAX_UINT16;\\n        minSubStakeLastPeriod = MAX_UINT16;\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake = _info.subStakes[i];\\n            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);\\n            if (lastPeriod < subStake.firstPeriod) {\\n                continue;\\n            }\\n            uint16 duration = lastPeriod - subStake.firstPeriod;\\n            if (subStake.firstPeriod <= _currentPeriod &&\\n                lastPeriod >= _currentPeriod &&\\n                (lastPeriod < minSubStakeLastPeriod ||\\n                lastPeriod == minSubStakeLastPeriod && duration < minSubStakeDuration))\\n            {\\n                shortestSubStake = subStake;\\n                minSubStakeDuration = duration;\\n                minSubStakeLastPeriod = lastPeriod;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Save the old sub stake values to prevent decreasing reward for the previous period\\n    * @dev Saving happens only if the previous period is committed\\n    * @param _info Staker structure\\n    * @param _firstPeriod First period of the old sub stake\\n    * @param _lockedValue Locked value of the old sub stake\\n    * @param _currentPeriod Current period, when the old sub stake is already unlocked\\n    */\\n    function saveOldSubStake(\\n        StakerInfo storage _info,\\n        uint16 _firstPeriod,\\n        uint256 _lockedValue,\\n        uint16 _currentPeriod\\n    )\\n        internal\\n    {\\n        // Check that the old sub stake should be saved\\n        bool oldCurrentCommittedPeriod = _info.currentCommittedPeriod != 0 &&\\n            _info.currentCommittedPeriod < _currentPeriod;\\n        bool oldnextCommittedPeriod = _info.nextCommittedPeriod != 0 &&\\n            _info.nextCommittedPeriod < _currentPeriod;\\n        bool crosscurrentCommittedPeriod = oldCurrentCommittedPeriod && _info.currentCommittedPeriod >= _firstPeriod;\\n        bool crossnextCommittedPeriod = oldnextCommittedPeriod && _info.nextCommittedPeriod >= _firstPeriod;\\n        if (!crosscurrentCommittedPeriod && !crossnextCommittedPeriod) {\\n            return;\\n        }\\n        // Try to find already existent proper old sub stake\\n        uint16 previousPeriod = _currentPeriod - 1;\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake = _info.subStakes[i];\\n            if (subStake.lastPeriod == previousPeriod &&\\n                ((crosscurrentCommittedPeriod ==\\n                (oldCurrentCommittedPeriod && _info.currentCommittedPeriod >= subStake.firstPeriod)) &&\\n                (crossnextCommittedPeriod ==\\n                (oldnextCommittedPeriod && _info.nextCommittedPeriod >= subStake.firstPeriod))))\\n            {\\n                subStake.lockedValue += uint128(_lockedValue);\\n                return;\\n            }\\n        }\\n        saveSubStake(_info, _firstPeriod, previousPeriod, 0, _lockedValue);\\n    }\\n\\n    //-------------Additional getters for stakers info-------------\\n    /**\\n    * @notice Return the length of the array of stakers\\n    */\\n    function getStakersLength() external view returns (uint256) {\\n        return stakers.length;\\n    }\\n\\n    /**\\n    * @notice Return the length of the array of sub stakes\\n    */\\n    function getSubStakesLength(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].subStakes.length;\\n    }\\n\\n    /**\\n    * @notice Return the information about sub stake\\n    */\\n    function getSubStakeInfo(address _staker, uint256 _index)\\n    // TODO change to structure when ABIEncoderV2 is released (#1501)\\n//        public view returns (SubStakeInfo)\\n        // TODO \\\"virtual\\\" only for tests, probably will be removed after #1512\\n        external view virtual returns (uint16 firstPeriod, uint16 lastPeriod, uint16 periods, uint128 lockedValue)\\n    {\\n        SubStakeInfo storage info = stakerInfo[_staker].subStakes[_index];\\n        firstPeriod = info.firstPeriod;\\n        lastPeriod = info.lastPeriod;\\n        periods = info.periods;\\n        lockedValue = info.lockedValue;\\n    }\\n\\n    /**\\n    * @notice Return the length of the array of past downtime\\n    */\\n    function getPastDowntimeLength(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].pastDowntime.length;\\n    }\\n\\n    /**\\n    * @notice Return the information about past downtime\\n    */\\n    function  getPastDowntime(address _staker, uint256 _index)\\n    // TODO change to structure when ABIEncoderV2 is released (#1501)\\n//        public view returns (Downtime)\\n        external view returns (uint16 startPeriod, uint16 endPeriod)\\n    {\\n        Downtime storage downtime = stakerInfo[_staker].pastDowntime[_index];\\n        startPeriod = downtime.startPeriod;\\n        endPeriod = downtime.endPeriod;\\n    }\\n\\n    //------------------ ERC900 connectors ----------------------\\n\\n    function totalStakedForAt(address _owner, uint256 _blockNumber) public view override returns (uint256){\\n        return stakerInfo[_owner].history.getValueAt(_blockNumber);\\n    }\\n\\n    function totalStakedAt(uint256 _blockNumber) public view override returns (uint256){\\n        return balanceHistory.getValueAt(_blockNumber);\\n    }\\n\\n    function supportsHistory() external pure override returns (bool){\\n        return true;\\n    }\\n\\n    //------------------------Upgradeable------------------------\\n    /**\\n    * @dev Get StakerInfo structure by delegatecall\\n    */\\n    function delegateGetStakerInfo(address _target, bytes32 _staker)\\n        internal returns (StakerInfo memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, this.stakerInfo.selector, 1, _staker, 0);\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /**\\n    * @dev Get SubStakeInfo structure by delegatecall\\n    */\\n    function delegateGetSubStakeInfo(address _target, bytes32 _staker, uint256 _index)\\n        internal returns (SubStakeInfo memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(\\n            _target, this.getSubStakeInfo.selector, 2, _staker, bytes32(_index));\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /**\\n    * @dev Get Downtime structure by delegatecall\\n    */\\n    function delegateGetPastDowntime(address _target, bytes32 _staker, uint256 _index)\\n        internal returns (Downtime memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(\\n            _target, this.getPastDowntime.selector, 2, _staker, bytes32(_index));\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n        require(address(delegateGet(_testTarget, this.policyManager.selector)) == address(policyManager));\\n        require(address(delegateGet(_testTarget, this.adjudicator.selector)) == address(adjudicator));\\n        require(address(delegateGet(_testTarget, this.workLock.selector)) == address(workLock));\\n        require(delegateGet(_testTarget, this.lockedPerPeriod.selector,\\n            bytes32(bytes2(RESERVED_PERIOD))) == lockedPerPeriod[RESERVED_PERIOD]);\\n        require(address(delegateGet(_testTarget, this.stakerFromWorker.selector, bytes32(0))) ==\\n            stakerFromWorker[address(0)]);\\n\\n        require(delegateGet(_testTarget, this.getStakersLength.selector) == stakers.length);\\n        if (stakers.length == 0) {\\n            return;\\n        }\\n        address stakerAddress = stakers[0];\\n        require(address(uint160(delegateGet(_testTarget, this.stakers.selector, 0))) == stakerAddress);\\n        StakerInfo storage info = stakerInfo[stakerAddress];\\n        bytes32 staker = bytes32(uint256(stakerAddress));\\n        StakerInfo memory infoToCheck = delegateGetStakerInfo(_testTarget, staker);\\n        require(infoToCheck.value == info.value &&\\n            infoToCheck.currentCommittedPeriod == info.currentCommittedPeriod &&\\n            infoToCheck.nextCommittedPeriod == info.nextCommittedPeriod &&\\n            infoToCheck.flags == info.flags &&\\n            infoToCheck.lockReStakeUntilPeriod == info.lockReStakeUntilPeriod &&\\n            infoToCheck.lastCommittedPeriod == info.lastCommittedPeriod &&\\n            infoToCheck.completedWork == info.completedWork &&\\n            infoToCheck.worker == info.worker &&\\n            infoToCheck.workerStartPeriod == info.workerStartPeriod);\\n\\n        require(delegateGet(_testTarget, this.getPastDowntimeLength.selector, staker) ==\\n            info.pastDowntime.length);\\n        for (uint256 i = 0; i < info.pastDowntime.length && i < MAX_CHECKED_VALUES; i++) {\\n            Downtime storage downtime = info.pastDowntime[i];\\n            Downtime memory downtimeToCheck = delegateGetPastDowntime(_testTarget, staker, i);\\n            require(downtimeToCheck.startPeriod == downtime.startPeriod &&\\n                downtimeToCheck.endPeriod == downtime.endPeriod);\\n        }\\n\\n        require(delegateGet(_testTarget, this.getSubStakesLength.selector, staker) == info.subStakes.length);\\n        for (uint256 i = 0; i < info.subStakes.length && i < MAX_CHECKED_VALUES; i++) {\\n            SubStakeInfo storage subStakeInfo = info.subStakes[i];\\n            SubStakeInfo memory subStakeInfoToCheck = delegateGetSubStakeInfo(_testTarget, staker, i);\\n            require(subStakeInfoToCheck.firstPeriod == subStakeInfo.firstPeriod &&\\n                subStakeInfoToCheck.lastPeriod == subStakeInfo.lastPeriod &&\\n                subStakeInfoToCheck.periods == subStakeInfo.periods &&\\n                subStakeInfoToCheck.lockedValue == subStakeInfo.lockedValue);\\n        }\\n\\n        // it's not perfect because checks not only slot value but also decoding\\n        // at least without additional functions\\n        require(delegateGet(_testTarget, this.totalStakedForAt.selector, staker, bytes32(block.number)) ==\\n            totalStakedForAt(stakerAddress, block.number));\\n        require(delegateGet(_testTarget, this.totalStakedAt.selector, bytes32(block.number)) ==\\n            totalStakedAt(block.number));\\n\\n        if (info.worker != address(0)) {\\n            require(address(delegateGet(_testTarget, this.stakerFromWorker.selector, bytes32(uint256(info.worker)))) ==\\n                stakerFromWorker[info.worker]);\\n        }\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `finishUpgrade`\\n    function finishUpgrade(address _target) public override virtual {\\n        super.finishUpgrade(_target);\\n        // Create fake period\\n        lockedPerPeriod[RESERVED_PERIOD] = 111;\\n\\n        // Create fake worker\\n        stakerFromWorker[address(0)] = address(this);\\n    }\\n}\"\r\n    },\r\n    \"aragon/interfaces/IERC900History.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\n// Minimum interface to interact with Aragon's Aggregator\\ninterface IERC900History {\\n    function totalStakedForAt(address addr, uint256 blockNumber) external view returns (uint256);\\n    function totalStakedAt(uint256 blockNumber) external view returns (uint256);\\n    function supportsHistory() external pure returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Issuer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"./NuCypherToken.sol\\\";\\nimport \\\"../zeppelin/math/Math.sol\\\";\\nimport \\\"./proxy/Upgradeable.sol\\\";\\nimport \\\"./lib/AdditionalMath.sol\\\";\\nimport \\\"../zeppelin/token/ERC20/SafeERC20.sol\\\";\\n\\n\\n/**\\n* @notice Contract for calculation of issued tokens\\n* @dev |v3.3.1|\\n*/\\nabstract contract Issuer is Upgradeable {\\n    using SafeERC20 for NuCypherToken;\\n    using AdditionalMath for uint32;\\n\\n    event Donated(address indexed sender, uint256 value);\\n    /// Issuer is initialized with a reserved reward\\n    event Initialized(uint256 reservedReward);\\n\\n    uint128 constant MAX_UINT128 = uint128(0) - 1;\\n\\n    NuCypherToken public immutable token;\\n    uint128 public immutable totalSupply;\\n\\n    // d * k2\\n    uint256 public immutable mintingCoefficient;\\n    // k1\\n    uint256 public immutable lockDurationCoefficient1;\\n    // k2\\n    uint256 public immutable lockDurationCoefficient2;\\n    uint32 public immutable secondsPerPeriod;\\n    // kmax\\n    uint16 public immutable maximumRewardedPeriods;\\n\\n    uint256 public immutable firstPhaseMaxIssuance;\\n    uint256 public immutable firstPhaseTotalSupply;\\n\\n    /**\\n    * Current supply is used in the minting formula and is stored to prevent different calculation\\n    * for stakers which get reward in the same period. There are two values -\\n    * supply for previous period (used in formula) and supply for current period which accumulates value\\n    * before end of period.\\n    */\\n    uint128 public previousPeriodSupply;\\n    uint128 public currentPeriodSupply;\\n    uint16 public currentMintingPeriod;\\n\\n    /**\\n    * @notice Constructor sets address of token contract and coefficients for minting\\n    * @dev Minting formula for one sub-stake in one period for the first phase\\n    firstPhaseMaxIssuance * (lockedValue / totalLockedValue) * (k1 + min(allLockedPeriods, kmax)) / k2\\n    * @dev Minting formula for one sub-stake in one period for the second phase\\n    (totalSupply - currentSupply) / d * (lockedValue / totalLockedValue) * (k1 + min(allLockedPeriods, kmax)) / k2\\n    if allLockedPeriods > maximumRewardedPeriods then allLockedPeriods = maximumRewardedPeriods\\n    * @param _token Token contract\\n    * @param _hoursPerPeriod Size of period in hours\\n    * @param _issuanceDecayCoefficient (d) Coefficient which modifies the rate at which the maximum issuance decays,\\n    * only applicable to Phase 2. d = 365 * half-life / LOG2 where default half-life = 2.\\n    * See Equation 10 in Staking Protocol & Economics paper\\n    * @param _lockDurationCoefficient1 (k1) Numerator of the coefficient which modifies the extent \\n    * to which a stake's lock duration affects the subsidy it receives. Affects stakers differently. \\n    * Applicable to Phase 1 and Phase 2. k1 = k2 * small_stake_multiplier where default small_stake_multiplier = 0.5.  \\n    * See Equation 8 in Staking Protocol & Economics paper.\\n    * @param _lockDurationCoefficient2 (k2) Denominator of the coefficient which modifies the extent\\n    * to which a stake's lock duration affects the subsidy it receives. Affects stakers differently.\\n    * Applicable to Phase 1 and Phase 2. k2 = maximum_rewarded_periods / (1 - small_stake_multiplier)\\n    * where default maximum_rewarded_periods = 365 and default small_stake_multiplier = 0.5.\\n    * See Equation 8 in Staking Protocol & Economics paper.\\n    * @param _maximumRewardedPeriods (kmax) Number of periods beyond which a stake's lock duration\\n    * no longer increases the subsidy it receives. kmax = reward_saturation * 365 where default reward_saturation = 1.\\n    * See Equation 8 in Staking Protocol & Economics paper.\\n    * @param _firstPhaseTotalSupply Total supply for the first phase\\n    * @param _firstPhaseMaxIssuance (Imax) Maximum number of new tokens minted per period during Phase 1.\\n    * See Equation 7 in Staking Protocol & Economics paper.\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        uint32 _hoursPerPeriod,\\n        uint256 _issuanceDecayCoefficient,\\n        uint256 _lockDurationCoefficient1,\\n        uint256 _lockDurationCoefficient2,\\n        uint16 _maximumRewardedPeriods,\\n        uint256 _firstPhaseTotalSupply,\\n        uint256 _firstPhaseMaxIssuance\\n    ) {\\n        uint256 localTotalSupply = _token.totalSupply();\\n        require(localTotalSupply > 0 &&\\n            _issuanceDecayCoefficient != 0 &&\\n            _hoursPerPeriod != 0 &&\\n            _lockDurationCoefficient1 != 0 &&\\n            _lockDurationCoefficient2 != 0 &&\\n            _maximumRewardedPeriods != 0);\\n        require(localTotalSupply <= uint256(MAX_UINT128), \\\"Token contract has supply more than supported\\\");\\n\\n        uint256 maxLockDurationCoefficient = _maximumRewardedPeriods + _lockDurationCoefficient1;\\n        uint256 localMintingCoefficient = _issuanceDecayCoefficient * _lockDurationCoefficient2;\\n        require(maxLockDurationCoefficient > _maximumRewardedPeriods &&\\n            localMintingCoefficient / _issuanceDecayCoefficient ==  _lockDurationCoefficient2 &&\\n            // worst case for `totalLockedValue * d * k2`, when totalLockedValue == totalSupply\\n            localTotalSupply * localMintingCoefficient / localTotalSupply == localMintingCoefficient &&\\n            // worst case for `(totalSupply - currentSupply) * lockedValue * (k1 + min(allLockedPeriods, kmax))`,\\n            // when currentSupply == 0, lockedValue == totalSupply\\n            localTotalSupply * localTotalSupply * maxLockDurationCoefficient / localTotalSupply / localTotalSupply ==\\n                maxLockDurationCoefficient,\\n            \\\"Specified parameters cause overflow\\\");\\n\\n        require(maxLockDurationCoefficient <= _lockDurationCoefficient2,\\n            \\\"Resulting locking duration coefficient must be less than 1\\\");\\n        require(_firstPhaseTotalSupply <= localTotalSupply, \\\"Too many tokens for the first phase\\\");\\n        require(_firstPhaseMaxIssuance <= _firstPhaseTotalSupply, \\\"Reward for the first phase is too high\\\");\\n\\n        token = _token;\\n        secondsPerPeriod = _hoursPerPeriod.mul32(1 hours);\\n        lockDurationCoefficient1 = _lockDurationCoefficient1;\\n        lockDurationCoefficient2 = _lockDurationCoefficient2;\\n        maximumRewardedPeriods = _maximumRewardedPeriods;\\n        firstPhaseTotalSupply = _firstPhaseTotalSupply;\\n        firstPhaseMaxIssuance = _firstPhaseMaxIssuance;\\n        totalSupply = uint128(localTotalSupply);\\n        mintingCoefficient = localMintingCoefficient;\\n    }\\n\\n    /**\\n    * @dev Checks contract initialization\\n    */\\n    modifier isInitialized()\\n    {\\n        require(currentMintingPeriod != 0);\\n        _;\\n    }\\n\\n    /**\\n    * @return Number of current period\\n    */\\n    function getCurrentPeriod() public view returns (uint16) {\\n        return uint16(block.timestamp / secondsPerPeriod);\\n    }\\n\\n    /**\\n    * @notice Initialize reserved tokens for reward\\n    */\\n    function initialize(uint256 _reservedReward, address _sourceOfFunds) external onlyOwner {\\n        require(currentMintingPeriod == 0);\\n        // Reserved reward must be sufficient for at least one period of the first phase\\n        require(firstPhaseMaxIssuance <= _reservedReward);\\n        currentMintingPeriod = getCurrentPeriod();\\n        currentPeriodSupply = totalSupply - uint128(_reservedReward);\\n        previousPeriodSupply = currentPeriodSupply;\\n        token.safeTransferFrom(_sourceOfFunds, address(this), _reservedReward);\\n        emit Initialized(_reservedReward);\\n    }\\n\\n    /**\\n    * @notice Function to mint tokens for one period.\\n    * @param _currentPeriod Current period number.\\n    * @param _lockedValue The amount of tokens that were locked by user in specified period.\\n    * @param _totalLockedValue The amount of tokens that were locked by all users in specified period.\\n    * @param _allLockedPeriods The max amount of periods during which tokens will be locked after specified period.\\n    * @return amount Amount of minted tokens.\\n    */\\n    function mint(\\n        uint16 _currentPeriod,\\n        uint256 _lockedValue,\\n        uint256 _totalLockedValue,\\n        uint16 _allLockedPeriods\\n    )\\n        internal returns (uint256 amount)\\n    {\\n        if (currentPeriodSupply == totalSupply) {\\n            return 0;\\n        }\\n\\n        if (_currentPeriod > currentMintingPeriod) {\\n            previousPeriodSupply = currentPeriodSupply;\\n            currentMintingPeriod = _currentPeriod;\\n        }\\n\\n        uint256 currentReward;\\n        uint256 coefficient;\\n\\n        // first phase\\n        // firstPhaseMaxIssuance * lockedValue * (k1 + min(allLockedPeriods, kmax)) / (totalLockedValue * k2)\\n        if (previousPeriodSupply + firstPhaseMaxIssuance <= firstPhaseTotalSupply) {\\n            currentReward = firstPhaseMaxIssuance;\\n            coefficient = lockDurationCoefficient2;\\n        // second phase\\n        // (totalSupply - currentSupply) * lockedValue * (k1 + min(allLockedPeriods, kmax)) / (totalLockedValue * d * k2)\\n        } else {\\n            currentReward = totalSupply - previousPeriodSupply;\\n            coefficient = mintingCoefficient;\\n        }\\n\\n        uint256 allLockedPeriods =\\n            AdditionalMath.min16(_allLockedPeriods, maximumRewardedPeriods) + lockDurationCoefficient1;\\n        amount = (uint256(currentReward) * _lockedValue * allLockedPeriods) /\\n            (_totalLockedValue * coefficient);\\n\\n        // rounding the last reward\\n        uint256 maxReward = getReservedReward();\\n        if (amount == 0) {\\n            amount = 1;\\n        } else if (amount > maxReward) {\\n            amount = maxReward;\\n        }\\n\\n        currentPeriodSupply += uint128(amount);\\n    }\\n\\n    /**\\n    * @notice Return tokens for future minting\\n    * @param _amount Amount of tokens\\n    */\\n    function unMint(uint256 _amount) internal {\\n        previousPeriodSupply -= uint128(_amount);\\n        currentPeriodSupply -= uint128(_amount);\\n    }\\n\\n    /**\\n    * @notice Donate sender's tokens. Amount of tokens will be returned for future minting\\n    * @param _value Amount to donate\\n    */\\n    function donate(uint256 _value) external isInitialized {\\n        token.safeTransferFrom(msg.sender, address(this), _value);\\n        unMint(_value);\\n        emit Donated(msg.sender, _value);\\n    }\\n\\n    /**\\n    * @notice Returns the number of tokens that can be minted\\n    */\\n    function getReservedReward() public view returns (uint256) {\\n        return totalSupply - currentPeriodSupply;\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n        require(uint16(delegateGet(_testTarget, this.currentMintingPeriod.selector)) == currentMintingPeriod);\\n        require(uint128(delegateGet(_testTarget, this.previousPeriodSupply.selector)) == previousPeriodSupply);\\n        require(uint128(delegateGet(_testTarget, this.currentPeriodSupply.selector)) == currentPeriodSupply);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/NuCypherToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"../zeppelin/token/ERC20/ERC20.sol\\\";\\nimport \\\"../zeppelin/token/ERC20/ERC20Detailed.sol\\\";\\n\\n\\n/**\\n* @title NuCypher token\\n* @notice ERC20 token\\n* @dev Optional approveAndCall() functionality to notify a contract if an approve() has occurred.\\n*/\\ncontract NuCypherToken is ERC20, ERC20Detailed('NuCypher', 'NU', 18) {\\n\\n    /**\\n    * @notice Set amount of tokens\\n    * @param _totalSupplyOfTokens Total number of tokens\\n    */\\n    constructor (uint256 _totalSupplyOfTokens) {\\n        _mint(msg.sender, _totalSupplyOfTokens);\\n    }\\n\\n    /**\\n    * @notice Approves and then calls the receiving contract\\n    *\\n    * @dev call the receiveApproval function on the contract you want to be notified.\\n    * receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\\n    */\\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData)\\n        external returns (bool success)\\n    {\\n        approve(_spender, _value);\\n        TokenRecipient(_spender).receiveApproval(msg.sender, _value, address(this), _extraData);\\n        return true;\\n    }\\n\\n}\\n\\n\\n/**\\n* @dev Interface to use the receiveApproval method\\n*/\\ninterface TokenRecipient {\\n\\n    /**\\n    * @notice Receives a notification of approval of the transfer\\n    * @param _from Sender of approval\\n    * @param _value  The amount of tokens to be spent\\n    * @param _tokenContract Address of the token contract\\n    * @param _extraData Extra data\\n    */\\n    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;\\n\\n}\\n\"\r\n    },\r\n    \"zeppelin/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Originally based on code by FirstBlood:\\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n *\\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\\n * compliant implementations may not do it.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner The address to query the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified address\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function transfer(address to, uint256 value) public override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public override returns (bool) {\\n\\n        // To change the approve amount you first have to reduce the addresses`\\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\\n        //  already 0 to mitigate the race condition described here:\\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n        require(value == 0 || _allowed[msg.sender][spender] == 0);\\n\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another.\\n     * Note that while this function emits an Approval event, this is not required as per the specification,\\n     * and other compliant implementations may not emit the event.\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 value) public override returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified addresses\\n     * @param from The address to transfer from.\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that mints an amount of the token and assigns it to\\n     * an account. This encapsulates the modification of balances such that the\\n     * proper events are emitted.\\n     * @param account The account that will receive the created tokens.\\n     * @param value The amount that will be created.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account.\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Approve an address to spend another addresses' tokens.\\n     * @param owner The address that owns the tokens.\\n     * @param spender The address that will spend the tokens.\\n     * @param value The number of tokens that can be spent.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(spender != address(0));\\n        require(owner != address(0));\\n\\n        _allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account, deducting from the sender's allowance for said account. Uses the\\n     * internal burn function.\\n     * Emits an Approval event (reflecting the reduced allowance).\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burnFrom(address account, uint256 value) internal {\\n        _burn(account, value);\\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"zeppelin/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"zeppelin/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"zeppelin/token/ERC20/ERC20Detailed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\n/**\\n * @title ERC20Detailed token\\n * @dev The decimals are only for visualization purposes.\\n * All the operations are done using the smallest and indivisible token unit,\\n * just as on Ethereum all the operations are done in wei.\\n */\\nabstract contract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @return the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @return the symbol of the token.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @return the number of decimals of the token.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"zeppelin/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title Math\\n * @dev Assorted math operations\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Calculates the average of two numbers. Since these are integers,\\n     * averages of an even and odd number cannot be represented, and will be\\n     * rounded down.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proxy/Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"../../zeppelin/ownership/Ownable.sol\\\";\\n\\n\\n/**\\n* @notice Base contract for upgradeable contract\\n* @dev Inherited contract should implement verifyState(address) method by checking storage variables\\n* (see verifyState(address) in Dispatcher). Also contract should implement finishUpgrade(address)\\n* if it is using constructor parameters by coping this parameters to the dispatcher storage\\n*/\\nabstract contract Upgradeable is Ownable {\\n\\n    event StateVerified(address indexed testTarget, address sender);\\n    event UpgradeFinished(address indexed target, address sender);\\n\\n    /**\\n    * @dev Contracts at the target must reserve the same location in storage for this address as in Dispatcher\\n    * Stored data actually lives in the Dispatcher\\n    * However the storage layout is specified here in the implementing contracts\\n    */\\n    address public target;\\n\\n    /**\\n    * @dev Previous contract address (if available). Used for rollback\\n    */\\n    address public previousTarget;\\n\\n    /**\\n    * @dev Upgrade status. Explicit `uint8` type is used instead of `bool` to save gas by excluding 0 value\\n    */\\n    uint8 public isUpgrade;\\n\\n    /**\\n    * @dev Guarantees that next slot will be separated from the previous\\n    */\\n    uint256 stubSlot;\\n\\n    /**\\n    * @dev Constants for `isUpgrade` field\\n    */\\n    uint8 constant UPGRADE_FALSE = 1;\\n    uint8 constant UPGRADE_TRUE = 2;\\n\\n    /**\\n    * @dev Checks that function executed while upgrading\\n    * Recommended to add to `verifyState` and `finishUpgrade` methods\\n    */\\n    modifier onlyWhileUpgrading()\\n    {\\n        require(isUpgrade == UPGRADE_TRUE);\\n        _;\\n    }\\n\\n    /**\\n    * @dev Method for verifying storage state.\\n    * Should check that new target contract returns right storage value\\n    */\\n    function verifyState(address _testTarget) public virtual onlyWhileUpgrading {\\n        emit StateVerified(_testTarget, msg.sender);\\n    }\\n\\n    /**\\n    * @dev Copy values from the new target to the current storage\\n    * @param _target New target contract address\\n    */\\n    function finishUpgrade(address _target) public virtual onlyWhileUpgrading {\\n        emit UpgradeFinished(_target, msg.sender);\\n    }\\n\\n    /**\\n    * @dev Base method to get data\\n    * @param _target Target to call\\n    * @param _selector Method selector\\n    * @param _numberOfArguments Number of used arguments\\n    * @param _argument1 First method argument\\n    * @param _argument2 Second method argument\\n    * @return memoryAddress Address in memory where the data is located\\n    */\\n    function delegateGetData(\\n        address _target,\\n        bytes4 _selector,\\n        uint8 _numberOfArguments,\\n        bytes32 _argument1,\\n        bytes32 _argument2\\n    )\\n        internal returns (bytes32 memoryAddress)\\n    {\\n        assembly {\\n            memoryAddress := mload(0x40)\\n            mstore(memoryAddress, _selector)\\n            if gt(_numberOfArguments, 0) {\\n                mstore(add(memoryAddress, 0x04), _argument1)\\n            }\\n            if gt(_numberOfArguments, 1) {\\n                mstore(add(memoryAddress, 0x24), _argument2)\\n            }\\n            switch delegatecall(gas(), _target, memoryAddress, add(0x04, mul(0x20, _numberOfArguments)), 0, 0)\\n                case 0 {\\n                    revert(memoryAddress, 0)\\n                }\\n                default {\\n                    returndatacopy(memoryAddress, 0x0, returndatasize())\\n                }\\n        }\\n    }\\n\\n    /**\\n    * @dev Call \\\"getter\\\" without parameters.\\n    * Result should not exceed 32 bytes\\n    */\\n    function delegateGet(address _target, bytes4 _selector)\\n        internal returns (uint256 result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, _selector, 0, 0, 0);\\n        assembly {\\n            result := mload(memoryAddress)\\n        }\\n    }\\n\\n    /**\\n    * @dev Call \\\"getter\\\" with one parameter.\\n    * Result should not exceed 32 bytes\\n    */\\n    function delegateGet(address _target, bytes4 _selector, bytes32 _argument)\\n        internal returns (uint256 result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, _selector, 1, _argument, 0);\\n        assembly {\\n            result := mload(memoryAddress)\\n        }\\n    }\\n\\n    /**\\n    * @dev Call \\\"getter\\\" with two parameters.\\n    * Result should not exceed 32 bytes\\n    */\\n    function delegateGet(\\n        address _target,\\n        bytes4 _selector,\\n        bytes32 _argument1,\\n        bytes32 _argument2\\n    )\\n        internal returns (uint256 result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, _selector, 2, _argument1, _argument2);\\n        assembly {\\n            result := mload(memoryAddress)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"zeppelin/ownership/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AdditionalMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"../../zeppelin/math/SafeMath.sol\\\";\\n\\n\\n/**\\n* @notice Additional math operations\\n*/\\nlibrary AdditionalMath {\\n    using SafeMath for uint256;\\n\\n    function max16(uint16 a, uint16 b) internal pure returns (uint16) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function min16(uint16 a, uint16 b) internal pure returns (uint16) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n    * @notice Division and ceil\\n    */\\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a.add(b) - 1) / b;\\n    }\\n\\n    /**\\n    * @dev Adds signed value to unsigned value, throws on overflow.\\n    */\\n    function addSigned(uint256 a, int256 b) internal pure returns (uint256) {\\n        if (b >= 0) {\\n            return a.add(uint256(b));\\n        } else {\\n            return a.sub(uint256(-b));\\n        }\\n    }\\n\\n    /**\\n    * @dev Subtracts signed value from unsigned value, throws on overflow.\\n    */\\n    function subSigned(uint256 a, int256 b) internal pure returns (uint256) {\\n        if (b >= 0) {\\n            return a.sub(uint256(b));\\n        } else {\\n            return a.add(uint256(-b));\\n        }\\n    }\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul32(uint32 a, uint32 b) internal pure returns (uint32) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint32 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add16(uint16 a, uint16 b) internal pure returns (uint16) {\\n        uint16 c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub16(uint16 a, uint16 b) internal pure returns (uint16) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Adds signed value to unsigned value, throws on overflow.\\n    */\\n    function addSigned16(uint16 a, int16 b) internal pure returns (uint16) {\\n        if (b >= 0) {\\n            return add16(a, uint16(b));\\n        } else {\\n            return sub16(a, uint16(-b));\\n        }\\n    }\\n\\n    /**\\n    * @dev Subtracts signed value from unsigned value, throws on overflow.\\n    */\\n    function subSigned16(uint16 a, int16 b) internal pure returns (uint16) {\\n        if (b >= 0) {\\n            return sub16(a, uint16(b));\\n        } else {\\n            return add16(a, uint16(-b));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"zeppelin/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        require(token.transfer(to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        require(token.transferFrom(from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require((value == 0) || (token.allowance(msg.sender, spender) == 0));\\n        require(token.approve(spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        require(token.approve(spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        require(token.approve(spender, newAllowance));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Bits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n* @dev Taken from https://github.com/ethereum/solidity-examples/blob/master/src/bits/Bits.sol\\n*/\\nlibrary Bits {\\n\\n    uint256 internal constant ONE = uint256(1);\\n\\n    /**\\n    * @notice Sets the bit at the given 'index' in 'self' to:\\n    *  '1' - if the bit is '0'\\n    *  '0' - if the bit is '1'\\n    * @return The modified value\\n    */\\n    function toggleBit(uint256 self, uint8 index) internal pure returns (uint256) {\\n        return self ^ ONE << index;\\n    }\\n\\n    /**\\n    * @notice Get the value of the bit at the given 'index' in 'self'.\\n    */\\n    function bit(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8(self >> index & 1);\\n    }\\n\\n    /**\\n    * @notice Check if the bit at the given 'index' in 'self' is set.\\n    * @return  'true' - if the value of the bit is '1',\\n    *          'false' - if the value of the bit is '0'\\n    */\\n    function bitSet(uint256 self, uint8 index) internal pure returns (bool) {\\n        return self >> index & 1 == 1;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Snapshot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title Snapshot\\n * @notice Manages snapshots of size 128 bits (32 bits for timestamp, 96 bits for value)\\n * 96 bits is enough for storing NU token values, and 32 bits should be OK for block numbers\\n * @dev Since each storage slot can hold two snapshots, new slots are allocated every other TX. Thus, gas cost of adding snapshots is 51400 and 36400 gas, alternately.\\n * Based on Aragon's Checkpointing (https://https://github.com/aragonone/voting-connectors/blob/master/shared/contract-utils/contracts/Checkpointing.sol)\\n * On average, adding snapshots spends ~6500 less gas than the 256-bit checkpoints of Aragon's Checkpointing\\n */\\nlibrary Snapshot {\\n\\n    function encodeSnapshot(uint32 _time, uint96 _value) internal pure returns(uint128) {\\n        return uint128(uint256(_time) << 96 | uint256(_value));\\n    }\\n\\n    function decodeSnapshot(uint128 _snapshot) internal pure returns(uint32 time, uint96 value){\\n        time = uint32(bytes4(bytes16(_snapshot)));\\n        value = uint96(_snapshot);\\n    }\\n\\n    function addSnapshot(uint128[] storage _self, uint256 _value) internal {\\n        addSnapshot(_self, block.number, _value);\\n    }\\n\\n    function addSnapshot(uint128[] storage _self, uint256 _time, uint256 _value) internal {\\n        uint256 length = _self.length;\\n        if (length != 0) {\\n            (uint32 currentTime, ) = decodeSnapshot(_self[length - 1]);\\n            if (uint32(_time) == currentTime) {\\n                _self[length - 1] = encodeSnapshot(uint32(_time), uint96(_value));\\n                return;\\n            } else if (uint32(_time) < currentTime){\\n                revert();\\n            }\\n        }\\n        _self.push(encodeSnapshot(uint32(_time), uint96(_value)));\\n    }\\n\\n    function lastSnapshot(uint128[] storage _self) internal view returns (uint32, uint96) {\\n        uint256 length = _self.length;\\n        if (length > 0) {\\n            return decodeSnapshot(_self[length - 1]);\\n        }\\n\\n        return (0, 0);\\n    }\\n\\n    function lastValue(uint128[] storage _self) internal view returns (uint96) {\\n        (, uint96 value) = lastSnapshot(_self);\\n        return value;\\n    }\\n\\n    function getValueAt(uint128[] storage _self, uint256 _time256) internal view returns (uint96) {\\n        uint32 _time = uint32(_time256);\\n        uint256 length = _self.length;\\n\\n        // Short circuit if there's no checkpoints yet\\n        // Note that this also lets us avoid using SafeMath later on, as we've established that\\n        // there must be at least one checkpoint\\n        if (length == 0) {\\n            return 0;\\n        }\\n\\n        // Check last checkpoint\\n        uint256 lastIndex = length - 1;\\n        (uint32 snapshotTime, uint96 snapshotValue) = decodeSnapshot(_self[length - 1]);\\n        if (_time >= snapshotTime) {\\n            return snapshotValue;\\n        }\\n\\n        // Check first checkpoint (if not already checked with the above check on last)\\n        (snapshotTime, snapshotValue) = decodeSnapshot(_self[0]);\\n        if (length == 1 || _time < snapshotTime) {\\n            return 0;\\n        }\\n\\n        // Do binary search\\n        // As we've already checked both ends, we don't need to check the last checkpoint again\\n        uint256 low = 0;\\n        uint256 high = lastIndex - 1;\\n        uint32 midTime;\\n        uint96 midValue;\\n\\n        while (high > low) {\\n            uint256 mid = (high + low + 1) / 2; // average, ceil round\\n            (midTime, midValue) = decodeSnapshot(_self[mid]);\\n\\n            if (_time > midTime) {\\n                low = mid;\\n            } else if (_time < midTime) {\\n                // Note that we don't need SafeMath here because mid must always be greater than 0\\n                // from the while condition\\n                high = mid - 1;\\n            } else {\\n                // _time == midTime\\n                return midValue;\\n            }\\n        }\\n\\n        (, snapshotValue) = decodeSnapshot(_self[low]);\\n        return snapshotValue;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/dao/IForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\ninterface IForwarder {\\n\\n    function isForwarder() external pure returns (bool);\\n    function canForward(address sender, bytes calldata evmCallScript) external view returns (bool);\\n    function forward(bytes calldata evmCallScript) external;\\n    \\n}\\n\"\r\n    },\r\n    \"contracts/dao/TokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\ninterface TokenManager {\\n\\n    function mint(address _receiver, uint256 _amount) external;\\n    function issue(uint256 _amount) external;\\n    function assign(address _receiver, uint256 _amount) external;\\n    function burn(address _holder, uint256 _amount) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/dao/Voting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IForwarder.sol\\\";\\n\\n// Interface for Voting contract, as found in https://github.com/aragon/aragon-apps/blob/master/apps/voting/contracts/Voting.sol\\ninterface Voting is IForwarder{\\n\\n    enum VoterState { Absent, Yea, Nay }\\n\\n    // Public getters\\n    function token() external returns (address);\\n    function supportRequiredPct() external returns (uint64);\\n    function minAcceptQuorumPct() external returns (uint64);\\n    function voteTime() external returns (uint64);\\n    function votesLength() external returns (uint256);\\n\\n    // Setters\\n    function changeSupportRequiredPct(uint64 _supportRequiredPct) external;\\n    function changeMinAcceptQuorumPct(uint64 _minAcceptQuorumPct) external;\\n\\n    // Creating new votes\\n    function newVote(bytes calldata _executionScript, string memory _metadata) external returns (uint256 voteId);\\n    function newVote(bytes calldata _executionScript, string memory _metadata, bool _castVote, bool _executesIfDecided)\\n        external returns (uint256 voteId);\\n\\n    // Voting\\n    function canVote(uint256 _voteId, address _voter) external view returns (bool);\\n    function vote(uint256 _voteId, bool _supports, bool _executesIfDecided) external;\\n\\n    // Executing a passed vote\\n    function canExecute(uint256 _voteId) external view returns (bool);\\n    function executeVote(uint256 _voteId) external;\\n\\n    // Additional info\\n    function getVote(uint256 _voteId) external view\\n        returns (\\n            bool open,\\n            bool executed,\\n            uint64 startDate,\\n            uint64 snapshotBlock,\\n            uint64 supportRequired,\\n            uint64 minAcceptQuorum,\\n            uint256 yea,\\n            uint256 nay,\\n            uint256 votingPower,\\n            bytes memory script\\n        );\\n    function getVoterState(uint256 _voteId, address _voter) external view returns (VoterState);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/MultiSig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"../zeppelin/math/SafeMath.sol\\\";\\n\\n\\n/**\\n* @notice Multi-signature contract with off-chain signing\\n*/\\ncontract MultiSig {\\n    using SafeMath for uint256;\\n\\n    event Executed(address indexed sender, uint256 indexed nonce, address indexed destination, uint256 value);\\n    event OwnerAdded(address indexed owner);\\n    event OwnerRemoved(address indexed owner);\\n    event RequirementChanged(uint16 required);\\n\\n    uint256 constant public MAX_OWNER_COUNT = 50;\\n\\n    uint256 public nonce;\\n    uint8 public required;\\n    mapping (address => bool) public isOwner;\\n    address[] public owners;\\n\\n    /**\\n    * @notice Only this contract can call method\\n    */\\n    modifier onlyThisContract() {\\n        require(msg.sender == address(this));\\n        _;\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n    * @param _required Number of required signings\\n    * @param _owners List of initial owners.\\n    */\\n    constructor (uint8 _required, address[] memory _owners) {\\n        require(_owners.length <= MAX_OWNER_COUNT &&\\n            _required <= _owners.length &&\\n            _required > 0);\\n\\n        for (uint256 i = 0; i < _owners.length; i++) {\\n            address owner = _owners[i];\\n            require(!isOwner[owner] && owner != address(0));\\n            isOwner[owner] = true;\\n        }\\n        owners = _owners;\\n        required = _required;\\n    }\\n\\n    /**\\n    * @notice Get unsigned hash for transaction parameters\\n    * @dev Follows ERC191 signature scheme: https://github.com/ethereum/EIPs/issues/191\\n    * @param _sender Trustee who will execute the transaction\\n    * @param _destination Destination address\\n    * @param _value Amount of ETH to transfer\\n    * @param _data Call data\\n    * @param _nonce Nonce\\n    */\\n    function getUnsignedTransactionHash(\\n        address _sender,\\n        address _destination,\\n        uint256 _value,\\n        bytes memory _data,\\n        uint256 _nonce\\n    )\\n        public view returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(byte(0x19), byte(0), address(this), _sender, _destination, _value, _data, _nonce));\\n    }\\n\\n    /**\\n    * @dev Note that address recovered from signatures must be strictly increasing\\n    * @param _sigV Array of signatures values V\\n    * @param _sigR Array of signatures values R\\n    * @param _sigS Array of signatures values S\\n    * @param _destination Destination address\\n    * @param _value Amount of ETH to transfer\\n    * @param _data Call data\\n    */\\n    function execute(\\n        uint8[] calldata _sigV,\\n        bytes32[] calldata _sigR,\\n        bytes32[] calldata _sigS,\\n        address _destination,\\n        uint256 _value,\\n        bytes calldata _data\\n    )\\n        external\\n    {\\n        require(_sigR.length >= required &&\\n            _sigR.length == _sigS.length &&\\n            _sigR.length == _sigV.length);\\n\\n        bytes32 txHash = getUnsignedTransactionHash(msg.sender, _destination, _value, _data, nonce);\\n        address lastAdd = address(0);\\n        for (uint256 i = 0; i < _sigR.length; i++) {\\n            address recovered = ecrecover(txHash, _sigV[i], _sigR[i], _sigS[i]);\\n            require(recovered > lastAdd && isOwner[recovered]);\\n            lastAdd = recovered;\\n        }\\n\\n        emit Executed(msg.sender, nonce, _destination, _value);\\n        nonce = nonce.add(1);\\n        (bool callSuccess,) = _destination.call{value: _value}(_data);\\n        require(callSuccess);\\n    }\\n\\n    /**\\n    * @notice Allows to add a new owner\\n    * @dev Transaction has to be sent by `execute` method.\\n    * @param _owner Address of new owner\\n    */\\n    function addOwner(address _owner)\\n        external\\n        onlyThisContract\\n    {\\n        require(owners.length < MAX_OWNER_COUNT &&\\n            _owner != address(0) &&\\n            !isOwner[_owner]);\\n        isOwner[_owner] = true;\\n        owners.push(_owner);\\n        emit OwnerAdded(_owner);\\n    }\\n\\n    /**\\n    * @notice Allows to remove an owner\\n    * @dev Transaction has to be sent by `execute` method.\\n    * @param _owner Address of owner\\n    */\\n    function removeOwner(address _owner)\\n        external\\n        onlyThisContract\\n    {\\n        require(owners.length > required && isOwner[_owner]);\\n        isOwner[_owner] = false;\\n        for (uint256 i = 0; i < owners.length - 1; i++) {\\n            if (owners[i] == _owner) {\\n                owners[i] = owners[owners.length - 1];\\n                break;\\n            }\\n        }\\n        owners.pop();\\n        emit OwnerRemoved(_owner);\\n    }\\n\\n    /**\\n    * @notice Returns the number of owners of this MultiSig\\n    */\\n    function getNumberOfOwners() external view returns (uint256) {\\n        return owners.length;\\n    }\\n\\n    /**\\n    * @notice Allows to change the number of required signatures\\n    * @dev Transaction has to be sent by `execute` method\\n    * @param _required Number of required signatures\\n    */\\n    function changeRequirement(uint8 _required)\\n        external\\n        onlyThisContract\\n    {\\n        require(_required <= owners.length && _required > 0);\\n        required = _required;\\n        emit RequirementChanged(_required);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/PolicyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"../zeppelin/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../zeppelin/math/SafeMath.sol\\\";\\nimport \\\"../zeppelin/math/Math.sol\\\";\\nimport \\\"../zeppelin/utils/Address.sol\\\";\\nimport \\\"./lib/AdditionalMath.sol\\\";\\nimport \\\"./lib/SignatureVerifier.sol\\\";\\nimport \\\"./StakingEscrow.sol\\\";\\nimport \\\"./NuCypherToken.sol\\\";\\nimport \\\"./proxy/Upgradeable.sol\\\";\\n\\n\\n/**\\n* @notice Contract holds policy data and locks accrued policy fees\\n* @dev |v6.1.2|\\n*/\\ncontract PolicyManager is Upgradeable {\\n    using SafeERC20 for NuCypherToken;\\n    using SafeMath for uint256;\\n    using AdditionalMath for uint256;\\n    using AdditionalMath for int256;\\n    using AdditionalMath for uint16;\\n    using Address for address payable;\\n\\n    event PolicyCreated(\\n        bytes16 indexed policyId,\\n        address indexed sponsor,\\n        address indexed owner,\\n        uint256 feeRate,\\n        uint64 startTimestamp,\\n        uint64 endTimestamp,\\n        uint256 numberOfNodes\\n    );\\n    event ArrangementRevoked(\\n        bytes16 indexed policyId,\\n        address indexed sender,\\n        address indexed node,\\n        uint256 value\\n    );\\n    event RefundForArrangement(\\n        bytes16 indexed policyId,\\n        address indexed sender,\\n        address indexed node,\\n        uint256 value\\n    );\\n    event PolicyRevoked(bytes16 indexed policyId, address indexed sender, uint256 value);\\n    event RefundForPolicy(bytes16 indexed policyId, address indexed sender, uint256 value);\\n    event NodeBrokenState(address indexed node, uint16 period);\\n    event MinFeeRateSet(address indexed node, uint256 value);\\n    // TODO #1501\\n    // Range range\\n    event FeeRateRangeSet(address indexed sender, uint256 min, uint256 defaultValue, uint256 max);\\n    event Withdrawn(address indexed node, address indexed recipient, uint256 value);\\n\\n    struct ArrangementInfo {\\n        address node;\\n        uint256 indexOfDowntimePeriods;\\n        uint16 lastRefundedPeriod;\\n    }\\n\\n    struct Policy {\\n        bool disabled;\\n        address payable sponsor;\\n        address owner;\\n\\n        uint128 feeRate;\\n        uint64 startTimestamp;\\n        uint64 endTimestamp;\\n\\n        uint256 reservedSlot1;\\n        uint256 reservedSlot2;\\n        uint256 reservedSlot3;\\n        uint256 reservedSlot4;\\n        uint256 reservedSlot5;\\n\\n        ArrangementInfo[] arrangements;\\n    }\\n\\n    struct NodeInfo {\\n        uint128 fee;\\n        uint16 previousFeePeriod;\\n        uint256 feeRate;\\n        uint256 minFeeRate;\\n        mapping (uint16 => int256) feeDelta;\\n    }\\n\\n    // TODO used only for `delegateGetNodeInfo`, probably will be removed after #1512\\n    struct MemoryNodeInfo {\\n        uint128 fee;\\n        uint16 previousFeePeriod;\\n        uint256 feeRate;\\n        uint256 minFeeRate;\\n    }\\n\\n    struct Range {\\n        uint128 min;\\n        uint128 defaultValue;\\n        uint128 max;\\n    }\\n\\n    bytes16 internal constant RESERVED_POLICY_ID = bytes16(0);\\n    address internal constant RESERVED_NODE = address(0);\\n    uint256 internal constant MAX_BALANCE = uint256(uint128(0) - 1);\\n    // controlled overflow to get max int256\\n    int256 public constant DEFAULT_FEE_DELTA = int256((uint256(0) - 1) >> 1);\\n\\n    StakingEscrow public immutable escrow;\\n    uint32 public immutable secondsPerPeriod;\\n\\n    mapping (bytes16 => Policy) public policies;\\n    mapping (address => NodeInfo) public nodes;\\n    Range public feeRateRange;\\n\\n    /**\\n    * @notice Constructor sets address of the escrow contract\\n    * @param _escrow Escrow contract\\n    */\\n    constructor(StakingEscrow _escrow) {\\n        // if the input address is not the StakingEscrow then calling `secondsPerPeriod` will throw error\\n        uint32 localSecondsPerPeriod = _escrow.secondsPerPeriod();\\n        require(localSecondsPerPeriod > 0);\\n        secondsPerPeriod = localSecondsPerPeriod;\\n        escrow = _escrow;\\n    }\\n\\n    /**\\n    * @dev Checks that sender is the StakingEscrow contract\\n    */\\n    modifier onlyEscrowContract()\\n    {\\n        require(msg.sender == address(escrow));\\n        _;\\n    }\\n\\n    /**\\n    * @return Number of current period\\n    */\\n    function getCurrentPeriod() public view returns (uint16) {\\n        return uint16(block.timestamp / secondsPerPeriod);\\n    }\\n\\n    /**\\n    * @notice Register a node\\n    * @param _node Node address\\n    * @param _period Initial period\\n    */\\n    function register(address _node, uint16 _period) external onlyEscrowContract {\\n        NodeInfo storage nodeInfo = nodes[_node];\\n        require(nodeInfo.previousFeePeriod == 0 && _period < getCurrentPeriod());\\n        nodeInfo.previousFeePeriod = _period;\\n    }\\n\\n    /**\\n    * @notice Set minimum, default & maximum fee rate for all stakers and all policies ('global fee range')\\n    */\\n    // TODO # 1501\\n    // function setFeeRateRange(Range calldata _range) external onlyOwner {\\n    function setFeeRateRange(uint128 _min, uint128 _default, uint128 _max) external onlyOwner {\\n        require(_min <= _default && _default <= _max);\\n        feeRateRange = Range(_min, _default, _max);\\n        emit FeeRateRangeSet(msg.sender, _min, _default, _max);\\n    }\\n\\n    /**\\n    * @notice Set the minimum acceptable fee rate (set by staker for their associated worker)\\n    * @dev Input value must fall within `feeRateRange` (global fee range)\\n    */\\n    function setMinFeeRate(uint256 _minFeeRate) external {\\n        require(_minFeeRate >= feeRateRange.min &&\\n            _minFeeRate <= feeRateRange.max,\\n            \\\"The staker's min fee rate must fall within the global fee range\\\");\\n        NodeInfo storage nodeInfo = nodes[msg.sender];\\n        if (nodeInfo.minFeeRate == _minFeeRate) {\\n            return;\\n        }\\n        nodeInfo.minFeeRate = _minFeeRate;\\n        emit MinFeeRateSet(msg.sender, _minFeeRate);\\n    }\\n\\n    /**\\n    * @notice Get the minimum acceptable fee rate (set by staker for their associated worker)\\n    */\\n    function getMinFeeRate(NodeInfo storage _nodeInfo) internal view returns (uint256) {\\n        // if minFeeRate has not been set or chosen value falls outside the global fee range\\n        // a default value is returned instead\\n        if (_nodeInfo.minFeeRate == 0 ||\\n            _nodeInfo.minFeeRate < feeRateRange.min ||\\n            _nodeInfo.minFeeRate > feeRateRange.max) {\\n            return feeRateRange.defaultValue;\\n        } else {\\n            return _nodeInfo.minFeeRate;\\n        }\\n    }\\n\\n    /**\\n    * @notice Get the minimum acceptable fee rate (set by staker for their associated worker)\\n    */\\n    function getMinFeeRate(address _node) public view returns (uint256) {\\n        NodeInfo storage nodeInfo = nodes[_node];\\n        return getMinFeeRate(nodeInfo);\\n    }\\n\\n    /**\\n    * @notice Create policy\\n    * @dev Generate policy id before creation\\n    * @param _policyId Policy id\\n    * @param _policyOwner Policy owner. Zero address means sender is owner\\n    * @param _endTimestamp End timestamp of the policy in seconds\\n    * @param _nodes Nodes that will handle policy\\n    */\\n    function createPolicy(\\n        bytes16 _policyId,\\n        address _policyOwner,\\n        uint64 _endTimestamp,\\n        address[] calldata _nodes\\n    )\\n        external payable\\n    {\\n        Policy storage policy = policies[_policyId];\\n        require(\\n            _policyId != RESERVED_POLICY_ID &&\\n            policy.feeRate == 0 &&\\n            !policy.disabled &&\\n            _endTimestamp > block.timestamp &&\\n            msg.value > 0\\n        );\\n        require(address(this).balance <= MAX_BALANCE);\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 endPeriod = uint16(_endTimestamp / secondsPerPeriod) + 1;\\n        uint256 numberOfPeriods = endPeriod - currentPeriod;\\n\\n        policy.sponsor = msg.sender;\\n        policy.startTimestamp = uint64(block.timestamp);\\n        policy.endTimestamp = _endTimestamp;\\n        policy.feeRate = uint128(msg.value.div(_nodes.length) / numberOfPeriods);\\n        require(policy.feeRate > 0 && policy.feeRate * numberOfPeriods * _nodes.length  == msg.value);\\n        if (_policyOwner != msg.sender && _policyOwner != address(0)) {\\n            policy.owner = _policyOwner;\\n        }\\n\\n        for (uint256 i = 0; i < _nodes.length; i++) {\\n            address node = _nodes[i];\\n            require(node != RESERVED_NODE);\\n            NodeInfo storage nodeInfo = nodes[node];\\n            require(nodeInfo.previousFeePeriod != 0 &&\\n                nodeInfo.previousFeePeriod < currentPeriod &&\\n                policy.feeRate >= getMinFeeRate(nodeInfo));\\n            // Check default value for feeDelta\\n            if (nodeInfo.feeDelta[currentPeriod] == DEFAULT_FEE_DELTA) {\\n                nodeInfo.feeDelta[currentPeriod] = int256(policy.feeRate);\\n            } else {\\n                // Overflow protection removed, because ETH total supply less than uint255/int256\\n                nodeInfo.feeDelta[currentPeriod] += int256(policy.feeRate);\\n            }\\n            if (nodeInfo.feeDelta[endPeriod] == DEFAULT_FEE_DELTA) {\\n                nodeInfo.feeDelta[endPeriod] = -int256(policy.feeRate);\\n            } else {\\n                nodeInfo.feeDelta[endPeriod] -= int256(policy.feeRate);\\n            }\\n            // Reset to default value if needed\\n            if (nodeInfo.feeDelta[currentPeriod] == 0) {\\n                nodeInfo.feeDelta[currentPeriod] = DEFAULT_FEE_DELTA;\\n            }\\n            if (nodeInfo.feeDelta[endPeriod] == 0) {\\n                nodeInfo.feeDelta[endPeriod] = DEFAULT_FEE_DELTA;\\n            }\\n            policy.arrangements.push(ArrangementInfo(node, 0, 0));\\n        }\\n\\n        emit PolicyCreated(\\n            _policyId,\\n            msg.sender,\\n            _policyOwner == address(0) ? msg.sender : _policyOwner,\\n            policy.feeRate,\\n            policy.startTimestamp,\\n            policy.endTimestamp,\\n            _nodes.length\\n        );\\n    }\\n\\n    /**\\n    * @notice Get policy owner\\n    */\\n    function getPolicyOwner(bytes16 _policyId) public view returns (address) {\\n        Policy storage policy = policies[_policyId];\\n        return policy.owner == address(0) ? policy.sponsor : policy.owner;\\n    }\\n\\n    /**\\n    * @notice Set default `feeDelta` value for specified period\\n    * @dev This method increases gas cost for node in trade of decreasing cost for policy sponsor\\n    * @param _node Node address\\n    * @param _period Period to set\\n    */\\n    function setDefaultFeeDelta(address _node, uint16 _period) external onlyEscrowContract {\\n        NodeInfo storage node = nodes[_node];\\n        if (node.feeDelta[_period] == 0) {\\n            node.feeDelta[_period] = DEFAULT_FEE_DELTA;\\n        }\\n    }\\n\\n    /**\\n    * @notice Update node fee\\n    * @param _node Node address\\n    * @param _period Processed period\\n    */\\n    function updateFee(address _node, uint16 _period) external onlyEscrowContract {\\n        NodeInfo storage node = nodes[_node];\\n        if (node.previousFeePeriod == 0 || _period <= node.previousFeePeriod) {\\n            return;\\n        }\\n        for (uint16 i = node.previousFeePeriod + 1; i <= _period; i++) {\\n            int256 delta = node.feeDelta[i];\\n            if (delta == DEFAULT_FEE_DELTA) {\\n                // gas refund\\n                node.feeDelta[i] = 0;\\n                continue;\\n            }\\n\\n            // broken state\\n            if (delta < 0 && uint256(-delta) > node.feeRate) {\\n                node.feeDelta[i] += int256(node.feeRate);\\n                node.feeRate = 0;\\n                emit NodeBrokenState(_node, _period);\\n            // good state\\n            } else {\\n                node.feeRate = node.feeRate.addSigned(delta);\\n                // gas refund\\n                node.feeDelta[i] = 0;\\n            }\\n        }\\n        node.previousFeePeriod = _period;\\n        node.fee += uint128(node.feeRate);\\n    }\\n\\n    /**\\n    * @notice Withdraw fee by node\\n    */\\n    function withdraw() external returns (uint256) {\\n        return withdraw(msg.sender);\\n    }\\n\\n    /**\\n    * @notice Withdraw fee by node\\n    * @param _recipient Recipient of the fee\\n    */\\n    function withdraw(address payable _recipient) public returns (uint256) {\\n        NodeInfo storage node = nodes[msg.sender];\\n        uint256 fee = node.fee;\\n        require(fee != 0);\\n        node.fee = 0;\\n        _recipient.sendValue(fee);\\n        emit Withdrawn(msg.sender, _recipient, fee);\\n        return fee;\\n    }\\n\\n    /**\\n    * @notice Calculate amount of refund\\n    * @param _policy Policy\\n    * @param _arrangement Arrangement\\n    */\\n    function calculateRefundValue(Policy storage _policy, ArrangementInfo storage _arrangement)\\n        internal view returns (uint256 refundValue, uint256 indexOfDowntimePeriods, uint16 lastRefundedPeriod)\\n    {\\n        uint16 policyStartPeriod = uint16(_policy.startTimestamp / secondsPerPeriod);\\n        uint16 maxPeriod = AdditionalMath.min16(getCurrentPeriod(), uint16(_policy.endTimestamp / secondsPerPeriod));\\n        uint16 minPeriod = AdditionalMath.max16(policyStartPeriod, _arrangement.lastRefundedPeriod);\\n        uint16 downtimePeriods = 0;\\n        uint256 length = escrow.getPastDowntimeLength(_arrangement.node);\\n        uint256 initialIndexOfDowntimePeriods;\\n        if (_arrangement.lastRefundedPeriod == 0) {\\n            initialIndexOfDowntimePeriods = escrow.findIndexOfPastDowntime(_arrangement.node, policyStartPeriod);\\n        } else {\\n            initialIndexOfDowntimePeriods = _arrangement.indexOfDowntimePeriods;\\n        }\\n\\n        for (indexOfDowntimePeriods = initialIndexOfDowntimePeriods;\\n             indexOfDowntimePeriods < length;\\n             indexOfDowntimePeriods++)\\n        {\\n            (uint16 startPeriod, uint16 endPeriod) =\\n                escrow.getPastDowntime(_arrangement.node, indexOfDowntimePeriods);\\n            if (startPeriod > maxPeriod) {\\n                break;\\n            } else if (endPeriod < minPeriod) {\\n                continue;\\n            }\\n            downtimePeriods += AdditionalMath.min16(maxPeriod, endPeriod)\\n                .sub16(AdditionalMath.max16(minPeriod, startPeriod)) + 1;\\n            if (maxPeriod <= endPeriod) {\\n                break;\\n            }\\n        }\\n\\n        uint16 lastCommittedPeriod = escrow.getLastCommittedPeriod(_arrangement.node);\\n        if (indexOfDowntimePeriods == length && lastCommittedPeriod < maxPeriod) {\\n            // Overflow protection removed:\\n            // lastCommittedPeriod < maxPeriod and minPeriod <= maxPeriod + 1\\n            downtimePeriods += maxPeriod - AdditionalMath.max16(minPeriod - 1, lastCommittedPeriod);\\n        }\\n\\n        refundValue = _policy.feeRate * downtimePeriods;\\n        lastRefundedPeriod = maxPeriod + 1;\\n    }\\n\\n    /**\\n    * @notice Revoke/refund arrangement/policy by the sponsor\\n    * @param _policyId Policy id\\n    * @param _node Node that will be excluded or RESERVED_NODE if full policy should be used\\n    ( @param _forceRevoke Force revoke arrangement/policy\\n    */\\n    function refundInternal(bytes16 _policyId, address _node, bool _forceRevoke)\\n        internal returns (uint256 refundValue)\\n    {\\n        refundValue = 0;\\n        Policy storage policy = policies[_policyId];\\n        require(!policy.disabled);\\n        uint16 endPeriod = uint16(policy.endTimestamp / secondsPerPeriod) + 1;\\n        uint256 numberOfActive = policy.arrangements.length;\\n        uint256 i = 0;\\n        for (; i < policy.arrangements.length; i++) {\\n            ArrangementInfo storage arrangement = policy.arrangements[i];\\n            address node = arrangement.node;\\n            if (node == RESERVED_NODE || _node != RESERVED_NODE && _node != node) {\\n                numberOfActive--;\\n                continue;\\n            }\\n            uint256 nodeRefundValue;\\n            (nodeRefundValue, arrangement.indexOfDowntimePeriods, arrangement.lastRefundedPeriod) =\\n                calculateRefundValue(policy, arrangement);\\n            if (_forceRevoke) {\\n                NodeInfo storage nodeInfo = nodes[node];\\n\\n                // Check default value for feeDelta\\n                uint16 lastRefundedPeriod = arrangement.lastRefundedPeriod;\\n                if (nodeInfo.feeDelta[lastRefundedPeriod] == DEFAULT_FEE_DELTA) {\\n                    nodeInfo.feeDelta[lastRefundedPeriod] = -int256(policy.feeRate);\\n                } else {\\n                    nodeInfo.feeDelta[lastRefundedPeriod] -= int256(policy.feeRate);\\n                }\\n                if (nodeInfo.feeDelta[endPeriod] == DEFAULT_FEE_DELTA) {\\n                    nodeInfo.feeDelta[endPeriod] = -int256(policy.feeRate);\\n                } else {\\n                    nodeInfo.feeDelta[endPeriod] += int256(policy.feeRate);\\n                }\\n\\n                // Reset to default value if needed\\n                if (nodeInfo.feeDelta[lastRefundedPeriod] == 0) {\\n                    nodeInfo.feeDelta[lastRefundedPeriod] = DEFAULT_FEE_DELTA;\\n                }\\n                if (nodeInfo.feeDelta[endPeriod] == 0) {\\n                    nodeInfo.feeDelta[endPeriod] = DEFAULT_FEE_DELTA;\\n                }\\n                nodeRefundValue += uint256(endPeriod - lastRefundedPeriod) * policy.feeRate;\\n            }\\n            if (_forceRevoke || arrangement.lastRefundedPeriod >= endPeriod) {\\n                arrangement.node = RESERVED_NODE;\\n                arrangement.indexOfDowntimePeriods = 0;\\n                arrangement.lastRefundedPeriod = 0;\\n                numberOfActive--;\\n                emit ArrangementRevoked(_policyId, msg.sender, node, nodeRefundValue);\\n            } else {\\n                emit RefundForArrangement(_policyId, msg.sender, node, nodeRefundValue);\\n            }\\n\\n            refundValue += nodeRefundValue;\\n            if (_node != RESERVED_NODE) {\\n               break;\\n            }\\n        }\\n        address payable policySponsor = policy.sponsor;\\n        if (_node == RESERVED_NODE) {\\n            if (numberOfActive == 0) {\\n                policy.disabled = true;\\n                // gas refund\\n                policy.sponsor = address(0);\\n                policy.owner = address(0);\\n                policy.feeRate = 0;\\n                policy.startTimestamp = 0;\\n                policy.endTimestamp = 0;\\n                emit PolicyRevoked(_policyId, msg.sender, refundValue);\\n            } else {\\n                emit RefundForPolicy(_policyId, msg.sender, refundValue);\\n            }\\n        } else {\\n            // arrangement not found\\n            require(i < policy.arrangements.length);\\n        }\\n        if (refundValue > 0) {\\n            policySponsor.sendValue(refundValue);\\n        }\\n    }\\n\\n    /**\\n    * @notice Calculate amount of refund\\n    * @param _policyId Policy id\\n    * @param _node Node or RESERVED_NODE if all nodes should be used\\n    */\\n    function calculateRefundValueInternal(bytes16 _policyId, address _node)\\n        internal view returns (uint256 refundValue)\\n    {\\n        refundValue = 0;\\n        Policy storage policy = policies[_policyId];\\n        require((policy.owner == msg.sender || policy.sponsor == msg.sender) && !policy.disabled);\\n        uint256 i = 0;\\n        for (; i < policy.arrangements.length; i++) {\\n            ArrangementInfo storage arrangement = policy.arrangements[i];\\n            if (arrangement.node == RESERVED_NODE || _node != RESERVED_NODE && _node != arrangement.node) {\\n                continue;\\n            }\\n            (uint256 nodeRefundValue,,) = calculateRefundValue(policy, arrangement);\\n            refundValue += nodeRefundValue;\\n            if (_node != RESERVED_NODE) {\\n               break;\\n            }\\n        }\\n        if (_node != RESERVED_NODE) {\\n            // arrangement not found\\n            require(i < policy.arrangements.length);\\n        }\\n    }\\n\\n    /**\\n    * @notice Revoke policy by the sponsor\\n    * @param _policyId Policy id\\n    */\\n    function revokePolicy(bytes16 _policyId) external returns (uint256 refundValue) {\\n        require(getPolicyOwner(_policyId) == msg.sender);\\n        return refundInternal(_policyId, RESERVED_NODE, true);\\n    }\\n\\n    /**\\n    * @notice Revoke arrangement by the sponsor\\n    * @param _policyId Policy id\\n    * @param _node Node that will be excluded\\n    */\\n    function revokeArrangement(bytes16 _policyId, address _node)\\n        external returns (uint256 refundValue)\\n    {\\n        require(_node != RESERVED_NODE);\\n        require(getPolicyOwner(_policyId) == msg.sender);\\n        return refundInternal(_policyId, _node, true);\\n    }\\n\\n    /**\\n    * @notice Get unsigned hash for revocation\\n    * @param _policyId Policy id\\n    * @param _node Node that will be excluded\\n    * @return Revocation hash, EIP191 version 0x45 ('E')\\n    */\\n    function getRevocationHash(bytes16 _policyId, address _node) public view returns (bytes32) {\\n        return SignatureVerifier.hashEIP191(abi.encodePacked(_policyId, _node), byte(0x45));\\n    }\\n\\n    /**\\n    * @notice Check correctness of signature\\n    * @param _policyId Policy id\\n    * @param _node Node that will be excluded, zero address if whole policy will be revoked\\n    * @param _signature Signature of owner\\n    */\\n    function checkOwnerSignature(bytes16 _policyId, address _node, bytes memory _signature) internal view {\\n        bytes32 hash = getRevocationHash(_policyId, _node);\\n        address recovered = SignatureVerifier.recover(hash, _signature);\\n        require(getPolicyOwner(_policyId) == recovered);\\n    }\\n\\n    /**\\n    * @notice Revoke policy or arrangement using owner's signature\\n    * @param _policyId Policy id\\n    * @param _node Node that will be excluded, zero address if whole policy will be revoked\\n    * @param _signature Signature of owner, EIP191 version 0x45 ('E')\\n    */\\n    function revoke(bytes16 _policyId, address _node, bytes calldata _signature)\\n        external returns (uint256 refundValue)\\n    {\\n        checkOwnerSignature(_policyId, _node, _signature);\\n        return refundInternal(_policyId, _node, true);\\n    }\\n\\n    /**\\n    * @notice Refund part of fee by the sponsor\\n    * @param _policyId Policy id\\n    */\\n    function refund(bytes16 _policyId) external {\\n        Policy storage policy = policies[_policyId];\\n        require(policy.owner == msg.sender || policy.sponsor == msg.sender);\\n        refundInternal(_policyId, RESERVED_NODE, false);\\n    }\\n\\n    /**\\n    * @notice Refund part of one node's fee by the sponsor\\n    * @param _policyId Policy id\\n    * @param _node Node address\\n    */\\n    function refund(bytes16 _policyId, address _node)\\n        external returns (uint256 refundValue)\\n    {\\n        require(_node != RESERVED_NODE);\\n        Policy storage policy = policies[_policyId];\\n        require(policy.owner == msg.sender || policy.sponsor == msg.sender);\\n        return refundInternal(_policyId, _node, false);\\n    }\\n\\n    /**\\n    * @notice Calculate amount of refund\\n    * @param _policyId Policy id\\n    */\\n    function calculateRefundValue(bytes16 _policyId)\\n        external view returns (uint256 refundValue)\\n    {\\n        return calculateRefundValueInternal(_policyId, RESERVED_NODE);\\n    }\\n\\n    /**\\n    * @notice Calculate amount of refund\\n    * @param _policyId Policy id\\n    * @param _node Node\\n    */\\n    function calculateRefundValue(bytes16 _policyId, address _node)\\n        external view returns (uint256 refundValue)\\n    {\\n        require(_node != RESERVED_NODE);\\n        return calculateRefundValueInternal(_policyId, _node);\\n    }\\n\\n    /**\\n    * @notice Get number of arrangements in the policy\\n    * @param _policyId Policy id\\n    */\\n    function getArrangementsLength(bytes16 _policyId) external view returns (uint256) {\\n        return policies[_policyId].arrangements.length;\\n    }\\n\\n    /**\\n    * @notice Get information about staker's fee rate\\n    * @param _node Address of staker\\n    * @param _period Period to get fee delta\\n    */\\n    function getNodeFeeDelta(address _node, uint16 _period)\\n        // TODO \\\"virtual\\\" only for tests, probably will be removed after #1512\\n        external view virtual returns (int256)\\n    {\\n        return nodes[_node].feeDelta[_period];\\n    }\\n\\n    /**\\n    * @notice Return the information about arrangement\\n    */\\n    function getArrangementInfo(bytes16 _policyId, uint256 _index)\\n    // TODO change to structure when ABIEncoderV2 is released (#1501)\\n//        public view returns (ArrangementInfo)\\n        external view returns (address node, uint256 indexOfDowntimePeriods, uint16 lastRefundedPeriod)\\n    {\\n        ArrangementInfo storage info = policies[_policyId].arrangements[_index];\\n        node = info.node;\\n        indexOfDowntimePeriods = info.indexOfDowntimePeriods;\\n        lastRefundedPeriod = info.lastRefundedPeriod;\\n    }\\n\\n\\n    /**\\n    * @dev Get Policy structure by delegatecall\\n    */\\n    function delegateGetPolicy(address _target, bytes16 _policyId)\\n        internal returns (Policy memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, this.policies.selector, 1, bytes32(_policyId), 0);\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /**\\n    * @dev Get ArrangementInfo structure by delegatecall\\n    */\\n    function delegateGetArrangementInfo(address _target, bytes16 _policyId, uint256 _index)\\n        internal returns (ArrangementInfo memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(\\n            _target, this.getArrangementInfo.selector, 2, bytes32(_policyId), bytes32(_index));\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /**\\n    * @dev Get NodeInfo structure by delegatecall\\n    */\\n    function delegateGetNodeInfo(address _target, address _node)\\n        internal returns (MemoryNodeInfo memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, this.nodes.selector, 1, bytes32(uint256(_node)), 0);\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /**\\n    * @dev Get feeRateRange structure by delegatecall\\n    */\\n    function delegateGetFeeRateRange(address _target) internal returns (Range memory result) {\\n        bytes32 memoryAddress = delegateGetData(_target, this.feeRateRange.selector, 0, 0, 0);\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n        Range memory rangeToCheck = delegateGetFeeRateRange(_testTarget);\\n        require(feeRateRange.min == rangeToCheck.min &&\\n            feeRateRange.defaultValue == rangeToCheck.defaultValue &&\\n            feeRateRange.max == rangeToCheck.max);\\n        Policy storage policy = policies[RESERVED_POLICY_ID];\\n        Policy memory policyToCheck = delegateGetPolicy(_testTarget, RESERVED_POLICY_ID);\\n        require(policyToCheck.sponsor == policy.sponsor &&\\n            policyToCheck.owner == policy.owner &&\\n            policyToCheck.feeRate == policy.feeRate &&\\n            policyToCheck.startTimestamp == policy.startTimestamp &&\\n            policyToCheck.endTimestamp == policy.endTimestamp &&\\n            policyToCheck.disabled == policy.disabled);\\n\\n        require(delegateGet(_testTarget, this.getArrangementsLength.selector, RESERVED_POLICY_ID) ==\\n            policy.arrangements.length);\\n        if (policy.arrangements.length > 0) {\\n            ArrangementInfo storage arrangement = policy.arrangements[0];\\n            ArrangementInfo memory arrangementToCheck = delegateGetArrangementInfo(\\n                _testTarget, RESERVED_POLICY_ID, 0);\\n            require(arrangementToCheck.node == arrangement.node &&\\n                arrangementToCheck.indexOfDowntimePeriods == arrangement.indexOfDowntimePeriods &&\\n                arrangementToCheck.lastRefundedPeriod == arrangement.lastRefundedPeriod);\\n        }\\n\\n        NodeInfo storage nodeInfo = nodes[RESERVED_NODE];\\n        MemoryNodeInfo memory nodeInfoToCheck = delegateGetNodeInfo(_testTarget, RESERVED_NODE);\\n        require(nodeInfoToCheck.fee == nodeInfo.fee &&\\n            nodeInfoToCheck.feeRate == nodeInfo.feeRate &&\\n            nodeInfoToCheck.previousFeePeriod == nodeInfo.previousFeePeriod &&\\n            nodeInfoToCheck.minFeeRate == nodeInfo.minFeeRate);\\n\\n        require(int256(delegateGet(_testTarget, this.getNodeFeeDelta.selector,\\n            bytes32(bytes20(RESERVED_NODE)), bytes32(uint256(11)))) == nodeInfo.feeDelta[11]);\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `finishUpgrade`\\n    function finishUpgrade(address _target) public override virtual {\\n        super.finishUpgrade(_target);\\n        // Create fake Policy and NodeInfo to use them in verifyState(address)\\n        Policy storage policy = policies[RESERVED_POLICY_ID];\\n        policy.sponsor = msg.sender;\\n        policy.owner = address(this);\\n        policy.startTimestamp = 1;\\n        policy.endTimestamp = 2;\\n        policy.feeRate = 3;\\n        policy.disabled = true;\\n        policy.arrangements.push(ArrangementInfo(RESERVED_NODE, 11, 22));\\n        NodeInfo storage nodeInfo = nodes[RESERVED_NODE];\\n        nodeInfo.fee = 100;\\n        nodeInfo.feeRate = 33;\\n        nodeInfo.previousFeePeriod = 44;\\n        nodeInfo.feeDelta[11] = 55;\\n        nodeInfo.minFeeRate = 777;\\n    }\\n}\\n\"\r\n    },\r\n    \"zeppelin/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proxy/Dispatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"../../zeppelin/utils/Address.sol\\\";\\n\\n\\n/**\\n* @notice ERC897 - ERC DelegateProxy\\n*/\\ninterface ERCProxy {\\n    function proxyType() external pure returns (uint256);\\n    function implementation() external view returns (address);\\n}\\n\\n\\n/**\\n* @notice Proxying requests to other contracts.\\n* Client should use ABI of real contract and address of this contract\\n*/\\ncontract Dispatcher is Upgradeable, ERCProxy {\\n    using Address for address;\\n\\n    event Upgraded(address indexed from, address indexed to, address owner);\\n    event RolledBack(address indexed from, address indexed to, address owner);\\n\\n    /**\\n    * @dev Set upgrading status before and after operations\\n    */\\n    modifier upgrading()\\n    {\\n        isUpgrade = UPGRADE_TRUE;\\n        _;\\n        isUpgrade = UPGRADE_FALSE;\\n    }\\n\\n    /**\\n    * @param _target Target contract address\\n    */\\n    constructor(address _target) upgrading {\\n        require(_target.isContract());\\n        // Checks that target contract inherits Dispatcher state\\n        verifyState(_target);\\n        // `verifyState` must work with its contract\\n        verifyUpgradeableState(_target, _target);\\n        target = _target;\\n        finishUpgrade();\\n        emit Upgraded(address(0), _target, msg.sender);\\n    }\\n\\n    //------------------------ERC897------------------------\\n    /**\\n     * @notice ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\\n     */\\n    function proxyType() external pure override returns (uint256) {\\n        return 2;\\n    }\\n\\n    /**\\n     * @notice ERC897, gets the address of the implementation where every call will be delegated\\n     */\\n    function implementation() external view override returns (address) {\\n        return target;\\n    }\\n    //------------------------------------------------------------\\n\\n    /**\\n    * @notice Verify new contract storage and upgrade target\\n    * @param _target New target contract address\\n    */\\n    function upgrade(address _target) public onlyOwner upgrading {\\n        require(_target.isContract());\\n        // Checks that target contract has \\\"correct\\\" (as much as possible) state layout\\n        verifyState(_target);\\n        //`verifyState` must work with its contract\\n        verifyUpgradeableState(_target, _target);\\n        if (target.isContract()) {\\n            verifyUpgradeableState(target, _target);\\n        }\\n        previousTarget = target;\\n        target = _target;\\n        finishUpgrade();\\n        emit Upgraded(previousTarget, _target, msg.sender);\\n    }\\n\\n    /**\\n    * @notice Rollback to previous target\\n    * @dev Test storage carefully before upgrade again after rollback\\n    */\\n    function rollback() public onlyOwner upgrading {\\n        require(previousTarget.isContract());\\n        emit RolledBack(target, previousTarget, msg.sender);\\n        // should be always true because layout previousTarget -> target was already checked\\n        // but `verifyState` is not 100% accurate so check again\\n        verifyState(previousTarget);\\n        if (target.isContract()) {\\n            verifyUpgradeableState(previousTarget, target);\\n        }\\n        target = previousTarget;\\n        previousTarget = address(0);\\n        finishUpgrade();\\n    }\\n\\n    /**\\n    * @dev Call verifyState method for Upgradeable contract\\n    */\\n    function verifyUpgradeableState(address _from, address _to) private {\\n        (bool callSuccess,) = _from.delegatecall(abi.encodeWithSelector(this.verifyState.selector, _to));\\n        require(callSuccess);\\n    }\\n\\n    /**\\n    * @dev Call finishUpgrade method from the Upgradeable contract\\n    */\\n    function finishUpgrade() private {\\n        (bool callSuccess,) = target.delegatecall(abi.encodeWithSelector(this.finishUpgrade.selector, target));\\n        require(callSuccess);\\n    }\\n\\n    function verifyState(address _testTarget) public override onlyWhileUpgrading {\\n        //checks equivalence accessing state through new contract and current storage\\n        require(address(uint160(delegateGet(_testTarget, this.owner.selector))) == owner());\\n        require(address(uint160(delegateGet(_testTarget, this.target.selector))) == target);\\n        require(address(uint160(delegateGet(_testTarget, this.previousTarget.selector))) == previousTarget);\\n        require(uint8(delegateGet(_testTarget, this.isUpgrade.selector)) == isUpgrade);\\n    }\\n\\n    /**\\n    * @dev Override function using empty code because no reason to call this function in Dispatcher\\n    */\\n    function finishUpgrade(address) public override {}\\n\\n    /**\\n    * @dev Receive function sends empty request to the target contract\\n    */\\n    receive() external payable {\\n        assert(target.isContract());\\n        // execute receive function from target contract using storage of the dispatcher\\n        (bool callSuccess,) = target.delegatecall(\\\"\\\");\\n        if (!callSuccess) {\\n            revert();\\n        }\\n    }\\n\\n    /**\\n    * @dev Fallback function sends all requests to the target contract\\n    */\\n    fallback() external payable {\\n        assert(target.isContract());\\n        // execute requested function from target contract using storage of the dispatcher\\n        (bool callSuccess,) = target.delegatecall(msg.data);\\n        if (callSuccess) {\\n            // copy result of the request to the return data\\n            // we can use the second return value from `delegatecall` (bytes memory)\\n            // but it will consume a little more gas\\n            assembly {\\n                returndatacopy(0x0, 0x0, returndatasize())\\n                return(0x0, returndatasize())\\n            }\\n        } else {\\n            revert();\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/staking_contracts/AbstractStakingContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../zeppelin/ownership/Ownable.sol\\\";\\nimport \\\"../../zeppelin/utils/Address.sol\\\";\\nimport \\\"../../zeppelin/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./StakingInterface.sol\\\";\\nimport \\\"../../zeppelin/proxy/Initializable.sol\\\";\\n\\n\\n/**\\n* @notice Router for accessing interface contract\\n*/\\ncontract StakingInterfaceRouter is Ownable {\\n    BaseStakingInterface public target;\\n\\n    /**\\n    * @param _target Address of the interface contract\\n    */\\n    constructor(BaseStakingInterface _target) {\\n        require(address(_target.token()) != address(0));\\n        target = _target;\\n    }\\n\\n    /**\\n    * @notice Upgrade interface\\n    * @param _target New contract address\\n    */\\n    function upgrade(BaseStakingInterface _target) external onlyOwner {\\n        require(address(_target.token()) != address(0));\\n        target = _target;\\n    }\\n\\n}\\n\\n\\n/**\\n* @notice Internal base class for AbstractStakingContract and InitializableStakingContract\\n*/\\nabstract contract RawStakingContract {\\n    using Address for address;\\n\\n    /**\\n    * @dev Returns address of StakingInterfaceRouter\\n    */\\n    function router() public view virtual returns (StakingInterfaceRouter);\\n\\n    /**\\n    * @dev Checks permission for calling fallback function\\n    */\\n    function isFallbackAllowed() public virtual returns (bool);\\n\\n    /**\\n    * @dev Withdraw tokens from staking contract\\n    */\\n    function withdrawTokens(uint256 _value) public virtual;\\n\\n    /**\\n    * @dev Withdraw ETH from staking contract\\n    */\\n    function withdrawETH() public virtual;\\n\\n    receive() external payable {}\\n\\n    /**\\n    * @dev Function sends all requests to the target contract\\n    */\\n    fallback() external payable {\\n        require(isFallbackAllowed());\\n        address target = address(router().target());\\n        require(target.isContract());\\n        // execute requested function from target contract\\n        (bool callSuccess, ) = target.delegatecall(msg.data);\\n        if (callSuccess) {\\n            // copy result of the request to the return data\\n            // we can use the second return value from `delegatecall` (bytes memory)\\n            // but it will consume a little more gas\\n            assembly {\\n                returndatacopy(0x0, 0x0, returndatasize())\\n                return(0x0, returndatasize())\\n            }\\n        } else {\\n            revert();\\n        }\\n    }\\n}\\n\\n\\n/**\\n* @notice Base class for any staking contract (not usable with openzeppelin proxy)\\n* @dev Implement `isFallbackAllowed()` or override fallback function\\n* Implement `withdrawTokens(uint256)` and `withdrawETH()` functions\\n*/\\nabstract contract AbstractStakingContract is RawStakingContract {\\n\\n    StakingInterfaceRouter immutable router_;\\n    NuCypherToken public immutable token;\\n\\n    /**\\n    * @param _router Interface router contract address\\n    */\\n    constructor(StakingInterfaceRouter _router) {\\n        router_ = _router;\\n        NuCypherToken localToken = _router.target().token();\\n        require(address(localToken) != address(0));\\n        token = localToken;\\n    }\\n\\n    /**\\n    * @dev Returns address of StakingInterfaceRouter\\n    */\\n    function router() public view override returns (StakingInterfaceRouter) {\\n        return router_;\\n    }\\n\\n}\\n\\n\\n/**\\n* @notice Base class for any staking contract usable with openzeppelin proxy\\n* @dev Implement `isFallbackAllowed()` or override fallback function\\n* Implement `withdrawTokens(uint256)` and `withdrawETH()` functions\\n*/\\nabstract contract InitializableStakingContract is Initializable, RawStakingContract {\\n\\n    StakingInterfaceRouter router_;\\n    NuCypherToken public token;\\n\\n    /**\\n    * @param _router Interface router contract address\\n    */\\n    function initialize(StakingInterfaceRouter _router) public initializer {\\n        router_ = _router;\\n        NuCypherToken localToken = _router.target().token();\\n        require(address(localToken) != address(0));\\n        token = localToken;\\n    }\\n\\n    /**\\n    * @dev Returns address of StakingInterfaceRouter\\n    */\\n    function router() public view override returns (StakingInterfaceRouter) {\\n        return router_;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/staking_contracts/StakingInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"./AbstractStakingContract.sol\\\";\\nimport \\\"../NuCypherToken.sol\\\";\\nimport \\\"../StakingEscrow.sol\\\";\\nimport \\\"../PolicyManager.sol\\\";\\nimport \\\"../WorkLock.sol\\\";\\n\\n\\n/**\\n* @notice Base StakingInterface\\n*/\\ncontract BaseStakingInterface {\\n\\n    address public immutable stakingInterfaceAddress;\\n    NuCypherToken public immutable token;\\n    StakingEscrow public immutable escrow;\\n    PolicyManager public immutable policyManager;\\n    WorkLock public immutable workLock;\\n\\n    /**\\n    * @notice Constructor sets addresses of the contracts\\n    * @param _token Token contract\\n    * @param _escrow Escrow contract\\n    * @param _policyManager PolicyManager contract\\n    * @param _workLock WorkLock contract\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        StakingEscrow _escrow,\\n        PolicyManager _policyManager,\\n        WorkLock _workLock\\n    ) {\\n        require(_token.totalSupply() > 0 &&\\n            _escrow.secondsPerPeriod() > 0 &&\\n            _policyManager.secondsPerPeriod() > 0 &&\\n            // in case there is no worklock contract\\n            (address(_workLock) == address(0) || _workLock.boostingRefund() > 0));\\n        token = _token;\\n        escrow = _escrow;\\n        policyManager = _policyManager;\\n        workLock = _workLock;\\n        stakingInterfaceAddress = address(this);\\n    }\\n\\n    /**\\n    * @dev Checks executing through delegate call\\n    */\\n    modifier onlyDelegateCall()\\n    {\\n        require(stakingInterfaceAddress != address(this));\\n        _;\\n    }\\n\\n    /**\\n    * @dev Checks the existence of the worklock contract\\n    */\\n    modifier workLockSet()\\n    {\\n        require(address(workLock) != address(0));\\n        _;\\n    }\\n\\n}\\n\\n\\n/**\\n* @notice Interface for accessing main contracts from a staking contract\\n* @dev All methods must be stateless because this code will be executed by delegatecall call, use immutable fields.\\n* @dev |v1.5.2|\\n*/\\ncontract StakingInterface is BaseStakingInterface {\\n\\n    event DepositedAsStaker(address indexed sender, uint256 value, uint16 periods);\\n    event WithdrawnAsStaker(address indexed sender, uint256 value);\\n    event DepositedAndIncreased(address indexed sender, uint256 index, uint256 value);\\n    event LockedAndCreated(address indexed sender, uint256 value, uint16 periods);\\n    event LockedAndIncreased(address indexed sender, uint256 index, uint256 value);\\n    event Divided(address indexed sender, uint256 index, uint256 newValue, uint16 periods);\\n    event Merged(address indexed sender, uint256 index1, uint256 index2);\\n    event Minted(address indexed sender);\\n    event PolicyFeeWithdrawn(address indexed sender, uint256 value);\\n    event MinFeeRateSet(address indexed sender, uint256 value);\\n    event ReStakeSet(address indexed sender, bool reStake);\\n    event ReStakeLocked(address indexed sender, uint16 lockUntilPeriod);\\n    event WorkerBonded(address indexed sender, address worker);\\n    event Prolonged(address indexed sender, uint256 index, uint16 periods);\\n    event WindDownSet(address indexed sender, bool windDown);\\n    event Bid(address indexed sender, uint256 depositedETH);\\n    event Claimed(address indexed sender, uint256 claimedTokens);\\n    event Refund(address indexed sender, uint256 refundETH);\\n    event BidCanceled(address indexed sender);\\n    event CompensationWithdrawn(address indexed sender);\\n\\n    /**\\n    * @notice Constructor sets addresses of the contracts\\n    * @param _token Token contract\\n    * @param _escrow Escrow contract\\n    * @param _policyManager PolicyManager contract\\n    * @param _workLock WorkLock contract\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        StakingEscrow _escrow,\\n        PolicyManager _policyManager,\\n        WorkLock _workLock\\n    )\\n        BaseStakingInterface(_token, _escrow, _policyManager, _workLock)\\n    {\\n    }\\n\\n    /**\\n    * @notice Bond worker in the staking escrow\\n    * @param _worker Worker address\\n    */\\n    function bondWorker(address _worker) public onlyDelegateCall {\\n        escrow.bondWorker(_worker);\\n        emit WorkerBonded(msg.sender, _worker);\\n    }\\n\\n    /**\\n    * @notice Set `reStake` parameter in the staking escrow\\n    * @param _reStake Value for parameter\\n    */\\n    function setReStake(bool _reStake) public onlyDelegateCall {\\n        escrow.setReStake(_reStake);\\n        emit ReStakeSet(msg.sender, _reStake);\\n    }\\n\\n    /**\\n    * @notice Lock `reStake` parameter in the staking escrow\\n    * @param _lockReStakeUntilPeriod Can't change `reStake` value until this period\\n    */\\n    function lockReStake(uint16 _lockReStakeUntilPeriod) public onlyDelegateCall {\\n        escrow.lockReStake(_lockReStakeUntilPeriod);\\n        emit ReStakeLocked(msg.sender, _lockReStakeUntilPeriod);\\n    }\\n\\n    /**\\n    * @notice Deposit tokens to the staking escrow\\n    * @param _value Amount of token to deposit\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function depositAsStaker(uint256 _value, uint16 _periods) public onlyDelegateCall {\\n        require(token.balanceOf(address(this)) >= _value);\\n        token.approve(address(escrow), _value);\\n        escrow.deposit(address(this), _value, _periods);\\n        emit DepositedAsStaker(msg.sender, _value, _periods);\\n    }\\n\\n    /**\\n    * @notice Deposit tokens to the staking escrow\\n    * @param _index Index of the sub-stake\\n    * @param _value Amount of tokens which will be locked\\n    */\\n    function depositAndIncrease(uint256 _index, uint256 _value) public onlyDelegateCall {\\n        require(token.balanceOf(address(this)) >= _value);\\n        token.approve(address(escrow), _value);\\n        escrow.depositAndIncrease(_index, _value);\\n        emit DepositedAndIncreased(msg.sender, _index, _value);\\n    }\\n\\n    /**\\n    * @notice Withdraw available amount of tokens from the staking escrow to the staking contract\\n    * @param _value Amount of token to withdraw\\n    */\\n    function withdrawAsStaker(uint256 _value) public onlyDelegateCall {\\n        escrow.withdraw(_value);\\n        emit WithdrawnAsStaker(msg.sender, _value);\\n    }\\n\\n    /**\\n    * @notice Lock some tokens in the staking escrow\\n    * @param _value Amount of tokens which should lock\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function lockAndCreate(uint256 _value, uint16 _periods) public onlyDelegateCall {\\n        escrow.lockAndCreate(_value, _periods);\\n        emit LockedAndCreated(msg.sender, _value, _periods);\\n    }\\n\\n    /**\\n    * @notice Lock some tokens in the staking escrow\\n    * @param _index Index of the sub-stake\\n    * @param _value Amount of tokens which will be locked\\n    */\\n    function lockAndIncrease(uint256 _index, uint256 _value) public onlyDelegateCall {\\n        escrow.lockAndIncrease(_index, _value);\\n        emit LockedAndIncreased(msg.sender, _index, _value);\\n    }\\n\\n    /**\\n    * @notice Divide stake into two parts\\n    * @param _index Index of stake\\n    * @param _newValue New stake value\\n    * @param _periods Amount of periods for extending stake\\n    */\\n    function divideStake(uint256 _index, uint256 _newValue, uint16 _periods) public onlyDelegateCall {\\n        escrow.divideStake(_index, _newValue, _periods);\\n        emit Divided(msg.sender, _index, _newValue, _periods);\\n    }\\n\\n    /**\\n    * @notice Merge two sub-stakes into one\\n    * @param _index1 Index of the first sub-stake\\n    * @param _index2 Index of the second sub-stake\\n    */\\n    function mergeStake(uint256 _index1, uint256 _index2) public onlyDelegateCall {\\n        escrow.mergeStake(_index1, _index2);\\n        emit Merged(msg.sender, _index1, _index2);\\n    }\\n\\n    /**\\n    * @notice Mint tokens in the staking escrow\\n    */\\n    function mint() public onlyDelegateCall {\\n        escrow.mint();\\n        emit Minted(msg.sender);\\n    }\\n\\n    /**\\n    * @notice Withdraw available policy fees from the policy manager to the staking contract\\n    */\\n    function withdrawPolicyFee() public onlyDelegateCall {\\n        uint256 value = policyManager.withdraw();\\n        emit PolicyFeeWithdrawn(msg.sender, value);\\n    }\\n\\n    /**\\n    * @notice Set the minimum fee that the staker will accept in the policy manager contract\\n    */\\n    function setMinFeeRate(uint256 _minFeeRate) public onlyDelegateCall {\\n        policyManager.setMinFeeRate(_minFeeRate);\\n        emit MinFeeRateSet(msg.sender, _minFeeRate);\\n    }\\n\\n\\n    /**\\n    * @notice Prolong active sub stake\\n    * @param _index Index of the sub stake\\n    * @param _periods Amount of periods for extending sub stake\\n    */\\n    function prolongStake(uint256 _index, uint16 _periods) public onlyDelegateCall {\\n        escrow.prolongStake(_index, _periods);\\n        emit Prolonged(msg.sender, _index, _periods);\\n    }\\n\\n    /**\\n    * @notice Set `windDown` parameter in the staking escrow\\n    * @param _windDown Value for parameter\\n    */\\n    function setWindDown(bool _windDown) public onlyDelegateCall {\\n        escrow.setWindDown(_windDown);\\n        emit WindDownSet(msg.sender, _windDown);\\n    }\\n\\n    /**\\n    * @notice Bid for tokens by transferring ETH\\n    */\\n    function bid(uint256 _value) public payable onlyDelegateCall workLockSet {\\n        workLock.bid{value: _value}();\\n        emit Bid(msg.sender, _value);\\n    }\\n\\n    /**\\n    * @notice Cancel bid and refund deposited ETH\\n    */\\n    function cancelBid() public onlyDelegateCall workLockSet {\\n        workLock.cancelBid();\\n        emit BidCanceled(msg.sender);\\n    }\\n\\n    /**\\n    * @notice Withdraw compensation after force refund\\n    */\\n    function withdrawCompensation() public onlyDelegateCall workLockSet {\\n        workLock.withdrawCompensation();\\n        emit CompensationWithdrawn(msg.sender);\\n    }\\n\\n    /**\\n    * @notice Claimed tokens will be deposited and locked as stake in the StakingEscrow contract\\n    */\\n    function claim() public onlyDelegateCall workLockSet {\\n        uint256 claimedTokens = workLock.claim();\\n        emit Claimed(msg.sender, claimedTokens);\\n    }\\n\\n    /**\\n    * @notice Refund ETH for the completed work\\n    */\\n    function refund() public onlyDelegateCall workLockSet {\\n        uint256 refundETH = workLock.refund();\\n        emit Refund(msg.sender, refundETH);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/WorkLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"../zeppelin/math/SafeMath.sol\\\";\\nimport \\\"../zeppelin/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../zeppelin/utils/Address.sol\\\";\\nimport \\\"../zeppelin/ownership/Ownable.sol\\\";\\nimport \\\"./NuCypherToken.sol\\\";\\nimport \\\"./StakingEscrow.sol\\\";\\nimport \\\"./lib/AdditionalMath.sol\\\";\\n\\n\\n/**\\n* @notice The WorkLock distribution contract\\n*/\\ncontract WorkLock is Ownable {\\n    using SafeERC20 for NuCypherToken;\\n    using SafeMath for uint256;\\n    using AdditionalMath for uint256;\\n    using Address for address payable;\\n    using Address for address;\\n\\n    event Deposited(address indexed sender, uint256 value);\\n    event Bid(address indexed sender, uint256 depositedETH);\\n    event Claimed(address indexed sender, uint256 claimedTokens);\\n    event Refund(address indexed sender, uint256 refundETH, uint256 completedWork);\\n    event Canceled(address indexed sender, uint256 value);\\n    event BiddersChecked(address indexed sender, uint256 startIndex, uint256 endIndex);\\n    event ForceRefund(address indexed sender, address indexed bidder, uint256 refundETH);\\n    event CompensationWithdrawn(address indexed sender, uint256 value);\\n    event Shutdown(address indexed sender);\\n\\n    struct WorkInfo {\\n        uint256 depositedETH;\\n        uint256 completedWork;\\n        bool claimed;\\n        uint128 index;\\n    }\\n\\n    uint16 public constant SLOWING_REFUND = 100;\\n    uint256 private constant MAX_ETH_SUPPLY = 2e10 ether;\\n\\n    NuCypherToken public immutable token;\\n    StakingEscrow public immutable escrow;\\n\\n    /*\\n    * @dev WorkLock calculations:\\n    * bid = minBid + bonusETHPart\\n    * bonusTokenSupply = tokenSupply - bidders.length * minAllowableLockedTokens\\n    * bonusDepositRate = bonusTokenSupply / bonusETHSupply\\n    * claimedTokens = minAllowableLockedTokens + bonusETHPart * bonusDepositRate\\n    * bonusRefundRate = bonusDepositRate * SLOWING_REFUND / boostingRefund\\n    * refundETH = completedWork / refundRate\\n    */\\n    uint256 public immutable boostingRefund;\\n    uint256 public immutable minAllowedBid;\\n    uint16 public immutable stakingPeriods;\\n    // copy from the escrow contract\\n    uint256 public immutable maxAllowableLockedTokens;\\n    uint256 public immutable minAllowableLockedTokens;\\n\\n    uint256 public tokenSupply;\\n    uint256 public startBidDate;\\n    uint256 public endBidDate;\\n    uint256 public endCancellationDate;\\n\\n    uint256 public bonusETHSupply;\\n    mapping(address => WorkInfo) public workInfo;\\n    mapping(address => uint256) public compensation;\\n\\n    address[] public bidders;\\n    // if value == bidders.length then WorkLock is fully checked\\n    uint256 public nextBidderToCheck;\\n\\n    /**\\n    * @dev Checks timestamp regarding cancellation window\\n    */\\n    modifier afterCancellationWindow()\\n    {\\n        require(block.timestamp >= endCancellationDate,\\n            \\\"Operation is allowed when cancellation phase is over\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @param _token Token contract\\n    * @param _escrow Escrow contract\\n    * @param _startBidDate Timestamp when bidding starts\\n    * @param _endBidDate Timestamp when bidding will end\\n    * @param _endCancellationDate Timestamp when cancellation will ends\\n    * @param _boostingRefund Coefficient to boost refund ETH\\n    * @param _stakingPeriods Amount of periods during which tokens will be locked after claiming\\n    * @param _minAllowedBid Minimum allowed ETH amount for bidding\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        StakingEscrow _escrow,\\n        uint256 _startBidDate,\\n        uint256 _endBidDate,\\n        uint256 _endCancellationDate,\\n        uint256 _boostingRefund,\\n        uint16 _stakingPeriods,\\n        uint256 _minAllowedBid\\n    ) {\\n        uint256 totalSupply = _token.totalSupply();\\n        require(totalSupply > 0 &&                              // token contract is deployed and accessible\\n            _escrow.secondsPerPeriod() > 0 &&                   // escrow contract is deployed and accessible\\n            _escrow.token() == _token &&                        // same token address for worklock and escrow\\n            _endBidDate > _startBidDate &&                      // bidding period lasts some time\\n            _endBidDate > block.timestamp &&                    // there is time to make a bid\\n            _endCancellationDate >= _endBidDate &&              // cancellation window includes bidding\\n            _minAllowedBid > 0 &&                               // min allowed bid was set\\n            _boostingRefund > 0 &&                              // boosting coefficient was set\\n            _stakingPeriods >= _escrow.minLockedPeriods());     // staking duration is consistent with escrow contract\\n        // worst case for `ethToWork()` and `workToETH()`,\\n        // when ethSupply == MAX_ETH_SUPPLY and tokenSupply == totalSupply\\n        require(MAX_ETH_SUPPLY * totalSupply * SLOWING_REFUND / MAX_ETH_SUPPLY / totalSupply == SLOWING_REFUND &&\\n            MAX_ETH_SUPPLY * totalSupply * _boostingRefund / MAX_ETH_SUPPLY / totalSupply == _boostingRefund);\\n\\n        token = _token;\\n        escrow = _escrow;\\n        startBidDate = _startBidDate;\\n        endBidDate = _endBidDate;\\n        endCancellationDate = _endCancellationDate;\\n        boostingRefund = _boostingRefund;\\n        stakingPeriods = _stakingPeriods;\\n        minAllowedBid = _minAllowedBid;\\n        maxAllowableLockedTokens = _escrow.maxAllowableLockedTokens();\\n        minAllowableLockedTokens = _escrow.minAllowableLockedTokens();\\n    }\\n\\n    /**\\n    * @notice Deposit tokens to contract\\n    * @param _value Amount of tokens to transfer\\n    */\\n    function tokenDeposit(uint256 _value) external {\\n        require(block.timestamp < endBidDate, \\\"Can't deposit more tokens after end of bidding\\\");\\n        token.safeTransferFrom(msg.sender, address(this), _value);\\n        tokenSupply += _value;\\n        emit Deposited(msg.sender, _value);\\n    }\\n\\n    /**\\n    * @notice Calculate amount of tokens that will be get for specified amount of ETH\\n    * @dev This value will be fixed only after end of bidding\\n    */\\n    function ethToTokens(uint256 _ethAmount) public view returns (uint256) {\\n        if (_ethAmount < minAllowedBid) {\\n            return 0;\\n        }\\n\\n        // when all participants bid with the same minimum amount of eth\\n        if (bonusETHSupply == 0) {\\n            return tokenSupply / bidders.length;\\n        }\\n\\n        uint256 bonusETH = _ethAmount - minAllowedBid;\\n        uint256 bonusTokenSupply = tokenSupply - bidders.length * minAllowableLockedTokens;\\n        return minAllowableLockedTokens + bonusETH.mul(bonusTokenSupply).div(bonusETHSupply);\\n    }\\n\\n    /**\\n    * @notice Calculate amount of work that need to be done to refund specified amount of ETH\\n    */\\n    function ethToWork(uint256 _ethAmount, uint256 _tokenSupply, uint256 _ethSupply)\\n        internal view returns (uint256)\\n    {\\n        return _ethAmount.mul(_tokenSupply).mul(SLOWING_REFUND).divCeil(_ethSupply.mul(boostingRefund));\\n    }\\n\\n    /**\\n    * @notice Calculate amount of work that need to be done to refund specified amount of ETH\\n    * @dev This value will be fixed only after end of bidding\\n    * @param _ethToReclaim Specified sum of ETH staker wishes to reclaim following completion of work\\n    * @param _restOfDepositedETH Remaining ETH in staker's deposit once ethToReclaim sum has been subtracted\\n    * @dev _ethToReclaim + _restOfDepositedETH = depositedETH\\n    */\\n    function ethToWork(uint256 _ethToReclaim, uint256 _restOfDepositedETH) internal view returns (uint256) {\\n\\n        uint256 baseETHSupply = bidders.length * minAllowedBid;\\n        // when all participants bid with the same minimum amount of eth\\n        if (bonusETHSupply == 0) {\\n            return ethToWork(_ethToReclaim, tokenSupply, baseETHSupply);\\n        }\\n\\n        uint256 baseETH = 0;\\n        uint256 bonusETH = 0;\\n\\n        // If the staker's total remaining deposit (including the specified sum of ETH to reclaim)\\n        // is lower than the minimum bid size,\\n        // then only the base part is used to calculate the work required to reclaim ETH\\n        if (_ethToReclaim + _restOfDepositedETH <= minAllowedBid) {\\n            baseETH = _ethToReclaim;\\n\\n        // If the staker's remaining deposit (not including the specified sum of ETH to reclaim)\\n        // is still greater than the minimum bid size,\\n        // then only the bonus part is used to calculate the work required to reclaim ETH\\n        } else if (_restOfDepositedETH >= minAllowedBid) {\\n            bonusETH = _ethToReclaim;\\n\\n        // If the staker's remaining deposit (not including the specified sum of ETH to reclaim)\\n        // is lower than the minimum bid size,\\n        // then both the base and bonus parts must be used to calculate the work required to reclaim ETH\\n        } else {\\n            bonusETH = _ethToReclaim + _restOfDepositedETH - minAllowedBid;\\n            baseETH = _ethToReclaim - bonusETH;\\n        }\\n\\n        uint256 baseTokenSupply = bidders.length * minAllowableLockedTokens;\\n        uint256 work = 0;\\n        if (baseETH > 0) {\\n            work = ethToWork(baseETH, baseTokenSupply, baseETHSupply);\\n        }\\n\\n        if (bonusETH > 0) {\\n            uint256 bonusTokenSupply = tokenSupply - baseTokenSupply;\\n            work += ethToWork(bonusETH, bonusTokenSupply, bonusETHSupply);\\n        }\\n\\n        return work;\\n    }\\n\\n    /**\\n    * @notice Calculate amount of work that need to be done to refund specified amount of ETH\\n    * @dev This value will be fixed only after end of bidding\\n    */\\n    function ethToWork(uint256 _ethAmount) public view returns (uint256) {\\n        return ethToWork(_ethAmount, 0);\\n    }\\n\\n    /**\\n    * @notice Calculate amount of ETH that will be refund for completing specified amount of work\\n    */\\n    function workToETH(uint256 _completedWork, uint256 _ethSupply, uint256 _tokenSupply)\\n        internal view returns (uint256)\\n    {\\n        return _completedWork.mul(_ethSupply).mul(boostingRefund).div(_tokenSupply.mul(SLOWING_REFUND));\\n    }\\n\\n    /**\\n    * @notice Calculate amount of ETH that will be refund for completing specified amount of work\\n    * @dev This value will be fixed only after end of bidding\\n    */\\n    function workToETH(uint256 _completedWork, uint256 _depositedETH) public view returns (uint256) {\\n        uint256 baseETHSupply = bidders.length * minAllowedBid;\\n        // when all participants bid with the same minimum amount of eth\\n        if (bonusETHSupply == 0) {\\n            return workToETH(_completedWork, baseETHSupply, tokenSupply);\\n        }\\n\\n        uint256 bonusWork = 0;\\n        uint256 bonusETH = 0;\\n        uint256 baseTokenSupply = bidders.length * minAllowableLockedTokens;\\n\\n        if (_depositedETH > minAllowedBid) {\\n            bonusETH = _depositedETH - minAllowedBid;\\n            uint256 bonusTokenSupply = tokenSupply - baseTokenSupply;\\n            bonusWork = ethToWork(bonusETH, bonusTokenSupply, bonusETHSupply);\\n\\n            if (_completedWork <= bonusWork) {\\n                return workToETH(_completedWork, bonusETHSupply, bonusTokenSupply);\\n            }\\n        }\\n\\n        _completedWork -= bonusWork;\\n        return bonusETH + workToETH(_completedWork, baseETHSupply, baseTokenSupply);\\n    }\\n\\n    /**\\n    * @notice Get remaining work to full refund\\n    */\\n    function getRemainingWork(address _bidder) external view returns (uint256) {\\n        WorkInfo storage info = workInfo[_bidder];\\n        uint256 completedWork = escrow.getCompletedWork(_bidder).sub(info.completedWork);\\n        uint256 remainingWork = ethToWork(info.depositedETH);\\n        if (remainingWork <= completedWork) {\\n            return 0;\\n        }\\n        return remainingWork - completedWork;\\n    }\\n\\n    /**\\n    * @notice Get length of bidders array\\n    */\\n    function getBiddersLength() external view returns (uint256) {\\n        return bidders.length;\\n    }\\n\\n    /**\\n    * @notice Bid for tokens by transferring ETH\\n    */\\n    function bid() external payable {\\n        require(block.timestamp >= startBidDate, \\\"Bidding is not open yet\\\");\\n        require(block.timestamp < endBidDate, \\\"Bidding is already finished\\\");\\n        WorkInfo storage info = workInfo[msg.sender];\\n\\n        // first bid\\n        if (info.depositedETH == 0) {\\n            require(msg.value >= minAllowedBid, \\\"Bid must be at least minimum\\\");\\n            require(bidders.length < tokenSupply / minAllowableLockedTokens, \\\"Not enough tokens for more bidders\\\");\\n            info.index = uint128(bidders.length);\\n            bidders.push(msg.sender);\\n            bonusETHSupply = bonusETHSupply.add(msg.value - minAllowedBid);\\n        } else {\\n            bonusETHSupply = bonusETHSupply.add(msg.value);\\n        }\\n\\n        info.depositedETH = info.depositedETH.add(msg.value);\\n        emit Bid(msg.sender, msg.value);\\n    }\\n\\n    /**\\n    * @notice Cancel bid and refund deposited ETH\\n    */\\n    function cancelBid() external {\\n        require(block.timestamp < endCancellationDate,\\n            \\\"Cancellation allowed only during cancellation window\\\");\\n        WorkInfo storage info = workInfo[msg.sender];\\n        require(info.depositedETH > 0, \\\"No bid to cancel\\\");\\n        require(!info.claimed, \\\"Tokens are already claimed\\\");\\n        uint256 refundETH = info.depositedETH;\\n        info.depositedETH = 0;\\n\\n        // remove from bidders array, move last bidder to the empty place\\n        uint256 lastIndex = bidders.length - 1;\\n        if (info.index != lastIndex) {\\n            address lastBidder = bidders[lastIndex];\\n            bidders[info.index] = lastBidder;\\n            workInfo[lastBidder].index = info.index;\\n        }\\n        bidders.pop();\\n\\n        if (refundETH > minAllowedBid) {\\n            bonusETHSupply = bonusETHSupply.sub(refundETH - minAllowedBid);\\n        }\\n        msg.sender.sendValue(refundETH);\\n        emit Canceled(msg.sender, refundETH);\\n    }\\n\\n    /**\\n    * @notice Cancels distribution, makes possible to retrieve all bids and owner gets all tokens\\n    */\\n    function shutdown() external onlyOwner {\\n        require(!isClaimingAvailable(), \\\"Claiming has already been enabled\\\");\\n        internalShutdown();\\n    }\\n\\n    /**\\n    * @notice Cancels distribution, makes possible to retrieve all bids and owner gets all tokens\\n    */\\n    function internalShutdown() internal {\\n        startBidDate = 0;\\n        endBidDate = 0;\\n        endCancellationDate = uint256(0) - 1; // \\\"infinite\\\" cancellation window\\n        token.safeTransfer(owner(), tokenSupply);\\n        emit Shutdown(msg.sender);\\n    }\\n\\n    /**\\n    * @notice Make force refund to bidders who can get tokens more than maximum allowed\\n    * @param _biddersForRefund Sorted list of unique bidders. Only bidders who must receive a refund\\n    */\\n    function forceRefund(address payable[] calldata _biddersForRefund) external afterCancellationWindow {\\n        require(nextBidderToCheck != bidders.length, \\\"Bidders have already been checked\\\");\\n\\n        uint256 length = _biddersForRefund.length;\\n        require(length > 0, \\\"Must be at least one bidder for a refund\\\");\\n\\n        uint256 minNumberOfBidders = tokenSupply.divCeil(maxAllowableLockedTokens);\\n        if (bidders.length < minNumberOfBidders) {\\n            internalShutdown();\\n            return;\\n        }\\n\\n        address previousBidder = _biddersForRefund[0];\\n        uint256 minBid = workInfo[previousBidder].depositedETH;\\n        uint256 maxBid = minBid;\\n\\n        // get minimum and maximum bids\\n        for (uint256 i = 1; i < length; i++) {\\n            address bidder = _biddersForRefund[i];\\n            uint256 depositedETH = workInfo[bidder].depositedETH;\\n            require(bidder > previousBidder && depositedETH > 0, \\\"Addresses must be an array of unique bidders\\\");\\n            if (minBid > depositedETH) {\\n                minBid = depositedETH;\\n            } else if (maxBid < depositedETH) {\\n                maxBid = depositedETH;\\n            }\\n            previousBidder = bidder;\\n        }\\n\\n        uint256[] memory refunds = new uint256[](length);\\n        // first step - align at a minimum bid\\n        if (minBid != maxBid) {\\n            for (uint256 i = 0; i < length; i++) {\\n                address bidder = _biddersForRefund[i];\\n                WorkInfo storage info = workInfo[bidder];\\n                if (info.depositedETH > minBid) {\\n                    refunds[i] = info.depositedETH - minBid;\\n                    info.depositedETH = minBid;\\n                    bonusETHSupply -= refunds[i];\\n                }\\n            }\\n        }\\n\\n        require(ethToTokens(minBid) > maxAllowableLockedTokens,\\n            \\\"At least one of bidders has allowable bid\\\");\\n\\n        // final bids adjustment (only for bonus part)\\n        // (min_whale_bid * token_supply - max_stake * eth_supply) / (token_supply - max_stake * n_whales)\\n        uint256 maxBonusTokens = maxAllowableLockedTokens - minAllowableLockedTokens;\\n        uint256 minBonusETH = minBid - minAllowedBid;\\n        uint256 bonusTokenSupply = tokenSupply - bidders.length * minAllowableLockedTokens;\\n        uint256 refundETH = minBonusETH.mul(bonusTokenSupply)\\n                                .sub(maxBonusTokens.mul(bonusETHSupply))\\n                                .divCeil(bonusTokenSupply - maxBonusTokens.mul(length));\\n        uint256 resultBid = minBid.sub(refundETH);\\n        bonusETHSupply -= length * refundETH;\\n        for (uint256 i = 0; i < length; i++) {\\n            address bidder = _biddersForRefund[i];\\n            WorkInfo storage info = workInfo[bidder];\\n            refunds[i] += refundETH;\\n            info.depositedETH = resultBid;\\n        }\\n\\n        // reset verification\\n        nextBidderToCheck = 0;\\n\\n        // save a refund\\n        for (uint256 i = 0; i < length; i++) {\\n            address bidder = _biddersForRefund[i];\\n            compensation[bidder] += refunds[i];\\n            emit ForceRefund(msg.sender, bidder, refunds[i]);\\n        }\\n\\n    }\\n\\n    /**\\n    * @notice Withdraw compensation after force refund\\n    */\\n    function withdrawCompensation() external {\\n        uint256 refund = compensation[msg.sender];\\n        require(refund > 0, \\\"There is no compensation\\\");\\n        compensation[msg.sender] = 0;\\n        msg.sender.sendValue(refund);\\n        emit CompensationWithdrawn(msg.sender, refund);\\n    }\\n\\n    /**\\n    * @notice Check that the claimed tokens are within `maxAllowableLockedTokens` for all participants,\\n    * starting from the last point `nextBidderToCheck`\\n    * @dev Method stops working when the remaining gas is less than `_gasToSaveState`\\n    * and saves the state in `nextBidderToCheck`.\\n    * If all bidders have been checked then `nextBidderToCheck` will be equal to the length of the bidders array\\n    */\\n    function verifyBiddingCorrectness(uint256 _gasToSaveState) external afterCancellationWindow returns (uint256) {\\n        require(nextBidderToCheck != bidders.length, \\\"Bidders have already been checked\\\");\\n\\n        // all participants bid with the same minimum amount of eth\\n        uint256 index = nextBidderToCheck;\\n        if (bonusETHSupply == 0) {\\n            require(tokenSupply / bidders.length <= maxAllowableLockedTokens, \\\"Not enough bidders\\\");\\n            index = bidders.length;\\n        }\\n\\n        uint256 maxBonusTokens = maxAllowableLockedTokens - minAllowableLockedTokens;\\n        uint256 bonusTokenSupply = tokenSupply - bidders.length * minAllowableLockedTokens;\\n        uint256 maxBidFromMaxStake = minAllowedBid + maxBonusTokens.mul(bonusETHSupply).div(bonusTokenSupply);\\n\\n\\n        while (index < bidders.length && gasleft() > _gasToSaveState) {\\n            address bidder = bidders[index];\\n            require(workInfo[bidder].depositedETH <= maxBidFromMaxStake, \\\"Bid is greater than max allowable bid\\\");\\n            index++;\\n        }\\n\\n        if (index != nextBidderToCheck) {\\n            emit BiddersChecked(msg.sender, nextBidderToCheck, index);\\n            nextBidderToCheck = index;\\n        }\\n        return nextBidderToCheck;\\n    }\\n\\n    /**\\n    * @notice Checks if claiming available\\n    */\\n    function isClaimingAvailable() public view returns (bool) {\\n        return block.timestamp >= endCancellationDate &&\\n            nextBidderToCheck == bidders.length;\\n    }\\n\\n    /**\\n    * @notice Claimed tokens will be deposited and locked as stake in the StakingEscrow contract.\\n    */\\n    function claim() external returns (uint256 claimedTokens) {\\n        require(isClaimingAvailable(), \\\"Claiming has not been enabled yet\\\");\\n        WorkInfo storage info = workInfo[msg.sender];\\n        require(!info.claimed, \\\"Tokens are already claimed\\\");\\n        claimedTokens = ethToTokens(info.depositedETH);\\n        require(claimedTokens > 0, \\\"Nothing to claim\\\");\\n\\n        info.claimed = true;\\n        token.approve(address(escrow), claimedTokens);\\n        escrow.depositFromWorkLock(msg.sender, claimedTokens, stakingPeriods);\\n        info.completedWork = escrow.setWorkMeasurement(msg.sender, true);\\n        emit Claimed(msg.sender, claimedTokens);\\n    }\\n\\n    /**\\n    * @notice Get available refund for bidder\\n    */\\n    function getAvailableRefund(address _bidder) public view returns (uint256) {\\n        WorkInfo storage info = workInfo[_bidder];\\n        // nothing to refund\\n        if (info.depositedETH == 0) {\\n            return 0;\\n        }\\n\\n        uint256 currentWork = escrow.getCompletedWork(_bidder);\\n        uint256 completedWork = currentWork.sub(info.completedWork);\\n        // no work that has been completed since last refund\\n        if (completedWork == 0) {\\n            return 0;\\n        }\\n\\n        uint256 refundETH = workToETH(completedWork, info.depositedETH);\\n        if (refundETH > info.depositedETH) {\\n            refundETH = info.depositedETH;\\n        }\\n        return refundETH;\\n    }\\n\\n    /**\\n    * @notice Refund ETH for the completed work\\n    */\\n    function refund() external returns (uint256 refundETH) {\\n        WorkInfo storage info = workInfo[msg.sender];\\n        require(info.claimed, \\\"Tokens must be claimed before refund\\\");\\n        refundETH = getAvailableRefund(msg.sender);\\n        require(refundETH > 0, \\\"Nothing to refund: there is no ETH to refund or no completed work\\\");\\n\\n        if (refundETH == info.depositedETH) {\\n            escrow.setWorkMeasurement(msg.sender, false);\\n        }\\n        info.depositedETH = info.depositedETH.sub(refundETH);\\n        // convert refund back to work to eliminate potential rounding errors\\n        uint256 completedWork = ethToWork(refundETH, info.depositedETH);\\n\\n        info.completedWork = info.completedWork.add(completedWork);\\n        emit Refund(msg.sender, refundETH, completedWork);\\n        msg.sender.sendValue(refundETH);\\n    }\\n}\\n\"\r\n    },\r\n    \"zeppelin/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/staking_contracts/PoolingStakingContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"../../zeppelin/ownership/Ownable.sol\\\";\\nimport \\\"../../zeppelin/math/SafeMath.sol\\\";\\nimport \\\"./AbstractStakingContract.sol\\\";\\n\\n\\n/**\\n* @notice Contract acts as delegate for sub-stakers and owner\\n**/\\ncontract PoolingStakingContract is AbstractStakingContract, Ownable {\\n    using SafeMath for uint256;\\n    using Address for address payable;\\n    using SafeERC20 for NuCypherToken;\\n\\n    event TokensDeposited(address indexed sender, uint256 value, uint256 depositedTokens);\\n    event TokensWithdrawn(address indexed sender, uint256 value, uint256 depositedTokens);\\n    event ETHWithdrawn(address indexed sender, uint256 value);\\n    event DepositSet(address indexed sender, bool value);\\n\\n    struct Delegator {\\n        uint256 depositedTokens;\\n        uint256 withdrawnReward;\\n        uint256 withdrawnETH;\\n    }\\n\\n    StakingEscrow public immutable escrow;\\n\\n    uint256 public totalDepositedTokens;\\n    uint256 public totalWithdrawnReward;\\n    uint256 public totalWithdrawnETH;\\n\\n    uint256 public ownerFraction;\\n    uint256 public ownerWithdrawnReward;\\n    uint256 public ownerWithdrawnETH;\\n\\n    mapping (address => Delegator) public delegators;\\n    bool depositIsEnabled = true;\\n\\n    /**\\n    * @param _router Address of the StakingInterfaceRouter contract\\n    * @param _ownerFraction Base owner's portion of reward\\n    */\\n    constructor(\\n        StakingInterfaceRouter _router,\\n        uint256 _ownerFraction\\n    )\\n        AbstractStakingContract(_router)\\n    {\\n        escrow = _router.target().escrow();\\n        ownerFraction = _ownerFraction;\\n    }\\n\\n    /**\\n    * @notice Enabled deposit\\n    */\\n    function enableDeposit() external onlyOwner {\\n        depositIsEnabled = true;\\n        emit DepositSet(msg.sender, depositIsEnabled);\\n    }\\n\\n    /**\\n    * @notice Disable deposit\\n    */\\n    function disableDeposit() external onlyOwner {\\n        depositIsEnabled = false;\\n        emit DepositSet(msg.sender, depositIsEnabled);\\n    }\\n\\n    /**\\n    * @notice Transfer tokens as delegator\\n    * @param _value Amount of tokens to transfer\\n    */\\n    function depositTokens(uint256 _value) external {\\n        require(depositIsEnabled, \\\"Deposit must be enabled\\\");\\n        require(_value > 0, \\\"Value must be not empty\\\");\\n        totalDepositedTokens = totalDepositedTokens.add(_value);\\n        Delegator storage delegator = delegators[msg.sender];\\n        delegator.depositedTokens += _value;\\n        token.safeTransferFrom(msg.sender, address(this), _value);\\n        emit TokensDeposited(msg.sender, _value, delegator.depositedTokens);\\n    }\\n\\n    /**\\n    * @notice Get available reward for all delegators and owner\\n    */\\n    function getAvailableReward() public view returns (uint256) {\\n        uint256 stakedTokens = escrow.getAllTokens(address(this));\\n        uint256 freeTokens = token.balanceOf(address(this));\\n        uint256 reward = stakedTokens + freeTokens - totalDepositedTokens;\\n        if (reward > freeTokens) {\\n            return freeTokens;\\n        }\\n        return reward;\\n    }\\n\\n    /**\\n    * @notice Get cumulative reward\\n    */\\n    function getCumulativeReward() public view returns (uint256) {\\n        return getAvailableReward().add(totalWithdrawnReward);\\n    }\\n\\n    /**\\n    * @notice Get available reward in tokens for pool owner\\n    */\\n    function getAvailableOwnerReward() public view returns (uint256) {\\n        uint256 reward = getCumulativeReward();\\n\\n        uint256 maxAllowableReward;\\n        if (totalDepositedTokens != 0) {\\n            maxAllowableReward = reward.mul(ownerFraction).div(totalDepositedTokens.add(ownerFraction));\\n        } else {\\n            maxAllowableReward = reward;\\n        }\\n\\n        return maxAllowableReward.sub(ownerWithdrawnReward);\\n    }\\n\\n    /**\\n    * @notice Get available reward in tokens for delegator\\n    */\\n    function getAvailableReward(address _delegator) public view returns (uint256) {\\n        if (totalDepositedTokens == 0) {\\n            return 0;\\n        }\\n\\n        uint256 reward = getCumulativeReward();\\n        Delegator storage delegator = delegators[_delegator];\\n        uint256 maxAllowableReward = reward.mul(delegator.depositedTokens)\\n            .div(totalDepositedTokens.add(ownerFraction));\\n\\n        return maxAllowableReward > delegator.withdrawnReward ? maxAllowableReward - delegator.withdrawnReward : 0;\\n    }\\n\\n    /**\\n    * @notice Withdraw reward in tokens to owner\\n    */\\n    function withdrawOwnerReward() public onlyOwner {\\n        uint256 balance = token.balanceOf(address(this));\\n        uint256 availableReward = getAvailableOwnerReward();\\n\\n        if (availableReward > balance) {\\n            availableReward = balance;\\n        }\\n        require(availableReward > 0, \\\"There is no available reward to withdraw\\\");\\n        ownerWithdrawnReward  = ownerWithdrawnReward.add(availableReward);\\n        totalWithdrawnReward = totalWithdrawnReward.add(availableReward);\\n\\n        token.safeTransfer(msg.sender, availableReward);\\n        emit TokensWithdrawn(msg.sender, availableReward, 0);\\n    }\\n\\n    /**\\n    * @notice Withdraw amount of tokens to delegator\\n    * @param _value Amount of tokens to withdraw\\n    */\\n    function withdrawTokens(uint256 _value) public override {\\n        uint256 balance = token.balanceOf(address(this));\\n        require(_value <= balance, \\\"Not enough tokens in the contract\\\");\\n\\n        uint256 availableReward = getAvailableReward(msg.sender);\\n\\n        Delegator storage delegator = delegators[msg.sender];\\n        require(_value <= availableReward + delegator.depositedTokens,\\n            \\\"Requested amount of tokens exceeded allowed portion\\\");\\n\\n        if (_value <= availableReward) {\\n            delegator.withdrawnReward += _value;\\n            totalWithdrawnReward += _value;\\n        } else {\\n            delegator.withdrawnReward = delegator.withdrawnReward.add(availableReward);\\n            totalWithdrawnReward = totalWithdrawnReward.add(availableReward);\\n\\n            uint256 depositToWithdraw = _value - availableReward;\\n            uint256 newDepositedTokens = delegator.depositedTokens - depositToWithdraw;\\n            uint256 newWithdrawnReward = delegator.withdrawnReward.mul(newDepositedTokens).div(delegator.depositedTokens);\\n            uint256 newWithdrawnETH = delegator.withdrawnETH.mul(newDepositedTokens).div(delegator.depositedTokens);\\n            totalDepositedTokens -= depositToWithdraw;\\n            totalWithdrawnReward -= (delegator.withdrawnReward - newWithdrawnReward);\\n            totalWithdrawnETH -= (delegator.withdrawnETH - newWithdrawnETH);\\n            delegator.depositedTokens = newDepositedTokens;\\n            delegator.withdrawnReward = newWithdrawnReward;\\n            delegator.withdrawnETH = newWithdrawnETH;\\n        }\\n\\n        token.safeTransfer(msg.sender, _value);\\n        emit TokensWithdrawn(msg.sender, _value, delegator.depositedTokens);\\n    }\\n\\n    /**\\n    * @notice Get available ether for owner\\n    */\\n    function getAvailableOwnerETH() public view returns (uint256) {\\n        // TODO boilerplate code\\n        uint256 balance = address(this).balance;\\n        balance = balance.add(totalWithdrawnETH);\\n        uint256 maxAllowableETH = balance.mul(ownerFraction).div(totalDepositedTokens.add(ownerFraction));\\n\\n        uint256 availableETH = maxAllowableETH.sub(ownerWithdrawnETH);\\n        if (availableETH > balance) {\\n            availableETH = balance;\\n        }\\n        return availableETH;\\n    }\\n\\n    /**\\n    * @notice Get available ether for delegator\\n    */\\n    function getAvailableETH(address _delegator) public view returns (uint256) {\\n        Delegator storage delegator = delegators[_delegator];\\n        // TODO boilerplate code\\n        uint256 balance = address(this).balance;\\n        balance = balance.add(totalWithdrawnETH);\\n        uint256 maxAllowableETH = balance.mul(delegator.depositedTokens)\\n            .div(totalDepositedTokens.add(ownerFraction));\\n\\n        uint256 availableETH = maxAllowableETH.sub(delegator.withdrawnETH);\\n        if (availableETH > balance) {\\n            availableETH = balance;\\n        }\\n        return availableETH;\\n    }\\n\\n    /**\\n    * @notice Withdraw available amount of ETH to pool owner\\n    */\\n    function withdrawOwnerETH() public onlyOwner {\\n        uint256 availableETH = getAvailableOwnerETH();\\n        require(availableETH > 0, \\\"There is no available ETH to withdraw\\\");\\n\\n        ownerWithdrawnETH = ownerWithdrawnETH.add(availableETH);\\n        totalWithdrawnETH = totalWithdrawnETH.add(availableETH);\\n\\n        msg.sender.sendValue(availableETH);\\n        emit ETHWithdrawn(msg.sender, availableETH);\\n    }\\n\\n    /**\\n    * @notice Withdraw available amount of ETH to delegator\\n    */\\n    function withdrawETH() public override {\\n        uint256 availableETH = getAvailableETH(msg.sender);\\n        require(availableETH > 0, \\\"There is no available ETH to withdraw\\\");\\n\\n        Delegator storage delegator = delegators[msg.sender];\\n        delegator.withdrawnETH = delegator.withdrawnETH.add(availableETH);\\n\\n        totalWithdrawnETH = totalWithdrawnETH.add(availableETH);\\n        msg.sender.sendValue(availableETH);\\n        emit ETHWithdrawn(msg.sender, availableETH);\\n    }\\n\\n    /**\\n    * @notice Calling fallback function is allowed only for the owner\\n    **/\\n    function isFallbackAllowed() public view override returns (bool) {\\n        return msg.sender == owner();\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/staking_contracts/PreallocationEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"../../zeppelin/ownership/Ownable.sol\\\";\\nimport \\\"../../zeppelin/math/SafeMath.sol\\\";\\nimport \\\"./AbstractStakingContract.sol\\\";\\n\\n\\n/**\\n* @notice Contract holds tokens for vesting.\\n* Also tokens can be used as a stake in the staking escrow contract\\n*/\\ncontract PreallocationEscrow is AbstractStakingContract, Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for NuCypherToken;\\n    using Address for address payable;\\n\\n    event TokensDeposited(address indexed sender, uint256 value, uint256 duration);\\n    event TokensWithdrawn(address indexed owner, uint256 value);\\n    event ETHWithdrawn(address indexed owner, uint256 value);\\n\\n    StakingEscrow public immutable stakingEscrow;\\n\\n    uint256 public lockedValue;\\n    uint256 public endLockTimestamp;\\n\\n    /**\\n    * @param _router Address of the StakingInterfaceRouter contract\\n    */\\n    constructor(StakingInterfaceRouter _router) AbstractStakingContract(_router) {\\n        stakingEscrow = _router.target().escrow();\\n    }\\n\\n    /**\\n    * @notice Initial tokens deposit\\n    * @param _sender Token sender\\n    * @param _value Amount of token to deposit\\n    * @param _duration Duration of tokens locking\\n    */\\n    function initialDeposit(address _sender, uint256 _value, uint256 _duration) internal {\\n        require(lockedValue == 0 && _value > 0);\\n        endLockTimestamp = block.timestamp.add(_duration);\\n        lockedValue = _value;\\n        token.safeTransferFrom(_sender, address(this), _value);\\n        emit TokensDeposited(_sender, _value, _duration);\\n    }\\n\\n    /**\\n    * @notice Initial tokens deposit\\n    * @param _value Amount of token to deposit\\n    * @param _duration Duration of tokens locking\\n    */\\n    function initialDeposit(uint256 _value, uint256 _duration) external {\\n        initialDeposit(msg.sender, _value, _duration);\\n    }\\n\\n    /**\\n    * @notice Implementation of the receiveApproval(address,uint256,address,bytes) method\\n    * (see NuCypherToken contract). Initial tokens deposit\\n    * @param _from Sender\\n    * @param _value Amount of tokens to deposit\\n    * @param _tokenContract Token contract address\\n    * @notice (param _extraData) Amount of seconds during which tokens will be locked\\n    */\\n    function receiveApproval(\\n        address _from,\\n        uint256 _value,\\n        address _tokenContract,\\n        bytes calldata /* _extraData */\\n    )\\n        external\\n    {\\n        require(_tokenContract == address(token) && msg.sender == address(token));\\n\\n        // Copy first 32 bytes from _extraData, according to calldata memory layout:\\n        //\\n        // 0x00: method signature      4 bytes\\n        // 0x04: _from                 32 bytes after encoding\\n        // 0x24: _value                32 bytes after encoding\\n        // 0x44: _tokenContract        32 bytes after encoding\\n        // 0x64: _extraData pointer    32 bytes. Value must be 0x80 (offset of _extraData wrt to 1st parameter)\\n        // 0x84: _extraData length     32 bytes\\n        // 0xA4: _extraData data       Length determined by previous variable\\n        //\\n        // See https://solidity.readthedocs.io/en/latest/abi-spec.html#examples\\n\\n        uint256 payloadSize;\\n        uint256 payload;\\n        assembly {\\n            payloadSize := calldataload(0x84)\\n            payload := calldataload(0xA4)\\n        }\\n        payload = payload >> 8*(32 - payloadSize);\\n        initialDeposit(_from, _value, payload);\\n    }\\n\\n    /**\\n    * @notice Get locked tokens value\\n    */\\n    function getLockedTokens() public view returns (uint256) {\\n        if (endLockTimestamp <= block.timestamp) {\\n            return 0;\\n        }\\n        return lockedValue;\\n    }\\n\\n    /**\\n    * @notice Withdraw available amount of tokens to owner\\n    * @param _value Amount of token to withdraw\\n    */\\n    function withdrawTokens(uint256 _value) public override onlyOwner {\\n        uint256 balance = token.balanceOf(address(this));\\n        require(balance >= _value);\\n        // Withdrawal invariant for PreallocationEscrow:\\n        // After withdrawing, the sum of all escrowed tokens (either here or in StakingEscrow) must exceed the locked amount\\n        require(balance - _value + stakingEscrow.getAllTokens(address(this)) >= getLockedTokens());\\n        token.safeTransfer(msg.sender, _value);\\n        emit TokensWithdrawn(msg.sender, _value);\\n    }\\n\\n    /**\\n    * @notice Withdraw available ETH to the owner\\n    */\\n    function withdrawETH() public override onlyOwner {\\n        uint256 balance = address(this).balance;\\n        require(balance != 0);\\n        msg.sender.sendValue(balance);\\n        emit ETHWithdrawn(msg.sender, balance);\\n    }\\n\\n    /**\\n    * @notice Calling fallback function is allowed only for the owner\\n    */\\n    function isFallbackAllowed() public view override returns (bool) {\\n        return msg.sender == owner();\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/staking_contracts/WorkLockPoolingContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../zeppelin/ownership/Ownable.sol\\\";\\nimport \\\"../../zeppelin/math/SafeMath.sol\\\";\\nimport \\\"./AbstractStakingContract.sol\\\";\\n\\n/**\\n * @notice Contract acts as delegate for sub-stakers and owner\\n * @author @vzotova and @roma_k\\n **/\\ncontract WorkLockPoolingContract is InitializableStakingContract, Ownable {\\n    using SafeMath for uint256;\\n    using Address for address payable;\\n    using SafeERC20 for NuCypherToken;\\n\\n    event TokensDeposited(\\n        address indexed sender,\\n        uint256 value,\\n        uint256 depositedTokens\\n    );\\n    event TokensWithdrawn(\\n        address indexed sender,\\n        uint256 value,\\n        uint256 depositedTokens\\n    );\\n    event ETHWithdrawn(address indexed sender, uint256 value);\\n    event DepositSet(address indexed sender, bool value);\\n    event Bid(address indexed sender, uint256 depositedETH);\\n    event Claimed(address indexed sender, uint256 claimedTokens);\\n    event Refund(address indexed sender, uint256 refundETH);\\n\\n    struct Delegator {\\n        uint256 depositedTokens;\\n        uint256 withdrawnReward;\\n        uint256 withdrawnETH;\\n\\n        uint256 depositedETHWorkLock;\\n        uint256 refundedETHWorkLock;\\n        bool claimedWorkLockTokens;\\n    }\\n\\n    uint256 public constant BASIS_FRACTION = 100;\\n\\n    StakingEscrow public escrow;\\n    WorkLock public workLock;\\n    address public workerOwner;\\n\\n    uint256 public totalDepositedTokens;\\n    uint256 public workLockClaimedTokens;\\n\\n    uint256 public totalWithdrawnReward;\\n    uint256 public totalWithdrawnETH;\\n\\n    uint256 public totalWorkLockETHReceived;\\n    uint256 public totalWorkLockETHRefunded;\\n    uint256 public totalWorkLockETHWithdrawn;\\n\\n    uint256 workerFraction;\\n    uint256 public workerWithdrawnReward;\\n\\n    mapping(address => Delegator) public delegators;\\n    bool depositIsEnabled = true;\\n\\n    /**\\n     * @notice Initialize function for using with OpenZeppelin proxy\\n     * @param _workerFraction Share of token reward that worker node owner will get.\\n     * Use value up to BASIS_FRACTION, if _workerFraction = BASIS_FRACTION -> means 100% reward as commission\\n     * @param _router StakingInterfaceRouter address\\n     * @param _workerOwner Owner of worker node, only this address can withdraw worker commission\\n     */\\n    function initialize(\\n        uint256 _workerFraction,\\n        StakingInterfaceRouter _router,\\n        address _workerOwner\\n    ) public initializer {\\n        require(_workerOwner != address(0) && _workerFraction <= BASIS_FRACTION);\\n        InitializableStakingContract.initialize(_router);\\n        _transferOwnership(msg.sender);\\n        escrow = _router.target().escrow();\\n        workLock = _router.target().workLock();\\n        workerFraction = _workerFraction;\\n        workerOwner = _workerOwner;\\n    }\\n\\n    /**\\n     * @notice Enabled deposit\\n     */\\n    function enableDeposit() external onlyOwner {\\n        depositIsEnabled = true;\\n        emit DepositSet(msg.sender, depositIsEnabled);\\n    }\\n\\n    /**\\n     * @notice Disable deposit\\n     */\\n    function disableDeposit() external onlyOwner {\\n        depositIsEnabled = false;\\n        emit DepositSet(msg.sender, depositIsEnabled);\\n    }\\n\\n    /**\\n     * @notice Calculate worker's fraction depending on deposited tokens\\n     */\\n    function getWorkerFraction() public view returns (uint256) {\\n        return workerFraction;\\n    }\\n\\n    /**\\n     * @notice Transfer tokens as delegator\\n     * @param _value Amount of tokens to transfer\\n     */\\n    function depositTokens(uint256 _value) external {\\n        require(depositIsEnabled, \\\"Deposit must be enabled\\\");\\n        require(_value > 0, \\\"Value must be not empty\\\");\\n        totalDepositedTokens = totalDepositedTokens.add(_value);\\n        Delegator storage delegator = delegators[msg.sender];\\n        delegator.depositedTokens = delegator.depositedTokens.add(_value);\\n        token.safeTransferFrom(msg.sender, address(this), _value);\\n        emit TokensDeposited(msg.sender, _value, delegator.depositedTokens);\\n    }\\n\\n    /**\\n     * @notice Delegator can transfer ETH directly to workLock\\n     */\\n    function escrowETH() external payable {\\n        Delegator storage delegator = delegators[msg.sender];\\n        delegator.depositedETHWorkLock = delegator.depositedETHWorkLock.add(msg.value);\\n        totalWorkLockETHReceived = totalWorkLockETHReceived.add(msg.value);\\n        workLock.bid{value: msg.value}();\\n        emit Bid(msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * @dev Hide method from StakingInterface\\n     */\\n    function bid(uint256) public payable {\\n        revert();\\n    }\\n\\n    /**\\n     * @dev Hide method from StakingInterface\\n     */\\n    function withdrawCompensation() public pure {\\n        revert();\\n    }\\n\\n    /**\\n     * @dev Hide method from StakingInterface\\n     */\\n    function cancelBid() public pure {\\n        revert();\\n    }\\n\\n    /**\\n     * @dev Hide method from StakingInterface\\n     */\\n    function claim() public pure {\\n        revert();\\n    }\\n\\n    /**\\n     * @notice Claim tokens in WorkLock and save number of claimed tokens\\n     */\\n    function claimTokensFromWorkLock() public {\\n        workLockClaimedTokens = workLock.claim();\\n        totalDepositedTokens = totalDepositedTokens.add(workLockClaimedTokens);\\n        emit Claimed(address(this), workLockClaimedTokens);\\n    }\\n\\n    /**\\n     * @notice Calculate and save number of claimed tokens for specified delegator\\n     */\\n    function calculateAndSaveTokensAmount() external {\\n        Delegator storage delegator = delegators[msg.sender];\\n        calculateAndSaveTokensAmount(delegator);\\n    }\\n\\n    /**\\n     * @notice Calculate and save number of claimed tokens for specified delegator\\n     */\\n    function calculateAndSaveTokensAmount(Delegator storage _delegator) internal {\\n        if (workLockClaimedTokens == 0 ||\\n            _delegator.depositedETHWorkLock == 0 ||\\n            _delegator.claimedWorkLockTokens)\\n        {\\n            return;\\n        }\\n\\n        uint256 delegatorTokensShare = _delegator.depositedETHWorkLock.mul(workLockClaimedTokens)\\n            .div(totalWorkLockETHReceived);\\n\\n        _delegator.depositedTokens = _delegator.depositedTokens.add(delegatorTokensShare);\\n        _delegator.claimedWorkLockTokens = true;\\n        emit Claimed(msg.sender, delegatorTokensShare);\\n    }\\n\\n    /**\\n     * @notice Get available reward for all delegators and owner\\n     */\\n    function getAvailableReward() public view returns (uint256) {\\n        uint256 stakedTokens = escrow.getAllTokens(address(this));\\n        uint256 freeTokens = token.balanceOf(address(this));\\n        uint256 reward = stakedTokens.add(freeTokens).sub(totalDepositedTokens);\\n        if (reward > freeTokens) {\\n            return freeTokens;\\n        }\\n        return reward;\\n    }\\n\\n    /**\\n     * @notice Get cumulative reward\\n     */\\n    function getCumulativeReward() public view returns (uint256) {\\n        return getAvailableReward().add(totalWithdrawnReward);\\n    }\\n\\n    /**\\n     * @notice Get available reward in tokens for worker node owner\\n     */\\n    function getAvailableWorkerReward() public view returns (uint256) {\\n        uint256 reward = getCumulativeReward();\\n\\n        uint256 maxAllowableReward;\\n        if (totalDepositedTokens != 0) {\\n            uint256 fraction = getWorkerFraction();\\n            maxAllowableReward = reward.mul(fraction).div(BASIS_FRACTION);\\n        } else {\\n            maxAllowableReward = reward;\\n        }\\n\\n        if (maxAllowableReward > workerWithdrawnReward) {\\n            return maxAllowableReward - workerWithdrawnReward;\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Get available reward in tokens for delegator\\n     */\\n    function getAvailableReward(address _delegator)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (totalDepositedTokens == 0) {\\n            return 0;\\n        }\\n\\n        uint256 reward = getCumulativeReward();\\n        Delegator storage delegator = delegators[_delegator];\\n        uint256 fraction = getWorkerFraction();\\n        uint256 maxAllowableReward = reward.mul(delegator.depositedTokens).mul(BASIS_FRACTION - fraction).div(\\n            totalDepositedTokens.mul(BASIS_FRACTION)\\n        );\\n\\n        return\\n            maxAllowableReward > delegator.withdrawnReward\\n                ? maxAllowableReward - delegator.withdrawnReward\\n                : 0;\\n    }\\n\\n    /**\\n     * @notice Withdraw reward in tokens to worker node owner\\n     */\\n    function withdrawWorkerReward() external {\\n        require(msg.sender == workerOwner);\\n        uint256 balance = token.balanceOf(address(this));\\n        uint256 availableReward = getAvailableWorkerReward();\\n\\n        if (availableReward > balance) {\\n            availableReward = balance;\\n        }\\n        require(\\n            availableReward > 0,\\n            \\\"There is no available reward to withdraw\\\"\\n        );\\n        workerWithdrawnReward = workerWithdrawnReward.add(availableReward);\\n        totalWithdrawnReward = totalWithdrawnReward.add(availableReward);\\n\\n        token.safeTransfer(msg.sender, availableReward);\\n        emit TokensWithdrawn(msg.sender, availableReward, 0);\\n    }\\n\\n    /**\\n     * @notice Withdraw reward to delegator\\n     * @param _value Amount of tokens to withdraw\\n     */\\n    function withdrawTokens(uint256 _value) public override {\\n        uint256 balance = token.balanceOf(address(this));\\n        require(_value <= balance, \\\"Not enough tokens in the contract\\\");\\n\\n        Delegator storage delegator = delegators[msg.sender];\\n        calculateAndSaveTokensAmount(delegator);\\n\\n        uint256 availableReward = getAvailableReward(msg.sender);\\n\\n        require( _value <= availableReward, \\\"Requested amount of tokens exceeded allowed portion\\\");\\n        delegator.withdrawnReward = delegator.withdrawnReward.add(_value);\\n        totalWithdrawnReward = totalWithdrawnReward.add(_value);\\n\\n        token.safeTransfer(msg.sender, _value);\\n        emit TokensWithdrawn(msg.sender, _value, delegator.depositedTokens);\\n    }\\n\\n    /**\\n     * @notice Withdraw reward, deposit and fee to delegator\\n     */\\n    function withdrawAll() public {\\n        uint256 balance = token.balanceOf(address(this));\\n\\n        Delegator storage delegator = delegators[msg.sender];\\n        calculateAndSaveTokensAmount(delegator);\\n\\n        uint256 availableReward = getAvailableReward(msg.sender);\\n        uint256 value = availableReward.add(delegator.depositedTokens);\\n        require(value <= balance, \\\"Not enough tokens in the contract\\\");\\n\\n        // TODO remove double reading\\n        uint256 availableWorkerReward = getAvailableWorkerReward();\\n\\n        // potentially could be less then due reward\\n        uint256 availableETH = getAvailableETH(msg.sender);\\n\\n        // prevent losing reward for worker after calculations\\n        uint256 workerReward = availableWorkerReward.mul(delegator.depositedTokens).div(totalDepositedTokens);\\n        if (workerReward > 0) {\\n            require(value.add(workerReward) <= balance, \\\"Not enough tokens in the contract\\\");\\n            token.safeTransfer(workerOwner, workerReward);\\n            emit TokensWithdrawn(workerOwner, workerReward, 0);\\n        }\\n\\n        uint256 withdrawnToDecrease = workerWithdrawnReward.mul(delegator.depositedTokens).div(totalDepositedTokens);\\n\\n        workerWithdrawnReward = workerWithdrawnReward.sub(withdrawnToDecrease);\\n        totalWithdrawnReward = totalWithdrawnReward.sub(withdrawnToDecrease).sub(delegator.withdrawnReward);\\n        totalDepositedTokens = totalDepositedTokens.sub(delegator.depositedTokens);\\n\\n        delegator.withdrawnReward = 0;\\n        delegator.depositedTokens = 0;\\n\\n        token.safeTransfer(msg.sender, value);\\n        emit TokensWithdrawn(msg.sender, value, 0);\\n\\n        totalWithdrawnETH = totalWithdrawnETH.sub(delegator.withdrawnETH);\\n        delegator.withdrawnETH = 0;\\n        if (availableETH > 0) {\\n            msg.sender.sendValue(availableETH);\\n            emit ETHWithdrawn(msg.sender, availableETH);\\n        }\\n    }\\n\\n    /**\\n     * @notice Get available ether for delegator\\n     */\\n    function getAvailableETH(address _delegator) public view returns (uint256) {\\n        Delegator storage delegator = delegators[_delegator];\\n        uint256 balance = address(this).balance;\\n        // ETH balance + already withdrawn - (refunded - refundWithdrawn)\\n        balance = balance.add(totalWithdrawnETH).add(totalWorkLockETHWithdrawn).sub(totalWorkLockETHRefunded);\\n        uint256 maxAllowableETH = balance.mul(delegator.depositedTokens).div(totalDepositedTokens);\\n\\n        uint256 availableETH = maxAllowableETH.sub(delegator.withdrawnETH);\\n        if (availableETH > balance) {\\n            availableETH = balance;\\n        }\\n        return availableETH;\\n    }\\n\\n    /**\\n     * @notice Withdraw available amount of ETH to delegator\\n     */\\n    function withdrawETH() public override {\\n        Delegator storage delegator = delegators[msg.sender];\\n        calculateAndSaveTokensAmount(delegator);\\n\\n        uint256 availableETH = getAvailableETH(msg.sender);\\n        require(availableETH > 0, \\\"There is no available ETH to withdraw\\\");\\n        delegator.withdrawnETH = delegator.withdrawnETH.add(availableETH);\\n\\n        totalWithdrawnETH = totalWithdrawnETH.add(availableETH);\\n        msg.sender.sendValue(availableETH);\\n        emit ETHWithdrawn(msg.sender, availableETH);\\n    }\\n\\n    /**\\n     * @notice Withdraw compensation and refund from WorkLock and save these numbers\\n     */\\n    function refund() public {\\n        uint256 balance = address(this).balance;\\n        if (workLock.compensation(address(this)) > 0) {\\n            workLock.withdrawCompensation();\\n        }\\n        workLock.refund();\\n        uint256 refundETH = address(this).balance - balance;\\n        totalWorkLockETHRefunded = totalWorkLockETHRefunded.add(refundETH);\\n        emit Refund(address(this), refundETH);\\n    }\\n\\n    /**\\n     * @notice Get available refund for delegator\\n     */\\n    function getAvailableRefund(address _delegator) public view returns (uint256) {\\n        Delegator storage delegator = delegators[_delegator];\\n        uint256 maxAllowableETH = totalWorkLockETHRefunded.mul(delegator.depositedETHWorkLock)\\n            .div(totalWorkLockETHReceived);\\n\\n        uint256 availableETH = maxAllowableETH.sub(delegator.refundedETHWorkLock);\\n        uint256 balance = totalWorkLockETHRefunded.sub(totalWorkLockETHWithdrawn);\\n\\n        if (availableETH > balance) {\\n            availableETH = balance;\\n        }\\n        return availableETH;\\n    }\\n\\n    /**\\n     * @notice Withdraw available amount of ETH to delegator\\n     */\\n    function withdrawRefund() external {\\n        uint256 availableETH = getAvailableRefund(msg.sender);\\n        require(availableETH > 0, \\\"There is no available ETH to withdraw\\\");\\n\\n        Delegator storage delegator = delegators[msg.sender];\\n        delegator.refundedETHWorkLock = delegator.refundedETHWorkLock.add(availableETH);\\n\\n        totalWorkLockETHWithdrawn = totalWorkLockETHWithdrawn.add(availableETH);\\n        msg.sender.sendValue(availableETH);\\n        emit Refund(msg.sender, availableETH);\\n    }\\n\\n    /**\\n     * @notice Calling fallback function is allowed only for the owner\\n     */\\n    function isFallbackAllowed() public override view returns (bool) {\\n        return msg.sender == owner();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingEscrow_original.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.7.0;\\n\\n\\nimport \\\"../aragon/interfaces/IERC900History.sol\\\";\\nimport \\\"./Issuer.sol\\\";\\nimport \\\"./lib/Bits.sol\\\";\\nimport \\\"./lib/Snapshot.sol\\\";\\nimport \\\"../zeppelin/math/SafeMath.sol\\\";\\nimport \\\"../zeppelin/token/ERC20/SafeERC20.sol\\\";\\n\\n\\n/**\\n* @notice PolicyManager interface\\n*/\\ninterface PolicyManagerInterface {\\n    function register(address _node, uint16 _period) external;\\n    function updateFee(address _node, uint16 _period) external;\\n    function escrow() external view returns (address);\\n    function setDefaultFeeDelta(address _node, uint16 _period) external;\\n}\\n\\n\\n/**\\n* @notice Adjudicator interface\\n*/\\ninterface AdjudicatorInterface {\\n    function escrow() external view returns (address);\\n}\\n\\n\\n/**\\n* @notice WorkLock interface\\n*/\\ninterface WorkLockInterface {\\n    function escrow() external view returns (address);\\n}\\n\\n\\n/**\\n* @notice Contract holds and locks stakers tokens.\\n* Each staker that locks their tokens will receive some compensation\\n* @dev |v5.4.2|\\n*/\\ncontract StakingEscrow is Issuer, IERC900History {\\n\\n    using AdditionalMath for uint256;\\n    using AdditionalMath for uint16;\\n    using Bits for uint256;\\n    using SafeMath for uint256;\\n    using Snapshot for uint128[];\\n    using SafeERC20 for NuCypherToken;\\n\\n    event Deposited(address indexed staker, uint256 value, uint16 periods);\\n    event Locked(address indexed staker, uint256 value, uint16 firstPeriod, uint16 periods);\\n    event Divided(\\n        address indexed staker,\\n        uint256 oldValue,\\n        uint16 lastPeriod,\\n        uint256 newValue,\\n        uint16 periods\\n    );\\n    event Merged(address indexed staker, uint256 value1, uint256 value2, uint16 lastPeriod);\\n    event Prolonged(address indexed staker, uint256 value, uint16 lastPeriod, uint16 periods);\\n    event Withdrawn(address indexed staker, uint256 value);\\n    event CommitmentMade(address indexed staker, uint16 indexed period, uint256 value);\\n    event Minted(address indexed staker, uint16 indexed period, uint256 value);\\n    event Slashed(address indexed staker, uint256 penalty, address indexed investigator, uint256 reward);\\n    event ReStakeSet(address indexed staker, bool reStake);\\n    event ReStakeLocked(address indexed staker, uint16 lockUntilPeriod);\\n    event WorkerBonded(address indexed staker, address indexed worker, uint16 indexed startPeriod);\\n    event WorkMeasurementSet(address indexed staker, bool measureWork);\\n    event WindDownSet(address indexed staker, bool windDown);\\n    event SnapshotSet(address indexed staker, bool snapshotsEnabled);\\n\\n    struct SubStakeInfo {\\n        uint16 firstPeriod;\\n        uint16 lastPeriod;\\n        uint16 periods;\\n        uint128 lockedValue;\\n    }\\n\\n    struct Downtime {\\n        uint16 startPeriod;\\n        uint16 endPeriod;\\n    }\\n\\n    struct StakerInfo {\\n        uint256 value;\\n        /*\\n        * Stores periods that are committed but not yet rewarded.\\n        * In order to optimize storage, only two values are used instead of an array.\\n        * commitToNextPeriod() method invokes mint() method so there can only be two committed\\n        * periods that are not yet rewarded: the current and the next periods.\\n        */\\n        uint16 currentCommittedPeriod;\\n        uint16 nextCommittedPeriod;\\n        uint16 lastCommittedPeriod;\\n        uint16 lockReStakeUntilPeriod;\\n        uint256 completedWork;\\n        uint16 workerStartPeriod; // period when worker was bonded\\n        address worker;\\n        uint256 flags; // uint256 to acquire whole slot and minimize operations on it\\n\\n        uint256 reservedSlot1;\\n        uint256 reservedSlot2;\\n        uint256 reservedSlot3;\\n        uint256 reservedSlot4;\\n        uint256 reservedSlot5;\\n\\n        Downtime[] pastDowntime;\\n        SubStakeInfo[] subStakes;\\n        uint128[] history;\\n\\n    }\\n\\n    // used only for upgrading\\n    uint16 internal constant RESERVED_PERIOD = 0;\\n    uint16 internal constant MAX_CHECKED_VALUES = 5;\\n    // to prevent high gas consumption in loops for slashing\\n    uint16 public constant MAX_SUB_STAKES = 30;\\n    uint16 internal constant MAX_UINT16 = 65535;\\n\\n    // indices for flags\\n    uint8 internal constant RE_STAKE_DISABLED_INDEX = 0;\\n    uint8 internal constant WIND_DOWN_INDEX = 1;\\n    uint8 internal constant MEASURE_WORK_INDEX = 2;\\n    uint8 internal constant SNAPSHOTS_DISABLED_INDEX = 3;\\n\\n    uint16 public immutable minLockedPeriods;\\n    uint16 public immutable minWorkerPeriods;\\n    uint256 public immutable minAllowableLockedTokens;\\n    uint256 public immutable maxAllowableLockedTokens;\\n    bool public immutable isTestContract;\\n\\n    mapping (address => StakerInfo) public stakerInfo;\\n    address[] public stakers;\\n    mapping (address => address) public stakerFromWorker;\\n\\n    mapping (uint16 => uint256) public lockedPerPeriod;\\n    uint128[] public balanceHistory;\\n\\n    PolicyManagerInterface public policyManager;\\n    AdjudicatorInterface public adjudicator;\\n    WorkLockInterface public workLock;\\n\\n    /**\\n    * @notice Constructor sets address of token contract and coefficients for minting\\n    * @param _token Token contract\\n    * @param _hoursPerPeriod Size of period in hours\\n    * @param _issuanceDecayCoefficient (d) Coefficient which modifies the rate at which the maximum issuance decays,\\n    * only applicable to Phase 2. d = 365 * half-life / LOG2 where default half-life = 2.\\n    * See Equation 10 in Staking Protocol & Economics paper\\n    * @param _lockDurationCoefficient1 (k1) Numerator of the coefficient which modifies the extent\\n    * to which a stake's lock duration affects the subsidy it receives. Affects stakers differently.\\n    * Applicable to Phase 1 and Phase 2. k1 = k2 * small_stake_multiplier where default small_stake_multiplier = 0.5.\\n    * See Equation 8 in Staking Protocol & Economics paper.\\n    * @param _lockDurationCoefficient2 (k2) Denominator of the coefficient which modifies the extent\\n    * to which a stake's lock duration affects the subsidy it receives. Affects stakers differently.\\n    * Applicable to Phase 1 and Phase 2. k2 = maximum_rewarded_periods / (1 - small_stake_multiplier)\\n    * where default maximum_rewarded_periods = 365 and default small_stake_multiplier = 0.5.\\n    * See Equation 8 in Staking Protocol & Economics paper.\\n    * @param _maximumRewardedPeriods (kmax) Number of periods beyond which a stake's lock duration\\n    * no longer increases the subsidy it receives. kmax = reward_saturation * 365 where default reward_saturation = 1.\\n    * See Equation 8 in Staking Protocol & Economics paper.\\n    * @param _firstPhaseTotalSupply Total supply for the first phase\\n    * @param _firstPhaseMaxIssuance (Imax) Maximum number of new tokens minted per period during Phase 1.\\n    * See Equation 7 in Staking Protocol & Economics paper.\\n    * @param _minLockedPeriods Min amount of periods during which tokens can be locked\\n    * @param _minAllowableLockedTokens Min amount of tokens that can be locked\\n    * @param _maxAllowableLockedTokens Max amount of tokens that can be locked\\n    * @param _minWorkerPeriods Min amount of periods while a worker can't be changed\\n    * @param _isTestContract True if contract is only for tests\\n    */\\n    constructor(\\n        NuCypherToken _token,\\n        uint32 _hoursPerPeriod,\\n        uint256 _issuanceDecayCoefficient,\\n        uint256 _lockDurationCoefficient1,\\n        uint256 _lockDurationCoefficient2,\\n        uint16 _maximumRewardedPeriods,\\n        uint256 _firstPhaseTotalSupply,\\n        uint256 _firstPhaseMaxIssuance,\\n        uint16 _minLockedPeriods,\\n        uint256 _minAllowableLockedTokens,\\n        uint256 _maxAllowableLockedTokens,\\n        uint16 _minWorkerPeriods,\\n        bool _isTestContract\\n    )\\n        Issuer(\\n            _token,\\n            _hoursPerPeriod,\\n            _issuanceDecayCoefficient,\\n            _lockDurationCoefficient1,\\n            _lockDurationCoefficient2,\\n            _maximumRewardedPeriods,\\n            _firstPhaseTotalSupply,\\n            _firstPhaseMaxIssuance\\n        )\\n    {\\n        // constant `1` in the expression `_minLockedPeriods > 1` uses to simplify the `lock` method\\n        require(_minLockedPeriods > 1 && _maxAllowableLockedTokens != 0);\\n        minLockedPeriods = _minLockedPeriods;\\n        minAllowableLockedTokens = _minAllowableLockedTokens;\\n        maxAllowableLockedTokens = _maxAllowableLockedTokens;\\n        minWorkerPeriods = _minWorkerPeriods;\\n        isTestContract = _isTestContract;\\n    }\\n\\n    /**\\n    * @dev Checks the existence of a staker in the contract\\n    */\\n    modifier onlyStaker()\\n    {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        require(info.value > 0 || info.nextCommittedPeriod != 0);\\n        _;\\n    }\\n\\n    //------------------------Initialization------------------------\\n    /**\\n    * @notice Set policy manager address\\n    */\\n    function setPolicyManager(PolicyManagerInterface _policyManager) external onlyOwner {\\n        // Policy manager can be set only once\\n        require(address(policyManager) == address(0));\\n        // This escrow must be the escrow for the new policy manager\\n        require(_policyManager.escrow() == address(this));\\n        policyManager = _policyManager;\\n    }\\n\\n    /**\\n    * @notice Set adjudicator address\\n    */\\n    function setAdjudicator(AdjudicatorInterface _adjudicator) external onlyOwner {\\n        // Adjudicator can be set only once\\n        require(address(adjudicator) == address(0));\\n        // This escrow must be the escrow for the new adjudicator\\n        require(_adjudicator.escrow() == address(this));\\n        adjudicator = _adjudicator;\\n    }\\n\\n    /**\\n    * @notice Set worklock address\\n    */\\n    function setWorkLock(WorkLockInterface _workLock) external onlyOwner {\\n        // WorkLock can be set only once\\n        require(address(workLock) == address(0) || isTestContract);\\n        // This escrow must be the escrow for the new worklock\\n        require(_workLock.escrow() == address(this));\\n        workLock = _workLock;\\n    }\\n\\n    //------------------------Main getters------------------------\\n    /**\\n    * @notice Get all tokens belonging to the staker\\n    */\\n    function getAllTokens(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].value;\\n    }\\n\\n    /**\\n    * @notice Get all flags for the staker\\n    */\\n    function getFlags(address _staker)\\n        external view returns (\\n            bool windDown,\\n            bool reStake,\\n            bool measureWork,\\n            bool snapshots\\n        )\\n    {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        windDown = info.flags.bitSet(WIND_DOWN_INDEX);\\n        reStake = !info.flags.bitSet(RE_STAKE_DISABLED_INDEX);\\n        measureWork = info.flags.bitSet(MEASURE_WORK_INDEX);\\n        snapshots = !info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX);\\n    }\\n\\n    /**\\n    * @notice Get the start period. Use in the calculation of the last period of the sub stake\\n    * @param _info Staker structure\\n    * @param _currentPeriod Current period\\n    */\\n    function getStartPeriod(StakerInfo storage _info, uint16 _currentPeriod)\\n        internal view returns (uint16)\\n    {\\n        // if the next period (after current) is committed\\n        if (_info.flags.bitSet(WIND_DOWN_INDEX) && _info.nextCommittedPeriod > _currentPeriod) {\\n            return _currentPeriod + 1;\\n        }\\n        return _currentPeriod;\\n    }\\n\\n    /**\\n    * @notice Get the last period of the sub stake\\n    * @param _subStake Sub stake structure\\n    * @param _startPeriod Pre-calculated start period\\n    */\\n    function getLastPeriodOfSubStake(SubStakeInfo storage _subStake, uint16 _startPeriod)\\n        internal view returns (uint16)\\n    {\\n        if (_subStake.lastPeriod != 0) {\\n            return _subStake.lastPeriod;\\n        }\\n        uint32 lastPeriod = uint32(_startPeriod) + _subStake.periods;\\n        if (lastPeriod > uint32(MAX_UINT16)) {\\n            return MAX_UINT16;\\n        }\\n        return uint16(lastPeriod);\\n    }\\n\\n    /**\\n    * @notice Get the last period of the sub stake\\n    * @param _staker Staker\\n    * @param _index Stake index\\n    */\\n    function getLastPeriodOfSubStake(address _staker, uint256 _index)\\n        public view returns (uint16)\\n    {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        SubStakeInfo storage subStake = info.subStakes[_index];\\n        uint16 startPeriod = getStartPeriod(info, getCurrentPeriod());\\n        return getLastPeriodOfSubStake(subStake, startPeriod);\\n    }\\n\\n\\n    /**\\n    * @notice Get the value of locked tokens for a staker in a specified period\\n    * @dev Information may be incorrect for rewarded or not committed surpassed period\\n    * @param _info Staker structure\\n    * @param _currentPeriod Current period\\n    * @param _period Next period\\n    */\\n    function getLockedTokens(StakerInfo storage _info, uint16 _currentPeriod, uint16 _period)\\n        internal view returns (uint256 lockedValue)\\n    {\\n        lockedValue = 0;\\n        uint16 startPeriod = getStartPeriod(_info, _currentPeriod);\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake = _info.subStakes[i];\\n            if (subStake.firstPeriod <= _period &&\\n                getLastPeriodOfSubStake(subStake, startPeriod) >= _period) {\\n                lockedValue += subStake.lockedValue;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Get the value of locked tokens for a staker in a future period\\n    * @dev This function is used by PreallocationEscrow so its signature can't be updated.\\n    * @param _staker Staker\\n    * @param _periods Amount of periods that will be added to the current period\\n    */\\n    function getLockedTokens(address _staker, uint16 _periods)\\n        external view returns (uint256 lockedValue)\\n    {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod.add16(_periods);\\n        return getLockedTokens(info, currentPeriod, nextPeriod);\\n    }\\n\\n    /**\\n    * @notice Get the last committed staker's period\\n    * @param _staker Staker\\n    */\\n    function getLastCommittedPeriod(address _staker) public view returns (uint16) {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        return info.nextCommittedPeriod != 0 ? info.nextCommittedPeriod : info.lastCommittedPeriod;\\n    }\\n\\n    /**\\n    * @notice Get the value of locked tokens for active stakers in (getCurrentPeriod() + _periods) period\\n    * as well as stakers and their locked tokens\\n    * @param _periods Amount of periods for locked tokens calculation\\n    * @param _startIndex Start index for looking in stakers array\\n    * @param _maxStakers Max stakers for looking, if set 0 then all will be used\\n    * @return allLockedTokens Sum of locked tokens for active stakers\\n    * @return activeStakers Array of stakers and their locked tokens. Stakers addresses stored as uint256\\n    * @dev Note that activeStakers[0] in an array of uint256, but you want addresses. Careful when used directly!\\n    */\\n    function getActiveStakers(uint16 _periods, uint256 _startIndex, uint256 _maxStakers)\\n        external view returns (uint256 allLockedTokens, uint256[2][] memory activeStakers)\\n    {\\n        require(_periods > 0);\\n\\n        uint256 endIndex = stakers.length;\\n        require(_startIndex < endIndex);\\n        if (_maxStakers != 0 && _startIndex + _maxStakers < endIndex) {\\n            endIndex = _startIndex + _maxStakers;\\n        }\\n        activeStakers = new uint256[2][](endIndex - _startIndex);\\n        allLockedTokens = 0;\\n\\n        uint256 resultIndex = 0;\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod.add16(_periods);\\n\\n        for (uint256 i = _startIndex; i < endIndex; i++) {\\n            address staker = stakers[i];\\n            StakerInfo storage info = stakerInfo[staker];\\n            if (info.currentCommittedPeriod != currentPeriod &&\\n                info.nextCommittedPeriod != currentPeriod) {\\n                continue;\\n            }\\n            uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);\\n            if (lockedTokens != 0) {\\n                activeStakers[resultIndex][0] = uint256(staker);\\n                activeStakers[resultIndex++][1] = lockedTokens;\\n                allLockedTokens += lockedTokens;\\n            }\\n        }\\n        assembly {\\n            mstore(activeStakers, resultIndex)\\n        }\\n    }\\n\\n    /**\\n    * @notice Checks if `reStake` parameter is available for changing\\n    * @param _staker Staker\\n    */\\n    function isReStakeLocked(address _staker) public view returns (bool) {\\n        return getCurrentPeriod() < stakerInfo[_staker].lockReStakeUntilPeriod;\\n    }\\n\\n    /**\\n    * @notice Get worker using staker's address\\n    */\\n    function getWorkerFromStaker(address _staker) external view returns (address) {\\n        return stakerInfo[_staker].worker;\\n    }\\n\\n    /**\\n    * @notice Get work that completed by the staker\\n    */\\n    function getCompletedWork(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].completedWork;\\n    }\\n\\n    /**\\n    * @notice Find index of downtime structure that includes specified period\\n    * @dev If specified period is outside all downtime periods, the length of the array will be returned\\n    * @param _staker Staker\\n    * @param _period Specified period number\\n    */\\n    function findIndexOfPastDowntime(address _staker, uint16 _period) external view returns (uint256 index) {\\n        StakerInfo storage info = stakerInfo[_staker];\\n        for (index = 0; index < info.pastDowntime.length; index++) {\\n            if (_period <= info.pastDowntime[index].endPeriod) {\\n                return index;\\n            }\\n        }\\n    }\\n\\n    //------------------------Main methods------------------------\\n    /**\\n    * @notice Start or stop measuring the work of a staker\\n    * @param _staker Staker\\n    * @param _measureWork Value for `measureWork` parameter\\n    * @return Work that was previously done\\n    */\\n    function setWorkMeasurement(address _staker, bool _measureWork) external returns (uint256) {\\n        require(msg.sender == address(workLock));\\n        StakerInfo storage info = stakerInfo[_staker];\\n        if (info.flags.bitSet(MEASURE_WORK_INDEX) == _measureWork) {\\n            return info.completedWork;\\n        }\\n        info.flags = info.flags.toggleBit(MEASURE_WORK_INDEX);\\n        emit WorkMeasurementSet(_staker, _measureWork);\\n        return info.completedWork;\\n    }\\n\\n    /**\\n    * @notice Bond worker\\n    * @param _worker Worker address. Must be a real address, not a contract\\n    */\\n    function bondWorker(address _worker) external onlyStaker {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        // Specified worker is already bonded with this staker\\n        require(_worker != info.worker);\\n        uint16 currentPeriod = getCurrentPeriod();\\n        if (info.worker != address(0)) { // If this staker had a worker ...\\n            // Check that enough time has passed to change it\\n            require(currentPeriod >= info.workerStartPeriod.add16(minWorkerPeriods));\\n            // Remove the old relation \\\"worker->staker\\\"\\n            stakerFromWorker[info.worker] = address(0);\\n        }\\n\\n        if (_worker != address(0)) {\\n            // Specified worker is already in use\\n            require(stakerFromWorker[_worker] == address(0));\\n            // Specified worker is a staker\\n            require(stakerInfo[_worker].subStakes.length == 0 || _worker == msg.sender);\\n            // Set new worker->staker relation\\n            stakerFromWorker[_worker] = msg.sender;\\n        }\\n\\n        // Bond new worker (or unbond if _worker == address(0))\\n        info.worker = _worker;\\n        info.workerStartPeriod = currentPeriod;\\n        emit WorkerBonded(msg.sender, _worker, currentPeriod);\\n    }\\n\\n    /**\\n    * @notice Set `reStake` parameter. If true then all staking rewards will be added to locked stake\\n    * Only if this parameter is not locked\\n    * @param _reStake Value for parameter\\n    */\\n    function setReStake(bool _reStake) external {\\n        require(!isReStakeLocked(msg.sender));\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        if (info.flags.bitSet(RE_STAKE_DISABLED_INDEX) == !_reStake) {\\n            return;\\n        }\\n        info.flags = info.flags.toggleBit(RE_STAKE_DISABLED_INDEX);\\n        emit ReStakeSet(msg.sender, _reStake);\\n    }\\n\\n    /**\\n    * @notice Lock `reStake` parameter. Only if this parameter is not locked\\n    * @param _lockReStakeUntilPeriod Can't change `reStake` value until this period\\n    */\\n    function lockReStake(uint16 _lockReStakeUntilPeriod) external {\\n        require(!isReStakeLocked(msg.sender) &&\\n            _lockReStakeUntilPeriod > getCurrentPeriod());\\n        stakerInfo[msg.sender].lockReStakeUntilPeriod = _lockReStakeUntilPeriod;\\n        emit ReStakeLocked(msg.sender, _lockReStakeUntilPeriod);\\n    }\\n\\n    /**\\n    * @notice Deposit tokens from WorkLock contract\\n    * @param _staker Staker address\\n    * @param _value Amount of tokens to deposit\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function depositFromWorkLock(\\n        address _staker,\\n        uint256 _value,\\n        uint16 _periods\\n    )\\n        external\\n    {\\n        require(msg.sender == address(workLock));\\n        StakerInfo storage info = stakerInfo[_staker];\\n        if (!info.flags.bitSet(WIND_DOWN_INDEX) && info.subStakes.length == 0) {\\n            info.flags = info.flags.toggleBit(WIND_DOWN_INDEX);\\n            emit WindDownSet(_staker, true);\\n        }\\n        deposit(_staker, msg.sender, MAX_SUB_STAKES, _value, _periods);\\n    }\\n\\n    /**\\n    * @notice Set `windDown` parameter.\\n    * If true then stake's duration will be decreasing in each period with `commitToNextPeriod()`\\n    * @param _windDown Value for parameter\\n    */\\n    function setWindDown(bool _windDown) external onlyStaker {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        if (info.flags.bitSet(WIND_DOWN_INDEX) == _windDown) {\\n            return;\\n        }\\n        info.flags = info.flags.toggleBit(WIND_DOWN_INDEX);\\n        emit WindDownSet(msg.sender, _windDown);\\n\\n        // duration adjustment if next period is committed\\n        uint16 nextPeriod = getCurrentPeriod() + 1;\\n        if (info.nextCommittedPeriod != nextPeriod) {\\n           return;\\n        }\\n\\n        // adjust sub-stakes duration for the new value of winding down parameter\\n        for (uint256 index = 0; index < info.subStakes.length; index++) {\\n            SubStakeInfo storage subStake = info.subStakes[index];\\n            // sub-stake does not have fixed last period when winding down is disabled\\n            if (!_windDown && subStake.lastPeriod == nextPeriod) {\\n                subStake.lastPeriod = 0;\\n                subStake.periods = 1;\\n                continue;\\n            }\\n            // this sub-stake is no longer affected by winding down parameter\\n            if (subStake.lastPeriod != 0 || subStake.periods == 0) {\\n                continue;\\n            }\\n\\n            subStake.periods = _windDown ? subStake.periods - 1 : subStake.periods + 1;\\n            if (subStake.periods == 0) {\\n                subStake.lastPeriod = nextPeriod;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Activate/deactivate taking snapshots of balances\\n    * @param _enableSnapshots True to activate snapshots, False to deactivate\\n    */\\n    function setSnapshots(bool _enableSnapshots) external {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        if (info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX) == !_enableSnapshots) {\\n            return;\\n        }\\n\\n        uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());\\n        if(_enableSnapshots){\\n            info.history.addSnapshot(info.value);\\n            balanceHistory.addSnapshot(lastGlobalBalance + info.value);\\n        } else {\\n            info.history.addSnapshot(0);\\n            balanceHistory.addSnapshot(lastGlobalBalance - info.value);\\n        }\\n        info.flags = info.flags.toggleBit(SNAPSHOTS_DISABLED_INDEX);\\n\\n        emit SnapshotSet(msg.sender, _enableSnapshots);\\n    }\\n\\n    /**\\n    * @notice Adds a new snapshot to both the staker and global balance histories,\\n    * assuming the staker's balance was already changed\\n    * @param _info Reference to affected staker's struct\\n    * @param _addition Variance in balance. It can be positive or negative.\\n    */\\n    function addSnapshot(StakerInfo storage _info, int256 _addition) internal {\\n        if(!_info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX)){\\n            _info.history.addSnapshot(_info.value);\\n            uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());\\n            balanceHistory.addSnapshot(lastGlobalBalance.addSigned(_addition));\\n        }\\n    }\\n\\n\\n    /**\\n    * @notice Batch deposit. Allowed only initial deposit for each staker\\n    * @param _stakers Stakers\\n    * @param _numberOfSubStakes Number of sub-stakes which belong to staker in _values and _periods arrays\\n    * @param _values Amount of tokens to deposit for each staker\\n    * @param _periods Amount of periods during which tokens will be locked for each staker\\n    */\\n    function batchDeposit(\\n        address[] calldata _stakers,\\n        uint256[] calldata _numberOfSubStakes,\\n        uint256[] calldata _values,\\n        uint16[] calldata _periods\\n    )\\n        external\\n    {\\n        uint256 subStakesLength = _values.length;\\n        require(_stakers.length != 0 &&\\n            _stakers.length == _numberOfSubStakes.length &&\\n            subStakesLength >= _stakers.length &&\\n            _periods.length == subStakesLength);\\n        uint16 previousPeriod = getCurrentPeriod() - 1;\\n        uint16 nextPeriod = previousPeriod + 2;\\n        uint256 sumValue = 0;\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < _stakers.length; i++) {\\n            address staker = _stakers[i];\\n            uint256 numberOfSubStakes = _numberOfSubStakes[i];\\n            uint256 endIndex = j + numberOfSubStakes;\\n            require(numberOfSubStakes > 0 && subStakesLength >= endIndex);\\n            StakerInfo storage info = stakerInfo[staker];\\n            require(info.subStakes.length == 0);\\n            // A staker can't be a worker for another staker\\n            require(stakerFromWorker[staker] == address(0));\\n            stakers.push(staker);\\n            policyManager.register(staker, previousPeriod);\\n\\n            for (; j < endIndex; j++) {\\n                uint256 value =  _values[j];\\n                uint16 periods = _periods[j];\\n                require(value >= minAllowableLockedTokens && periods >= minLockedPeriods);\\n                info.value = info.value.add(value);\\n                info.subStakes.push(SubStakeInfo(nextPeriod, 0, periods, uint128(value)));\\n                sumValue = sumValue.add(value);\\n                emit Deposited(staker, value, periods);\\n                emit Locked(staker, value, nextPeriod, periods);\\n            }\\n            require(info.value <= maxAllowableLockedTokens);\\n            info.history.addSnapshot(info.value);\\n        }\\n        require(j == subStakesLength);\\n        uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());\\n        balanceHistory.addSnapshot(lastGlobalBalance + sumValue);\\n        token.safeTransferFrom(msg.sender, address(this), sumValue);\\n    }\\n\\n    /**\\n    * @notice Implementation of the receiveApproval(address,uint256,address,bytes) method\\n    * (see NuCypherToken contract). Deposit all tokens that were approved to transfer\\n    * @param _from Staker\\n    * @param _value Amount of tokens to deposit\\n    * @param _tokenContract Token contract address\\n    * @notice (param _extraData) Amount of periods during which tokens will be locked\\n    */\\n    function receiveApproval(\\n        address _from,\\n        uint256 _value,\\n        address _tokenContract,\\n        bytes calldata /* _extraData */\\n    )\\n        external\\n    {\\n        require(_tokenContract == address(token) && msg.sender == address(token));\\n\\n        // Copy first 32 bytes from _extraData, according to calldata memory layout:\\n        //\\n        // 0x00: method signature      4 bytes\\n        // 0x04: _from                 32 bytes after encoding\\n        // 0x24: _value                32 bytes after encoding\\n        // 0x44: _tokenContract        32 bytes after encoding\\n        // 0x64: _extraData pointer    32 bytes. Value must be 0x80 (offset of _extraData wrt to 1st parameter)\\n        // 0x84: _extraData length     32 bytes\\n        // 0xA4: _extraData data       Length determined by previous variable\\n        //\\n        // See https://solidity.readthedocs.io/en/latest/abi-spec.html#examples\\n\\n        uint256 payloadSize;\\n        uint256 payload;\\n        assembly {\\n            payloadSize := calldataload(0x84)\\n            payload := calldataload(0xA4)\\n        }\\n        payload = payload >> 8*(32 - payloadSize);\\n        deposit(_from, _from, MAX_SUB_STAKES, _value, uint16(payload));\\n    }\\n\\n    /**\\n    * @notice Deposit tokens and create new sub-stake. Use this method to become a staker\\n    * @param _staker Staker\\n    * @param _value Amount of tokens to deposit\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function deposit(address _staker, uint256 _value, uint16 _periods) external {\\n        deposit(_staker, msg.sender, MAX_SUB_STAKES, _value, _periods);\\n    }\\n\\n    /**\\n    * @notice Deposit tokens and increase lock amount of an existing sub-stake\\n    * @dev This is preferable way to stake tokens because will be fewer active sub-stakes in the result\\n    * @param _index Index of the sub stake\\n    * @param _value Amount of tokens which will be locked\\n    */\\n    function depositAndIncrease(uint256 _index, uint256 _value) external onlyStaker {\\n        require(_index < MAX_SUB_STAKES);\\n        deposit(msg.sender, msg.sender, _index, _value, 0);\\n    }\\n\\n    /**\\n    * @notice Deposit tokens\\n    * @dev Specify either index and zero periods (for an existing sub-stake)\\n    * or index >= MAX_SUB_STAKES and real value for periods (for a new sub-stake), not both\\n    * @param _staker Staker\\n    * @param _payer Owner of tokens\\n    * @param _index Index of the sub stake\\n    * @param _value Amount of tokens to deposit\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function deposit(address _staker, address _payer, uint256 _index, uint256 _value, uint16 _periods) internal {\\n        require(_value != 0);\\n        StakerInfo storage info = stakerInfo[_staker];\\n        // A staker can't be a worker for another staker\\n        require(stakerFromWorker[_staker] == address(0) || stakerFromWorker[_staker] == info.worker);\\n        // initial stake of the staker\\n        if (info.subStakes.length == 0) {\\n            stakers.push(_staker);\\n            policyManager.register(_staker, getCurrentPeriod() - 1);\\n        }\\n        token.safeTransferFrom(_payer, address(this), _value);\\n        info.value += _value;\\n        lock(_staker, _index, _value, _periods);\\n\\n        addSnapshot(info, int256(_value));\\n        if (_index >= MAX_SUB_STAKES) {\\n            emit Deposited(_staker, _value, _periods);\\n        } else {\\n            uint16 lastPeriod = getLastPeriodOfSubStake(_staker, _index);\\n            emit Deposited(_staker, _value, lastPeriod - getCurrentPeriod());\\n        }\\n    }\\n\\n    /**\\n    * @notice Lock some tokens as a new sub-stake\\n    * @param _value Amount of tokens which will be locked\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function lockAndCreate(uint256 _value, uint16 _periods) external onlyStaker {\\n        lock(msg.sender, MAX_SUB_STAKES, _value, _periods);\\n    }\\n\\n    /**\\n    * @notice Increase lock amount of an existing sub-stake\\n    * @param _index Index of the sub-stake\\n    * @param _value Amount of tokens which will be locked\\n    */\\n    function lockAndIncrease(uint256 _index, uint256 _value) external onlyStaker {\\n        require(_index < MAX_SUB_STAKES);\\n        lock(msg.sender, _index, _value, 0);\\n    }\\n\\n    /**\\n    * @notice Lock some tokens as a stake\\n    * @dev Specify either index and zero periods (for an existing sub-stake)\\n    * or index >= MAX_SUB_STAKES and real value for periods (for a new sub-stake), not both\\n    * @param _staker Staker\\n    * @param _index Index of the sub stake\\n    * @param _value Amount of tokens which will be locked\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function lock(address _staker, uint256 _index, uint256 _value, uint16 _periods) internal {\\n        if (_index < MAX_SUB_STAKES) {\\n            require(_value > 0);\\n        } else {\\n            require(_value >= minAllowableLockedTokens && _periods >= minLockedPeriods);\\n        }\\n\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod + 1;\\n        StakerInfo storage info = stakerInfo[_staker];\\n        uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);\\n        uint256 requestedLockedTokens = _value.add(lockedTokens);\\n        require(requestedLockedTokens <= info.value && requestedLockedTokens <= maxAllowableLockedTokens);\\n\\n        // next period is committed\\n        if (info.nextCommittedPeriod == nextPeriod) {\\n            lockedPerPeriod[nextPeriod] += _value;\\n            emit CommitmentMade(_staker, nextPeriod, _value);\\n        }\\n\\n        // if index was provided then increase existing sub-stake\\n        if (_index < MAX_SUB_STAKES) {\\n            lockAndIncrease(info, currentPeriod, nextPeriod, _staker, _index, _value);\\n        // otherwise create new\\n        } else {\\n            lockAndCreate(info, nextPeriod, _staker, _value, _periods);\\n        }\\n    }\\n\\n    /**\\n    * @notice Lock some tokens as a new sub-stake\\n    * @param _info Staker structure\\n    * @param _nextPeriod Next period\\n    * @param _staker Staker\\n    * @param _value Amount of tokens which will be locked\\n    * @param _periods Amount of periods during which tokens will be locked\\n    */\\n    function lockAndCreate(\\n        StakerInfo storage _info,\\n        uint16 _nextPeriod,\\n        address _staker,\\n        uint256 _value,\\n        uint16 _periods\\n    )\\n        internal\\n    {\\n        uint16 duration = _periods;\\n        // if winding down is enabled and next period is committed\\n        // then sub-stakes duration were decreased\\n        if (_info.nextCommittedPeriod == _nextPeriod && _info.flags.bitSet(WIND_DOWN_INDEX)) {\\n            duration -= 1;\\n        }\\n        saveSubStake(_info, _nextPeriod, 0, duration, _value);\\n\\n        emit Locked(_staker, _value, _nextPeriod, _periods);\\n    }\\n\\n    /**\\n    * @notice Increase lock amount of an existing sub-stake\\n    * @dev Probably will be created a new sub-stake but it will be active only one period\\n    * @param _info Staker structure\\n    * @param _currentPeriod Current period\\n    * @param _nextPeriod Next period\\n    * @param _staker Staker\\n    * @param _index Index of the sub-stake\\n    * @param _value Amount of tokens which will be locked\\n    */\\n    function lockAndIncrease(\\n        StakerInfo storage _info,\\n        uint16 _currentPeriod,\\n        uint16 _nextPeriod,\\n        address _staker,\\n        uint256 _index,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        SubStakeInfo storage subStake = _info.subStakes[_index];\\n        (, uint16 lastPeriod) = checkLastPeriodOfSubStake(_info, subStake, _currentPeriod);\\n\\n        // create temporary sub-stake for current or previous committed periods\\n        // to leave locked amount in this period unchanged\\n        if (_info.currentCommittedPeriod != 0 &&\\n            _info.currentCommittedPeriod <= _currentPeriod ||\\n            _info.nextCommittedPeriod != 0 &&\\n            _info.nextCommittedPeriod <= _currentPeriod)\\n        {\\n            saveSubStake(_info, subStake.firstPeriod, _currentPeriod, 0, subStake.lockedValue);\\n        }\\n\\n        subStake.lockedValue += uint128(_value);\\n        // all new locks should start from the next period\\n        subStake.firstPeriod = _nextPeriod;\\n\\n        emit Locked(_staker, _value, _nextPeriod, lastPeriod - _currentPeriod);\\n    }\\n\\n    /**\\n    * @notice Checks that last period of sub-stake is greater than the current period\\n    * @param _info Staker structure\\n    * @param _subStake Sub-stake structure\\n    * @param _currentPeriod Current period\\n    * @return startPeriod Start period. Use in the calculation of the last period of the sub stake\\n    * @return lastPeriod Last period of the sub stake\\n    */\\n    function checkLastPeriodOfSubStake(\\n        StakerInfo storage _info,\\n        SubStakeInfo storage _subStake,\\n        uint16 _currentPeriod\\n    )\\n        internal view returns (uint16 startPeriod, uint16 lastPeriod)\\n    {\\n        startPeriod = getStartPeriod(_info, _currentPeriod);\\n        lastPeriod = getLastPeriodOfSubStake(_subStake, startPeriod);\\n        // The sub stake must be active at least in the next period\\n        require(lastPeriod > _currentPeriod);\\n    }\\n\\n    /**\\n    * @notice Save sub stake. First tries to override inactive sub stake\\n    * @dev Inactive sub stake means that last period of sub stake has been surpassed and already rewarded\\n    * @param _info Staker structure\\n    * @param _firstPeriod First period of the sub stake\\n    * @param _lastPeriod Last period of the sub stake\\n    * @param _periods Duration of the sub stake in periods\\n    * @param _lockedValue Amount of locked tokens\\n    */\\n    function saveSubStake(\\n        StakerInfo storage _info,\\n        uint16 _firstPeriod,\\n        uint16 _lastPeriod,\\n        uint16 _periods,\\n        uint256 _lockedValue\\n    )\\n        internal\\n    {\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake = _info.subStakes[i];\\n            if (subStake.lastPeriod != 0 &&\\n                (_info.currentCommittedPeriod == 0 ||\\n                subStake.lastPeriod < _info.currentCommittedPeriod) &&\\n                (_info.nextCommittedPeriod == 0 ||\\n                subStake.lastPeriod < _info.nextCommittedPeriod))\\n            {\\n                subStake.firstPeriod = _firstPeriod;\\n                subStake.lastPeriod = _lastPeriod;\\n                subStake.periods = _periods;\\n                subStake.lockedValue = uint128(_lockedValue);\\n                return;\\n            }\\n        }\\n        require(_info.subStakes.length < MAX_SUB_STAKES);\\n        _info.subStakes.push(SubStakeInfo(_firstPeriod, _lastPeriod, _periods, uint128(_lockedValue)));\\n    }\\n\\n    /**\\n    * @notice Divide sub stake into two parts\\n    * @param _index Index of the sub stake\\n    * @param _newValue New sub stake value\\n    * @param _periods Amount of periods for extending sub stake\\n    */\\n    function divideStake(uint256 _index, uint256 _newValue, uint16 _periods) external onlyStaker {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        require(_newValue >= minAllowableLockedTokens && _periods > 0);\\n        SubStakeInfo storage subStake = info.subStakes[_index];\\n        uint16 currentPeriod = getCurrentPeriod();\\n        (, uint16 lastPeriod) = checkLastPeriodOfSubStake(info, subStake, currentPeriod);\\n\\n        uint256 oldValue = subStake.lockedValue;\\n        subStake.lockedValue = uint128(oldValue.sub(_newValue));\\n        require(subStake.lockedValue >= minAllowableLockedTokens);\\n        uint16 requestedPeriods = subStake.periods.add16(_periods);\\n        saveSubStake(info, subStake.firstPeriod, 0, requestedPeriods, _newValue);\\n        emit Divided(msg.sender, oldValue, lastPeriod, _newValue, _periods);\\n        emit Locked(msg.sender, _newValue, subStake.firstPeriod, requestedPeriods);\\n    }\\n\\n    /**\\n    * @notice Prolong active sub stake\\n    * @param _index Index of the sub stake\\n    * @param _periods Amount of periods for extending sub stake\\n    */\\n    function prolongStake(uint256 _index, uint16 _periods) external onlyStaker {\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        // Incorrect parameters\\n        require(_periods > 0);\\n        SubStakeInfo storage subStake = info.subStakes[_index];\\n        uint16 currentPeriod = getCurrentPeriod();\\n        (uint16 startPeriod, uint16 lastPeriod) = checkLastPeriodOfSubStake(info, subStake, currentPeriod);\\n\\n        subStake.periods = subStake.periods.add16(_periods);\\n        // if the sub stake ends in the next committed period then reset the `lastPeriod` field\\n        if (lastPeriod == startPeriod) {\\n            subStake.lastPeriod = 0;\\n        }\\n        // The extended sub stake must not be less than the minimum value\\n        require(uint32(lastPeriod - currentPeriod) + _periods >= minLockedPeriods);\\n        emit Locked(msg.sender, subStake.lockedValue, lastPeriod + 1, _periods);\\n        emit Prolonged(msg.sender, subStake.lockedValue, lastPeriod, _periods);\\n    }\\n\\n    /**\\n    * @notice Merge two sub-stakes into one if their last periods are equal\\n    * @dev It's possible that both sub-stakes will be active after this transaction.\\n    * But only one of them will be active until next call `commitToNextPeriod` (in the next period)\\n    * @param _index1 Index of the first sub-stake\\n    * @param _index2 Index of the second sub-stake\\n    */\\n    function mergeStake(uint256 _index1, uint256 _index2) external onlyStaker {\\n        require(_index1 != _index2); // must be different sub-stakes\\n\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        SubStakeInfo storage subStake1 = info.subStakes[_index1];\\n        SubStakeInfo storage subStake2 = info.subStakes[_index2];\\n        uint16 currentPeriod = getCurrentPeriod();\\n\\n        (, uint16 lastPeriod1) = checkLastPeriodOfSubStake(info, subStake1, currentPeriod);\\n        (, uint16 lastPeriod2) = checkLastPeriodOfSubStake(info, subStake2, currentPeriod);\\n        // both sub-stakes must have equal last period to be mergeable\\n        require(lastPeriod1 == lastPeriod2);\\n        emit Merged(msg.sender, subStake1.lockedValue, subStake2.lockedValue, lastPeriod1);\\n\\n        if (subStake1.firstPeriod == subStake2.firstPeriod) {\\n            subStake1.lockedValue += subStake2.lockedValue;\\n            subStake2.lastPeriod = 1;\\n            subStake2.periods = 0;\\n        } else if (subStake1.firstPeriod > subStake2.firstPeriod) {\\n            subStake1.lockedValue += subStake2.lockedValue;\\n            subStake2.lastPeriod = subStake1.firstPeriod - 1;\\n            subStake2.periods = 0;\\n        } else {\\n            subStake2.lockedValue += subStake1.lockedValue;\\n            subStake1.lastPeriod = subStake2.firstPeriod - 1;\\n            subStake1.periods = 0;\\n        }\\n    }\\n\\n    /**\\n    * @notice Withdraw available amount of tokens to staker\\n    * @param _value Amount of tokens to withdraw\\n    */\\n    function withdraw(uint256 _value) external onlyStaker {\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod + 1;\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        // the max locked tokens in most cases will be in the current period\\n        // but when the staker locks more then we should use the next period\\n        uint256 lockedTokens = Math.max(getLockedTokens(info, currentPeriod, nextPeriod),\\n            getLockedTokens(info, currentPeriod, currentPeriod));\\n        require(_value <= info.value.sub(lockedTokens));\\n        info.value -= _value;\\n\\n        addSnapshot(info, - int256(_value));\\n        token.safeTransfer(msg.sender, _value);\\n        emit Withdrawn(msg.sender, _value);\\n\\n        // unbond worker if staker withdraws last portion of NU\\n        if (info.value == 0 &&\\n            info.nextCommittedPeriod == 0 &&\\n            info.worker != address(0))\\n        {\\n            stakerFromWorker[info.worker] = address(0);\\n            info.worker = address(0);\\n            emit WorkerBonded(msg.sender, address(0), currentPeriod);\\n        }\\n    }\\n\\n    /**\\n    * @notice Make a commitment to the next period and mint for the previous period\\n    */\\n    function commitToNextPeriod() external isInitialized {\\n        address staker = stakerFromWorker[msg.sender];\\n        StakerInfo storage info = stakerInfo[staker];\\n        // Staker must have a stake to make a commitment\\n        require(info.value > 0);\\n        // Only worker with real address can make a commitment\\n        require(msg.sender == tx.origin);\\n\\n        uint16 lastCommittedPeriod = getLastCommittedPeriod(staker);\\n        mint(staker);\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod + 1;\\n\\n        // the period has already been committed\\n        if (info.nextCommittedPeriod == nextPeriod) {\\n            return;\\n        }\\n\\n        uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);\\n        require(lockedTokens > 0);\\n        lockedPerPeriod[nextPeriod] += lockedTokens;\\n\\n        info.currentCommittedPeriod = info.nextCommittedPeriod;\\n        info.nextCommittedPeriod = nextPeriod;\\n\\n        decreaseSubStakesDuration(info, nextPeriod);\\n\\n        // staker was inactive for several periods\\n        if (lastCommittedPeriod < currentPeriod) {\\n            info.pastDowntime.push(Downtime(lastCommittedPeriod + 1, currentPeriod));\\n        }\\n        policyManager.setDefaultFeeDelta(staker, nextPeriod);\\n        emit CommitmentMade(staker, nextPeriod, lockedTokens);\\n    }\\n\\n    /**\\n    * @notice Decrease sub-stakes duration if `windDown` is enabled\\n    */\\n    function decreaseSubStakesDuration(StakerInfo storage _info, uint16 _nextPeriod) internal {\\n        if (!_info.flags.bitSet(WIND_DOWN_INDEX)) {\\n            return;\\n        }\\n        for (uint256 index = 0; index < _info.subStakes.length; index++) {\\n            SubStakeInfo storage subStake = _info.subStakes[index];\\n            if (subStake.lastPeriod != 0 || subStake.periods == 0) {\\n                continue;\\n            }\\n            subStake.periods--;\\n            if (subStake.periods == 0) {\\n                subStake.lastPeriod = _nextPeriod;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Mint tokens for previous periods if staker locked their tokens and made a commitment\\n    */\\n    function mint() external onlyStaker {\\n        // save last committed period to the storage if both periods will be empty after minting\\n        // because we won't be able to calculate last committed period\\n        // see getLastCommittedPeriod(address)\\n        StakerInfo storage info = stakerInfo[msg.sender];\\n        uint16 previousPeriod = getCurrentPeriod() - 1;\\n        if (info.nextCommittedPeriod <= previousPeriod && info.nextCommittedPeriod != 0) {\\n            info.lastCommittedPeriod = info.nextCommittedPeriod;\\n        }\\n        mint(msg.sender);\\n    }\\n\\n    /**\\n    * @notice Mint tokens for previous periods if staker locked their tokens and made a commitment\\n    * @param _staker Staker\\n    */\\n    function mint(address _staker) internal {\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 previousPeriod = currentPeriod  - 1;\\n        StakerInfo storage info = stakerInfo[_staker];\\n\\n        if (info.nextCommittedPeriod == 0 ||\\n            info.currentCommittedPeriod == 0 &&\\n            info.nextCommittedPeriod > previousPeriod ||\\n            info.currentCommittedPeriod > previousPeriod) {\\n            return;\\n        }\\n\\n        uint16 startPeriod = getStartPeriod(info, currentPeriod);\\n        uint256 reward = 0;\\n        bool reStake = !info.flags.bitSet(RE_STAKE_DISABLED_INDEX);\\n        if (info.currentCommittedPeriod != 0) {\\n            reward = mint(_staker, info, info.currentCommittedPeriod, currentPeriod, startPeriod, reStake);\\n            info.currentCommittedPeriod = 0;\\n            if (reStake) {\\n                lockedPerPeriod[info.nextCommittedPeriod] += reward;\\n            }\\n        }\\n        if (info.nextCommittedPeriod <= previousPeriod) {\\n            reward += mint(_staker, info, info.nextCommittedPeriod, currentPeriod, startPeriod, reStake);\\n            info.nextCommittedPeriod = 0;\\n        }\\n\\n        info.value += reward;\\n        if (info.flags.bitSet(MEASURE_WORK_INDEX)) {\\n            info.completedWork += reward;\\n        }\\n\\n        addSnapshot(info, int256(reward));\\n        emit Minted(_staker, previousPeriod, reward);\\n    }\\n\\n    /**\\n    * @notice Calculate reward for one period\\n    * @param _staker Staker's address\\n    * @param _info Staker structure\\n    * @param _mintingPeriod Period for minting calculation\\n    * @param _currentPeriod Current period\\n    * @param _startPeriod Pre-calculated start period\\n    */\\n    function mint(\\n        address _staker,\\n        StakerInfo storage _info,\\n        uint16 _mintingPeriod,\\n        uint16 _currentPeriod,\\n        uint16 _startPeriod,\\n        bool _reStake\\n    )\\n        internal returns (uint256 reward)\\n    {\\n        reward = 0;\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake =  _info.subStakes[i];\\n            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);\\n            if (subStake.firstPeriod <= _mintingPeriod && lastPeriod >= _mintingPeriod) {\\n                uint256 subStakeReward = mint(\\n                    _currentPeriod,\\n                    subStake.lockedValue,\\n                    lockedPerPeriod[_mintingPeriod],\\n                    lastPeriod.sub16(_mintingPeriod));\\n                reward += subStakeReward;\\n                if (_reStake) {\\n                    subStake.lockedValue += uint128(subStakeReward);\\n                }\\n            }\\n        }\\n        policyManager.updateFee(_staker, _mintingPeriod);\\n        return reward;\\n    }\\n\\n    //-------------------------Slashing-------------------------\\n    /**\\n    * @notice Slash the staker's stake and reward the investigator\\n    * @param _staker Staker's address\\n    * @param _penalty Penalty\\n    * @param _investigator Investigator\\n    * @param _reward Reward for the investigator\\n    */\\n    function slashStaker(\\n        address _staker,\\n        uint256 _penalty,\\n        address _investigator,\\n        uint256 _reward\\n    )\\n        public isInitialized\\n    {\\n        require(msg.sender == address(adjudicator));\\n        require(_penalty > 0);\\n        StakerInfo storage info = stakerInfo[_staker];\\n        if (info.value <= _penalty) {\\n            _penalty = info.value;\\n        }\\n        info.value -= _penalty;\\n        if (_reward > _penalty) {\\n            _reward = _penalty;\\n        }\\n\\n        uint16 currentPeriod = getCurrentPeriod();\\n        uint16 nextPeriod = currentPeriod + 1;\\n        uint16 startPeriod = getStartPeriod(info, currentPeriod);\\n\\n        (uint256 currentLock, uint256 nextLock, uint256 currentAndNextLock, uint256 shortestSubStakeIndex) =\\n            getLockedTokensAndShortestSubStake(info, currentPeriod, nextPeriod, startPeriod);\\n\\n        // Decrease the stake if amount of locked tokens in the current period more than staker has\\n        uint256 lockedTokens = currentLock + currentAndNextLock;\\n        if (info.value < lockedTokens) {\\n           decreaseSubStakes(info, lockedTokens - info.value, currentPeriod, startPeriod, shortestSubStakeIndex);\\n        }\\n        // Decrease the stake if amount of locked tokens in the next period more than staker has\\n        if (nextLock > 0) {\\n            lockedTokens = nextLock + currentAndNextLock -\\n                (currentAndNextLock > info.value ? currentAndNextLock - info.value : 0);\\n            if (info.value < lockedTokens) {\\n               decreaseSubStakes(info, lockedTokens - info.value, nextPeriod, startPeriod, MAX_SUB_STAKES);\\n            }\\n        }\\n\\n        emit Slashed(_staker, _penalty, _investigator, _reward);\\n        if (_penalty > _reward) {\\n            unMint(_penalty - _reward);\\n        }\\n        // TODO change to withdrawal pattern (#1499)\\n        if (_reward > 0) {\\n            token.safeTransfer(_investigator, _reward);\\n        }\\n\\n        addSnapshot(info, - int256(_penalty));\\n\\n    }\\n\\n    /**\\n    * @notice Get the value of locked tokens for a staker in the current and the next period\\n    * and find the shortest sub stake\\n    * @param _info Staker structure\\n    * @param _currentPeriod Current period\\n    * @param _nextPeriod Next period\\n    * @param _startPeriod Pre-calculated start period\\n    * @return currentLock Amount of tokens that locked in the current period and unlocked in the next period\\n    * @return nextLock Amount of tokens that locked in the next period and not locked in the current period\\n    * @return currentAndNextLock Amount of tokens that locked in the current period and in the next period\\n    * @return shortestSubStakeIndex Index of the shortest sub stake\\n    */\\n    function getLockedTokensAndShortestSubStake(\\n        StakerInfo storage _info,\\n        uint16 _currentPeriod,\\n        uint16 _nextPeriod,\\n        uint16 _startPeriod\\n    )\\n        internal view returns (\\n            uint256 currentLock,\\n            uint256 nextLock,\\n            uint256 currentAndNextLock,\\n            uint256 shortestSubStakeIndex\\n        )\\n    {\\n        uint16 minDuration = MAX_UINT16;\\n        uint16 minLastPeriod = MAX_UINT16;\\n        shortestSubStakeIndex = MAX_SUB_STAKES;\\n        currentLock = 0;\\n        nextLock = 0;\\n        currentAndNextLock = 0;\\n\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake = _info.subStakes[i];\\n            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);\\n            if (lastPeriod < subStake.firstPeriod) {\\n                continue;\\n            }\\n            if (subStake.firstPeriod <= _currentPeriod &&\\n                lastPeriod >= _nextPeriod) {\\n                currentAndNextLock += subStake.lockedValue;\\n            } else if (subStake.firstPeriod <= _currentPeriod &&\\n                lastPeriod >= _currentPeriod) {\\n                currentLock += subStake.lockedValue;\\n            } else if (subStake.firstPeriod <= _nextPeriod &&\\n                lastPeriod >= _nextPeriod) {\\n                nextLock += subStake.lockedValue;\\n            }\\n            uint16 duration = lastPeriod - subStake.firstPeriod;\\n            if (subStake.firstPeriod <= _currentPeriod &&\\n                lastPeriod >= _currentPeriod &&\\n                (lastPeriod < minLastPeriod ||\\n                lastPeriod == minLastPeriod && duration < minDuration))\\n            {\\n                shortestSubStakeIndex = i;\\n                minDuration = duration;\\n                minLastPeriod = lastPeriod;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Decrease short sub stakes\\n    * @param _info Staker structure\\n    * @param _penalty Penalty rate\\n    * @param _decreasePeriod The period when the decrease begins\\n    * @param _startPeriod Pre-calculated start period\\n    * @param _shortestSubStakeIndex Index of the shortest period\\n    */\\n    function decreaseSubStakes(\\n        StakerInfo storage _info,\\n        uint256 _penalty,\\n        uint16 _decreasePeriod,\\n        uint16 _startPeriod,\\n        uint256 _shortestSubStakeIndex\\n    )\\n        internal\\n    {\\n        SubStakeInfo storage shortestSubStake = _info.subStakes[0];\\n        uint16 minSubStakeLastPeriod = MAX_UINT16;\\n        uint16 minSubStakeDuration = MAX_UINT16;\\n        while(_penalty > 0) {\\n            if (_shortestSubStakeIndex < MAX_SUB_STAKES) {\\n                shortestSubStake = _info.subStakes[_shortestSubStakeIndex];\\n                minSubStakeLastPeriod = getLastPeriodOfSubStake(shortestSubStake, _startPeriod);\\n                minSubStakeDuration = minSubStakeLastPeriod - shortestSubStake.firstPeriod;\\n                _shortestSubStakeIndex = MAX_SUB_STAKES;\\n            } else {\\n                (shortestSubStake, minSubStakeDuration, minSubStakeLastPeriod) =\\n                    getShortestSubStake(_info, _decreasePeriod, _startPeriod);\\n            }\\n            if (minSubStakeDuration == MAX_UINT16) {\\n                break;\\n            }\\n            uint256 appliedPenalty = _penalty;\\n            if (_penalty < shortestSubStake.lockedValue) {\\n                shortestSubStake.lockedValue -= uint128(_penalty);\\n                saveOldSubStake(_info, shortestSubStake.firstPeriod, _penalty, _decreasePeriod);\\n                _penalty = 0;\\n            } else {\\n                shortestSubStake.lastPeriod = _decreasePeriod - 1;\\n                _penalty -= shortestSubStake.lockedValue;\\n                appliedPenalty = shortestSubStake.lockedValue;\\n            }\\n            if (_info.currentCommittedPeriod >= _decreasePeriod &&\\n                _info.currentCommittedPeriod <= minSubStakeLastPeriod)\\n            {\\n                lockedPerPeriod[_info.currentCommittedPeriod] -= appliedPenalty;\\n            }\\n            if (_info.nextCommittedPeriod >= _decreasePeriod &&\\n                _info.nextCommittedPeriod <= minSubStakeLastPeriod)\\n            {\\n                lockedPerPeriod[_info.nextCommittedPeriod] -= appliedPenalty;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Get the shortest sub stake\\n    * @param _info Staker structure\\n    * @param _currentPeriod Current period\\n    * @param _startPeriod Pre-calculated start period\\n    * @return shortestSubStake The shortest sub stake\\n    * @return minSubStakeDuration Duration of the shortest sub stake\\n    * @return minSubStakeLastPeriod Last period of the shortest sub stake\\n    */\\n    function getShortestSubStake(\\n        StakerInfo storage _info,\\n        uint16 _currentPeriod,\\n        uint16 _startPeriod\\n    )\\n        internal view returns (\\n            SubStakeInfo storage shortestSubStake,\\n            uint16 minSubStakeDuration,\\n            uint16 minSubStakeLastPeriod\\n        )\\n    {\\n        shortestSubStake = shortestSubStake;\\n        minSubStakeDuration = MAX_UINT16;\\n        minSubStakeLastPeriod = MAX_UINT16;\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake = _info.subStakes[i];\\n            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);\\n            if (lastPeriod < subStake.firstPeriod) {\\n                continue;\\n            }\\n            uint16 duration = lastPeriod - subStake.firstPeriod;\\n            if (subStake.firstPeriod <= _currentPeriod &&\\n                lastPeriod >= _currentPeriod &&\\n                (lastPeriod < minSubStakeLastPeriod ||\\n                lastPeriod == minSubStakeLastPeriod && duration < minSubStakeDuration))\\n            {\\n                shortestSubStake = subStake;\\n                minSubStakeDuration = duration;\\n                minSubStakeLastPeriod = lastPeriod;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Save the old sub stake values to prevent decreasing reward for the previous period\\n    * @dev Saving happens only if the previous period is committed\\n    * @param _info Staker structure\\n    * @param _firstPeriod First period of the old sub stake\\n    * @param _lockedValue Locked value of the old sub stake\\n    * @param _currentPeriod Current period, when the old sub stake is already unlocked\\n    */\\n    function saveOldSubStake(\\n        StakerInfo storage _info,\\n        uint16 _firstPeriod,\\n        uint256 _lockedValue,\\n        uint16 _currentPeriod\\n    )\\n        internal\\n    {\\n        // Check that the old sub stake should be saved\\n        bool oldCurrentCommittedPeriod = _info.currentCommittedPeriod != 0 &&\\n            _info.currentCommittedPeriod < _currentPeriod;\\n        bool oldnextCommittedPeriod = _info.nextCommittedPeriod != 0 &&\\n            _info.nextCommittedPeriod < _currentPeriod;\\n        bool crosscurrentCommittedPeriod = oldCurrentCommittedPeriod && _info.currentCommittedPeriod >= _firstPeriod;\\n        bool crossnextCommittedPeriod = oldnextCommittedPeriod && _info.nextCommittedPeriod >= _firstPeriod;\\n        if (!crosscurrentCommittedPeriod && !crossnextCommittedPeriod) {\\n            return;\\n        }\\n        // Try to find already existent proper old sub stake\\n        uint16 previousPeriod = _currentPeriod - 1;\\n        for (uint256 i = 0; i < _info.subStakes.length; i++) {\\n            SubStakeInfo storage subStake = _info.subStakes[i];\\n            if (subStake.lastPeriod == previousPeriod &&\\n                ((crosscurrentCommittedPeriod ==\\n                (oldCurrentCommittedPeriod && _info.currentCommittedPeriod >= subStake.firstPeriod)) &&\\n                (crossnextCommittedPeriod ==\\n                (oldnextCommittedPeriod && _info.nextCommittedPeriod >= subStake.firstPeriod))))\\n            {\\n                subStake.lockedValue += uint128(_lockedValue);\\n                return;\\n            }\\n        }\\n        saveSubStake(_info, _firstPeriod, previousPeriod, 0, _lockedValue);\\n    }\\n\\n    //-------------Additional getters for stakers info-------------\\n    /**\\n    * @notice Return the length of the array of stakers\\n    */\\n    function getStakersLength() external view returns (uint256) {\\n        return stakers.length;\\n    }\\n\\n    /**\\n    * @notice Return the length of the array of sub stakes\\n    */\\n    function getSubStakesLength(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].subStakes.length;\\n    }\\n\\n    /**\\n    * @notice Return the information about sub stake\\n    */\\n    function getSubStakeInfo(address _staker, uint256 _index)\\n    // TODO change to structure when ABIEncoderV2 is released (#1501)\\n//        public view returns (SubStakeInfo)\\n        // TODO \\\"virtual\\\" only for tests, probably will be removed after #1512\\n        external view virtual returns (uint16 firstPeriod, uint16 lastPeriod, uint16 periods, uint128 lockedValue)\\n    {\\n        SubStakeInfo storage info = stakerInfo[_staker].subStakes[_index];\\n        firstPeriod = info.firstPeriod;\\n        lastPeriod = info.lastPeriod;\\n        periods = info.periods;\\n        lockedValue = info.lockedValue;\\n    }\\n\\n    /**\\n    * @notice Return the length of the array of past downtime\\n    */\\n    function getPastDowntimeLength(address _staker) external view returns (uint256) {\\n        return stakerInfo[_staker].pastDowntime.length;\\n    }\\n\\n    /**\\n    * @notice Return the information about past downtime\\n    */\\n    function  getPastDowntime(address _staker, uint256 _index)\\n    // TODO change to structure when ABIEncoderV2 is released (#1501)\\n//        public view returns (Downtime)\\n        external view returns (uint16 startPeriod, uint16 endPeriod)\\n    {\\n        Downtime storage downtime = stakerInfo[_staker].pastDowntime[_index];\\n        startPeriod = downtime.startPeriod;\\n        endPeriod = downtime.endPeriod;\\n    }\\n\\n    //------------------ ERC900 connectors ----------------------\\n\\n    function totalStakedForAt(address _owner, uint256 _blockNumber) public view override returns (uint256){\\n        return stakerInfo[_owner].history.getValueAt(_blockNumber);\\n    }\\n\\n    function totalStakedAt(uint256 _blockNumber) public view override returns (uint256){\\n        return balanceHistory.getValueAt(_blockNumber);\\n    }\\n\\n    function supportsHistory() external pure override returns (bool){\\n        return true;\\n    }\\n\\n    //------------------------Upgradeable------------------------\\n    /**\\n    * @dev Get StakerInfo structure by delegatecall\\n    */\\n    function delegateGetStakerInfo(address _target, bytes32 _staker)\\n        internal returns (StakerInfo memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(_target, this.stakerInfo.selector, 1, _staker, 0);\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /**\\n    * @dev Get SubStakeInfo structure by delegatecall\\n    */\\n    function delegateGetSubStakeInfo(address _target, bytes32 _staker, uint256 _index)\\n        internal returns (SubStakeInfo memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(\\n            _target, this.getSubStakeInfo.selector, 2, _staker, bytes32(_index));\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /**\\n    * @dev Get Downtime structure by delegatecall\\n    */\\n    function delegateGetPastDowntime(address _target, bytes32 _staker, uint256 _index)\\n        internal returns (Downtime memory result)\\n    {\\n        bytes32 memoryAddress = delegateGetData(\\n            _target, this.getPastDowntime.selector, 2, _staker, bytes32(_index));\\n        assembly {\\n            result := memoryAddress\\n        }\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\\n    function verifyState(address _testTarget) public override virtual {\\n        super.verifyState(_testTarget);\\n        require(address(delegateGet(_testTarget, this.policyManager.selector)) == address(policyManager));\\n        require(address(delegateGet(_testTarget, this.adjudicator.selector)) == address(adjudicator));\\n        require(address(delegateGet(_testTarget, this.workLock.selector)) == address(workLock));\\n        require(delegateGet(_testTarget, this.lockedPerPeriod.selector,\\n            bytes32(bytes2(RESERVED_PERIOD))) == lockedPerPeriod[RESERVED_PERIOD]);\\n        require(address(delegateGet(_testTarget, this.stakerFromWorker.selector, bytes32(0))) ==\\n            stakerFromWorker[address(0)]);\\n\\n        require(delegateGet(_testTarget, this.getStakersLength.selector) == stakers.length);\\n        if (stakers.length == 0) {\\n            return;\\n        }\\n        address stakerAddress = stakers[0];\\n        require(address(uint160(delegateGet(_testTarget, this.stakers.selector, 0))) == stakerAddress);\\n        StakerInfo storage info = stakerInfo[stakerAddress];\\n        bytes32 staker = bytes32(uint256(stakerAddress));\\n        StakerInfo memory infoToCheck = delegateGetStakerInfo(_testTarget, staker);\\n        require(infoToCheck.value == info.value &&\\n            infoToCheck.currentCommittedPeriod == info.currentCommittedPeriod &&\\n            infoToCheck.nextCommittedPeriod == info.nextCommittedPeriod &&\\n            infoToCheck.flags == info.flags &&\\n            infoToCheck.lockReStakeUntilPeriod == info.lockReStakeUntilPeriod &&\\n            infoToCheck.lastCommittedPeriod == info.lastCommittedPeriod &&\\n            infoToCheck.completedWork == info.completedWork &&\\n            infoToCheck.worker == info.worker &&\\n            infoToCheck.workerStartPeriod == info.workerStartPeriod);\\n\\n        require(delegateGet(_testTarget, this.getPastDowntimeLength.selector, staker) ==\\n            info.pastDowntime.length);\\n        for (uint256 i = 0; i < info.pastDowntime.length && i < MAX_CHECKED_VALUES; i++) {\\n            Downtime storage downtime = info.pastDowntime[i];\\n            Downtime memory downtimeToCheck = delegateGetPastDowntime(_testTarget, staker, i);\\n            require(downtimeToCheck.startPeriod == downtime.startPeriod &&\\n                downtimeToCheck.endPeriod == downtime.endPeriod);\\n        }\\n\\n        require(delegateGet(_testTarget, this.getSubStakesLength.selector, staker) == info.subStakes.length);\\n        for (uint256 i = 0; i < info.subStakes.length && i < MAX_CHECKED_VALUES; i++) {\\n            SubStakeInfo storage subStakeInfo = info.subStakes[i];\\n            SubStakeInfo memory subStakeInfoToCheck = delegateGetSubStakeInfo(_testTarget, staker, i);\\n            require(subStakeInfoToCheck.firstPeriod == subStakeInfo.firstPeriod &&\\n                subStakeInfoToCheck.lastPeriod == subStakeInfo.lastPeriod &&\\n                subStakeInfoToCheck.periods == subStakeInfo.periods &&\\n                subStakeInfoToCheck.lockedValue == subStakeInfo.lockedValue);\\n        }\\n\\n        // it's not perfect because checks not only slot value but also decoding\\n        // at least without additional functions\\n        require(delegateGet(_testTarget, this.totalStakedForAt.selector, staker, bytes32(block.number)) ==\\n            totalStakedForAt(stakerAddress, block.number));\\n        require(delegateGet(_testTarget, this.totalStakedAt.selector, bytes32(block.number)) ==\\n            totalStakedAt(block.number));\\n\\n        if (info.worker != address(0)) {\\n            require(address(delegateGet(_testTarget, this.stakerFromWorker.selector, bytes32(uint256(info.worker)))) ==\\n                stakerFromWorker[info.worker]);\\n        }\\n    }\\n\\n    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `finishUpgrade`\\n    function finishUpgrade(address _target) public override virtual {\\n        super.finishUpgrade(_target);\\n        // Create fake period\\n        lockedPerPeriod[RESERVED_PERIOD] = 111;\\n\\n        // Create fake worker\\n        stakerFromWorker[address(0)] = address(this);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract NuCypherToken\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_hoursPerPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_issuanceDecayCoefficient\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDurationCoefficient1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDurationCoefficient2\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_maximumRewardedPeriods\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_firstPhaseTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_firstPhaseMaxIssuance\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_minLockedPeriods\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_minAllowableLockedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAllowableLockedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_minWorkerPeriods\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_isTestContract\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"period\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"CommitmentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"periods\",\"type\":\"uint16\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"lastPeriod\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"periods\",\"type\":\"uint16\"}],\"name\":\"Divided\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Donated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservedReward\",\"type\":\"uint256\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"firstPeriod\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"periods\",\"type\":\"uint16\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"lastPeriod\",\"type\":\"uint16\"}],\"name\":\"Merged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"period\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"lastPeriod\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"periods\",\"type\":\"uint16\"}],\"name\":\"Prolonged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"lockUntilPeriod\",\"type\":\"uint16\"}],\"name\":\"ReStakeLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"reStake\",\"type\":\"bool\"}],\"name\":\"ReStakeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investigator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Slashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"snapshotsEnabled\",\"type\":\"bool\"}],\"name\":\"SnapshotSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"testTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"StateVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"UpgradeFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"windDown\",\"type\":\"bool\"}],\"name\":\"WindDownSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"measureWork\",\"type\":\"bool\"}],\"name\":\"WorkMeasurementSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"worker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"startPeriod\",\"type\":\"uint16\"}],\"name\":\"WorkerBonded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUB_STAKES\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adjudicator\",\"outputs\":[{\"internalType\":\"contract AdjudicatorInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceHistory\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_stakers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_numberOfSubStakes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_periods\",\"type\":\"uint16[]\"}],\"name\":\"batchDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_worker\",\"type\":\"address\"}],\"name\":\"bondWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commitToNextPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMintingPeriod\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPeriodSupply\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_periods\",\"type\":\"uint16\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositAndIncrease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_periods\",\"type\":\"uint16\"}],\"name\":\"depositFromWorkLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newValue\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_periods\",\"type\":\"uint16\"}],\"name\":\"divideStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_period\",\"type\":\"uint16\"}],\"name\":\"findIndexOfPastDowntime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"finishUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstPhaseMaxIssuance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstPhaseTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_periods\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxStakers\",\"type\":\"uint256\"}],\"name\":\"getActiveStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allLockedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2][]\",\"name\":\"activeStakers\",\"type\":\"uint256[2][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getAllTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getCompletedWork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getFlags\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"windDown\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"reStake\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"measureWork\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"snapshots\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getLastCommittedPeriod\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLastPeriodOfSubStake\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_periods\",\"type\":\"uint16\"}],\"name\":\"getLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPastDowntime\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"startPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"endPeriod\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getPastDowntimeLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReservedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getSubStakeInfo\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"firstPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"lastPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"periods\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"lockedValue\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getSubStakesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getWorkerFromStaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reservedReward\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sourceOfFunds\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"isReStakeLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTestContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUpgrade\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_periods\",\"type\":\"uint16\"}],\"name\":\"lockAndCreate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"lockAndIncrease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDurationCoefficient1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDurationCoefficient2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_lockReStakeUntilPeriod\",\"type\":\"uint16\"}],\"name\":\"lockReStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"lockedPerPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAllowableLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumRewardedPeriods\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index2\",\"type\":\"uint256\"}],\"name\":\"mergeStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAllowableLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minLockedPeriods\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minWorkerPeriods\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingCoefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policyManager\",\"outputs\":[{\"internalType\":\"contract PolicyManagerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousPeriodSupply\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_periods\",\"type\":\"uint16\"}],\"name\":\"prolongStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondsPerPeriod\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AdjudicatorInterface\",\"name\":\"_adjudicator\",\"type\":\"address\"}],\"name\":\"setAdjudicator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PolicyManagerInterface\",\"name\":\"_policyManager\",\"type\":\"address\"}],\"name\":\"setPolicyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_reStake\",\"type\":\"bool\"}],\"name\":\"setReStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enableSnapshots\",\"type\":\"bool\"}],\"name\":\"setSnapshots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_windDown\",\"type\":\"bool\"}],\"name\":\"setWindDown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract WorkLockInterface\",\"name\":\"_workLock\",\"type\":\"address\"}],\"name\":\"setWorkLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_measureWork\",\"type\":\"bool\"}],\"name\":\"setWorkMeasurement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_penalty\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_investigator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"slashStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerFromWorker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"currentCommittedPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"nextCommittedPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"lastCommittedPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"lockReStakeUntilPeriod\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"completedWork\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"workerStartPeriod\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"worker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSlot5\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportsHistory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract NuCypherToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalStakedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalStakedForAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_testTarget\",\"type\":\"address\"}],\"name\":\"verifyState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"workLock\",\"outputs\":[{\"internalType\":\"contract WorkLockInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StakingEscrow","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004fe83213d56308330ec302a8bd641f1d0113a4cc0000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000041d000000000000000000000000000000000000000000000000000000000000016d00000000000000000000000000000000000000000000000000000000000002da000000000000000000000000000000000000000000000000000000000000016d0000000000000000000000000000000000000000092492d451ad95edc960000000000000000000000000000000000000000000000000d44a25d4c6c7b4efc7e3000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000032d26d12e980b60000000000000000000000000000000000000000000000018d0bf423c03d8de00000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}