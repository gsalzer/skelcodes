{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\modules\\Ownable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Managerable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ncontract Managerable is Ownable {\r\n\r\n    address private _managerAddress;\r\n    /**\r\n     * @dev modifier, Only manager can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyManager() {\r\n        require(_managerAddress == msg.sender,\"Managerable: caller is not the Manager\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev set manager by owner. \r\n     *\r\n     */\r\n    function setManager(address managerAddress)\r\n    public\r\n    onlyOwner\r\n    {\r\n        _managerAddress = managerAddress;\r\n    }\r\n    /**\r\n     * @dev get manager address. \r\n     *\r\n     */\r\n    function getManager()public view returns (address) {\r\n        return _managerAddress;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\whiteList.sol\r\n\r\npragma solidity >=0.5.16;\r\n/**\r\n * SPDX-License-Identifier: GPL-3.0-or-later\r\n * FinNexus\r\n * Copyright (C) 2020 FinNexus Options Protocol\r\n */\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint32.\r\n     */\r\nlibrary whiteListUint32 {\r\n    /**\r\n     * @dev add uint32 into white list.\r\n     * @param whiteList the storage whiteList.\r\n     * @param temp input value\r\n     */\r\n\r\n    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\r\n        if (!isEligibleUint32(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    /**\r\n     * @dev remove uint32 from whitelist.\r\n     */\r\n    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint256.\r\n     */\r\nlibrary whiteListUint256 {\r\n    // add whiteList\r\n    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\r\n        if (!isEligibleUint256(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible address.\r\n     */\r\nlibrary whiteListAddress {\r\n    // add whiteList\r\n    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\r\n        if (!isEligibleAddress(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Operator.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * each operator can be granted exclusive access to specific functions.\r\n *\r\n */\r\ncontract Operator is Ownable {\r\n    mapping(uint256=>address) private _operators;\r\n    /**\r\n     * @dev modifier, Only indexed operator can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyOperator(uint256 index) {\r\n        require(_operators[index] == msg.sender,\"Operator: caller is not the eligible Operator\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev modify indexed operator by owner. \r\n     *\r\n     */\r\n    function setOperator(uint256 index,address addAddress)public onlyOwner{\r\n        _operators[index] = addAddress;\r\n    }\r\n    function getOperator(uint256 index)public view returns (address) {\r\n        return _operators[index];\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Halt.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\ncontract Halt is Ownable {\r\n    \r\n    bool private halted = false; \r\n    \r\n    modifier notHalted() {\r\n        require(!halted,\"This contract is halted\");\r\n        _;\r\n    }\r\n\r\n    modifier isHalted() {\r\n        require(halted,\"This contract is not halted\");\r\n        _;\r\n    }\r\n    \r\n    /// @notice function Emergency situation that requires \r\n    /// @notice contribution period to stop or not.\r\n    function setHalt(bool halt) \r\n        public \r\n        onlyOwner\r\n    {\r\n        halted = halt;\r\n    }\r\n}\r\n\r\n// File: contracts\\Airdrop\\AirdropVaultData.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\ncontract AirDropVaultData is Operator,Halt {\r\n\r\n    \r\n    address public optionColPool;//the option manager address\r\n    address public minePool;    //the fixed minePool address\r\n    address public cfnxToken;   //the cfnx toekn address\r\n    address public fnxToken;    //fnx token address\r\n    address public ftpbToken;   //ftpb toekn address\r\n    \r\n    uint256 public totalWhiteListAirdrop; //total ammout for white list seting accounting\r\n    uint256 public totalWhiteListClaimed; //total claimed amount by the user in white list\r\n    uint256 public totalFreeClaimed;      //total claimed amount by the user in curve or hegic\r\n    uint256 public maxWhiteListFnxAirDrop;//the max claimable limit for white list user\r\n    uint256 public maxFreeFnxAirDrop;     // the max claimable limit for hegic or curve user\r\n    \r\n    uint256 public claimBeginTime;  //airdrop start time\r\n    uint256 public claimEndTime;    //airdrop finish time\r\n    uint256 public fnxPerFreeClaimUser; //the fnx amount for each person in curve or hegic\r\n\r\n\r\n    mapping (address => uint256) public userWhiteList; //the white list user info\r\n    mapping (address => uint256)  public tkBalanceRequire; //target airdrop token list address=>min balance require\r\n    address[] public tokenWhiteList; //the token address for free air drop\r\n    \r\n    //the user which is claimed already for different token\r\n    mapping (address=>mapping(address => bool)) public freeClaimedUserList; //the users list for the user claimed already from curve or hegic\r\n    \r\n    uint256 public sushiTotalMine;  //sushi total mine amount for accounting\r\n    uint256 public sushiMineStartTime; //suhi mine start time\r\n    uint256 public sushimineInterval = 30 days; //sushi mine reward interval time\r\n    mapping (address => uint256) public suhiUserMineBalance; //the user balance for subcidy for sushi mine\r\n    mapping (uint256=>mapping(address => bool)) sushiMineRecord;//the user list which user mine is set already\r\n    \r\n    event AddWhiteList(address indexed claimer, uint256 indexed amount);\r\n    event WhiteListClaim(address indexed claimer, uint256 indexed amount,uint256 indexed ftpbnum);\r\n    event UserFreeClaim(address indexed claimer, uint256 indexed amount,uint256 indexed ftpbnum);\r\n    \r\n    event AddSushiList(address indexed claimer, uint256 indexed amount);\r\n    event SushiMineClaim(address indexed claimer, uint256 indexed amount);\r\n}\r\n\r\n// File: contracts\\modules\\SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\ERC20\\IERC20.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\Airdrop\\AirdropVault.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n\r\ninterface IOptionMgrPoxy {\r\n    function addCollateral(address collateral,uint256 amount) external payable;\r\n}\r\n\r\ninterface IMinePool {\r\n    function lockAirDrop(address user,uint256 ftp_b_amount) external;\r\n}\r\n\r\ninterface ITargetToken {\r\n     function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n\r\ncontract AirDropVault is AirDropVaultData {\r\n    using SafeMath for uint256;\r\n    \r\n    modifier airdropinited() {\r\n        require(optionColPool!=address(0),\"collateral pool address should be set\");\r\n        require(minePool!=address(0),\"mine pool address should be set\");\r\n        require(fnxToken!=address(0),\"fnx token address should be set\");\r\n        require(ftpbToken!=address(0),\"ftpb token address should be set\");\r\n        require(claimBeginTime>0,\"airdrop claim begin time should be set\");\r\n        require(claimEndTime>0,\"airdrop claim end time should be set\");\r\n        require(fnxPerFreeClaimUser>0,\"the air drop number for each free claimer should be set\");\r\n        require(maxWhiteListFnxAirDrop>0,\"the max fnx number for whitelist air drop should be set\");\r\n        require(maxFreeFnxAirDrop>0,\"the max fnx number for free air drop should be set\");\r\n        _;\r\n    }\r\n    \r\n    modifier suhsimineinited() {\r\n        require(cfnxToken!=address(0),\"cfnc token address should be set\");\r\n        require(sushiMineStartTime>0,\"sushi mine start time should be set\");\r\n        require(sushimineInterval>0,\"sushi mine interval should be set\");\r\n        _;\r\n    }    \r\n\r\n    function initialize() onlyOwner public {}\r\n    \r\n    function update() onlyOwner public{ \r\n\r\n        \r\n        userWhiteList[0x6fC1B3e4aEB54772D0CB96F5aCb4c60E70c29aB9] = 1000 ether;//https://etherscan.io/tx/0xec6021191e5e3f5d3af2494ee265e68bfa5f721dca9c82fbc96c2d666477d097\r\n        userWhiteList[0x0c18cc3A37E6969Df5CCe67D1579d645115b4861] = 1000 ether;//https://etherscan.io/tx/0x9c0ff821b4cca5ef08a61f33e77d9e595a814369ceb4ddf76e8b20773f659dfa\r\n        userWhiteList[0x4a96B3C9997E06eD17CE4948586F87D7d14D8d7e] = 1000 ether;//https://etherscan.io/tx/0x51758bf71230f0b5ae66a485f4fd4e0f1fce191c0e8d4d27a25d1c713e419ea8\r\n        \r\n\r\n        uint256 j;\r\n        //recover it to false\r\n        for(j=0;j<tokenWhiteList.length;j++) {\r\n            freeClaimedUserList[tokenWhiteList[j]][0xAbd252CfbaE138043e4fB5E667B489710964D572] = false;//https://etherscan.io/tx/0xe67383074eefe031fcdca9db63c7d582b410275bfabf1c4834aa1b01e764de28\r\n            freeClaimedUserList[tokenWhiteList[j]][0x2D8e5b082dFA5cD2A8EcFA5A0a93956cAD3dF91A] = false;//https://etherscan.io/tx/0x91aa4d999df2d6782bb884973c11f51fc7bdc423e75e2cfed51bde04f8885dcf\r\n        }\r\n        \r\n        uint256  MAX_UINT = (2**256 - 1);\r\n        IERC20(ftpbToken).approve(minePool,MAX_UINT);\r\n        \r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev init function,init air drop\r\n     * @param _optionColPool  the option collateral contract address\r\n     * @param _fnxToken  the fnx token address\r\n     * @param _ftpbToken the ftpb token address\r\n     * @param _claimBeginTime the start time for airdrop\r\n     * @param _claimEndTime  the end time for airdrop\r\n     * @param _fnxPerFreeClaimUser the fnx amo for each person in airdrop\r\n     * @param _maxFreeFnxAirDrop the max fnx amount for free claimer from hegic,curve\r\n     * @param _maxWhiteListFnxAirDrop the mx fnx number in whitelist ways\r\n     */\r\n    function initAirdrop( address _optionColPool,\r\n                                address _minePool,\r\n                                address _fnxToken,\r\n                                address _ftpbToken,\r\n                                uint256 _claimBeginTime,\r\n                                uint256 _claimEndTime,\r\n                                uint256 _fnxPerFreeClaimUser,\r\n                                uint256 _maxFreeFnxAirDrop,\r\n                                uint256 _maxWhiteListFnxAirDrop) public onlyOwner {\r\n        if(_optionColPool!=address(0))                            \r\n            optionColPool = _optionColPool;\r\n        if(_minePool!=address(0))    \r\n            minePool = _minePool;\r\n        if(_fnxToken!=address(0))    \r\n            fnxToken = _fnxToken;  \r\n        if(_ftpbToken!=address(0))    \r\n            ftpbToken = _ftpbToken;\r\n        \r\n        if(_claimBeginTime>0)    \r\n            claimBeginTime = _claimBeginTime;\r\n         \r\n        if(_claimEndTime>0)    \r\n            claimEndTime = _claimEndTime;\r\n            \r\n        if(_fnxPerFreeClaimUser>0)    \r\n            fnxPerFreeClaimUser = _fnxPerFreeClaimUser;\r\n\r\n        if(_maxFreeFnxAirDrop>0)\r\n            maxFreeFnxAirDrop = _maxFreeFnxAirDrop;\r\n            \r\n        if(_maxWhiteListFnxAirDrop>0)    \r\n            maxWhiteListFnxAirDrop = _maxWhiteListFnxAirDrop;\r\n    }\r\n    \r\n    /**\r\n     * @dev init function,init sushi mine\r\n     * @param _cfnxToken  the mined reward token\r\n     * @param _sushiMineStartTime mine start time\r\n     * @param _sushimineInterval the sushi mine time interval\r\n     */\r\n    function initSushiMine(address _cfnxToken,uint256 _sushiMineStartTime,uint256 _sushimineInterval) public onlyOwner{\r\n        if(_cfnxToken!=address(0))\r\n            cfnxToken = _cfnxToken;\r\n        if(_sushiMineStartTime>0)    \r\n            sushiMineStartTime = _sushiMineStartTime;\r\n        if(_sushimineInterval>0)    \r\n            sushimineInterval = _sushimineInterval;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev getting back the left mine token\r\n     * @param _reciever the reciever for getting back mine token\r\n     */\r\n    function getbackLeftFnx(address _reciever)  public onlyOwner {\r\n        uint256 bal =  IERC20(fnxToken).balanceOf(address(this));\r\n        if(bal>0)\r\n            IERC20(fnxToken).transfer(_reciever,bal);\r\n        \r\n        bal = IERC20(ftpbToken).balanceOf(address(this));\r\n        if(bal>0)\r\n            IERC20(ftpbToken).transfer(_reciever,bal);\r\n\r\n        bal = IERC20(cfnxToken).balanceOf(address(this));\r\n        if(bal>0)\r\n            IERC20(cfnxToken).transfer(_reciever,bal);            \r\n            \r\n    }  \r\n    \r\n    /**\r\n     * reset token setting in case of setting is wrong\r\n     */\r\n    function resetTokenList()  public onlyOwner {\r\n        uint256 i;\r\n        for(i=0;i<tokenWhiteList.length;i++) {\r\n            delete tkBalanceRequire[tokenWhiteList[i]];\r\n        }\r\n        \r\n        tokenWhiteList.length = 0;\r\n    }     \r\n\r\n    /**\r\n     * @dev Retrieve user's locked balance. \r\n     * @param _account user's account.\r\n     */ \r\n    function balanceOfWhitListUser(address _account) private view returns (uint256) {\r\n        \r\n        if(totalWhiteListClaimed < maxWhiteListFnxAirDrop) {\r\n            uint256 amount = userWhiteList[_account];\r\n            uint256 total = totalWhiteListClaimed.add(amount);\r\n            \r\n            if (total>maxWhiteListFnxAirDrop){\r\n                amount = maxWhiteListFnxAirDrop.sub(totalWhiteListClaimed);\r\n            }\r\n            \r\n            return amount;\r\n        }\r\n        \r\n        return 0;\r\n       \r\n    }\r\n\r\n   /**\r\n   * @dev setting function.set airdrop users address and balance in whitelist ways\r\n   * @param _accounts   the user address.tested support 200 address in one tx\r\n   * @param _fnxnumbers the user's airdrop fnx number\r\n   */   \r\n    function setWhiteList(address[] memory _accounts,uint256[] memory _fnxnumbers) public onlyOperator(1) {\r\n        require(_accounts.length==_fnxnumbers.length,\"the input array length is not equal\");\r\n        uint256 i = 0;\r\n        for(;i<_accounts.length;i++) {\r\n            if(userWhiteList[_accounts[i]]==0) {\r\n               require(_fnxnumbers[i]>0,\"fnx number must be over 0!\");\r\n               //just for tatics    \r\n               totalWhiteListAirdrop = totalWhiteListAirdrop.add(_fnxnumbers[i]);\r\n               userWhiteList[_accounts[i]] = _fnxnumbers[i];\r\n               emit AddWhiteList(_accounts[i],_fnxnumbers[i]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev claim the airdrop for user in whitelist ways\r\n    */\r\n    function whitelistClaim() internal /*airdropinited*/ {\r\n        // require(now >= claimBeginTime,\"claim not begin\");\r\n        // require(now < claimEndTime,\"claim finished\");\r\n\r\n        if(totalWhiteListClaimed < maxWhiteListFnxAirDrop) {\r\n          \r\n           if(userWhiteList[msg.sender]>0) {\r\n               \r\n                uint256 amount = userWhiteList[msg.sender];\r\n                userWhiteList[msg.sender] = 0;\r\n                uint256 total = totalWhiteListClaimed.add(amount);\r\n                if (total>maxWhiteListFnxAirDrop){\r\n                    amount = maxWhiteListFnxAirDrop.sub(totalWhiteListClaimed);\r\n                }\r\n                totalWhiteListClaimed = totalWhiteListClaimed.add(amount);\r\n                \r\n                // IERC20(fnxToken).approve(optionColPool,amount);\r\n                // uint256 prefptb = IERC20(ftpbToken).balanceOf(address(this));\r\n                // IOptionMgrPoxy(optionColPool).addCollateral(fnxToken,amount);\r\n                // uint256 afterftpb = IERC20(ftpbToken).balanceOf(address(this));\r\n                // uint256 ftpbnum = afterftpb.sub(prefptb);\r\n                // IERC20(ftpbToken).approve(minePool,ftpbnum);\r\n                // IMinePool(minePool).lockAirDrop(msg.sender,ftpbnum);\r\n                // emit WhiteListClaim(msg.sender,amount,ftpbnum);\r\n                \r\n                //1000 fnx = 94 fpt\r\n                uint256 ftpbnum = 100 ether;\r\n               // IERC20(ftpbToken).approve(minePool,ftpbnum);\r\n                IMinePool(minePool).lockAirDrop(msg.sender,ftpbnum);\r\n                emit UserFreeClaim(msg.sender,amount,ftpbnum);\r\n            }\r\n         }\r\n    }\r\n    \r\n   /**\r\n   * @dev setting function.set target token and required balance for airdrop token\r\n   * @param _tokens   the tokens address.tested support 200 address in one tx\r\n   * @param _minBalForFreeClaim  the required minimal balance for the claimer\r\n   */    \r\n    function setTokenList(address[] memory _tokens,uint256[] memory _minBalForFreeClaim) public onlyOwner {\r\n        uint256 i = 0;\r\n        require(_tokens.length==_minBalForFreeClaim.length,\"array length is not match\");\r\n        for (i=0;i<_tokens.length;i++) {\r\n            if(tkBalanceRequire[_tokens[i]]==0) {\r\n                require(_minBalForFreeClaim[i]>0,\"the min balance require must be over 0!\");\r\n                tkBalanceRequire[_tokens[i]] = _minBalForFreeClaim[i];\r\n                tokenWhiteList.push(_tokens[i]);\r\n            }\r\n        }\r\n    }\r\n    \r\n   /**\r\n   * @dev getting function.get user claimable airdrop balance for curve.hegic user\r\n   * @param _targetToken the token address for getting balance from it for user \r\n   * @param _account user address\r\n   */     \r\n    function balanceOfFreeClaimAirDrop(address _targetToken,address _account) public view airdropinited returns(uint256){\r\n        require(tkBalanceRequire[_targetToken]>0,\"the target token is not set active\");\r\n        require(now >= claimBeginTime,\"claim not begin\");\r\n        require(now < claimEndTime,\"claim finished\");\r\n        if(!freeClaimedUserList[_targetToken][_account]) {\r\n            if(totalFreeClaimed < maxFreeFnxAirDrop) {\r\n                uint256 bal = ITargetToken(_targetToken).balanceOf(_account);\r\n                if(bal>=tkBalanceRequire[_targetToken]) {\r\n                    uint256 amount = fnxPerFreeClaimUser;\r\n                    uint256 total = totalFreeClaimed.add(amount);\r\n                    if(total>maxFreeFnxAirDrop) {\r\n                        amount = maxFreeFnxAirDrop.sub(totalFreeClaimed);\r\n                    }\r\n                    return amount;\r\n                }\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n   /**\r\n   * @dev user claim airdrop for curve.hegic user\r\n   * @param _targetToken the token address for getting balance from it for user \r\n   */ \r\n    function freeClaim(address _targetToken) internal /*airdropinited*/ {\r\n        // require(tkBalanceRequire[_targetToken]>0,\"the target token is not set active\");\r\n        // require(now >= claimBeginTime,\"claim not begin\");\r\n        // require(now < claimEndTime,\"claim finished\");\r\n        \r\n        //the user not claimed yet\r\n        if(!freeClaimedUserList[_targetToken][msg.sender]) {\r\n            //total claimed fnx not over the max free claim limit\r\n           if(totalFreeClaimed < maxFreeFnxAirDrop) {\r\n                //get user balance in target token\r\n                uint256 bal = ITargetToken(_targetToken).balanceOf(msg.sender);\r\n                //over the required balance number\r\n                if(bal >= tkBalanceRequire[_targetToken]){\r\n                    \r\n                    //set user claimed already\r\n                    freeClaimedUserList[_targetToken][msg.sender] = true;\r\n\r\n                    uint256 amount = fnxPerFreeClaimUser; \r\n                    uint256 total = totalFreeClaimed.add(amount);\r\n                    if(total>maxFreeFnxAirDrop) {\r\n                        amount = maxFreeFnxAirDrop.sub(totalFreeClaimed);\r\n                    }\r\n                    totalFreeClaimed = totalFreeClaimed.add(amount);\r\n                    \r\n                  //  IERC20(fnxToken).approve(optionColPool,amount);\r\n                   // uint256 prefptb = IERC20(ftpbToken).balanceOf(address(this));\r\n                   // IOptionMgrPoxy(optionColPool).addCollateral(fnxToken,amount);\r\n                   // uint256 afterftpb = IERC20(ftpbToken).balanceOf(address(this));\r\n                  //  uint256 ftpbnum = afterftpb.sub(prefptb);\r\n                  //  IERC20(ftpbToken).approve(minePool,ftpbnum);\r\n                  //  IMinePool(minePool).lockAirDrop(msg.sender,ftpbnum);\r\n                  //  emit UserFreeClaim(msg.sender,amount,ftpbnum);\r\n                  //1000 fnx = 94 fpt\r\n                  \r\n                  uint256 ftpbnum = 100 ether;\r\n                 // IERC20(ftpbToken).approve(minePool,ftpbnum);\r\n                  IMinePool(minePool).lockAirDrop(msg.sender,ftpbnum);\r\n                  emit UserFreeClaim(_targetToken,amount,ftpbnum);\r\n                }\r\n            }\r\n        }\r\n    }   \r\n\r\n        \r\n   /**\r\n   * @dev setting function.set user the subcidy balance for sushi fnx-eth miners\r\n   * @param _accounts   the user address.tested support 200 address in one tx\r\n   * @param _fnxnumbers the user's mined fnx number\r\n   */    \r\n   function setSushiMineList(address[] memory _accounts,uint256[] memory _fnxnumbers) public onlyOperator(2) {\r\n        require(_accounts.length==_fnxnumbers.length,\"the input array length is not equal\");\r\n        uint256 i = 0;\r\n        uint256 idx = (now - sushiMineStartTime)/sushimineInterval;\r\n        for(;i<_accounts.length;i++) {\r\n            if(!sushiMineRecord[idx][_accounts[i]]) {\r\n                require(_fnxnumbers[i] > 0, \"fnx number must be over 0!\");\r\n                \r\n                sushiMineRecord[idx][_accounts[i]] = true;\r\n                suhiUserMineBalance[_accounts[i]] = suhiUserMineBalance[_accounts[i]].add(_fnxnumbers[i]);\r\n                sushiTotalMine = sushiTotalMine.add(_fnxnumbers[i]);\r\n                \r\n                emit AddSushiList(_accounts[i],_fnxnumbers[i]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev  user get fnx subsidy for sushi fnx-eth mine pool\r\n     */\r\n    function sushiMineClaim() public suhsimineinited {\r\n        require(suhiUserMineBalance[msg.sender]>0,\"sushi mine balance is not enough\");\r\n        \r\n        uint256 amount = suhiUserMineBalance[msg.sender];\r\n        suhiUserMineBalance[msg.sender] = 0;\r\n        \r\n        uint256 precfnx = IERC20(cfnxToken).balanceOf(address(this));\r\n        IERC20(cfnxToken).transfer(msg.sender,amount);\r\n        uint256 aftercfnc = IERC20(cfnxToken).balanceOf(address(this));\r\n        uint256 cfncnum = precfnx.sub(aftercfnc);\r\n        require(cfncnum==amount,\"transfer balance is wrong\");\r\n        emit SushiMineClaim(msg.sender,amount);\r\n    }\r\n    \r\n    /**\r\n     * @dev getting function.retrieve all of the balance for airdrop include whitelist and free claimer\r\n     * @param _account  the user \r\n     */    \r\n    function balanceOfAirDrop(address _account) public view returns(uint256){\r\n        uint256 whitelsBal = balanceOfWhitListUser(_account);\r\n        uint256 i = 0;\r\n        uint256 freeClaimBal = 0;\r\n        for(i=0;i<tokenWhiteList.length;i++) {\r\n           freeClaimBal = freeClaimBal.add(balanceOfFreeClaimAirDrop(tokenWhiteList[i],_account));\r\n        }\r\n        \r\n        return whitelsBal.add(freeClaimBal);\r\n    }\r\n    \r\n    /**\r\n     * @dev claim all of the airdrop include whitelist and free claimer\r\n     */\r\n    function claimAirdrop() public airdropinited{\r\n        require(now >= claimBeginTime,\"claim not begin\");\r\n        require(now < claimEndTime,\"claim finished\");        \r\n        whitelistClaim();\r\n        \r\n        uint256 i;\r\n        address targetToken;\r\n         for(i=0;i<tokenWhiteList.length;i++) {\r\n            targetToken = tokenWhiteList[i]; \r\n            if(tkBalanceRequire[targetToken]>0) {\r\n                freeClaim(targetToken);\r\n            }\r\n         }\r\n    }\r\n      \r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddSushiList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddWhiteList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SushiMineClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ftpbnum\",\"type\":\"uint256\"}],\"name\":\"UserFreeClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ftpbnum\",\"type\":\"uint256\"}],\"name\":\"WhiteListClaim\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOfAirDrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOfFreeClaimAirDrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfnxToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimBeginTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fnxPerFreeClaimUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fnxToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"freeClaimedUserList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ftpbToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reciever\",\"type\":\"address\"}],\"name\":\"getbackLeftFnx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_optionColPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fnxToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ftpbToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_claimBeginTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fnxPerFreeClaimUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxFreeFnxAirDrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxWhiteListFnxAirDrop\",\"type\":\"uint256\"}],\"name\":\"initAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cfnxToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sushiMineStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sushimineInterval\",\"type\":\"uint256\"}],\"name\":\"initSushiMine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxFreeFnxAirDrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxWhiteListFnxAirDrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"optionColPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetTokenList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"halt\",\"type\":\"bool\"}],\"name\":\"setHalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fnxnumbers\",\"type\":\"uint256[]\"}],\"name\":\"setSushiMineList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_minBalForFreeClaim\",\"type\":\"uint256[]\"}],\"name\":\"setTokenList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fnxnumbers\",\"type\":\"uint256[]\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"suhiUserMineBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sushiMineClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sushiMineStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sushiTotalMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sushimineInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tkBalanceRequire\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenWhiteList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFreeClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWhiteListAirdrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWhiteListClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userWhiteList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AirDropVault","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b92432efd4022e67802572e1520cbf79fb920fe27d238479fa0242ec3a10be13"}]}