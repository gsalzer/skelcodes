{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CoverMarketMakers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\r\\n\\r\\npragma solidity ^0.7.5;\\r\\n\\r\\nimport \\\"./utils/SafeMath.sol\\\";\\r\\nimport \\\"./utils/SafeERC20.sol\\\";\\r\\n\\r\\ninterface IProtocolFactory {\\r\\n  function getCovTokenAddress(bytes32 _protocolName, uint48 _timestamp, address _collateral, uint256 _claimNonce, bool _isClaimCovToken) external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IProtocol {\\r\\n  function name() external view returns (bytes32);\\r\\n  function claimNonce() external view returns (uint256);\\r\\n  function addCover(address _collateral, uint48 _timestamp, uint256 _amount)\\r\\n    external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IBPool {\\r\\n    function getBalance(address) external view returns (uint);\\r\\n    function getNormalizedWeight(address) external view returns (uint);\\r\\n    function joinPool(uint, uint[] calldata maxAmountsIn) external;\\r\\n    function exitPool(uint, uint[] calldata minAmountsOut) external;\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function getFinalTokens() external view returns (address[] memory tokens);\\r\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint spotPrice);\\r\\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint spotPrice);\\r\\n}\\r\\n\\r\\ninterface ICover {\\r\\n  function redeemCollateral(uint256 _amount) external;\\r\\n}\\r\\n\\r\\ncontract CoverMarketMakers {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IProtocolFactory public factory;\\r\\n    IERC20 public daiToken;\\r\\n\\r\\n    // Initialize, called once\\r\\n    constructor (IProtocolFactory _factory) {\\r\\n      factory = _factory;\\r\\n    }\\r\\n\\r\\n    // Mint CLAIM / NOCLAIM , deposit CLAIM and NOCLAIM in balancer and return BPTs\\r\\n    function marketMakerDeposit(\\r\\n      IProtocol _protocol,\\r\\n      IBPool _claimPool,\\r\\n      IBPool _noclaimPool,\\r\\n      uint48 _expiration,\\r\\n      uint256 _mintAmount,\\r\\n      uint256 _collateraLpAmount,\\r\\n      address _collateral\\r\\n    ) external {\\r\\n      IERC20(_collateral).safeTransferFrom(msg.sender, address(this), (_collateraLpAmount.add(_mintAmount)));\\r\\n      if (IERC20(_collateral).allowance(address(this), address(_protocol)) < (_collateraLpAmount.add(_mintAmount))) {\\r\\n        IERC20(_collateral).approve(address(_protocol), uint256(-1));\\r\\n      }\\r\\n      address noclaimTokenAddr = factory.getCovTokenAddress(_protocol.name(), _expiration, _collateral, _protocol.claimNonce(), false);\\r\\n      address claimTokenAddr = factory.getCovTokenAddress(_protocol.name(), _expiration, _collateral, _protocol.claimNonce(), true);\\r\\n\\r\\n      _protocol.addCover(_collateral, _expiration, _mintAmount);\\r\\n      _provideLiquidity(_claimPool, claimTokenAddr, _mintAmount, _collateral, _collateraLpAmount);\\r\\n      _provideLiquidity(_noclaimPool, noclaimTokenAddr, _mintAmount, _collateral, _collateraLpAmount);\\r\\n\\r\\n      uint256 remainCollateral = IERC20(_collateral).balanceOf(address(this));\\r\\n      if (remainCollateral > 0) {\\r\\n        IERC20(_collateral).safeTransfer(msg.sender, remainCollateral);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Withdraws liquidity from both CLAIM / NOCLAIM pools\\r\\n    function marketMakerWithdraw(\\r\\n      IProtocol _protocol,\\r\\n      address _claimPoolAddr,\\r\\n      address _noclaimPoolAddr,\\r\\n      uint48 _expiration,\\r\\n      address _collateral,\\r\\n      uint256 _bptAmountClaim,\\r\\n      uint256 _bptAmountNoClaim\\r\\n    ) external {\\r\\n      _withdrawLiquidity(_claimPoolAddr, _noclaimPoolAddr, _bptAmountClaim, _bptAmountNoClaim);\\r\\n\\r\\n      address noclaimTokenAddr = factory.getCovTokenAddress(_protocol.name(), _expiration, _collateral, _protocol.claimNonce(), false);\\r\\n      address claimTokenAddr = factory.getCovTokenAddress(_protocol.name(), _expiration, _collateral, _protocol.claimNonce(), true);\\r\\n\\r\\n      IERC20 claimToken = IERC20(claimTokenAddr);\\r\\n      IERC20 noClaimToken = IERC20(noclaimTokenAddr);\\r\\n      IERC20 collateralToken = IERC20(_collateral);\\r\\n      claimToken.safeTransfer(msg.sender, claimToken.balanceOf(address(this)));\\r\\n      noClaimToken.safeTransfer(msg.sender, noClaimToken.balanceOf(address(this)));\\r\\n      collateralToken.safeTransfer(msg.sender, collateralToken.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function marketMakerWithdrawAndRedeem(\\r\\n      IProtocol _protocol,\\r\\n      ICover _cover,\\r\\n      address _claimPoolAddr,\\r\\n      address _noclaimPoolAddr,\\r\\n      uint48 _expiration,\\r\\n      address _collateral,\\r\\n      uint256 _bptAmountClaim,\\r\\n      uint256 _bptAmountNoClaim\\r\\n      ) external {\\r\\n      _withdrawLiquidity(_claimPoolAddr, _noclaimPoolAddr, _bptAmountClaim, _bptAmountNoClaim);\\r\\n\\r\\n      address noclaimTokenAddr = factory.getCovTokenAddress(_protocol.name(), _expiration, _collateral, _protocol.claimNonce(), false);\\r\\n      address claimTokenAddr = factory.getCovTokenAddress(_protocol.name(), _expiration, _collateral, _protocol.claimNonce(), true);\\r\\n\\r\\n      IERC20 claimToken = IERC20(claimTokenAddr);\\r\\n      IERC20 noClaimToken = IERC20(noclaimTokenAddr);\\r\\n\\r\\n      address redeemCovAddr = claimToken.balanceOf(address(this)) > noClaimToken.balanceOf(address(this)) ? noclaimTokenAddr : claimTokenAddr;\\r\\n      address remainCovAddr = redeemCovAddr == claimTokenAddr ? noclaimTokenAddr : claimTokenAddr;\\r\\n\\r\\n      _cover.redeemCollateral(IERC20(redeemCovAddr).balanceOf(address(this)));\\r\\n\\r\\n      if (IERC20(remainCovAddr).balanceOf(address(this)) > 0) {\\r\\n        IERC20(remainCovAddr).safeTransfer(msg.sender, IERC20(remainCovAddr).balanceOf(address(this)));\\r\\n      }\\r\\n      IERC20(_collateral).safeTransfer(msg.sender, IERC20(_collateral).balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function _withdrawLiquidity(\\r\\n      address _claimPoolAddr,\\r\\n      address _noclaimPoolAddr,\\r\\n      uint256 _bptAmountClaim,\\r\\n      uint256 _bptAmountNoClaim\\r\\n      ) private {\\r\\n      require(_bptAmountClaim > 0, \\\"MarketMaker: insufficient bpt balance\\\");\\r\\n      require(_bptAmountNoClaim > 0, \\\"MarketMaker: insufficient bpt balance\\\");\\r\\n\\r\\n      uint256[] memory minAmountsOut = new uint256[](2);\\r\\n      minAmountsOut[0] = 0;\\r\\n      minAmountsOut[1] = 0;\\r\\n\\r\\n      IERC20(_claimPoolAddr).safeTransferFrom(msg.sender, address(this), _bptAmountClaim);\\r\\n      IERC20(_noclaimPoolAddr).safeTransferFrom(msg.sender, address(this), _bptAmountNoClaim);\\r\\n      IBPool(_claimPoolAddr).exitPool(IERC20(_claimPoolAddr).balanceOf(address(this)), minAmountsOut);\\r\\n      IBPool(_noclaimPoolAddr).exitPool(IERC20(_noclaimPoolAddr).balanceOf(address(this)), minAmountsOut);\\r\\n    }\\r\\n\\r\\n    function _provideLiquidity(\\r\\n      IBPool _bPool,\\r\\n      address _covTokenAddress,\\r\\n      uint256 _covTokenAmount,\\r\\n      address _collateralAddress,\\r\\n      uint256 _collateralAmount\\r\\n      ) private {\\r\\n      if (IERC20(_covTokenAddress).allowance(address(this), address(_bPool)) < _covTokenAmount) {\\r\\n        IERC20(_covTokenAddress).approve(address(_bPool), uint256(-1));\\r\\n      }\\r\\n      if (IERC20(_collateralAddress).allowance(address(this), address(_bPool)) < _collateralAmount) {\\r\\n        IERC20(_collateralAddress).approve(address(_bPool), uint256(-1));\\r\\n      }\\r\\n\\r\\n      uint256 poolAmountOutInCov = _covTokenAmount.mul(_bPool.totalSupply()).div(_bPool.getBalance(_covTokenAddress));\\r\\n      uint256 poolAmountOutInCollateral = _collateralAmount.mul(_bPool.totalSupply()).div(_bPool.getBalance(_collateralAddress));\\r\\n      uint256 bptAmountOut = poolAmountOutInCov > poolAmountOutInCollateral ? poolAmountOutInCollateral : poolAmountOutInCov;\\r\\n      bptAmountOut = bptAmountOut.sub((uint256(1 ether))); // Buffer, alternatively bptAmountOut.mul(99).div(100);\\r\\n\\r\\n      address[] memory tokenAddresses = _bPool.getFinalTokens();\\r\\n      uint[] memory maxAmountsIn = new uint256[](2);\\r\\n      if(tokenAddresses[0] == _collateralAddress){\\r\\n        maxAmountsIn[0] = _collateralAmount;\\r\\n        maxAmountsIn[1] = _covTokenAmount;\\r\\n      } else {\\r\\n        maxAmountsIn[0] = _covTokenAmount;\\r\\n        maxAmountsIn[1] = _collateralAmount;\\r\\n      }\\r\\n\\r\\n      _bPool.joinPool(bptAmountOut, maxAmountsIn);\\r\\n      require((IERC20(address(_bPool)).balanceOf(address(this)) == bptAmountOut), \\\"LP_FAILED\\\");\\r\\n\\r\\n      IERC20 bpt = IERC20(address(_bPool));\\r\\n      bpt.safeTransfer(msg.sender, bpt.balanceOf(address(this)));\\r\\n      uint256 remainCovToken = IERC20(_covTokenAddress).balanceOf(address(this));\\r\\n      if (remainCovToken > 0) {\\r\\n        IERC20(_covTokenAddress).safeTransfer(msg.sender, remainCovToken);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    function getCollateralAmountLp(\\r\\n      IBPool _bPool,\\r\\n      address _covTokenAddr,\\r\\n      address _collateralAddr,\\r\\n      uint256 _mintAmount\\r\\n      ) external view returns(uint256) {\\r\\n\\r\\n      return _bPool.getBalance(_collateralAddr).mul(_mintAmount).div(_bPool.getBalance(_covTokenAddr));\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\r\\n\\r\\npragma solidity ^0.7.4;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.5;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length > 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.4;\\r\\n\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256('')`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash && codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        return _functionCallWithValue(target, data, value, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\r\\n\\r\\npragma solidity ^0.7.3;\\r\\n\\r\\n/**\\r\\n * @title Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IProtocolFactory\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"daiToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IProtocolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBPool\",\"name\":\"_bPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_covTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_mintAmount\",\"type\":\"uint256\"}],\"name\":\"getCollateralAmountLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocol\",\"name\":\"_protocol\",\"type\":\"address\"},{\"internalType\":\"contract IBPool\",\"name\":\"_claimPool\",\"type\":\"address\"},{\"internalType\":\"contract IBPool\",\"name\":\"_noclaimPool\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"_expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"_mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collateraLpAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"}],\"name\":\"marketMakerDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocol\",\"name\":\"_protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_claimPoolAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_noclaimPoolAddr\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"_expiration\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bptAmountClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bptAmountNoClaim\",\"type\":\"uint256\"}],\"name\":\"marketMakerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocol\",\"name\":\"_protocol\",\"type\":\"address\"},{\"internalType\":\"contract ICover\",\"name\":\"_cover\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_claimPoolAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_noclaimPoolAddr\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"_expiration\",\"type\":\"uint48\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bptAmountClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bptAmountNoClaim\",\"type\":\"uint256\"}],\"name\":\"marketMakerWithdrawAndRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CoverMarketMakers","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000edfc81bf63527337cd2193925f9c0cf2d537acca","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}