{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity  ^0.6.0;\r\n\r\ncontract SafeMath {\r\n   /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeSub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function safeSub(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\r\n        require(b <= a, error);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function safeDiv(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\r\n        require(b > 0, error);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeExponent(uint256 a,uint256 b) internal pure returns (uint256) {\r\n        uint256 result;\r\n        assembly {\r\n            result:=exp(a, b)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: contracts\\DateTime.sol\r\n\r\npragma solidity ^0.6;\r\n\r\ncontract DateTime {\r\n        /*\r\n         *  Date and Time utilities for ethereum contracts\r\n         *\r\n         */\r\n        struct _DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) public pure returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) public pure returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal pure returns (_DateTime memory dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n\r\n                // Minute\r\n                dt.minute = getMinute(timestamp);\r\n\r\n                // Second\r\n                dt.second = getSecond(timestamp);\r\n\r\n                // Day of week.\r\n                dt.weekday = getWeekday(timestamp);\r\n        }\r\n\r\n        function getYear(uint timestamp) public pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }\r\n\r\n        function getMinute(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60) % 60);\r\n        }\r\n\r\n        function getSecond(uint timestamp) public pure returns (uint8) {\r\n                return uint8(timestamp % 60);\r\n        }\r\n\r\n        function getWeekday(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, 0, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, minute, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\r\n                uint16 i;\r\n\r\n                // Year\r\n                for (i = ORIGIN_YEAR; i < year; i++) {\r\n                        if (isLeapYear(i)) {\r\n                                timestamp += LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                timestamp += YEAR_IN_SECONDS;\r\n                        }\r\n                }\r\n\r\n                // Month\r\n                uint8[12] memory monthDayCounts;\r\n                monthDayCounts[0] = 31;\r\n                if (isLeapYear(year)) {\r\n                        monthDayCounts[1] = 29;\r\n                }\r\n                else {\r\n                        monthDayCounts[1] = 28;\r\n                }\r\n                monthDayCounts[2] = 31;\r\n                monthDayCounts[3] = 30;\r\n                monthDayCounts[4] = 31;\r\n                monthDayCounts[5] = 30;\r\n                monthDayCounts[6] = 31;\r\n                monthDayCounts[7] = 31;\r\n                monthDayCounts[8] = 30;\r\n                monthDayCounts[9] = 31;\r\n                monthDayCounts[10] = 30;\r\n                monthDayCounts[11] = 31;\r\n\r\n                for (i = 1; i < month; i++) {\r\n                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n                }\r\n\r\n                // Day\r\n                timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n                // Hour\r\n                timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n                // Minute\r\n                timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n                // Second\r\n                timestamp += second;\r\n\r\n                return timestamp;\r\n        }\r\n}\r\n\r\n// File: contracts\\STYK_I.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract STYK_I is SafeMath, DateTime {\r\n    constructor(\r\n        uint256 _lockTime,\r\n        uint256 _auctionExpiryTime,\r\n        uint256 _auctionLimit,\r\n        uint256 _stakeAmount\r\n    ) public {\r\n        STYK_REWARD_TOKENS = safeMul(200000, 1e18);\r\n        MONTHLY_REWARD_TOKENS = safeMul(100000, 1e18);\r\n\r\n        tokenBalanceLedger_[address(this)] = safeAdd(\r\n            STYK_REWARD_TOKENS,\r\n            MONTHLY_REWARD_TOKENS\r\n        );\r\n        // time lock for 100 years\r\n        lockTime = _lockTime;\r\n        auctionExpiryTime = _auctionExpiryTime;\r\n        auctionEthLimit = _auctionLimit;\r\n        stakingRequirement = _stakeAmount;\r\n        inflationPayOutDays = safeAdd(now, 500 days);\r\n    }\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    // only people with tokens\r\n    modifier onlybelievers() {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    // only people with profits\r\n    modifier onlyhodler() {\r\n        require(myDividends(true) > 0);\r\n        _;\r\n    }\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n\r\n    // ERC20\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    string public name = \"STYK I\";\r\n    string public symbol = \"STYK\";\r\n    uint256 public constant decimals = 18;\r\n    uint8 internal constant dividendFee_ = 10;\r\n    uint256 internal constant tokenPriceInitial_ = 0.0000001 ether;\r\n    uint256 internal constant tokenPriceIncremental_ = 0.00000001 ether;\r\n    uint256 internal constant magnitude = 2**64;\r\n    uint256 STYK_REWARD_TOKENS;\r\n\r\n    uint256 MONTHLY_REWARD_TOKENS;\r\n\r\n    uint256 internal inflationTime;\r\n\r\n    uint256 internal lockTime;\r\n    uint256 internal inflationPayOutDays;\r\n    uint56 internal userCount = 0;\r\n    uint256 public inflationCounter = 0;\r\n\r\n    // proof of stake (defaults at 1 token)\r\n    uint256 internal stakingRequirement;\r\n\r\n    /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n\r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) internal referralBalance_;\r\n    mapping(address => bool) public rewardQualifier;\r\n    mapping(address => uint256) internal stykRewards;\r\n    mapping(address => address[]) internal referralUsers;\r\n    mapping(address => mapping(address => bool)) internal userExists;\r\n    mapping(address => bool) internal earlyadopters;\r\n    mapping(address => bool) internal userAdded;\r\n    mapping(address => uint256) internal userIndex;\r\n    mapping(address => int256) internal payoutsTo_;\r\n    mapping(address => uint256) internal totalMonthRewards;\r\n    mapping(address => uint256) internal earlyadopterBonus;\r\n    mapping(address => uint256) internal userDeposit;\r\n    mapping(address => bool) internal auctionAddressTracker;\r\n    mapping(address => mapping(uint256 => mapping (uint256 => bool)))public monthlyRewardsClaimed;\r\n    mapping(address =>mapping(uint256 => bool))public stykclaimMap;\r\n\r\n    address[] internal userAddress;\r\n    uint256 internal tokenSupply_ = 0;\r\n    uint256 public auctionEthLimit;\r\n    uint256 public auctionExpiryTime;\r\n    uint256 internal profitPerShare_;\r\n    uint256 internal auctionProfitPerShare_;\r\n\r\n    /**\r\n     * Converts all incoming Ethereum to tokens for the caller, and passes down the referral address (if any)\r\n     */\r\n    function buy(address _referredBy) public payable returns (uint256) {\r\n        purchaseTokens(msg.value, _referredBy);\r\n    }\r\n\r\n    //Cannot directly deposit ethers\r\n    fallback() external payable {\r\n        revert(\"ERR_CANNOT_FORCE_ETHERS\");\r\n    }\r\n\r\n    //Cannot directly deposit ethers\r\n    receive() external payable {\r\n        revert(\"ERR_CANNOT_FORCE_ETHERS\");\r\n    }\r\n\r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    function reinvest() public onlyhodler() {\r\n        // pay out the dividends virtually\r\n        address _customerAddress = msg.sender;\r\n        // fetch dividends\r\n        uint256 _dividends = totalDividends(_customerAddress);\r\n        userDeposit[_customerAddress] = 0;\r\n        payoutsTo_[_customerAddress] += (int256)(\r\n            _dividendsOf(_customerAddress) * magnitude\r\n        );\r\n        referralBalance_[_customerAddress] = 0;\r\n\r\n        //determine whether user qualify for early adopter bonus or not\r\n        if (\r\n            earlyadopters[_customerAddress] &&\r\n            (now > safeAdd(auctionExpiryTime, 24 hours))\r\n        ) {\r\n            if (tokenBalanceLedger_[_customerAddress] == 0) {\r\n                earlyadopterBonus[_customerAddress] = 0;\r\n            }\r\n            earlyadopters[_customerAddress] = false;\r\n        }\r\n\r\n        //determine whether user qualify for styk bonus or not\r\n        if (\r\n            rewardQualifier[_customerAddress] &&\r\n            _calculateInflationMinutes() > 4320\r\n        ) {\r\n            stykRewards[_customerAddress] = 0;\r\n            rewardQualifier[_customerAddress] = false;\r\n        }\r\n        if (totalMonthRewards[_customerAddress] != 0) {\r\n            totalMonthRewards[_customerAddress] = 0;\r\n        }\r\n\r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens = purchaseTokens(_dividends, address(0));\r\n\r\n        // fire event\r\n        emit onReinvestment(_customerAddress, _dividends, _tokens);\r\n    }\r\n\r\n    /**\r\n     * Alias of sell() and withdraw().\r\n     */\r\n    function exit() public {\r\n        // get token count for caller & sell them all\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n\r\n        if (_tokens > 0) sell(_tokens);\r\n\r\n        withdraw();\r\n        userAdded[_customerAddress] = false;\r\n\r\n        uint256 index = getUserAddressIndex(_customerAddress);\r\n        address _lastAddress = userAddress[userAddress.length - 1];\r\n        uint256 _lastindex = getUserAddressIndex(_lastAddress);\r\n        userAddress[index] = _lastAddress;\r\n        userAddress[userAddress.length - 1] = _customerAddress;\r\n\r\n        userIndex[_lastAddress] = index;\r\n        userIndex[_customerAddress] = _lastindex;\r\n        delete userIndex[_customerAddress];\r\n        userAddress.pop();\r\n        userCount--;\r\n    }\r\n\r\n    /**\r\n     * Withdraws all of the callers earnings.\r\n     */\r\n    function withdraw() public onlyhodler() {\r\n        // setup data\r\n        address payable _customerAddress = msg.sender;\r\n        uint256 _dividends = totalDividends(_customerAddress);\r\n\r\n        userDeposit[_customerAddress] = 0;\r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress] += (int256)(\r\n            _dividendsOf(_customerAddress) * magnitude\r\n        );\r\n        referralBalance_[_customerAddress] = 0;\r\n\r\n        //determine whether user qualify for early adopter bonus or not\r\n        if (\r\n            earlyadopters[_customerAddress] &&\r\n            (now > safeAdd(auctionExpiryTime, 24 hours))\r\n        ) {\r\n            if (tokenBalanceLedger_[_customerAddress] == 0) {\r\n                earlyadopterBonus[_customerAddress] = 0;\r\n            }\r\n            earlyadopters[_customerAddress] = false;\r\n        }\r\n\r\n        //determine whether user qualify for styk bonus or not\r\n        if (\r\n            rewardQualifier[_customerAddress] &&\r\n            _calculateInflationMinutes() > 4320\r\n        ) {\r\n            stykRewards[_customerAddress] = 0;\r\n            rewardQualifier[_customerAddress] = false;\r\n        }\r\n        if (totalMonthRewards[_customerAddress] != 0) {\r\n            totalMonthRewards[_customerAddress] = 0;\r\n        }\r\n        // delivery service\r\n        _customerAddress.transfer(_dividends);\r\n\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n\r\n    /**\r\n     * Liquifies tokens to ethereum.\r\n     */\r\n    function sell(uint256 _amountOfTokens) public onlybelievers() {\r\n        address _customerAddress = msg.sender;\r\n\r\n        require(\r\n            now > auctionExpiryTime,\r\n            \"ERR_CANNOT_SELL_TOKENS_BEFORE_AUCTION\"\r\n        );\r\n\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\r\n\r\n        if (tokenBalanceLedger_[_customerAddress] == _amountOfTokens) {\r\n            if (earlyadopters[_customerAddress]) {\r\n                earlyadopterBonus[_customerAddress] = earlyAdopterBonus(\r\n                    _customerAddress\r\n                );\r\n            }\r\n            if (rewardQualifier[_customerAddress]) {\r\n                stykRewards[_customerAddress] = STYKRewards(_customerAddress);\r\n            }\r\n        }\r\n\r\n        // burn the sold tokens\r\n        tokenSupply_ = safeSub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = safeSub(\r\n            tokenBalanceLedger_[_customerAddress],\r\n            _tokens\r\n        );\r\n\r\n        if (auctionAddressTracker[_customerAddress]) {\r\n            int256 _updatedPayouts = (int256)(auctionProfitPerShare_ * _tokens);\r\n            payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n        } else {\r\n            int256 _updatedPayouts = (int256)(profitPerShare_ * _tokens);\r\n            payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n        }\r\n\r\n        // dividing by zero is a bad idea\r\n        if (tokenSupply_ > 0) {\r\n            // update the amount of dividends per token\r\n            auctionProfitPerShare_ = safeAdd(\r\n                auctionProfitPerShare_,\r\n                (_dividends * magnitude) /\r\n                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\r\n            );\r\n\r\n            profitPerShare_ = safeAdd(\r\n                profitPerShare_,\r\n                (_dividends * magnitude) /\r\n                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\r\n            );\r\n        }\r\n\r\n        userDeposit[_customerAddress] = safeAdd(\r\n            userDeposit[_customerAddress],\r\n            _taxedEthereum\r\n        );\r\n\r\n        // fire events\r\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\r\n        emit Transfer(_customerAddress, address(0), _amountOfTokens);\r\n    }\r\n\r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Method to view the current Ethereum stored in the contract\r\n     * Example: totalEthereumBalance()\r\n     */\r\n    function totalEthereumBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the dividends owned by the caller.\r\n     */\r\n    function myDividends(bool _includeReferralBonus)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return\r\n            _includeReferralBonus\r\n                ? _dividendsOf(_customerAddress) +\r\n                    referralBalance_[_customerAddress]\r\n                : _dividendsOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address _customerAddress) public view returns (uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    /**\r\n     * Retrieve the dividend balance of any single address.\r\n     */\r\n    function _dividendsOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (auctionAddressTracker[_customerAddress]) {\r\n            return\r\n                safeAdd(\r\n                    (uint256)(\r\n                        (int256)(\r\n                            auctionProfitPerShare_ *\r\n                                (tokenBalanceLedger_[_customerAddress])\r\n                        ) - payoutsTo_[_customerAddress]\r\n                    ) / magnitude,\r\n                    userDeposit[_customerAddress]\r\n                );\r\n        } else {\r\n            return\r\n                safeAdd(\r\n                    (uint256)(\r\n                        (int256)(\r\n                            profitPerShare_ *\r\n                                (tokenBalanceLedger_[_customerAddress])\r\n                        ) - payoutsTo_[_customerAddress]\r\n                    ) / magnitude,\r\n                    userDeposit[_customerAddress]\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the buy price of 1 individual token.\r\n     */\r\n    function sellPrice() external view returns (uint256) {\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n            uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the sell price of 1 individual token.\r\n     */\r\n    function buyPrice() public view returns (uint256) {\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n            uint256 _taxedEthereum = safeAdd(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n\r\n    function calculateTokensReceived(uint256 _ethereumToSpend)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 _dividends = safeDiv(_ethereumToSpend, dividendFee_);\r\n        uint256 _taxedEthereum = safeSub(_ethereumToSpend, _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    function calculateEthereumReceived(uint256 _tokensToSell)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\r\n        return _taxedEthereum;\r\n    }\r\n\r\n    /*==========================================\r\n    =            Methods Developed By Minddeft    =\r\n    ==========================================*/\r\n\r\n    function _inflation() internal view returns (uint256) {\r\n        uint256 buyPrice_ = buyPrice();\r\n        uint256 inflation_factor = safeDiv(buyPrice_, 1e12);\r\n        return inflation_factor;\r\n    }\r\n\r\n    // chainlink already give data as 10**8 so convert to 18 decimal\r\n    function checkInflation() external view returns (uint256) {\r\n        return _inflation();\r\n    }\r\n\r\n    //To set inflationTime when inflation factor reaches 2% of ethereum\r\n    function setInflationTime() internal {\r\n        if (_inflation() >= 20000 || now > inflationPayOutDays) {\r\n            inflationTime = now;\r\n            inflationPayOutDays = safeAdd(inflationTime, 500 days);\r\n             ++inflationCounter;\r\n        }\r\n    }\r\n\r\n    //To calculate Inflation minutes (72 hours converted into minutes)\r\n    function _calculateInflationMinutes() internal view returns (uint256) {\r\n        if (inflationTime == 0) {\r\n            return 0;\r\n        }\r\n        return safeDiv(safeSub(now, inflationTime), 60);\r\n    }\r\n\r\n    function calculateInflationMinutes() external view returns (uint256) {\r\n        return _calculateInflationMinutes();\r\n    }\r\n\r\n    //To calculate Token Percentage\r\n    function _calculateTokenPercentage(address _customerAddress)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (tokenBalanceLedger_[_customerAddress] > 0) {\r\n            uint256 token_percent =\r\n                safeDiv(\r\n                    safeMul(tokenBalanceLedger_[_customerAddress], 1000000),\r\n                    totalSupply()\r\n                );\r\n            return token_percent;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    //To calculate Token Percentage\r\n    function calculateTokenPercentage(address _customerAddress)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _calculateTokenPercentage(_customerAddress);\r\n    }\r\n\r\n    //To calculate user's STYK rewards\r\n    function _calculateSTYKReward(address _customerAddress)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (now > auctionExpiryTime) {\r\n            uint256 token_percent = _calculateTokenPercentage(_customerAddress);\r\n            if (token_percent > 0) {\r\n                uint256 rewards =\r\n                    safeDiv(\r\n                        safeMul(\r\n                            _dividendsOfPremintedTokens(STYK_REWARD_TOKENS),\r\n                            token_percent\r\n                        ),\r\n                        1000000\r\n                    );\r\n                return rewards;\r\n            }\r\n            return 0;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function calculateSTYKReward(address _customerAddress)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _calculateSTYKReward(_customerAddress);\r\n    }\r\n\r\n    //To activate deflation\r\n    function deflationSell() external {\r\n        uint256 inflationMinutes = _calculateInflationMinutes();\r\n        require(\r\n            inflationMinutes <= 4320,\r\n            \"ERR_INFLATION_MINUTES_SHOULD_BE_LESS_THAN_4320\"\r\n        );\r\n\r\n        require(!stykclaimMap[msg.sender][inflationCounter], \"ERR_REWARD_ALREADY_CLAIMED\");\r\n\r\n        if (_calculateSTYKReward(msg.sender) > 0) {\r\n            rewardQualifier[msg.sender] = true;\r\n            stykclaimMap[msg.sender][inflationCounter] = true;\r\n            uint256 rewards = _calculateSTYKReward(msg.sender);\r\n\r\n            stykRewards[msg.sender] = safeAdd(stykRewards[msg.sender], rewards);\r\n\r\n            uint256 userToken =\r\n                safeDiv(safeMul(tokenBalanceLedger_[msg.sender], 25), 100);\r\n\r\n            sell(userToken);\r\n        }\r\n    }\r\n\r\n    //To accumulate rewards of non qualifying after deflation sell\r\n    function _deflationAccumulatedRewards() internal view returns (uint256) {\r\n        uint256 stykRewardPoolBalance = 0;\r\n\r\n        for (uint256 i = 0; i < userAddress.length; i++) {\r\n            if (userAddress[i] != address(0)) {\r\n                address _user = userAddress[i];\r\n                if (!rewardQualifier[_user]) {\r\n                    stykRewardPoolBalance = safeAdd(\r\n                        _calculateSTYKReward(_user),\r\n                        stykRewardPoolBalance\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        return stykRewardPoolBalance;\r\n    }\r\n\r\n    //To pay STYK Rewards\r\n    function STYKRewards(address _to) internal view returns (uint256) {\r\n        if (_calculateTokenPercentage(_to) > 0) {\r\n            uint256 _rewards = stykRewards[_to];\r\n            uint256 accumulatedRewards =\r\n                safeDiv(\r\n                    safeMul(\r\n                        _deflationAccumulatedRewards(),\r\n                        _calculateTokenPercentage(_to)\r\n                    ),\r\n                    1000000\r\n                );\r\n            uint256 finalRewards = safeAdd(_rewards, accumulatedRewards);\r\n            return finalRewards;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    //To calculate team token holder percent\r\n    function _teamTokenHolder(address _to) internal view returns (uint256) {\r\n        uint256 useractivecount = 0;\r\n        uint256 usertotaltokens = 0;\r\n        if (profitPerShare_ > 0) {\r\n            for (uint256 i = 0; i < referralUsers[_to].length; i++) {\r\n                address _userAddress = referralUsers[_to][i];\r\n                if (_checkUserActiveStatus(_userAddress)) {\r\n                    ++useractivecount;\r\n                }\r\n            }\r\n\r\n            if (useractivecount >= 3) {\r\n                for (uint256 i = 0; i < referralUsers[_to].length; i++) {\r\n                    address _addr = referralUsers[_to][i];\r\n                    usertotaltokens = safeAdd(\r\n                        tokenBalanceLedger_[_addr],\r\n                        usertotaltokens\r\n                    );\r\n                }\r\n                return\r\n                    safeDiv(safeMul(usertotaltokens, 1000000), totalSupply());\r\n            } else {\r\n                return 0;\r\n            }\r\n        } else return 0;\r\n    }\r\n\r\n    function teamTokenHolder(address _to) external view returns (uint256) {\r\n        return _teamTokenHolder(_to);\r\n    }\r\n\r\n    // To calculate monthly  rewards\r\n    function _calculateMonthlyRewards(address _to)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 token_percent = _teamTokenHolder(_to);\r\n        if (token_percent != 0) {\r\n            uint256 rewards =\r\n                safeDiv(\r\n                    safeMul(\r\n                        _dividendsOfPremintedTokens(MONTHLY_REWARD_TOKENS),\r\n                        token_percent\r\n                    ),\r\n                    1000000\r\n                );\r\n\r\n            return rewards;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function calculateMonthlyRewards(address _to)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _calculateMonthlyRewards(_to);\r\n    }\r\n\r\n    // To check the user's  status\r\n    function _checkUserActiveStatus(address _user)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (tokenBalanceLedger_[_user] > safeMul(10, 1e18)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    //To distribute rewards to early adopters\r\n    function earlyAdopterBonus(address _user) public view returns (uint256) {\r\n        if (tokenBalanceLedger_[_user] > 0 && earlyadopters[_user]) {\r\n            uint256 token_percent = _calculateTokenPercentage(_user);\r\n            uint256 _earlyadopterDividends =\r\n                (uint256)(\r\n                    (int256)(\r\n                        auctionProfitPerShare_ *\r\n                            tokenBalanceLedger_[address(this)]\r\n                    )\r\n                ) / magnitude;\r\n            uint256 rewards =\r\n                safeDiv(\r\n                    safeMul(_earlyadopterDividends, token_percent),\r\n                    1000000\r\n                );\r\n            return rewards;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    //To get user affiliate rewards\r\n    function getUserAffiliateBalance(address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return referralBalance_[_user];\r\n    }\r\n\r\n    //To retrieve the index of user's address\r\n    function getUserAddressIndex(address _customerAddress)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return userIndex[_customerAddress];\r\n    }\r\n\r\n    /**\r\n     * Retrieve the dividends from pre-minted tokens.\r\n     */\r\n    function _dividendsOfPremintedTokens(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (uint256)((int256)(profitPerShare_ * _tokens)) / magnitude;\r\n    }\r\n\r\n    //To calculate total dividends of user\r\n    function totalDividends(address _customerAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 _dividends = _dividendsOf(_customerAddress);\r\n\r\n        uint256 qualifying_rewards;\r\n        if (\r\n            earlyadopters[_customerAddress] &&\r\n            (now > safeAdd(auctionExpiryTime, 24 hours))\r\n        ) {\r\n            if (tokenBalanceLedger_[_customerAddress] > 0) {\r\n                qualifying_rewards = safeAdd(\r\n                    qualifying_rewards,\r\n                    earlyAdopterBonus(_customerAddress)\r\n                );\r\n            } else {\r\n                qualifying_rewards = safeAdd(\r\n                    qualifying_rewards,\r\n                    earlyadopterBonus[_customerAddress]\r\n                );\r\n            }\r\n        }\r\n        if (\r\n            rewardQualifier[_customerAddress] &&\r\n            _calculateInflationMinutes() > 4320\r\n        ) {\r\n            if (tokenBalanceLedger_[_customerAddress] > 0) {\r\n                qualifying_rewards = safeAdd(\r\n                    qualifying_rewards,\r\n                    STYKRewards(_customerAddress)\r\n                );\r\n            } else {\r\n                qualifying_rewards = safeAdd(\r\n                    qualifying_rewards,\r\n                    stykRewards[_customerAddress]\r\n                );\r\n            }\r\n        }\r\n\r\n        if (totalMonthRewards[_customerAddress] != 0) {\r\n            qualifying_rewards = safeAdd(\r\n                qualifying_rewards,\r\n                totalMonthRewards[_customerAddress]\r\n            );\r\n        }\r\n\r\n        return (\r\n            safeAdd(\r\n                safeAdd(_dividends, qualifying_rewards),\r\n                referralBalance_[_customerAddress]\r\n            )\r\n        );\r\n    }\r\n\r\n    //To Claim Monthly Rewards\r\n    function claimMonthlyRewards() external {\r\n        address _customerAddress = msg.sender;\r\n        \r\n        require(_calculateMonthlyRewards(_customerAddress) > 0 ,\"ERR_YOU_DONT_QUALIFY\");\r\n        \r\n        uint256 daysPayout = safeSub(getDaysInMonth(getMonth(now), getYear(now)),1);\r\n\r\n        require(\r\n            (getDay(now) == daysPayout || getDay(now) == getDaysInMonth(getMonth(now), getYear(now))),\r\n            \"ERR_CANNOT_CLAIM_BEFORE_PAYOUT\"\r\n        );\r\n        \r\n        require(!monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)],\"ERR_REWARD_ALREADY_CLAIMED\");\r\n        \r\n        if (_calculateTokenPercentage(_customerAddress) != 0) {\r\n            totalMonthRewards[_customerAddress] = safeAdd(\r\n                totalMonthRewards[_customerAddress],\r\n                _calculateMonthlyRewards(_customerAddress)\r\n            );\r\n            monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)] = true;\r\n        \r\n        }\r\n    }\r\n\r\n    //To release the pre-minted tokens after the lock time\r\n    function release() external {\r\n        require(now > lockTime, \"ERR_CANNOT_RELEASE_TOKENS_BEFORE_LOCK_TIME\");\r\n\r\n        uint256 amount = tokenBalanceLedger_[address(this)];\r\n        tokenSupply_ = safeAdd(tokenSupply_, amount);\r\n    }\r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // data setup\r\n        address _customerAddress = msg.sender;\r\n        uint256 _undividedDividends = safeDiv(_incomingEthereum, dividendFee_);\r\n        uint256 _referralBonus = safeDiv(_undividedDividends, 2);\r\n        uint256 _dividends = safeSub(_undividedDividends, _referralBonus);\r\n        uint256 _taxedEthereum =\r\n            safeSub(_incomingEthereum, _undividedDividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        uint256 _fee = _dividends * magnitude;\r\n\r\n        require(\r\n            _amountOfTokens > 0 &&\r\n                (safeAdd(_amountOfTokens, tokenSupply_) > tokenSupply_)\r\n        );\r\n\r\n        // is the user referred by a karmalink?\r\n        if (\r\n            _referredBy != address(0) &&\r\n            // no cheating!\r\n            _referredBy != _customerAddress &&\r\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\r\n        ) {\r\n            // wealth redistribution\r\n            referralBalance_[_referredBy] = safeAdd(\r\n                referralBalance_[_referredBy],\r\n                _referralBonus\r\n            );\r\n        } else {\r\n            // no ref purchase\r\n            // add the referral bonus back to the global dividends cake\r\n            _dividends = safeAdd(_dividends, _referralBonus);\r\n            _fee = _dividends * magnitude;\r\n        }\r\n\r\n        // add tokens to the pool\r\n        tokenSupply_ = safeAdd(tokenSupply_, _amountOfTokens);\r\n\r\n        // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\r\n        if (now > auctionExpiryTime) {\r\n            profitPerShare_ += ((_dividends * magnitude) /\r\n                safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)]));\r\n        }\r\n        auctionProfitPerShare_ += ((_dividends * magnitude) /\r\n            safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)]));\r\n\r\n        // calculate the amount of tokens the customer receives over his purchase\r\n        _fee =\r\n            _fee -\r\n            (_fee -\r\n                (_amountOfTokens *\r\n                    ((_dividends * magnitude) /\r\n                        safeAdd(\r\n                            tokenSupply_,\r\n                            tokenBalanceLedger_[address(this)]\r\n                        ))));\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = safeAdd(\r\n            tokenBalanceLedger_[_customerAddress],\r\n            _amountOfTokens\r\n        );\r\n\r\n        if (\r\n            !userExists[_referredBy][_customerAddress] &&\r\n            _referredBy != address(0) &&\r\n            _referredBy != _customerAddress\r\n        ) {\r\n            userExists[_referredBy][_customerAddress] = true;\r\n            referralUsers[_referredBy].push(_customerAddress);\r\n        }\r\n\r\n        if (now <= auctionExpiryTime) {\r\n            if (\r\n                totalEthereumBalance() <= auctionEthLimit &&\r\n                safeAdd(totalEthereumBalance(), _incomingEthereum) <=\r\n                auctionEthLimit\r\n            ) {\r\n                if (!earlyadopters[_customerAddress]) {\r\n                    earlyadopters[_customerAddress] = true;\r\n                }\r\n                if (!auctionAddressTracker[_customerAddress]) {\r\n                    auctionAddressTracker[_customerAddress] = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (auctionAddressTracker[_customerAddress]) {\r\n            int256 _updatedPayouts =\r\n                (int256)((auctionProfitPerShare_ * _amountOfTokens) - _fee);\r\n            payoutsTo_[_customerAddress] += _updatedPayouts;\r\n        } else {\r\n            int256 _updatedPayouts =\r\n                (int256)((profitPerShare_ * _amountOfTokens) - _fee);\r\n            payoutsTo_[_customerAddress] += _updatedPayouts;\r\n        }\r\n\r\n        if (!userAdded[_customerAddress]) {\r\n            userAddress.push(_customerAddress);\r\n            userAdded[_customerAddress] = true;\r\n            userIndex[_customerAddress] = userCount;\r\n            userCount++;\r\n        }\r\n\r\n        // fire event\r\n        emit onTokenPurchase(\r\n            _customerAddress,\r\n            _incomingEthereum,\r\n            _amountOfTokens,\r\n            _referredBy\r\n        );\r\n        if (now > auctionExpiryTime) {\r\n            if (inflationTime == 0 || _calculateInflationMinutes() > 4320)\r\n                setInflationTime();\r\n        }\r\n        emit Transfer(address(this), _customerAddress, _amountOfTokens);\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /**\r\n     * Calculate Token price based on an amount of incoming ethereum\r\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\r\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n    function ethereumToTokens_(uint256 _ethereum)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived =\r\n            ((\r\n                // underflow attempts BTFO\r\n                safeSub(\r\n                    (\r\n                        sqrt(\r\n                            (_tokenPriceInitial**2) +\r\n                                (2 *\r\n                                    (tokenPriceIncremental_ * 1e18) *\r\n                                    (_ethereum * 1e18)) +\r\n                                (((tokenPriceIncremental_)**2) *\r\n                                    (tokenSupply_**2)) +\r\n                                (2 *\r\n                                    (tokenPriceIncremental_) *\r\n                                    _tokenPriceInitial *\r\n                                    tokenSupply_)\r\n                        )\r\n                    ),\r\n                    _tokenPriceInitial\r\n                )\r\n            ) / (tokenPriceIncremental_)) - (tokenSupply_);\r\n\r\n        return _tokensReceived;\r\n    }\r\n\r\n    /**\r\n     * Calculate token sell value.\r\n     */\r\n    function tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n            (// underflow attempts BTFO\r\n            safeSub(\r\n                (((tokenPriceInitial_ +\r\n                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\r\n                    tokenPriceIncremental_) * (tokens_ - 1e18)),\r\n                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\r\n            ) / 1e18);\r\n        return _etherReceived;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n/*================================================================================================================================\r\n                                      \r\n                                       CREDITS        \r\n    \r\n   credit goes to POWH, GANDHIJI, HEX, WISE & ECLIPSE CITY smart contracts\" All charity work is inspired by BI Phakathi (Youtuber)\r\n  \r\n     \r\n================================================================================================================================*/","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_auctionExpiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_auctionLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"_dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionEthLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionExpiryTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateInflationMinutes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"calculateMonthlyRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"calculateSTYKReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"calculateTokenPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkInflation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimMonthlyRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deflationSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"earlyAdopterBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getDay\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"getDaysInMonth\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getHour\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinute\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMonth\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getSecond\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserAffiliateBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getWeekday\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getYear\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inflationCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"isLeapYear\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"}],\"name\":\"leapYearsBefore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"monthlyRewardsClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardQualifier\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stykclaimMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"teamTokenHolder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"day\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hour\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"minute\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"day\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hour\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"day\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"day\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hour\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"minute\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"second\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"totalDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"STYK_I","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000603c911b000000000000000000000000000000000000000000000000000000006063bb8000000000000000000000000000000000000000000000021e19e0c9bab24000000000000000000000000000000000000000000000000000000de0b6b3a7640000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0f883de0bb93bce4b2804177b2f317aaa0d8973366ded018c92c0afeca7ce3b5"}]}