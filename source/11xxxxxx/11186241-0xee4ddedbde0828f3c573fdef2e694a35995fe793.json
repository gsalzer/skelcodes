{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOAssetHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nlibrary ACOAssetHelper {\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get if the address is for Ethereum (0x0).\\r\\n     * @param _address Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address _address) internal pure returns(bool) {\\r\\n        return _address == address(0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to approve ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param spender Authorized address.\\r\\n     * @param amount Amount to authorize.\\r\\n     */\\r\\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callApproveERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callTransferERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to call transferFrom on ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param sender Address of the sender.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callTransferFromERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset symbol.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset symbol.\\r\\n     */\\r\\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetSymbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset decimals.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset decimals.\\r\\n     */\\r\\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\\r\\n        if (_isEther(asset)) {\\r\\n            return uint8(18);\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetDecimals\\\");\\r\\n            return abi.decode(returndata, (uint8));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to the asset name.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset name.\\r\\n     */\\r\\n    function _getAssetName(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"Ethereum\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetName\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset balance of an account.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param account Address of the account.\\r\\n     * @return The account balance.\\r\\n     */\\r\\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return account.balance;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetBalanceOf\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset allowance between two addresses.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @return The owner allowance for the spender.\\r\\n     */\\r\\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetAllowance\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer an asset. \\r\\n     * @param asset Address of the asset to be transferred.\\r\\n     * @param to Address of the destination.\\r\\n     * @param amount The amount to be transferred.\\r\\n     */\\r\\n    function _transferAsset(address asset, address to, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            (bool success,) = to.call{value:amount}(new bytes(0));\\r\\n            require(success, \\u0027ACOAssetHelper::_transferAsset\\u0027);\\r\\n        } else {\\r\\n            _callTransferERC20(asset, to, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to receive an asset. \\r\\n     * @param asset Address of the asset to be received.\\r\\n     * @param amount The amount to be received.\\r\\n     */\\r\\n    function _receiveAsset(address asset, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            require(msg.value == amount, \\\"ACOAssetHelper:: Invalid ETH amount\\\");\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"ACOAssetHelper:: Ether is not expected\\\");\\r\\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @param amount Amount to check allowance.\\r\\n     */\\r\\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\\r\\n        if (_getAssetAllowance(asset, owner, spender) \\u003c amount) {\\r\\n            _callApproveERC20(asset, spender, MAX_UINT);\\r\\n        }\\r\\n    }\\r\\n}\"},\"ACOVaultUSDCStrategy3CRV.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./ICurveFi3.sol\\u0027;\\r\\nimport \\u0027./ACOVaultUSDCStrategyCurveBase.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title ACOVaultUSDCStrategy3CRV\\r\\n * @dev The contract is to set the strategy for an ACO Vault.\\r\\n * This strategy is to farm CRV and use it to buy ACO options.\\r\\n */\\r\\ncontract ACOVaultUSDCStrategy3CRV is ACOVaultUSDCStrategyCurveBase {\\r\\n    constructor(VaultUSDCStrategyCurveBaseInitData memory initData) ACOVaultUSDCStrategyCurveBase(initData) public {\\r\\n        ICurveFi3 _curve = ICurveFi3(initData.curve);\\r\\n        token = _curve.coins(uint256(USDC_COIN_INDEX));\\r\\n        IERC20(token).approve(initData.controller, MAX_UINT);\\r\\n    }\\r\\n\\r\\n    function _normalizedBalanceOf(uint256 bal) internal pure override returns(uint256) {\\r\\n        return bal.div(1000000000000);\\r\\n    }\\r\\n\\r\\n    function _normalizedWithdrawAmount(uint256 amount) internal pure override returns(uint256) {\\r\\n        return amount.mul(1000000000000);\\r\\n    }\\r\\n\\r\\n    function getName() external pure returns (string memory) {\\r\\n        return \\\"ACOVaultUSDCStrategy3CRV\\\";\\r\\n    }\\r\\n\\r\\n    function deposit(uint256 amount) onlyController external override {\\r\\n        if (amount \\u003e 0) {\\r\\n            ACOAssetHelper._setAssetInfinityApprove(token, address(this), address(curve), amount);\\r\\n            ICurveFi3 _curve = ICurveFi3(address(curve));\\r\\n            _curve.add_liquidity([0,amount,0],0);\\r\\n        }\\r\\n        _depositOnGauge();\\r\\n    }\\r\\n    \\r\\n    function _withdrawUnderlying(uint256 _amount) internal override returns (uint256) {\\r\\n        IERC20 usdc = IERC20(token);\\r\\n        uint256 _before = usdc.balanceOf(address(this));\\r\\n        \\r\\n        ACOAssetHelper._setAssetInfinityApprove(address(crvPoolToken), address(this), address(curve), _amount);\\r\\n        ICurveFi3 _curve = ICurveFi3(address(curve));\\r\\n        _curve.remove_liquidity(_amount, [uint256(0),0,0]);\\r\\n    \\r\\n        _exchangeCurveCoinToUSDC(0);\\r\\n        _exchangeCurveCoinToUSDC(2);\\r\\n        \\r\\n        uint256 _after = usdc.balanceOf(address(this));\\r\\n        \\r\\n        return _after.sub(_before);\\r\\n    }\\r\\n}\"},\"ACOVaultUSDCStrategyCurveBase.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./Ownable.sol\\u0027;\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\nimport \\u0027./ACOAssetHelper.sol\\u0027;\\r\\nimport \\u0027./IACOVaultUSDCStrategyCurveBase.sol\\u0027;\\r\\nimport \\u0027./IStrategy.sol\\u0027;\\r\\nimport \\u0027./IGauge.sol\\u0027;\\r\\nimport \\u0027./IMintr.sol\\u0027;\\r\\nimport \\u0027./ICurveFiBase.sol\\u0027;\\r\\nimport \\u0027./IyERC20.sol\\u0027;\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\nimport \\u0027./IController.sol\\u0027;\\r\\nimport \\u0027./IACOAssetConverterHelper.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title ACOVaultUSDCStrategyCurveBase\\r\\n * @dev The contract is to set the strategy for an ACO Vault.\\r\\n * This strategy is to farm CRV and use it to buy ACO options.\\r\\n */\\r\\nabstract contract ACOVaultUSDCStrategyCurveBase is Ownable, IACOVaultUSDCStrategyCurveBase, IStrategy {\\r\\n    using Address for address;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n    int128 internal constant USDC_COIN_INDEX = 1;\\r\\n    uint256 internal constant MAX_GAS_SUBSIDY_FEE = 100000;\\r\\n    \\r\\n    event SetController(address indexed oldController, address indexed newController);\\r\\n    event SetAssetConverter(address indexed oldAssetConverter, address indexed newAssetConverter);\\r\\n    event SetWithdrawalFee(uint256 indexed oldWithdrawalFee, uint256 indexed newWithdrawalFee);\\r\\n    event SetGasSubsidyFee(uint256 indexed oldGasSubsidyFee, uint256 indexed newGasSubsidyFee);\\r\\n    event SetOperator(address indexed operator, bool indexed previousPermission, bool indexed newPermission);\\r\\n    \\r\\n    IGauge public immutable gauge;\\r\\n    IMintr public immutable mintr;\\r\\n    ICurveFiBase public immutable curve;\\r\\n    IERC20 public immutable crv;\\r\\n    IERC20 public immutable crvPoolToken;\\r\\n    address public override token;\\r\\n\\r\\n    IController public controller;\\r\\n    IACOAssetConverterHelper public assetConverter;\\r\\n    uint256 public gasSubsidyFee; \\r\\n\\r\\n    mapping(address =\\u003e bool) public operators;\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any address other than the controller.\\r\\n     */\\r\\n    modifier onlyController() {\\r\\n        require(msg.sender == address(controller), \\\"ACOVaultUSDCStrategyCurveBase:: caller is not the controller\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(VaultUSDCStrategyCurveBaseInitData memory initData) public {\\r\\n        super.init();\\r\\n        \\r\\n        gauge = IGauge(initData.gauge);\\r\\n        mintr = IMintr(initData.mintr);\\r\\n        curve = ICurveFiBase(initData.curve);\\r\\n        crv = IERC20(initData.crv);        \\r\\n        crvPoolToken = IERC20(initData.crvPoolToken);\\r\\n                \\r\\n        _setController(initData.controller);\\r\\n        _setAssetConverter(initData.assetConverter);\\r\\n        _setGasSubsidyFee(initData.gasSubsidyFee);\\r\\n        _setOperator(msg.sender, true);\\r\\n    }    \\r\\n\\r\\n    function setGasSubsidyFee(uint256 newGasSubsidyFee) onlyOwner external {\\r\\n        _setGasSubsidyFee(newGasSubsidyFee);\\r\\n    }\\r\\n\\r\\n    function setController(address newController) onlyOwner external {\\r\\n        _setController(newController);\\r\\n        IERC20(token).approve(newController, MAX_UINT);\\r\\n    }\\r\\n\\r\\n    function setAssetConverter(address newAssetConverter) onlyOwner external {\\r\\n        _setAssetConverter(newAssetConverter);\\r\\n    } \\r\\n\\r\\n    function setOperator(address operator, bool permission) onlyOwner external {\\r\\n        _setOperator(operator, permission);\\r\\n    }   \\r\\n    \\r\\n    function withdrawStuckToken(address _token, address destination) onlyController external override {\\r\\n        require(token != address(_token), \\\"ACOVaultUSDCStrategyCurveBase:: Invalid token\\\");\\r\\n        require(address(crv) != address(_token), \\\"ACOVaultUSDCStrategyCurveBase:: Invalid token\\\");\\r\\n        require(address(crvPoolToken) != address(_token), \\\"ACOVaultUSDCStrategyCurveBase:: Invalid token\\\");\\r\\n        uint256 _balance = ACOAssetHelper._getAssetBalanceOf(_token, address(this));\\r\\n        if (_balance \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(_token, destination, _balance);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function withdraw(uint256 _amount) onlyController external override returns (uint256) {\\r\\n        return _withdrawSome(_amount);\\r\\n    }\\r\\n    \\r\\n    function withdrawAll() onlyController external override {\\r\\n        _withdrawAll();\\r\\n    }\\r\\n\\r\\n    function harvest() external {\\r\\n        require(operators[msg.sender], \\\"ACOVaultUSDCStrategyCurveBase:: Invalid sender\\\");\\r\\n        mintr.mint(address(gauge));\\r\\n        uint256 _crvBalance = crv.balanceOf(address(this));\\r\\n        if (_crvBalance \\u003e 0) {    \\r\\n            ACOAssetHelper._setAssetInfinityApprove(address(crv), address(this), address(assetConverter), _crvBalance);\\r\\n            IERC20 _token = IERC20(token);\\r\\n            uint256 _before = _token.balanceOf(address(this));\\r\\n            assetConverter.swapExactAmountOutWithMinAmountToReceive(address(crv), address(_token), _crvBalance, 1);\\r\\n            uint256 _after = _token.balanceOf(address(this));\\r\\n\\r\\n            _collectGasSubsidyFee(_after.sub(_before));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _depositOnGauge() internal {\\r\\n        uint256 _crvPoolTokenBalance = crvPoolToken.balanceOf(address(this));\\r\\n        if (_crvPoolTokenBalance \\u003e 0) {\\r\\n            ACOAssetHelper._setAssetInfinityApprove(address(crvPoolToken), address(this), address(gauge), _crvPoolTokenBalance);\\r\\n            gauge.deposit(_crvPoolTokenBalance);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _collectGasSubsidyFee(uint256 amount) internal {\\r\\n        if (amount \\u003e 0) {\\r\\n            uint256 _fee = amount.mul(gasSubsidyFee).div(MAX_GAS_SUBSIDY_FEE);\\r\\n            controller.sendFee(_fee);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _exchangeCurveCoinToUSDC(int128 coinIndex) internal {\\r\\n        address coinAddress = curve.coins(uint256(coinIndex));\\r\\n        uint256 _balance = IERC20(coinAddress).balanceOf(address(this));\\r\\n        if (_balance \\u003e 0) {\\r\\n            ACOAssetHelper._setAssetInfinityApprove(coinAddress, address(this), address(curve), _balance);\\r\\n            curve.exchange(coinIndex, USDC_COIN_INDEX, _balance, 0);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _withdrawAll() internal {\\r\\n        gauge.withdraw(gauge.balanceOf(address(this)));\\r\\n        _withdrawUnderlying(crvPoolToken.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function _withdrawUnderlying(uint256 _amount) internal virtual returns (uint256);\\r\\n    function _normalizedWithdrawAmount(uint256 _amount) internal pure virtual returns(uint256);\\r\\n\\r\\n    function _withdrawSome(uint256 amount) internal returns (uint256) {\\r\\n        uint256 _amount = amount.mul(1e18).div(curve.get_virtual_price());\\r\\n        _amount = _normalizedWithdrawAmount(_amount);\\r\\n        \\r\\n        uint256 _before = crvPoolToken.balanceOf(address(this));\\r\\n        gauge.withdraw(_amount);\\r\\n        uint256 _after = crvPoolToken.balanceOf(address(this));\\r\\n\\r\\n        return _withdrawUnderlying(_after.sub(_before));\\r\\n    }\\r\\n    \\r\\n    function balanceOfWant() public view override returns (uint256) {\\r\\n        return IERC20(token).balanceOf(address(this));\\r\\n    }\\r\\n    \\r\\n    function balanceOfGauge() public view returns (uint256) {\\r\\n        return gauge.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    function _normalizedBalanceOf(uint256 bal) internal pure virtual returns(uint256);\\r\\n    \\r\\n    function balanceOf() external view override returns (uint256) {\\r\\n        uint256 bal = balanceOfGauge().mul(curve.get_virtual_price()).div(1e18);\\r\\n        return _normalizedBalanceOf(bal);\\r\\n    }\\r\\n    \\r\\n    function actualBalanceFor(uint256 amount) external view override returns(uint256) {\\r\\n        return amount.mul(curve.get_virtual_price()).div(1e18);\\r\\n    }\\r\\n\\r\\n    function _setController(address newController) internal {\\r\\n        require(newController.isContract(), \\\"ACOVaultUSDCStrategyCurveBase:: Invalid controller\\\");\\r\\n        emit SetController(address(controller), newController);\\r\\n        controller = IController(newController);\\r\\n    }\\r\\n    \\r\\n    function _setAssetConverter(address newAssetConverter) internal {\\r\\n        require(newAssetConverter.isContract(), \\\"ACOVaultUSDCStrategyCurveBase:: Invalid asset converter\\\");\\r\\n        emit SetAssetConverter(address(assetConverter), newAssetConverter);\\r\\n        assetConverter = IACOAssetConverterHelper(newAssetConverter);\\r\\n    }\\r\\n\\r\\n    function _setGasSubsidyFee(uint256 newGasSubsidyFee) internal {\\r\\n        require(newGasSubsidyFee \\u003c MAX_GAS_SUBSIDY_FEE, \\\"ACOVaultUSDCStrategyCurveBase:: Invalid gas subsidy fee\\\");\\r\\n        emit SetGasSubsidyFee(gasSubsidyFee, newGasSubsidyFee);\\r\\n        gasSubsidyFee = newGasSubsidyFee;\\r\\n    }\\r\\n    \\r\\n    function _setOperator(address operator, bool newPermission) internal {\\r\\n        emit SetOperator(operator, operators[operator], newPermission);\\r\\n        operators[operator] = newPermission;\\r\\n    }\\r\\n}\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"IACOAssetConverterHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOAssetConverterHelper {\\r\\n    function setPairTolerancePercentage(address baseAsset, address quoteAsset, uint256 tolerancePercentage) external;\\r\\n    function setAggregator(address baseAsset, address quoteAsset, address aggregator) external;\\r\\n    function setUniswapMiddleRoute(address baseAsset, address quoteAsset, address[] calldata uniswapMiddleRoute) external;\\r\\n    function withdrawStuckAsset(address asset, address destination) external;\\r\\n    function hasAggregator(address baseAsset, address quoteAsset) external view returns(bool);\\r\\n    function getPairData(address baseAsset, address quoteAsset) external view returns(address, uint256, uint256, uint256);\\r\\n    function getUniswapMiddleRouteByIndex(address baseAsset, address quoteAsset, uint256 index) external view returns(address);\\r\\n    function getPrice(address baseAsset, address quoteAsset) external view returns(uint256);\\r\\n    function getPriceWithTolerance(address baseAsset, address quoteAsset, bool isMinimumPrice) external view returns(uint256);\\r\\n    function getExpectedAmountOutToSwapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external view returns(uint256);\\r\\n    function getExpectedAmountOutToSwapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external view returns(uint256);\\r\\n    function swapExactAmountOut(address assetToSold, address assetToBuy, uint256 amountToSold) external payable returns(uint256);\\r\\n    function swapExactAmountOutWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 tolerancePercentage) external payable returns(uint256);\\r\\n    function swapExactAmountOutWithMinAmountToReceive(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 minAmountToReceive) external payable returns(uint256);\\r\\n    function swapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external payable returns(uint256);\\r\\n    function swapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external payable returns(uint256);\\r\\n    function swapExactAmountInWithMaxAmountToSold(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 maxAmountToSold) external payable returns(uint256);\\r\\n}\"},\"IACOVaultUSDCStrategyCurveBase.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IACOVaultUSDCStrategyCurveBase {\\r\\n    struct VaultUSDCStrategyCurveBaseInitData {\\r\\n        address curve;\\r\\n        address gauge;\\r\\n        address mintr;\\r\\n        address crv;\\r\\n        address crvPoolToken;\\r\\n        address controller;\\r\\n        address assetConverter;        \\r\\n        uint256 gasSubsidyFee;\\r\\n    }\\r\\n}\"},\"IControlled.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IControlled {\\r\\n    function token() external view returns(address);\\r\\n    function withdrawStuckToken(address _token, address destination) external;\\r\\n}\"},\"IController.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IController {\\r\\n    function balanceOf(address vault) external view returns(uint256);\\r\\n    function actualAmount(address vault, uint256 amount) external view returns(uint256);\\r\\n    function earn(uint256 amount) external;\\r\\n    function withdraw(uint256 amount) external returns(uint256);\\r\\n    function sendFee(uint256 amount) external;\\r\\n}\"},\"ICurveFi3.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\u0027./ICurveFiBase.sol\\u0027;\\r\\n\\r\\ninterface ICurveFi3 is ICurveFiBase {\\r\\n  function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;\\r\\n  function remove_liquidity(uint256 _amount, uint256[3] calldata amounts) external;\\r\\n}\"},\"ICurveFiBase.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface ICurveFiBase {\\r\\n  function get_virtual_price() external view returns (uint);\\r\\n  function coins(uint256 arg0) external view returns (address);\\r\\n  function exchange(int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount) external;\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"IGauge.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IGauge {\\r\\n    function deposit(uint) external;\\r\\n    function balanceOf(address) external view returns (uint);\\r\\n    function withdraw(uint) external;\\r\\n}\"},\"IMintr.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IMintr {\\r\\n    function mint(address) external;\\r\\n}\"},\"IStrategy.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\u0027./IControlled.sol\\u0027;\\r\\n\\r\\ninterface IStrategy is IControlled {\\r\\n    function balanceOf() external view returns(uint256);\\r\\n    function balanceOfWant() external view returns(uint256);\\r\\n    function actualBalanceFor(uint256 amount) external view returns(uint256);\\r\\n    function deposit(uint256 amount) external;\\r\\n    function withdraw(uint256 amount) external returns(uint256);\\r\\n    function withdrawAll() external;\\r\\n}\"},\"IyERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n\\r\\ninterface IyERC20 {\\r\\n  function deposit(uint) external;\\r\\n  function withdraw(uint) external;\\r\\n  function getPricePerFullShare() external view returns (uint);\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Adapted from OpenZeppelin\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    function init() internal {\\r\\n        require(_owner == address(0), \\\"Ownable: Contract initialized\\\");\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"curve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mintr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"crv\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"crvPoolToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetConverter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasSubsidyFee\",\"type\":\"uint256\"}],\"internalType\":\"struct IACOVaultUSDCStrategyCurveBase.VaultUSDCStrategyCurveBaseInitData\",\"name\":\"initData\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAssetConverter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAssetConverter\",\"type\":\"address\"}],\"name\":\"SetAssetConverter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldController\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"SetController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldGasSubsidyFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newGasSubsidyFee\",\"type\":\"uint256\"}],\"name\":\"SetGasSubsidyFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"previousPermission\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"newPermission\",\"type\":\"bool\"}],\"name\":\"SetOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldWithdrawalFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newWithdrawalFee\",\"type\":\"uint256\"}],\"name\":\"SetWithdrawalFee\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"actualBalanceFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetConverter\",\"outputs\":[{\"internalType\":\"contract IACOAssetConverterHelper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfGauge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfWant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crv\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crvPoolToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curve\",\"outputs\":[{\"internalType\":\"contract ICurveFiBase\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasSubsidyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gauge\",\"outputs\":[{\"internalType\":\"contract IGauge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintr\",\"outputs\":[{\"internalType\":\"contract IMintr\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAssetConverter\",\"type\":\"address\"}],\"name\":\"setAssetConverter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGasSubsidyFee\",\"type\":\"uint256\"}],\"name\":\"setGasSubsidyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"permission\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"withdrawStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ACOVaultUSDCStrategy3CRV","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bebc44782c7db0a1a60cb6fe97d0b483032ff1c7000000000000000000000000bfcf63294ad7105dea65aa58f8ae5be2d9d0952a000000000000000000000000d061d61a4d941c39e5453435b6345dc261c2fce0000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd520000000000000000000000006c3f90f043a72fa612cbac8115ee7e52bde6e490000000000000000000000000658224f5dca62d19491c14a747411e0ee9f5364a0000000000000000000000008e17731d424887b3f1f488857b68501b3b1c279b0000000000000000000000000000000000000000000000000000000000002710","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://13497660dc1e5b175851d446933beac6fbb87945f656e8049e5651dcdc80fcf4"}]}