{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lp-oracle-contracts/proxies/BalancerSharedPoolPriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/BPool.sol\\\";\\nimport \\\"../interfaces/IPriceOracle.sol\\\";\\nimport \\\"../misc/BNum.sol\\\";\\n\\n/** @title BalancerSharedPoolPriceProvider\\n * @notice Price provider for a balancer pool token\\n * It calculates the price using Chainlink as an external price source and the pool's tokens balances using the weighted arithmetic mean formula.\\n * If there is a price deviation, instead of the balances, it uses a weighted geometric mean with the token's weights and constant value function V.\\n */\\n\\ncontract BalancerSharedPoolPriceProvider is BNum {\\n    BPool public pool;\\n    address[] public tokens;\\n    uint256[] public weights;\\n    bool[] public isPeggedToEth;\\n    uint8[] public decimals;\\n    IPriceOracle public priceOracle;\\n    uint256 public immutable maxPriceDeviation;\\n    uint256 internal immutable K;\\n    uint256 internal immutable powerPrecision;\\n    uint256[][] internal approximationMatrix;\\n\\n    /**\\n     * BalancerSharedPoolPriceProvider constructor.\\n     * @param _pool Balancer pool address.\\n     * @param _isPeggedToEth For each token, true if it is pegged to ETH (token order determined by pool.getFinalTokens()).\\n     * @param _decimals Number of decimals for each token (token order determined by pool.getFinalTokens()).\\n     * @param _priceOracle Aave price oracle.\\n     * @param _maxPriceDeviation Threshold of spot prices deviation: 10ˆ16 represents a 1% deviation.\\n     * @param _K //Constant K = 1 / (w1ˆw1 * .. * wn^wn)\\n     * @param _powerPrecision //Precision for power math function.\\n     * @param _approximationMatrix //Approximation matrix for gas optimization.\\n     */\\n    constructor(\\n        BPool _pool,\\n        bool[] memory _isPeggedToEth,\\n        uint8[] memory _decimals,\\n        IPriceOracle _priceOracle,\\n        uint256 _maxPriceDeviation,\\n        uint256 _K,\\n        uint256 _powerPrecision,\\n        uint256[][] memory _approximationMatrix\\n    ) public {\\n        pool = _pool;\\n        //Get token list\\n        tokens = pool.getFinalTokens(); //This already checks for pool finalized\\n        uint256 length = tokens.length;\\n        //Validate contructor params\\n        require(length >= 2 && length <= 3, \\\"ERR_INVALID_POOL_TOKENS_NUMBER\\\");\\n        require(_isPeggedToEth.length == length, \\\"ERR_INVALID_PEGGED_LENGTH\\\");\\n        require(_decimals.length == length, \\\"ERR_INVALID_DECIMALS_LENGTH\\\");\\n        for (uint8 i = 0; i < length; i++) {\\n            require(_decimals[i] <= 18, \\\"ERR_INVALID_DECIMALS\\\");\\n        }\\n        require(\\n            _approximationMatrix.length == 0 ||\\n                _approximationMatrix[0].length == length + 1,\\n            \\\"ERR_INVALID_APPROX_MATRIX\\\"\\n        );\\n        require(_maxPriceDeviation < BONE, \\\"ERR_INVALID_PRICE_DEVIATION\\\");\\n        require(\\n            _powerPrecision >= 1 && _powerPrecision <= BONE,\\n            \\\"ERR_INVALID_POWER_PRECISION\\\"\\n        );\\n        require(\\n            address(_priceOracle) != address(0),\\n            \\\"ERR_INVALID_PRICE_PROVIDER\\\"\\n        );\\n        //Get token normalized weights\\n        for (uint8 i = 0; i < length; i++) {\\n            weights.push(pool.getNormalizedWeight(tokens[i]));\\n        }\\n        isPeggedToEth = _isPeggedToEth;\\n        decimals = _decimals;\\n        priceOracle = _priceOracle;\\n        maxPriceDeviation = _maxPriceDeviation;\\n        K = _K;\\n        powerPrecision = _powerPrecision;\\n        approximationMatrix = _approximationMatrix;\\n    }\\n\\n    /**\\n     * Returns the token balance in ethers by multiplying its balance with its price in ethers.\\n     * @param index Token index.\\n     */\\n    function getEthBalanceByToken(uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 pi = isPeggedToEth[index]\\n            ? BONE\\n            : uint256(priceOracle.getAssetPrice(tokens[index]));\\n        require(pi > 0, \\\"ERR_NO_ORACLE_PRICE\\\");\\n        uint256 missingDecimals = 18 - decimals[index];\\n        uint256 bi = bmul(\\n            pool.getBalance(tokens[index]),\\n            BONE * 10**(missingDecimals)\\n        );\\n        return bmul(bi, pi);\\n    }\\n\\n    /**\\n     * Using the matrix approximation, returns a near base and exponentiation result, for num ^ weights[index]\\n     * @param index Token index.\\n     * @param num Base to approximate.\\n     */\\n    function getClosestBaseAndExponetation(uint256 index, uint256 num)\\n        internal\\n        view\\n        returns (uint256, uint256)\\n    {\\n        uint256 length = approximationMatrix.length;\\n        uint256 k = index + 1;\\n        for (uint8 i = 0; i < length; i++) {\\n            if (approximationMatrix[i][0] >= num) {\\n                return (approximationMatrix[i][0], approximationMatrix[i][k]);\\n            }\\n        }\\n        return (0, 0);\\n    }\\n\\n    /**\\n     * Returns true if there is a price deviation.\\n     * @param ethTotals Balance of each token in ethers.\\n     */\\n    function hasDeviation(uint256[] memory ethTotals)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        //Check for a price deviation\\n        uint256 length = tokens.length;\\n        for (uint8 i = 0; i < length; i++) {\\n            for (uint8 o = 0; o < length; o++) {\\n                if (i != o) {\\n                    uint256 price_deviation = bdiv(\\n                        bdiv(ethTotals[i], weights[i]),\\n                        bdiv(ethTotals[o], weights[o])\\n                    );\\n                    if (\\n                        price_deviation > (BONE + maxPriceDeviation) ||\\n                        price_deviation < (BONE - maxPriceDeviation)\\n                    ) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Calculates the price of the pool token using the formula of weighted arithmetic mean.\\n     * @param ethTotals Balance of each token in ethers.\\n     */\\n    function getArithmeticMean(uint256[] memory ethTotals)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 totalEth = 0;\\n        uint256 length = tokens.length;\\n        for (uint8 i = 0; i < length; i++) {\\n            totalEth = badd(totalEth, ethTotals[i]);\\n        }\\n        return bdiv(totalEth, pool.totalSupply());\\n    }\\n\\n    /**\\n     * Returns the weighted token balance in ethers by calculating the balance in ether of the token to the power of its weight.\\n     * @param index Token index.\\n     */\\n    function getWeightedEthBalanceByToken(uint256 index, uint256 ethTotal)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 weight = weights[index];\\n        (uint256 base, uint256 result) = getClosestBaseAndExponetation(\\n            index,\\n            ethTotal\\n        );\\n        if (base == 0 || ethTotal < MAX_BPOW_BASE) {\\n            if (ethTotal < MAX_BPOW_BASE) {\\n                return bpowApprox(ethTotal, weight, powerPrecision);\\n            } else {\\n                return\\n                    bmul(\\n                        ethTotal,\\n                        bpowApprox(\\n                            bdiv(BONE, ethTotal),\\n                            (BONE - weight),\\n                            powerPrecision\\n                        )\\n                    );\\n            }\\n        } else {\\n            return\\n                bmul(\\n                    result,\\n                    bpowApprox(bdiv(ethTotal, base), weight, powerPrecision)\\n                );\\n        }\\n    }\\n\\n    /**\\n     * Calculates the price of the pool token using the formula of weighted geometric mean.\\n     * @param ethTotals Balance of each token in ethers.\\n     */\\n    function getWeightedGeometricMean(uint256[] memory ethTotals)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 mult = BONE;\\n        uint256 length = tokens.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            mult = bmul(mult, getWeightedEthBalanceByToken(i, ethTotals[i]));\\n        }\\n        return bdiv(bmul(mult, K), pool.totalSupply());\\n    }\\n\\n    /**\\n     * Returns the pool's token price.\\n     * It calculates the price using Chainlink as an external price source and the pool's tokens balances using the weighted arithmetic mean formula.\\n     * If there is a price deviation, instead of the balances, it uses a weighted geometric mean with the token's weights and constant value function V.\\n     */\\n    function latestAnswer() external view returns (uint256) {\\n        //Get token balances in ethers\\n        uint256[] memory ethTotals = new uint256[](tokens.length);\\n        uint256 length = tokens.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            ethTotals[i] = getEthBalanceByToken(i);\\n        }\\n\\n        if (hasDeviation(ethTotals)) {\\n            //Calculate the weighted geometric mean\\n            return getWeightedGeometricMean(ethTotals);\\n        } else {\\n            //Calculate the weighted arithmetic mean\\n            return getArithmeticMean(ethTotals);\\n        }\\n    }\\n\\n    /**\\n     * Returns Balancer pool address.\\n     */\\n    function getPool() external view returns (BPool) {\\n        return pool;\\n    }\\n\\n    /**\\n     * Returns all tokens.\\n     */\\n    function getTokens() external view returns (address[] memory) {\\n        return tokens;\\n    }\\n\\n    /**\\n     * Returns all tokens's weights.\\n     */\\n    function getWeights() external view returns (uint256[] memory) {\\n        return weights;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/interfaces/BPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n\\ninterface BPool {\\n\\n    function getFinalTokens() external view returns (address[] memory tokens);\\n    function getNormalizedWeight(address token) external view returns (uint);\\n    function getBalance(address token) external view returns (uint);\\n    function totalSupply() external view returns (uint);\\n \\n}\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/************\\n@title IPriceOracle interface\\n@notice Interface for the Aave price oracle.*/\\ninterface IPriceOracle {\\n    /***********\\n    @dev returns the asset price in ETH\\n     */\\n    function getAssetPrice(address _asset) external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/misc/BNum.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// From https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./BConst.sol\\\";\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure \\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = bfloor(exp);   \\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom \\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/misc/BConst.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// From // From https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\\n\\npragma solidity 0.6.12;\\n\\ncontract BConst {\\n    uint public constant BONE              = 10**18;\\n\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\n    uint public constant MAX_BOUND_TOKENS  = 8;\\n\\n    uint public constant MIN_FEE           = BONE / 10**6;\\n    uint public constant MAX_FEE           = BONE / 10;\\n    uint public constant EXIT_FEE          = 0;\\n\\n    uint public constant MIN_WEIGHT        = BONE;\\n    uint public constant MAX_WEIGHT        = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\\n    uint public constant MIN_BALANCE       = BONE / 10**12;\\n\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract BPool\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"_isPeggedToEth\",\"type\":\"bool[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_decimals\",\"type\":\"uint8[]\"},{\"internalType\":\"contract IPriceOracle\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxPriceDeviation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_powerPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"_approximationMatrix\",\"type\":\"uint256[][]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"contract BPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeights\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isPeggedToEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPriceDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract BPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"contract IPriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"weights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BalancerSharedPoolPriceProvider","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001eff8af5d577060ba4ac8a29a13525bb0ee2a3d500000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000160000000000000000000000000a50ba011c48153de246e5192c8f9258a2ba79ca900000000000000000000000000000000000000000000000000b1a2bc2ec500000000000000000000000000000000000000000000000000001bc16d674ec800000000000000000000000000000000000000000000000000000000000005f5e10000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000048000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000580000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000006800000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000078000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000880000000000000000000000000000000000000000000000000000000000000090000000000000000000000000000000000000000000000000000000000000009800000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a800000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000b800000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000002be2aac7077d5bc40000000000000000000000000000000000000000000000002be2aac7077d5bc400000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000008ac7230489e80000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000003635c9adc5dea00000000000000000000000000000000000000000000000000001b6daabc64ae595a8000000000000000000000000000000000000000000000001b6daabc64ae595a8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000021e19e0c9bab24000000000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000056bc75e2d63100000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000152d02c7e14af6800000000000000000000000000000000000000000000000000011248ab5beecf7d890000000000000000000000000000000000000000000000011248ab5beecf7d890000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000084595161401484a0000000000000000000000000000000000000000000000000000ab6d6b197541ae75a00000000000000000000000000000000000000000000000ab6d6b197541ae75a0000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000052b7d2dcc80cd2e400000000000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000033b2e3c9fd0803ce80000000000000000000000000000000000000000000000000006b2462efe9490d098400000000000000000000000000000000000000000000006b2462efe9490d0984000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000204fce5e3e2502611000000000000000000000000000000000000000000000000000152d02c7e14af680000000000000000000000000000000000000000000000000152d02c7e14af680000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000001431e0fae6d7217caa00000000000000000000000000000000000000000000000000042f6bdd5f1cda825f2800000000000000000000000000000000000000000000042f6bdd5f1cda825f2800000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000c9f2c9cd04674edea4000000000000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000000000000000000000000d3c21bcecceda10000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000007e37be2022c0914b2680000000000000000000000000000000000000000000000000029da36a5b7208917b7900000000000000000000000000000000000000000000029da36a5b7208917b7900000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000004ee2d6d415b85acef8100000000000000000000000000000000000000000000000000084595161401484a000000000000000000000000000000000000000000000000084595161401484a0000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000314dc6448d9338c15b0a000000000000000000000000000000000000000000000000001a286227927455aed2ba000000000000000000000000000000000000000000001a286227927455aed2ba000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000001ed09bead87c0378d8e640000000000000000000000000000000000000000000000000052b7d2dcc80cd2e400000000000000000000000000000000000000000000000052b7d2dcc80cd2e40000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000013426172c74d822b878fe8000000000000000000000000000000000000000000000000010593d58bb88b58d43b44000000000000000000000000000000000000000000010593d58bb88b58d43b440000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000c097ce7bc90715b34b9f10000000000000000000000000000000000000000000000000033b2e3c9fd0803ce80000000000000000000000000000000000000000000000033b2e3c9fd0803ce80000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000785ee10d5da46d900f436a00000000000000000000000000000000000000000000000000a37c657753571784a50a80000000000000000000000000000000000000000000a37c657753571784a50a8000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000004b3b4ca85a86c47a098a2240000000000000000000000000000000000000000000000000204fce5e3e250261100000000000000000000000000000000000000000000000204fce5e3e25026110000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}