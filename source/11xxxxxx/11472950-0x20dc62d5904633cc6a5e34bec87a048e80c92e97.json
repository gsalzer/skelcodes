{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IDepositContract.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\n\\n/**\\n  * @title Deposit contract interface\\n  */\\ninterface IDepositContract {\\n    /**\\n      * @notice Top-ups deposit of a validator on the ETH 2.0 side\\n      * @param pubkey Validator signing key\\n      * @param withdrawal_credentials Credentials that allows to withdraw funds\\n      * @param signature Signature of the request\\n      * @param deposit_data_root The deposits Merkle tree node, used as a checksum\\n      */\\n    function deposit(\\n        bytes /* 48 */ pubkey,\\n        bytes /* 32 */ withdrawal_credentials,\\n        bytes /* 96 */ signature,\\n        bytes32 deposit_data_root\\n    )\\n        external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/Lido.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\n/* See contracts/COMPILERS.md */\\npragma solidity 0.4.24;\\n\\nimport \\\"@aragon/os/contracts/apps/AragonApp.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath64.sol\\\";\\nimport \\\"@aragon/os/contracts/common/IsContract.sol\\\";\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\n\\nimport \\\"./interfaces/ILido.sol\\\";\\nimport \\\"./interfaces/INodeOperatorsRegistry.sol\\\";\\nimport \\\"./interfaces/IDepositContract.sol\\\";\\n\\nimport \\\"./StETH.sol\\\";\\n\\n\\n/**\\n* @title Liquid staking pool implementation\\n*\\n* Lido is an Ethereum 2.0 liquid staking protocol solving the problem of frozen staked Ethers\\n* until transfers become available in Ethereum 2.0.\\n* Whitepaper: https://lido.fi/static/Lido:Ethereum-Liquid-Staking.pdf\\n*\\n* NOTE: the code below assumes moderate amount of node operators, e.g. up to 50.\\n*\\n* Since balances of all token holders change when the amount of total pooled Ether\\n* changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\\n* events upon explicit transfer between holders. In contrast, when Lido oracle reports\\n* rewards, no Transfer events are generated: doing so would require emitting an event\\n* for each token holder and thus running an unbounded loop.\\n*/\\ncontract Lido is ILido, IsContract, StETH, AragonApp {\\n    using SafeMath for uint256;\\n    using SafeMath64 for uint64;\\n    using UnstructuredStorage for bytes32;\\n\\n    /// ACL\\n    bytes32 constant public PAUSE_ROLE = keccak256(\\\"PAUSE_ROLE\\\");\\n    bytes32 constant public MANAGE_FEE = keccak256(\\\"MANAGE_FEE\\\");\\n    bytes32 constant public MANAGE_WITHDRAWAL_KEY = keccak256(\\\"MANAGE_WITHDRAWAL_KEY\\\");\\n    bytes32 constant public SET_ORACLE = keccak256(\\\"SET_ORACLE\\\");\\n    bytes32 constant public BURN_ROLE = keccak256(\\\"BURN_ROLE\\\");\\n    bytes32 constant public SET_TREASURY = keccak256(\\\"SET_TREASURY\\\");\\n    bytes32 constant public SET_INSURANCE_FUND = keccak256(\\\"SET_INSURANCE_FUND\\\");\\n\\n    uint256 constant public PUBKEY_LENGTH = 48;\\n    uint256 constant public WITHDRAWAL_CREDENTIALS_LENGTH = 32;\\n    uint256 constant public SIGNATURE_LENGTH = 96;\\n\\n    uint256 constant public DEPOSIT_SIZE = 32 ether;\\n\\n    uint256 internal constant DEPOSIT_AMOUNT_UNIT = 1000000000 wei;\\n\\n    /// @dev default value for maximum number of Ethereum 2.0 validators registered in a single depositBufferedEther call\\n    uint256 internal constant DEFAULT_MAX_DEPOSITS_PER_CALL = 16;\\n\\n    bytes32 internal constant FEE_POSITION = keccak256(\\\"lido.Lido.fee\\\");\\n    bytes32 internal constant TREASURY_FEE_POSITION = keccak256(\\\"lido.Lido.treasuryFee\\\");\\n    bytes32 internal constant INSURANCE_FEE_POSITION = keccak256(\\\"lido.Lido.insuranceFee\\\");\\n    bytes32 internal constant NODE_OPERATORS_FEE_POSITION = keccak256(\\\"lido.Lido.nodeOperatorsFee\\\");\\n\\n    bytes32 internal constant DEPOSIT_CONTRACT_POSITION = keccak256(\\\"lido.Lido.depositContract\\\");\\n    bytes32 internal constant ORACLE_POSITION = keccak256(\\\"lido.Lido.oracle\\\");\\n    bytes32 internal constant NODE_OPERATORS_REGISTRY_POSITION = keccak256(\\\"lido.Lido.nodeOperatorsRegistry\\\");\\n    bytes32 internal constant TREASURY_POSITION = keccak256(\\\"lido.Lido.treasury\\\");\\n    bytes32 internal constant INSURANCE_FUND_POSITION = keccak256(\\\"lido.Lido.insuranceFund\\\");\\n\\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\\n    bytes32 internal constant BUFFERED_ETHER_POSITION = keccak256(\\\"lido.Lido.bufferedEther\\\");\\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION = keccak256(\\\"lido.Lido.depositedValidators\\\");\\n    /// @dev total amount of Beacon-side Ether (sum of all the balances of Lido validators)\\n    bytes32 internal constant BEACON_BALANCE_POSITION = keccak256(\\\"lido.Lido.beaconBalance\\\");\\n    /// @dev number of Lido's validators available in the Beacon state\\n    bytes32 internal constant BEACON_VALIDATORS_POSITION = keccak256(\\\"lido.Lido.beaconValidators\\\");\\n\\n    /// @dev Credentials which allows the DAO to withdraw Ether on the 2.0 side\\n    bytes32 internal constant WITHDRAWAL_CREDENTIALS_POSITION = keccak256(\\\"lido.Lido.withdrawalCredentials\\\");\\n\\n    /**\\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\\n    * @param depositContract official ETH2 Deposit contract\\n    * @param _oracle oracle contract\\n    * @param _operators instance of Node Operators Registry\\n    */\\n    function initialize(\\n        IDepositContract depositContract,\\n        address _oracle,\\n        INodeOperatorsRegistry _operators,\\n        address _treasury,\\n        address _insuranceFund\\n    )\\n        public onlyInit\\n    {\\n        _setDepositContract(depositContract);\\n        _setOracle(_oracle);\\n        _setOperators(_operators);\\n        _setTreasury(_treasury);\\n        _setInsuranceFund(_insuranceFund);\\n\\n        initialized();\\n    }\\n\\n    /**\\n    * @notice Send funds to the pool\\n    * @dev Users are able to submit their funds by transacting to the fallback function.\\n    * Unlike vanilla Eth2.0 Deposit contract, accepting only 32-Ether transactions, Lido\\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\\n    * depositBufferedEther() and pushes them to the ETH2 Deposit contract.\\n    */\\n    function() external payable {\\n        // protection against accidental submissions by calling non-existent function\\n        require(msg.data.length == 0, \\\"NON_EMPTY_DATA\\\");\\n        _submit(0);\\n    }\\n\\n    /**\\n    * @notice Send funds to the pool with optional _referral parameter\\n    * @dev This function is alternative way to submit funds. Supports optional referral address.\\n    * @return Amount of StETH shares generated\\n    */\\n    function submit(address _referral) external payable returns (uint256) {\\n        return _submit(_referral);\\n    }\\n\\n    /**\\n    * @notice Deposits buffered ethers to the official DepositContract.\\n    * @dev This function is separated from submit() to reduce the cost of sending funds.\\n    */\\n    function depositBufferedEther() external {\\n        return _depositBufferedEther(DEFAULT_MAX_DEPOSITS_PER_CALL);\\n    }\\n\\n    /**\\n      * @notice Deposits buffered ethers to the official DepositContract, making no more than `_maxDeposits` deposit calls.\\n      * @dev This function is separated from submit() to reduce the cost of sending funds.\\n      */\\n    function depositBufferedEther(uint256 _maxDeposits) external {\\n        return _depositBufferedEther(_maxDeposits);\\n    }\\n\\n    function burnShares(address _account, uint256 _sharesAmount)\\n        external\\n        authP(BURN_ROLE, arr(_account, _sharesAmount))\\n        returns (uint256 newTotalShares)\\n    {\\n        return _burnShares(_account, _sharesAmount);\\n    }\\n\\n    /**\\n      * @notice Stop pool routine operations\\n      */\\n    function stop() external auth(PAUSE_ROLE) {\\n        _stop();\\n    }\\n\\n    /**\\n      * @notice Resume pool routine operations\\n      */\\n    function resume() external auth(PAUSE_ROLE) {\\n        _resume();\\n    }\\n\\n    /**\\n      * @notice Set fee rate to `_feeBasisPoints` basis points. The fees are accrued when oracles report staking results\\n      * @param _feeBasisPoints Fee rate, in basis points\\n      */\\n    function setFee(uint16 _feeBasisPoints) external auth(MANAGE_FEE) {\\n        _setBPValue(FEE_POSITION, _feeBasisPoints);\\n        emit FeeSet(_feeBasisPoints);\\n    }\\n\\n    /**\\n      * @notice Set fee distribution: `_treasuryFeeBasisPoints` basis points go to the treasury, `_insuranceFeeBasisPoints` basis points go to the insurance fund, `_operatorsFeeBasisPoints` basis points go to node operators. The sum has to be 10 000.\\n      */\\n    function setFeeDistribution(\\n        uint16 _treasuryFeeBasisPoints,\\n        uint16 _insuranceFeeBasisPoints,\\n        uint16 _operatorsFeeBasisPoints\\n    )\\n        external auth(MANAGE_FEE)\\n    {\\n        require(\\n            10000 == uint256(_treasuryFeeBasisPoints)\\n            .add(uint256(_insuranceFeeBasisPoints))\\n            .add(uint256(_operatorsFeeBasisPoints)),\\n            \\\"FEES_DONT_ADD_UP\\\"\\n        );\\n\\n        _setBPValue(TREASURY_FEE_POSITION, _treasuryFeeBasisPoints);\\n        _setBPValue(INSURANCE_FEE_POSITION, _insuranceFeeBasisPoints);\\n        _setBPValue(NODE_OPERATORS_FEE_POSITION, _operatorsFeeBasisPoints);\\n\\n        emit FeeDistributionSet(_treasuryFeeBasisPoints, _insuranceFeeBasisPoints, _operatorsFeeBasisPoints);\\n    }\\n\\n    /**\\n      * @notice Set authorized oracle contract address to `_oracle`\\n      * @dev Contract specified here is allowed to make periodical updates of beacon states\\n      * by calling pushBeacon.\\n      * @param _oracle oracle contract\\n      */\\n    function setOracle(address _oracle) external auth(SET_ORACLE) {\\n        _setOracle(_oracle);\\n    }\\n\\n    /**\\n      * @notice Set treasury contract address to `_treasury`\\n      * @dev Contract specified here is used to accumulate the protocol treasury fee.\\n      * @param _treasury contract which accumulates treasury fee.\\n      */\\n    function setTreasury(address _treasury) external auth(SET_TREASURY) {\\n        _setTreasury(_treasury);\\n    }\\n\\n    /**\\n      * @notice Set insuranceFund contract address to `_insuranceFund`\\n      * @dev Contract specified here is used to accumulate the protocol insurance fee.\\n      * @param _insuranceFund contract which accumulates insurance fee.\\n      */\\n    function setInsuranceFund(address _insuranceFund) external auth(SET_INSURANCE_FUND) {\\n        _setInsuranceFund(_insuranceFund);\\n    }\\n\\n    /**\\n      * @notice Set credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched to `_withdrawalCredentials`\\n      * @dev Note that setWithdrawalCredentials discards all unused signing keys as the signatures are invalidated.\\n      * @param _withdrawalCredentials hash of withdrawal multisignature key as accepted by\\n      *        the deposit_contract.deposit function\\n      */\\n    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external auth(MANAGE_WITHDRAWAL_KEY) {\\n        WITHDRAWAL_CREDENTIALS_POSITION.setStorageBytes32(_withdrawalCredentials);\\n        getOperators().trimUnusedKeys();\\n\\n        emit WithdrawalCredentialsSet(_withdrawalCredentials);\\n    }\\n\\n    /**\\n      * @notice Issues withdrawal request. Not implemented.\\n      * @param _amount Amount of StETH to withdraw\\n      * @param _pubkeyHash Receiving address\\n      */\\n    function withdraw(uint256 _amount, bytes32 _pubkeyHash) external whenNotStopped { /* solhint-disable-line no-unused-vars */\\n        //will be upgraded to an actual implementation when withdrawals are enabled (Phase 1.5 or 2 of Eth2 launch, likely late 2021 or 2022).\\n        //at the moment withdrawals are not possible in the beacon chain and there's no workaround\\n        revert(\\\"NOT_IMPLEMENTED_YET\\\");\\n    }\\n\\n    /**\\n    * @notice Updates the number of Lido-controlled keys in the beacon validators set and their total balance.\\n    * @dev periodically called by the Oracle contract\\n    * @param _beaconValidators number of Lido's keys in the beacon state\\n    * @param _beaconBalance simmarized balance of Lido-controlled keys in wei\\n    */\\n    function pushBeacon(uint256 _beaconValidators, uint256 _beaconBalance) external whenNotStopped {\\n        require(msg.sender == getOracle(), \\\"APP_AUTH_FAILED\\\");\\n\\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\\n        require(_beaconValidators <= depositedValidators, \\\"REPORTED_MORE_DEPOSITED\\\");\\n\\n        uint256 beaconValidators = BEACON_VALIDATORS_POSITION.getStorageUint256();\\n        // Since the calculation of funds in the ingress queue is based on the number of validators\\n        // that are in a transient state (deposited but not seen on beacon yet), we can't decrease the previously\\n        // reported number (we'll be unable to figure out who is in the queue and count them).\\n        // See LIP-1 for details https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-1.md\\n        require(_beaconValidators >= beaconValidators, \\\"REPORTED_LESS_VALIDATORS\\\");\\n        uint256 appearedValidators = _beaconValidators.sub(beaconValidators);\\n\\n        // RewardBase is the amount of money that is not included in the reward calculation\\n        // Just appeared validators * 32 added to the previously reported beacon balance\\n        uint256 rewardBase = (appearedValidators.mul(DEPOSIT_SIZE)).add(BEACON_BALANCE_POSITION.getStorageUint256());\\n\\n        // Save the current beacon balance and validators to\\n        // calcuate rewards on the next push\\n        BEACON_BALANCE_POSITION.setStorageUint256(_beaconBalance);\\n        BEACON_VALIDATORS_POSITION.setStorageUint256(_beaconValidators);\\n\\n        if (_beaconBalance > rewardBase) {\\n            uint256 rewards = _beaconBalance.sub(rewardBase);\\n            distributeRewards(rewards);\\n        }\\n    }\\n\\n    /**\\n      * @notice Send funds to recovery Vault. Overrides default AragonApp behaviour.\\n      * @param _token Token to be sent to recovery vault.\\n      */\\n    function transferToVault(address _token) external {\\n        require(allowRecoverability(_token), \\\"RECOVER_DISALLOWED\\\");\\n        address vault = getRecoveryVault();\\n        require(isContract(vault), \\\"RECOVER_VAULT_NOT_CONTRACT\\\");\\n\\n        uint256 balance;\\n        if (_token == ETH) {\\n            balance = _getUnaccountedEther();\\n            vault.transfer(balance);\\n        } else {\\n            ERC20 token = ERC20(_token);\\n            balance = token.staticBalanceOf(this);\\n            // safeTransfer comes from overriden default implementation\\n            require(token.safeTransfer(vault, balance), \\\"RECOVER_TOKEN_TRANSFER_FAILED\\\");\\n        }\\n\\n        emit RecoverToVault(vault, _token, balance);\\n    }\\n\\n    /**\\n      * @notice Returns staking rewards fee rate\\n      */\\n    function getFee() external view returns (uint16 feeBasisPoints) {\\n        return _getFee();\\n    }\\n\\n    /**\\n      * @notice Returns fee distribution proportion\\n      */\\n    function getFeeDistribution()\\n        external\\n        view\\n        returns (\\n            uint16 treasuryFeeBasisPoints,\\n            uint16 insuranceFeeBasisPoints,\\n            uint16 operatorsFeeBasisPoints\\n        )\\n    {\\n        return _getFeeDistribution();\\n    }\\n\\n    /**\\n      * @notice Returns current credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched\\n      */\\n    function getWithdrawalCredentials() public view returns (bytes32) {\\n        return WITHDRAWAL_CREDENTIALS_POSITION.getStorageBytes32();\\n    }\\n\\n    /**\\n    * @notice Get the amount of Ether temporary buffered on this contract balance\\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\\n    * until the moment they are actually sent to the official Deposit contract.\\n    * @return uint256 of buffered funds in wei\\n    */\\n    function getBufferedEther() external view returns (uint256) {\\n        return _getBufferedEther();\\n    }\\n\\n    /**\\n      * @notice Gets deposit contract handle\\n      */\\n    function getDepositContract() public view returns (IDepositContract) {\\n        return IDepositContract(DEPOSIT_CONTRACT_POSITION.getStorageAddress());\\n    }\\n\\n    /**\\n    * @notice Gets authorized oracle address\\n    * @return address of oracle contract\\n    */\\n    function getOracle() public view returns (address) {\\n        return ORACLE_POSITION.getStorageAddress();\\n    }\\n\\n    /**\\n      * @notice Gets node operators registry interface handle\\n      */\\n    function getOperators() public view returns (INodeOperatorsRegistry) {\\n        return INodeOperatorsRegistry(NODE_OPERATORS_REGISTRY_POSITION.getStorageAddress());\\n    }\\n\\n    /**\\n      * @notice Returns the treasury address\\n      */\\n    function getTreasury() public view returns (address) {\\n        return TREASURY_POSITION.getStorageAddress();\\n    }\\n\\n    /**\\n      * @notice Returns the insurance fund address\\n      */\\n    function getInsuranceFund() public view returns (address) {\\n        return INSURANCE_FUND_POSITION.getStorageAddress();\\n    }\\n\\n    /**\\n    * @notice Returns the key values related to Beacon-side\\n    * @return depositedValidators - number of deposited validators\\n    * @return beaconValidators - number of Lido's validators visible in the Beacon state, reported by oracles\\n    * @return beaconBalance - total amount of Beacon-side Ether (sum of all the balances of Lido validators)\\n    */\\n    function getBeaconStat() public view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\\n        beaconValidators = BEACON_VALIDATORS_POSITION.getStorageUint256();\\n        beaconBalance = BEACON_BALANCE_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n    * @dev Sets the address of Deposit contract\\n    * @param _contract the address of Deposit contract\\n    */\\n    function _setDepositContract(IDepositContract _contract) internal {\\n        require(isContract(address(_contract)), \\\"NOT_A_CONTRACT\\\");\\n        DEPOSIT_CONTRACT_POSITION.setStorageAddress(address(_contract));\\n    }\\n\\n    /**\\n    * @dev Internal function to set authorized oracle address\\n    * @param _oracle oracle contract\\n    */\\n    function _setOracle(address _oracle) internal {\\n        require(isContract(_oracle), \\\"NOT_A_CONTRACT\\\");\\n        ORACLE_POSITION.setStorageAddress(_oracle);\\n    }\\n\\n    /**\\n    * @dev Internal function to set node operator registry address\\n    * @param _r registry of node operators\\n    */\\n    function _setOperators(INodeOperatorsRegistry _r) internal {\\n        require(isContract(_r), \\\"NOT_A_CONTRACT\\\");\\n        NODE_OPERATORS_REGISTRY_POSITION.setStorageAddress(_r);\\n    }\\n\\n    function _setTreasury(address _treasury) internal {\\n        require(_treasury != address(0), \\\"SET_TREASURY_ZERO_ADDRESS\\\");\\n        TREASURY_POSITION.setStorageAddress(_treasury);\\n    }\\n\\n    function _setInsuranceFund(address _insuranceFund) internal {\\n        require(_insuranceFund != address(0), \\\"SET_INSURANCE_FUND_ZERO_ADDRESS\\\");\\n        INSURANCE_FUND_POSITION.setStorageAddress(_insuranceFund);\\n    }\\n\\n    /**\\n    * @dev Process user deposit, mints liquid tokens and increase the pool buffer\\n    * @param _referral address of referral.\\n    * @return amount of StETH shares generated\\n    */\\n    function _submit(address _referral) internal whenNotStopped returns (uint256) {\\n        address sender = msg.sender;\\n        uint256 deposit = msg.value;\\n        require(deposit != 0, \\\"ZERO_DEPOSIT\\\");\\n\\n        uint256 sharesAmount = getSharesByPooledEth(deposit);\\n        if (sharesAmount == 0) {\\n            // totalControlledEther is 0: either the first-ever deposit or complete slashing\\n            // assume that shares correspond to Ether 1-to-1\\n            sharesAmount = deposit;\\n        }\\n\\n        _mintShares(sender, sharesAmount);\\n        _submitted(sender, deposit, _referral);\\n        _emitTransferAfterMintingShares(sender, sharesAmount);\\n        return sharesAmount;\\n    }\\n\\n    /**\\n     * @dev Emits an {Transfer} event where from is 0 address. Indicates mint events.\\n     */\\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\\n        emit Transfer(address(0), _to, getPooledEthByShares(_sharesAmount));\\n    }\\n\\n    /**\\n    * @dev Deposits buffered eth to the DepositContract and assigns chunked deposits to node operators\\n    */\\n    function _depositBufferedEther(uint256 _maxDeposits) internal whenNotStopped {\\n        uint256 buffered = _getBufferedEther();\\n        if (buffered >= DEPOSIT_SIZE) {\\n            uint256 unaccounted = _getUnaccountedEther();\\n            uint256 numDeposits = buffered.div(DEPOSIT_SIZE);\\n            _markAsUnbuffered(_ETH2Deposit(numDeposits < _maxDeposits ? numDeposits : _maxDeposits));\\n            assert(_getUnaccountedEther() == unaccounted);\\n        }\\n    }\\n\\n    /**\\n    * @dev Performs deposits to the ETH 2.0 side\\n    * @param _numDeposits Number of deposits to perform\\n    * @return actually deposited Ether amount\\n    */\\n    function _ETH2Deposit(uint256 _numDeposits) internal returns (uint256) {\\n        (bytes memory pubkeys, bytes memory signatures) = getOperators().assignNextSigningKeys(_numDeposits);\\n\\n        if (pubkeys.length == 0) {\\n            return 0;\\n        }\\n\\n        require(pubkeys.length.mod(PUBKEY_LENGTH) == 0, \\\"REGISTRY_INCONSISTENT_PUBKEYS_LEN\\\");\\n        require(signatures.length.mod(SIGNATURE_LENGTH) == 0, \\\"REGISTRY_INCONSISTENT_SIG_LEN\\\");\\n\\n        uint256 numKeys = pubkeys.length.div(PUBKEY_LENGTH);\\n        require(numKeys == signatures.length.div(SIGNATURE_LENGTH), \\\"REGISTRY_INCONSISTENT_SIG_COUNT\\\");\\n\\n        for (uint256 i = 0; i < numKeys; ++i) {\\n            bytes memory pubkey = BytesLib.slice(pubkeys, i * PUBKEY_LENGTH, PUBKEY_LENGTH);\\n            bytes memory signature = BytesLib.slice(signatures, i * SIGNATURE_LENGTH, SIGNATURE_LENGTH);\\n            _stake(pubkey, signature);\\n        }\\n\\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(\\n            DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(numKeys)\\n        );\\n\\n        return numKeys.mul(DEPOSIT_SIZE);\\n    }\\n\\n    /**\\n    * @dev Invokes a deposit call to the official Deposit contract\\n    * @param _pubkey Validator to stake for\\n    * @param _signature Signature of the deposit call\\n    */\\n    function _stake(bytes memory _pubkey, bytes memory _signature) internal {\\n        bytes32 withdrawalCredentials = getWithdrawalCredentials();\\n        require(withdrawalCredentials != 0, \\\"EMPTY_WITHDRAWAL_CREDENTIALS\\\");\\n\\n        uint256 value = DEPOSIT_SIZE;\\n\\n        // The following computations and Merkle tree-ization will make official Deposit contract happy\\n        uint256 depositAmount = value.div(DEPOSIT_AMOUNT_UNIT);\\n        assert(depositAmount.mul(DEPOSIT_AMOUNT_UNIT) == value);    // properly rounded\\n\\n        // Compute deposit data root (`DepositData` hash tree root) according to deposit_contract.sol\\n        bytes32 pubkeyRoot = sha256(_pad64(_pubkey));\\n        bytes32 signatureRoot = sha256(\\n            abi.encodePacked(\\n                sha256(BytesLib.slice(_signature, 0, 64)),\\n                sha256(_pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH.sub(64))))\\n            )\\n        );\\n\\n        bytes32 depositDataRoot = sha256(\\n            abi.encodePacked(\\n                sha256(abi.encodePacked(pubkeyRoot, withdrawalCredentials)),\\n                sha256(abi.encodePacked(_toLittleEndian64(depositAmount), signatureRoot))\\n            )\\n        );\\n\\n        uint256 targetBalance = address(this).balance.sub(value);\\n\\n        getDepositContract().deposit.value(value)(\\n            _pubkey, abi.encodePacked(withdrawalCredentials), _signature, depositDataRoot);\\n        require(address(this).balance == targetBalance, \\\"EXPECTING_DEPOSIT_TO_HAPPEN\\\");\\n    }\\n\\n    /**\\n    * @dev Distributes rewards by minting and distributing corresponding amount of liquid tokens.\\n    * @param _totalRewards Total rewards accrued on the Ethereum 2.0 side in wei\\n    */\\n    function distributeRewards(uint256 _totalRewards) internal {\\n        // We need to take a defined percentage of the reported reward as a fee, and we do\\n        // this by minting new token shares and assigning them to the fee recipients (see\\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 is 100%).\\n        //\\n        // Since we've increased totalPooledEther by _totalRewards (which is already\\n        // performed by the time this function is called), the combined cost of all holders'\\n        // shares has became _totalRewards StETH tokens more, effectively splitting the reward\\n        // between each token holder proportionally to their token share.\\n        //\\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\\n        // newly-minted shares exactly corresponds to the fee taken:\\n        //\\n        // shares2mint * newShareCost = (_totalRewards * feeBasis) / 10000\\n        // newShareCost = newTotalPooledEther / (prevTotalShares + shares2mint)\\n        //\\n        // which follows to:\\n        //\\n        //                        _totalRewards * feeBasis * prevTotalShares\\n        // shares2mint = --------------------------------------------------------------\\n        //                 (newTotalPooledEther * 10000) - (feeBasis * _totalRewards)\\n        //\\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\\n        // the rest of the reward is distributed between token holders proportionally to their\\n        // token shares.\\n        uint256 feeBasis = _getFee();\\n        uint256 shares2mint = (\\n            _totalRewards.mul(feeBasis).mul(_getTotalShares())\\n            .div(\\n                _getTotalPooledEther().mul(10000)\\n                .sub(feeBasis.mul(_totalRewards))\\n            )\\n        );\\n\\n        // Mint the calculated amount of shares to this contract address. This will reduce the\\n        // balances of the holders, as if the fee was taken in parts from each of them.\\n        _mintShares(address(this), shares2mint);\\n\\n        (,uint16 insuranceFeeBasisPoints, uint16 operatorsFeeBasisPoints) = _getFeeDistribution();\\n\\n        uint256 toInsuranceFund = shares2mint.mul(insuranceFeeBasisPoints).div(10000);\\n        address insuranceFund = getInsuranceFund();\\n        _transferShares(address(this), insuranceFund, toInsuranceFund);\\n        _emitTransferAfterMintingShares(insuranceFund, toInsuranceFund);\\n\\n        uint256 distributedToOperatorsShares = _distributeNodeOperatorsReward(\\n            shares2mint.mul(operatorsFeeBasisPoints).div(10000)\\n        );\\n\\n        // Transfer the rest of the fee to treasury\\n        uint256 toTreasury = shares2mint.sub(toInsuranceFund).sub(distributedToOperatorsShares);\\n\\n        address treasury = getTreasury();\\n        _transferShares(address(this), treasury, toTreasury);\\n        _emitTransferAfterMintingShares(treasury, toTreasury);\\n    }\\n\\n    function _distributeNodeOperatorsReward(uint256 _sharesToDistribute) internal returns (uint256 distributed) {\\n        (address[] memory recipients, uint256[] memory shares) = getOperators().getRewardsDistribution(_sharesToDistribute);\\n\\n        assert(recipients.length == shares.length);\\n\\n        distributed = 0;\\n        for (uint256 idx = 0; idx < recipients.length; ++idx) {\\n            _transferShares(\\n                address(this),\\n                recipients[idx],\\n                shares[idx]\\n            );\\n            _emitTransferAfterMintingShares(recipients[idx], shares[idx]);\\n            distributed = distributed.add(shares[idx]);\\n        }\\n    }\\n\\n    /**\\n    * @dev Records a deposit made by a user with optional referral\\n    * @param _sender sender's address\\n    * @param _value Deposit value in wei\\n    * @param _referral address of the referral\\n    */\\n    function _submitted(address _sender, uint256 _value, address _referral) internal {\\n        BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().add(_value));\\n\\n        emit Submitted(_sender, _value, _referral);\\n    }\\n\\n    /**\\n      * @dev Records a deposit to the deposit_contract.deposit function.\\n      * @param _amount Total amount deposited to the ETH 2.0 side\\n      */\\n    function _markAsUnbuffered(uint256 _amount) internal {\\n        BUFFERED_ETHER_POSITION.setStorageUint256(\\n            BUFFERED_ETHER_POSITION.getStorageUint256().sub(_amount));\\n\\n        emit Unbuffered(_amount);\\n    }\\n\\n    /**\\n      * @dev Write a value nominated in basis points\\n      */\\n    function _setBPValue(bytes32 _slot, uint16 _value) internal {\\n        require(_value <= 10000, \\\"VALUE_OVER_100_PERCENT\\\");\\n        _slot.setStorageUint256(uint256(_value));\\n    }\\n\\n    /**\\n      * @dev Returns staking rewards fee rate\\n      */\\n    function _getFee() internal view returns (uint16) {\\n        return _readBPValue(FEE_POSITION);\\n    }\\n\\n    /**\\n      * @dev Returns fee distribution proportion\\n      */\\n    function _getFeeDistribution() internal view\\n        returns (uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints, uint16 operatorsFeeBasisPoints)\\n    {\\n        treasuryFeeBasisPoints = _readBPValue(TREASURY_FEE_POSITION);\\n        insuranceFeeBasisPoints = _readBPValue(INSURANCE_FEE_POSITION);\\n        operatorsFeeBasisPoints = _readBPValue(NODE_OPERATORS_FEE_POSITION);\\n    }\\n\\n    /**\\n      * @dev Read a value nominated in basis points\\n      */\\n    function _readBPValue(bytes32 _slot) internal view returns (uint16) {\\n        uint256 v = _slot.getStorageUint256();\\n        assert(v <= 10000);\\n        return uint16(v);\\n    }\\n\\n    /**\\n      * @dev Gets the amount of Ether temporary buffered on this contract balance\\n      */\\n    function _getBufferedEther() internal view returns (uint256) {\\n        uint256 buffered = BUFFERED_ETHER_POSITION.getStorageUint256();\\n        assert(address(this).balance >= buffered);\\n\\n        return buffered;\\n    }\\n\\n    /**\\n      * @dev Gets unaccounted (excess) Ether on this contract balance\\n      */\\n    function _getUnaccountedEther() internal view returns (uint256) {\\n        return address(this).balance.sub(_getBufferedEther());\\n    }\\n\\n    /**\\n    * @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\\n    *      i.e. submitted to the official Deposit contract but not yet visible in the beacon state.\\n    * @return transient balance in wei (1e-18 Ether)\\n    */\\n    function _getTransientBalance() internal view returns (uint256) {\\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\\n        uint256 beaconValidators = BEACON_VALIDATORS_POSITION.getStorageUint256();\\n        // beaconValidators can never be less than deposited ones.\\n        assert(depositedValidators >= beaconValidators);\\n        uint256 transientValidators = depositedValidators.sub(beaconValidators);\\n        return transientValidators.mul(DEPOSIT_SIZE);\\n    }\\n\\n    /**\\n    * @dev Gets the total amount of Ether controlled by the system\\n    * @return total balance in wei\\n    */\\n    function _getTotalPooledEther() internal view returns (uint256) {\\n        uint256 bufferedBalance = _getBufferedEther();\\n        uint256 beaconBalance = BEACON_BALANCE_POSITION.getStorageUint256();\\n        uint256 transientBalance = _getTransientBalance();\\n        return bufferedBalance.add(beaconBalance).add(transientBalance);\\n    }\\n\\n    /**\\n      * @dev Padding memory array with zeroes up to 64 bytes on the right\\n      * @param _b Memory array of size 32 .. 64\\n      */\\n    function _pad64(bytes memory _b) internal pure returns (bytes memory) {\\n        assert(_b.length >= 32 && _b.length <= 64);\\n        if (64 == _b.length)\\n            return _b;\\n\\n        bytes memory zero32 = new bytes(32);\\n        assembly { mstore(add(zero32, 0x20), 0) }\\n\\n        if (32 == _b.length)\\n            return BytesLib.concat(_b, zero32);\\n        else\\n            return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64).sub(_b.length)));\\n    }\\n\\n    /**\\n      * @dev Converting value to little endian bytes and padding up to 32 bytes on the right\\n      * @param _value Number less than `2**64` for compatibility reasons\\n      */\\n    function _toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\\n        result = 0;\\n        uint256 temp_value = _value;\\n        for (uint256 i = 0; i < 8; ++i) {\\n            result = (result << 8) | (temp_value & 0xFF);\\n            temp_value >>= 8;\\n        }\\n\\n        assert(0 == temp_value);    // fully converted\\n        result <<= (24 * 8);\\n    }\\n\\n    function to64(uint256 v) internal pure returns (uint64) {\\n        assert(v <= uint256(uint64(-1)));\\n        return uint64(v);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/apps/AragonApp.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./AppStorage.sol\\\";\\nimport \\\"../acl/ACLSyntaxSugar.sol\\\";\\nimport \\\"../common/Autopetrified.sol\\\";\\nimport \\\"../common/ConversionHelpers.sol\\\";\\nimport \\\"../common/ReentrancyGuard.sol\\\";\\nimport \\\"../common/VaultRecoverable.sol\\\";\\nimport \\\"../evmscript/EVMScriptRunner.sol\\\";\\n\\n\\n// Contracts inheriting from AragonApp are, by default, immediately petrified upon deployment so\\n// that they can never be initialized.\\n// Unless overriden, this behaviour enforces those contracts to be usable only behind an AppProxy.\\n// ReentrancyGuard, EVMScriptRunner, and ACLSyntaxSugar are not directly used by this contract, but\\n// are included so that they are automatically usable by subclassing contracts\\ncontract AragonApp is AppStorage, Autopetrified, VaultRecoverable, ReentrancyGuard, EVMScriptRunner, ACLSyntaxSugar {\\n    string private constant ERROR_AUTH_FAILED = \\\"APP_AUTH_FAILED\\\";\\n\\n    modifier auth(bytes32 _role) {\\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\\n        _;\\n    }\\n\\n    modifier authP(bytes32 _role, uint256[] _params) {\\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\\n        _;\\n    }\\n\\n    /**\\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\\n    * @param _sender Sender of the call\\n    * @param _role Role on this app\\n    * @param _params Permission params for the role\\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\\n    *         Always returns false if the app hasn't been initialized yet.\\n    */\\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\\n        if (!hasInitialized()) {\\n            return false;\\n        }\\n\\n        IKernel linkedKernel = kernel();\\n        if (address(linkedKernel) == address(0)) {\\n            return false;\\n        }\\n\\n        return linkedKernel.hasPermission(\\n            _sender,\\n            address(this),\\n            _role,\\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\\n        );\\n    }\\n\\n    /**\\n    * @dev Get the recovery vault for the app\\n    * @return Recovery vault address for the app\\n    */\\n    function getRecoveryVault() public view returns (address) {\\n        // Funds recovery via a vault is only available when used with a kernel\\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/lib/math/SafeMath.sol\": {\r\n      \"content\": \"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\\n// Adapted to use pragma ^0.4.24 and satisfy our linter rules\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    string private constant ERROR_ADD_OVERFLOW = \\\"MATH_ADD_OVERFLOW\\\";\\n    string private constant ERROR_SUB_UNDERFLOW = \\\"MATH_SUB_UNDERFLOW\\\";\\n    string private constant ERROR_MUL_OVERFLOW = \\\"MATH_MUL_OVERFLOW\\\";\\n    string private constant ERROR_DIV_ZERO = \\\"MATH_DIV_ZERO\\\";\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (_a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = _a * _b;\\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\\n        uint256 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\\n        uint256 c = _a - _b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        uint256 c = _a + _b;\\n        require(c >= _a, ERROR_ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, ERROR_DIV_ZERO);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/lib/math/SafeMath64.sol\": {\r\n      \"content\": \"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\\n// Adapted for uint64, pragma ^0.4.24, and satisfying our linter rules\\n// Also optimized the mul() implementation, see https://github.com/aragon/aragonOS/pull/417\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath64\\n * @dev Math operations for uint64 with safety checks that revert on error\\n */\\nlibrary SafeMath64 {\\n    string private constant ERROR_ADD_OVERFLOW = \\\"MATH64_ADD_OVERFLOW\\\";\\n    string private constant ERROR_SUB_UNDERFLOW = \\\"MATH64_SUB_UNDERFLOW\\\";\\n    string private constant ERROR_MUL_OVERFLOW = \\\"MATH64_MUL_OVERFLOW\\\";\\n    string private constant ERROR_DIV_ZERO = \\\"MATH64_DIV_ZERO\\\";\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        uint256 c = uint256(_a) * uint256(_b);\\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\\n\\n        return uint64(c);\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\\n        uint64 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\\n        uint64 c = _a - _b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        uint64 c = _a + _b;\\n        require(c >= _a, ERROR_ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\\n        require(b != 0, ERROR_DIV_ZERO);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/IsContract.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract IsContract {\\n    /*\\n    * NOTE: this should NEVER be used for authentication\\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\\n    *\\n    * This is only intended to be used as a sanity check that an address is actually a contract,\\n    * RATHER THAN an address not being a contract.\\n    */\\n    function isContract(address _target) internal view returns (bool) {\\n        if (_target == address(0)) {\\n            return false;\\n        }\\n\\n        uint256 size;\\n        assembly { size := extcodesize(_target) }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity-bytes-utils/contracts/BytesLib.sol\": {\r\n      \"content\": \"/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\n\\npragma solidity ^0.4.19;\\n\\n\\nlibrary BytesLib {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add \\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes_slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes_slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes_slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes_slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n                \\n                for { \\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\\n        require(_bytes.length >= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\\n        require(_bytes.length >= (_start + 20));\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes _bytes, uint _start) internal  pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1));\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes _bytes, uint _start) internal  pure returns (uint16) {\\n        require(_bytes.length >= (_start + 2));\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes _bytes, uint _start) internal  pure returns (uint32) {\\n        require(_bytes.length >= (_start + 4));\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32));\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes _bytes, uint _start) internal  pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32));\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes_slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes_slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILido.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\n\\n/**\\n  * @title Liquid staking pool\\n  *\\n  * For the high-level description of the pool operation please refer to the paper.\\n  * Pool manages withdrawal keys and fees. It receives ether submitted by users on the ETH 1 side\\n  * and stakes it via the deposit_contract.sol contract. It doesn't hold ether on it's balance,\\n  * only a small portion (buffer) of it.\\n  * It also mints new tokens for rewards generated at the ETH 2.0 side.\\n  */\\ninterface ILido {\\n    /**\\n      * @notice Stop pool routine operations\\n      */\\n    function stop() external;\\n\\n    /**\\n      * @notice Resume pool routine operations\\n      */\\n    function resume() external;\\n\\n    event Stopped();\\n    event Resumed();\\n\\n\\n    /**\\n      * @notice Set fee rate to `_feeBasisPoints` basis points. The fees are accrued when oracles report staking results\\n      * @param _feeBasisPoints Fee rate, in basis points\\n      */\\n    function setFee(uint16 _feeBasisPoints) external;\\n\\n    /**\\n      * @notice Set fee distribution: `_treasuryFeeBasisPoints` basis points go to the treasury, `_insuranceFeeBasisPoints` basis points go to the insurance fund, `_operatorsFeeBasisPoints` basis points go to node operators. The sum has to be 10 000.\\n      */\\n    function setFeeDistribution(\\n        uint16 _treasuryFeeBasisPoints,\\n        uint16 _insuranceFeeBasisPoints,\\n        uint16 _operatorsFeeBasisPoints)\\n        external;\\n\\n    /**\\n      * @notice Returns staking rewards fee rate\\n      */\\n    function getFee() external view returns (uint16 feeBasisPoints);\\n\\n    /**\\n      * @notice Returns fee distribution proportion\\n      */\\n    function getFeeDistribution() external view returns (uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints,\\n                                                         uint16 operatorsFeeBasisPoints);\\n\\n    event FeeSet(uint16 feeBasisPoints);\\n\\n    event FeeDistributionSet(uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints, uint16 operatorsFeeBasisPoints);\\n\\n\\n    /**\\n      * @notice Set credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched to `_withdrawalCredentials`\\n      * @dev Note that setWithdrawalCredentials discards all unused signing keys as the signatures are invalidated.\\n      * @param _withdrawalCredentials hash of withdrawal multisignature key as accepted by\\n      *        the deposit_contract.deposit function\\n      */\\n    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external;\\n\\n    /**\\n      * @notice Returns current credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched\\n      */\\n    function getWithdrawalCredentials() external view returns (bytes);\\n\\n\\n    event WithdrawalCredentialsSet(bytes32 withdrawalCredentials);\\n\\n\\n    /**\\n      * @notice Ether on the ETH 2.0 side reported by the oracle\\n      * @param _epoch Epoch id\\n      * @param _eth2balance Balance in wei on the ETH 2.0 side\\n      */\\n    function pushBeacon(uint256 _epoch, uint256 _eth2balance) external;\\n\\n\\n    // User functions\\n\\n    /**\\n      * @notice Adds eth to the pool\\n      * @return StETH Amount of StETH generated\\n      */\\n    function submit(address _referral) external payable returns (uint256 StETH);\\n\\n    // Records a deposit made by a user\\n    event Submitted(address indexed sender, uint256 amount, address referral);\\n\\n    // The `_amount` of ether was sent to the deposit_contract.deposit function.\\n    event Unbuffered(uint256 amount);\\n\\n    /**\\n      * @notice Issues withdrawal request. Large withdrawals will be processed only after the phase 2 launch.\\n      * @param _amount Amount of StETH to burn\\n      * @param _pubkeyHash Receiving address\\n      */\\n    function withdraw(uint256 _amount, bytes32 _pubkeyHash) external;\\n\\n    // Requested withdrawal of `etherAmount` to `pubkeyHash` on the ETH 2.0 side, `tokenAmount` burned by `sender`,\\n    // `sentFromBuffer` was sent on the current Ethereum side.\\n    event Withdrawal(address indexed sender, uint256 tokenAmount, uint256 sentFromBuffer,\\n                     bytes32 indexed pubkeyHash, uint256 etherAmount);\\n\\n\\n    // Info functions\\n\\n    /**\\n      * @notice Gets the amount of Ether controlled by the system\\n      */\\n    function getTotalPooledEther() external view returns (uint256);\\n\\n    /**\\n      * @notice Gets the amount of Ether temporary buffered on this contract balance\\n      */\\n    function getBufferedEther() external view returns (uint256);\\n\\n    /**\\n      * @notice Returns the key values related to Beacon-side\\n      * @return depositedValidators - number of deposited validators\\n      * @return beaconValidators - number of Lido's validators visible in the Beacon state, reported by oracles\\n      * @return beaconBalance - total amount of Beacon-side Ether (sum of all the balances of Lido validators)\\n      */\\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INodeOperatorsRegistry.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\n\\n/**\\n  * @title Node Operator registry\\n  *\\n  * Node Operator registry manages signing keys and other node operator data.\\n  * It's also responsible for distributing rewards to node operators.\\n  */\\ninterface INodeOperatorsRegistry {\\n    /**\\n      * @notice Add node operator named `name` with reward address `rewardAddress` and staking limit `stakingLimit` validators\\n      * @param _name Human-readable name\\n      * @param _rewardAddress Ethereum 1 address which receives stETH rewards for this operator\\n      * @param _stakingLimit the maximum number of validators to stake for this operator\\n      * @return a unique key of the added operator\\n      */\\n    function addNodeOperator(string _name, address _rewardAddress, uint64 _stakingLimit) external returns (uint256 id);\\n\\n    /**\\n      * @notice `_active ? 'Enable' : 'Disable'` the node operator #`_id`\\n      */\\n    function setNodeOperatorActive(uint256 _id, bool _active) external;\\n\\n    /**\\n      * @notice Change human-readable name of the node operator #`_id` to `_name`\\n      */\\n    function setNodeOperatorName(uint256 _id, string _name) external;\\n\\n    /**\\n      * @notice Change reward address of the node operator #`_id` to `_rewardAddress`\\n      */\\n    function setNodeOperatorRewardAddress(uint256 _id, address _rewardAddress) external;\\n\\n    /**\\n      * @notice Set the maximum number of validators to stake for the node operator #`_id` to `_stakingLimit`\\n      */\\n    function setNodeOperatorStakingLimit(uint256 _id, uint64 _stakingLimit) external;\\n\\n    /**\\n      * @notice Report `_stoppedIncrement` more stopped validators of the node operator #`_id`\\n      */\\n    function reportStoppedValidators(uint256 _id, uint64 _stoppedIncrement) external;\\n\\n    /**\\n      * @notice Remove unused signing keys\\n      * @dev Function is used by the pool\\n      */\\n    function trimUnusedKeys() external;\\n\\n    /**\\n      * @notice Returns total number of node operators\\n      */\\n    function getNodeOperatorsCount() external view returns (uint256);\\n\\n    /**\\n      * @notice Returns number of active node operators\\n      */\\n    function getActiveNodeOperatorsCount() external view returns (uint256);\\n\\n    /**\\n      * @notice Returns the n-th node operator\\n      * @param _id Node Operator id\\n      * @param _fullInfo If true, name will be returned as well\\n      */\\n    function getNodeOperator(uint256 _id, bool _fullInfo) external view returns (\\n        bool active,\\n        string name,\\n        address rewardAddress,\\n        uint64 stakingLimit,\\n        uint64 stoppedValidators,\\n        uint64 totalSigningKeys,\\n        uint64 usedSigningKeys);\\n\\n    /**\\n      * @notice Returns the rewards distribution proportional to the effective stake for each node operator.\\n      * @param _totalRewardShares Total amount of reward shares to distribute.\\n      */\\n    function getRewardsDistribution(uint256 _totalRewardShares) external view returns (\\n        address[] memory recipients,\\n        uint256[] memory shares\\n    );\\n\\n    event NodeOperatorAdded(uint256 id, string name, address rewardAddress, uint64 stakingLimit);\\n    event NodeOperatorActiveSet(uint256 indexed id, bool active);\\n    event NodeOperatorNameSet(uint256 indexed id, string name);\\n    event NodeOperatorRewardAddressSet(uint256 indexed id, address rewardAddress);\\n    event NodeOperatorStakingLimitSet(uint256 indexed id, uint64 stakingLimit);\\n    event NodeOperatorTotalStoppedValidatorsReported(uint256 indexed id, uint64 totalStopped);\\n\\n    /**\\n     * @notice Selects and returns at most `_numKeys` signing keys (as well as the corresponding\\n     *         signatures) from the set of active keys and marks the selected keys as used.\\n     *         May only be called by the pool contract.\\n     *\\n     * @param _numKeys The number of keys to select. The actual number of selected keys may be less\\n     *        due to the lack of active keys.\\n     */\\n    function assignNextSigningKeys(uint256 _numKeys) external returns (bytes memory pubkeys, bytes memory signatures);\\n\\n    /**\\n      * @notice Add `_quantity` validator signing keys to the keys of the node operator #`_operator_id`. Concatenated keys are: `_pubkeys`\\n      * @dev Along with each key the DAO has to provide a signatures for the\\n      *      (pubkey, withdrawal_credentials, 32000000000) message.\\n      *      Given that information, the contract'll be able to call\\n      *      deposit_contract.deposit on-chain.\\n      * @param _operator_id Node Operator id\\n      * @param _quantity Number of signing keys provided\\n      * @param _pubkeys Several concatenated validator signing keys\\n      * @param _signatures Several concatenated signatures for (pubkey, withdrawal_credentials, 32000000000) messages\\n      */\\n    function addSigningKeys(uint256 _operator_id, uint256 _quantity, bytes _pubkeys, bytes _signatures) external;\\n\\n    /**\\n      * @notice Removes a validator signing key #`_index` from the keys of the node operator #`_operator_id`\\n      * @param _operator_id Node Operator id\\n      * @param _index Index of the key, starting with 0\\n      */\\n    function removeSigningKey(uint256 _operator_id, uint256 _index) external;\\n\\n    /**\\n      * @notice Returns total number of signing keys of the node operator #`_operator_id`\\n      */\\n    function getTotalSigningKeyCount(uint256 _operator_id) external view returns (uint256);\\n\\n    /**\\n      * @notice Returns number of usable signing keys of the node operator #`_operator_id`\\n      */\\n    function getUnusedSigningKeyCount(uint256 _operator_id) external view returns (uint256);\\n\\n    /**\\n      * @notice Returns n-th signing key of the node operator #`_operator_id`\\n      * @param _operator_id Node Operator id\\n      * @param _index Index of the key, starting with 0\\n      * @return key Key\\n      * @return depositSignature Signature needed for a deposit_contract.deposit call\\n      * @return used Flag indication if the key was used in the staking\\n      */\\n    function getSigningKey(uint256 _operator_id, uint256 _index) external view returns\\n            (bytes key, bytes depositSignature, bool used);\\n\\n    event SigningKeyAdded(uint256 indexed operatorId, bytes pubkey);\\n    event SigningKeyRemoved(uint256 indexed operatorId, bytes pubkey);\\n}\\n\"\r\n    },\r\n    \"contracts/StETH.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\n/* See contracts/COMPILERS.md */\\npragma solidity 0.4.24;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@aragon/os/contracts/common/UnstructuredStorage.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath.sol\\\";\\nimport \\\"./lib/Pausable.sol\\\";\\n\\n/**\\n * @title Interest-bearing ERC20-like token for Lido Liquid Stacking protocol.\\n *\\n * This contract is abstract. To make the contract deployable override the\\n * `_getTotalPooledEther` function. `Lido.sol` contract inherits StETH and defines\\n * the `_getTotalPooledEther` function.\\n *\\n * StETH balances are dynamic and represent the holder's share in the total amount\\n * of Ether controlled by the protocol. Account shares aren't normalized, so the\\n * contract also stores the sum of all shares to calculate each account's token balance\\n * which equals to:\\n *\\n *   shares[account] * _getTotalPooledEther() / _getTotalShares()\\n *\\n * For example, assume that we have:\\n *\\n *   _getTotalPooledEther() -> 10 ETH\\n *   sharesOf(user1) -> 100\\n *   sharesOf(user2) -> 400\\n *\\n * Therefore:\\n *\\n *   balanceOf(user1) -> 2 tokens which corresponds 2 ETH\\n *   balanceOf(user2) -> 8 tokens which corresponds 8 ETH\\n *\\n * Since balances of all token holders change when the amount of total pooled Ether\\n * changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\\n * events upon explicit transfer between holders. In contrast, when total amount of\\n * pooled Ether increases, no `Transfer` events are generated: doing so would require\\n * emitting an event for each token holder and thus running an unbounded loop.\\n *\\n * The token inherits from `Pausable` and uses `whenNotStopped` modifier for methods\\n * which change `shares` or `allowances`. `_stop` and `_resume` functions are overriden\\n * in `Lido.sol` and might be called by an account with the `PAUSE_ROLE` assigned by the\\n * DAO. This is useful for emergency scenarios, e.g. a protocol bug, where one might want\\n * to freeze all token transfers and approvals until the emergency is resolved.\\n */\\ncontract StETH is IERC20, Pausable {\\n    using SafeMath for uint256;\\n    using UnstructuredStorage for bytes32;\\n\\n    /**\\n     * @dev StETH balances are dynamic and are calculated based on the accounts' shares\\n     * and the total amount of Ether controlled by the protocol. Account shares aren't\\n     * normalized, so the contract also stores the sum of all shares to calculate\\n     * each account's token balance which equals to:\\n     *\\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\\n    */\\n    mapping (address => uint256) private shares;\\n\\n    /**\\n     * @dev Allowances are nominated in tokens, not token shares.\\n     */\\n    mapping (address => mapping (address => uint256)) private allowances;\\n\\n    /**\\n     * @dev Storage position used for holding the total amount of shares in existence.\\n     *\\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\\n     * for value types:\\n     *\\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\\n     *\\n     * For reference types, conventional storage variables are used since it's non-trivial\\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\\n     */\\n    bytes32 internal constant TOTAL_SHARES_POSITION = keccak256(\\\"lido.StETH.totalShares\\\");\\n\\n    /**\\n     * @return the name of the token.\\n     */\\n    function name() public pure returns (string) {\\n        return \\\"Liquid staked Ether 2.0\\\";\\n    }\\n\\n    /**\\n     * @return the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public pure returns (string) {\\n        return \\\"stETH\\\";\\n    }\\n\\n    /**\\n     * @return the number of decimals for getting user representation of a token amount.\\n     */\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @return the amount of tokens in existence.\\n     *\\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\\n     * is pegged to the total amount of Ether controlled by the protocol.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _getTotalPooledEther();\\n    }\\n\\n    /**\\n     * @return the entire amount of Ether controlled by the protocol.\\n     *\\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\\n     */\\n    function getTotalPooledEther() public view returns (uint256) {\\n        return _getTotalPooledEther();\\n    }\\n\\n    /**\\n     * @return the amount of tokens owned by the `_account`.\\n     *\\n     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\\n     * total Ether controlled by the protocol. See `sharesOf`.\\n     */\\n    function balanceOf(address _account) public view returns (uint256) {\\n        return getPooledEthByShares(_sharesOf(_account));\\n    }\\n\\n    /**\\n     * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\\n     *\\n     * @return a boolean value indicating whether the operation succeeded.\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `_recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `_amount`.\\n     * - the contract must not be paused.\\n     *\\n     * @dev The `_amount` argument is the amount of tokens, not shares.\\n     */\\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\\n        _transfer(msg.sender, _recipient, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @return the remaining number of tokens that `_spender` is allowed to spend\\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\\n     *\\n     * @dev This value changes when `approve` or `transferFrom` is called.\\n     */\\n    function allowance(address _owner, address _spender) public view returns (uint256) {\\n        return allowances[_owner][_spender];\\n    }\\n\\n    /**\\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\\n     *\\n     * @return a boolean value indicating whether the operation succeeded.\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `_spender` cannot be the zero address.\\n     * - the contract must not be paused.\\n     *\\n     * @dev The `_amount` argument is the amount of tokens, not shares.\\n     */\\n    function approve(address _spender, uint256 _amount) public returns (bool) {\\n        _approve(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\\n     * allowance mechanism. `_amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * @return a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `_sender` and `_recipient` cannot be the zero addresses.\\n     * - `_sender` must have a balance of at least `_amount`.\\n     * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\\n     * - the contract must not be paused.\\n     *\\n     * @dev The `_amount` argument is the amount of tokens, not shares.\\n     */\\n    function transferFrom(address _sender, address _recipient, uint256 _amount) public returns (bool) {\\n        uint256 currentAllowance = allowances[_sender][msg.sender];\\n        require(currentAllowance >= _amount, \\\"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\\\");\\n\\n        _transfer(_sender, _recipient, _amount);\\n        _approve(_sender, msg.sender, currentAllowance.sub(_amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in:\\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `_spender` cannot be the the zero address.\\n     * - the contract must not be paused.\\n     */\\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in:\\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `_spender` cannot be the zero address.\\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\\n     * - the contract must not be paused.\\n     */\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\\n        uint256 currentAllowance = allowances[msg.sender][_spender];\\n        require(currentAllowance >= _subtractedValue, \\\"DECREASED_ALLOWANCE_BELOW_ZERO\\\");\\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @return the total amount of shares in existence.\\n     *\\n     * @dev The sum of all accounts' shares can be an arbitrary number, therefore\\n     * it is necessary to store it in order to calculate each account's relative share.\\n     */\\n    function getTotalShares() public view returns (uint256) {\\n        return _getTotalShares();\\n    }\\n\\n    /**\\n     * @return the amount of shares owned by `_account`.\\n     */\\n    function sharesOf(address _account) public view returns (uint256) {\\n        return _sharesOf(_account);\\n    }\\n\\n    /**\\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\\n     */\\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\\n        uint256 totalPooledEther = _getTotalPooledEther();\\n        if (totalPooledEther == 0) {\\n            return 0;\\n        } else {\\n            return _ethAmount\\n                .mul(_getTotalShares())\\n                .div(totalPooledEther);\\n        }\\n    }\\n\\n    /**\\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\\n     */\\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\\n        uint256 totalShares = _getTotalShares();\\n        if (totalShares == 0) {\\n            return 0;\\n        } else {\\n            return _sharesAmount\\n                .mul(_getTotalPooledEther())\\n                .div(totalShares);\\n        }\\n    }\\n\\n    /**\\n     * @return the total amount (in wei) of Ether controlled by the protocol.\\n     * @dev This is used for calaulating tokens from shares and vice versa.\\n     * @dev This function is required to be implemented in a derived contract.\\n     */\\n    function _getTotalPooledEther() internal view returns (uint256);\\n\\n    /**\\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\\n     * Emits a `Transfer` event.\\n     */\\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\\n        _transferShares(_sender, _recipient, _sharesToTransfer);\\n        emit Transfer(_sender, _recipient, _amount);\\n    }\\n\\n    /**\\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `_owner` cannot be the zero address.\\n     * - `_spender` cannot be the zero address.\\n     * - the contract must not be paused.\\n     */\\n    function _approve(address _owner, address _spender, uint256 _amount) internal whenNotStopped {\\n        require(_owner != address(0), \\\"APPROVE_FROM_ZERO_ADDRESS\\\");\\n        require(_spender != address(0), \\\"APPROVE_TO_ZERO_ADDRESS\\\");\\n\\n        allowances[_owner][_spender] = _amount;\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    /**\\n     * @return the total amount of shares in existence.\\n     */\\n    function _getTotalShares() internal view returns (uint256) {\\n        return TOTAL_SHARES_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n     * @return the amount of shares owned by `_account`.\\n     */\\n    function _sharesOf(address _account) internal view returns (uint256) {\\n        return shares[_account];\\n    }\\n\\n    /**\\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\\n     *\\n     * Requirements:\\n     *\\n     * - `_sender` cannot be the zero address.\\n     * - `_recipient` cannot be the zero address.\\n     * - `_sender` must hold at least `_sharesAmount` shares.\\n     * - the contract must not be paused.\\n     */\\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal whenNotStopped {\\n        require(_sender != address(0), \\\"TRANSFER_FROM_THE_ZERO_ADDRESS\\\");\\n        require(_recipient != address(0), \\\"TRANSFER_TO_THE_ZERO_ADDRESS\\\");\\n\\n        uint256 currentSenderShares = shares[_sender];\\n        require(_sharesAmount <= currentSenderShares, \\\"TRANSFER_AMOUNT_EXCEEDS_BALANCE\\\");\\n\\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\\n    }\\n\\n    /**\\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\\n     * @dev This doesn't increase the token total supply.\\n     *\\n     * Requirements:\\n     *\\n     * - `_recipient` cannot be the zero address.\\n     * - the contract must not be paused.\\n     */\\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal whenNotStopped returns (uint256 newTotalShares) {\\n        require(_recipient != address(0), \\\"MINT_TO_THE_ZERO_ADDRESS\\\");\\n\\n        newTotalShares = _getTotalShares().add(_sharesAmount);\\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\\n\\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\\n\\n        // Notice: we're not emitting a Transfer event from the zero address here since shares mint\\n        // works by taking the amount of tokens corresponding to the minted shares from all other\\n        // token holders, proportionally to their share. The total supply of the token doesn't change\\n        // as the result. This is equivalent to performing a send from each other token holder's\\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\\n        // number of events.\\n    }\\n\\n    /**\\n     * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\\n     * @dev This doesn't decrease the token total supply.\\n     *\\n     * Requirements:\\n     *\\n     * - `_account` cannot be the zero address.\\n     * - `_account` must hold at least `_sharesAmount` shares.\\n     * - the contract must not be paused.\\n     */\\n    function _burnShares(address _account, uint256 _sharesAmount) internal whenNotStopped returns (uint256 newTotalShares) {\\n        require(_account != address(0), \\\"BURN_FROM_THE_ZERO_ADDRESS\\\");\\n\\n        uint256 accountShares = shares[_account];\\n        require(_sharesAmount <= accountShares, \\\"BURN_AMOUNT_EXCEEDS_BALANCE\\\");\\n\\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\\n\\n        shares[_account] = accountShares.sub(_sharesAmount);\\n\\n        // Notice: we're not emitting a Transfer event to the zero address here since shares burn\\n        // works by redistributing the amount of tokens corresponding to the burned shares between\\n        // all other token holders. The total supply of the token doesn't change as the result.\\n        // This is equivalent to performing a send from `address` to each other token holder address,\\n        // but we cannot reflect this as it would require sending an unbounded number of events.\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/apps/AppStorage.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../common/UnstructuredStorage.sol\\\";\\nimport \\\"../kernel/IKernel.sol\\\";\\n\\n\\ncontract AppStorage {\\n    using UnstructuredStorage for bytes32;\\n\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_POSITION = keccak256(\\\"aragonOS.appStorage.kernel\\\");\\n    bytes32 internal constant APP_ID_POSITION = keccak256(\\\"aragonOS.appStorage.appId\\\");\\n    */\\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\\n\\n    function kernel() public view returns (IKernel) {\\n        return IKernel(KERNEL_POSITION.getStorageAddress());\\n    }\\n\\n    function appId() public view returns (bytes32) {\\n        return APP_ID_POSITION.getStorageBytes32();\\n    }\\n\\n    function setKernel(IKernel _kernel) internal {\\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\\n    }\\n\\n    function setAppId(bytes32 _appId) internal {\\n        APP_ID_POSITION.setStorageBytes32(_appId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/acl/ACLSyntaxSugar.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract ACLSyntaxSugar {\\n    function arr() internal pure returns (uint256[]) {\\n        return new uint256[](0);\\n    }\\n\\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a));\\n    }\\n\\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a));\\n    }\\n\\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), _b, _c);\\n    }\\n\\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), _b, _c, _d);\\n    }\\n\\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\\n    }\\n\\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), uint256(_c));\\n    }\\n\\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), uint256(_c));\\n    }\\n\\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\\n        r = new uint256[](1);\\n        r[0] = _a;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\\n        r = new uint256[](2);\\n        r[0] = _a;\\n        r[1] = _b;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\\n        r = new uint256[](3);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\\n        r = new uint256[](4);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n        r[3] = _d;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\\n        r = new uint256[](5);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n        r[3] = _d;\\n        r[4] = _e;\\n    }\\n}\\n\\n\\ncontract ACLHelpers {\\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\\n        return uint8(_x >> (8 * 30));\\n    }\\n\\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\\n        return uint8(_x >> (8 * 31));\\n    }\\n\\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\\n        a = uint32(_x);\\n        b = uint32(_x >> (8 * 4));\\n        c = uint32(_x >> (8 * 8));\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Autopetrified.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Petrifiable.sol\\\";\\n\\n\\ncontract Autopetrified is Petrifiable {\\n    constructor() public {\\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\\n        // This renders them uninitializable (and unusable without a proxy).\\n        petrify();\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/ConversionHelpers.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n\\nlibrary ConversionHelpers {\\n    string private constant ERROR_IMPROPER_LENGTH = \\\"CONVERSION_IMPROPER_LENGTH\\\";\\n\\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\\n        // Force cast the uint256[] into a bytes array, by overwriting its length\\n        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\\n        // with the input and a new length. The input becomes invalid from this point forward.\\n        uint256 byteLength = _input.length * 32;\\n        assembly {\\n            output := _input\\n            mstore(output, byteLength)\\n        }\\n    }\\n\\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\\n        // Force cast the bytes array into a uint256[], by overwriting its length\\n        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\\n        // with the input and a new length. The input becomes invalid from this point forward.\\n        uint256 intsLength = _input.length / 32;\\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\\n\\n        assembly {\\n            output := _input\\n            mstore(output, intsLength)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/ReentrancyGuard.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../common/UnstructuredStorage.sol\\\";\\n\\n\\ncontract ReentrancyGuard {\\n    using UnstructuredStorage for bytes32;\\n\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant REENTRANCY_MUTEX_POSITION = keccak256(\\\"aragonOS.reentrancyGuard.mutex\\\");\\n    */\\n    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\\n\\n    string private constant ERROR_REENTRANT = \\\"REENTRANCY_REENTRANT_CALL\\\";\\n\\n    modifier nonReentrant() {\\n        // Ensure mutex is unlocked\\n        require(!REENTRANCY_MUTEX_POSITION.getStorageBool(), ERROR_REENTRANT);\\n\\n        // Lock mutex before function call\\n        REENTRANCY_MUTEX_POSITION.setStorageBool(true);\\n\\n        // Perform function call\\n        _;\\n\\n        // Unlock mutex after function call\\n        REENTRANCY_MUTEX_POSITION.setStorageBool(false);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/VaultRecoverable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../lib/token/ERC20.sol\\\";\\nimport \\\"./EtherTokenConstant.sol\\\";\\nimport \\\"./IsContract.sol\\\";\\nimport \\\"./IVaultRecoverable.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\n\\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\\n    using SafeERC20 for ERC20;\\n\\n    string private constant ERROR_DISALLOWED = \\\"RECOVER_DISALLOWED\\\";\\n    string private constant ERROR_VAULT_NOT_CONTRACT = \\\"RECOVER_VAULT_NOT_CONTRACT\\\";\\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \\\"RECOVER_TOKEN_TRANSFER_FAILED\\\";\\n\\n    /**\\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\\n     *         but in case it does, this function allows one to recover them.\\n     * @param _token Token balance to be sent to recovery vault.\\n     */\\n    function transferToVault(address _token) external {\\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\\n        address vault = getRecoveryVault();\\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\\n\\n        uint256 balance;\\n        if (_token == ETH) {\\n            balance = address(this).balance;\\n            vault.transfer(balance);\\n        } else {\\n            ERC20 token = ERC20(_token);\\n            balance = token.staticBalanceOf(this);\\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\\n        }\\n\\n        emit RecoverToVault(vault, _token, balance);\\n    }\\n\\n    /**\\n    * @dev By default deriving from AragonApp makes it recoverable\\n    * @param token Token address that would be recovered\\n    * @return bool whether the app allows the recovery\\n    */\\n    function allowRecoverability(address token) public view returns (bool) {\\n        return true;\\n    }\\n\\n    // Cast non-implemented interface to be public so we can use it internally\\n    function getRecoveryVault() public view returns (address);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/evmscript/EVMScriptRunner.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IEVMScriptExecutor.sol\\\";\\nimport \\\"./IEVMScriptRegistry.sol\\\";\\n\\nimport \\\"../apps/AppStorage.sol\\\";\\nimport \\\"../kernel/KernelConstants.sol\\\";\\nimport \\\"../common/Initializable.sol\\\";\\n\\n\\ncontract EVMScriptRunner is AppStorage, Initializable, EVMScriptRegistryConstants, KernelNamespaceConstants {\\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = \\\"EVMRUN_EXECUTOR_UNAVAILABLE\\\";\\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = \\\"EVMRUN_PROTECTED_STATE_MODIFIED\\\";\\n\\n    /* This is manually crafted in assembly\\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = \\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\";\\n    */\\n\\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\\n\\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\\n    }\\n\\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\\n        return IEVMScriptRegistry(registryAddr);\\n    }\\n\\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\\n        internal\\n        isInitialized\\n        protectState\\n        returns (bytes)\\n    {\\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\\n\\n        bytes4 sig = executor.execScript.selector;\\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\\n\\n        bytes memory output;\\n        assembly {\\n            let success := delegatecall(\\n                gas,                // forward all gas\\n                executor,           // address\\n                add(data, 0x20),    // calldata start\\n                mload(data),        // calldata length\\n                0,                  // don't write output (we'll handle this ourselves)\\n                0                   // don't write output\\n            )\\n\\n            output := mload(0x40) // free mem ptr get\\n\\n            switch success\\n            case 0 {\\n                // If the call errored, forward its full error data\\n                returndatacopy(output, 0, returndatasize)\\n                revert(output, returndatasize)\\n            }\\n            default {\\n                switch gt(returndatasize, 0x3f)\\n                case 0 {\\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\\n                    // revert with \\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\"\\n                    // See remix: doing a `revert(\\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\")` always results in\\n                    // this memory layout\\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\\n\\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\\n                }\\n                default {\\n                    // Copy result\\n                    //\\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\\n                    //    [ output length (32 bytes) ]\\n                    //    [ output content (N bytes) ]\\n                    //\\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\\n                    let copysize := sub(returndatasize, 0x20)\\n                    returndatacopy(output, 0x20, copysize)\\n\\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\\n                }\\n            }\\n        }\\n\\n        emit ScriptResult(address(executor), _script, _input, output);\\n\\n        return output;\\n    }\\n\\n    modifier protectState {\\n        address preKernel = address(kernel());\\n        bytes32 preAppId = appId();\\n        _; // exec\\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/UnstructuredStorage.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\nlibrary UnstructuredStorage {\\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function setStorageBool(bytes32 position, bool data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageAddress(bytes32 position, address data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageUint256(bytes32 position, uint256 data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/kernel/IKernel.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../acl/IACL.sol\\\";\\nimport \\\"../common/IVaultRecoverable.sol\\\";\\n\\n\\ninterface IKernelEvents {\\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\\n}\\n\\n\\n// This should be an interface, but interfaces can't inherit yet :(\\ncontract IKernel is IKernelEvents, IVaultRecoverable {\\n    function acl() public view returns (IACL);\\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\\n\\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/acl/IACL.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IACL {\\n    function initialize(address permissionsCreator) external;\\n\\n    // TODO: this should be external\\n    // See https://github.com/ethereum/solidity/issues/4832\\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/IVaultRecoverable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IVaultRecoverable {\\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\\n\\n    function transferToVault(address token) external;\\n\\n    function allowRecoverability(address token) external view returns (bool);\\n    function getRecoveryVault() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Petrifiable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Initializable.sol\\\";\\n\\n\\ncontract Petrifiable is Initializable {\\n    // Use block UINT256_MAX (which should be never) as the initializable date\\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\\n\\n    function isPetrified() public view returns (bool) {\\n        return getInitializationBlock() == PETRIFIED_BLOCK;\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract to prevent being initialized.\\n    *      Useful for freezing base contracts when they're used behind proxies.\\n    */\\n    function petrify() internal onlyInit {\\n        initializedAt(PETRIFIED_BLOCK);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Initializable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./TimeHelpers.sol\\\";\\nimport \\\"./UnstructuredStorage.sol\\\";\\n\\n\\ncontract Initializable is TimeHelpers {\\n    using UnstructuredStorage for bytes32;\\n\\n    // keccak256(\\\"aragonOS.initializable.initializationBlock\\\")\\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\\n\\n    string private constant ERROR_ALREADY_INITIALIZED = \\\"INIT_ALREADY_INITIALIZED\\\";\\n    string private constant ERROR_NOT_INITIALIZED = \\\"INIT_NOT_INITIALIZED\\\";\\n\\n    modifier onlyInit {\\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\\n        _;\\n    }\\n\\n    modifier isInitialized {\\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\\n        _;\\n    }\\n\\n    /**\\n    * @return Block number in which the contract was initialized\\n    */\\n    function getInitializationBlock() public view returns (uint256) {\\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n    * @return Whether the contract has been initialized by the time of the current block\\n    */\\n    function hasInitialized() public view returns (bool) {\\n        uint256 initializationBlock = getInitializationBlock();\\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract after initialization has finished.\\n    */\\n    function initialized() internal onlyInit {\\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract after initialization to enable the contract\\n    *      at a future block number rather than immediately.\\n    */\\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/TimeHelpers.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Uint256Helpers.sol\\\";\\n\\n\\ncontract TimeHelpers {\\n    using Uint256Helpers for uint256;\\n\\n    /**\\n    * @dev Returns the current block number.\\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\\n    *      tests.\\n    */\\n    function getBlockNumber() internal view returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n    * @dev Returns the current block number, converted to uint64.\\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\\n    *      tests.\\n    */\\n    function getBlockNumber64() internal view returns (uint64) {\\n        return getBlockNumber().toUint64();\\n    }\\n\\n    /**\\n    * @dev Returns the current timestamp.\\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\\n    *      tests.\\n    */\\n    function getTimestamp() internal view returns (uint256) {\\n        return block.timestamp; // solium-disable-line security/no-block-members\\n    }\\n\\n    /**\\n    * @dev Returns the current timestamp, converted to uint64.\\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\\n    *      tests.\\n    */\\n    function getTimestamp64() internal view returns (uint64) {\\n        return getTimestamp().toUint64();\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Uint256Helpers.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n\\nlibrary Uint256Helpers {\\n    uint256 private constant MAX_UINT64 = uint64(-1);\\n\\n    string private constant ERROR_NUMBER_TOO_BIG = \\\"UINT64_NUMBER_TOO_BIG\\\";\\n\\n    function toUint64(uint256 a) internal pure returns (uint64) {\\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\\n        return uint64(a);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/lib/token/ERC20.sol\": {\r\n      \"content\": \"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/ERC20.sol\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 {\\n    function totalSupply() public view returns (uint256);\\n\\n    function balanceOf(address _who) public view returns (uint256);\\n\\n    function allowance(address _owner, address _spender)\\n        public view returns (uint256);\\n\\n    function transfer(address _to, uint256 _value) public returns (bool);\\n\\n    function approve(address _spender, uint256 _value)\\n        public returns (bool);\\n\\n    function transferFrom(address _from, address _to, uint256 _value)\\n        public returns (bool);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/EtherTokenConstant.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\\n// contracts where both tokens and ETH are accepted\\ncontract EtherTokenConstant {\\n    address internal constant ETH = address(0);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/SafeERC20.sol\": {\r\n      \"content\": \"// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../lib/token/ERC20.sol\\\";\\n\\n\\nlibrary SafeERC20 {\\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\\n    // https://github.com/ethereum/solidity/issues/3544\\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\\n\\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \\\"SAFE_ERC_20_BALANCE_REVERTED\\\";\\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \\\"SAFE_ERC_20_ALLOWANCE_REVERTED\\\";\\n\\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\\n        private\\n        returns (bool)\\n    {\\n        bool ret;\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            let success := call(\\n                gas,                  // forward all gas\\n                _addr,                // address\\n                0,                    // no value\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                // Check number of bytes returned from last function call\\n                switch returndatasize\\n\\n                // No bytes returned: assume success\\n                case 0 {\\n                    ret := 1\\n                }\\n\\n                // 32 bytes returned: check if non-zero\\n                case 0x20 {\\n                    // Only return success if returned data was true\\n                    // Already have output in ptr\\n                    ret := eq(mload(ptr), 1)\\n                }\\n\\n                // Not sure what was returned: don't mark as success\\n                default { }\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    function staticInvoke(address _addr, bytes memory _calldata)\\n        private\\n        view\\n        returns (bool, uint256)\\n    {\\n        bool success;\\n        uint256 ret;\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            success := staticcall(\\n                gas,                  // forward all gas\\n                _addr,                // address\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                ret := mload(ptr)\\n            }\\n        }\\n        return (success, ret);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferCallData = abi.encodeWithSelector(\\n            TRANSFER_SELECTOR,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, transferCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferFromCallData = abi.encodeWithSelector(\\n            _token.transferFrom.selector,\\n            _from,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, transferFromCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\\n        bytes memory approveCallData = abi.encodeWithSelector(\\n            _token.approve.selector,\\n            _spender,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, approveCallData);\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.balanceOf().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\\n            _token.balanceOf.selector,\\n            _owner\\n        );\\n\\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\\n\\n        return tokenBalance;\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.allowance().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\\n        bytes memory allowanceCallData = abi.encodeWithSelector(\\n            _token.allowance.selector,\\n            _owner,\\n            _spender\\n        );\\n\\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\\n\\n        return allowance;\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.totalSupply().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\\n\\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\\n\\n        return totalSupply;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IEVMScriptExecutor {\\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\\n    function executorType() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IEVMScriptExecutor.sol\\\";\\n\\n\\ncontract EVMScriptRegistryConstants {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\\\"evmreg\\\");\\n    */\\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\\n}\\n\\n\\ninterface IEVMScriptRegistry {\\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\\n    function disableScriptExecutor(uint256 executorId) external;\\n\\n    // TODO: this should be external\\n    // See https://github.com/ethereum/solidity/issues/4832\\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/kernel/KernelConstants.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract KernelAppIds {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash(\\\"kernel\\\");\\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash(\\\"acl\\\");\\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash(\\\"vault\\\");\\n    */\\n    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\\n}\\n\\n\\ncontract KernelNamespaceConstants {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\\\"core\\\");\\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\\\"base\\\");\\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\\\"app\\\");\\n    */\\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external view returns (uint256);\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n    external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    external returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Pausable.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\nimport \\\"@aragon/os/contracts/common/UnstructuredStorage.sol\\\";\\n\\n\\ncontract Pausable {\\n    using UnstructuredStorage for bytes32;\\n\\n    event Stopped();\\n    event Resumed();\\n\\n    bytes32 internal constant ACTIVE_FLAG_POSITION = keccak256(\\\"lido.Pausable.activeFlag\\\");\\n\\n    modifier whenNotStopped() {\\n        require(ACTIVE_FLAG_POSITION.getStorageBool(), \\\"CONTRACT_IS_STOPPED\\\");\\n        _;\\n    }\\n\\n    modifier whenStopped() {\\n        require(!ACTIVE_FLAG_POSITION.getStorageBool(), \\\"CONTRACT_IS_ACTIVE\\\");\\n        _;\\n    }\\n\\n    function isStopped() external view returns (bool) {\\n        return !ACTIVE_FLAG_POSITION.getStorageBool();\\n    }\\n\\n    function _stop() internal whenNotStopped {\\n        ACTIVE_FLAG_POSITION.setStorageBool(false);\\n        emit Stopped();\\n    }\\n\\n    function _resume() internal whenStopped {\\n        ACTIVE_FLAG_POSITION.setStorageBool(true);\\n        emit Resumed();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"constantinople\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"depositContract\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_operators\",\"type\":\"address\"},{\"name\":\"_treasury\",\"type\":\"address\"},{\"name\":\"_insuranceFund\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInsuranceFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"name\":\"getSharesByPooledEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_script\",\"type\":\"bytes\"}],\"name\":\"getEVMScriptExecutor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRecoveryVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEPOSIT_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalPooledEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PAUSE_ROLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTreasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_ORACLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MANAGE_WITHDRAWAL_KEY\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBufferedEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SIGNATURE_LENGTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawalCredentials\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeDistribution\",\"outputs\":[{\"name\":\"treasuryFeeBasisPoints\",\"type\":\"uint16\"},{\"name\":\"insuranceFeeBasisPoints\",\"type\":\"uint16\"},{\"name\":\"operatorsFeeBasisPoints\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"getPooledEthByShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"allowRecoverability\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"appId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitializationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_treasuryFeeBasisPoints\",\"type\":\"uint16\"},{\"name\":\"_insuranceFeeBasisPoints\",\"type\":\"uint16\"},{\"name\":\"_operatorsFeeBasisPoints\",\"type\":\"uint16\"}],\"name\":\"setFeeDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeBasisPoints\",\"type\":\"uint16\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxDeposits\",\"type\":\"uint256\"}],\"name\":\"depositBufferedEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MANAGE_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"transferToVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_TREASURY\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"},{\"name\":\"_params\",\"type\":\"uint256[]\"}],\"name\":\"canPerform\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"submit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAWAL_CREDENTIALS_LENGTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEVMScriptRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PUBKEY_LENGTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_pubkeyHash\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDepositContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBeaconStat\",\"outputs\":[{\"name\":\"depositedValidators\",\"type\":\"uint256\"},{\"name\":\"beaconValidators\",\"type\":\"uint256\"},{\"name\":\"beaconBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BURN_ROLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_insuranceFund\",\"type\":\"address\"}],\"name\":\"setInsuranceFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"name\":\"feeBasisPoints\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_INSURANCE_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kernel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPetrified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalCredentials\",\"type\":\"bytes32\"}],\"name\":\"setWithdrawalCredentials\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositBufferedEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"burnShares\",\"outputs\":[{\"name\":\"newTotalShares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beaconValidators\",\"type\":\"uint256\"},{\"name\":\"_beaconBalance\",\"type\":\"uint256\"}],\"name\":\"pushBeacon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"script\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"input\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"ScriptResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RecoverToVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Resumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"feeBasisPoints\",\"type\":\"uint16\"}],\"name\":\"FeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"treasuryFeeBasisPoints\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"insuranceFeeBasisPoints\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"operatorsFeeBasisPoints\",\"type\":\"uint16\"}],\"name\":\"FeeDistributionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"withdrawalCredentials\",\"type\":\"bytes32\"}],\"name\":\"WithdrawalCredentialsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Submitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unbuffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sentFromBuffer\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"pubkeyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"Lido","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"constantinople","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}