{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath mul overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath div 0\"); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath sub b > a\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath add overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath mod 0\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/schnorr/Secp256k1.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract Secp256k1 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\r\n    uint256 constant gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\r\n    uint256 constant n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\r\n    uint256 constant a = 0;\r\n    uint256 constant b = 7;\r\n\r\n    function getGx() public pure returns (uint256) {\r\n        return gx;\r\n    }\r\n\r\n    function getGy() public pure returns (uint256) {\r\n        return gy;\r\n    }\r\n\r\n    function ecadd(\r\n        uint256 x1,\r\n        uint256 y1,\r\n        uint256 x2,\r\n        uint256 y2\r\n    ) public view returns (uint256 retx, uint256 rety) {\r\n        address to = 0X42;\r\n        assembly {\r\n            let freePtr := mload(0x40)\r\n            mstore(add(freePtr, 0), x1)\r\n            mstore(add(freePtr, 32), y1)\r\n            mstore(add(freePtr, 64), x2)\r\n            mstore(add(freePtr, 96), y2)\r\n\r\n            if iszero(staticcall(gas, to, freePtr, 132, freePtr, 64)) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            retx := mload(freePtr)\r\n            rety := mload(add(freePtr, 32))\r\n        }\r\n    }\r\n\r\n    function ecmul(\r\n        uint256 xPk,\r\n        uint256 yPk,\r\n        uint256 scalar\r\n    ) public view returns (uint256 x, uint256 y) {\r\n        address to = 0x43;\r\n        assembly {\r\n            let freePtr := mload(0x40)\r\n            mstore(add(freePtr, 0), scalar)\r\n            mstore(add(freePtr, 32), xPk)\r\n            mstore(add(freePtr, 64), yPk)\r\n\r\n            if iszero(staticcall(gas, to, freePtr, 96, freePtr, 64)) {\r\n                revert(0,0)\r\n            }\r\n\r\n            x := mload(freePtr)\r\n            y := mload(add(freePtr, 32))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/schnorr/Secp256k1SchnorrVerifier.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract Secp256k1SchnorrVerifier is Secp256k1 {\r\n    struct Point {\r\n        uint256 x; uint256 y;\r\n    }\r\n\r\n    struct Verification {\r\n        Point groupKey;\r\n        Point randomPoint;\r\n        uint256 signature;\r\n        bytes32 message;\r\n\r\n        uint256 _hash;\r\n        Point _left;\r\n        Point _right;\r\n    }\r\n\r\n    function h(bytes32 m, uint256 a, uint256 b) public pure returns (uint256) {\r\n        return uint256(sha256(abi.encodePacked(m, uint8(0x04), a, b)));\r\n    }\r\n\r\n    // function cmul(Point p, uint256 scalar) public pure returns (uint256, uint256) {\r\n    function cmul(uint256 x, uint256 y, uint256 scalar) public view returns (uint256, uint256) {\r\n        return ecmul(x, y, scalar);\r\n    }\r\n\r\n    function sg(uint256 sig_s) public view returns (uint256, uint256) {\r\n        return ecmul(getGx(), getGy(), sig_s);\r\n    }\r\n\r\n    // function cadd(Point a, Point b) public pure returns (uint256, uint256) {\r\n    function cadd(uint256 ax, uint256 ay, uint256 bx, uint256 by) public view returns (uint256, uint256) {\r\n        return ecadd(ax, ay, bx, by);\r\n    }\r\n\r\n    function verify(bytes32 signature, bytes32 groupKeyX, bytes32 groupKeyY, bytes32 randomPointX, bytes32 randomPointY, bytes32 message)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        bool flag = false;\r\n        Verification memory state;\r\n\r\n        state.signature = uint256(signature);\r\n        state.groupKey.x = uint256(groupKeyX);\r\n        state.groupKey.y = uint256(groupKeyY);\r\n        state.randomPoint.x = uint256(randomPointX);\r\n        state.randomPoint.y = uint256(randomPointY);\r\n        state.message = message;\r\n\r\n        state._hash = h(state.message, state.randomPoint.x, state.randomPoint.y);\r\n\r\n        (state._left.x, state._left.y) = sg(state.signature);\r\n        Point memory rightPart;\r\n        (rightPart.x, rightPart.y) = cmul(state.groupKey.x, state.groupKey.y, state._hash);\r\n        (state._right.x, state._right.y) = cadd(state.randomPoint.x, state.randomPoint.y, rightPart.x, rightPart.y);\r\n\r\n        flag = state._left.x == state._right.x && state._left.y == state._right.y;\r\n\r\n        return flag;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"signature\",\"type\":\"bytes32\"},{\"name\":\"groupKeyX\",\"type\":\"bytes32\"},{\"name\":\"groupKeyY\",\"type\":\"bytes32\"},{\"name\":\"randomPointX\",\"type\":\"bytes32\"},{\"name\":\"randomPointY\",\"type\":\"bytes32\"},{\"name\":\"message\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"scalar\",\"type\":\"uint256\"}],\"name\":\"cmul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ax\",\"type\":\"uint256\"},{\"name\":\"ay\",\"type\":\"uint256\"},{\"name\":\"bx\",\"type\":\"uint256\"},{\"name\":\"by\",\"type\":\"uint256\"}],\"name\":\"cadd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"xPk\",\"type\":\"uint256\"},{\"name\":\"yPk\",\"type\":\"uint256\"},{\"name\":\"scalar\",\"type\":\"uint256\"}],\"name\":\"ecmul\",\"outputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"},{\"name\":\"x2\",\"type\":\"uint256\"},{\"name\":\"y2\",\"type\":\"uint256\"}],\"name\":\"ecadd\",\"outputs\":[{\"name\":\"retx\",\"type\":\"uint256\"},{\"name\":\"rety\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sig_s\",\"type\":\"uint256\"}],\"name\":\"sg\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"m\",\"type\":\"bytes32\"},{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"h\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Secp256k1SchnorrVerifier","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://aa98909a240c1a18be6f732a7d11901555d669f43eb6018c5045f362812d3723"}]}