{"status":"1","message":"OK","result":[{"SourceCode":"//   _    _ _   _                __ _                            \r\n//  | |  (_) | | |              / _(_)                           \r\n//  | | ___| |_| |_ ___ _ __   | |_ _ _ __   __ _ _ __   ___ ___ \r\n//  | |/ / | __| __/ _ \\ '_ \\  |  _| | '_ \\ / _` | '_ \\ / __/ _ \\\r\n//  |   <| | |_| ||  __/ | | |_| | | | | | | (_| | | | | (_|  __/\r\n//  |_|\\_\\_|\\__|\\__\\___|_| |_(_)_| |_|_| |_|\\__,_|_| |_|\\___\\___|\r\n//\r\n//  KittenSwap v0.1\r\n//\r\n//  https://www.KittenSwap.org/\r\n//\r\npragma solidity ^0.6.12;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"!!add\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"!!sub\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"!!mul\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"!!div\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\ncontract KittenSwapV01 \r\n{\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    \r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    address public govAddr;\r\n    address public devAddr;\r\n    \r\n    constructor () public {\r\n        govAddr = msg.sender;\r\n        devAddr = msg.sender;\r\n    }\r\n    \r\n    modifier govOnly() \r\n    {\r\n    \trequire(msg.sender == govAddr, \"!gov\");\r\n    \t_;\r\n    }\r\n    function govTransferAddr(address newAddr) external govOnly \r\n    {\r\n    \trequire(newAddr != address(0), \"!addr\");\r\n    \tgovAddr = newAddr;\r\n    }\r\n    \r\n    modifier devOnly() \r\n    {\r\n    \trequire(msg.sender == devAddr, \"!dev\");\r\n    \t_;\r\n    }\r\n    function devTransferAddr(address newAddr) external govOnly \r\n    {\r\n    \trequire(newAddr != address(0), \"!addr\");\r\n    \tdevAddr = newAddr;\r\n    }\r\n    \r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    mapping (address => mapping (address => uint)) public vault;\r\n    \r\n    event VAULT_DEPOSIT(address indexed user, address indexed token, uint amt);\r\n    event VAULT_WITHDRAW(address indexed user, address indexed token, uint amt);\r\n    \r\n    function vaultWithdraw(address token, uint amt) external \r\n    {\r\n        address payable user = msg.sender;\r\n\r\n        vault[user][token] = vault[user][token].sub(amt);\r\n        if (token == address(0)) {\r\n            user.transfer(amt);\r\n        } else {\r\n            IERC20(token).safeTransfer(user, amt);\r\n        }\r\n        emit VAULT_WITHDRAW(user, token, amt);\r\n    }\r\n    \r\n    function vaultDeposit(address token, uint amt) external payable\r\n    {\r\n        address user = msg.sender;\r\n\r\n        if (token == address(0)) {\r\n            vault[user][token] = vault[user][token].add(msg.value);\r\n        } else {\r\n            IERC20(token).safeTransferFrom(user, address(this), amt);\r\n            vault[user][token] = vault[user][token].add(amt);\r\n        }\r\n        emit VAULT_DEPOSIT(user, token, amt);\r\n    }    \r\n    \r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    struct MARKET {\r\n        address token;        // fixed after creation\r\n        uint96 AMT_SCALE;     // fixed after creation\r\n        uint96 PRICE_SCALE;   // fixed after creation\r\n        uint16 DEVFEE_BP;     // in terms of basis points (1 bp = 0.01%)\r\n    }\r\n    MARKET[] public marketList;\r\n    \r\n    event MARKET_CREATE(address indexed token, uint96 $AMT_SCALE, uint96 $PRICE_SCALE, uint indexed id);\r\n    \r\n    function govCreateMarket(address $token, uint96 $AMT_SCALE, uint96 $PRICE_SCALE, uint16 $DEVFEE_BP) external govOnly \r\n    {\r\n        require ($AMT_SCALE > 0);\r\n        require ($PRICE_SCALE > 0);\r\n        require ($DEVFEE_BP <= 60);\r\n        \r\n        MARKET memory m;\r\n        m.token = $token;\r\n        m.AMT_SCALE = $AMT_SCALE;\r\n        m.PRICE_SCALE = $PRICE_SCALE;\r\n        m.DEVFEE_BP = $DEVFEE_BP;\r\n        \r\n        marketList.push(m);\r\n        \r\n        emit MARKET_CREATE($token, $AMT_SCALE, $PRICE_SCALE, marketList.length - 1);\r\n    }\r\n    \r\n    function govSetDevFee(uint $marketId, uint16 $DEVFEE_BP) external govOnly \r\n    {\r\n        require ($DEVFEE_BP <= 60);\r\n        marketList[$marketId].DEVFEE_BP = $DEVFEE_BP;\r\n    }\r\n    \r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    struct ORDER {\r\n        uint32 tokenAmtScaled;  // scaled by AMT_SCALE        SCALE 10^12 => 1 ~ 2^32-1 means 0.000001 ~ 4294.967295\r\n        uint24 priceLowScaled;  // scaled by PRICE_SCALE      SCALE 10^4 => 1 ~ 2^24-1 means 0.0001 ~ 1677.7215\r\n        uint24 priceHighScaled; // scaled by PRICE_SCALE      SCALE 10^4 => 1 ~ 2^24-1 means 0.0001 ~ 1677.7215\r\n        uint160 userMaker;\r\n    }\r\n    mapping (uint => ORDER[]) public orderList; // div 2 = market, mod 2 = 0 sell, 1 buy\r\n    \r\n    uint constant UINT32_MAX = 2**32 - 1;\r\n    \r\n    event ORDER_CREATE(address indexed userMaker, uint indexed marketIsBuy, uint orderInfo, uint indexed orderId);\r\n    event ORDER_MODIFY(address indexed userMaker, uint indexed marketIsBuy, uint newOrderInfo, uint indexed orderId);\r\n    event ORDER_TRADE(address indexed userTaker, address userMaker, uint indexed marketIsBuy, uint fillOrderInfo, uint indexed orderId);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    function marketCount() external view returns (uint)\r\n    {\r\n        return marketList.length;\r\n    }\r\n    \r\n    function orderCount(uint $marketIsBuy) external view returns (uint)\r\n    {\r\n        return orderList[$marketIsBuy].length;\r\n    }\r\n    \r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    function orderCreate(uint $marketIsBuy, uint32 $tokenAmtScaled, uint24 $priceLowScaled, uint24 $priceHighScaled) external payable \r\n    {\r\n        require($priceLowScaled > 0, \"!priceLow\");\r\n        require($priceHighScaled > 0, \"!priceHigh\");\r\n        require($priceHighScaled >= $priceLowScaled, \"!priceRange\");\r\n\r\n        uint isMakerBuy = $marketIsBuy % 2;\r\n        MARKET memory m = marketList[$marketIsBuy / 2];\r\n        require(m.token != address(0), \"!market\");\r\n        \r\n        //------------------------------------------------------------------------------\r\n\r\n        address userMaker = msg.sender;\r\n            \r\n        if (isMakerBuy > 0) // buy token -> deposit ETH\r\n        {\r\n            uint ethAmt = uint($tokenAmtScaled) * uint(m.AMT_SCALE) * (uint($priceLowScaled) + uint($priceHighScaled)) / uint(m.PRICE_SCALE * 2);\r\n            require(msg.value == ethAmt, '!eth');\r\n        }\r\n        else // sell token -> deposit token\r\n        {\r\n            IERC20 token = IERC20(m.token);\r\n            if ($tokenAmtScaled > 0)\r\n                token.safeTransferFrom(userMaker, address(this), uint($tokenAmtScaled) * uint(m.AMT_SCALE));\r\n            require(msg.value == 0, '!eth');\r\n        }\r\n        \r\n        //------------------------------------------------------------------------------\r\n        \r\n        ORDER memory o;\r\n        o.userMaker = uint160(userMaker);\r\n        o.tokenAmtScaled = $tokenAmtScaled;\r\n        o.priceLowScaled = $priceLowScaled;\r\n        o.priceHighScaled = $priceHighScaled;\r\n        \r\n        //------------------------------------------------------------------------------\r\n\r\n        ORDER[] storage oList = orderList[$marketIsBuy];\r\n        oList.push(o);\r\n        \r\n        uint orderId = oList.length - 1;\r\n        uint orderInfo = $tokenAmtScaled | ($priceLowScaled<<32) | ($priceHighScaled<<(32+24));\r\n\r\n        emit ORDER_CREATE(userMaker, $marketIsBuy, orderInfo, orderId);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    function orderModify(uint $marketIsBuy, uint32 newTokenAmtScaled, uint24 newPriceLowScaled, uint24 newPriceHighScaled, uint orderID) external payable \r\n    {\r\n        require(newPriceLowScaled > 0, \"!priceLow\");\r\n        require(newPriceHighScaled > 0, \"!priceHigh\");\r\n        require(newPriceHighScaled >= newPriceLowScaled, \"!priceRange\");\r\n        \r\n        address payable userMaker = msg.sender;\r\n        ORDER storage o = orderList[$marketIsBuy][orderID];\r\n        require (uint160(userMaker) == o.userMaker, \"!user\");\r\n\r\n        uint isMakerBuy = $marketIsBuy % 2;\r\n        MARKET memory m = marketList[$marketIsBuy / 2];\r\n        \r\n        //------------------------------------------------------------------------------\r\n\r\n        if (isMakerBuy > 0) // old order: maker buy token -> modify ETH amt\r\n        {\r\n            uint oldEthAmt = uint(o.tokenAmtScaled) * uint(m.AMT_SCALE) * (uint(o.priceLowScaled) + uint(o.priceHighScaled)) / uint(m.PRICE_SCALE * 2);\r\n            uint newEthAmt = uint(newTokenAmtScaled) * uint(m.AMT_SCALE) * (uint(newPriceLowScaled) + uint(newPriceHighScaled)) / uint(m.PRICE_SCALE * 2);\r\n\r\n            uint extraEthAmt = (msg.value).add(oldEthAmt).sub(newEthAmt); // throw if not enough\r\n            \r\n            if (extraEthAmt > 0)\r\n                userMaker.transfer(extraEthAmt); // return extra ETH to maker\r\n        }\r\n        else // old order: maker sell token -> modify token amt\r\n        {\r\n            uint oldTokenAmt = uint(o.tokenAmtScaled) * uint(m.AMT_SCALE);\r\n            uint newTokenAmt = uint(newTokenAmtScaled) * uint(m.AMT_SCALE);\r\n\r\n            IERC20 token = IERC20(m.token);\r\n            if (newTokenAmt > oldTokenAmt) {\r\n                token.safeTransferFrom(userMaker, address(this), newTokenAmt - oldTokenAmt);\r\n            }\r\n            else if (newTokenAmt < oldTokenAmt) {\r\n                token.safeTransfer(userMaker, oldTokenAmt - newTokenAmt); // return extra token to maker\r\n            }\r\n            require(msg.value == 0, '!eth');            \r\n        }\r\n        \r\n        //------------------------------------------------------------------------------\r\n        \r\n        if (o.tokenAmtScaled != newTokenAmtScaled)\r\n            o.tokenAmtScaled = newTokenAmtScaled;\r\n        if (o.priceLowScaled != newPriceLowScaled)\r\n            o.priceLowScaled = newPriceLowScaled;\r\n        if (o.priceHighScaled != newPriceHighScaled)\r\n            o.priceHighScaled = newPriceHighScaled;\r\n\r\n        uint orderInfo = newTokenAmtScaled | (newPriceLowScaled<<32) | (newPriceHighScaled<<(32+24));\r\n\r\n        emit ORDER_MODIFY(userMaker, $marketIsBuy, orderInfo, orderID);\r\n    }\r\n    \r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    \r\n    \r\n    function _fill_WLO(ORDER storage o, MARKET memory m, uint isMakerBuy, uint32 $tokenAmtScaled, uint24 fillPriceWorstScaled) internal returns (uint fillTokenAmtScaled, uint fillEthAmt)\r\n    {\r\n        uint allSlots = uint(1) + uint(o.priceHighScaled) - uint(o.priceLowScaled);\r\n        uint fullFillSlots = allSlots * ($tokenAmtScaled) / uint(o.tokenAmtScaled);\r\n        if (fullFillSlots > allSlots) {\r\n            fullFillSlots = allSlots;\r\n        }\r\n        \r\n        if (isMakerBuy > 0) // maker buy token -> taker sell token\r\n        {\r\n            require (fillPriceWorstScaled <= o.priceHighScaled, '!price');\r\n            uint fillPriceEndScaled = uint(o.priceHighScaled).sub(fullFillSlots);\r\n            if ((uint(fillPriceWorstScaled) * 2) > (o.priceHighScaled))\r\n            {\r\n                uint _ppp = (uint(fillPriceWorstScaled) * 2) - (o.priceHighScaled);\r\n                if (fillPriceEndScaled < _ppp)\r\n                    fillPriceEndScaled = _ppp;\r\n            }\r\n            require (fillPriceEndScaled <= o.priceHighScaled, '!price');\r\n            \r\n            //------------------------------------------------------------------------------\r\n            \r\n            if (($tokenAmtScaled >= o.tokenAmtScaled) && (fillPriceEndScaled <= o.priceLowScaled)) // full fill\r\n            {\r\n                fillTokenAmtScaled = o.tokenAmtScaled;\r\n                fillEthAmt = uint(fillTokenAmtScaled) * uint(m.AMT_SCALE) * (uint(o.priceLowScaled) + uint(o.priceHighScaled)) / uint(m.PRICE_SCALE * 2);\r\n\r\n                o.tokenAmtScaled = 0;\r\n\r\n                return (fillTokenAmtScaled, fillEthAmt);\r\n            }\r\n            \r\n            //------------------------------------------------------------------------------\r\n            \r\n            {\r\n                uint fillTokenAmtFirst = 0; // full fill @ [fillPriceEndScaled+1, priceHighScaled]\r\n                {\r\n                    uint firstFillSlots = uint(o.priceHighScaled) - uint(fillPriceEndScaled);\r\n                    fillTokenAmtFirst = firstFillSlots * uint(o.tokenAmtScaled) * uint(m.AMT_SCALE) / allSlots;\r\n                }\r\n                fillEthAmt = fillTokenAmtFirst * (uint(o.priceHighScaled) + uint(fillPriceEndScaled) + 1) / uint(m.PRICE_SCALE * 2);\r\n                \r\n                uint fillTokenAmtSecond = (uint($tokenAmtScaled) * uint(m.AMT_SCALE)).sub(fillTokenAmtFirst); // partial fill @ fillPriceEndScaled\r\n                {\r\n                    uint amtPerSlot = uint(o.tokenAmtScaled) * uint(m.AMT_SCALE) / allSlots;\r\n                    if (fillTokenAmtSecond > amtPerSlot) {\r\n                        fillTokenAmtSecond = amtPerSlot;\r\n                    }\r\n                }\r\n                \r\n                fillTokenAmtScaled = (fillTokenAmtFirst + fillTokenAmtSecond) / uint(m.AMT_SCALE);\r\n                \r\n                fillTokenAmtSecond = (fillTokenAmtScaled * uint(m.AMT_SCALE)).sub(fillTokenAmtFirst);\r\n                fillEthAmt = fillEthAmt.add(fillTokenAmtSecond * fillPriceEndScaled / uint(m.PRICE_SCALE));\r\n            }\r\n            \r\n            //------------------------------------------------------------------------------\r\n            \r\n            uint newPriceHighScaled =\r\n                (\r\n                    ( uint(o.tokenAmtScaled) * uint(m.AMT_SCALE) * (uint(o.priceLowScaled) + uint(o.priceHighScaled)) )\r\n                    .sub\r\n                    ( fillEthAmt * uint(m.PRICE_SCALE * 2) )\r\n                )\r\n                /\r\n                ( (uint(o.tokenAmtScaled).sub(fillTokenAmtScaled)) * uint(m.AMT_SCALE) )\r\n            ;\r\n            newPriceHighScaled = newPriceHighScaled.sub(o.priceLowScaled);\r\n            \r\n            require (newPriceHighScaled >= o.priceLowScaled, \"!badFinalRange\"); // shall never happen\r\n            \r\n            o.priceHighScaled = uint24(newPriceHighScaled);        \r\n            \r\n            o.tokenAmtScaled = uint32(uint(o.tokenAmtScaled).sub(fillTokenAmtScaled));\r\n        }\r\n        //------------------------------------------------------------------------------\r\n        else // maker sell token -> taker buy token\r\n        {\r\n            require (fillPriceWorstScaled >= o.priceLowScaled, '!price');\r\n            uint fillPriceEndScaled = uint(o.priceLowScaled).add(fullFillSlots);\r\n            {\r\n                uint _ppp = (uint(fillPriceWorstScaled) * 2).sub(o.priceLowScaled);\r\n                if (fillPriceEndScaled > _ppp)\r\n                    fillPriceEndScaled = _ppp;\r\n            }\r\n            require (fillPriceEndScaled >= o.priceLowScaled, '!price');\r\n            \r\n            //------------------------------------------------------------------------------\r\n            \r\n            if (($tokenAmtScaled >= o.tokenAmtScaled) && (fillPriceEndScaled >= o.priceHighScaled)) // full fill\r\n            {\r\n                fillTokenAmtScaled = o.tokenAmtScaled;\r\n                fillEthAmt = uint(fillTokenAmtScaled) * uint(m.AMT_SCALE) * (uint(o.priceLowScaled) + uint(o.priceHighScaled)) / uint(m.PRICE_SCALE * 2);\r\n\r\n                o.tokenAmtScaled = 0;\r\n\r\n                return (fillTokenAmtScaled, fillEthAmt);\r\n            }\r\n            \r\n            //------------------------------------------------------------------------------\r\n\r\n            {\r\n                uint fillTokenAmtFirst = 0; // full fill @ [priceLowScaled, fillPriceEndScaled-1]\r\n                {\r\n                    uint firstFillSlots = uint(fillPriceEndScaled) - uint(o.priceLowScaled);\r\n                    fillTokenAmtFirst = firstFillSlots * uint(o.tokenAmtScaled) * uint(m.AMT_SCALE) / allSlots;\r\n                }\r\n                fillEthAmt = fillTokenAmtFirst * (uint(o.priceLowScaled) + uint(fillPriceEndScaled) - 1) / uint(m.PRICE_SCALE * 2);\r\n                \r\n                uint fillTokenAmtSecond = (uint($tokenAmtScaled) * uint(m.AMT_SCALE)).sub(fillTokenAmtFirst); // partial fill @ fillPriceEndScaled\r\n                {\r\n                    uint amtPerSlot = uint(o.tokenAmtScaled) * uint(m.AMT_SCALE) / allSlots;\r\n                    if (fillTokenAmtSecond > amtPerSlot) {\r\n                        fillTokenAmtSecond = amtPerSlot;\r\n                    }\r\n                }\r\n                \r\n                fillTokenAmtScaled = (fillTokenAmtFirst + fillTokenAmtSecond) / uint(m.AMT_SCALE);\r\n                \r\n                fillTokenAmtSecond = (fillTokenAmtScaled * uint(m.AMT_SCALE)).sub(fillTokenAmtFirst);\r\n                fillEthAmt = fillEthAmt.add(fillTokenAmtSecond * fillPriceEndScaled / uint(m.PRICE_SCALE));\r\n            }\r\n            \r\n            //------------------------------------------------------------------------------\r\n            \r\n            o.tokenAmtScaled = uint32(uint(o.tokenAmtScaled).sub(fillTokenAmtScaled));\r\n            o.priceLowScaled = uint24(fillPriceEndScaled);\r\n        }\r\n    }\r\n    \r\n    ////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    function orderTrade(uint $marketIsBuy, uint32 $tokenAmtScaled, uint24 fillPriceWorstScaled, uint orderID) external payable \r\n    {\r\n        ORDER storage o = orderList[$marketIsBuy][orderID];\r\n        require ($tokenAmtScaled > 0, '!amt');\r\n        require (o.tokenAmtScaled > 0, '!amt');\r\n\r\n        address payable userTaker = msg.sender;\r\n        address payable userMaker = payable(o.userMaker);\r\n\r\n        uint isMakerBuy = $marketIsBuy % 2;\r\n        MARKET memory m = marketList[$marketIsBuy / 2];\r\n        IERC20 token = IERC20(m.token);\r\n\r\n        uint fillTokenAmtScaled = 0;\r\n        uint fillEthAmt = 0;\r\n        \r\n        //------------------------------------------------------------------------------\r\n\r\n        if (o.priceLowScaled == o.priceHighScaled) // simple limit order\r\n        {\r\n            uint fillPriceScaled = o.priceLowScaled;\r\n            \r\n            if (isMakerBuy > 0) { // maker buy token -> taker sell token\r\n                require (fillPriceScaled >= fillPriceWorstScaled, \"!price\"); // sell at higher price\r\n            }\r\n            else { // maker sell token -> taker buy token\r\n                require (fillPriceScaled <= fillPriceWorstScaled, \"!price\"); // buy at lower price\r\n            }\r\n            \r\n            //------------------------------------------------------------------------------\r\n\r\n            fillTokenAmtScaled = $tokenAmtScaled;\r\n            if (fillTokenAmtScaled > o.tokenAmtScaled)\r\n                fillTokenAmtScaled = o.tokenAmtScaled;\r\n\r\n            fillEthAmt = fillTokenAmtScaled * uint(m.AMT_SCALE) * (fillPriceScaled) / uint(m.PRICE_SCALE);\r\n\r\n            o.tokenAmtScaled = uint32(uint(o.tokenAmtScaled).sub(fillTokenAmtScaled));\r\n        }\r\n        //------------------------------------------------------------------------------\r\n        else // Wide Limit Order\r\n        {\r\n            require (o.priceHighScaled > o.priceLowScaled, '!badOrder');\r\n            \r\n            (fillTokenAmtScaled, fillEthAmt) = _fill_WLO(o, m, isMakerBuy, $tokenAmtScaled, fillPriceWorstScaled); // will modify order\r\n        }\r\n        \r\n        //------------------------------------------------------------------------------\r\n        \r\n        require(fillTokenAmtScaled > 0, \"!fillTokenAmtScaled\");\r\n        require(fillEthAmt > 0, \"!fillEthAmt\");\r\n        \r\n        uint fillTokenAmt = fillTokenAmtScaled * uint(m.AMT_SCALE);\r\n        \r\n        if (isMakerBuy > 0) // maker buy token -> taker sell token\r\n        {\r\n            token.safeTransferFrom(userTaker, userMaker, fillTokenAmt); // send token to maker (from taker)\r\n\r\n            uint devFee = fillEthAmt * uint(m.DEVFEE_BP) / (10000);\r\n            vault[devAddr][address(0)] = vault[devAddr][address(0)].add(devFee);\r\n\r\n            userTaker.transfer(fillEthAmt.sub(devFee)); // send eth to taker\r\n            require(msg.value == 0, '!eth');\r\n        }\r\n        else // maker sell token -> taker buy token\r\n        {\r\n            require(msg.value >= fillEthAmt, '!eth');\r\n            \r\n            token.safeTransfer(userTaker, fillTokenAmt); // send token to taker\r\n\r\n            uint devFee = fillEthAmt * uint(m.DEVFEE_BP) / (10000);\r\n            vault[devAddr][address(0)] = vault[devAddr][address(0)].add(devFee);\r\n\r\n            userMaker.transfer(fillEthAmt.sub(devFee)); // send eth to maker\r\n            \r\n            if (msg.value > fillEthAmt) {\r\n                userTaker.transfer(msg.value - fillEthAmt); // return extra eth to taker\r\n            }\r\n        }\r\n\r\n        //------------------------------------------------------------------------------\r\n\r\n        uint orderInfo = fillTokenAmtScaled | fillEthAmt<<32;\r\n\r\n        emit ORDER_TRADE(userTaker, userMaker, $marketIsBuy, orderInfo, orderID);    \r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"$AMT_SCALE\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"$PRICE_SCALE\",\"type\":\"uint96\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"MARKET_CREATE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userMaker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"marketIsBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderInfo\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"ORDER_CREATE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userMaker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"marketIsBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newOrderInfo\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"ORDER_MODIFY\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userTaker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userMaker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"marketIsBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fillOrderInfo\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"ORDER_TRADE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"VAULT_DEPOSIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"VAULT_WITHDRAW\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"devAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"devTransferAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"govAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"$token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"$AMT_SCALE\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"$PRICE_SCALE\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"$DEVFEE_BP\",\"type\":\"uint16\"}],\"name\":\"govCreateMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"$marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"$DEVFEE_BP\",\"type\":\"uint16\"}],\"name\":\"govSetDevFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"govTransferAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"AMT_SCALE\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"PRICE_SCALE\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"DEVFEE_BP\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"$marketIsBuy\",\"type\":\"uint256\"}],\"name\":\"orderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"$marketIsBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"$tokenAmtScaled\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"$priceLowScaled\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"$priceHighScaled\",\"type\":\"uint24\"}],\"name\":\"orderCreate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderList\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenAmtScaled\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"priceLowScaled\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"priceHighScaled\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"userMaker\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"$marketIsBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"newTokenAmtScaled\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"newPriceLowScaled\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"newPriceHighScaled\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"orderID\",\"type\":\"uint256\"}],\"name\":\"orderModify\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"$marketIsBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"$tokenAmtScaled\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"fillPriceWorstScaled\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"orderID\",\"type\":\"uint256\"}],\"name\":\"orderTrade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"vaultDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"vaultWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KittenSwapV01","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://27db567a69e2cd1271882b6301e44f31d93acaf01e6542df89ba274561542051"}]}