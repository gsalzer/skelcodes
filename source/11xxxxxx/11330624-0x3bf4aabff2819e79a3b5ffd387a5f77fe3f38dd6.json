{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.0;\\n\\ninterface IERC20 {\\n\\n  function totalSupply() external view returns (uint);\\n  function balanceOf(address tokenOwner) external view returns (uint balance);\\n  function allowance(address tokenOwner, address spender) external view returns (uint remaining);\\n  function transfer(address to, uint tokens) external returns (bool success);\\n  function approve(address spender, uint tokens) external returns (bool success);\\n  function transferFrom(address from, address to, uint tokens) external returns (bool success);\\n\\n  event Transfer(address indexed from, address indexed to, uint tokens);\\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.0;\\n\\ncontract Ownable {\\n\\n  address public owner;\\n  address public feeAddress;\\n  address public reserveAddress;\\n\\n  event OwnershipTransferred(address newOwner);\\n  event FeeAddressTransferred(address newFeeAddress);\\n  event ReserveAddressTransferred(address newReserveAddress);\\n\\n  constructor() {\\n    owner = msg.sender;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == owner, \\u0027You are not the owner!\\u0027);\\n    _;\\n  }\\n\\n  function transferOwnership(address newOwner) onlyOwner internal {\\n    owner = newOwner;\\n  }\\n\\n  function transferFeeAddress(address newFeeAddress) onlyOwner internal {\\n    feeAddress = newFeeAddress;\\n  }\\n\\n  function transferReserveAddress(address newReserveAddress) onlyOwner internal {\\n    reserveAddress = newReserveAddress;\\n  }\\n\\n}\"},\"SafeMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.0;\\n\\nlibrary SafeMath {\\n\\n  function add(uint a, uint b) internal pure returns(uint) {\\n    uint c = a + b;\\n    require(c \\u003e= a, \\\"Sum overflow!\\\");\\n    return c;\\n  }\\n\\n  function sub(uint a, uint b) internal pure returns(uint) {\\n    uint c = a - b;\\n    require(c \\u003c= a, \\\"Sub underflow!\\\");\\n    return c;\\n  }\\n\\n  function mul(uint a, uint b) internal pure returns(uint) {\\n    if(a == 0) {\\n      return 0;\\n    }\\n    uint c = a * b;\\n    require(c / a == b, \\\"Mul overflow!\\\");\\n    return c;\\n  }\\n  \\n  function div(uint a, uint b) internal pure returns(uint) {\\n    uint c = a / b;\\n    return c;\\n  }\\n\\n}\"},\"TreasuryBondsPlus.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.0;\\npragma experimental ABIEncoderV2;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./Ownable.sol\\u0027;\\nimport \\u0027./SafeMathLib.sol\\u0027;\\n\\ncontract TreasuryBondsPlus is Ownable, IERC20 {\\n\\n  using SafeMath for uint;\\n\\n  string public constant name = \\u0027Treasury Bonds Plus\\u0027;\\n  string public constant symbol = \\u0027TB+\\u0027;\\n  uint8 public constant decimals = 8;\\n\\n  uint private _totalSupply;\\n\\n  mapping(address =\\u003e uint) private _balances;\\n  mapping(address =\\u003e mapping(address =\\u003e uint)) private _allowed;\\n\\n  event Mint(address indexed to, uint tokens);\\n  event Burn(address indexed account, uint tokens);\\n  event BuyBack(address indexed tokenOwner, uint tokens);\\n\\n  constructor(address _feeAddress, address _reserveAddress) {\\n    _totalSupply = 50000000 * 10 **uint(decimals);\\n    feeAddress = _feeAddress;\\n    reserveAddress = _reserveAddress;\\n\\n    _balances[owner] = _totalSupply;\\n    emit Transfer(address(0), owner, _totalSupply);\\n  }\\n\\n  function totalSupply() public override view returns (uint) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address tokenOwner) public override view returns (uint balance) {\\n    return _balances[tokenOwner];\\n  }\\n\\n  function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\\n    return _allowed[tokenOwner][spender];\\n  }\\n\\n  function transfer(address to, uint tokens) public override returns (bool success) {\\n    require(tokens \\u003e= 1000000, \\u0027The minimum amount of tokens that can be transferred is 0.01.\\u0027);\\n\\n    uint tax = 0;\\n    if (msg.sender != owner) tax = _setTax(tokens);\\n\\n    _transfer(msg.sender, to, tokens, tax);\\n    return true;\\n  }\\n\\n  function approve(address spender, uint tokens) public override returns (bool success) {\\n    require(msg.sender != address(0), \\u0027Invalid address!\\u0027);\\n    require(spender != address(0), \\u0027Invalid address!\\u0027);\\n\\n    _allowed[msg.sender][spender] = tokens;\\n    emit Approval(msg.sender, spender, tokens);\\n    return true;\\n  }\\n\\n  function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\\n    require(tokens \\u003e= 1000000, \\u0027The minimum amount of tokens that can be transferred is 0.01.\\u0027);\\n    require(_allowed[from][msg.sender] \\u003e= tokens, \\u0027Quantity of tokens allowed is insufficient!\\u0027);\\n    require(to == msg.sender, \\u0027The receiving address must be the same as the one calling the function!\\u0027);\\n\\n    uint tax = _setTax(tokens);\\n    _transfer(from, to, tokens, tax);\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens);\\n    return true;\\n  }\\n\\n  function mint(address to, uint tokens) public onlyOwner {\\n    require(to != address(0), \\u0027Invalid address!\\u0027);\\n\\n    _balances[to] = _balances[to].add(tokens);\\n    _totalSupply = _totalSupply.add(tokens);\\n    emit Mint(to, tokens);\\n  }\\n\\n  function burn(address account, uint tokens) public onlyOwner {\\n    require(account != address(0), \\u0027Invalid address!\\u0027);\\n    require(_balances[account] \\u003e= tokens, \\u0027Account balance is less than the number of tokens\\u0027);\\n\\n    _balances[account] = _balances[account].sub(tokens);\\n    _totalSupply = _totalSupply.sub(tokens);\\n    emit Burn(account, tokens);\\n  }\\n\\n  function buyBack(address tokenOwner, uint tokens) public onlyOwner returns (bool success) {\\n    require(_balances[tokenOwner] \\u003e= tokens, \\u0027Insufficient tokens!\\u0027);\\n\\n    _balances[tokenOwner] = _balances[tokenOwner].sub(tokens);\\n    _balances[reserveAddress] = _balances[reserveAddress].add(tokens);\\n    \\n    emit BuyBack(tokenOwner, tokens);\\n    return true;\\n  }\\n\\n  function newOwner(address account) public onlyOwner returns (bool success) {\\n    require(account != owner, \\u0027The address of the new owner must be different from the current one.\\u0027);\\n\\n    address oldOwner = owner;\\n    transferOwnership(account);\\n    _balances[account] = _balances[oldOwner];\\n    _balances[oldOwner] = 0;\\n    OwnershipTransferred(account);\\n    return true;\\n  }\\n\\n  function newFeeAddress(address account) public onlyOwner returns (bool success) {\\n    require(account != feeAddress, \\u0027The new feeAddress must be different from the current one.\\u0027);\\n\\n    address oldFeeAddress = feeAddress;\\n    transferFeeAddress(account);\\n    _balances[account] = _balances[oldFeeAddress];\\n    _balances[oldFeeAddress] = 0;\\n    FeeAddressTransferred(account);\\n    return true;\\n  }\\n\\n  function newReserveAddress(address account) public onlyOwner returns (bool success) {\\n    require(account != reserveAddress, \\u0027The new reserveAddress must be different from the current one.\\u0027);\\n\\n    address oldReserveAddress = reserveAddress;\\n    transferReserveAddress(account);\\n    _balances[account] = _balances[oldReserveAddress];\\n    _balances[oldReserveAddress] = 0;\\n    ReserveAddressTransferred(account);\\n    return true;\\n  }\\n\\n  function close() public onlyOwner {\\n    selfdestruct(payable(owner));\\n  }\\n\\n  function _setTax(uint tokens) private pure returns (uint) {\\n    uint tokensInPercentage = tokens / 100;\\n    uint tax;\\n\\n    if (tokens \\u003c= 10000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 2; // 0,50%\\n    else if (tokens \\u003c= 50000 * 10 **uint(decimals)) tax = tokensInPercentage * 7 / 20; // 0,35%\\n    else if (tokens \\u003c= 100000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 4; // 0,25%\\n    else if (tokens \\u003c= 1000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 5; // 0,20%\\n    else if (tokens \\u003c= 10000000 * 10 **uint(decimals)) tax = tokensInPercentage * 9 / 50; // 0,18%\\n    else if (tokens \\u003c= 50000000 * 10 **uint(decimals)) tax = tokensInPercentage * 3 / 20; // 0,15%\\n    else if (tokens \\u003c= 100000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 10; // 0,10%\\n    else if (tokens \\u003c= 300000000 * 10 **uint(decimals)) tax = tokensInPercentage * 7 / 100; // 0,07%\\n    else if (tokens \\u003c= 500000000 * 10 **uint(decimals)) tax = tokensInPercentage * 3 / 50; // 0,06%\\n    else if (tokens \\u003c= 1000000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 20; // 0,05%\\n    else tax = tokensInPercentage * 1 / 25; // 0,04%\\n\\n    return tax;\\n  }\\n\\n  function _transfer(address sender, address recipient, uint tokens, uint tax) private {\\n    require(sender != address(0), \\u0027Invalid address!\\u0027);\\n    require(recipient != address(0), \\u0027Invalid address!\\u0027);\\n    require(sender != recipient, \\u0027Addresses must be different!\\u0027);\\n    require(_balances[sender] \\u003e= tokens, \\u0027Insufficient tokens!\\u0027);\\n\\n    uint tokensWithTax = tokens;\\n    if (tax \\u003e 0) {\\n      tokensWithTax = tokens - tax;\\n      _balances[feeAddress] = _balances[feeAddress].add(tax);\\n    }\\n    \\n    _balances[sender] = _balances[sender].sub(tokens);\\n    _balances[recipient] = _balances[recipient].add(tokensWithTax);\\n\\n    emit Transfer(sender, recipient, tokens);\\n  }\\n\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reserveAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"BuyBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeAddress\",\"type\":\"address\"}],\"name\":\"FeeAddressTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReserveAddress\",\"type\":\"address\"}],\"name\":\"ReserveAddressTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"buyBack\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"newFeeAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"newReserveAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TreasuryBondsPlus","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000fd2f357491f6cc553e9181d1f07e2391252f4a3700000000000000000000000020159d6e895b3afe3a570a296a8d6b568ed6744c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6d43e597403994acdd646fb84ff693496f126f7347e97da25e32191c575a9528"}]}