{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic is ERC165 {\r\n\r\n  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n  /*\r\n   * 0x80ac58cd ===\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n  /*\r\n   * 0x4f558e79 ===\r\n   *   bytes4(keccak256('exists(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n  /**\r\n   * 0x780e9d63 ===\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n  /**\r\n   * 0x5b5e139f ===\r\n   *   bytes4(keccak256('name()')) ^\r\n   *   bytes4(keccak256('symbol()')) ^\r\n   *   bytes4(keccak256('tokenURI(uint256)'))\r\n   */\r\n\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 _tokenId);\r\n\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() external view returns (string _name);\r\n  function symbol() external view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/SupportsInterfaceWithLookup.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title SupportsInterfaceWithLookup\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract SupportsInterfaceWithLookup is ERC165 {\r\n\r\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n  /**\r\n   * 0x01ffc9a7 ===\r\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\r\n   */\r\n\r\n  /**\r\n   * @dev a mapping of interface id to whether or not it's supported\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev A contract implementing SupportsInterfaceWithLookup\r\n   * implement ERC165 itself\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    _registerInterface(InterfaceId_ERC165);\r\n  }\r\n\r\n  /**\r\n   * @dev implement supportsInterface(bytes4) using a lookup table\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceId];\r\n  }\r\n\r\n  /**\r\n   * @dev private method for registering an interface\r\n   */\r\n  function _registerInterface(bytes4 _interfaceId)\r\n    internal\r\n  {\r\n    require(_interfaceId != 0xffffffff);\r\n    supportedInterfaces[_interfaceId] = true;\r\n  }\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/IMintableERC20.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract IMintableERC20 {\r\n\r\n    function mint(address _to, uint256 _value) public;\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/ISettingsRegistry.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract ISettingsRegistry {\r\n    enum SettingsValueTypes { NONE, UINT, STRING, ADDRESS, BYTES, BOOL, INT }\r\n\r\n    function uintOf(bytes32 _propertyName) public view returns (uint256);\r\n\r\n    function stringOf(bytes32 _propertyName) public view returns (string);\r\n\r\n    function addressOf(bytes32 _propertyName) public view returns (address);\r\n\r\n    function bytesOf(bytes32 _propertyName) public view returns (bytes);\r\n\r\n    function boolOf(bytes32 _propertyName) public view returns (bool);\r\n\r\n    function intOf(bytes32 _propertyName) public view returns (int);\r\n\r\n    function setUintProperty(bytes32 _propertyName, uint _value) public;\r\n\r\n    function setStringProperty(bytes32 _propertyName, string _value) public;\r\n\r\n    function setAddressProperty(bytes32 _propertyName, address _value) public;\r\n\r\n    function setBytesProperty(bytes32 _propertyName, bytes _value) public;\r\n\r\n    function setBoolProperty(bytes32 _propertyName, bool _value) public;\r\n\r\n    function setIntProperty(bytes32 _propertyName, int _value) public;\r\n\r\n    function getValueTypeOf(bytes32 _propertyName) public view returns (uint /* SettingsValueTypes */ );\r\n\r\n    event ChangeProperty(bytes32 indexed _propertyName, uint256 _type);\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/IAuthority.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract IAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\n// File: @evolutionland/common/contracts/DSAuth.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\n/**\r\n * @title DSAuth\r\n * @dev The DSAuth contract is reference implement of https://github.com/dapphub/ds-auth\r\n * But in the isAuthorized method, the src from address(this) is remove for safty concern.\r\n */\r\ncontract DSAuth is DSAuthEvents {\r\n    IAuthority   public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(IAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == owner) {\r\n            return true;\r\n        } else if (authority == IAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @evolutionland/common/contracts/SettingIds.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n    Id definitions for SettingsRegistry.sol\r\n    Can be used in conjunction with the settings registry to get properties\r\n*/\r\ncontract SettingIds {\r\n    bytes32 public constant CONTRACT_RING_ERC20_TOKEN = \"CONTRACT_RING_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_KTON_ERC20_TOKEN = \"CONTRACT_KTON_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_GOLD_ERC20_TOKEN = \"CONTRACT_GOLD_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_WOOD_ERC20_TOKEN = \"CONTRACT_WOOD_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_WATER_ERC20_TOKEN = \"CONTRACT_WATER_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_FIRE_ERC20_TOKEN = \"CONTRACT_FIRE_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_SOIL_ERC20_TOKEN = \"CONTRACT_SOIL_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_OBJECT_OWNERSHIP = \"CONTRACT_OBJECT_OWNERSHIP\";\r\n\r\n    bytes32 public constant CONTRACT_TOKEN_LOCATION = \"CONTRACT_TOKEN_LOCATION\";\r\n\r\n    bytes32 public constant CONTRACT_LAND_BASE = \"CONTRACT_LAND_BASE\";\r\n\r\n    bytes32 public constant CONTRACT_USER_POINTS = \"CONTRACT_USER_POINTS\";\r\n\r\n    bytes32 public constant CONTRACT_INTERSTELLAR_ENCODER = \"CONTRACT_INTERSTELLAR_ENCODER\";\r\n\r\n    bytes32 public constant CONTRACT_DIVIDENDS_POOL = \"CONTRACT_DIVIDENDS_POOL\";\r\n\r\n    bytes32 public constant CONTRACT_TOKEN_USE = \"CONTRACT_TOKEN_USE\";\r\n\r\n    bytes32 public constant CONTRACT_REVENUE_POOL = \"CONTRACT_REVENUE_POOL\";\r\n\r\n    bytes32 public constant CONTRACT_ERC721_BRIDGE = \"CONTRACT_ERC721_BRIDGE\";\r\n\r\n    bytes32 public constant CONTRACT_PET_BASE = \"CONTRACT_PET_BASE\";\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // this can be considered as transaction fee.\r\n    // Values 0-10,000 map to 0%-100%\r\n    // set ownerCut to 4%\r\n    // ownerCut = 400;\r\n    bytes32 public constant UINT_AUCTION_CUT = \"UINT_AUCTION_CUT\";  // Denominator is 10000\r\n\r\n    bytes32 public constant UINT_TOKEN_OFFER_CUT = \"UINT_TOKEN_OFFER_CUT\";  // Denominator is 10000\r\n\r\n    // Cut referer takes on each auction, measured in basis points (1/100 of a percent).\r\n    // which cut from transaction fee.\r\n    // Values 0-10,000 map to 0%-100%\r\n    // set refererCut to 4%\r\n    // refererCut = 400;\r\n    bytes32 public constant UINT_REFERER_CUT = \"UINT_REFERER_CUT\";\r\n\r\n    bytes32 public constant CONTRACT_LAND_RESOURCE = \"CONTRACT_LAND_RESOURCE\";\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/IInterstellarEncoder.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract IInterstellarEncoder {\r\n    uint256 constant CLEAR_HIGH =  0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\r\n\r\n    uint256 public constant MAGIC_NUMBER = 42;    // Interstellar Encoding Magic Number.\r\n    uint256 public constant CHAIN_ID = 1; // Ethereum mainet.\r\n    uint256 public constant CURRENT_LAND = 1; // 1 is Atlantis, 0 is NaN.\r\n\r\n    enum ObjectClass { \r\n        NaN,\r\n        LAND,\r\n        APOSTLE,\r\n        OBJECT_CLASS_COUNT\r\n    }\r\n\r\n    function registerNewObjectClass(address _objectContract, uint8 objectClass) public;\r\n\r\n    function registerNewTokenContract(address _tokenAddress) public;\r\n\r\n    function encodeTokenId(address _tokenAddress, uint8 _objectClass, uint128 _objectIndex) public view returns (uint256 _tokenId);\r\n\r\n    function encodeTokenIdForObjectContract(\r\n        address _tokenAddress, address _objectContract, uint128 _objectId) public view returns (uint256 _tokenId);\r\n\r\n    function getContractAddress(uint256 _tokenId) public view returns (address);\r\n\r\n    function getObjectId(uint256 _tokenId) public view returns (uint128 _objectId);\r\n\r\n    function getObjectClass(uint256 _tokenId) public view returns (uint8);\r\n\r\n    function getObjectAddress(uint256 _tokenId) public view returns (address);\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/ITokenUse.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract ITokenUse {\r\n    uint48 public constant MAX_UINT48_TIME = 281474976710655;\r\n\r\n    function isObjectInHireStage(uint256 _tokenId) public view returns (bool);\r\n\r\n    function isObjectReadyToUse(uint256 _tokenId) public view returns (bool);\r\n\r\n    function getTokenUser(uint256 _tokenId) public view returns (address);\r\n\r\n    function createTokenUseOffer(uint256 _tokenId, uint256 _duration, uint256 _price, address _acceptedActivity) public;\r\n\r\n    function cancelTokenUseOffer(uint256 _tokenId) public;\r\n\r\n    function takeTokenUseOffer(uint256 _tokenId) public;\r\n\r\n    function addActivity(uint256 _tokenId, address _user, uint256 _endTime) public;\r\n\r\n    function removeActivity(uint256 _tokenId, address _user) public;\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/IActivity.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract IActivity is ERC165 {\r\n    bytes4 internal constant InterfaceId_IActivity = 0x6086e7f8; \r\n    /*\r\n     * 0x6086e7f8 ===\r\n     *   bytes4(keccak256('activityStopped(uint256)'))\r\n     */\r\n\r\n    function activityStopped(uint256 _tokenId) public;\r\n}\r\n\r\n// File: @evolutionland/common/contracts/interfaces/IMinerObject.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract IMinerObject is ERC165  {\r\n    bytes4 internal constant InterfaceId_IMinerObject = 0x64272b75;\r\n    \r\n    /*\r\n     * 0x64272b752 ===\r\n     *   bytes4(keccak256('strengthOf(uint256,address)'))\r\n     */\r\n\r\n    function strengthOf(uint256 _tokenId, address _resourceToken, uint256 _landTokenId) public view returns (uint256);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ILandBase.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract ILandBase {\r\n\r\n    /*\r\n     *  Event\r\n     */\r\n    event ModifiedResourceRate(uint indexed tokenId, address resourceToken, uint16 newResourceRate);\r\n    event HasboxSetted(uint indexed tokenId, bool hasBox);\r\n\r\n    event ChangedReourceRateAttr(uint indexed tokenId, uint256 attr);\r\n\r\n    event ChangedFlagMask(uint indexed tokenId, uint256 newFlagMask);\r\n\r\n    event CreatedNewLand(uint indexed tokenId, int x, int y, address beneficiary, uint256 resourceRateAttr, uint256 mask);\r\n\r\n    function defineResouceTokenRateAttrId(address _resourceToken, uint8 _attrId) public;\r\n\r\n    function setHasBox(uint _landTokenID, bool isHasBox) public;\r\n    function isReserved(uint256 _tokenId) public view returns (bool);\r\n    function isSpecial(uint256 _tokenId) public view returns (bool);\r\n    function isHasBox(uint256 _tokenId) public view returns (bool);\r\n\r\n    function getResourceRateAttr(uint _landTokenId) public view returns (uint256);\r\n    function setResourceRateAttr(uint _landTokenId, uint256 _newResourceRateAttr) public;\r\n\r\n    function getResourceRate(uint _landTokenId, address _resouceToken) public view returns (uint16);\r\n    function setResourceRate(uint _landTokenID, address _resourceToken, uint16 _newResouceRate) public;\r\n\r\n    function getFlagMask(uint _landTokenId) public view returns (uint256);\r\n\r\n    function setFlagMask(uint _landTokenId, uint256 _newFlagMask) public;\r\n\r\n}\r\n\r\n// File: contracts/LandSettingIds.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract LandSettingIds is SettingIds {\r\n\r\n}\r\n\r\n// File: contracts/LandResourceV4.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title LandResource\r\n * @dev LandResource is registry that manage the element resources generated on Land, and related resource releasing speed.\r\n * difference between LandResourceV2:\r\n     1. add function landWorkingOn to get which land the apostle is working on\r\n     2. add function updateMinerStrength to update miner strength on land\r\n     3. add event UpdateMiningStrength\r\n */\r\n\r\n\r\ncontract LandResourceV4 is SupportsInterfaceWithLookup, DSAuth, IActivity, LandSettingIds {\r\n    using SafeMath for *;\r\n\r\n    // For every seconds, the speed will decrease by current speed multiplying (DENOMINATOR_in_seconds - seconds) / DENOMINATOR_in_seconds\r\n    // resource will decrease 1/10000 every day.\r\n    uint256 public constant DENOMINATOR = 10000;\r\n\r\n    uint256 public constant TOTAL_SECONDS = DENOMINATOR * (1 days);\r\n\r\n    bool private singletonLock = false;\r\n\r\n    ISettingsRegistry public registry;\r\n\r\n    uint256 public resourceReleaseStartTime;\r\n\r\n    // TODO: move to global settings contract.\r\n    uint256 public attenPerDay = 1;\r\n    uint256 public recoverAttenPerDay = 20;\r\n\r\n    // Struct for recording resouces on land which have already been pinged.\r\n    // 金, Evolution Land Gold\r\n    // 木, Evolution Land Wood\r\n    // 水, Evolution Land Water\r\n    // 火, Evolution Land fire\r\n    // 土, Evolution Land Silicon\r\n    struct ResourceMineState {\r\n        mapping(address => uint256) mintedBalance;\r\n        mapping(address => uint256[]) miners;\r\n        mapping(address => uint256) totalMinerStrength;\r\n        uint256 lastUpdateSpeedInSeconds;\r\n        uint256 lastDestoryAttenInSeconds;\r\n        uint256 industryIndex;\r\n        uint128 lastUpdateTime;\r\n        uint64 totalMiners;\r\n        uint64 maxMiners;\r\n    }\r\n\r\n    struct MinerStatus {\r\n        uint256 landTokenId;\r\n        address resource;\r\n        uint64 indexInResource;\r\n    }\r\n\r\n    mapping(uint256 => ResourceMineState) public land2ResourceMineState;\r\n\r\n    mapping(uint256 => MinerStatus) public miner2Index;\r\n\r\n    /*\r\n     *  Event\r\n     */\r\n\r\n    event StartMining(uint256 minerTokenId, uint256 landTokenId, address _resource, uint256 strength);\r\n    event StopMining(uint256 minerTokenId, uint256 landTokenId, address _resource, uint256 strength);\r\n    event ResourceClaimed(address owner, uint256 landTokenId, uint256 goldBalance, uint256 woodBalance, uint256 waterBalance, uint256 fireBalance, uint256 soilBalance);\r\n\r\n    event UpdateMiningStrengthWhenStop(uint256 apostleTokenId, uint256 landTokenId, uint256 strength);\r\n    event UpdateMiningStrengthWhenStart(uint256 apostleTokenId, uint256 landTokenId, uint256 strength);\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier singletonLockCall() {\r\n        require(!singletonLock, \"Only can call once\");\r\n        _;\r\n        singletonLock = true;\r\n    }\r\n\r\n\r\n    function initializeContract(address _registry, uint256 _resourceReleaseStartTime) public singletonLockCall {\r\n        // Ownable constructor\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n\r\n        registry = ISettingsRegistry(_registry);\r\n\r\n        resourceReleaseStartTime = _resourceReleaseStartTime;\r\n\r\n        _registerInterface(InterfaceId_IActivity);\r\n    }\r\n\r\n    // get amount of speed uint at this moment\r\n    function _getReleaseSpeedInSeconds(uint256 _tokenId, uint256 _time) internal view returns (uint256 currentSpeed) {\r\n        require(_time >= resourceReleaseStartTime, \"Should after release time\");\r\n        require(_time >= land2ResourceMineState[_tokenId].lastUpdateTime, \"Should after release last update time\");\r\n\r\n        // after 10000 days from start\r\n        // the resource release speed decreases to 0\r\n        if (TOTAL_SECONDS < _time - resourceReleaseStartTime)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        // max amount of speed unit of _tokenId for now\r\n        // suppose that speed_uint = 1 in this function\r\n        uint256 availableSpeedInSeconds = TOTAL_SECONDS.sub(_time - resourceReleaseStartTime);\r\n        // time from last update\r\n        uint256 timeBetween = _time - land2ResourceMineState[_tokenId].lastUpdateTime;\r\n\r\n        // the recover speed is 20/10000, 20 times.\r\n        // recoveryRate overall from lasUpdateTime til now + amount of speed uint at lastUpdateTime\r\n        uint256 nextSpeedInSeconds = land2ResourceMineState[_tokenId].lastUpdateSpeedInSeconds + timeBetween * recoverAttenPerDay;\r\n        // destroyRate overall from lasUpdateTime til now amount of speed uint at lastUpdateTime\r\n        uint256 destroyedSpeedInSeconds = timeBetween * land2ResourceMineState[_tokenId].lastDestoryAttenInSeconds;\r\n\r\n        if (nextSpeedInSeconds < destroyedSpeedInSeconds)\r\n        {\r\n            nextSpeedInSeconds = 0;\r\n        } else {\r\n            nextSpeedInSeconds = nextSpeedInSeconds - destroyedSpeedInSeconds;\r\n        }\r\n\r\n        if (nextSpeedInSeconds > availableSpeedInSeconds) {\r\n            nextSpeedInSeconds = availableSpeedInSeconds;\r\n        }\r\n\r\n        return nextSpeedInSeconds;\r\n    }\r\n\r\n    function getReleaseSpeed(uint256 _tokenId, address _resourceToken, uint256 _time) public view returns (uint256 currentSpeed) {\r\n        return ILandBase(registry.addressOf(CONTRACT_LAND_BASE))\r\n        .getResourceRate(_tokenId, _resourceToken).mul(_getReleaseSpeedInSeconds(_tokenId, _time))\r\n        .div(TOTAL_SECONDS);\r\n    }\r\n\r\n    /**\r\n     * @dev Get and Query the amount of resources available from lastUpdateTime to now for use on specific land.\r\n     * @param _tokenId The token id of specific land.\r\n    */\r\n    function _getMinableBalance(uint256 _tokenId, address _resourceToken, uint256 _currentTime, uint256 _lastUpdateTime) public view returns (uint256 minableBalance) {\r\n\r\n        uint256 speed_in_current_period = ILandBase(registry.addressOf(CONTRACT_LAND_BASE))\r\n        .getResourceRate(_tokenId, _resourceToken).mul(_getReleaseSpeedInSeconds(_tokenId, ((_currentTime + _lastUpdateTime) / 2))).mul(1 ether).div(1 days).div(TOTAL_SECONDS);\r\n\r\n        // calculate the area of trapezoid\r\n        minableBalance = speed_in_current_period.mul(_currentTime - _lastUpdateTime);\r\n    }\r\n\r\n    function _getMaxMineBalance(uint256 _tokenId, address _resourceToken, uint256 _currentTime, uint256 _lastUpdateTime) internal view returns (uint256) {\r\n        // totalMinerStrength is in wei\r\n        uint256 mineSpeed = land2ResourceMineState[_tokenId].totalMinerStrength[_resourceToken];\r\n\r\n        return mineSpeed.mul(_currentTime - _lastUpdateTime).div(1 days);\r\n    }\r\n\r\n    function mine(uint256 _landTokenId) public {\r\n        _mineAllResource(\r\n            _landTokenId,\r\n            registry.addressOf(CONTRACT_GOLD_ERC20_TOKEN),\r\n            registry.addressOf(CONTRACT_WOOD_ERC20_TOKEN),\r\n            registry.addressOf(CONTRACT_WATER_ERC20_TOKEN),\r\n            registry.addressOf(CONTRACT_FIRE_ERC20_TOKEN),\r\n            registry.addressOf(CONTRACT_SOIL_ERC20_TOKEN)\r\n        );\r\n    }\r\n\r\n    function _mineAllResource(uint256 _landTokenId, address _gold, address _wood, address _water, address _fire, address _soil) internal {\r\n        require(IInterstellarEncoder(registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)).getObjectClass(_landTokenId) == 1, \"Token must be land.\");\r\n\r\n        if (land2ResourceMineState[_landTokenId].lastUpdateTime == 0) {\r\n            land2ResourceMineState[_landTokenId].lastUpdateTime = uint128(resourceReleaseStartTime);\r\n            land2ResourceMineState[_landTokenId].lastUpdateSpeedInSeconds = TOTAL_SECONDS;\r\n        }\r\n\r\n        _mineResource(_landTokenId, _gold);\r\n        _mineResource(_landTokenId, _wood);\r\n        _mineResource(_landTokenId, _water);\r\n        _mineResource(_landTokenId, _fire);\r\n        _mineResource(_landTokenId, _soil);\r\n\r\n        land2ResourceMineState[_landTokenId].lastUpdateSpeedInSeconds = _getReleaseSpeedInSeconds(_landTokenId, now);\r\n        land2ResourceMineState[_landTokenId].lastUpdateTime = uint128(now);\r\n\r\n    }\r\n\r\n    function _mineResource(uint256 _landTokenId, address _resourceToken) internal {\r\n        // the longest seconds to zero speed.\r\n        uint minedBalance = _calculateMinedBalance(_landTokenId, _resourceToken, now);\r\n\r\n        land2ResourceMineState[_landTokenId].mintedBalance[_resourceToken] += minedBalance;\r\n    }\r\n\r\n    function _calculateMinedBalance(uint256 _landTokenId, address _resourceToken, uint256 _currentTime) internal returns (uint256) {\r\n        uint256 currentTime = _currentTime;\r\n\r\n        uint256 minedBalance;\r\n        uint256 minableBalance;\r\n        if (currentTime > (resourceReleaseStartTime + TOTAL_SECONDS))\r\n        {\r\n            currentTime = (resourceReleaseStartTime + TOTAL_SECONDS);\r\n        }\r\n\r\n        uint256 lastUpdateTime = land2ResourceMineState[_landTokenId].lastUpdateTime;\r\n        require(currentTime >= lastUpdateTime);\r\n\r\n        if (lastUpdateTime >= (resourceReleaseStartTime + TOTAL_SECONDS)) {\r\n            minedBalance = 0;\r\n            minableBalance = 0;\r\n        } else {\r\n            minedBalance = _getMaxMineBalance(_landTokenId, _resourceToken, currentTime, lastUpdateTime);\r\n            minableBalance = _getMinableBalance(_landTokenId, _resourceToken, currentTime, lastUpdateTime);\r\n        }\r\n\r\n\r\n        if (minedBalance > minableBalance) {\r\n            minedBalance = minableBalance;\r\n        }\r\n\r\n        return minedBalance;\r\n    }\r\n\r\n    function claimAllResource(uint256 _landTokenId) public {\r\n        require(msg.sender == ERC721(registry.addressOf(CONTRACT_OBJECT_OWNERSHIP)).ownerOf(_landTokenId), \"Must be the owner of the land\");\r\n\r\n        address gold = registry.addressOf(CONTRACT_GOLD_ERC20_TOKEN);\r\n        address wood = registry.addressOf(CONTRACT_WOOD_ERC20_TOKEN);\r\n        address water = registry.addressOf(CONTRACT_WATER_ERC20_TOKEN);\r\n        address fire = registry.addressOf(CONTRACT_FIRE_ERC20_TOKEN);\r\n        address soil = registry.addressOf(CONTRACT_SOIL_ERC20_TOKEN);\r\n\r\n        _mineAllResource(_landTokenId, gold, wood, water, fire, soil);\r\n\r\n        uint goldBalance;\r\n        uint woodBalance;\r\n        uint waterBalance;\r\n        uint fireBalance;\r\n        uint soilBalance;\r\n\r\n        if (land2ResourceMineState[_landTokenId].mintedBalance[gold] > 0) {\r\n            goldBalance = land2ResourceMineState[_landTokenId].mintedBalance[gold];\r\n            IMintableERC20(gold).mint(msg.sender, goldBalance);\r\n            land2ResourceMineState[_landTokenId].mintedBalance[gold] = 0;\r\n        }\r\n\r\n        if (land2ResourceMineState[_landTokenId].mintedBalance[wood] > 0) {\r\n            woodBalance = land2ResourceMineState[_landTokenId].mintedBalance[wood];\r\n            IMintableERC20(wood).mint(msg.sender, woodBalance);\r\n            land2ResourceMineState[_landTokenId].mintedBalance[wood] = 0;\r\n        }\r\n\r\n        if (land2ResourceMineState[_landTokenId].mintedBalance[water] > 0) {\r\n            waterBalance = land2ResourceMineState[_landTokenId].mintedBalance[water];\r\n            IMintableERC20(water).mint(msg.sender, waterBalance);\r\n            land2ResourceMineState[_landTokenId].mintedBalance[water] = 0;\r\n        }\r\n\r\n        if (land2ResourceMineState[_landTokenId].mintedBalance[fire] > 0) {\r\n            fireBalance = land2ResourceMineState[_landTokenId].mintedBalance[fire];\r\n            IMintableERC20(fire).mint(msg.sender, fireBalance);\r\n            land2ResourceMineState[_landTokenId].mintedBalance[fire] = 0;\r\n        }\r\n\r\n        if (land2ResourceMineState[_landTokenId].mintedBalance[soil] > 0) {\r\n            soilBalance = land2ResourceMineState[_landTokenId].mintedBalance[soil];\r\n            IMintableERC20(soil).mint(msg.sender, soilBalance);\r\n            land2ResourceMineState[_landTokenId].mintedBalance[soil] = 0;\r\n        }\r\n\r\n        emit ResourceClaimed(msg.sender, _landTokenId, goldBalance, woodBalance, waterBalance, fireBalance, soilBalance);\r\n    }\r\n\r\n    // both for own _tokenId or hired one\r\n    function startMining(uint256 _tokenId, uint256 _landTokenId, address _resource) public {\r\n        ITokenUse tokenUse = ITokenUse(registry.addressOf(CONTRACT_TOKEN_USE));\r\n\r\n        tokenUse.addActivity(_tokenId, msg.sender, 0);\r\n\r\n        // require the permission from land owner;\r\n        require(msg.sender == ERC721(registry.addressOf(CONTRACT_OBJECT_OWNERSHIP)).ownerOf(_landTokenId), \"Must be the owner of the land\");\r\n\r\n        // make sure that _tokenId won't be used repeatedly\r\n        require(miner2Index[_tokenId].landTokenId == 0);\r\n\r\n        // update status!\r\n        mine(_landTokenId);\r\n\r\n        uint256 _index = land2ResourceMineState[_landTokenId].miners[_resource].length;\r\n\r\n        land2ResourceMineState[_landTokenId].totalMiners += 1;\r\n\r\n        if (land2ResourceMineState[_landTokenId].maxMiners == 0) {\r\n            land2ResourceMineState[_landTokenId].maxMiners = 5;\r\n        }\r\n\r\n        require(land2ResourceMineState[_landTokenId].totalMiners <= land2ResourceMineState[_landTokenId].maxMiners);\r\n\r\n        address miner = IInterstellarEncoder(registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)).getObjectAddress(_tokenId);\r\n        uint256 strength = IMinerObject(miner).strengthOf(_tokenId, _resource, _landTokenId);\r\n\r\n        land2ResourceMineState[_landTokenId].miners[_resource].push(_tokenId);\r\n        land2ResourceMineState[_landTokenId].totalMinerStrength[_resource] += strength;\r\n\r\n        miner2Index[_tokenId] = MinerStatus({\r\n            landTokenId : _landTokenId,\r\n            resource : _resource,\r\n            indexInResource : uint64(_index)\r\n            });\r\n\r\n        emit StartMining(_tokenId, _landTokenId, _resource, strength);\r\n\r\n    }\r\n\r\n    function batchStartMining(uint256[] _tokenIds, uint256[] _landTokenIds, address[] _resources) public {\r\n        require(_tokenIds.length == _landTokenIds.length && _landTokenIds.length == _resources.length, \"input error\");\r\n        uint length = _tokenIds.length;\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            startMining(_tokenIds[i], _landTokenIds[i], _resources[i]);\r\n        }\r\n\r\n    }\r\n\r\n    function batchClaimAllResource(uint256[] _landTokenIds) public {\r\n        uint length = _landTokenIds.length;\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            claimAllResource(_landTokenIds[i]);\r\n        }\r\n    }\r\n\r\n    // Only trigger from Token Activity.\r\n    function activityStopped(uint256 _tokenId) public auth {\r\n\r\n        _stopMining(_tokenId);\r\n    }\r\n\r\n    function stopMining(uint256 _tokenId) public {\r\n        ITokenUse(registry.addressOf(CONTRACT_TOKEN_USE)).removeActivity(_tokenId, msg.sender);\r\n    }\r\n\r\n    function _stopMining(uint256 _tokenId) internal {\r\n        // remove the miner from land2ResourceMineState;\r\n        uint64 minerIndex = miner2Index[_tokenId].indexInResource;\r\n        address resource = miner2Index[_tokenId].resource;\r\n        uint256 landTokenId = miner2Index[_tokenId].landTokenId;\r\n\r\n        // update status!\r\n        mine(landTokenId);\r\n\r\n        uint64 lastMinerIndex = uint64(land2ResourceMineState[landTokenId].miners[resource].length.sub(1));\r\n        uint256 lastMiner = land2ResourceMineState[landTokenId].miners[resource][lastMinerIndex];\r\n\r\n        land2ResourceMineState[landTokenId].miners[resource][minerIndex] = lastMiner;\r\n        land2ResourceMineState[landTokenId].miners[resource][lastMinerIndex] = 0;\r\n\r\n        land2ResourceMineState[landTokenId].miners[resource].length -= 1;\r\n        miner2Index[lastMiner].indexInResource = minerIndex;\r\n\r\n        land2ResourceMineState[landTokenId].totalMiners -= 1;\r\n\r\n        address miner = IInterstellarEncoder(registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)).getObjectAddress(_tokenId);\r\n        uint256 strength = IMinerObject(miner).strengthOf(_tokenId, resource, landTokenId);\r\n\r\n        // for backward compatibility\r\n        // if strength can fluctuate some time in the future\r\n        if (land2ResourceMineState[landTokenId].totalMinerStrength[resource] != 0) {\r\n            if (land2ResourceMineState[landTokenId].totalMinerStrength[resource] > strength) {\r\n                land2ResourceMineState[landTokenId].totalMinerStrength[resource] = land2ResourceMineState[landTokenId].totalMinerStrength[resource].sub(strength);\r\n            } else {\r\n                land2ResourceMineState[landTokenId].totalMinerStrength[resource] = 0;\r\n            }\r\n        }\r\n\r\n        if (land2ResourceMineState[landTokenId].totalMiners == 0) {\r\n            land2ResourceMineState[landTokenId].totalMinerStrength[resource] = 0;\r\n        }\r\n\r\n        delete miner2Index[_tokenId];\r\n\r\n        emit StopMining(_tokenId, landTokenId, resource, strength);\r\n    }\r\n\r\n    function getMinerOnLand(uint _landTokenId, address _resourceToken, uint _index) public view returns (uint256) {\r\n        return land2ResourceMineState[_landTokenId].miners[_resourceToken][_index];\r\n    }\r\n\r\n    function getTotalMiningStrength(uint _landTokenId, address _resourceToken) public view returns (uint256) {\r\n        return land2ResourceMineState[_landTokenId].totalMinerStrength[_resourceToken];\r\n    }\r\n\r\n    function availableResources(uint256 _landTokenId, address[5] _resourceTokens) public view returns (uint256, uint256, uint256, uint256, uint256) {\r\n\r\n        uint availableGold = _calculateMinedBalance(_landTokenId, _resourceTokens[0], now) + land2ResourceMineState[_landTokenId].mintedBalance[_resourceTokens[0]];\r\n        uint availableWood = _calculateMinedBalance(_landTokenId, _resourceTokens[1], now) + land2ResourceMineState[_landTokenId].mintedBalance[_resourceTokens[1]];\r\n        uint availableWater = _calculateMinedBalance(_landTokenId, _resourceTokens[2], now) + land2ResourceMineState[_landTokenId].mintedBalance[_resourceTokens[2]];\r\n        uint availableFire = _calculateMinedBalance(_landTokenId, _resourceTokens[3], now) + land2ResourceMineState[_landTokenId].mintedBalance[_resourceTokens[3]];\r\n        uint availableSoil = _calculateMinedBalance(_landTokenId, _resourceTokens[4], now) + land2ResourceMineState[_landTokenId].mintedBalance[_resourceTokens[4]];\r\n\r\n        return (availableGold, availableWood, availableWater, availableFire, availableSoil);\r\n    }\r\n\r\n    function mintedBalanceOnLand(uint256 _landTokenId, address _resourceToken) public view returns (uint256) {\r\n        return land2ResourceMineState[_landTokenId].mintedBalance[_resourceToken];\r\n    }\r\n\r\n    function landWorkingOn(uint256 _apostleTokenId) public view returns (uint256 landTokenId) {\r\n        landTokenId = miner2Index[_apostleTokenId].landTokenId;\r\n    }\r\n\r\n\r\n\r\n\r\n    function _updateMinerStrength(uint256 _apostleTokenId, bool _isStop) internal returns (uint256, uint256){\r\n        // require that this apostle\r\n        uint256 landTokenId = landWorkingOn(_apostleTokenId);\r\n        require(landTokenId != 0, \"this apostle is not mining.\");\r\n\r\n        address resource = miner2Index[_apostleTokenId].resource;\r\n\r\n        address miner = IInterstellarEncoder(registry.addressOf(CONTRACT_INTERSTELLAR_ENCODER)).getObjectAddress(_apostleTokenId);\r\n        uint256 strength = IMinerObject(miner).strengthOf(_apostleTokenId, resource, landTokenId);\r\n\r\n        mine(landTokenId);\r\n\r\n        if (_isStop) {\r\n            land2ResourceMineState[landTokenId].totalMinerStrength[resource] = land2ResourceMineState[landTokenId].totalMinerStrength[resource].sub(strength);\r\n        } else {\r\n            land2ResourceMineState[landTokenId].totalMinerStrength[resource] += strength;\r\n        }\r\n\r\n        return (landTokenId, strength);\r\n    }\r\n\r\n    // when a mirrorToken or a pet has tied to apostle\r\n    // we need to update status and remove this apostle from mining list first\r\n    // open authority to PetBase\r\n    // can only be called by PetBase\r\n    function updateMinerStrengthWhenStop(uint256 _apostleTokenId) public auth {\r\n        uint256 landTokenId;\r\n        uint256 strength;\r\n        (landTokenId, strength) = _updateMinerStrength(_apostleTokenId, true);\r\n        // _isStop == true - minus strength\r\n        // _isStop == false - add strength\r\n        emit UpdateMiningStrengthWhenStop(_apostleTokenId, landTokenId, strength);\r\n    }\r\n\r\n    function updateMinerStrengthWhenStart(uint256 _apostleTokenId) public auth {\r\n        uint256 landTokenId;\r\n        uint256 strength;\r\n        (landTokenId, strength) = _updateMinerStrength(_apostleTokenId, false);\r\n        // _isStop == true - minus strength\r\n        // _isStop == false - add strength\r\n        emit UpdateMiningStrengthWhenStart(_apostleTokenId, landTokenId, strength);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_USER_POINTS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resourceReleaseStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_apostleTokenId\",\"type\":\"uint256\"}],\"name\":\"updateMinerStrengthWhenStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_WATER_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_GOLD_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_RING_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_landTokenId\",\"type\":\"uint256\"},{\"name\":\"_resourceTokens\",\"type\":\"address[5]\"}],\"name\":\"availableResources\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SECONDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_AUCTION_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"stopMining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_apostleTokenId\",\"type\":\"uint256\"}],\"name\":\"landWorkingOn\",\"outputs\":[{\"name\":\"landTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_TOKEN_LOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landTokenId\",\"type\":\"uint256\"}],\"name\":\"mine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_KTON_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_landTokenId\",\"type\":\"uint256\"},{\"name\":\"_resource\",\"type\":\"address\"}],\"name\":\"startMining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_WOOD_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_FIRE_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"activityStopped\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"miner2Index\",\"outputs\":[{\"name\":\"landTokenId\",\"type\":\"uint256\"},{\"name\":\"resource\",\"type\":\"address\"},{\"name\":\"indexInResource\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_landTokenId\",\"type\":\"uint256\"},{\"name\":\"_resourceToken\",\"type\":\"address\"}],\"name\":\"mintedBalanceOnLand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_landTokenId\",\"type\":\"uint256\"},{\"name\":\"_resourceToken\",\"type\":\"address\"}],\"name\":\"getTotalMiningStrength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_LAND_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_landTokenId\",\"type\":\"uint256\"},{\"name\":\"_resourceToken\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getMinerOnLand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_INTERSTELLAR_ENCODER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_PET_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"attenPerDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_SOIL_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_resourceToken\",\"type\":\"address\"},{\"name\":\"_currentTime\",\"type\":\"uint256\"},{\"name\":\"_lastUpdateTime\",\"type\":\"uint256\"}],\"name\":\"_getMinableBalance\",\"outputs\":[{\"name\":\"minableBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_apostleTokenId\",\"type\":\"uint256\"}],\"name\":\"updateMinerStrengthWhenStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landTokenId\",\"type\":\"uint256\"}],\"name\":\"claimAllResource\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_resourceReleaseStartTime\",\"type\":\"uint256\"}],\"name\":\"initializeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_OBJECT_OWNERSHIP\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"land2ResourceMineState\",\"outputs\":[{\"name\":\"lastUpdateSpeedInSeconds\",\"type\":\"uint256\"},{\"name\":\"lastDestoryAttenInSeconds\",\"type\":\"uint256\"},{\"name\":\"industryIndex\",\"type\":\"uint256\"},{\"name\":\"lastUpdateTime\",\"type\":\"uint128\"},{\"name\":\"totalMiners\",\"type\":\"uint64\"},{\"name\":\"maxMiners\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_TOKEN_USE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landTokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchClaimAllResource\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ERC721_BRIDGE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_REVENUE_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_landTokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_resources\",\"type\":\"address[]\"}],\"name\":\"batchStartMining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_LAND_RESOURCE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_REFERER_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_resourceToken\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getReleaseSpeed\",\"outputs\":[{\"name\":\"currentSpeed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recoverAttenPerDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_TOKEN_OFFER_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_DIVIDENDS_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minerTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"landTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_resource\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"strength\",\"type\":\"uint256\"}],\"name\":\"StartMining\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minerTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"landTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_resource\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"strength\",\"type\":\"uint256\"}],\"name\":\"StopMining\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"landTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"goldBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"woodBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"waterBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fireBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"soilBalance\",\"type\":\"uint256\"}],\"name\":\"ResourceClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"apostleTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"landTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"strength\",\"type\":\"uint256\"}],\"name\":\"UpdateMiningStrengthWhenStop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"apostleTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"landTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"strength\",\"type\":\"uint256\"}],\"name\":\"UpdateMiningStrengthWhenStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"LandResourceV4","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a51e2fcbd42d7b43ca85b170b7fd66a95c529b76323ae655a3f328bf15b89ff5"}]}