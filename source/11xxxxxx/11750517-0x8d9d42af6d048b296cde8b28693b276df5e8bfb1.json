{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n// As described in https://eips.ethereum.org/EIPS/eip-20\\ninterface IERC20 {\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  function name() external view returns (string memory); // optional method - see eip spec\\n  function symbol() external view returns (string memory); // optional method - see eip spec\\n  function decimals() external view returns (uint8); // optional method - see eip spec\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address owner) external view returns (uint256);\\n  function transfer(address to, uint256 value) external returns (bool);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\\n  function approve(address spender, uint256 value) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n}\"},\"Owned.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\ncontract Owned {\\n\\n  address public owner = msg.sender;\\n\\n  event LogOwnershipTransferred(address indexed owner, address indexed newOwner);\\n\\n  modifier onlyOwner {\\n    require(msg.sender == owner, \\\"Only owner\\\");\\n    _;\\n  }\\n\\n  function setOwner(address _owner)\\n    external\\n    onlyOwner\\n  {\\n    require(_owner != address(0), \\\"Owner cannot be zero address\\\");\\n    emit LogOwnershipTransferred(owner, _owner);\\n    owner = _owner;\\n  }\\n}\"},\"ValidatorRegistration.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.5;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Owned.sol\\\";\\n\\n/**\\n * @title ValidatorRegistration\\n * @dev Implements managing AvN stake and fees\\n */\\ncontract ValidatorRegistration is Owned {\\n\\n  // specifies the maximum amount of stake per node\\n  uint public constant MAX_NODE_STAKE = 250000 ether;\\n  // specifies the number of nodes availible to stake\\n  uint8 public constant NUM_NODES = 10;\\n  // specifies the number of months fees will be generated for\\n  uint8 public constant NUM_MONTHS = 12;\\n\\n  // Data structure to represent each Aventus Node\\n  struct Node {\\n    // Amount deposited in stake for a node\\n    uint stake;\\n    // Fees associated with a node for each month\\n    Fee[NUM_MONTHS] fees;\\n    // Amount of stake associated with any particular staker\\n    mapping (address =\\u003e uint) stakerBalance;\\n  }\\n\\n  // Data structure to represent each month\\u0027s worth of fees for a node\\n  struct Fee {\\n    // Total fees remaining to be distributed\\n    uint balance;\\n    // Which stakers have already withdrawn their fees for the month\\n    mapping (address =\\u003e bool) isWithdrawn;\\n  }\\n\\n  // address for the AVT token contract\\n  IERC20 public avt;\\n  // sets whether stake deposits or withdrawals are active\\n  bool public isWithdrawStake;\\n  // stores each of the 10 nodes\\n  Node[NUM_NODES] public nodes;\\n\\n  /**\\n   * @dev Initilaise contract to point to AVT token.\\n   * @param _avt address of AVT token contract\\n   */\\n  constructor(IERC20 _avt) {\\n    avt = _avt;\\n    isWithdrawStake = false;\\n  }\\n\\n  /**\\n   * @dev Getter for the stake associated with a node\\n   * @param node the index of the node associated with the AVT\\n   */\\n  function getNodeStake(uint8 node)\\n    external\\n    view\\n    returns (uint)\\n  {\\n    return nodes[node].stake;\\n  }\\n\\n  /**\\n   * @dev Getter for the staker balance associated with a node\\n   * @param node the index of the node associated with the AVT\\n   * @param staker the address of the staker for which the balance is retrieved\\n   */\\n  function getStakerBalance(uint8 node, address staker)\\n    external\\n    view\\n    returns (uint)\\n  {\\n    return nodes[node].stakerBalance[staker];\\n  }\\n\\n  /**\\n   * @dev deposit AVT tokens for staking.\\n   * @param amount number of AVT tokens to be deposited as stake for a node\\n   * @param node the index of the node to associate the AVT stake with\\n   */\\n  function depositStakeAndAgreeToTermsAndConditions(uint amount, uint8 node)\\n    external\\n  {\\n    require(nodes[node].stake + amount \\u003c= MAX_NODE_STAKE, \\\"Balance being deposited is too much for specified bucket\\\");\\n\\n    nodes[node].stake += amount;\\n    nodes[node].stakerBalance[msg.sender] += amount;\\n\\n    require(avt.transferFrom(msg.sender, address(this), amount), \\\"Approved insufficient funds for deposit\\\");\\n  }\\n\\n  /**\\n   * @dev withdraw AVT tokens from staking. Only active after the 12 month period, manually set by owner.\\n   * @param amount number of AVT tokens to be withdrawn from stake for a node\\n   * @param node the index of the node associated with the AVT stake\\n   */\\n  function withdrawStake(uint amount, uint8 node)\\n    external\\n  {\\n    require(isWithdrawStake, \\\"Contract is not currently accepting withdrawals of stake\\\");\\n    require(nodes[node].stakerBalance[msg.sender] \\u003e= amount, \\\"Balance being withdrawn is too much for msg.sender\\\");\\n\\n    nodes[node].stake -= amount;\\n    nodes[node].stakerBalance[msg.sender] -= amount;\\n\\n    require(avt.transfer(msg.sender, amount), \\\"Insufficient contract AVT balance to withdraw stake\\\");\\n  }\\n\\n  /**\\n   * @dev deposit AVT fees associated with each node for each month. Anyone can deposit fees but likely will only be owner.\\n   * @param amount number of AVT tokens to be deposited as fees\\n   * @param node the index of the node having the fees deposited\\n   * @param month the month for which the fees are being deposited\\n   */\\n  function depositFees(uint amount, uint8 node, uint8 month)\\n    external\\n  {\\n    nodes[node].fees[month].balance += amount;\\n\\n    require(avt.transferFrom(msg.sender, address(this), amount), \\\"Approved insufficient funds for deposit\\\");\\n  }\\n\\n  /**\\n   * @dev withdraw AVT fees associated with each node for each month for a particular staker.\\n   * @param _node the index of the node from which fees are being withdrawn\\n   * @param month the month for which the fees are being withdrawn\\n   */\\n  function withdrawFees(uint8 _node, uint8 month)\\n    external\\n  {\\n    Node storage node = nodes[_node];\\n    Fee storage fee = node.fees[month];\\n\\n    require(!fee.isWithdrawn[msg.sender], \\\"Transaction sender is not owed any fees for specified node and month\\\");\\n\\n    // Safe for integer overflow. fee.balance is always \\u003c 100,000e18, staker balance is always \\u003c 250,000e18, node.stake is always 250,000e18.\\n    uint amount = fee.balance * node.stakerBalance[msg.sender] / node.stake;\\n\\n    // Safe from underflow\\n    require(amount \\u003e 0, \\\"No amount to be withdrawn\\\");\\n\\n    fee.balance -= amount;\\n    fee.isWithdrawn[msg.sender] = true;\\n\\n    require(avt.transfer(msg.sender, amount), \\\"Contract has insufficient funds for withdrawal\\\");\\n  }\\n\\n  /**\\n   * @dev Switch between (not) accepting withdrawals of stake.\\n   * Only owner can do this and will do so at the end of NUM_MONTHS to return stake.\\n   */\\n  function flipIsWithdrawStake()\\n    external\\n    onlyOwner\\n  {\\n    isWithdrawStake = !isWithdrawStake;\\n  }\\n\\n  /**\\n   * @dev Remove the balance of AVT associated with a staker.\\n   * @param staker the address of the staker\\n   * @param _node the index of the node\\n   */\\n  function removeStaker(address staker, uint8 _node)\\n    external\\n    onlyOwner\\n  {\\n    Node storage node = nodes[_node];\\n\\n    // Update total stake associated with a node\\n    node.stake -= node.stakerBalance[staker];\\n\\n    // Update staker avt\\n    node.stakerBalance[staker] = 0;\\n  }\\n\\n   /**\\n   * @dev Sends AVT associated with this contract to the dst address. Only owner can do this to get stake for nodes.\\n   * @param dst is the destination address where the stake should be sent\\n   */\\n  function drain(address dst)\\n    external\\n    onlyOwner\\n  {\\n    require(avt.transfer(dst, avt.balanceOf(address(this))));\\n  }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_avt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogOwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_NODE_STAKE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NUM_MONTHS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NUM_NODES\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"node\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"}],\"name\":\"depositFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"node\",\"type\":\"uint8\"}],\"name\":\"depositStakeAndAgreeToTermsAndConditions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"drain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipIsWithdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"node\",\"type\":\"uint8\"}],\"name\":\"getNodeStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"node\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWithdrawStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_node\",\"type\":\"uint8\"}],\"name\":\"removeStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_node\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"node\",\"type\":\"uint8\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ValidatorRegistration","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000000d88ed6e74bbfd96b831231638b66c05571e824f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5bf25e7c68d46bc84f21ce6b3503033c3d1b734c62c067639eed51656a2b6ad7"}]}