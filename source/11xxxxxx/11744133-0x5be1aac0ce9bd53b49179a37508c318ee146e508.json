{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\n\r\npragma abicoder v2;\r\npragma solidity >=0.7.6;\r\n\r\ninterface IStakePoolCreator {\r\n    function version() external returns (uint256);\r\n\r\n    function create() external returns (address);\r\n\r\n    function initialize(\r\n        address poolAddress,\r\n        address pair,\r\n        address rewardToken,\r\n        address timelock,\r\n        address stakePoolRewardFund,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IValueLiquidRouter {\r\n    struct Swap {\r\n        address pool;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 swapAmount; // tokenInAmount / tokenOutAmount\r\n        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\r\n        uint256 maxPrice;\r\n        bool isBPool;\r\n    }\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function controller() external view returns (address);\r\n\r\n    function formula() external view returns (address);\r\n\r\n    function WETH() external view returns (address);\r\n\r\n    function addLiquidity(\r\n        address pair,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address pair,\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForTokens(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        address tokenOut,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        address tokenIn,\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        address tokenOut,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external;\r\n\r\n    function addStakeLiquidity(\r\n        address stakePool,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addStakeLiquidityETH(\r\n        address stakePool,\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function multihopBatchSwapExactIn(\r\n        Swap[][] memory swapSequences,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 totalAmountIn,\r\n        uint256 minTotalAmountOut,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable returns (uint256 totalAmountOut);\r\n\r\n    function multihopBatchSwapExactOut(\r\n        Swap[][] memory swapSequences,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 maxTotalAmountIn,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable returns (uint256 totalAmountIn);\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint32 tokenWeightA,\r\n        uint32 swapFee,\r\n        address to,\r\n        uint8 flag\r\n    ) external returns (uint256 liquidity);\r\n\r\n    function createPairETH(\r\n        address token,\r\n        uint256 amountToken,\r\n        uint32 tokenWeight,\r\n        uint32 swapFee,\r\n        address to,\r\n        uint8 flag\r\n    ) external payable returns (uint256 liquidity);\r\n}\r\n\r\ninterface IValueLiquidFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint256);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function formula() external view returns (address);\r\n\r\n    function protocolFee() external view returns (uint256);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint32 tokenWeightA,\r\n        uint32 swapFee\r\n    ) external view returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function isPair(address) external view returns (bool);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint32 tokenWeightA,\r\n        uint32 swapFee\r\n    ) external returns (address pair);\r\n\r\n    function getWeightsAndSwapFee(address pair)\r\n        external\r\n        view\r\n        returns (\r\n            uint32 tokenWeight0,\r\n            uint32 tokenWeight1,\r\n            uint32 swapFee\r\n        );\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n\r\n    function setProtocolFee(uint256) external;\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n\r\ninterface IValueLiquidPair {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\r\n\r\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\r\n\r\n    function getSwapFee() external view returns (uint32);\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(\r\n        address,\r\n        address,\r\n        uint32,\r\n        uint32\r\n    ) external;\r\n}\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b > 0, \"ds-math-division-by-zero\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract TimeLock {\r\n    using SafeMath for uint256;\r\n    event NewAdmin(address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    event NewDelay(uint256 indexed newDelay);\r\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\r\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\r\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\r\n\r\n    uint256 public constant GRACE_PERIOD = 14 days;\r\n    uint256 public constant MINIMUM_DELAY = 1 days;\r\n    uint256 public constant MAXIMUM_DELAY = 30 days;\r\n    bool private _initialized;\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    uint256 public delay;\r\n    bool public admin_initialized;\r\n    mapping(bytes32 => bool) public queuedTransactions;\r\n\r\n    constructor() {\r\n        admin_initialized = false;\r\n        _initialized = false;\r\n    }\r\n\r\n    function initialize(address _admin, uint256 _delay) public {\r\n        require(_initialized == false, \"Timelock::constructor: Initialized must be false.\");\r\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = _delay;\r\n        admin = _admin;\r\n        _initialized = true;\r\n        emit NewAdmin(admin);\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function setDelay(uint256 _delay) public {\r\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\r\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = _delay;\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    function acceptAdmin() public {\r\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    function setPendingAdmin(address _pendingAdmin) public {\r\n        // allows one time setting of admin for deployment purposes\r\n        if (admin_initialized) {\r\n            require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\r\n        } else {\r\n            require(msg.sender == admin, \"Timelock::setPendingAdmin: First call must come from admin.\");\r\n            admin_initialized = true;\r\n        }\r\n        pendingAdmin = _pendingAdmin;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    function queueTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) public returns (bytes32) {\r\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\r\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) public {\r\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\r\n    }\r\n\r\n    function executeTransaction(\r\n        address target,\r\n        uint256 value,\r\n        string memory signature,\r\n        bytes memory data,\r\n        uint256 eta\r\n    ) public payable returns (bytes memory) {\r\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\r\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\r\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\r\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\r\n\r\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function getBlockTimestamp() internal view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n\r\ninterface IEpochController {\r\n    function epoch() external view returns (uint256);\r\n\r\n    function nextEpochPoint() external view returns (uint256);\r\n\r\n    function nextEpochLength() external view returns (uint256);\r\n\r\n    function nextEpochAllocatedReward(address _pool) external view returns (uint256);\r\n}\r\n\r\ninterface IStakePoolEpochReward {\r\n    event AllocateReward(uint256 blocktime, uint256 amount);\r\n    event Deposit(address indexed account, uint256 amount);\r\n    event PayRewardPool(\r\n        uint256 indexed poolId,\r\n        address indexed rewardToken,\r\n        address indexed account,\r\n        uint256 pendingReward,\r\n        uint256 rebaseAmount,\r\n        uint256 paidReward\r\n    );\r\n    event Withdraw(address indexed account, uint256 amount);\r\n\r\n    function version() external returns (uint256);\r\n\r\n    function pair() external returns (address);\r\n\r\n    function allowRecoverRewardToken(address _token) external view returns (bool);\r\n\r\n    function epoch() external view returns (uint256);\r\n\r\n    function nextEpochPoint() external view returns (uint256);\r\n\r\n    function nextEpochLength() external view returns (uint256);\r\n\r\n    function nextEpochAllocatedReward() external view returns (uint256);\r\n\r\n    function earned(address _account) external view returns (uint256);\r\n\r\n    function unlockWithdrawEpoch(address _account) external view returns (uint256);\r\n\r\n    function unlockRewardEpoch(address _account) external view returns (uint256);\r\n\r\n    function stake(uint256) external;\r\n\r\n    function stakeFor(address _account) external;\r\n\r\n    function withdraw(uint256) external;\r\n\r\n    function claimReward() external;\r\n\r\n    function emergencyWithdraw() external;\r\n\r\n    function setEpochController(address) external;\r\n\r\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external;\r\n\r\n    function allocateReward(uint256 _amount) external;\r\n\r\n    function removeLiquidity(\r\n        address provider,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address provider,\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address provider,\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountETH);\r\n}\r\n\r\ninterface IValueLiquidProvider {\r\n    function factory() external view returns (address);\r\n\r\n    function controller() external view returns (address);\r\n\r\n    function formula() external view returns (address);\r\n\r\n    function WETH() external view returns (address);\r\n\r\n    function removeLiquidity(\r\n        address pair,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address pair,\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address pair,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address pair,\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address pair,\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address pair,\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function stake(\r\n        address stakePool,\r\n        uint256 amount,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function stakeWithPermit(\r\n        address stakePool,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\ninterface IStakePoolController {\r\n    event MasterCreated(address indexed farm, address indexed pair, uint256 version, address timelock, address stakePoolRewardFund, uint256 totalStakePool);\r\n    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\r\n    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\r\n    event SetStakePoolCreator(address indexed contractAddress, uint256 verion);\r\n    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\r\n    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\r\n    event SetStakePoolVerifier(address indexed contractAddress, bool value);\r\n    event ChangeGovernance(address indexed governance);\r\n    event SetFeeCollector(address indexed feeCollector);\r\n    event SetFeeToken(address indexed token);\r\n    event SetFeeAmount(uint256 indexed amount);\r\n\r\n    function allStakePools(uint256) external view returns (address stakePool);\r\n\r\n    function isStakePool(address contractAddress) external view returns (bool);\r\n\r\n    function isStakePoolVerifier(address contractAddress) external view returns (bool);\r\n\r\n    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\r\n\r\n    function isWhitelistStakePool(address contractAddress) external view returns (int8);\r\n\r\n    function setStakePoolVerifier(address contractAddress, bool state) external;\r\n\r\n    function setWhitelistStakingFor(address contractAddress, bool state) external;\r\n\r\n    function setWhitelistStakePool(address contractAddress, int8 state) external;\r\n\r\n    function addStakePoolCreator(address contractAddress) external;\r\n\r\n    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\r\n\r\n    function isAllowEmergencyWithdrawStakePool(address _address) external view returns (bool);\r\n\r\n    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\r\n\r\n    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\r\n\r\n    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external;\r\n\r\n    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\r\n\r\n    function setEnableWhitelistRewardRebaser(bool value) external;\r\n\r\n    function setEnableWhitelistRewardMultiplier(bool value) external;\r\n\r\n    function allStakePoolsLength() external view returns (uint256);\r\n\r\n    function create(\r\n        uint256 version,\r\n        address pair,\r\n        address rewardToken,\r\n        uint256 rewardFundAmount,\r\n        uint256 delayTimeLock,\r\n        bytes calldata data,\r\n        uint8 flag\r\n    ) external returns (address);\r\n\r\n    function createPair(\r\n        uint256 version,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint32 tokenWeightA,\r\n        uint32 swapFee,\r\n        address rewardToken,\r\n        uint256 rewardFundAmount,\r\n        uint256 delayTimeLock,\r\n        bytes calldata poolRewardInfo,\r\n        uint8 flag\r\n    ) external returns (address);\r\n\r\n    function setGovernance(address) external;\r\n\r\n    function setFeeCollector(address _address) external;\r\n\r\n    function setFeeToken(address _token) external;\r\n\r\n    function setFeeAmount(uint256 _token) external;\r\n}\r\n\r\ninterface IStakePoolRewardRebaser {\r\n    function getRebaseAmount(address rewardToken, uint256 baseAmount) external view returns (uint256);\r\n}\r\n\r\ninterface IStakePoolRewardMultiplier {\r\n    function getRewardMultiplier(\r\n        uint256 _start,\r\n        uint256 _end,\r\n        uint256 _from,\r\n        uint256 _to,\r\n        uint256 _rewardPerBlock\r\n    ) external view returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IStakePoolRewardFund {\r\n    function initialize(address _stakePool, address _timelock) external;\r\n\r\n    function safeTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value\r\n    ) external;\r\n}\r\n\r\n// This implements BPool contract, and allows for generalized staking, yield farming (by epoch), and token distribution.\r\ncontract StakePoolEpochReward is IStakePoolEpochReward {\r\n    using SafeMath for uint256;\r\n    uint256 public override version;\r\n\r\n    /* ========== DATA STRUCTURES ========== */\r\n\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 lastSnapshotIndex;\r\n        uint256 rewardEarned;\r\n        uint256 epochTimerStart;\r\n    }\r\n\r\n    struct Snapshot {\r\n        uint256 time;\r\n        uint256 rewardReceived;\r\n        uint256 rewardPerShare;\r\n    }\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    address public epochController;\r\n    address public rewardToken;\r\n\r\n    uint256 public withdrawLockupEpochs;\r\n    uint256 public rewardLockupEpochs;\r\n\r\n    mapping(address => UserInfo) public userInfo;\r\n    Snapshot[] public snapshotHistory;\r\n\r\n    address public override pair;\r\n    address public rewardFund;\r\n    address public timelock;\r\n    address public controller;\r\n\r\n    uint256 public balance;\r\n    uint256 private _unlocked = 1;\r\n    bool private _initialized = false;\r\n\r\n    constructor(address _controller, uint256 _version) {\r\n        controller = _controller;\r\n        timelock = msg.sender;\r\n        version = _version;\r\n        Snapshot memory genesisSnapshot = Snapshot({time: block.number, rewardReceived: 0, rewardPerShare: 0});\r\n        snapshotHistory.push(genesisSnapshot);\r\n    }\r\n\r\n    modifier lock() {\r\n        require(_unlocked == 1, \"StakePoolEpochReward: LOCKED\");\r\n        _unlocked = 0;\r\n        _;\r\n        _unlocked = 1;\r\n    }\r\n\r\n    modifier onlyTimeLock() {\r\n        require(msg.sender == timelock, \"StakePoolEpochReward: !timelock\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyEpochController() {\r\n        require(msg.sender == epochController, \"StakePoolEpochReward: !epochController\");\r\n        _;\r\n    }\r\n\r\n    modifier updateReward(address _account) {\r\n        if (_account != address(0)) {\r\n            UserInfo storage user = userInfo[_account];\r\n            user.rewardEarned = earned(_account);\r\n            user.lastSnapshotIndex = latestSnapshotIndex();\r\n        }\r\n        _;\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(\r\n        address _pair,\r\n        address _rewardFund,\r\n        address _timelock,\r\n        address _epochController,\r\n        address _rewardToken,\r\n        uint256 _withdrawLockupEpochs,\r\n        uint256 _rewardLockupEpochs\r\n    ) external {\r\n        require(_initialized == false, \"StakePoolEpochReward: Initialize must be false.\");\r\n        pair = _pair;\r\n        rewardFund = _rewardFund;\r\n        timelock = _timelock;\r\n        withdrawLockupEpochs = _withdrawLockupEpochs;\r\n        rewardLockupEpochs = _rewardLockupEpochs;\r\n        epochController = _epochController;\r\n        rewardToken = _rewardToken;\r\n        _initialized = true;\r\n    }\r\n\r\n    /* ========== GOVERNANCE ========== */\r\n\r\n    function setEpochController(address _epochController) external override lock onlyTimeLock {\r\n        epochController = _epochController;\r\n    }\r\n\r\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external override lock onlyTimeLock {\r\n        require(_withdrawLockupEpochs >= _rewardLockupEpochs && _withdrawLockupEpochs <= 56, \"_withdrawLockupEpochs: out of range\"); // <= 2 week\r\n        withdrawLockupEpochs = _withdrawLockupEpochs;\r\n        rewardLockupEpochs = _rewardLockupEpochs;\r\n    }\r\n\r\n    function allocateReward(uint256 _amount) external override lock onlyEpochController {\r\n        require(_amount > 0, \"StakePoolEpochReward: Cannot allocate 0\");\r\n        uint256 _before = IERC20(rewardToken).balanceOf(address(rewardFund));\r\n        TransferHelper.safeTransferFrom(rewardToken, msg.sender, rewardFund, _amount);\r\n        if (balance > 0) {\r\n            uint256 _after = IERC20(rewardToken).balanceOf(address(rewardFund));\r\n            _amount = _after.sub(_before);\r\n\r\n            // Create & add new snapshot\r\n            uint256 _prevRPS = getLatestSnapshot().rewardPerShare;\r\n            uint256 _nextRPS = _prevRPS.add(_amount.mul(1e18).div(balance));\r\n\r\n            Snapshot memory _newSnapshot = Snapshot({time: block.number, rewardReceived: _amount, rewardPerShare: _nextRPS});\r\n            emit AllocateReward(block.number, _amount);\r\n            snapshotHistory.push(_newSnapshot);\r\n        }\r\n    }\r\n\r\n    function allowRecoverRewardToken(address _token) external view override returns (bool) {\r\n        if (rewardToken == _token) {\r\n            // do not allow to drain reward token if less than 1 months after pool ends\r\n            if (block.timestamp < (getLatestSnapshot().time + 7 days)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // =========== Epoch getters\r\n\r\n    function epoch() public view override returns (uint256) {\r\n        return IEpochController(epochController).epoch();\r\n    }\r\n\r\n    function nextEpochPoint() external view override returns (uint256) {\r\n        return IEpochController(epochController).nextEpochPoint();\r\n    }\r\n\r\n    function nextEpochLength() external view override returns (uint256) {\r\n        return IEpochController(epochController).nextEpochLength();\r\n    }\r\n\r\n    function nextEpochAllocatedReward() external view override returns (uint256) {\r\n        return IEpochController(epochController).nextEpochAllocatedReward(address(this));\r\n    }\r\n\r\n    // =========== Snapshot getters\r\n\r\n    function latestSnapshotIndex() public view returns (uint256) {\r\n        return snapshotHistory.length.sub(1);\r\n    }\r\n\r\n    function getLatestSnapshot() internal view returns (Snapshot memory) {\r\n        return snapshotHistory[latestSnapshotIndex()];\r\n    }\r\n\r\n    function getLastSnapshotIndexOf(address _account) public view returns (uint256) {\r\n        return userInfo[_account].lastSnapshotIndex;\r\n    }\r\n\r\n    function getLastSnapshotOf(address _account) internal view returns (Snapshot memory) {\r\n        return snapshotHistory[getLastSnapshotIndexOf(_account)];\r\n    }\r\n\r\n    // =========== _account getters\r\n\r\n    function rewardPerShare() public view returns (uint256) {\r\n        return getLatestSnapshot().rewardPerShare;\r\n    }\r\n\r\n    function earned(address _account) public view override returns (uint256) {\r\n        uint256 latestRPS = getLatestSnapshot().rewardPerShare;\r\n        uint256 storedRPS = getLastSnapshotOf(_account).rewardPerShare;\r\n\r\n        UserInfo memory user = userInfo[_account];\r\n        return user.amount.mul(latestRPS.sub(storedRPS)).div(1e18).add(user.rewardEarned);\r\n    }\r\n\r\n    function canWithdraw(address _account) external view returns (bool) {\r\n        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs) <= epoch();\r\n    }\r\n\r\n    function canClaimReward(address _account) external view returns (bool) {\r\n        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs) <= epoch();\r\n    }\r\n\r\n    function unlockWithdrawEpoch(address _account) public view override returns (uint256) {\r\n        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs);\r\n    }\r\n\r\n    function unlockRewardEpoch(address _account) public view override returns (uint256) {\r\n        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function stake(uint256 _amount) external override lock {\r\n        IValueLiquidPair(pair).transferFrom(msg.sender, address(this), _amount);\r\n        _stakeFor(msg.sender);\r\n    }\r\n\r\n    function stakeFor(address _account) external override lock {\r\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"StakePoolEpochReward: Invalid sender\");\r\n        _stakeFor(_account);\r\n    }\r\n\r\n    function _stakeFor(address _account) internal {\r\n        uint256 _amount = IValueLiquidPair(pair).balanceOf(address(this)).sub(balance);\r\n        require(_amount > 0, \"StakePoolEpochReward: Invalid balance\");\r\n        balance = balance.add(_amount);\r\n        UserInfo storage user = userInfo[_account];\r\n        user.epochTimerStart = epoch(); // reset timer\r\n        user.amount = user.amount.add(_amount);\r\n        emit Deposit(_account, _amount);\r\n    }\r\n\r\n    function removeStakeInternal(uint256 _amount) internal {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 _epoch = epoch();\r\n        require(user.epochTimerStart.add(withdrawLockupEpochs) <= _epoch, \"StakePoolEpochReward: still in withdraw lockup\");\r\n        require(user.amount >= _amount, \"StakePoolEpochReward: invalid withdraw amount\");\r\n        _claimReward(false);\r\n        balance = balance.sub(_amount);\r\n        user.epochTimerStart = _epoch; // reset timer\r\n        user.amount = user.amount.sub(_amount);\r\n    }\r\n\r\n    function withdraw(uint256 _amount) public override lock {\r\n        removeStakeInternal(_amount);\r\n        IValueLiquidPair(pair).transfer(msg.sender, _amount);\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    function exit() external {\r\n        withdraw(userInfo[msg.sender].amount);\r\n    }\r\n\r\n    function _claimReward(bool _lockChecked) internal updateReward(msg.sender) {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 _reward = user.rewardEarned;\r\n        if (_reward > 0) {\r\n            if (_lockChecked) {\r\n                uint256 _epoch = epoch();\r\n                require(user.epochTimerStart.add(rewardLockupEpochs) <= _epoch, \"StakePoolEpochReward: still in reward lockup\");\r\n                user.epochTimerStart = _epoch; // reset timer\r\n            }\r\n            user.rewardEarned = 0;\r\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\r\n            uint256 _rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\r\n            uint256 _paidAmount = _rewardBalance > _reward ? _reward : _rewardBalance;\r\n            IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, msg.sender, _paidAmount);\r\n            emit PayRewardPool(0, rewardToken, msg.sender, _reward, _reward, _paidAmount);\r\n        }\r\n    }\r\n\r\n    function claimReward() public override {\r\n        _claimReward(true);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw() external override lock {\r\n        require(IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), \"StakePoolEpochReward: Not allow emergencyWithdraw\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 amount = user.amount;\r\n        balance = balance.sub(amount);\r\n        user.amount = 0;\r\n        IValueLiquidPair(pair).transfer(msg.sender, amount);\r\n    }\r\n\r\n    function removeLiquidity(\r\n        address provider,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) public override lock returns (uint256 amountA, uint256 amountB) {\r\n        require(IStakePoolController(controller).isWhitelistStakingFor(provider), \"StakePoolEpochReward: Invalid provider\");\r\n        removeStakeInternal(liquidity);\r\n        IValueLiquidPair(pair).approve(provider, liquidity);\r\n        emit Withdraw(msg.sender, liquidity);\r\n        (amountA, amountB) = IValueLiquidProvider(provider).removeLiquidity(address(pair), tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n\r\n    function removeLiquidityETH(\r\n        address provider,\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external override lock returns (uint256 amountToken, uint256 amountETH) {\r\n        require(IStakePoolController(controller).isWhitelistStakingFor(provider), \"StakePoolEpochReward: Invalid provider\");\r\n        removeStakeInternal(liquidity);\r\n        IValueLiquidPair(pair).approve(provider, liquidity);\r\n        emit Withdraw(msg.sender, liquidity);\r\n        (amountToken, amountETH) = IValueLiquidProvider(provider).removeLiquidityETH(\r\n            address(pair),\r\n            token,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            to,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address provider,\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external override lock returns (uint256 amountETH) {\r\n        require(IStakePoolController(controller).isWhitelistStakingFor(provider), \"StakePoolEpochReward: Invalid provider\");\r\n        removeStakeInternal(liquidity);\r\n        IValueLiquidPair(pair).approve(provider, liquidity);\r\n        emit Withdraw(msg.sender, liquidity);\r\n        amountETH = IValueLiquidProvider(provider).removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            address(pair),\r\n            token,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            to,\r\n            deadline\r\n        );\r\n    }\r\n}\r\n\r\ncontract StakePoolEpochRewardCreator is IStakePoolCreator {\r\n    uint256 public override version = 4001;\r\n    struct PoolRewardInfo {\r\n        address epochController;\r\n        uint256 withdrawLockupEpochs;\r\n        uint256 rewardLockupEpochs;\r\n    }\r\n\r\n    function create() external override returns (address) {\r\n        StakePoolEpochReward pool = new StakePoolEpochReward(msg.sender, version);\r\n        return address(pool);\r\n    }\r\n\r\n    function initialize(\r\n        address poolAddress,\r\n        address pair,\r\n        address rewardToken,\r\n        address timelock,\r\n        address stakePoolRewardFund,\r\n        bytes calldata data\r\n    ) external override {\r\n        StakePoolEpochReward pool = StakePoolEpochReward(poolAddress);\r\n\r\n        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\r\n        pool.initialize(\r\n            pair,\r\n            address(stakePoolRewardFund),\r\n            address(timelock),\r\n            poolRewardInfo.epochController,\r\n            rewardToken,\r\n            poolRewardInfo.withdrawLockupEpochs,\r\n            poolRewardInfo.rewardLockupEpochs\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"timelock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakePoolRewardFund\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StakePoolEpochRewardCreator","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://776c81b9054a6b3aef772f8011d2364fe31a737657f177ba9bd2050f360087d0"}]}