{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOPoolLib.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IACOPoolStrategy.sol\\\";\\r\\nimport \\\"./IACOFactory.sol\\\";\\r\\nimport \\\"./IACOToken.sol\\\";\\r\\nimport \\\"./ILendingPool.sol\\\";\\r\\n\\r\\nlibrary ACOPoolLib {\\r\\n\\tusing SafeMath for uint256;\\r\\n\\t\\r\\n\\tstruct OpenPositionData {\\r\\n        uint256 underlyingPrice;\\r\\n        uint256 baseVolatility;\\r\\n        uint256 underlyingPriceAdjustPercentage;\\r\\n        uint256 underlyingPrecision;\\r\\n        address strategy;\\r\\n        address acoFactory;\\r\\n\\t    address acoToken;\\r\\n\\t}\\r\\n\\t\\r\\n\\tstruct QuoteData {\\r\\n\\t\\tbool isCall;\\r\\n        uint256 tokenAmount; \\r\\n\\t\\taddress underlying;\\r\\n\\t\\taddress strikeAsset;\\r\\n\\t\\tuint256 strikePrice; \\r\\n\\t\\tuint256 expiryTime;\\r\\n\\t\\taddress lendingToken;\\r\\n\\t\\taddress strategy;\\r\\n\\t\\tuint256 baseVolatility;\\r\\n\\t\\tuint256 fee;\\r\\n\\t\\tuint256 minExpiration;\\r\\n\\t\\tuint256 maxExpiration;\\r\\n\\t\\tuint256 tolerancePriceBelow;\\r\\n\\t\\tuint256 tolerancePriceAbove;\\r\\n\\t\\tuint256 underlyingPrice;\\r\\n\\t\\tuint256 underlyingPrecision;\\r\\n\\t}\\r\\n\\t\\r\\n\\tstruct OpenPositionExtraData {\\r\\n        bool isCall;\\r\\n        uint256 strikePrice; \\r\\n        uint256 expiryTime;\\r\\n        uint256 tokenAmount;\\r\\n\\t    address underlying;\\r\\n        address strikeAsset; \\r\\n\\t}\\r\\n\\t\\r\\n\\tuint256 public constant PERCENTAGE_PRECISION = 100000;\\r\\n\\t\\r\\n\\tfunction name(address underlying, address strikeAsset, bool isCall) public view returns(string memory) {\\r\\n        return string(abi.encodePacked(\\r\\n            \\\"ACO POOL WRITE \\\",\\r\\n            _getAssetSymbol(underlying),\\r\\n            \\\"-\\\",\\r\\n            _getAssetSymbol(strikeAsset),\\r\\n            \\\"-\\\",\\r\\n            (isCall ? \\\"CALL\\\" : \\\"PUT\\\")\\r\\n        ));\\r\\n    }\\r\\n    \\r\\n\\tfunction acoStrikePriceIsValid(\\r\\n\\t\\tuint256 tolerancePriceBelow,\\r\\n\\t\\tuint256 tolerancePriceAbove,\\r\\n\\t\\tuint256 strikePrice, \\r\\n\\t\\tuint256 price\\r\\n\\t) public pure returns(bool) {\\r\\n\\t\\treturn (tolerancePriceBelow == 0 \\u0026\\u0026 tolerancePriceAbove == 0) ||\\r\\n\\t\\t\\t(tolerancePriceBelow == 0 \\u0026\\u0026 strikePrice \\u003e price.mul(PERCENTAGE_PRECISION.add(tolerancePriceAbove)).div(PERCENTAGE_PRECISION)) ||\\r\\n\\t\\t\\t(tolerancePriceAbove == 0 \\u0026\\u0026 strikePrice \\u003c price.mul(PERCENTAGE_PRECISION.sub(tolerancePriceBelow)).div(PERCENTAGE_PRECISION)) ||\\r\\n\\t\\t\\t(strikePrice \\u003e= price.mul(PERCENTAGE_PRECISION.sub(tolerancePriceBelow)).div(PERCENTAGE_PRECISION) \\u0026\\u0026 \\r\\n\\t\\t\\t strikePrice \\u003c= price.mul(PERCENTAGE_PRECISION.add(tolerancePriceAbove)).div(PERCENTAGE_PRECISION));\\r\\n\\t}\\r\\n\\r\\n\\tfunction acoExpirationIsValid(uint256 acoExpiryTime, uint256 minExpiration, uint256 maxExpiration) public view returns(bool) {\\r\\n\\t\\treturn acoExpiryTime \\u003e= block.timestamp.add(minExpiration) \\u0026\\u0026 acoExpiryTime \\u003c= block.timestamp.add(maxExpiration);\\r\\n\\t}\\r\\n\\r\\n    function getBaseAssetsWithdrawWithLocked(\\r\\n        uint256 shares,\\r\\n        address underlying,\\r\\n        address strikeAsset,\\r\\n        bool isCall,\\r\\n        uint256 totalSupply,\\r\\n        address lendingToken\\r\\n    ) public view returns(\\r\\n        uint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n    ) {\\r\\n\\t\\tuint256 underlyingBalance = _getPoolBalanceOf(underlying);\\r\\n\\t\\tuint256 strikeAssetBalance;\\r\\n\\t\\tif (isCall) {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\\r\\n\\t\\t} else {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(lendingToken);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\\r\\n\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\\r\\n    }\\r\\n    \\r\\n    function getBaseWithdrawNoLockedData(\\r\\n        uint256 shares,\\r\\n        uint256 totalSupply,\\r\\n        bool isCall,\\r\\n        uint256 underlyingBalance, \\r\\n        uint256 strikeAssetBalance, \\r\\n        uint256 collateralBalance, \\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) public pure returns(\\r\\n        uint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\tbool isPossible\\r\\n    ) {\\r\\n\\t\\tuint256 collateralAmount = shares.mul(collateralBalance).div(totalSupply);\\r\\n\\t\\t\\r\\n\\t\\tif (isCall) {\\r\\n\\t\\t\\tunderlyingWithdrawn = collateralAmount;\\r\\n\\t\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\\r\\n\\t\\t\\tisPossible = (collateralAmount \\u003c= underlyingBalance.add(collateralLockedRedeemable));\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tstrikeAssetWithdrawn = collateralAmount;\\r\\n\\t\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\\r\\n\\t\\t\\tisPossible = (collateralAmount \\u003c= strikeAssetBalance.add(collateralLockedRedeemable));\\r\\n\\t\\t}\\r\\n    }\\r\\n    \\r\\n    function getAmountToLockedWithdraw(\\r\\n        uint256 shares, \\r\\n        uint256 totalSupply, \\r\\n        address lendingToken,\\r\\n        address underlying, \\r\\n        address strikeAsset, \\r\\n        bool isCall\\r\\n    ) public view returns(\\r\\n        uint256 underlyingWithdrawn, \\r\\n        uint256 strikeAssetWithdrawn\\r\\n    ) {\\r\\n\\t\\tuint256 underlyingBalance = _getPoolBalanceOf(underlying);\\r\\n\\t\\tuint256 strikeAssetBalance;\\r\\n\\t\\tif (isCall) {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\\r\\n\\t\\t} else {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(lendingToken);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\\r\\n\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\\r\\n    }\\r\\n    \\r\\n    function getAmountToNoLockedWithdraw(\\r\\n        uint256 shares, \\r\\n        uint256 totalSupply,\\r\\n        uint256 underlyingBalance, \\r\\n        uint256 strikeAssetBalance,\\r\\n        uint256 collateralBalance,\\r\\n        uint256 minCollateral,\\r\\n        bool isCall\\r\\n    ) public pure returns(\\r\\n        uint256 underlyingWithdrawn, \\r\\n        uint256 strikeAssetWithdrawn\\r\\n    ) {\\r\\n\\t\\tuint256 collateralAmount = shares.mul(collateralBalance).div(totalSupply);\\r\\n\\t\\trequire(collateralAmount \\u003e= minCollateral, \\\"ACOPoolLib: The minimum collateral was not satisfied\\\");\\r\\n\\r\\n        if (isCall) {\\r\\n\\t\\t\\trequire(collateralAmount \\u003c= underlyingBalance, \\\"ACOPoolLib: Collateral balance is not sufficient\\\");\\r\\n\\t\\t\\tunderlyingWithdrawn = collateralAmount;\\r\\n\\t\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\\r\\n        } else {\\r\\n\\t\\t\\trequire(collateralAmount \\u003c= strikeAssetBalance, \\\"ACOPoolLib: Collateral balance is not sufficient\\\");\\r\\n\\t\\t\\tstrikeAssetWithdrawn = collateralAmount;\\r\\n\\t\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\\r\\n\\t\\t}\\r\\n    }\\r\\n    \\r\\n\\tfunction getBaseCollateralData(\\r\\n\\t    address lendingToken,\\r\\n\\t    address underlying,\\r\\n\\t    address strikeAsset,\\r\\n\\t    bool isCall,\\r\\n\\t    uint256 underlyingPrice,\\r\\n\\t    uint256 underlyingPriceAdjustPercentage,\\r\\n\\t    uint256 underlyingPrecision,\\r\\n\\t    bool isDeposit\\r\\n    ) public view returns(\\r\\n        uint256 underlyingBalance, \\r\\n        uint256 strikeAssetBalance, \\r\\n        uint256 collateralBalance\\r\\n    ) {\\r\\n\\t\\tunderlyingBalance = _getPoolBalanceOf(underlying);\\r\\n\\t\\t\\r\\n\\t\\tif (isCall) {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\\r\\n\\t\\t\\tcollateralBalance = underlyingBalance;\\r\\n\\t\\t\\tif (isDeposit \\u0026\\u0026 strikeAssetBalance \\u003e 0) {\\r\\n\\t\\t\\t\\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, underlyingPriceAdjustPercentage, false); \\r\\n\\t\\t\\t\\tcollateralBalance = collateralBalance.add(strikeAssetBalance.mul(underlyingPrecision).div(priceAdjusted));\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t    strikeAssetBalance = _getPoolBalanceOf(lendingToken);\\r\\n\\t\\t\\tcollateralBalance = strikeAssetBalance;\\r\\n\\t\\t\\tif (isDeposit \\u0026\\u0026 underlyingBalance \\u003e 0) {\\r\\n\\t\\t\\t\\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, underlyingPriceAdjustPercentage, true); \\r\\n\\t\\t\\t\\tcollateralBalance = collateralBalance.add(underlyingBalance.mul(priceAdjusted).div(underlyingPrecision));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction getOpenPositionCollateralBalance(OpenPositionData memory data) public view returns(\\r\\n        uint256 collateralLocked, \\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n        OpenPositionExtraData memory extraData = _getOpenPositionCollateralExtraData(data.acoToken, data.acoFactory);\\r\\n        (collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _getOpenPositionCollateralBalance(data, extraData);\\r\\n    }\\r\\n    \\r\\n    function quote(QuoteData memory data) public view returns(\\r\\n        uint256 swapPrice, \\r\\n        uint256 protocolFee, \\r\\n        uint256 volatility, \\r\\n        uint256 collateralAmount\\r\\n    ) {\\r\\n        require(data.expiryTime \\u003e block.timestamp, \\\"ACOPoolLib: ACO token expired\\\");\\r\\n        require(acoExpirationIsValid(data.expiryTime, data.minExpiration, data.maxExpiration), \\\"ACOPoolLib: Invalid ACO token expiration\\\");\\r\\n\\t\\trequire(acoStrikePriceIsValid(data.tolerancePriceBelow, data.tolerancePriceAbove, data.strikePrice, data.underlyingPrice), \\\"ACOPoolLib: Invalid ACO token strike price\\\");\\r\\n\\r\\n        uint256 collateralAvailable;\\r\\n        (collateralAmount, collateralAvailable) = _getOrderSizeData(data.tokenAmount, data.underlying, data.isCall, data.strikePrice, data.lendingToken, data.underlyingPrecision);\\r\\n        uint256 calcPrice;\\r\\n        (calcPrice, volatility) = _strategyQuote(data.strategy, data.underlying, data.strikeAsset, data.isCall, data.strikePrice, data.expiryTime, data.underlyingPrice, data.baseVolatility, collateralAmount, collateralAvailable);\\r\\n        (swapPrice, protocolFee) = _setSwapPriceAndFee(calcPrice, data.tokenAmount, data.fee, data.underlyingPrecision);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function _getCollateralAmount(\\r\\n\\t\\tuint256 tokenAmount,\\r\\n\\t\\tuint256 strikePrice,\\r\\n\\t\\tbool isCall,\\r\\n\\t\\tuint256 underlyingPrecision\\r\\n\\t) private pure returns(uint256) {\\r\\n        if (isCall) {\\r\\n            return tokenAmount;\\r\\n        } else if (tokenAmount \\u003e 0) {\\r\\n            return tokenAmount.mul(strikePrice).div(underlyingPrecision);\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _getOrderSizeData(\\r\\n        uint256 tokenAmount,\\r\\n        address underlying,\\r\\n        bool isCall,\\r\\n        uint256 strikePrice,\\r\\n        address lendingToken,\\r\\n        uint256 underlyingPrecision\\r\\n    ) private view returns(\\r\\n        uint256 collateralAmount, \\r\\n        uint256 collateralAvailable\\r\\n    ) {\\r\\n        if (isCall) {\\r\\n            collateralAvailable = _getPoolBalanceOf(underlying);\\r\\n            collateralAmount = tokenAmount; \\r\\n        } else {\\r\\n            collateralAvailable = _getPoolBalanceOf(lendingToken);\\r\\n            collateralAmount = _getCollateralAmount(tokenAmount, strikePrice, isCall, underlyingPrecision);\\r\\n            require(collateralAmount \\u003e 0, \\\"ACOPoolLib: The token amount is too small\\\");\\r\\n        }\\r\\n        require(collateralAmount \\u003c= collateralAvailable, \\\"ACOPoolLib: Insufficient liquidity\\\");\\r\\n    }\\r\\n    \\r\\n\\tfunction _strategyQuote(\\r\\n        address strategy,\\r\\n\\t\\taddress underlying,\\r\\n\\t\\taddress strikeAsset,\\r\\n\\t\\tbool isCall,\\r\\n\\t\\tuint256 strikePrice,\\r\\n        uint256 expiryTime,\\r\\n        uint256 underlyingPrice,\\r\\n\\t\\tuint256 baseVolatility,\\r\\n        uint256 collateralAmount,\\r\\n        uint256 collateralAvailable\\r\\n    ) private view returns(uint256 swapPrice, uint256 volatility) {\\r\\n        (swapPrice, volatility) = IACOPoolStrategy(strategy).quote(IACOPoolStrategy.OptionQuote(\\r\\n\\t\\t\\tunderlyingPrice,\\r\\n            underlying, \\r\\n            strikeAsset, \\r\\n            isCall, \\r\\n            strikePrice, \\r\\n            expiryTime, \\r\\n            baseVolatility, \\r\\n            collateralAmount, \\r\\n            collateralAvailable\\r\\n        ));\\r\\n    }\\r\\n    \\r\\n    function _setSwapPriceAndFee(\\r\\n        uint256 calcPrice, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 fee,\\r\\n        uint256 underlyingPrecision\\r\\n    ) private pure returns(uint256 swapPrice, uint256 protocolFee) {\\r\\n        \\r\\n        swapPrice = calcPrice.mul(tokenAmount).div(underlyingPrecision);\\r\\n        \\r\\n        if (fee \\u003e 0) {\\r\\n            protocolFee = swapPrice.mul(fee).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t\\tswapPrice = swapPrice.add(protocolFee);\\r\\n        }\\r\\n        require(swapPrice \\u003e 0, \\\"ACOPoolLib: Invalid quoted price\\\");\\r\\n    }\\r\\n    \\r\\n    function _getOpenPositionCollateralExtraData(address acoToken, address acoFactory) private view returns(OpenPositionExtraData memory extraData) {\\r\\n        (address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime) = IACOFactory(acoFactory).acoTokenData(acoToken);\\r\\n        uint256 tokenAmount = IACOToken(acoToken).currentCollateralizedTokens(address(this));\\r\\n        extraData = OpenPositionExtraData(isCall, strikePrice, expiryTime, tokenAmount, underlying, strikeAsset);\\r\\n    }\\r\\n    \\r\\n\\tfunction _getOpenPositionCollateralBalance(\\r\\n\\t\\tOpenPositionData memory data,\\r\\n\\t\\tOpenPositionExtraData memory extraData\\r\\n\\t) private view returns(\\r\\n\\t    uint256 collateralLocked, \\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n        collateralLocked = _getCollateralAmount(extraData.tokenAmount, extraData.strikePrice, extraData.isCall, data.underlyingPrecision);\\r\\n        \\r\\n        if (extraData.expiryTime \\u003e block.timestamp) {\\r\\n    \\t\\t(uint256 price,) = _strategyQuote(data.strategy, extraData.underlying, extraData.strikeAsset, extraData.isCall, extraData.strikePrice, extraData.expiryTime, data.underlyingPrice, data.baseVolatility, 0, 1);\\r\\n    \\t\\tif (extraData.isCall) {\\r\\n    \\t\\t\\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(data.underlyingPrice, data.underlyingPriceAdjustPercentage, false); \\r\\n    \\t\\t\\tcollateralOnOpenPosition = price.mul(extraData.tokenAmount).div(priceAdjusted);\\r\\n    \\t\\t} else {\\r\\n    \\t\\t\\tcollateralOnOpenPosition = price.mul(extraData.tokenAmount).div(data.underlyingPrecision);\\r\\n    \\t\\t}\\r\\n        } else {\\r\\n            collateralLockedRedeemable = collateralLocked;\\r\\n        }\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction _getUnderlyingPriceAdjusted(uint256 underlyingPrice, uint256 underlyingPriceAdjustPercentage, bool isMaximum) private pure returns(uint256) {\\r\\n\\t\\tif (isMaximum) {\\r\\n\\t\\t\\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.add(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.sub(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t}\\r\\n    }\\r\\n    \\r\\n    function _getPoolBalanceOf(address asset) private view returns(uint256) {\\r\\n        if (asset == address(0)) {\\r\\n            return address(this).balance;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, address(this)));\\r\\n            require(success, \\\"ACOPoolLib::_getAssetBalanceOf\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _getAssetSymbol(address asset) private view returns(string memory) {\\r\\n        if (asset == address(0)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n            require(success, \\\"ACOPoolLib::_getAssetSymbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n}\"},\"IACOFactory.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOFactory {\\r\\n\\tfunction init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) external;\\r\\n    function acoFee() external view returns(uint256);\\r\\n    function factoryAdmin() external view returns(address);\\r\\n    function acoTokenImplementation() external view returns(address);\\r\\n    function acoFeeDestination() external view returns(address);\\r\\n    function acoTokenData(address acoToken) external view returns(address, address, bool, uint256, uint256);\\r\\n    function creators(address acoToken) external view returns(address);\\r\\n    function createAcoToken(address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime, uint256 maxExercisedAccounts) external returns(address);\\r\\n    function setFactoryAdmin(address newFactoryAdmin) external;\\r\\n    function setAcoTokenImplementation(address newAcoTokenImplementation) external;\\r\\n    function setAcoFee(uint256 newAcoFee) external;\\r\\n    function setAcoFeeDestination(address newAcoFeeDestination) external;\\r\\n}\"},\"IACOPoolStrategy.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IACOPoolStrategy {\\r\\n    \\r\\n    struct OptionQuote {\\r\\n        uint256 underlyingPrice;\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCallOption;\\r\\n        uint256 strikePrice; \\r\\n        uint256 expiryTime;\\r\\n        uint256 baseVolatility;\\r\\n        uint256 collateralOrderAmount;\\r\\n        uint256 collateralAvailable;\\r\\n    }\\r\\n\\r\\n    function quote(OptionQuote calldata quoteData) external view returns(uint256 optionPrice, uint256 volatility);\\r\\n}\"},\"IACOToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IACOToken is IERC20 {\\r\\n\\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function underlying() external view returns (address);\\r\\n    function strikeAsset() external view returns (address);\\r\\n    function feeDestination() external view returns (address);\\r\\n    function isCall() external view returns (bool);\\r\\n    function strikePrice() external view returns (uint256);\\r\\n    function expiryTime() external view returns (uint256);\\r\\n    function totalCollateral() external view returns (uint256);\\r\\n    function acoFee() external view returns (uint256);\\r\\n\\tfunction maxExercisedAccounts() external view returns (uint256);\\r\\n    function underlyingSymbol() external view returns (string memory);\\r\\n    function strikeAssetSymbol() external view returns (string memory);\\r\\n    function underlyingDecimals() external view returns (uint8);\\r\\n    function strikeAssetDecimals() external view returns (uint8);\\r\\n    function currentCollateral(address account) external view returns(uint256);\\r\\n    function unassignableCollateral(address account) external view returns(uint256);\\r\\n    function assignableCollateral(address account) external view returns(uint256);\\r\\n    function currentCollateralizedTokens(address account) external view returns(uint256);\\r\\n    function unassignableTokens(address account) external view returns(uint256);\\r\\n    function assignableTokens(address account) external view returns(uint256);\\r\\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\\r\\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\\r\\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\\r\\n    function numberOfAccountsWithCollateral() external view returns(uint256);\\r\\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\\r\\n    function collateral() external view returns(address);\\r\\n    function mintPayable() external payable returns(uint256);\\r\\n    function mintToPayable(address account) external payable returns(uint256);\\r\\n    function mint(uint256 collateralAmount) external returns(uint256);\\r\\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\\r\\n    function burn(uint256 tokenAmount) external returns(uint256);\\r\\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\\r\\n    function redeem() external returns(uint256);\\r\\n    function redeemFrom(address account) external returns(uint256);\\r\\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function transferCollateralOwnership(address recipient, uint256 tokenCollateralizedAmount) external;\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"ILendingPool.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nlibrary DataTypes {\\r\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\r\\n  struct ReserveData {\\r\\n    //stores the reserve configuration\\r\\n    ReserveConfigurationMap configuration;\\r\\n    //the liquidity index. Expressed in ray\\r\\n    uint128 liquidityIndex;\\r\\n    //variable borrow index. Expressed in ray\\r\\n    uint128 variableBorrowIndex;\\r\\n    //the current supply rate. Expressed in ray\\r\\n    uint128 currentLiquidityRate;\\r\\n    //the current variable borrow rate. Expressed in ray\\r\\n    uint128 currentVariableBorrowRate;\\r\\n    //the current stable borrow rate. Expressed in ray\\r\\n    uint128 currentStableBorrowRate;\\r\\n    uint40 lastUpdateTimestamp;\\r\\n    //tokens addresses\\r\\n    address aTokenAddress;\\r\\n    address stableDebtTokenAddress;\\r\\n    address variableDebtTokenAddress;\\r\\n    //address of the interest rate strategy\\r\\n    address interestRateStrategyAddress;\\r\\n    //the id of the reserve. Represents the position in the list of the active reserves\\r\\n    uint8 id;\\r\\n  }\\r\\n\\r\\n  struct ReserveConfigurationMap {\\r\\n    //bit 0-15: LTV\\r\\n    //bit 16-31: Liq. threshold\\r\\n    //bit 32-47: Liq. bonus\\r\\n    //bit 48-55: Decimals\\r\\n    //bit 56: Reserve is active\\r\\n    //bit 57: reserve is frozen\\r\\n    //bit 58: borrowing is enabled\\r\\n    //bit 59: stable rate borrowing enabled\\r\\n    //bit 60-63: reserved\\r\\n    //bit 64-79: reserve factor\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  struct UserConfigurationMap {\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title LendingPoolAddressesProvider contract\\r\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\r\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\r\\n * - Owned by the Aave Governance\\r\\n * @author Aave\\r\\n **/\\r\\ninterface ILendingPoolAddressesProvider {\\r\\n  event MarketIdSet(string newMarketId);\\r\\n  event LendingPoolUpdated(address indexed newAddress);\\r\\n  event ConfigurationAdminUpdated(address indexed newAddress);\\r\\n  event EmergencyAdminUpdated(address indexed newAddress);\\r\\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\\r\\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\\r\\n  event PriceOracleUpdated(address indexed newAddress);\\r\\n  event LendingRateOracleUpdated(address indexed newAddress);\\r\\n  event ProxyCreated(bytes32 id, address indexed newAddress);\\r\\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\r\\n\\r\\n  function getMarketId() external view returns (string memory);\\r\\n\\r\\n  function setMarketId(string calldata marketId) external;\\r\\n\\r\\n  function setAddress(bytes32 id, address newAddress) external;\\r\\n\\r\\n  function setAddressAsProxy(bytes32 id, address impl) external;\\r\\n\\r\\n  function getAddress(bytes32 id) external view returns (address);\\r\\n\\r\\n  function getLendingPool() external view returns (address);\\r\\n\\r\\n  function setLendingPoolImpl(address pool) external;\\r\\n\\r\\n  function getLendingPoolConfigurator() external view returns (address);\\r\\n\\r\\n  function setLendingPoolConfiguratorImpl(address configurator) external;\\r\\n\\r\\n  function getLendingPoolCollateralManager() external view returns (address);\\r\\n\\r\\n  function setLendingPoolCollateralManager(address manager) external;\\r\\n\\r\\n  function getPoolAdmin() external view returns (address);\\r\\n\\r\\n  function setPoolAdmin(address admin) external;\\r\\n\\r\\n  function getEmergencyAdmin() external view returns (address);\\r\\n\\r\\n  function setEmergencyAdmin(address admin) external;\\r\\n\\r\\n  function getPriceOracle() external view returns (address);\\r\\n\\r\\n  function setPriceOracle(address priceOracle) external;\\r\\n\\r\\n  function getLendingRateOracle() external view returns (address);\\r\\n\\r\\n  function setLendingRateOracle(address lendingRateOracle) external;\\r\\n}\\r\\n\\r\\n\\r\\ninterface ILendingPool {\\r\\n  /**\\r\\n   * @dev Emitted on deposit()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address initiating the deposit\\r\\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\\r\\n   * @param amount The amount deposited\\r\\n   * @param referral The referral code used\\r\\n   **/\\r\\n  event Deposit(\\r\\n    address indexed reserve,\\r\\n    address user,\\r\\n    address indexed onBehalfOf,\\r\\n    uint256 amount,\\r\\n    uint16 indexed referral\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on withdraw()\\r\\n   * @param reserve The address of the underlyng asset being withdrawn\\r\\n   * @param user The address initiating the withdrawal, owner of aTokens\\r\\n   * @param to Address that will receive the underlying\\r\\n   * @param amount The amount to be withdrawn\\r\\n   **/\\r\\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\r\\n   * @param reserve The address of the underlying asset being borrowed\\r\\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\\r\\n   * initiator of the transaction on flashLoan()\\r\\n   * @param onBehalfOf The address that will be getting the debt\\r\\n   * @param amount The amount borrowed out\\r\\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\\r\\n   * @param borrowRate The numeric rate at which the user has borrowed\\r\\n   * @param referral The referral code used\\r\\n   **/\\r\\n  event Borrow(\\r\\n    address indexed reserve,\\r\\n    address user,\\r\\n    address indexed onBehalfOf,\\r\\n    uint256 amount,\\r\\n    uint256 borrowRateMode,\\r\\n    uint256 borrowRate,\\r\\n    uint16 indexed referral\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on repay()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The beneficiary of the repayment, getting his debt reduced\\r\\n   * @param repayer The address of the user initiating the repay(), providing the funds\\r\\n   * @param amount The amount repaid\\r\\n   **/\\r\\n  event Repay(\\r\\n    address indexed reserve,\\r\\n    address indexed user,\\r\\n    address indexed repayer,\\r\\n    uint256 amount\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on swapBorrowRateMode()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user swapping his rate mode\\r\\n   * @param rateMode The rate mode that the user wants to swap to\\r\\n   **/\\r\\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user enabling the usage as collateral\\r\\n   **/\\r\\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user enabling the usage as collateral\\r\\n   **/\\r\\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on rebalanceStableBorrowRate()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user for which the rebalance has been executed\\r\\n   **/\\r\\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on flashLoan()\\r\\n   * @param target The address of the flash loan receiver contract\\r\\n   * @param initiator The address initiating the flash loan\\r\\n   * @param asset The address of the asset being flash borrowed\\r\\n   * @param amount The amount flash borrowed\\r\\n   * @param premium The fee flash borrowed\\r\\n   * @param referralCode The referral code used\\r\\n   **/\\r\\n  event FlashLoan(\\r\\n    address indexed target,\\r\\n    address indexed initiator,\\r\\n    address indexed asset,\\r\\n    uint256 amount,\\r\\n    uint256 premium,\\r\\n    uint16 referralCode\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the pause is triggered.\\r\\n   */\\r\\n  event Paused();\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the pause is lifted.\\r\\n   */\\r\\n  event Unpaused();\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\\r\\n   * LendingPoolCollateral manager using a DELEGATECALL\\r\\n   * This allows to have the events in the generated ABI for LendingPool.\\r\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n   * @param user The address of the borrower getting liquidated\\r\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\\r\\n   * @param liquidator The address of the liquidator\\r\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\r\\n   * to receive the underlying collateral asset directly\\r\\n   **/\\r\\n  event LiquidationCall(\\r\\n    address indexed collateralAsset,\\r\\n    address indexed debtAsset,\\r\\n    address indexed user,\\r\\n    uint256 debtToCover,\\r\\n    uint256 liquidatedCollateralAmount,\\r\\n    address liquidator,\\r\\n    bool receiveAToken\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\r\\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\\r\\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\\r\\n   * gets added to the LendingPool ABI\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param liquidityRate The new liquidity rate\\r\\n   * @param stableBorrowRate The new stable borrow rate\\r\\n   * @param variableBorrowRate The new variable borrow rate\\r\\n   * @param liquidityIndex The new liquidity index\\r\\n   * @param variableBorrowIndex The new variable borrow index\\r\\n   **/\\r\\n  event ReserveDataUpdated(\\r\\n    address indexed reserve,\\r\\n    uint256 liquidityRate,\\r\\n    uint256 stableBorrowRate,\\r\\n    uint256 variableBorrowRate,\\r\\n    uint256 liquidityIndex,\\r\\n    uint256 variableBorrowIndex\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\r\\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\r\\n   * @param asset The address of the underlying asset to deposit\\r\\n   * @param amount The amount to be deposited\\r\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\r\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\r\\n   *   is a different wallet\\r\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n   *   0 if the action is executed directly by the user, without any middle-man\\r\\n   **/\\r\\n  function deposit(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address onBehalfOf,\\r\\n    uint16 referralCode\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\r\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\r\\n   * @param asset The address of the underlying asset to withdraw\\r\\n   * @param amount The underlying amount to be withdrawn\\r\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\r\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\r\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\r\\n   *   different wallet\\r\\n   * @return The final amount withdrawn\\r\\n   **/\\r\\n  function withdraw(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address to\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\r\\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\\r\\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\\r\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\r\\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\r\\n   * @param asset The address of the underlying asset to borrow\\r\\n   * @param amount The amount to be borrowed\\r\\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\r\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n   *   0 if the action is executed directly by the user, without any middle-man\\r\\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\\r\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\r\\n   * if he has been given credit delegation allowance\\r\\n   **/\\r\\n  function borrow(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    uint256 interestRateMode,\\r\\n    uint16 referralCode,\\r\\n    address onBehalfOf\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\r\\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\r\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\r\\n   * @param amount The amount to repay\\r\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\r\\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\r\\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\r\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\r\\n   * other borrower whose debt should be removed\\r\\n   * @return The final amount repaid\\r\\n   **/\\r\\n  function repay(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    uint256 rateMode,\\r\\n    address onBehalfOf\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\\r\\n   * @param asset The address of the underlying asset borrowed\\r\\n   * @param rateMode The rate mode that the user wants to swap to\\r\\n   **/\\r\\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\\r\\n   * - Users can be rebalanced if the following conditions are satisfied:\\r\\n   *     1. Usage ratio is above 95%\\r\\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\\r\\n   *        borrowed at a stable rate and depositors are not earning enough\\r\\n   * @param asset The address of the underlying asset borrowed\\r\\n   * @param user The address of the user to be rebalanced\\r\\n   **/\\r\\n  function rebalanceStableBorrowRate(address asset, address user) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\r\\n   * @param asset The address of the underlying asset deposited\\r\\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\\r\\n   **/\\r\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\r\\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\r\\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\r\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n   * @param user The address of the borrower getting liquidated\\r\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\r\\n   * to receive the underlying collateral asset directly\\r\\n   **/\\r\\n  function liquidationCall(\\r\\n    address collateralAsset,\\r\\n    address debtAsset,\\r\\n    address user,\\r\\n    uint256 debtToCover,\\r\\n    bool receiveAToken\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\r\\n   * as long as the amount taken plus a fee is returned.\\r\\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\\r\\n   * For further details please visit https://developers.aave.com\\r\\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\\r\\n   * @param assets The addresses of the assets being flash-borrowed\\r\\n   * @param amounts The amounts amounts being flash-borrowed\\r\\n   * @param modes Types of the debt to open if the flash loan is not returned:\\r\\n   *   0 -\\u003e Don\\u0027t open any debt, just revert if funds can\\u0027t be transferred from the receiver\\r\\n   *   1 -\\u003e Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\r\\n   *   2 -\\u003e Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\r\\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\r\\n   * @param params Variadic packed params to pass to the receiver as extra information\\r\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n   *   0 if the action is executed directly by the user, without any middle-man\\r\\n   **/\\r\\n  function flashLoan(\\r\\n    address receiverAddress,\\r\\n    address[] calldata assets,\\r\\n    uint256[] calldata amounts,\\r\\n    uint256[] calldata modes,\\r\\n    address onBehalfOf,\\r\\n    bytes calldata params,\\r\\n    uint16 referralCode\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the user account data across all the reserves\\r\\n   * @param user The address of the user\\r\\n   * @return totalCollateralETH the total collateral in ETH of the user\\r\\n   * @return totalDebtETH the total debt in ETH of the user\\r\\n   * @return availableBorrowsETH the borrowing power left of the user\\r\\n   * @return currentLiquidationThreshold the liquidation threshold of the user\\r\\n   * @return ltv the loan to value of the user\\r\\n   * @return healthFactor the current health factor of the user\\r\\n   **/\\r\\n  function getUserAccountData(address user)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint256 totalCollateralETH,\\r\\n      uint256 totalDebtETH,\\r\\n      uint256 availableBorrowsETH,\\r\\n      uint256 currentLiquidationThreshold,\\r\\n      uint256 ltv,\\r\\n      uint256 healthFactor\\r\\n    );\\r\\n\\r\\n  function initReserve(\\r\\n    address reserve,\\r\\n    address aTokenAddress,\\r\\n    address stableDebtAddress,\\r\\n    address variableDebtAddress,\\r\\n    address interestRateStrategyAddress\\r\\n  ) external;\\r\\n\\r\\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\\r\\n    external;\\r\\n\\r\\n  function setConfiguration(address reserve, uint256 configuration) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the configuration of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The configuration of the reserve\\r\\n   **/\\r\\n  function getConfiguration(address asset)\\r\\n    external\\r\\n    view\\r\\n    returns (DataTypes.ReserveConfigurationMap memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the configuration of the user across all the reserves\\r\\n   * @param user The user address\\r\\n   * @return The configuration of the user\\r\\n   **/\\r\\n  function getUserConfiguration(address user)\\r\\n    external\\r\\n    view\\r\\n    returns (DataTypes.UserConfigurationMap memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the normalized income normalized income of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The reserve\\u0027s normalized income\\r\\n   */\\r\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the normalized variable debt per unit of asset\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The reserve normalized variable debt\\r\\n   */\\r\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the state and configuration of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The state of the reserve\\r\\n   **/\\r\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\r\\n\\r\\n  function finalizeTransfer(\\r\\n    address asset,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 amount,\\r\\n    uint256 balanceFromAfter,\\r\\n    uint256 balanceToBefore\\r\\n  ) external;\\r\\n\\r\\n  function getReservesList() external view returns (address[] memory);\\r\\n\\r\\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\\r\\n\\r\\n  function setPause(bool val) external;\\r\\n\\r\\n  function paused() external view returns (bool);\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[],\"name\":\"PERCENTAGE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"acoExpiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxExpiration\",\"type\":\"uint256\"}],\"name\":\"acoExpirationIsValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tolerancePriceBelow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePriceAbove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"acoStrikePriceIsValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lendingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"}],\"name\":\"getAmountToLockedWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"}],\"name\":\"getAmountToNoLockedWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lendingToken\",\"type\":\"address\"}],\"name\":\"getBaseAssetsWithdrawWithLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lendingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPriceAdjustPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPrecision\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDeposit\",\"type\":\"bool\"}],\"name\":\"getBaseCollateralData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"underlyingBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLockedRedeemable\",\"type\":\"uint256\"}],\"name\":\"getBaseWithdrawNoLockedData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPossible\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"underlyingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseVolatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPriceAdjustPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPrecision\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"acoFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"}],\"internalType\":\"struct ACOPoolLib.OpenPositionData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"getOpenPositionCollateralBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralOnOpenPosition\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLockedRedeemable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"}],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lendingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseVolatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePriceBelow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePriceAbove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPrecision\",\"type\":\"uint256\"}],\"internalType\":\"struct ACOPoolLib.QuoteData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ACOPoolLib","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2f9bd0b8bf229a4498713542e5a69401353671ea9c218a11935476b6858c351e"}]}