{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n    /**\\n     * Returns whether the target address is a contract\\n     * @dev This function will return false if invoked during the constructor of a contract,\\n     * as the code is not actually created until after the constructor finishes.\\n     * @param account address of the account to check\\n     * @return whether the target address is a contract\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n}\"},\"all.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Unsigned math operations with safety checks that revert on error.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\r\\n     * reverts when dividing by zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * Utility library of inline functions on addresses\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * Returns whether the target address is a contract\\r\\n     * @dev This function will return false if invoked during the constructor of a contract,\\r\\n     * as the code is not actually created until after the constructor finishes.\\r\\n     * @param account address of the account to check\\r\\n     * @return whether the target address is a contract\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Roles\\r\\n * @dev Library for managing addresses assigned to a Role.\\r\\n */\\r\\nlibrary Roles {\\r\\n    struct Role {\\r\\n        mapping (address =\\u003e bool) bearer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Give an account access to this role.\\r\\n     */\\r\\n    function add(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(!has(role, account));\\r\\n\\r\\n        role.bearer[account] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove an account\\u0027s access to this role.\\r\\n     */\\r\\n    function remove(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(has(role, account));\\r\\n\\r\\n        role.bearer[account] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if an account has this role.\\r\\n     * @return bool\\r\\n     */\\r\\n    function has(Role storage role, address account) internal view returns (bool) {\\r\\n        require(account != address(0));\\r\\n        return role.bearer[account];\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @title FarmOrDie interface\\r\\n */\\r\\ninterface IFarmOrDie {\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address who) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\n\\r\\ncontract Ownable {\\r\\n    address public _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () public {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\ncontract FarmOrDie is Ownable, IFarmOrDie {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    event LogBurn(uint256 indexed epoch, uint256 totalSupply);\\r\\n\\r\\n    modifier validRecipient(address to) {\\r\\n        require(to != address(0x0));\\r\\n        require(to != address(this));\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    string public constant name = \\\"Farm Or Die\\\";\\r\\n    string public constant symbol = \\\"SKULLS\\\";\\r\\n    uint256 public constant decimals = 18;\\r\\n\\r\\n    uint256 private constant DECIMALS = 18;\\r\\n    uint256 private constant MAX_UINT256 = ~uint256(0); //(2^256) - 1\\r\\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 26000 * 10**DECIMALS;\\r\\n\\r\\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\\r\\n\\r\\n    uint256 private constant MAX_SUPPLY = ~uint128(0); //(2^128) - 1\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    uint256 private _gonsPerFragment;\\r\\n    mapping(address =\\u003e uint256) private _gonBalances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowedFragments;\\r\\n\\r\\n    function burn(uint256 epoch, uint256 decayrate) external onlyOwner returns (uint256)\\r\\n    {\\r\\n        uint256 _remainrate = 100;\\r\\n        _remainrate = _remainrate.sub(decayrate);\\r\\n\\r\\n\\r\\n        _totalSupply = _totalSupply.mul(_remainrate);\\r\\n        _totalSupply = _totalSupply.sub(_totalSupply.mod(100));\\r\\n        _totalSupply = _totalSupply.div(100);\\r\\n\\r\\n        \\r\\n        if (_totalSupply \\u003e MAX_SUPPLY) {\\r\\n            _totalSupply = MAX_SUPPLY;\\r\\n        }\\r\\n\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n\\r\\n        emit LogBurn(epoch, _totalSupply);\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    constructor() public {\\r\\n        _owner = msg.sender;\\r\\n        \\r\\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\r\\n        _gonBalances[_owner] = TOTAL_GONS;\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n\\r\\n        emit Transfer(address(0x0), _owner, _totalSupply);\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view returns (uint256)\\r\\n    {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address who) public view returns (uint256)\\r\\n    {\\r\\n        return _gonBalances[who].div(_gonsPerFragment);\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 value) public  validRecipient(to) returns (bool)\\r\\n    {\\r\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\r\\n        _gonBalances[msg.sender] = _gonBalances[msg.sender].sub(gonValue);\\r\\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\\r\\n        emit Transfer(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner_, address spender) public view returns (uint256)\\r\\n    {\\r\\n        return _allowedFragments[owner_][spender];\\r\\n    }\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value) public validRecipient(to) returns (bool)\\r\\n    {\\r\\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);\\r\\n\\r\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\r\\n        _gonBalances[from] = _gonBalances[from].sub(gonValue);\\r\\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\\r\\n        emit Transfer(from, to, value);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 value) public returns (bool)\\r\\n    {\\r\\n        _allowedFragments[msg.sender][spender] = value;\\r\\n        emit Approval(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool)\\r\\n    {\\r\\n        _allowedFragments[msg.sender][spender] =\\r\\n            _allowedFragments[msg.sender][spender].add(addedValue);\\r\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool)\\r\\n    {\\r\\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\\r\\n        if (subtractedValue \\u003e= oldValue) {\\r\\n            _allowedFragments[msg.sender][spender] = 0;\\r\\n        } else {\\r\\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\\r\\n        }\\r\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function mint(address account, uint256 value) public {\\r\\n        require(account != address(0));\\r\\n\\r\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(gonValue);   \\r\\n        _gonBalances[account] = _gonBalances[account].add(gonValue);\\r\\n        emit Transfer(address(0), account, value);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\n\\r\\ncontract MinterRole {\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    event MinterAdded(address indexed account);\\r\\n    event MinterRemoved(address indexed account);\\r\\n\\r\\n    Roles.Role private _minters;\\r\\n\\r\\n    constructor () internal {\\r\\n        _addMinter(msg.sender);\\r\\n    }\\r\\n\\r\\n    modifier onlyMinter() {\\r\\n        require(isMinter(msg.sender));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isMinter(address account) public view returns (bool) {\\r\\n        return _minters.has(account);\\r\\n    }\\r\\n\\r\\n    function addMinter(address account) public onlyMinter {\\r\\n        _addMinter(account);\\r\\n    }\\r\\n\\r\\n    function renounceMinter() public {\\r\\n        _removeMinter(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _addMinter(address account) internal {\\r\\n        _minters.add(account);\\r\\n        emit MinterAdded(account);\\r\\n    }\\r\\n\\r\\n    function _removeMinter(address account) internal {\\r\\n        _minters.remove(account);\\r\\n        emit MinterRemoved(account);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @title FarmOrDieMintable\\r\\n * @dev FarmOrDie minting logic.\\r\\n */\\r\\ncontract FarmOrDieMintable is FarmOrDie, MinterRole {\\r\\n    /**\\r\\n     * @dev Function to mint tokens\\r\\n     * @param to The address that will receive the minted tokens.\\r\\n     * @param value The amount of tokens to mint.\\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function _mint(address to, uint256 value) public onlyMinter returns (bool) {\\r\\n        mint(to, value);\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\ncontract Rewards is FarmOrDie, FarmOrDieMintable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256 public roundMask;\\r\\n    uint256 public lastMintedBlockNumber;\\r\\n    uint256 public totalParticipants = 0;\\r\\n    uint256 public tokensPerBlock; \\r\\n    uint256 public blockFreezeInterval; \\r\\n    address public tokencontractAddress = address(this);\\r\\n    mapping(address =\\u003e uint256) public participantMask; \\r\\n\\r\\n    \\r\\n    constructor(uint256 _tokensPerBlock, uint256 _blockFreezeInterval) public FarmOrDieMintable(){ \\r\\n        lastMintedBlockNumber = block.number;\\r\\n        tokensPerBlock = _tokensPerBlock;\\r\\n        blockFreezeInterval = _blockFreezeInterval;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to check if msg.sender is whitelisted as a minter. \\r\\n     */\\r\\n    modifier isAuthorized() {\\r\\n        require(isMinter(msg.sender));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to add participants in the network. \\r\\n     * @param _minter The address that will be able to mint tokens.\\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function addMinters(address _minter) external returns (bool) {\\r\\n    _addMinter(_minter);\\r\\n        totalParticipants = totalParticipants.add(1);\\r\\n        updateParticipantMask(_minter);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to remove participants in the network. \\r\\n     * @param _minter The address that will be unable to mint tokens.\\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function removeMinters(address _minter) external returns (bool) {\\r\\n        totalParticipants = totalParticipants.sub(1);\\r\\n        _removeMinter(_minter); \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to introduce new tokens in the network. \\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function trigger() external isAuthorized returns (bool) {\\r\\n        bool res = readyToMint();\\r\\n        if(res == false) {\\r\\n            return false;\\r\\n        } else {\\r\\n            mintTokens();\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to withdraw rewarded tokens by a participant. \\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function withdraw() external isAuthorized returns (bool) {\\r\\n        uint256 amount = calculateRewards();\\r\\n        require(amount \\u003e0);\\r\\n        FarmOrDie(tokencontractAddress).transfer(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to check if new tokens are ready to be minted. \\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function readyToMint() public view returns (bool) {\\r\\n        uint256 currentBlockNumber = block.number;\\r\\n        uint256 lastBlockNumber = lastMintedBlockNumber;\\r\\n        if(currentBlockNumber \\u003e lastBlockNumber + blockFreezeInterval) { \\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to calculate current rewards for a participant. \\r\\n     * @return A uint that returns the calculated rewards amount.\\r\\n     */\\r\\n    function calculateRewards() private returns (uint256) {\\r\\n        uint256 playerMask = participantMask[msg.sender];\\r\\n        uint256 rewards = roundMask.sub(playerMask);\\r\\n        updateParticipantMask(msg.sender);\\r\\n        return rewards;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to mint new tokens into the economy. \\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function mintTokens() private returns (bool) {\\r\\n        uint256 currentBlockNumber = block.number;\\r\\n        uint256 tokenReleaseAmount = (currentBlockNumber.sub(lastMintedBlockNumber)).mul(tokensPerBlock);\\r\\n        lastMintedBlockNumber = currentBlockNumber;\\r\\n        mint(tokencontractAddress, tokenReleaseAmount);\\r\\n        calculateTPP(tokenReleaseAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n     /**\\r\\n    * @dev Function to calculate TPP (token amount per participant).\\r\\n    * @return A boolean that indicates if the operation was successful.\\r\\n    */\\r\\n    function calculateTPP(uint256 tokens) private returns (bool) {\\r\\n        uint256 tpp = tokens.div(totalParticipants);\\r\\n        updateRoundMask(tpp);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n     /**\\r\\n    * @dev Function to update round mask. \\r\\n    * @return A boolean that indicates if the operation was successful.\\r\\n    */\\r\\n    function updateRoundMask(uint256 tpp) private returns (bool) {\\r\\n        roundMask = roundMask.add(tpp);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n     /**\\r\\n    * @dev Function to update participant mask (store the previous round mask)\\r\\n    * @return A boolean that indicates if the operation was successful.\\r\\n    */\\r\\n    function updateParticipantMask(address participant) private returns (bool) {\\r\\n        uint256 previousRoundMask = roundMask;\\r\\n        participantMask[participant] = previousRoundMask;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeFarmOrDie\\r\\n * @dev Wrappers around FarmOrDie operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeFarmOrDie for FarmOrDie;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeFarmOrDie {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IFarmOrDie token, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IFarmOrDie token, address from, address to, uint256 value) internal {\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IFarmOrDie token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IFarmOrDie token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IFarmOrDie token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\r\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function callOptionalReturn(IFarmOrDie token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n\\r\\n        require(address(token).isContract());\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success);\\r\\n\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            require(abi.decode(returndata, (bool)));\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev A token holder contract that will allow a beneficiary to extract the\\r\\n * tokens after a given release time.\\r\\n *\\r\\n * Useful for simple vesting schedules like \\\"advisors get all of their tokens\\r\\n * after 1 year\\\".\\r\\n */\\r\\ncontract TokenTimelock {\\r\\n    using SafeFarmOrDie for IFarmOrDie;\\r\\n\\r\\n    IFarmOrDie private _token;\\r\\n\\r\\n    address private _beneficiary;\\r\\n\\r\\n    uint256 private _releaseTime;\\r\\n\\r\\n    constructor (IFarmOrDie token, address beneficiary, uint256 releaseTime) public {\\r\\n        require(releaseTime \\u003e block.timestamp, \\\"TokenTimelock: release time is before current time\\\");\\r\\n        _token = token;\\r\\n        _beneficiary = beneficiary;\\r\\n        _releaseTime = releaseTime;\\r\\n    }\\r\\n\\r\\n    function token() public view returns (IFarmOrDie) {\\r\\n        return _token;\\r\\n    }\\r\\n\\r\\n    function beneficiary() public view returns (address) {\\r\\n        return _beneficiary;\\r\\n    }\\r\\n\\r\\n    function releaseTime() public view returns (uint256) {\\r\\n        return _releaseTime;\\r\\n    }\\r\\n\\r\\n    function release() public {\\r\\n        require(block.timestamp \\u003e= _releaseTime, \\\"TokenTimelock: current time is before release time\\\");\\r\\n\\r\\n        uint256 amount = _token.balanceOf(address(this));\\r\\n        require(amount \\u003e 0, \\\"TokenTimelock: no tokens to release\\\");\\r\\n\\r\\n        _token.safeTransfer(_beneficiary, amount);\\r\\n    }\\r\\n}\\r\\n\"},\"FarmOrDie.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\nimport \\\"./IFarmOrDie.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n\\r\\ncontract Ownable {\\r\\n    address public _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () public {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract FarmOrDie is Ownable, IFarmOrDie {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    event LogBurn(uint256 indexed epoch, uint256 totalSupply);\\r\\n\\r\\n    modifier validRecipient(address to) {\\r\\n        require(to != address(0x0));\\r\\n        require(to != address(this));\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    string public constant name = \\\"Farm Or Die\\\";\\r\\n    string public constant symbol = \\\"SKULLS\\\";\\r\\n    uint256 public constant decimals = 18;\\r\\n\\r\\n    uint256 private constant DECIMALS = 18;\\r\\n    uint256 private constant MAX_UINT256 = ~uint256(0); //(2^256) - 1\\r\\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 26000 * 10**DECIMALS;\\r\\n\\r\\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\\r\\n\\r\\n    uint256 private constant MAX_SUPPLY = ~uint128(0); //(2^128) - 1\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    uint256 private _gonsPerFragment;\\r\\n    mapping(address =\\u003e uint256) private _gonBalances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowedFragments;\\r\\n\\r\\n    function burn(uint256 epoch, uint256 decayrate) external onlyOwner returns (uint256)\\r\\n    {\\r\\n        uint256 _remainrate = 100;\\r\\n        _remainrate = _remainrate.sub(decayrate);\\r\\n\\r\\n\\r\\n        _totalSupply = _totalSupply.mul(_remainrate);\\r\\n        _totalSupply = _totalSupply.sub(_totalSupply.mod(100));\\r\\n        _totalSupply = _totalSupply.div(100);\\r\\n\\r\\n        \\r\\n        if (_totalSupply \\u003e MAX_SUPPLY) {\\r\\n            _totalSupply = MAX_SUPPLY;\\r\\n        }\\r\\n\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n\\r\\n        emit LogBurn(epoch, _totalSupply);\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    constructor() public {\\r\\n        _owner = msg.sender;\\r\\n        \\r\\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\r\\n        _gonBalances[_owner] = TOTAL_GONS;\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n\\r\\n        emit Transfer(address(0x0), _owner, _totalSupply);\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view returns (uint256)\\r\\n    {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address who) public view returns (uint256)\\r\\n    {\\r\\n        return _gonBalances[who].div(_gonsPerFragment);\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 value) public  validRecipient(to) returns (bool)\\r\\n    {\\r\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\r\\n        _gonBalances[msg.sender] = _gonBalances[msg.sender].sub(gonValue);\\r\\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\\r\\n        emit Transfer(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner_, address spender) public view returns (uint256)\\r\\n    {\\r\\n        return _allowedFragments[owner_][spender];\\r\\n    }\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value) public validRecipient(to) returns (bool)\\r\\n    {\\r\\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);\\r\\n\\r\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\r\\n        _gonBalances[from] = _gonBalances[from].sub(gonValue);\\r\\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\\r\\n        emit Transfer(from, to, value);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 value) public returns (bool)\\r\\n    {\\r\\n        _allowedFragments[msg.sender][spender] = value;\\r\\n        emit Approval(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool)\\r\\n    {\\r\\n        _allowedFragments[msg.sender][spender] =\\r\\n            _allowedFragments[msg.sender][spender].add(addedValue);\\r\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool)\\r\\n    {\\r\\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\\r\\n        if (subtractedValue \\u003e= oldValue) {\\r\\n            _allowedFragments[msg.sender][spender] = 0;\\r\\n        } else {\\r\\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\\r\\n        }\\r\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function mint(address account, uint256 value) public {\\r\\n        require(account != address(0));\\r\\n\\r\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(gonValue);   \\r\\n        _gonBalances[account] = _gonBalances[account].add(gonValue);\\r\\n        emit Transfer(address(0), account, value);\\r\\n    }\\r\\n}\"},\"FarmOrDieMintable.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\n\\nimport \\\"./FarmOrDie.sol\\\";\\nimport \\\"./MinterRole.sol\\\";\\n\\n/**\\n * @title FarmOrDieMintable\\n * @dev FarmOrDie minting logic.\\n */\\ncontract FarmOrDieMintable is FarmOrDie, MinterRole {\\n    /**\\n     * @dev Function to mint tokens\\n     * @param to The address that will receive the minted tokens.\\n     * @param value The amount of tokens to mint.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n    function _mint(address to, uint256 value) public onlyMinter returns (bool) {\\n        mint(to, value);\\n        return true;\\n    }\\n}\\n\"},\"IFarmOrDie.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\n\\n/**\\n * @title FarmOrDie interface\\n */\\ninterface IFarmOrDie {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"MinterRole.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract MinterRole {\\n    using Roles for Roles.Role;\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    Roles.Role private _minters;\\n\\n    constructor () internal {\\n        _addMinter(msg.sender);\\n    }\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender));\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters.has(account);\\n    }\\n\\n    function addMinter(address account) public onlyMinter {\\n        _addMinter(account);\\n    }\\n\\n    function renounceMinter() public {\\n        _removeMinter(msg.sender);\\n    }\\n\\n    function _addMinter(address account) internal {\\n        _minters.add(account);\\n        emit MinterAdded(account);\\n    }\\n\\n    function _removeMinter(address account) internal {\\n        _minters.remove(account);\\n        emit MinterRemoved(account);\\n    }\\n}\\n\"},\"Rewards.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\r\\n\\r\\nimport \\\"./FarmOrDieMintable.sol\\\";\\r\\nimport \\\"./FarmOrDie.sol\\\";\\r\\n\\r\\ncontract Rewards is FarmOrDie, FarmOrDieMintable {\\r\\n\\r\\n\\tusing SafeMath for uint256;\\r\\n\\r\\n\\tuint256 public roundMask;\\r\\n\\tuint256 public lastMintedBlockNumber;\\r\\n\\tuint256 public totalParticipants = 0;\\r\\n\\tuint256 public tokensPerBlock; \\r\\n\\tuint256 public blockFreezeInterval; \\r\\n\\taddress public tokencontractAddress = address(this);\\r\\n\\tmapping(address =\\u003e uint256) public participantMask; \\r\\n\\r\\n\\t\\r\\n\\tconstructor(uint256 _tokensPerBlock, uint256 _blockFreezeInterval) public FarmOrDieMintable(){ \\r\\n\\t\\tlastMintedBlockNumber = block.number;\\r\\n\\t\\ttokensPerBlock = _tokensPerBlock;\\r\\n\\t\\tblockFreezeInterval = _blockFreezeInterval;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Modifier to check if msg.sender is whitelisted as a minter. \\r\\n\\t */\\r\\n\\tmodifier isAuthorized() {\\r\\n\\t\\trequire(isMinter(msg.sender));\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Function to add participants in the network. \\r\\n\\t * @param _minter The address that will be able to mint tokens.\\r\\n\\t * @return A boolean that indicates if the operation was successful.\\r\\n\\t */\\r\\n\\tfunction addMinters(address _minter) external returns (bool) {\\r\\n\\t_addMinter(_minter);\\r\\n\\t\\ttotalParticipants = totalParticipants.add(1);\\r\\n\\t\\tupdateParticipantMask(_minter);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Function to remove participants in the network. \\r\\n\\t * @param _minter The address that will be unable to mint tokens.\\r\\n\\t * @return A boolean that indicates if the operation was successful.\\r\\n\\t */\\r\\n\\tfunction removeMinters(address _minter) external returns (bool) {\\r\\n\\t\\ttotalParticipants = totalParticipants.sub(1);\\r\\n\\t\\t_removeMinter(_minter); \\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Function to introduce new tokens in the network. \\r\\n\\t * @return A boolean that indicates if the operation was successful.\\r\\n\\t */\\r\\n\\tfunction trigger() external isAuthorized returns (bool) {\\r\\n\\t\\tbool res = readyToMint();\\r\\n\\t\\tif(res == false) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tmintTokens();\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Function to withdraw rewarded tokens by a participant. \\r\\n\\t * @return A boolean that indicates if the operation was successful.\\r\\n\\t */\\r\\n\\tfunction withdraw() external isAuthorized returns (bool) {\\r\\n\\t\\tuint256 amount = calculateRewards();\\r\\n\\t\\trequire(amount \\u003e0);\\r\\n\\t\\tFarmOrDie(tokencontractAddress).transfer(msg.sender, amount);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Function to check if new tokens are ready to be minted. \\r\\n\\t * @return A boolean that indicates if the operation was successful.\\r\\n\\t */\\r\\n\\tfunction readyToMint() public view returns (bool) {\\r\\n\\t\\tuint256 currentBlockNumber = block.number;\\r\\n\\t\\tuint256 lastBlockNumber = lastMintedBlockNumber;\\r\\n\\t\\tif(currentBlockNumber \\u003e lastBlockNumber + blockFreezeInterval) { \\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Function to calculate current rewards for a participant. \\r\\n\\t * @return A uint that returns the calculated rewards amount.\\r\\n\\t */\\r\\n\\tfunction calculateRewards() private returns (uint256) {\\r\\n\\t\\tuint256 playerMask = participantMask[msg.sender];\\r\\n\\t\\tuint256 rewards = roundMask.sub(playerMask);\\r\\n\\t\\tupdateParticipantMask(msg.sender);\\r\\n\\t\\treturn rewards;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Function to mint new tokens into the economy. \\r\\n\\t * @return A boolean that indicates if the operation was successful.\\r\\n\\t */\\r\\n\\tfunction mintTokens() private returns (bool) {\\r\\n\\t\\tuint256 currentBlockNumber = block.number;\\r\\n\\t\\tuint256 tokenReleaseAmount = (currentBlockNumber.sub(lastMintedBlockNumber)).mul(tokensPerBlock);\\r\\n\\t\\tlastMintedBlockNumber = currentBlockNumber;\\r\\n\\t\\tmint(tokencontractAddress, tokenReleaseAmount);\\r\\n\\t\\tcalculateTPP(tokenReleaseAmount);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t /**\\r\\n\\t* @dev Function to calculate TPP (token amount per participant).\\r\\n\\t* @return A boolean that indicates if the operation was successful.\\r\\n\\t*/\\r\\n\\tfunction calculateTPP(uint256 tokens) private returns (bool) {\\r\\n\\t\\tuint256 tpp = tokens.div(totalParticipants);\\r\\n\\t\\tupdateRoundMask(tpp);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t /**\\r\\n\\t* @dev Function to update round mask. \\r\\n\\t* @return A boolean that indicates if the operation was successful.\\r\\n\\t*/\\r\\n\\tfunction updateRoundMask(uint256 tpp) private returns (bool) {\\r\\n\\t\\troundMask = roundMask.add(tpp);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t /**\\r\\n\\t* @dev Function to update participant mask (store the previous round mask)\\r\\n\\t* @return A boolean that indicates if the operation was successful.\\r\\n\\t*/\\r\\n\\tfunction updateParticipantMask(address participant) private returns (bool) {\\r\\n\\t\\tuint256 previousRoundMask = roundMask;\\r\\n\\t\\tparticipantMask[participant] = previousRoundMask;\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n}\"},\"Roles.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address =\\u003e bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(account != address(0));\\n        require(!has(role, account));\\n\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account\\u0027s access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(account != address(0));\\n        require(has(role, account));\\n\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0));\\n        return role.bearer[account];\\n    }\\n}\"},\"SafeFarmOrDie.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\n\\nimport \\\"./IFarmOrDie.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeFarmOrDie\\n * @dev Wrappers around FarmOrDie operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeFarmOrDie for FarmOrDie;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeFarmOrDie {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IFarmOrDie token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IFarmOrDie token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IFarmOrDie token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IFarmOrDie token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IFarmOrDie token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IFarmOrDie token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n\\n        require(address(token).isContract());\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success);\\n\\n        if (returndata.length \\u003e 0) { // Return data is optional\\n            require(abi.decode(returndata, (bool)));\\n        }\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\"},\"TokenTimelock.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\n\\nimport \\\"./SafeFarmOrDie.sol\\\";\\n\\n/**\\n * @title TokenTimelock\\n * @dev TokenTimelock is a token holder contract that will allow a\\n * beneficiary to extract the tokens after a given release time.\\n */\\ncontract TokenTimelock {\\n    using SafeFarmOrDie for IFarmOrDie;\\n\\n    IFarmOrDie private _token;\\n\\n    address private _beneficiary;\\n\\n    uint256 private _releaseTime;\\n\\n    constructor (IFarmOrDie token, address beneficiary, uint256 releaseTime) public {\\n        require(releaseTime \\u003e block.timestamp, \\\"TokenTimelock: release time is before current time\\\");\\n        _token = token;\\n        _beneficiary = beneficiary;\\n        _releaseTime = releaseTime;\\n    }\\n\\n    function token() public view returns (IFarmOrDie) {\\n        return _token;\\n    }\\n\\n    function beneficiary() public view returns (address) {\\n        return _beneficiary;\\n    }\\n\\n    function releaseTime() public view returns (uint256) {\\n        return _releaseTime;\\n    }\\n\\n    function release() public {\\n        require(block.timestamp \\u003e= _releaseTime, \\\"TokenTimelock: current time is before release time\\\");\\n\\n        uint256 amount = _token.balanceOf(address(this));\\n        require(amount \\u003e 0, \\\"TokenTimelock: no tokens to release\\\");\\n\\n        _token.safeTransfer(_beneficiary, amount);\\n    }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\"},{\"name\":\"decayrate\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FarmOrDie","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0fdf28695e7d1388801409e5187084208f0fb33fb6721ff23cc2f1fd884bff44"}]}