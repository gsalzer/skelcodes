{"status":"1","message":"OK","result":[{"SourceCode":"// hevm: flattened sources of src/oracles.sol\npragma solidity >0.4.13 >=0.4.23 >=0.5.12 >=0.5.0 <0.6.0 >=0.5.10 <0.6.0 >=0.5.12 <0.6.0;\n\n////// src/IERC20.sol\n/* pragma solidity ^0.5.0; */\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function mint(address account, uint256 amount) external;\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n////// src/base.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \"./IERC20.sol\"; */\n\ninterface IAdapter {\n    function calc(\n        address gem,\n        uint256 acc,\n        uint256 factor\n    ) external view returns (uint256);\n}\n\ninterface IGemForRewardChecker {\n    function check(address gem) external view returns (bool);\n}\n\n////// src/safeMath.sol\n/* pragma solidity ^0.5.0; */\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n}\n\n////// src/uni.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \"./base.sol\"; */\n/* import \"./safeMath.sol\"; */\n\ninterface UniswapV2PairLike {\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n}\n\ncontract UniswapAdapterForStables is IAdapter {\n    using SafeMath for uint256;\n\n    struct TokenPair {\n        address t0;\n        address t1;\n        uint256 r0;\n        uint256 r1;\n        uint256 usdPrec;\n    }\n\n    function calc(\n        address gem,\n        uint256 value,\n        uint256 factor\n    ) external view returns (uint256) {\n        (uint112 _reserve0, uint112 _reserve1, ) = UniswapV2PairLike(gem).getReserves();\n\n        TokenPair memory tokenPair;\n        tokenPair.usdPrec = 10**6;\n\n        tokenPair.t0 = UniswapV2PairLike(gem).token0();\n        tokenPair.t1 = UniswapV2PairLike(gem).token1();\n\n        tokenPair.r0 = uint256(_reserve0).mul(tokenPair.usdPrec).div(\n            uint256(10)**IERC20(tokenPair.t0).decimals()\n        );\n        tokenPair.r1 = uint256(_reserve1).mul(tokenPair.usdPrec).div(\n            uint256(10)**IERC20(tokenPair.t1).decimals()\n        );\n\n        uint256 totalValue = tokenPair.r0.min(tokenPair.r1).mul(2); //total value in uni's reserves for stables only\n\n        uint256 supply = UniswapV2PairLike(gem).totalSupply();\n\n        return value.mul(totalValue).mul(factor).mul(1e18).div(supply.mul(tokenPair.usdPrec));\n    }\n}\n\ncontract UniswapAdapterWithOneStable is IAdapter {\n    using SafeMath for uint256;\n\n    struct LocalVars {\n        address t0;\n        address t1;\n        uint256 totalValue;\n        uint256 supply;\n        uint256 usdPrec;\n    }\n\n    address public deployer;\n    address public buck;\n\n    constructor() public {\n        deployer = msg.sender;\n    }\n\n    function setup(address _buck) public {\n        require(deployer == msg.sender);\n        buck = _buck;\n        deployer = address(0);\n    }\n\n    function calc(\n        address gem,\n        uint256 value,\n        uint256 factor\n    ) external view returns (uint256) {\n        (uint112 _reserve0, uint112 _reserve1, ) = UniswapV2PairLike(gem).getReserves();\n\n        LocalVars memory loc;\n        loc.t0 = UniswapV2PairLike(gem).token0();\n        loc.t1 = UniswapV2PairLike(gem).token1();\n        loc.usdPrec = 10**6;\n\n        if (buck == loc.t0) {\n            loc.totalValue = uint256(_reserve0).mul(loc.usdPrec).div(\n                uint256(10)**IERC20(loc.t0).decimals()\n            );\n        } else if (buck == loc.t1) {\n            loc.totalValue = uint256(_reserve1).mul(loc.usdPrec).div(\n                uint256(10)**IERC20(loc.t1).decimals()\n            );\n        } else {\n            require(false, \"gem w/o buck\");\n        }\n\n        loc.supply = UniswapV2PairLike(gem).totalSupply();\n\n        return\n            value.mul(loc.totalValue).mul(2).mul(factor).mul(1e18).div(\n                loc.supply.mul(loc.usdPrec)\n            );\n    }\n}\n\ncontract UniForRewardCheckerBase {\n    mapping(address => bool) public tokens;\n\n    function check(address gem) external {\n        address t0 = UniswapV2PairLike(gem).token0();\n        address t1 = UniswapV2PairLike(gem).token1();\n\n        require(tokens[t0] && tokens[t1], \"non-approved-stable\");\n    }\n}\n\ncontract UniForRewardCheckerMainnet is UniForRewardCheckerBase {\n    constructor(address usdfl, address gov) public {\n        tokens[usdfl] = true;\n        tokens[gov] = true;\n        tokens[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = true; //usdc\n        tokens[0xdAC17F958D2ee523a2206206994597C13D831ec7] = true; //usdt\n        tokens[0x6B175474E89094C44Da98b954EedeAC495271d0F] = true; //dai\n        tokens[0x674C6Ad92Fd080e4004b2312b45f796a192D27a0] = true; //usdn\n    }\n}\n\ncontract UniForRewardCheckerKovan is UniForRewardCheckerBase {\n    constructor(address usdfl, address gov) public {\n        tokens[usdfl] = true;\n        tokens[gov] = true;\n        tokens[0xe22da380ee6B445bb8273C81944ADEB6E8450422] = true; //usdc\n        tokens[0x13512979ADE267AB5100878E2e0f485B568328a4] = true; //usdt\n        tokens[0xFf795577d9AC8bD7D90Ee22b6C1703490b6512FD] = true; //dai\n        tokens[0x5f99471D242d04C42a990A33e8233f5B48F89C43] = true; //usdn\n    }\n}\n\ncontract UniForRewardCheckerRinkeby is UniForRewardCheckerBase {\n    constructor(address usdfl, address gov) public {\n        tokens[usdfl] = true;\n        tokens[gov] = true;\n        tokens[0x4DBCdF9B62e891a7cec5A2568C3F4FAF9E8Abe2b] = true; //usdc\n        tokens[0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02] = true; //usdt\n        tokens[0x97833b01a73733065684A851Fd1E91D7951b5fD8] = true; //dai\n        tokens[0x033C5b4A8E1b8A2f3b5A7451a9defD561028a8C5] = true; //usdn\n    }\n}\n\n////// src/oracles.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \"./uni.sol\"; */\n/* import \"./safeMath.sol\"; */\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ncontract UniswapAdapterPriceOracle_USDT_Buck {\n    using SafeMath for uint256;\n\n    struct TokenPair {\n        address buck;\n        address usdt;\n        uint256 buckReserve;\n        uint256 usdtReserve;\n    }\n\n    AggregatorV3Interface public priceETHUSDT;\n    AggregatorV3Interface public priceUSDETH;\n    UniswapV2PairLike public gem;\n    address public deployer;\n    address public usdtAddress;\n\n    constructor() public {\n        deployer = msg.sender;\n    }\n\n    function setup(\n        address _priceETHUSDT,\n        address _priceUSDETH,\n        address _gem,\n        address _usdtAddress,\n        bool usdtAsString\n    ) public {\n        require(deployer == msg.sender);\n        require(_usdtAddress != address(0));\n        require(_priceETHUSDT != address(0));\n        require(_priceUSDETH != address(0));\n        require(_gem != address(0));\n\n        (bool success, bytes memory returndata) =\n            address(_usdtAddress).call(abi.encodeWithSignature(\"symbol()\"));\n        require(success, \"USDT: low-level call failed\");\n\n        require(returndata.length > 0);\n        if (usdtAsString) {\n            bytes memory usdtSymbol = bytes(abi.decode(returndata, (string)));\n            require(keccak256(bytes(usdtSymbol)) == keccak256(\"USDT\"));\n        } else {\n            bytes32 usdtSymbol = abi.decode(returndata, (bytes32));\n            require(usdtSymbol == \"USDT\");\n        }\n\n        priceETHUSDT = AggregatorV3Interface(_priceETHUSDT); //1/354 USD kovan:0x0bF499444525a23E7Bb61997539725cA2e928138\n        priceUSDETH = AggregatorV3Interface(_priceUSDETH); //354 USD kovan:0x9326BFA02ADD2366b30bacB125260Af641031331\n        gem = UniswapV2PairLike(_gem);\n        usdtAddress = _usdtAddress;\n\n        deployer = address(0);\n    }\n\n    function calc() internal view returns (bytes32, bool) {\n        if (\n            address(priceETHUSDT) == address(0x0) ||\n            address(priceUSDETH) == address(0x0) ||\n            address(gem) == address(0x0)\n        ) {\n            return (0x0, false);\n        }\n\n        (, int256 answerUSDETH, , , ) = priceUSDETH.latestRoundData();\n        (, int256 answerETHUSDT, , , ) = priceETHUSDT.latestRoundData();\n\n        if (answerUSDETH <= 0 || answerETHUSDT <= 0) {\n            return (0x0, false);\n        }\n\n        TokenPair memory tokenPair;\n        {\n            (uint112 _reserve0, uint112 _reserve1, ) = gem.getReserves();\n\n            if (gem.token1() == usdtAddress) {\n                tokenPair.buck = gem.token0(); //buck\n                tokenPair.buckReserve = uint256(_reserve0);\n\n                tokenPair.usdt = gem.token1(); //USDT\n                tokenPair.usdtReserve = uint256(_reserve1);\n            } else {\n                tokenPair.usdt = gem.token0(); //USDT\n                tokenPair.usdtReserve = uint256(_reserve0);\n\n                tokenPair.buck = gem.token1(); //buck\n                tokenPair.buckReserve = uint256(_reserve1);\n            }\n        }\n\n        uint256 usdPrec = 10**6;\n\n        //assume buck == 1 USD\n        uint256 r0 =\n            tokenPair.buckReserve.mul(usdPrec).div(\n                uint256(10)**uint256(IERC20(tokenPair.buck).decimals())\n            );\n\n        uint256 price1Div =\n            10 **\n                (\n                    uint256(priceETHUSDT.decimals()).add(uint256(priceUSDETH.decimals())).add(\n                        uint256(IERC20(tokenPair.usdt).decimals())\n                    )\n                );\n\n        uint256 usdtPrice = uint256(answerUSDETH).mul(uint256(answerETHUSDT));\n        uint256 r1 = tokenPair.usdtReserve.mul(usdPrec).mul(usdtPrice).div(price1Div);\n\n        uint256 totalValue = r0.min(r1).mul(2); //total value in uni's reserves\n        uint256 supply = gem.totalSupply();\n\n        return (\n            bytes32(\n                totalValue.mul(10**(uint256(gem.decimals()).add(18))).div(supply.mul(usdPrec))\n            ),\n            true\n        );\n    }\n\n    function peek() public view returns (bytes32, bool) {\n        return calc();\n    }\n\n    function read() public view returns (bytes32) {\n        bytes32 wut;\n        bool haz;\n        (wut, haz) = calc();\n        require(haz, \"haz-not\");\n        return wut;\n    }\n}\n\ncontract UniswapAdapterPriceOracle_Buck_Buck {\n    using SafeMath for uint256;\n\n    struct TokenPair {\n        address t0;\n        address t1;\n    }\n\n    UniswapV2PairLike public gem;\n    address public deployer;\n\n    constructor() public {\n        deployer = msg.sender;\n    }\n\n    function setup(address _gem) public {\n        require(deployer == msg.sender);\n        gem = UniswapV2PairLike(_gem);\n        deployer = address(0);\n    }\n\n    function calc() internal view returns (bytes32, bool) {\n        (uint112 _reserve0, uint112 _reserve1, ) = gem.getReserves();\n\n        TokenPair memory tokenPair;\n        tokenPair.t0 = gem.token0();\n        tokenPair.t1 = gem.token1();\n\n        uint256 usdPrec = 10**6;\n\n        uint256 r0 =\n            uint256(_reserve0).mul(usdPrec).div(\n                uint256(10)**uint256(IERC20(tokenPair.t0).decimals())\n            );\n        uint256 r1 =\n            uint256(_reserve1).mul(usdPrec).div(\n                uint256(10)**uint256(IERC20(tokenPair.t1).decimals())\n            );\n\n        uint256 totalValue = r0.min(r1).mul(2); //total value in uni's reserves\n        uint256 supply = gem.totalSupply();\n\n        return (\n            bytes32(\n                totalValue.mul(10**(uint256(gem.decimals()).add(18))).div(supply.mul(usdPrec))\n            ),\n            true\n        );\n    }\n\n    function peek() public view returns (bytes32, bool) {\n        return calc();\n    }\n\n    function read() public view returns (bytes32) {\n        bytes32 wut;\n        bool haz;\n        (wut, haz) = calc();\n        require(haz, \"haz-not\");\n        return wut;\n    }\n}\n","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gem\",\"outputs\":[{\"internalType\":\"contract UniswapV2PairLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"peek\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"read\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gem\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UniswapAdapterPriceOracle_Buck_Buck","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}