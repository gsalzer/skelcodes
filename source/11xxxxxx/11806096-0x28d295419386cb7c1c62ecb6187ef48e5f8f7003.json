{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n//Slightly modified SafeMath library - includes a min and max function, removes useless div function\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\r\n        if (b > 0) {\r\n            c = a + b;\r\n            assert(c >= a);\r\n        } else {\r\n            c = a + b;\r\n            assert(c <= a);\r\n        }\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    function max(int256 a, int256 b) internal pure returns (uint256) {\r\n        return a > b ? uint256(a) : uint256(b);\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\r\n        if (b > 0) {\r\n            c = a - b;\r\n            assert(c <= a);\r\n        } else {\r\n            c = a - b;\r\n            assert(c >= a);\r\n        }\r\n\r\n    }\r\n}\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Tellor Oracle Storage Library\r\n * @dev Contains all the variables/structs used by Tellor\r\n */\r\n\r\nlibrary TellorStorage {\r\n    //Internal struct for use in proof-of-work submission\r\n    struct Details {\r\n        uint256 value;\r\n        address miner;\r\n    }\r\n\r\n    struct Dispute {\r\n        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\r\n        int256 tally; //current tally of votes for - against measure\r\n        bool executed; //is the dispute settled\r\n        bool disputeVotePassed; //did the vote pass?\r\n        bool isPropFork; //true for fork proposal NEW\r\n        address reportedMiner; //miner who submitted the 'bad value' will get disputeFee if dispute vote fails\r\n        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\r\n        address proposedForkAddress; //new fork address (if fork proposal)\r\n        mapping(bytes32 => uint256) disputeUintVars;\r\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\r\n        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\"requestId\")]\r\n        //These are the variables saved in this mapping:\r\n        // uint keccak256(\"requestId\");//apiID of disputed value\r\n        // uint keccak256(\"timestamp\");//timestamp of disputed value\r\n        // uint keccak256(\"value\"); //the value being disputed\r\n        // uint keccak256(\"minExecutionDate\");//7 days from when dispute initialized\r\n        // uint keccak256(\"numberOfVotes\");//the number of parties who have voted on the measure\r\n        // uint keccak256(\"blockNumber\");// the blocknumber for which votes will be calculated from\r\n        // uint keccak256(\"minerSlot\"); //index in dispute array\r\n        // uint keccak256(\"fee\"); //fee paid corresponding to dispute\r\n        mapping(address => bool) voted; //mapping of address to whether or not they voted\r\n    }\r\n\r\n    struct StakeInfo {\r\n        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\r\n        uint256 startDate; //stake start date\r\n    }\r\n\r\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\r\n    struct Checkpoint {\r\n        uint128 fromBlock; // fromBlock is the block number that the value was generated from\r\n        uint128 value; // value is the amount of tokens at a specific block number\r\n    }\r\n\r\n    struct Request {\r\n        string queryString; //id to string api\r\n        string dataSymbol; //short name for api request\r\n        bytes32 queryHash; //hash of api string and granularity e.g. keccak256(abi.encodePacked(_api,_granularity))\r\n        uint256[] requestTimestamps; //array of all newValueTimestamps requested\r\n        mapping(bytes32 => uint256) apiUintVars;\r\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\r\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\"totalTip\")]\r\n        //These are the variables saved in this mapping:\r\n        // uint keccak256(\"granularity\"); //multiplier for miners\r\n        // uint keccak256(\"requestQPosition\"); //index in requestQ\r\n        // uint keccak256(\"totalTip\");//bonus portion of payout\r\n        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\r\n        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\r\n        mapping(uint256 => uint256) finalValues;\r\n        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\r\n        mapping(uint256 => address[5]) minersByValue;\r\n        mapping(uint256 => uint256[5]) valuesByTimestamp;\r\n    }\r\n\r\n    struct TellorStorageStruct {\r\n        bytes32 currentChallenge; //current challenge to be solved\r\n        uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\r\n        uint256[] newValueTimestamps; //array of all timestamps requested\r\n        Details[5] currentMiners; //This struct is for organizing the five mined values to find the median\r\n        mapping(bytes32 => address) addressVars;\r\n        //Address fields in the Tellor contract are saved the addressVars mapping\r\n        //e.g. addressVars[keccak256(\"tellorContract\")] = address\r\n        //These are the variables saved in this mapping:\r\n        // address keccak256(\"tellorContract\");//Tellor address\r\n        // address  keccak256(\"_owner\");//Tellor Owner address\r\n        // address  keccak256(\"_deity\");//Tellor Owner that can do things at will\r\n        // address  keccak256(\"pending_owner\"); // The proposed new owner\r\n        mapping(bytes32 => uint256) uintVars;\r\n        //uint fields in the Tellor contract are saved the uintVars mapping\r\n        //e.g. uintVars[keccak256(\"decimals\")] = uint\r\n        //These are the variables saved in this mapping:\r\n        // keccak256(\"decimals\");    //18 decimal standard ERC20\r\n        // keccak256(\"disputeFee\");//cost to dispute a mined value\r\n        // keccak256(\"disputeCount\");//totalHistoricalDisputes\r\n        // keccak256(\"total_supply\"); //total_supply of the token in circulation\r\n        // keccak256(\"stakeAmount\");//stakeAmount for miners (we can cut gas if we just hardcoded it in...or should it be variable?)\r\n        // keccak256(\"stakerCount\"); //number of parties currently staked\r\n        // keccak256(\"timeOfLastNewValue\"); // time of last challenge solved\r\n        // keccak256(\"difficulty\"); // Difficulty of current block\r\n        // keccak256(\"currentTotalTips\"); //value of highest api/timestamp PayoutPool\r\n        // keccak256(\"currentRequestId\"); //API being mined--updates with the ApiOnQ Id\r\n        // keccak256(\"requestCount\"); // total number of requests through the system\r\n        // keccak256(\"slotProgress\");//Number of miners who have mined this value so far\r\n        // keccak256(\"miningReward\");//Mining Reward in PoWo tokens given to all miners per value\r\n        // keccak256(\"timeTarget\"); //The time between blocks (mined Oracle values)\r\n        // keccak256(\"_tblock\"); //\r\n        // keccak256(\"runningTips\"); // VAriable to track running tips\r\n        // keccak256(\"currentReward\"); // The current reward\r\n        // keccak256(\"devShare\"); // The amount directed towards th devShare\r\n        // keccak256(\"currentTotalTips\"); //\r\n        //This is a boolean that tells you if a given challenge has been completed by a given miner\r\n        mapping(bytes32 => mapping(address => bool)) minersByChallenge;\r\n        mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\r\n        mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\r\n        mapping(uint256 => Dispute) disputesById; //disputeId=> Dispute details\r\n        mapping(address => Checkpoint[]) balances; //balances of a party given blocks\r\n        mapping(address => mapping(address => uint256)) allowed; //allowance for a given party and approver\r\n        mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\r\n        mapping(uint256 => Request) requestDetails; //mapping of apiID to details\r\n        mapping(bytes32 => uint256) requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\r\n        mapping(bytes32 => uint256) disputeIdByDisputeHash; //maps a hash to an ID for each dispute\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n/**\r\n* @title Tellor Transfer\r\n* @dev Contains the methods related to transfers and ERC20. Tellor.sol and TellorGetters.sol\r\n* reference this library for function's logic.\r\n*/\r\nlibrary TellorTransfer {\r\n    using SafeMath for uint256;\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value); //ERC20 Approval event\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value); //ERC20 Transfer Event\r\n\r\n    bytes32 public constant stakeAmount = 0x7be108969d31a3f0b261465c71f2b0ba9301cd914d55d9091c3b36a49d4d41b2; //keccak256(\"stakeAmount\")\r\n\r\n    /*Functions*/\r\n\r\n    /**\r\n    * @dev Allows for a transfer of tokens to _to\r\n    * @param _to The address to send tokens to\r\n    * @param _amount The amount of tokens to send\r\n    * @return true if transfer is successful\r\n    */\r\n    function transfer(TellorStorage.TellorStorageStruct storage self, address _to, uint256 _amount) public returns (bool success) {\r\n        doTransfer(self, msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Send _amount tokens to _to from _from on the condition it\r\n    * is approved by _from\r\n    * @param _from The address holding the tokens being transferred\r\n    * @param _to The address of the recipient\r\n    * @param _amount The amount of tokens to be transferred\r\n    * @return True if the transfer was successful\r\n    */\r\n    function transferFrom(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(self.allowed[_from][msg.sender] >= _amount, \"Allowance is wrong\");\r\n        self.allowed[_from][msg.sender] -= _amount;\r\n        doTransfer(self, _from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev This function approves a _spender an _amount of tokens to use\r\n    * @param _spender address\r\n    * @param _amount amount the spender is being approved for\r\n    * @return true if spender approved successfully\r\n    */\r\n    function approve(TellorStorage.TellorStorageStruct storage self, address _spender, uint256 _amount) public returns (bool) {\r\n        require(_spender != address(0), \"Spender is 0-address\");\r\n        require(self.allowed[msg.sender][_spender] == 0 || _amount == 0, \"Spender is already approved\");\r\n        self.allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @param _user address of party with the balance\r\n    * @param _spender address of spender of parties said balance\r\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\r\n    */\r\n    function allowance(TellorStorage.TellorStorageStruct storage self, address _user, address _spender) public view returns (uint256) {\r\n        return self.allowed[_user][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Completes POWO transfers by updating the balances on the current block number\r\n    * @param _from address to transfer from\r\n    * @param _to address to transfer to\r\n    * @param _amount to transfer\r\n    */\r\n    function doTransfer(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount) public {\r\n        require(_amount != 0, \"Tried to send non-positive amount\");\r\n        require(_to != address(0), \"Receiver is 0 address\");\r\n        require(allowedToTrade(self, _from, _amount), \"Should have sufficient balance to trade\");\r\n        uint256 previousBalance = balanceOf(self, _from);\r\n        updateBalanceAtNow(self.balances[_from], previousBalance - _amount);\r\n        previousBalance = balanceOf(self,_to);\r\n        require(previousBalance + _amount >= previousBalance, \"Overflow happened\"); // Check for overflow\r\n        updateBalanceAtNow(self.balances[_to], previousBalance + _amount);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets balance of owner specified\r\n    * @param _user is the owner address used to look up the balance\r\n    * @return Returns the balance associated with the passed in _user\r\n    */\r\n    function balanceOf(TellorStorage.TellorStorageStruct storage self, address _user) public view returns (uint256) {\r\n        return balanceOfAt(self, _user, block.number);\r\n    }\r\n\r\n    /**\r\n    * @dev Queries the balance of _user at a specific _blockNumber\r\n    * @param _user The address from which the balance will be retrieved\r\n    * @param _blockNumber The block number when the balance is queried\r\n    * @return The balance at _blockNumber specified\r\n    */\r\n    function balanceOfAt(TellorStorage.TellorStorageStruct storage self, address _user, uint256 _blockNumber) public view returns (uint256) {\r\n        TellorStorage.Checkpoint[] storage checkpoints = self.balances[_user];\r\n        if (checkpoints.length == 0|| checkpoints[0].fromBlock > _blockNumber) {\r\n            return 0;\r\n        } else {\r\n            if (_blockNumber >= checkpoints[checkpoints.length - 1].fromBlock) return checkpoints[checkpoints.length - 1].value;\r\n            // Binary search of the value in the array\r\n            uint256 min = 0;\r\n            uint256 max = checkpoints.length - 2;\r\n            while (max > min) {\r\n                uint256 mid = (max + min + 1) / 2;\r\n                if  (checkpoints[mid].fromBlock ==_blockNumber){\r\n                    return checkpoints[mid].value;\r\n                }else if(checkpoints[mid].fromBlock < _blockNumber) {\r\n                    min = mid;\r\n                } else {\r\n                    max = mid - 1;\r\n                }\r\n            }\r\n            return checkpoints[min].value;\r\n        }\r\n    }\r\n    /**\r\n    * @dev This function returns whether or not a given user is allowed to trade a given amount\r\n    * and removing the staked amount from their balance if they are staked\r\n    * @param _user address of user\r\n    * @param _amount to check if the user can spend\r\n    * @return true if they are allowed to spend the amount being checked\r\n    */\r\n    function allowedToTrade(TellorStorage.TellorStorageStruct storage self, address _user, uint256 _amount) public view returns (bool) { \r\n        if (self.stakerDetails[_user].currentStatus != 0 && self.stakerDetails[_user].currentStatus < 5) {\r\n            //Subtracts the stakeAmount from balance if the _user is staked\r\n            if (balanceOf(self, _user)- self.uintVars[stakeAmount] >= _amount) {\r\n                return true;\r\n            }\r\n            return false;\r\n        } \r\n        return (balanceOf(self, _user) >= _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Updates balance for from and to on the current block number via doTransfer\r\n    * @param checkpoints gets the mapping for the balances[owner]\r\n    * @param _value is the new balance\r\n    */\r\n    function updateBalanceAtNow(TellorStorage.Checkpoint[] storage checkpoints, uint256 _value) public {\r\n        if (checkpoints.length == 0 || checkpoints[checkpoints.length - 1].fromBlock != block.number) {\r\n           checkpoints.push(TellorStorage.Checkpoint({\r\n                fromBlock : uint128(block.number),\r\n                value : uint128(_value)\r\n            }));\r\n        } else {\r\n            TellorStorage.Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\r\n            oldCheckPoint.value = uint128(_value);\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n/**\r\n * @title Tellor Dispute\r\n * @dev Contains the methods related to disputes. Tellor.sol references this library for function's logic.\r\n */\r\n\r\nlibrary TellorDispute {\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n\r\n    //emitted when a new dispute is initialized\r\n    event NewDispute(\r\n        uint256 indexed _disputeId,\r\n        uint256 indexed _requestId,\r\n        uint256 _timestamp,\r\n        address _miner\r\n    );\r\n    //emitted when a new vote happens\r\n    event Voted(\r\n        uint256 indexed _disputeID,\r\n        bool _position,\r\n        address indexed _voter,\r\n        uint256 indexed _voteWeight\r\n    );\r\n    //emitted upon dispute tally\r\n    event DisputeVoteTallied(\r\n        uint256 indexed _disputeID,\r\n        int256 _result,\r\n        address indexed _reportedMiner,\r\n        address _reportingParty,\r\n        bool _active\r\n    );\r\n    event NewTellorAddress(address _newTellor); //emitted when a proposed fork is voted true\r\n\r\n    /*Functions*/\r\n\r\n    /**\r\n     * @dev Helps initialize a dispute by assigning it a disputeId\r\n     * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\r\n     * invalidated value information to POS voting\r\n     * @param _requestId being disputed\r\n     * @param _timestamp being disputed\r\n     * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\r\n     * requires 5 miners to submit a value.\r\n     */\r\n    function beginDispute(\r\n        TellorStorage.TellorStorageStruct storage self,\r\n        uint256 _requestId,\r\n        uint256 _timestamp,\r\n        uint256 _minerIndex\r\n    ) public {\r\n        TellorStorage.Request storage _request =\r\n            self.requestDetails[_requestId];\r\n        require(_request.minedBlockNum[_timestamp] != 0, \"Mined block is 0\");\r\n        require(_minerIndex < 5, \"Miner index is wrong\");\r\n\r\n        //_miner is the miner being disputed. For every mined value 5 miners are saved in an array and the _minerIndex\r\n        //provided by the party initiating the dispute\r\n        address _miner = _request.minersByValue[_timestamp][_minerIndex];\r\n        bytes32 _hash =\r\n            keccak256(abi.encodePacked(_miner, _requestId, _timestamp));\r\n\r\n        //Increase the dispute count by 1\r\n        uint256 disputeId = self.uintVars[keccak256(\"disputeCount\")] + 1;\r\n        self.uintVars[keccak256(\"disputeCount\")] = disputeId;\r\n\r\n        //Sets the new disputeCount as the disputeId\r\n\r\n        //Ensures that a dispute is not already open for the that miner, requestId and timestamp\r\n        uint256 hashId = self.disputeIdByDisputeHash[_hash];\r\n        if (hashId != 0) {\r\n            self.disputesById[disputeId].disputeUintVars[\r\n                keccak256(\"origID\")\r\n            ] = hashId;\r\n        } else {\r\n            self.disputeIdByDisputeHash[_hash] = disputeId;\r\n            hashId = disputeId;\r\n        }\r\n        uint256 origID = hashId;\r\n        uint256 dispRounds =\r\n            self.disputesById[origID].disputeUintVars[\r\n                keccak256(\"disputeRounds\")\r\n            ] + 1;\r\n        self.disputesById[origID].disputeUintVars[\r\n            keccak256(\"disputeRounds\")\r\n        ] = dispRounds;\r\n        self.disputesById[origID].disputeUintVars[\r\n            keccak256(abi.encode(dispRounds))\r\n        ] = disputeId;\r\n        if (disputeId != origID) {\r\n            uint256 lastID =\r\n                self.disputesById[origID].disputeUintVars[\r\n                    keccak256(abi.encode(dispRounds - 1))\r\n                ];\r\n            require(\r\n                self.disputesById[lastID].disputeUintVars[\r\n                    keccak256(\"minExecutionDate\")\r\n                ] <= now,\r\n                \"Dispute is already open\"\r\n            );\r\n            if (self.disputesById[lastID].executed) {\r\n                require(\r\n                    now -\r\n                        self.disputesById[lastID].disputeUintVars[\r\n                            keccak256(\"tallyDate\")\r\n                        ] <=\r\n                        1 days,\r\n                    \"Time for voting haven't elapsed\"\r\n                );\r\n            }\r\n        }\r\n        uint256 _fee;\r\n        if (_minerIndex == 2) {\r\n            self.requestDetails[_requestId].apiUintVars[\r\n                keccak256(\"disputeCount\")\r\n            ] =\r\n                self.requestDetails[_requestId].apiUintVars[\r\n                    keccak256(\"disputeCount\")\r\n                ] +\r\n                1;\r\n            //update dispute fee for this case\r\n            _fee =\r\n                self.uintVars[keccak256(\"stakeAmount\")] *\r\n                self.requestDetails[_requestId].apiUintVars[\r\n                    keccak256(\"disputeCount\")\r\n                ];\r\n        } else {\r\n            _fee = self.uintVars[keccak256(\"disputeFee\")] * dispRounds;\r\n        }\r\n\r\n        //maps the dispute to the Dispute struct\r\n        self.disputesById[disputeId] = TellorStorage.Dispute({\r\n            hash: _hash,\r\n            isPropFork: false,\r\n            reportedMiner: _miner,\r\n            reportingParty: msg.sender,\r\n            proposedForkAddress: address(0),\r\n            executed: false,\r\n            disputeVotePassed: false,\r\n            tally: 0\r\n        });\r\n\r\n        //Saves all the dispute variables for the disputeId\r\n        self.disputesById[disputeId].disputeUintVars[\r\n            keccak256(\"requestId\")\r\n        ] = _requestId;\r\n        self.disputesById[disputeId].disputeUintVars[\r\n            keccak256(\"timestamp\")\r\n        ] = _timestamp;\r\n        self.disputesById[disputeId].disputeUintVars[\r\n            keccak256(\"value\")\r\n        ] = _request.valuesByTimestamp[_timestamp][_minerIndex];\r\n        self.disputesById[disputeId].disputeUintVars[\r\n            keccak256(\"minExecutionDate\")\r\n        ] = now + 2 days * dispRounds;\r\n        self.disputesById[disputeId].disputeUintVars[\r\n            keccak256(\"blockNumber\")\r\n        ] = block.number;\r\n        self.disputesById[disputeId].disputeUintVars[\r\n            keccak256(\"minerSlot\")\r\n        ] = _minerIndex;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"fee\")] = _fee;\r\n        TellorTransfer.doTransfer(self, msg.sender, address(this), _fee);\r\n\r\n        //Values are sorted as they come in and the official value is the median of the first five\r\n        //So the \"official value\" miner is always minerIndex==2. If the official value is being\r\n        //disputed, it sets its status to inDispute(currentStatus = 3) so that users are made aware it is under dispute\r\n        if (_minerIndex == 2) {\r\n            _request.inDispute[_timestamp] = true;\r\n            _request.finalValues[_timestamp] = 0;\r\n        }\r\n        self.stakerDetails[_miner].currentStatus = 3;\r\n        emit NewDispute(disputeId, _requestId, _timestamp, _miner);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows token holders to vote\r\n     * @param _disputeId is the dispute id\r\n     * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\r\n     */\r\n    function vote(\r\n        TellorStorage.TellorStorageStruct storage self,\r\n        uint256 _disputeId,\r\n        bool _supportsDispute\r\n    ) public {\r\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\r\n\r\n        //Get the voteWeight or the balance of the user at the time/blockNumber the dispute began\r\n        uint256 voteWeight =\r\n            TellorTransfer.balanceOfAt(\r\n                self,\r\n                msg.sender,\r\n                disp.disputeUintVars[keccak256(\"blockNumber\")]\r\n            );\r\n\r\n        //Require that the msg.sender has not voted\r\n        require(disp.voted[msg.sender] != true, \"Sender has already voted\");\r\n\r\n        //Require that the user had a balance >0 at time/blockNumber the dispute began\r\n        require(voteWeight != 0, \"User balance is 0\");\r\n\r\n        //ensures miners that are under dispute cannot vote\r\n        require(\r\n            self.stakerDetails[msg.sender].currentStatus != 3,\r\n            \"Miner is under dispute\"\r\n        );\r\n\r\n        //Update user voting status to true\r\n        disp.voted[msg.sender] = true;\r\n\r\n        //Update the number of votes for the dispute\r\n        disp.disputeUintVars[keccak256(\"numberOfVotes\")] += 1;\r\n\r\n        //If the user supports the dispute increase the tally for the dispute by the voteWeight\r\n        //otherwise decrease it\r\n        if (_supportsDispute) {\r\n            disp.tally = disp.tally.add(int256(voteWeight));\r\n        } else {\r\n            disp.tally = disp.tally.sub(int256(voteWeight));\r\n        }\r\n\r\n        //Let the network know the user has voted on the dispute and their casted vote\r\n        emit Voted(_disputeId, _supportsDispute, msg.sender, voteWeight);\r\n    }\r\n\r\n    /**\r\n     * @dev tallies the votes and locks the stake disbursement(currentStatus = 4) if the vote passes\r\n     * @param _disputeId is the dispute id\r\n     */\r\n    function tallyVotes(\r\n        TellorStorage.TellorStorageStruct storage self,\r\n        uint256 _disputeId\r\n    ) public {\r\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\r\n\r\n        //Ensure this has not already been executed/tallied\r\n        require(disp.executed == false, \"Dispute has been already executed\");\r\n        require(\r\n            now >= disp.disputeUintVars[keccak256(\"minExecutionDate\")],\r\n            \"Time for voting haven't elapsed\"\r\n        );\r\n        require(\r\n            disp.reportingParty != address(0),\r\n            \"reporting Party is address 0\"\r\n        );\r\n        int256 _tally = disp.tally;\r\n        if (_tally > 0) {\r\n            //Set the dispute state to passed/true\r\n            disp.disputeVotePassed = true;\r\n        }\r\n        //If the vote is not a proposed fork\r\n        if (disp.isPropFork == false) {\r\n            //Ensure the time for voting has elapsed\r\n            TellorStorage.StakeInfo storage stakes =\r\n                self.stakerDetails[disp.reportedMiner];\r\n            //If the vote for disputing a value is successful(disp.tally >0) then unstake the reported\r\n            // miner and transfer the stakeAmount and dispute fee to the reporting party\r\n            if (stakes.currentStatus == 3) {\r\n                stakes.currentStatus = 4;\r\n            }\r\n        } else if (\r\n            uint256(_tally) >=\r\n            ((self.uintVars[keccak256(\"total_supply\")] * 10) / 100)\r\n        ) {\r\n            emit NewTellorAddress(disp.proposedForkAddress);\r\n        }\r\n        disp.disputeUintVars[keccak256(\"tallyDate\")] = now;\r\n        disp.executed = true;\r\n        emit DisputeVoteTallied(\r\n            _disputeId,\r\n            _tally,\r\n            disp.reportedMiner,\r\n            disp.reportingParty,\r\n            disp.disputeVotePassed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Allows for a fork to be proposed\r\n     * @param _propNewTellorAddress address for new proposed Tellor\r\n     */\r\n    function proposeFork(\r\n        TellorStorage.TellorStorageStruct storage self,\r\n        address _propNewTellorAddress\r\n    ) public {\r\n        bytes32 _hash = keccak256(abi.encode(_propNewTellorAddress));\r\n        self.uintVars[keccak256(\"disputeCount\")]++;\r\n        uint256 disputeId = self.uintVars[keccak256(\"disputeCount\")];\r\n        if (self.disputeIdByDisputeHash[_hash] != 0) {\r\n            self.disputesById[disputeId].disputeUintVars[\r\n                keccak256(\"origID\")\r\n            ] = self.disputeIdByDisputeHash[_hash];\r\n        } else {\r\n            self.disputeIdByDisputeHash[_hash] = disputeId;\r\n        }\r\n        uint256 origID = self.disputeIdByDisputeHash[_hash];\r\n\r\n        self.disputesById[origID].disputeUintVars[keccak256(\"disputeRounds\")]++;\r\n        uint256 dispRounds =\r\n            self.disputesById[origID].disputeUintVars[\r\n                keccak256(\"disputeRounds\")\r\n            ];\r\n        self.disputesById[origID].disputeUintVars[\r\n            keccak256(abi.encode(dispRounds))\r\n        ] = disputeId;\r\n        if (disputeId != origID) {\r\n            uint256 lastID =\r\n                self.disputesById[origID].disputeUintVars[\r\n                    keccak256(abi.encode(dispRounds - 1))\r\n                ];\r\n            require(\r\n                self.disputesById[lastID].disputeUintVars[\r\n                    keccak256(\"minExecutionDate\")\r\n                ] <= now,\r\n                \"Dispute is already open\"\r\n            );\r\n            if (self.disputesById[lastID].executed) {\r\n                require(\r\n                    now -\r\n                        self.disputesById[lastID].disputeUintVars[\r\n                            keccak256(\"tallyDate\")\r\n                        ] <=\r\n                        1 days,\r\n                    \"Time for voting haven't elapsed\"\r\n                );\r\n            }\r\n        }\r\n        self.disputesById[disputeId] = TellorStorage.Dispute({\r\n            hash: _hash,\r\n            isPropFork: true,\r\n            reportedMiner: msg.sender,\r\n            reportingParty: msg.sender,\r\n            proposedForkAddress: _propNewTellorAddress,\r\n            executed: false,\r\n            disputeVotePassed: false,\r\n            tally: 0\r\n        });\r\n        TellorTransfer.doTransfer(\r\n            self,\r\n            msg.sender,\r\n            address(this),\r\n            100e18 * 2**(dispRounds - 1)\r\n        ); //This is the fork fee (just 100 tokens flat, no refunds.  Goes up quickly to dispute a bad vote)\r\n        self.disputesById[disputeId].disputeUintVars[\r\n            keccak256(\"blockNumber\")\r\n        ] = block.number;\r\n        self.disputesById[disputeId].disputeUintVars[\r\n            keccak256(\"minExecutionDate\")\r\n        ] = now + 7 days;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"newVersion\")] =\r\n            self.uintVars[keccak256(\"version\")] +\r\n            1;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the Tellor address after a proposed fork has\r\n     * passed the vote and day has gone by without a dispute\r\n     * @param _disputeId the disputeId for the proposed fork\r\n     */\r\n    function updateTellor(\r\n        TellorStorage.TellorStorageStruct storage self,\r\n        uint256 _disputeId\r\n    ) public {\r\n        bytes32 _hash = self.disputesById[_disputeId].hash;\r\n        uint256 origID = self.disputeIdByDisputeHash[_hash];\r\n        uint256 lastID =\r\n            self.disputesById[origID].disputeUintVars[\r\n                keccak256(\r\n                    abi.encode(\r\n                        self.disputesById[origID].disputeUintVars[\r\n                            keccak256(\"disputeRounds\")\r\n                        ]\r\n                    )\r\n                )\r\n            ];\r\n        TellorStorage.Dispute storage disp = self.disputesById[lastID];\r\n        require(\r\n            disp.disputeUintVars[keccak256(\"newVersion\")] >\r\n                self.uintVars[keccak256(\"version\")],\r\n            \"can't upgrade to older version\"\r\n        );\r\n        require(disp.isPropFork, \"is not a propose fork dispute\");\r\n        require(\r\n            disp.proposedForkAddress != address(0),\r\n            \"can't migrate to zero address\"\r\n        );\r\n        require(disp.disputeVotePassed == true, \"vote needs to pass\");\r\n        require(\r\n            now - disp.disputeUintVars[keccak256(\"tallyDate\")] > 1 days,\r\n            \"Time for voting for further disputes has not passed\"\r\n        );\r\n        self.uintVars[keccak256(\"version\")] = disp.disputeUintVars[\r\n            keccak256(\"newVersion\")\r\n        ];\r\n        self.addressVars[keccak256(\"tellorContract\")] = disp\r\n            .proposedForkAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows disputer to unlock the dispute fee\r\n     * @param _disputeId to unlock fee from\r\n     */\r\n    function unlockDisputeFee(\r\n        TellorStorage.TellorStorageStruct storage self,\r\n        uint256 _disputeId\r\n    ) public {\r\n        uint256 origID =\r\n            self.disputeIdByDisputeHash[self.disputesById[_disputeId].hash];\r\n        uint256 lastID =\r\n            self.disputesById[origID].disputeUintVars[\r\n                keccak256(\r\n                    abi.encode(\r\n                        self.disputesById[origID].disputeUintVars[\r\n                            keccak256(\"disputeRounds\")\r\n                        ]\r\n                    )\r\n                )\r\n            ];\r\n        if (lastID == 0) {\r\n            lastID = origID;\r\n        }\r\n        TellorStorage.Dispute storage disp = self.disputesById[origID];\r\n        TellorStorage.Dispute storage last = self.disputesById[lastID];\r\n        //disputeRounds is increased by 1 so that the _id is not a negative number when it is the first time a dispute is initiated\r\n        uint256 dispRounds = disp.disputeUintVars[keccak256(\"disputeRounds\")];\r\n        if (dispRounds == 0) {\r\n            dispRounds = 1;\r\n        }\r\n        uint256 _id;\r\n        require(\r\n            disp.disputeUintVars[keccak256(\"paid\")] == 0,\r\n            \"already paid out\"\r\n        );\r\n        require(\r\n            now - last.disputeUintVars[keccak256(\"tallyDate\")] > 1 days,\r\n            \"Time for voting haven't elapsed\"\r\n        );\r\n        TellorStorage.StakeInfo storage stakes =\r\n            self.stakerDetails[disp.reportedMiner];\r\n        disp.disputeUintVars[keccak256(\"paid\")] = 1;\r\n        if (last.disputeVotePassed == true) {\r\n            //Changing the currentStatus and startDate unstakes the reported miner and transfers the stakeAmount\r\n            stakes.startDate = now - (now % 86400);\r\n\r\n            //Reduce the staker count\r\n            self.uintVars[keccak256(\"stakerCount\")] -= 1;\r\n\r\n            //Update the minimum dispute fee that is based on the number of stakers\r\n            updateMinDisputeFee(self);\r\n            //Decreases the stakerCount since the miner's stake is being slashed\r\n            if (stakes.currentStatus == 4) {\r\n                stakes.currentStatus = 5;\r\n                TellorTransfer.doTransfer(\r\n                    self,\r\n                    disp.reportedMiner,\r\n                    disp.reportingParty,\r\n                    self.uintVars[keccak256(\"stakeAmount\")]\r\n                );\r\n                stakes.currentStatus = 0;\r\n            }\r\n            for (uint256 i = 0; i < dispRounds; i++) {\r\n                _id = disp.disputeUintVars[\r\n                    keccak256(abi.encode(dispRounds - i))\r\n                ];\r\n                if (_id == 0) {\r\n                    _id = origID;\r\n                }\r\n                TellorStorage.Dispute storage disp2 = self.disputesById[_id];\r\n                //transfer fee adjusted based on number of miners if the minerIndex is not 2(official value)\r\n                TellorTransfer.doTransfer(\r\n                    self,\r\n                    address(this),\r\n                    disp2.reportingParty,\r\n                    disp2.disputeUintVars[keccak256(\"fee\")]\r\n                );\r\n            }\r\n        } else {\r\n            stakes.currentStatus = 1;\r\n            TellorStorage.Request storage _request =\r\n                self.requestDetails[\r\n                    disp.disputeUintVars[keccak256(\"requestId\")]\r\n                ];\r\n            if (disp.disputeUintVars[keccak256(\"minerSlot\")] == 2) {\r\n                //note we still don't put timestamp back into array (is this an issue? (shouldn't be))\r\n                _request.finalValues[\r\n                    disp.disputeUintVars[keccak256(\"timestamp\")]\r\n                ] = disp.disputeUintVars[keccak256(\"value\")];\r\n            }\r\n            if (\r\n                _request.inDispute[\r\n                    disp.disputeUintVars[keccak256(\"timestamp\")]\r\n                ] == true\r\n            ) {\r\n                _request.inDispute[\r\n                    disp.disputeUintVars[keccak256(\"timestamp\")]\r\n                ] = false;\r\n            }\r\n            for (uint256 i = 0; i < dispRounds; i++) {\r\n                _id = disp.disputeUintVars[\r\n                    keccak256(abi.encode(dispRounds - i))\r\n                ];\r\n                if (_id != 0) {\r\n                    last = self.disputesById[_id]; //handling if happens during an upgrade\r\n                }\r\n                TellorTransfer.doTransfer(\r\n                    self,\r\n                    address(this),\r\n                    last.reportedMiner,\r\n                    self.disputesById[_id].disputeUintVars[keccak256(\"fee\")]\r\n                );\r\n            }\r\n        }\r\n\r\n        if (disp.disputeUintVars[keccak256(\"minerSlot\")] == 2) {\r\n            self.requestDetails[disp.disputeUintVars[keccak256(\"requestId\")]]\r\n                .apiUintVars[keccak256(\"disputeCount\")]--;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This function updates the minimum dispute fee as a function of the amount\r\n     * of staked miners\r\n     */\r\n    function updateMinDisputeFee(TellorStorage.TellorStorageStruct storage self)\r\n        public\r\n    {\r\n        uint256 stakeAmount = self.uintVars[keccak256(\"stakeAmount\")];\r\n        uint256 targetMiners = self.uintVars[keccak256(\"targetMiners\")];\r\n        self.uintVars[keccak256(\"disputeFee\")] = SafeMath.max(\r\n            15e18,\r\n            (stakeAmount -\r\n                ((stakeAmount *\r\n                    (SafeMath.min(\r\n                        targetMiners,\r\n                        self.uintVars[keccak256(\"stakerCount\")]\r\n                    ) * 1000)) / targetMiners) /\r\n                1000)\r\n        );\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"_result\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reportedMiner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_reportingParty\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"DisputeVoteTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_miner\",\"type\":\"address\"}],\"name\":\"NewDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newTellor\",\"type\":\"address\"}],\"name\":\"NewTellorAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_position\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_voteWeight\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"}]","ContractName":"TellorDispute","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"5000000","ConstructorArguments":"","EVMVersion":"Default","Library":"TellorTransfer:b78cf2155b59e2696cb885bf548ed6663258be0b","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://54054cd71295db5d82262c571feedaf06f1bbbfaff8664684b89f1456504b9ab"}]}