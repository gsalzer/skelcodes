pragma solidity ^0.5.17;  library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {  if (a == 0) { return 0; }  c = a * b; assert(c / a == b); return c; }   function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; }   function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; }   function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } }   contract Ownable { address public owner;   event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner );   constructor() public { owner = msg.sender; }   modifier onlyOwner() { require(msg.sender == owner); _; }   function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); }   function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); }   function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } }    contract Destructible is Ownable {  constructor() public payable { }   }    contract ERC20Basic  { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); }   contract BasicToken is ERC20Basic { using SafeMath for uint256;  mapping(address => uint256) balances;  uint256 totalSupply_;  function totalSupply() public view returns (uint256) { return totalSupply_; }  function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]);  balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; }   function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }  } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256);  function transferFrom(address from, address to, uint256 value) public returns (bool);  function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); }    contract StandardToken is ERC20, BasicToken {  mapping (address => mapping (address => uint256)) internal allowed;   function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]);  balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }  function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }   function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; }   function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }   function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; }  }     contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); }  function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } }    contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished();  bool public mintingFinished = false;   modifier canMint() { require(!mintingFinished); _; }  modifier hasMintPermission() { require(msg.sender == owner); _; }   function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; }  function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } }     library Roles { struct Role { mapping (address => bool) bearer; }  function add(Role storage role, address addr) internal { role.bearer[addr] = true; }  function remove(Role storage role, address addr) internal { role.bearer[addr] = false; }  function check(Role storage role, address addr) view internal { require(has(role, addr)); }  function has(Role storage role, address addr) view internal returns (bool) { return role.bearer[addr]; } }    contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address indexed operator, string role); event RoleRemoved(address indexed operator, string role);  function checkRole(address _operator, string memory _role) view public { roles[_role].check(_operator); }  function hasRole(address _operator, string memory _role) view public returns (bool) { return roles[_role].has(_operator); }   function addRole(address _operator, string memory _role) internal { roles[_role].add(_operator); emit RoleAdded(_operator, _role); }   function removeRole(address _operator, string memory _role) internal { roles[_role].remove(_operator); emit RoleRemoved(_operator, _role); }   modifier onlyRole(string memory _role) { checkRole(msg.sender, _role); _; }   }     contract RBACMintableToken is MintableToken, RBAC { string public constant ROLE_MINTER = "minter"; modifier hasMintPermission() { checkRole(msg.sender, ROLE_MINTER); _; }   function addMinter(address minter) onlyOwner public { addRole(minter, ROLE_MINTER); }  function removeMinter(address minter) onlyOwner public { removeRole(minter, ROLE_MINTER); } }    contract Pausable is Ownable { event Pause(); event Unpause();  bool public paused = false;    modifier whenNotPaused() { require(!paused); _; }   modifier whenPaused() { require(paused); _; }   function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); }   function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } }     contract PausableToken is StandardToken, Pausable {  function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); }  function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); }  function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); }  function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); }  function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } }     contract RestorableToken is PausableToken { event Restore(address indexed from, address indexed to, uint256 value); function _restoreTokens(address _from,address _to) onlyOwner internal returns (bool) { require(_to != address(0)); uint value = balances[_from]; balances[_from] = balances[_from].sub(value); balances[_to] = balances[_to].add(value); emit Restore(_from, _to, value); return true; }  }   contract AccessList is Ownable, RBAC{ string constant public ROLE_MAINTAINER = "maintainer"; function isOwner() public view returns (bool){ return(msg.sender == owner); }  modifier onlyMaintainer() { require(isOwner() || hasRole(msg.sender, ROLE_MAINTAINER)); _; }  function isMaintainer() public view returns(bool){ return hasRole(msg.sender, ROLE_MAINTAINER) || isOwner(); }  function addMaintainer(address _addr) onlyOwner public { require(!hasRole(_addr, ROLE_MAINTAINER)); addRole(_addr, ROLE_MAINTAINER); }  function removeMaintainer(address _addr) onlyOwner public { require(hasRole(_addr, ROLE_MAINTAINER)); removeRole(_addr, ROLE_MAINTAINER); } }   contract ManagedMintableToken is RBACMintableToken,RestorableToken,AccessList{  function wasMintingFinished() internal view returns(bool){ return mintingFinished; }   modifier hasMintPermission() { require(isMaintainer()); _; }   function multiMint(address[] memory _investors ,uint256[] memory _amounts) onlyMaintainer public returns (bool){ require(_investors.length == _amounts.length,"The number of investors and amounts should be the same"); require(_investors.length > 0,"The investors address should be provided"); require(!mintingFinished,"Minting already finished"); uint len = _investors.length; for (uint i=0; i< len; i++) { address investor = _investors[i]; uint256 amount = _amounts[i]; mint(investor,amount); } return true; } }  contract ManagedBurnableToken is BurnableToken,ManagedMintableToken{ function burn(uint256) public { revert("Only maintainer is allowed to burn tokens"); }   function _burnTokens(address _account, uint256 _amount) onlyMaintainer internal { require(_account != address(0)); require(!mintingFinished,"Can burn only before the minitng was finished"); super._burn(_account,_amount); } }  contract WhiteListToken is ManagedBurnableToken{ event InvestorAddedToWhiteList(address indexed investorAddress,bool isAccredited,bool isFreezeWaiver,bool isFrozen); event InvestorRemovedFromWhiteList(address indexed investorAddress); event InvestorAccredited(address indexed investorAddress, bool accredited); event InvestorFreeze(address indexed investorAddress, bool freeze); event InvestorFreezeWaiver(address indexed investorAddress, bool waiver); event SetAccreditationDate(address indexed _investorAddress,uint accreditationDate); uint constant private YEAR = 365 days;   uint public numberOfInvestedInvestors;   struct Investor { bool isInitialized; bool isAccredited; uint accreditationDate; bool isFreezeWaiver; bool isFrozen; }   mapping (address => Investor) public investorsMap ;   function isInvestorInWhiteList(address _investorAddress) public view returns(bool) { return investorsMap[_investorAddress].isInitialized; }   function removeInvestorFromWhiteList(address _investorAddress) onlyMaintainer public{ if(!investorsMap[_investorAddress].isInitialized){ return; } delete investorsMap[_investorAddress]; emit InvestorRemovedFromWhiteList(_investorAddress); }   function addInvestorToWhiteList(address _investorAddress, bool _isAccredited, bool _isFreezeWaiver, bool _isFrozen) onlyMaintainer public { require(!investorsMap[_investorAddress].isInitialized,"investor allready whitelisted");  uint accreditationDate = 0; if(_isAccredited){ accreditationDate = now; } investorsMap[_investorAddress] = Investor(true, _isAccredited, accreditationDate, _isFreezeWaiver, _isFrozen ); emit InvestorAddedToWhiteList(_investorAddress,_isAccredited,_isFreezeWaiver,_isFrozen); }  function addInvestorsToWhiteList(address[] memory _investors, bool[] memory _isAccredited, bool[] memory _isFreezeWaiver, bool[] memory _isFrozen) onlyMaintainer public { require(_investors.length == _isAccredited.length, "The accredited array should be the same length as investors one"); require(_investors.length == _isFreezeWaiver.length, "The waiver array should be the same length as investors one"); require(_investors.length == _isFrozen.length, "The frozen array should be the same length as investors one"); uint arrayLength = _investors.length; for (uint i=0; i < arrayLength; i++) { addInvestorToWhiteList(_investors[i],_isAccredited[i],_isFreezeWaiver[i],_isFrozen[i]); } }   function addInvestorToWhiteListAndMint(address _investor, uint256 _amount, bool _isAccredited, bool _isFreezeWaiver, bool _isFrozen ) onlyMaintainer public { addInvestorToWhiteList(_investor,_isAccredited,_isFreezeWaiver,_isFrozen); mint(_investor, _amount); }   function setAccredited(address _investorAddress,bool _isAccredited) onlyMaintainer public { require(investorsMap[_investorAddress].isInitialized,"No investor exists");  if (_isAccredited) { investorsMap[_investorAddress].accreditationDate = now; } investorsMap[_investorAddress].isAccredited = _isAccredited; emit InvestorAccredited(_investorAddress, _isAccredited); }   function setAcreditationDate(address _investorAddress, uint accreditationDate) onlyMaintainer public { require(investorsMap[_investorAddress].isInitialized); investorsMap[_investorAddress].accreditationDate = accreditationDate; emit SetAccreditationDate(_investorAddress,accreditationDate); }   function setInvestorFreezeWaiver(address _investorAddress, bool _isFreezeWaiver) onlyMaintainer public { require(investorsMap[_investorAddress].isInitialized); investorsMap[_investorAddress].isFreezeWaiver = _isFreezeWaiver; emit InvestorFreezeWaiver(_investorAddress,_isFreezeWaiver); }   function isFreezeWaiver(address _investorAddress) public view returns(bool) { if(!investorsMap[_investorAddress].isInitialized){ return false; } return investorsMap[_investorAddress].isFreezeWaiver; }   function isAccreditedInvestor(address _investorAddress) public view returns(bool){ if(!investorsMap[_investorAddress].isInitialized){ return false; } if(!investorsMap[_investorAddress].isAccredited){ return false; } if((investorsMap[_investorAddress].accreditationDate + YEAR) < now){ return false; } return true; }   function setFrozenInvestor(address _investorAddress, bool _isFrozen) public onlyMaintainer { require(investorsMap[_investorAddress].isInitialized, "investor is not initialized"); investorsMap[_investorAddress].isFrozen = _isFrozen; emit InvestorFreeze(_investorAddress, _isFrozen); }   function setFrozenInvestors(address[] memory _investors, bool _isFrozen) public onlyMaintainer { uint arrayLength = _investors.length; for (uint i=0; i < arrayLength; i++) { address investor = _investors[i]; if (investorsMap[investor].isInitialized) { investorsMap[investor].isFrozen = _isFrozen; emit InvestorFreeze(investor, _isFrozen); } } }   function isFrozenInvestor(address _investorAddress) public view returns(bool){ return investorsMap[_investorAddress].isFrozen; }   function updateInvestedCounter( address _from, address _to, uint256 _value ) internal { if(_value == 0){ return; } if(_from == _to){ return; }  uint investorsCC = numberOfInvestedInvestors;  if(balances[_from] <= _value){ investorsCC = investorsCC.sub(1); } if(balances[_to] == 0){ investorsCC = investorsCC.add(1); } if(investorsCC != numberOfInvestedInvestors){ numberOfInvestedInvestors = investorsCC; } }   function canMintCheck(address _investorAddress,uint ) internal view returns (bool){ if(!investorsMap[_investorAddress].isInitialized){ return false; } if(!investorsMap[_investorAddress].isAccredited){ return false; } return !wasMintingFinished(); }   function canFinishMinting() internal view returns (bool){ return !wasMintingFinished(); }   function mint(address _to, uint256 _value) onlyMaintainer public returns (bool){ require(canMintCheck(_to, _value), "investor is not whitelisted"); uint oldBalance = balances[_to]; bool mintResult = super.mint(_to,_value); uint newBalance = balances[_to]; if(oldBalance == 0 && newBalance > 0){ numberOfInvestedInvestors = numberOfInvestedInvestors.add(1); } return mintResult; }   function _burnTokens(address _from, uint256 _value) onlyMaintainer internal{ uint oldBalance = balances[_from]; super._burnTokens(_from,_value); uint newBalance = balances[_from]; if(oldBalance > 0 && newBalance == 0){ numberOfInvestedInvestors = numberOfInvestedInvestors.sub(1); } }   function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(isInvestorInWhiteList(_to), "The _to investor is not in white list"); require(isAccreditedInvestor(_to), "The reciever is not accredited"); require(!isFrozenInvestor(_to), "The _to investor is frozen"); require(!isFrozenInvestor(_from), "The _from investor is frozen"); updateInvestedCounter(_from,_to,_value); return super.transferFrom(_from,_to,_value); }   function transfer(address _to, uint256 _value) public returns (bool) {  require(isInvestorInWhiteList(_to), "The _to investor not in white list"); require(isInvestorInWhiteList(msg.sender), "The sender investor not in white list"); require(isAccreditedInvestor(_to), "The reciever is not accredited"); require(!isFrozenInvestor(_to), "The _to investor is frozen"); require(!isFrozenInvestor(msg.sender), "The sender investor is frozen"); updateInvestedCounter(msg.sender,_to,_value); return super.transfer(_to,_value); } }   contract RegulationDToken is WhiteListToken{ event StartFreezePeriod(); event StartFreezePeriodSet(uint startFreezePeriodDate); event DefaultFreezePeriod(uint defaultFreezePeriod); event MinFreezePeriod(uint minFreezePeriod);   uint public minFreezePeriod = 90 days;   uint public defaultFreezePeriod = 365 days;  uint public startFreezePeriodDate;   function setMinFreezePeriod(uint _minFreezePeriod) onlyMaintainer public{ minFreezePeriod = _minFreezePeriod; emit MinFreezePeriod(minFreezePeriod); }   function setDefaultFreezePeriod(uint _defaultFreezePeriod) onlyMaintainer public{ defaultFreezePeriod = _defaultFreezePeriod; emit DefaultFreezePeriod(defaultFreezePeriod); }   function setStartFreezePeriod(uint _startFreezePeriodDate) onlyOwner public{ startFreezePeriodDate = _startFreezePeriodDate; emit StartFreezePeriodSet(startFreezePeriodDate); }  function startFreezePeriod() onlyMaintainer internal { startFreezePeriodDate = now; emit StartFreezePeriod(); }   function isFrozenSell(address _investorAddress) internal view returns(bool){ uint256 endPeriod = startFreezePeriodDate.add(minFreezePeriod); if(isFreezeWaiver(_investorAddress)){ return (endPeriod >= now); }  endPeriod = startFreezePeriodDate.add(defaultFreezePeriod); return (endPeriod >= now); }   function canInvestorBuy(address _investorAddress) internal view returns (bool){ if(!isInvestorInWhiteList(_investorAddress)){ return false; } if(!isAccreditedInvestor(_investorAddress)){ return false; } return true; }   function canInvestorSell(address _investorAddress) internal view returns (bool){ if(!isInvestorInWhiteList(_investorAddress)){ return false; } return !isFrozenSell(_investorAddress); }   function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(canInvestorBuy(_to), "Buying investor is not allowed to buy"); require(canInvestorSell(_from), "Selling investor is not allowed to sell"); return super.transferFrom(_from,_to,_value); }   function transfer(address _to, uint256 _value) public returns (bool) { require(canInvestorBuy(_to), "buying investor is not allowed to buy"); require(canInvestorSell(msg.sender), "selling investor is not allowed to sell"); return super.transfer(_to,_value); }  }   contract REITToken is RegulationDToken{ event MinHoldersSet(uint minHolders); event MinimumTokensPerInvestorSet(uint minimumTokensPerInvestor); event EnforceMinHoldersSet(bool enforceMinHolders); event EnforceMaxSingleHolding(bool enforceMaxSingleHolding); uint public minHolders = 100; bool public enforceMinHolders = true;  bool public enforceMaxSingleHolding = false;  uint constant private percentCorrection = 10000;  uint public maxSingleHolding = 980;   uint public minimumTokensPerInvestor = 10000;   function setMinHolders(uint _minHolders) onlyOwner public { minHolders = _minHolders; emit MinHoldersSet(minHolders); }   function setMinimumTokensPerInvestor(uint _minTokens) onlyOwner public { minimumTokensPerInvestor = _minTokens; emit MinimumTokensPerInvestorSet(minimumTokensPerInvestor); }   function setEnforceMinHolders(bool _enforceMinHolders) onlyOwner public { enforceMinHolders = _enforceMinHolders; emit EnforceMinHoldersSet(enforceMinHolders); }   function setEnforceMaxSingleHolding(bool _enforceMaxSingleHolding) onlyOwner public { enforceMaxSingleHolding = _enforceMaxSingleHolding; emit EnforceMaxSingleHolding(enforceMaxSingleHolding); }   function minTokensPerInvestorValid(uint _balance) internal view returns (bool){ return (_balance >= minimumTokensPerInvestor || _balance == 0); }   function maxSingleHoldingValid(address _investor, uint256 _amount) internal view returns (bool){ if(!enforceMaxSingleHolding){ return true; }  uint256 newToBalance = balances[_investor].add(_amount); uint256 newBalancePercentage = newToBalance.mul(percentCorrection); uint256 mulHoldingAndSupply = maxSingleHolding.mul(totalSupply_); return (newBalancePercentage <= mulHoldingAndSupply); }   function minHoldersValid(address _from,address _to,uint _amount) internal view returns (bool){ if(!enforceMinHolders){ return true; } uint newNumberOfInvestedInvestors = numberOfInvestedInvestors; if(balances[_from] <= _amount){ newNumberOfInvestedInvestors = newNumberOfInvestedInvestors.sub(1); } if(balances[_to] == 0){ newNumberOfInvestedInvestors = newNumberOfInvestedInvestors.add(1); } return (newNumberOfInvestedInvestors >= minHolders); }   function currentMinHoldersValid() internal view returns (bool){ if(!enforceMinHolders){ return true; } return (numberOfInvestedInvestors >= minHolders); }   function canFinishMinting() internal view returns (bool){ if(!currentMinHoldersValid()){ return false; }  return super.canFinishMinting(); }   function canMintCheck(address _investorAddress,uint _amount) internal view returns (bool){ if(!minTokensPerInvestorValid(_amount)){ return false; } return super.canMintCheck(_investorAddress,_amount); }   function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { uint senderNewBalance = balances[_from].sub(_value); uint receiverNewBalance = balances[_to].add(_value); require(minTokensPerInvestorValid(senderNewBalance),"exceeding minimal investor balance for sender"); require(minTokensPerInvestorValid(receiverNewBalance),"exceeding minimal investor balance for receiver"); require(maxSingleHoldingValid(_to,_value),"exceeding maximal investor holding"); require(minHoldersValid(_from,_to,_value),"exceeding minimal number of investors"); return super.transferFrom(_from,_to,_value); }   function transfer(address _to, uint256 _value) public returns (bool) { uint senderNewBalance = balances[msg.sender].sub(_value); uint receiverNewBalance = balances[_to].add(_value); require(minTokensPerInvestorValid(senderNewBalance),"exceeding minimal investor balance for sender"); require(minTokensPerInvestorValid(receiverNewBalance),"exceeding minimal investor balance for receiver"); require(maxSingleHoldingValid(_to,_value),"exceeding maximal investor holding"); require(minHoldersValid(msg.sender,_to,_value),"exceeding minimal number of investors"); return super.transfer(_to,_value); } }   contract UnlistedREITToken is REITToken{ using SafeMath for uint256; event MaxInvestors(uint maxInvestors);   uint public maxInvestors = 2000;   function setMaxInvestors(uint _maxInvestors) public onlyOwner{ maxInvestors = _maxInvestors; emit MaxInvestors(maxInvestors); }  function canFinishMinting() internal view returns (bool){ if (numberOfInvestedInvestors > maxInvestors){ return false; } return super.canFinishMinting(); }   function maxTotalInvestorsValid(address _from,  address _to, uint256 _amount) internal view returns(bool) {  if(_amount == 0){ return true; }  if(balances[_to] > 0){ return true; }  if (balances[_from] <= _amount) { return true; } if ((numberOfInvestedInvestors.add(1)) > maxInvestors) { return false; } return true; }   function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(maxTotalInvestorsValid(_from, _to, _value),"max total investors will be illegal after transfer"); return super.transferFrom(_from,_to,_value); }   function transfer(address _to, uint256 _value) public returns (bool) { require(maxTotalInvestorsValid(msg.sender, _to, _value),"max total investors will be illegal after transfer"); return super.transfer(_to,_value); }  }   contract LDBToken is UnlistedREITToken, Destructible{ using SafeMath for uint256; event HardCapSet(uint hardCap); string public constant name = "London Digital Bond"; string public constant symbol = "LDB"; string public constant assetName = "London Chelsea Real Estate LLC"; uint8 public constant decimals = 0; uint256 public softCap = 750000; uint public hardCap = 20000000;  string public constant CUSIP = "54180M AA8";   struct ContractInfo { string contractName; string symbol; string AssetName; uint256 softCap; uint256 hardCap; string TypeofSale; string TokenStandard; string IssuerName; string LegalStructure; string IncorporatedWhere; string RegulatoryStructure; string assetAddress; string Mortgage; string NetAssetValue; uint256 MinContribution; uint256 MaxContribution; string SalesStages; string AllowedJurisdictions; string BlacklistedJurisdictions; string KycAndAml; string DigitalCryptoInvestors; string UndersalePolicy; string OversalePolicy; }  string public contractInfo = "contractName: London Digital Bond symbol: LDB AssetName: London Chelsea Real Estate LLC \nsoftCap: 750000 hardCap: 20000000 TypeofSale: Security Token TokenStandard: ERC20 IssuerName: London Chelsea Real Estate LLC LegalStructure: Depository IncorporatedWhere: Delaware LLC RegulatoryStructure: Reg D 506 (c) equivalent in the jurisdiction assetAddress: 729 Ocean Parkway, Brooklyn, New York, 11230 Mortgage: None NetAssetValue: None MinContribution: 5000 MaxContribution: 10000000 SalesStages: No stages or periods for sales AllowedJurisdictions: All except blacklist BlacklistedJurisdictions: Iran; Crimea; North Korea; China; Algeria; Bolivia; Ecuador; Morocco; Pakistan KycAndAml: Handled by North Capital DigitalCryptoInvestors: Handled by Gemini UndersalePolicy: Refund investors: If they in invested in fiat - refunded in fiat; If invested in crypto - refundeded in crypto OversalePolicy: Refund the investors";    function setHardCap(uint _hardCap) public onlyOwner{ hardCap = _hardCap; emit HardCapSet(hardCap); }   function canMintCheck(address _investorAddress,uint _amount) internal view returns (bool){ if(wasMintingFinished()){ return false; } if(totalSupply_.add(_amount) > hardCap){ return false; } return super.canMintCheck(_investorAddress,_amount); }   function canFinishMinting() internal view returns (bool){ if(totalSupply_ > hardCap){ return false; } return super.canFinishMinting(); }    function finishMinting() public onlyOwner returns (bool){ require(canFinishMinting(), "Can't finish minting"); require(super.finishMinting(), "Finish minting failed"); super.startFreezePeriod(); return true; }   function burnTokens(address _from, uint256 _value) public onlyMaintainer { require(!wasMintingFinished(), "minting is not finished"); super._burnTokens(_from,_value); }   function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) {  require(wasMintingFinished(), "cant transfer before minting finishes"); return super.transferFrom(_from,_to,_value); }   function transfer(address _to, uint256 _value) public returns (bool) { require(wasMintingFinished(), "cant transfer before minting finished"); return super.transfer(_to,_value); }  function restoreTokens( address _from, address _to ) public onlyOwner returns (bool) { require(maxSingleHoldingValid(_to, balanceOf(_from)), "restoring tokens will violate max tokens amount per holder"); return super._restoreTokens(_from,_to); }   function mint(address _to, uint256 _value) onlyMaintainer public returns (bool){ require(canMintCheck(_to, _value), "Can't mint"); return super.mint(_to,_value); }  }
