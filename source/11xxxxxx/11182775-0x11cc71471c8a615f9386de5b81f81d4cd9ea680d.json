{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\n//pragma solidity >=0.4.16 <0.7.0;\r\npragma solidity ^0.6.6;\r\n\r\n//import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n// -- LaunchSwap, a contract for launching ventures --\r\n\r\n// investor submit capital and can redeem it at a cost\r\n// for now this is a single instance of the swap\r\n// the owner of the contract defines the mechanics\r\n// owner defines the mid price and the spread\r\n// users swap at the resulting bid and ask\r\n// in first iteration no liquidity pools\r\n\r\n// to visualize this market think of MM as setting only 2 variables\r\n// 1) midprice\r\n// 2) spread\r\n\r\n// resulting offer to buy and sell\r\n// low spread\r\n// ask  | bid\r\n// wide spread\r\n// ask      |     bid\r\n\r\n\r\ncontract LaunchSwap {\r\n\r\n    //VARIABLES\r\n    uint256 mid;\r\n    uint256 spread;\r\n    uint256 cap;\r\n    address private _owner;\r\n    uint deployedAt;\r\n\r\n    //investor_balances mapping\r\n    ////investor_balances[sender]+= tokens;\r\n\r\n    //EVENTS\r\n    //event Bought(uint256 amount);\r\n    //event Sold(uint256 amount);\r\n\r\n    //TODO\r\n    // address constant tokenAddress = address(\r\n    //     0x14eb2ab8e6d09000a98e3166b3cc994375071f69 //ERC20 token address\r\n    // );\r\n\r\n    //mid = 0.03/404\r\n    //0.000075 ETH/RTT\r\n    //74000000000000 \r\n    //amountRaised\r\n    //amountCap\r\n\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n        deployedAt = block.number;\r\n        mid = 300; //cents\r\n        spread = 20;\r\n\r\n        //TODO!\r\n        //token = new ERC20Basic();\r\n    }\r\n\r\n     modifier onlyOwner(){\r\n        //require(msg.sender == owner);\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n     }\r\n\r\n    function setCap(uint256 _cap) public onlyOwner {\r\n        cap = _cap;\r\n    }\r\n\r\n    //only admin can set the mid\r\n    //more complex operations here will make sense later\r\n    //purely algorithmic or driven by pool\r\n    function setMid(uint256 _mid) public { // onlyOwner {\r\n        mid = _mid;\r\n    }\r\n\r\n    //only admin can set spread\r\n    //more complex operations here will make sense later\r\n    //purely algorithmic or driven by pool\r\n    function setSpread(uint256 _spread) public onlyOwner {    \r\n        spread = _spread;\r\n    }\r\n\r\n    //bid calculated from mid and spread\r\n    function getBid() public returns (uint256) {\r\n        uint256 offset = mid * spread;\r\n        uint256 bid = mid - offset;\r\n        return bid;\r\n    }\r\n\r\n\r\n    //put up capital\r\n    //swap eth for tokens\r\n    function investETHForTokens(uint256 amountETH) public payable {\r\n        //TODO: check cap reached?\r\n        //TODO: check if round is open\r\n        \r\n        uint256 ask = getAsk();\r\n        \r\n        uint256 tokensToReceive = amountETH / ask;\r\n\r\n        //uint256 fundBalance = token.balanceOf(address(this));\r\n        require(amountETH > 0, \"Need to send Ether\");\r\n        //require(amountTobuy <= fundBalance, \"Not enough tokens in the reserve\");\r\n        //token.transfer(msg.sender, tokensToReceive);\r\n\r\n        //emit Bought(amountTobuy);\r\n\r\n        //TODO: check variable passed correctly\r\n        //require (msg.value == amountETH)\r\n\r\n        //TODO: send the tokens to msg.sender\r\n        //ERC20(tokenAddress).approve(address spender, uint tokens)\r\n        \r\n        //send tokens\r\n        //ERC20Token invest_token = ERC20Token(tokenAddr);\r\n        //invest_token.transferFrom(_owner, _recipient, 100);\r\n        //token.transfer(msg.sender, tokensReceive);\r\n    }\r\n\r\n    //investUSDCForTokens\r\n    //check cash is received\r\n\r\n    //withdraw capital\r\n    //swap tokens for eth\r\n    function DivestToTokens(uint256 amountTokens) public {\r\n        //check if round\r\n        uint256 bid = getBid();\r\n        \r\n        //require (msg.value == amountETH)\r\n        uint256 receive_eth = amountTokens / bid;\r\n        //cash is received\r\n\r\n        //send tokens\r\n        //ERC20Token tok = ERC20Token(tokenAddr);\r\n        //tok.transferFrom(_owner, _recipient, 100);\r\n    }\r\n\r\n    //ask calculated from mid and spread\r\n    function getAsk() public returns (uint256) {        \r\n        uint256 offset = (mid * spread)/100;\r\n        uint256 ask = mid + offset;\r\n        return ask;\r\n    }\r\n\r\n    function getMid() public view returns (uint) {\r\n        return mid;\r\n    }\r\n\r\n    function getSpread() public view returns (uint) {\r\n        return spread;\r\n    }\r\n\r\n    function getDeployedAt() public view returns (uint) {\r\n        return deployedAt;\r\n    }\r\n        \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"DivestToTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAsk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeployedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSpread\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"investETHForTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mid\",\"type\":\"uint256\"}],\"name\":\"setMid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_spread\",\"type\":\"uint256\"}],\"name\":\"setSpread\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LaunchSwap","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://09a8cb7ac3ca8da0756b157612f39e56b595bf31177910f75839029d9eeca1d9"}]}