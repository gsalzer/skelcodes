{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8; \r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public proposedOwner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Has to be owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _proposedOwner) public onlyOwner {\r\n        require(msg.sender != _proposedOwner, \"Has to be diff than current owner\");\r\n        proposedOwner = _proposedOwner;\r\n    }\r\n\r\n    function claimOwnership() public {\r\n        require(msg.sender == proposedOwner, \"Has to be the proposed owner\");\r\n        emit OwnershipTransferred(owner, proposedOwner);\r\n        owner = proposedOwner;\r\n        proposedOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Has to be unpaused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused, \"Has to be paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n\r\ncontract Whitelist is Ownable {\r\n\r\n    mapping(address => bool) public whitelist;\r\n    address[] public whitelistedAddresses;\r\n    bool public hasWhitelisting = false;\r\n\r\n    event AddedToWhitelist(address[] indexed accounts);\r\n    event RemovedFromWhitelist(address indexed account);\r\n\r\n    modifier onlyWhitelisted() {\r\n        if(hasWhitelisting){\r\n            require(isWhitelisted(msg.sender));\r\n        }\r\n        _;\r\n    }\r\n    \r\n    constructor (bool _hasWhitelisting) public{\r\n        hasWhitelisting = _hasWhitelisting;\r\n    }\r\n\r\n    function add(address[] memory _addresses) public onlyOwner {\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            require(whitelist[_addresses[i]] != true);\r\n            whitelist[_addresses[i]] = true;\r\n            whitelistedAddresses.push(_addresses[i]);\r\n        }\r\n        emit AddedToWhitelist(_addresses);\r\n    }\r\n\r\n    function remove(address _address, uint256 _index) public onlyOwner {\r\n        require(_address == whitelistedAddresses[_index]);\r\n        whitelist[_address] = false;\r\n        delete whitelistedAddresses[_index];\r\n        emit RemovedFromWhitelist(_address);\r\n    }\r\n\r\n    function getWhitelistedAddresses() public view returns(address[] memory) {\r\n        return whitelistedAddresses;\r\n    } \r\n\r\n    function isWhitelisted(address _address) public view returns(bool) {\r\n        return whitelist[_address];\r\n    }\r\n}\r\n\r\ncontract FixedSwap is Pausable, Whitelist {\r\n    using SafeMath for uint256;\r\n    uint256 increment = 0;\r\n\r\n    mapping(uint256 => Purchase) public purchases; /* Purchasers mapping */\r\n    address[] public buyers; /* Current Buyers Addresses */\r\n    uint256[] public purchaseIds; /* All purchaseIds */\r\n    mapping(address => uint256[]) public myPurchases; /* Purchasers mapping */\r\n\r\n    ERC20 public erc20;\r\n    bool public isSaleFunded = false;\r\n    uint public decimals = 0;\r\n    bool public unsoldTokensReedemed = false;\r\n    uint256 public tradeValue; /* Price in Wei */\r\n    uint256 public startDate; /* Start Date  */\r\n    uint256 public endDate;  /* End Date  */\r\n    uint256 public individualMinimumAmount = 0;  /* Minimum Amount Per Address */\r\n    uint256 public individualMaximumAmount = 0;  /* Minimum Amount Per Address */\r\n    uint256 public minimumRaise = 0;  /* Minimum Amount of Tokens that have to be sold */\r\n    uint256 public tokensAllocated = 0; /* Tokens Available for Allocation - Dynamic */\r\n    uint256 public tokensForSale = 0; /* Tokens Available for Sale */\r\n    bool    public isTokenSwapAtomic; /* Make token release atomic or not */\r\n    address payable public FEE_ADDRESS = 0xAEb39b67F27b641Ef9F95fB74F1A46b1EE4Efc83; /* Default Address for Fee Percentage */\r\n    uint256 public feePercentage = 1; /* Default Fee 1% */\r\n\r\n    struct Purchase {\r\n        uint256 amount;\r\n        address purchaser;\r\n        uint256 ethAmount;\r\n        uint256 timestamp;\r\n        bool wasFinalized /* Confirm the tokens were sent already */;\r\n        bool reverted /* Confirm the tokens were sent already */;\r\n    }\r\n\r\n    event PurchaseEvent(uint256 amount, address indexed purchaser, uint256 timestamp);\r\n\r\n    constructor(address _tokenAddress, uint256 _tradeValue, uint256 _tokensForSale, uint256 _startDate, \r\n        uint256 _endDate, uint256 _individualMinimumAmount, uint256 _individualMaximumAmount, bool _isTokenSwapAtomic, uint256 _minimumRaise,\r\n        uint256 _feeAmount, bool _hasWhitelisting\r\n    ) public Whitelist(_hasWhitelisting) {\r\n        \r\n        /* Confirmations */\r\n        require(block.timestamp < _endDate, \"End Date should be further than current date\");\r\n        require(block.timestamp < _startDate, \"End Date should be further than current date\");\r\n        require(_startDate < _endDate, \"End Date higher than Start Date\");\r\n        require(_tokensForSale > 0, \"Tokens for Sale should be > 0\");\r\n        require(_tokensForSale > _individualMinimumAmount, \"Tokens for Sale should be > Individual Minimum Amount\");\r\n        require(_individualMaximumAmount >= _individualMinimumAmount, \"Individual Maximim AMount should be > Individual Minimum Amount\");\r\n        require(_minimumRaise <= _tokensForSale, \"Minimum Raise should be < Tokens For Sale\");\r\n        require(_feeAmount >= feePercentage, \"Fee Percentage has to be >= 1\");\r\n        require(_feeAmount <= 99, \"Fee Percentage has to be < 100\");\r\n\r\n        startDate = _startDate; \r\n        endDate = _endDate;\r\n        tokensForSale = _tokensForSale;\r\n        tradeValue = _tradeValue;\r\n\r\n        individualMinimumAmount = _individualMinimumAmount; \r\n        individualMaximumAmount = _individualMaximumAmount; \r\n        isTokenSwapAtomic = _isTokenSwapAtomic;\r\n\r\n        if(!_isTokenSwapAtomic){ /* If raise is not atomic swap */\r\n            minimumRaise = _minimumRaise;\r\n        }\r\n\r\n        erc20 = ERC20(_tokenAddress);\r\n        decimals = erc20.decimals();\r\n        feePercentage = _feeAmount;\r\n    }\r\n\r\n    /**\r\n    * Modifier to make a function callable only when the contract has Atomic Swaps not available.\r\n    */\r\n    modifier isNotAtomicSwap() {\r\n        require(!isTokenSwapAtomic, \"Has to be non Atomic swap\");\r\n        _;\r\n    }\r\n\r\n     /**\r\n    * Modifier to make a function callable only when the contract has Atomic Swaps not available.\r\n    */\r\n    modifier isSaleFinalized() {\r\n        require(hasFinalized(), \"Has to be finalized\");\r\n        _;\r\n    }\r\n\r\n     /**\r\n    * Modifier to make a function callable only when the swap time is open.\r\n    */\r\n    modifier isSaleOpen() {\r\n        require(isOpen(), \"Has to be open\");\r\n        _;\r\n    }\r\n\r\n     /**\r\n    * Modifier to make a function callable only when the contract has Atomic Swaps not available.\r\n    */\r\n    modifier isSalePreStarted() {\r\n        require(isPreStart(), \"Has to be pre-started\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * Modifier to make a function callable only when the contract has Atomic Swaps not available.\r\n    */\r\n    modifier isFunded() {\r\n        require(isSaleFunded, \"Has to be funded\");\r\n        _;\r\n    }\r\n\r\n\r\n    /* Get Functions */\r\n    function isBuyer(uint256 purchase_id) public view returns (bool) {\r\n        return (msg.sender == purchases[purchase_id].purchaser);\r\n    }\r\n\r\n    /* Get Functions */\r\n    function totalRaiseCost() public view returns (uint256) {\r\n        return (cost(tokensForSale));\r\n    }\r\n\r\n    function availableTokens() public view returns (uint256) {\r\n        return erc20.balanceOf(address(this));\r\n    }\r\n\r\n    function tokensLeft() public view returns (uint256) {\r\n        return tokensForSale - tokensAllocated;\r\n    }\r\n\r\n    function hasMinimumRaise() public view returns (bool){\r\n        return (minimumRaise != 0);\r\n    }\r\n\r\n    /* Verify if minimum raise was not achieved */\r\n    function minimumRaiseNotAchieved() public view returns (bool){\r\n        require(cost(tokensAllocated) < cost(minimumRaise), \"TotalRaise is bigger than minimum raise amount\");\r\n        return true;\r\n    }\r\n\r\n    /* Verify if minimum raise was achieved */\r\n    function minimumRaiseAchieved() public view returns (bool){\r\n        if(hasMinimumRaise()){\r\n            require(cost(tokensAllocated) >= cost(minimumRaise), \"TotalRaise is less than minimum raise amount\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function hasFinalized() public view returns (bool){\r\n        return block.timestamp > endDate;\r\n    }\r\n\r\n    function hasStarted() public view returns (bool){\r\n        return block.timestamp >= startDate;\r\n    }\r\n    \r\n    function isPreStart() public view returns (bool){\r\n        return block.timestamp < startDate;\r\n    }\r\n\r\n    function isOpen() public view returns (bool){\r\n        return hasStarted() && !hasFinalized();\r\n    }\r\n\r\n    function hasMinimumAmount() public view returns (bool){\r\n       return (individualMinimumAmount != 0);\r\n    }\r\n\r\n    function cost(uint256 _amount) public view returns (uint){\r\n        return _amount.mul(tradeValue).div(10**decimals); \r\n    }\r\n\r\n    function getPurchase(uint256 _purchase_id) external view returns (uint256, address, uint256, uint256, bool, bool){\r\n        Purchase memory purchase = purchases[_purchase_id];\r\n        return (purchase.amount, purchase.purchaser, purchase.ethAmount, purchase.timestamp, purchase.wasFinalized, purchase.reverted);\r\n    }\r\n\r\n    function getPurchaseIds() public view returns(uint256[] memory) {\r\n        return purchaseIds;\r\n    }\r\n\r\n    function getBuyers() public view returns(address[] memory) {\r\n        return buyers;\r\n    }\r\n\r\n    function getMyPurchases(address _address) public view returns(uint256[] memory) {\r\n        return myPurchases[_address];\r\n    }\r\n\r\n    /* Fund - Pre Sale Start */\r\n    function fund(uint256 _amount) public isSalePreStarted {\r\n        \r\n        /* Confirm transfered tokens is no more than needed */\r\n        require(availableTokens().add(_amount) <= tokensForSale, \"Transfered tokens have to be equal or less than proposed\");\r\n\r\n        /* Transfer Funds */\r\n        require(erc20.transferFrom(msg.sender, address(this), _amount), \"Failed ERC20 token transfer\");\r\n        \r\n        /* If Amount is equal to needed - sale is ready */\r\n        if(availableTokens() == tokensForSale){\r\n            isSaleFunded = true;\r\n        }\r\n    }\r\n    \r\n    /* Action Functions */\r\n    function swap(uint256 _amount) payable external whenNotPaused isFunded isSaleOpen onlyWhitelisted {\r\n\r\n        /* Confirm Amount is positive */\r\n        require(_amount > 0, \"Amount has to be positive\");\r\n\r\n        /* Confirm Amount is less than tokens available */\r\n        require(_amount <= tokensLeft(), \"Amount is less than tokens available\");\r\n            \r\n        /* Confirm the user has funds for the transfer, confirm the value is equal */\r\n        require(msg.value == cost(_amount), \"User has to cover the cost of the swap in ETH, use the cost function to determine\");\r\n\r\n        /* Confirm Amount is bigger than minimum Amount */\r\n        require(_amount >= individualMinimumAmount, \"Amount is bigger than minimum amount\");\r\n\r\n        /* Confirm Amount is smaller than maximum Amount */\r\n        require(_amount <= individualMaximumAmount, \"Amount is smaller than maximum amount\");\r\n\r\n        /* Verify all user purchases, loop thru them */\r\n        uint256[] memory _purchases = getMyPurchases(msg.sender);\r\n        uint256 purchaserTotalAmountPurchased = 0;\r\n        for (uint i = 0; i < _purchases.length; i++) {\r\n            Purchase memory _purchase = purchases[_purchases[i]];\r\n            purchaserTotalAmountPurchased = purchaserTotalAmountPurchased.add(_purchase.amount);\r\n        }\r\n        require(purchaserTotalAmountPurchased.add(_amount) <= individualMaximumAmount, \"Address has already passed the max amount of swap\");\r\n\r\n        if(isTokenSwapAtomic){\r\n            /* Confirm transfer */\r\n            require(erc20.transfer(msg.sender, _amount), \"ERC20 transfer didn´t work\");\r\n        }\r\n        \r\n        uint256 purchase_id = increment;\r\n        increment = increment.add(1);\r\n\r\n        /* Create new purchase */\r\n        Purchase memory purchase = Purchase(_amount, msg.sender, msg.value, block.timestamp, isTokenSwapAtomic /* If Atomic Swap */, false);\r\n        purchases[purchase_id] = purchase;\r\n        purchaseIds.push(purchase_id);\r\n        myPurchases[msg.sender].push(purchase_id);\r\n        buyers.push(msg.sender);\r\n        tokensAllocated = tokensAllocated.add(_amount);\r\n        emit PurchaseEvent(_amount, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /* Redeem tokens when the sale was finalized */\r\n    function redeemTokens(uint256 purchase_id) external isNotAtomicSwap isSaleFinalized whenNotPaused {\r\n        /* Confirm it exists and was not finalized */\r\n        require((purchases[purchase_id].amount != 0) && !purchases[purchase_id].wasFinalized, \"Purchase is either 0 or finalized\");\r\n        require(isBuyer(purchase_id), \"Address is not buyer\");\r\n        purchases[purchase_id].wasFinalized = true;\r\n        require(erc20.transfer(msg.sender, purchases[purchase_id].amount), \"ERC20 transfer failed\");\r\n    }\r\n\r\n    /* Retrieve Minumum Amount */\r\n    function redeemGivenMinimumGoalNotAchieved(uint256 purchase_id) external isSaleFinalized isNotAtomicSwap {\r\n        require(hasMinimumRaise(), \"Minimum raise has to exist\");\r\n        require(minimumRaiseNotAchieved(), \"Minimum raise has to be reached\");\r\n        /* Confirm it exists and was not finalized */\r\n        require((purchases[purchase_id].amount != 0) && !purchases[purchase_id].wasFinalized, \"Purchase is either 0 or finalized\");\r\n        require(isBuyer(purchase_id), \"Address is not buyer\");\r\n        purchases[purchase_id].wasFinalized = true;\r\n        purchases[purchase_id].reverted = true;\r\n        msg.sender.transfer(purchases[purchase_id].ethAmount);\r\n    }\r\n\r\n    /* Admin Functions */\r\n    function withdrawFunds() external onlyOwner whenNotPaused isSaleFinalized {\r\n        require(minimumRaiseAchieved(), \"Minimum raise has to be reached\");\r\n        FEE_ADDRESS.transfer(address(this).balance.mul(feePercentage).div(100)); /* Fee Address */\r\n        msg.sender.transfer(address(this).balance);\r\n    }  \r\n    \r\n    function withdrawUnsoldTokens() external onlyOwner isSaleFinalized {\r\n        require(!unsoldTokensReedemed);\r\n        uint256 unsoldTokens;\r\n        if(hasMinimumRaise() && \r\n            (cost(tokensAllocated) < cost(minimumRaise))){ /* Minimum Raise not reached */\r\n                unsoldTokens = tokensForSale;\r\n        }else{\r\n            /* If minimum Raise Achieved Redeem All Tokens minus the ones */\r\n            unsoldTokens = tokensForSale.sub(tokensAllocated);\r\n        }\r\n\r\n        if(unsoldTokens > 0){\r\n            unsoldTokensReedemed = true;\r\n            require(erc20.transfer(msg.sender, unsoldTokens), \"ERC20 transfer failed\");\r\n        }\r\n    }   \r\n\r\n    function removeOtherERC20Tokens(address _tokenAddress, address _to) external onlyOwner isSaleFinalized {\r\n        require(_tokenAddress != address(erc20), \"Token Address has to be diff than the erc20 subject to sale\"); // Confirm tokens addresses are different from main sale one\r\n        ERC20 erc20Token = ERC20(_tokenAddress);\r\n        require(erc20Token.transfer(_to, erc20Token.balanceOf(address(this))), \"ERC20 Token transfer failed\");\r\n    } \r\n\r\n    /* Safe Pull function */\r\n    function safePull() payable external onlyOwner whenPaused {\r\n        msg.sender.transfer(address(this).balance);\r\n        erc20.transfer(msg.sender, erc20.balanceOf(address(this)));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"hasWhitelisting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasMinimumRaise\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSaleFunded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"purchase_id\",\"type\":\"uint256\"}],\"name\":\"redeemGivenMinimumGoalNotAchieved\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTokenSwapAtomic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safePull\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"individualMinimumAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPreStart\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_purchase_id\",\"type\":\"uint256\"}],\"name\":\"getPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"myPurchases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPurchaseIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWhitelistedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasMinimumAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumRaiseNotAchieved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"purchases\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"purchaser\",\"type\":\"address\"},{\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"wasFinalized\",\"type\":\"bool\"},{\"name\":\"reverted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumRaise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"cost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"removeOtherERC20Tokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"purchase_id\",\"type\":\"uint256\"}],\"name\":\"redeemTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumRaiseAchieved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unsoldTokensReedemed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelistedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getMyPurchases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"add\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawUnsoldTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"purchaseIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"individualMaximumAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRaiseCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buyers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBuyers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"purchase_id\",\"type\":\"uint256\"}],\"name\":\"isBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_tradeValue\",\"type\":\"uint256\"},{\"name\":\"_tokensForSale\",\"type\":\"uint256\"},{\"name\":\"_startDate\",\"type\":\"uint256\"},{\"name\":\"_endDate\",\"type\":\"uint256\"},{\"name\":\"_individualMinimumAmount\",\"type\":\"uint256\"},{\"name\":\"_individualMaximumAmount\",\"type\":\"uint256\"},{\"name\":\"_isTokenSwapAtomic\",\"type\":\"bool\"},{\"name\":\"_minimumRaise\",\"type\":\"uint256\"},{\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"name\":\"_hasWhitelisting\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PurchaseEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FixedSwap","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000051e00a95748dbd2a3f47bc5c3b3e7b3f0fea666c0000000000000000000000000000000000000000000000000000746a52880000000000000000000000000000000000000000000000002f0eadc321623778000000000000000000000000000000000000000000000000000000000000602a705000000000000000000000000000000000000000000000000000000000602a8c7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000480b947aa7fe240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000173070c989bff4900000000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://1976832cb41c0befbada94f6a055f1eb1393a2933e82566329bc9c50d44c9ece"}]}