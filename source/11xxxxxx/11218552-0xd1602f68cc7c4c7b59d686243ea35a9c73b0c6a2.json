{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.7\r\n\"\"\"\r\n@title Curve Registry Exchange Contract\r\n@license MIT\r\n@author Curve.Fi\r\n@notice Find pools, query exchange rates and perform swaps\r\n\"\"\"\r\n\r\nMAX_COINS: constant(int128) = 8\r\nCALC_INPUT_SIZE: constant(uint256) = 100\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface AddressProvider:\r\n    def admin() -> address: view\r\n    def get_registry() -> address: view\r\n\r\ninterface CurvePool:\r\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\r\n    def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\r\n    def get_dy(i: int128, j: int128, amount: uint256) -> uint256: view\r\n    def get_dy_underlying(i: int128, j: int128, amount: uint256) -> uint256: view\r\n\r\ninterface Registry:\r\n    def address_provider() -> address: view\r\n    def get_A(_pool: address) -> uint256: view\r\n    def get_fees(_pool: address) -> uint256[2]: view\r\n    def get_coin_indices(_pool: address, _from: address, _to: address) -> (int128, int128, bool): view\r\n    def get_n_coins(_pool: address) -> uint256[2]: view\r\n    def get_balances(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_underlying_balances(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_rates(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_decimals(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_underlying_decimals(_pool: address) -> uint256[MAX_COINS]: view\r\n    def find_pool_for_coins(_from: address, _to: address, i: uint256) -> address: view\r\n\r\ninterface Calculator:\r\n    def get_dx(n_coins: uint256, balances: uint256[MAX_COINS], amp: uint256, fee: uint256,\r\n               rates: uint256[MAX_COINS], precisions: uint256[MAX_COINS],\r\n               i: int128, j: int128, dx: uint256) -> uint256: view\r\n    def get_dy(n_coins: uint256, balances: uint256[MAX_COINS], amp: uint256, fee: uint256,\r\n               rates: uint256[MAX_COINS], precisions: uint256[MAX_COINS],\r\n               i: int128, j: int128, dx: uint256[CALC_INPUT_SIZE]) -> uint256[CALC_INPUT_SIZE]: view\r\n\r\n\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    receiver: indexed(address)\r\n    pool: indexed(address)\r\n    token_sold: address\r\n    token_bought: address\r\n    amount_sold: uint256\r\n    amount_bought: uint256\r\n\r\n\r\naddress_provider: AddressProvider\r\nregistry: public(address)\r\ndefault_calculator: public(address)\r\nis_killed: public(bool)\r\npool_calculator: HashMap[address, address]\r\n\r\nis_approved: HashMap[address, HashMap[address, bool]]\r\n\r\n\r\n@external\r\ndef __init__(_address_provider: address, _calculator: address):\r\n    \"\"\"\r\n    @notice Constructor function\r\n    \"\"\"\r\n    self.address_provider = AddressProvider(_address_provider)\r\n    self.registry = AddressProvider(_address_provider).get_registry()\r\n    self.default_calculator = _calculator\r\n\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    pass\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_exchange_amount(_pool: address, _from: address, _to: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins received in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_from` to be sent\r\n    @return Quantity of `_to` to be received\r\n    \"\"\"\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    i, j, is_underlying = Registry(self.registry).get_coin_indices(_pool, _from, _to) # dev: no market\r\n\r\n    if is_underlying:\r\n        return CurvePool(_pool).get_dy_underlying(i, j, _amount)\r\n\r\n    return CurvePool(_pool).get_dy(i, j, _amount)\r\n\r\n\r\n@internal\r\ndef _exchange(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _sender: address,\r\n    _receiver: address,\r\n) -> uint256:\r\n\r\n    assert not self.is_killed\r\n\r\n    initial_balance: uint256 = 0\r\n    eth_amount: uint256 = 0\r\n    received_amount: uint256 = 0\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    i, j, is_underlying = Registry(self.registry).get_coin_indices(_pool, _from, _to)  # dev: no market\r\n\r\n    # record initial balance\r\n    if _to == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        initial_balance = self.balance\r\n    else:\r\n        initial_balance = ERC20(_to).balanceOf(self)\r\n\r\n    # perform / verify input transfer\r\n    if _from == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        eth_amount = _amount\r\n    else:\r\n        response: Bytes[32] = raw_call(\r\n            _from,\r\n            concat(\r\n                method_id(\"transferFrom(address,address,uint256)\"),\r\n                convert(_sender, bytes32),\r\n                convert(self, bytes32),\r\n                convert(_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    # approve input token\r\n    if not self.is_approved[_from][_pool]:\r\n        response: Bytes[32] = raw_call(\r\n            _from,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(_pool, bytes32),\r\n                convert(MAX_UINT256, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n        self.is_approved[_from][_pool] = True\r\n\r\n    # perform coin exchange\r\n    if is_underlying:\r\n        CurvePool(_pool).exchange_underlying(i, j, _amount, _expected, value=eth_amount)\r\n    else:\r\n        CurvePool(_pool).exchange(i, j, _amount, _expected, value=eth_amount)\r\n\r\n    # perform output transfer\r\n    if _to == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        received_amount = self.balance - initial_balance\r\n        raw_call(_receiver, b\"\", value=received_amount)\r\n    else:\r\n        received_amount = ERC20(_to).balanceOf(self) - initial_balance\r\n        response: Bytes[32] = raw_call(\r\n            _to,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(_receiver, bytes32),\r\n                convert(received_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    log TokenExchange(_sender, _receiver, _pool, _from, _to, _amount, received_amount)\r\n\r\n    return received_amount\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef exchange_with_best_rate(\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange using the pool that offers the best rate\r\n    @dev Prior to calling this function, the caller must approve\r\n         this contract to transfer `_amount` coins from `_from`\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @param _expected Minimum quantity of `_from` received\r\n           in order for the transaction to succeed\r\n    @param _receiver Address to transfer the received tokens to\r\n    @return uint256 Amount received\r\n    \"\"\"\r\n    if _from == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        assert _amount == msg.value, \"Incorrect ETH amount\"\r\n    else:\r\n        assert msg.value == 0, \"Incorrect ETH amount\"\r\n\r\n    registry: address = self.registry\r\n    best_pool: address = Registry(registry).find_pool_for_coins(_from, _to, 0)\r\n    max_dy: uint256 = 0\r\n    for i in range(1, 65536):\r\n        pool: address = Registry(registry).find_pool_for_coins(_from, _to, i)\r\n        if pool == ZERO_ADDRESS:\r\n            break\r\n        elif i == 1:\r\n            max_dy = self._get_exchange_amount(best_pool, _from, _to, _amount)\r\n        dy: uint256 = self._get_exchange_amount(pool, _from, _to, _amount)\r\n        if dy > max_dy:\r\n            best_pool = pool\r\n            max_dy = dy\r\n\r\n    return self._exchange(best_pool, _from, _to, _amount, _expected, msg.sender, _receiver)\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef exchange(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange using a specific pool\r\n    @dev Prior to calling this function, the caller must approve\r\n         this contract to transfer `_amount` coins from `_from`\r\n    @param _pool Address of the pool to use for the swap\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @param _expected Minimum quantity of `_from` received\r\n           in order for the transaction to succeed\r\n    @param _receiver Address to transfer the received tokens to\r\n    @return uint256 Amount received\r\n    \"\"\"\r\n    if _from == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        assert _amount == msg.value, \"Incorrect ETH amount\"\r\n    else:\r\n        assert msg.value == 0, \"Incorrect ETH amount\"\r\n\r\n    return self._exchange(_pool, _from, _to, _amount, _expected, msg.sender, _receiver)\r\n\r\n\r\n@view\r\n@external\r\ndef get_best_rate(_from: address, _to: address, _amount: uint256) -> (address, uint256):\r\n    \"\"\"\r\n    @notice Find the pool offering the best rate for a given swap.\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @return Pool address, amount received\r\n    \"\"\"\r\n    best_pool: address = ZERO_ADDRESS\r\n    max_dy: uint256 = 0\r\n    for i in range(65536):\r\n        pool: address = Registry(self.registry).find_pool_for_coins(_from, _to, i)\r\n        if pool == ZERO_ADDRESS:\r\n            break\r\n\r\n        dy: uint256 = self._get_exchange_amount(pool, _from, _to, _amount)\r\n        if dy > max_dy:\r\n            best_pool = pool\r\n            max_dy = dy\r\n\r\n    return best_pool, max_dy\r\n\r\n\r\n@view\r\n@external\r\ndef get_exchange_amount(_pool: address, _from: address, _to: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins received in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_from` to be sent\r\n    @return Quantity of `_to` to be received\r\n    \"\"\"\r\n    return self._get_exchange_amount(_pool, _from, _to, _amount)\r\n\r\n\r\n@view\r\n@external\r\ndef get_input_amount(_pool: address, _from: address, _to: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins required to receive the given amount in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_to` to be received\r\n    @return Quantity of `_from` to be sent\r\n    \"\"\"\r\n    registry: address = self.registry\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    i, j, is_underlying = Registry(registry).get_coin_indices(_pool, _from, _to)\r\n    amp: uint256 = Registry(registry).get_A(_pool)\r\n    fee: uint256 = Registry(registry).get_fees(_pool)[0]\r\n\r\n    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    n_coins: uint256 = Registry(registry).get_n_coins(_pool)[convert(is_underlying, uint256)]\r\n    if is_underlying:\r\n        balances = Registry(registry).get_underlying_balances(_pool)\r\n        decimals = Registry(registry).get_underlying_decimals(_pool)\r\n        for x in range(MAX_COINS):\r\n            if x == n_coins:\r\n                break\r\n            rates[x] = 10**18\r\n    else:\r\n        balances = Registry(registry).get_balances(_pool)\r\n        decimals = Registry(registry).get_decimals(_pool)\r\n        rates = Registry(registry).get_rates(_pool)\r\n\r\n    for x in range(MAX_COINS):\r\n        if x == n_coins:\r\n            break\r\n        decimals[x] = 10 ** (18 - decimals[x])\r\n\r\n    calculator: address = self.pool_calculator[_pool]\r\n    if calculator == ZERO_ADDRESS:\r\n        calculator = self.default_calculator\r\n    return Calculator(calculator).get_dx(n_coins, balances, amp, fee, rates, decimals, i, j, _amount)\r\n\r\n\r\n@view\r\n@external\r\ndef get_exchange_amounts(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amounts: uint256[CALC_INPUT_SIZE]\r\n) -> uint256[CALC_INPUT_SIZE]:\r\n    \"\"\"\r\n    @notice Get the current number of coins required to receive the given amount in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amounts Quantity of `_to` to be received\r\n    @return Quantity of `_from` to be sent\r\n    \"\"\"\r\n    registry: address = self.registry\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n\r\n    amp: uint256 = Registry(registry).get_A(_pool)\r\n    fee: uint256 = Registry(registry).get_fees(_pool)[0]\r\n    i, j, is_underlying = Registry(registry).get_coin_indices(_pool, _from, _to)\r\n    n_coins: uint256 = Registry(registry).get_n_coins(_pool)[convert(is_underlying, uint256)]\r\n\r\n    if is_underlying:\r\n        balances = Registry(registry).get_underlying_balances(_pool)\r\n        decimals = Registry(registry).get_underlying_decimals(_pool)\r\n        for x in range(MAX_COINS):\r\n            if x == n_coins:\r\n                break\r\n            rates[x] = 10**18\r\n    else:\r\n        balances = Registry(registry).get_balances(_pool)\r\n        decimals = Registry(registry).get_decimals(_pool)\r\n        rates = Registry(registry).get_rates(_pool)\r\n\r\n    for x in range(MAX_COINS):\r\n        if x == n_coins:\r\n            break\r\n        decimals[x] = 10 ** (18 - decimals[x])\r\n\r\n    calculator: address = self.pool_calculator[_pool]\r\n    if calculator == ZERO_ADDRESS:\r\n        calculator = self.default_calculator\r\n    return Calculator(calculator).get_dy(n_coins, balances, amp, fee, rates, decimals, i, j, _amounts)\r\n\r\n\r\n@view\r\n@external\r\ndef get_calculator(_pool: address) -> address:\r\n    \"\"\"\r\n    @notice Set calculator contract\r\n    @dev Used to calculate `get_dy` for a pool\r\n    @param _pool Pool address\r\n    @return `CurveCalc` address\r\n    \"\"\"\r\n    calculator: address = self.pool_calculator[_pool]\r\n    if calculator == ZERO_ADDRESS:\r\n        return self.default_calculator\r\n    else:\r\n        return calculator\r\n\r\n\r\n@external\r\ndef update_registry_address() -> bool:\r\n    \"\"\"\r\n    @notice Update registry address\r\n    @dev The registry address is kept in storage to reduce gas costs.\r\n         If a new registry is deployed this function should be called\r\n         to update the local address from the address provider.\r\n    @return bool success\r\n    \"\"\"\r\n    self.registry = self.address_provider.get_registry()\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_calculator(_pool: address, _calculator: address) -> bool:\r\n    \"\"\"\r\n    @notice Set calculator contract\r\n    @dev Used to calculate `get_dy` for a pool\r\n    @param _pool Pool address\r\n    @param _calculator `CurveCalc` address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    self.pool_calculator[_pool] = _calculator\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_default_calculator(_calculator: address) -> bool:\r\n    \"\"\"\r\n    @notice Set default calculator contract\r\n    @dev Used to calculate `get_dy` for a pool\r\n    @param _calculator `CurveCalc` address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    self.default_calculator = _calculator\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef claim_balance(_token: address) -> bool:\r\n    \"\"\"\r\n    @notice Transfer an ERC20 or ETH balance held by this contract\r\n    @dev The entire balance is transferred to the owner\r\n    @param _token Token address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    if _token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        raw_call(msg.sender, b\"\", value=self.balance)\r\n    else:\r\n        amount: uint256 = ERC20(_token).balanceOf(self)\r\n        response: Bytes[32] = raw_call(\r\n            _token,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(msg.sender, bytes32),\r\n                convert(amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_killed(_is_killed: bool) -> bool:\r\n    \"\"\"\r\n    @notice Kill or unkill the contract\r\n    @param _is_killed Killed status of the contract\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n    self.is_killed = _is_killed\r\n\r\n    return True","ABI":"[{\"name\":\"TokenExchange\",\"inputs\":[{\"type\":\"address\",\"name\":\"buyer\",\"indexed\":true},{\"type\":\"address\",\"name\":\"receiver\",\"indexed\":true},{\"type\":\"address\",\"name\":\"pool\",\"indexed\":true},{\"type\":\"address\",\"name\":\"token_sold\",\"indexed\":false},{\"type\":\"address\",\"name\":\"token_bought\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount_sold\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount_bought\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_address_provider\"},{\"type\":\"address\",\"name\":\"_calculator\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"name\":\"exchange_with_best_rate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"exchange_with_best_rate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"},{\"type\":\"address\",\"name\":\"_receiver\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"exchange\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"exchange\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"uint256\",\"name\":\"_expected\"},{\"type\":\"address\",\"name\":\"_receiver\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"get_best_rate\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"},{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":298910689},{\"name\":\"get_exchange_amount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3911},{\"name\":\"get_input_amount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":15391},{\"name\":\"get_exchange_amounts\",\"outputs\":[{\"type\":\"uint256[100]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256[100]\",\"name\":\"_amounts\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":17958},{\"name\":\"get_calculator\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2462},{\"name\":\"update_registry_address\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36751},{\"name\":\"set_calculator\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_calculator\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37192},{\"name\":\"set_default_calculator\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_calculator\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37007},{\"name\":\"claim_balance\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_token\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37831},{\"name\":\"set_killed\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"bool\",\"name\":\"_is_killed\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37067},{\"name\":\"registry\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1571},{\"name\":\"default_calculator\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1601},{\"name\":\"is_killed\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1631}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000000000000022d53366457f9d5e68ec105046fc43830000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}