{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20Interface.sol\":{\"content\":\"  pragma solidity ^0.4.18;\\r\\n\\r\\n// ----------------------------------------------------------------------------------------------\\r\\n// Sample fixed supply token contract\\r\\n// Enjoy. (c) BokkyPooBah 2017. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------------------------\\r\\n\\r\\n// ERC Token Standard #20 Interface\\r\\n// https://github.com/ethereum/EIPs/issues/20\\r\\ncontract ERC20Interface {\\r\\n    // Get the total token supply\\r\\n    function totalSupply() public constant returns (uint256);\\r\\n\\r\\n    // Get the account balance of another account with address _owner\\r\\n    function balanceOf(address _owner) public constant returns (uint256 balance);\\r\\n\\r\\n    // Send _value amount of tokens to address _to\\r\\n    function transfer(address _to, uint256 _value) public returns (bool success);\\r\\n\\r\\n    // Send _value amount of tokens from address _from to address _to\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\r\\n\\r\\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\\r\\n    // If this function is called again it overwrites the current allowance with _value.\\r\\n    // this function is required for some DEX functionality\\r\\n    function approve(address _spender, uint256 _value) public returns (bool success);\\r\\n\\r\\n    // Returns the amount which _spender is still allowed to withdraw from _owner\\r\\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\\r\\n\\r\\n    // Triggered when tokens are transferred.\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n\\r\\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\"},\"keeper.sol\":{\"content\":\"pragma solidity ^0.4.18;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./ERC20Interface.sol\\u0027;\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\n\\r\\ninterface keeperv1 {\\r\\n    function worked(address _job_contarct) external;\\r\\n    function isValid(address _job_contarct , address _keeper) view external returns(bool);\\r\\n}\\r\\n\\r\\ninterface JobContract {\\r\\n    function work() external;\\r\\n}\\r\\n\\r\\ncontract Keeper is keeperv1 {\\r\\n    \\r\\n    uint256 job_count = 0;\\r\\n    \\r\\n    uint256 max_token = 10000000000000000000;\\r\\n    \\r\\n    address manager;\\r\\n    \\r\\n    ERC20Interface token = ERC20Interface(0x02d7b659389d537912B313611cBC5a7F7Ed615A9);\\r\\n    \\r\\n    mapping(address =\\u003e uint256) owner_job_count;\\r\\n    \\r\\n    mapping (uint256 =\\u003e Job) jobs;\\r\\n\\r\\n    mapping (address =\\u003e uint256) balance;\\r\\n    \\r\\n    //first address is job address and second one is keeper address\\r\\n    mapping (address =\\u003e mapping(uint256 =\\u003e address)) keeper;\\r\\n    //first address is job address and second one is last index\\r\\n    mapping (address =\\u003e uint256) keeper_index;\\r\\n    \\r\\n    //first address is keeper address and second one is job address\\r\\n    mapping (address =\\u003e  mapping(address =\\u003e uint256)) jobs_bonde;\\r\\n    \\r\\n    mapping (address =\\u003e uint256) completed_work_count;\\r\\n\\r\\n    ////////////////\\r\\n    ///improvment///\\r\\n    ///////////////\\r\\n    \\r\\n    mapping (address =\\u003e uint256) job2index;\\r\\n    \\r\\n    struct Job {\\r\\n        address job_contarct;\\r\\n        address owner;\\r\\n        string job_name;\\r\\n        string document_link;\\r\\n        uint256 liquidity;\\r\\n        uint256 reward;\\r\\n        uint256 limit_call;\\r\\n        uint256 last_call;\\r\\n        uint256 min_xp;\\r\\n        uint256 keeper_count;\\r\\n        uint256 max_keeper_count;\\r\\n    }\\r\\n\\r\\n    constructor() public{\\r\\n        manager = msg.sender;\\r\\n    }\\r\\n    \\r\\n    //////////////////////////////////\\r\\n    ///////// Main Functions /////////\\r\\n    //////////////////////////////////\\r\\n    \\r\\n    //create new job\\r\\n    function createJob(address _job_contarct, string _job_name , string _document_link , uint256 _liquidity , uint256 _reward , uint256 _max_keeper_count , uint256 _limit_call , uint _min_xp) public payable{\\r\\n        \\r\\n        //check for contract unique\\r\\n        require(!hasJob(_job_contarct) , \\u0027Job Is Already Added\\u0027);\\r\\n        \\r\\n        //transfer token to contract\\r\\n        require(token.transferFrom(msg.sender, address(this), _liquidity) == true , \\u0027transfer failed\\u0027);\\r\\n\\r\\n        require(_min_xp \\u003c= 5 , \\u0027max xp is 5\\u0027);\\r\\n        \\r\\n        job_count++;\\r\\n        \\r\\n        jobs[job_count].job_contarct = _job_contarct;\\r\\n        jobs[job_count].job_name = _job_name;\\r\\n        jobs[job_count].document_link = _document_link;\\r\\n        jobs[job_count].liquidity = _liquidity;\\r\\n        jobs[job_count].max_keeper_count = _max_keeper_count;\\r\\n        jobs[job_count].reward = _reward;\\r\\n        jobs[job_count].limit_call = _limit_call;\\r\\n        jobs[job_count].min_xp = _min_xp;\\r\\n        jobs[job_count].last_call = now;\\r\\n        jobs[job_count].keeper_count = 0;\\r\\n        jobs[job_count].owner = msg.sender;\\r\\n        \\r\\n        job2index[_job_contarct] = job_count;\\r\\n        \\r\\n        owner_job_count[msg.sender]++;\\r\\n    }\\r\\n    \\r\\n    function editJob(address _job_contarct , uint256 _liquidity , uint256 _reward , uint256 _limit_call , uint256 _min_xp , uint256 _max_keeper_count) public{\\r\\n        Job storage _selected_job = getJob(_job_contarct);\\r\\n        require(_selected_job.owner == msg.sender , \\u0027You are not Job Owner\\u0027);\\r\\n        require(_min_xp \\u003c= 5 , \\u0027max xp is 5\\u0027);\\r\\n        \\r\\n        if(_liquidity \\u003e 0){\\r\\n            //transfer token to contract\\r\\n            require(token.transferFrom(msg.sender, address(this), _liquidity) == true , \\u0027transfer failed\\u0027);\\r\\n        }\\r\\n        \\r\\n        _selected_job.liquidity = SafeMath.add(_liquidity , _selected_job.liquidity);\\r\\n        _selected_job.reward = _reward;\\r\\n        _selected_job.limit_call = _limit_call;\\r\\n        _selected_job.max_keeper_count = _max_keeper_count;\\r\\n        _selected_job.min_xp = _min_xp;\\r\\n    }\\r\\n    \\r\\n    //bonde to a job\\r\\n    function bonde(address _job_contarct , uint256 _amount) public{\\r\\n        \\r\\n        Job storage _selected_job = getJob(_job_contarct);\\r\\n        \\r\\n        require(balance[msg.sender] \\u003e= _amount , \\u0027Insufficient token balance\\u0027);\\r\\n        require(minMax(_amount) \\u003e= _selected_job.min_xp , \\u0027Insufficient token xp\\u0027);\\r\\n        require(!isKeeper(_job_contarct , msg.sender) , \\u0027You are a job keeper\\u0027);\\r\\n        require((_selected_job.keeper_count \\u003c _selected_job.max_keeper_count) || (_selected_job.max_keeper_count == 0) , \\u0027job user count limit is over\\u0027);\\r\\n                \\r\\n        //subtract token balance\\r\\n        balance[msg.sender] = SafeMath.sub(balance[msg.sender] , _amount);\\r\\n        \\r\\n        //bonde token to job\\r\\n        jobs_bonde[msg.sender][_job_contarct] = _amount;\\r\\n        \\r\\n        // //add keeper to job\\r\\n        keeper[_job_contarct][keeper_index[_job_contarct]] = msg.sender;\\r\\n        keeper_index[_job_contarct]++;\\r\\n        _selected_job.keeper_count++;\\r\\n    }\\r\\n\\r\\n    function unbonde(address _job_contarct) public{\\r\\n        \\r\\n        Job storage _selected_job = getJob(_job_contarct);\\r\\n\\r\\n        \\r\\n        require(isKeeper(_job_contarct , msg.sender) , \\u0027You are not a job keeper\\u0027);\\r\\n    \\r\\n        //get user bonde for this job\\r\\n        uint256 _bonde_balance = jobs_bonde[msg.sender][_job_contarct] ;\\r\\n    \\r\\n        //add token balance to user\\r\\n        balance[msg.sender] = SafeMath.add(balance[msg.sender] , _bonde_balance);\\r\\n        \\r\\n        //sub user balance from job\\r\\n        jobs_bonde[msg.sender][_job_contarct] = 0;\\r\\n    \\r\\n        \\r\\n        // //remove keeper from job\\r\\n        uint256 _keeper_index = findJobKeeperIndex(_job_contarct);\\r\\n        delete keeper[_job_contarct][_keeper_index];\\r\\n        keeper_index[_job_contarct]--;\\r\\n        _selected_job.keeper_count--;\\r\\n    }\\r\\n    \\r\\n    function worked(address _job_contarct) external{\\r\\n\\r\\n        uint256 _job_index = getJobIndexByAddressOrThrow(_job_contarct);\\r\\n        Job storage _selected_job =  jobs[_job_index];   \\r\\n        require(isKeeper(_job_contarct , msg.sender) \\u0026\\u0026 checkBalance(_selected_job) , \\\"Transaction is Invalid\\\");\\r\\n        \\r\\n        ///// Start do work \\r\\n        \\r\\n        JobContract job2do = JobContract(_job_contarct);\\r\\n        job2do.work();\\r\\n        \\r\\n        //// End do work\\r\\n        \\r\\n        //sub reward credit\\r\\n        _selected_job.liquidity = SafeMath.sub(_selected_job.liquidity , _selected_job.reward);\\r\\n        \\r\\n        //add reward\\r\\n        jobs_bonde[msg.sender][_job_contarct] = SafeMath.add(jobs_bonde[msg.sender][_job_contarct] , _selected_job.reward);\\r\\n        completed_work_count[msg.sender]++;\\r\\n        \\r\\n        _selected_job.last_call = now;\\r\\n    }\\r\\n    \\r\\n    function withdraw(uint256 _amount) public{\\r\\n        \\r\\n        require(_amount \\u003c= balance[msg.sender] , \\u0027Insufficient Token Amount Balance\\u0027);\\r\\n    \\r\\n        balance[msg.sender] = SafeMath.sub(balance[msg.sender] , _amount);\\r\\n    \\r\\n        token.approve(address(this) , _amount);\\r\\n\\r\\n        require(token.transferFrom(address(this) , msg.sender , _amount) == true , \\u0027Insufficient Token Amount In Repo\\u0027);\\r\\n        \\r\\n    }\\r\\n    \\r\\n    //////////////////////////////////\\r\\n    ///////// Show Functions /////////\\r\\n    //////////////////////////////////\\r\\n    \\r\\n    function showKeeperJobBonde(address _job_contarct , address _keeper) public view returns(uint256){\\r\\n        return jobs_bonde[_keeper][_job_contarct];\\r\\n    }\\r\\n    \\r\\n    function showJobLiquidity(address _job_contarct) public view returns(uint256){\\r\\n        return getJob(_job_contarct).liquidity;\\r\\n    }\\r\\n    \\r\\n    function showAllJobs() public view returns(address[] , string[] , uint256[] , address[]){\\r\\n        address[] memory _jobs_address = new address[](job_count);\\r\\n        string[] memory _jobs_name = new string[](job_count);\\r\\n        uint256[] memory _jobs_liquidity = new uint256[](job_count);\\r\\n        address[] memory _jobs_owner = new address[](job_count);\\r\\n\\r\\n        for(uint256 i = 1 ; i \\u003c= job_count ; i++){\\r\\n            _jobs_address[i-1] = (jobs[i].job_contarct);\\r\\n            _jobs_name[i-1] = (jobs[i].job_name);\\r\\n            _jobs_liquidity[i-1] = (jobs[i].liquidity);\\r\\n            _jobs_owner[i-1] = (jobs[i].owner);\\r\\n        }\\r\\n        \\r\\n        return(_jobs_address , _jobs_name , _jobs_liquidity , _jobs_owner);\\r\\n    }\\r\\n    \\r\\n    function showJobDetail(address _job_contarct) public view returns(address , address , string , string , uint256 , uint256 , uint256 , uint256 ,uint256 , uint256 ){\\r\\n        \\r\\n        Job storage _selected_job = getJob(_job_contarct);\\r\\n        \\r\\n        return(\\r\\n            _selected_job.job_contarct ,\\r\\n            _selected_job.owner ,\\r\\n            _selected_job.job_name ,\\r\\n            _selected_job.document_link ,\\r\\n            _selected_job.liquidity ,\\r\\n            _selected_job.reward ,\\r\\n            _selected_job.keeper_count ,\\r\\n            _selected_job.max_keeper_count ,\\r\\n            _selected_job.limit_call ,\\r\\n            _selected_job.min_xp\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    function showFreeBalance(address _keeper) public view returns(uint256){\\r\\n        return balance[_keeper];\\r\\n    }\\r\\n    \\r\\n    function showCompletedWorkCount(address _keeper) public view returns(uint256){\\r\\n        return completed_work_count[_keeper];\\r\\n    }\\r\\n    \\r\\n    function showOwnedJob() public view returns(address[] , string[]){\\r\\n        \\r\\n        uint256 _job_count = owner_job_count[msg.sender];\\r\\n        \\r\\n        address[] memory _jobs_address = new address[](_job_count);\\r\\n        string[] memory _jobs_name = new string[](_job_count);\\r\\n        \\r\\n        uint256 _index = 0;\\r\\n        for(uint256 i = 1 ; i \\u003c= job_count ; i++){\\r\\n            if(jobs[i].owner == msg.sender){\\r\\n                _jobs_address[_index] = (jobs[i].job_contarct);\\r\\n                _jobs_name[_index] = (jobs[i].job_name);\\r\\n                _index++;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return(_jobs_address , _jobs_name);\\r\\n    }\\r\\n    \\r\\n    function showJobOwnedCount() public view returns(uint256){\\r\\n        return owner_job_count[msg.sender];\\r\\n    }\\r\\n    \\r\\n    function showXp(address _keeper) public view returns(uint256){\\r\\n        return minMax(balance[_keeper]);\\r\\n    }\\r\\n\\r\\n    function showMaxToken() public view returns(uint256){\\r\\n        \\r\\n        return max_token;\\r\\n    }\\r\\n    \\r\\n    function nextAvailabeCall(address _job_contarct) public view returns(uint256){\\r\\n        Job storage _selected_job = getJob(_job_contarct);\\r\\n        return _selected_job.limit_call + _selected_job.last_call;\\r\\n    }\\r\\n    \\r\\n    ///////////////////////////////////\\r\\n    ///////// Manger Functions/////////\\r\\n    ///////////////////////////////////\\r\\n    \\r\\n    function changeMaxToken(uint256 _max_token) public{\\r\\n        require(msg.sender == manager , \\\"You Are NOT manger\\\");\\r\\n        max_token = _max_token;\\r\\n    }\\r\\n    \\r\\n    ///////////////////////////////////////\\r\\n    ///////// Helper Functions ////////////\\r\\n    ///////////////////////////////////////\\r\\n    \\r\\n    function findJobKeeperIndex(address _job_contarct) internal view returns(uint256){\\r\\n        uint256 _index = keeper_index[_job_contarct];\\r\\n        bool _has_result = false;\\r\\n        uint256 _result = 0;\\r\\n        for(uint256 i = 0 ; i \\u003c= _index ; i++){\\r\\n            if(keeper[_job_contarct][i] == msg.sender){\\r\\n                _has_result = true;\\r\\n                _result = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        require(_has_result , \\u0027Keeper Not Found\\u0027);\\r\\n        \\r\\n        return _result;\\r\\n    }\\r\\n    \\r\\n    function hasJob(address _job_contarct) private constant returns (bool _result) {\\r\\n        _result = false;\\r\\n        \\r\\n        uint256 index = job2index[_job_contarct];\\r\\n        if(index != 0){\\r\\n            _result = true;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function minMax(uint256 _value) private view returns(uint256){\\r\\n        if(_value \\u003e max_token){\\r\\n            _value = max_token;\\r\\n        }\\r\\n        return SafeMath.div(SafeMath.mul(_value , 5) , max_token);\\r\\n    }\\r\\n    \\r\\n    function isKeeper(address _job_contarct , address _keeper)public view returns (bool){\\r\\n        bool _result = false;\\r\\n        for(uint256 i = 0 ; i \\u003c keeper_index[_job_contarct] ; i++){\\r\\n            if(keeper[_job_contarct][i] == _keeper){\\r\\n                _result = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return _result;\\r\\n    }\\r\\n    \\r\\n    function getJobIndexByAddressOrThrow(address _job_contarct) internal view returns (uint256) {\\r\\n        uint256 index = job2index[_job_contarct];\\r\\n        require(index \\u003e 0 , \\u0027Job not found\\u0027);\\r\\n        return index;\\r\\n    }\\r\\n    \\r\\n    function checkBalance(Job storage _selected_job) internal view returns(bool){\\r\\n        return _selected_job.liquidity \\u003e= _selected_job.reward;\\r\\n    }\\r\\n    \\r\\n    function checkLastCall(Job storage _selected_job) internal view returns(bool _result){\\r\\n        _result = false;\\r\\n        if(_selected_job.last_call + _selected_job.limit_call \\u003c= now){\\r\\n            _result = true;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function isValid(address _job_contarct , address _keeper) external view returns (bool _result){\\r\\n        \\r\\n        uint256 _job_index = getJobIndexByAddressOrThrow(_job_contarct);\\r\\n        Job storage _selected_job =  jobs[_job_index];        \\r\\n        \\r\\n        _result = true;\\r\\n        if(!isKeeper(_job_contarct , _keeper)){\\r\\n            _result = false;\\r\\n        }\\r\\n        if(!checkBalance(_selected_job)){\\r\\n            _result = false;\\r\\n        }\\r\\n        if(!checkLastCall(_selected_job)){\\r\\n            _result = false;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function getJob(address _job_contarct) private view returns(Job storage){\\r\\n        uint256 _job_index = getJobIndexByAddressOrThrow(_job_contarct);\\r\\n        return jobs[_job_index];\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.4.18;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_max_token\",\"type\":\"uint256\"}],\"name\":\"changeMaxToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"},{\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"name\":\"_reward\",\"type\":\"uint256\"},{\"name\":\"_limit_call\",\"type\":\"uint256\"},{\"name\":\"_min_xp\",\"type\":\"uint256\"},{\"name\":\"_max_keeper_count\",\"type\":\"uint256\"}],\"name\":\"editJob\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"}],\"name\":\"showJobLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"showFreeBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"}],\"name\":\"worked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showJobOwnedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"},{\"name\":\"_job_name\",\"type\":\"string\"},{\"name\":\"_document_link\",\"type\":\"string\"},{\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"name\":\"_reward\",\"type\":\"uint256\"},{\"name\":\"_max_keeper_count\",\"type\":\"uint256\"},{\"name\":\"_limit_call\",\"type\":\"uint256\"},{\"name\":\"_min_xp\",\"type\":\"uint256\"}],\"name\":\"createJob\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"showCompletedWorkCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"},{\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"isKeeper\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showAllJobs\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"string[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"},{\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"isValid\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"}],\"name\":\"showJobDetail\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"bonde\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"}],\"name\":\"unbonde\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showOwnedJob\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"string[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"showXp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showMaxToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"},{\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"showKeeperJobBonde\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_job_contarct\",\"type\":\"address\"}],\"name\":\"nextAvailabeCall\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Keeper","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c7ac0d0b0f2f9c8cb0ac5a8a3a72e9509803b18405da21eb1575744deccd4ea0"}]}