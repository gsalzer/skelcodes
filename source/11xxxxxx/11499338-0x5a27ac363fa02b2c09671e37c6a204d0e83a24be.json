{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.8\r\n\"\"\"\r\n@title Pool tokens to seed Uniswap liquidity\r\n@license MIT\r\n@author banteg\r\n@notice Use this contract to boostrap a Uniswap exchange\r\n\"\"\"\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface Factory:\r\n    def getPair(tokenA: address, tokenB: address) -> address: view\r\n    def createPair(tokenA: address, tokenB: address) -> address: nonpayable\r\n\r\n\r\ninterface Router:\r\n    def factory() -> address: view\r\n    def addLiquidity(\r\n        tokenA: address,\r\n        tokenB: address,\r\n        amountADesired: uint256,\r\n        amountBDesired: uint256,\r\n        amountAMin: uint256,\r\n        amountBMin: uint256,\r\n        to: address,\r\n        deadline: uint256\r\n    ) -> (uint256, uint256, uint256): nonpayable\r\n\r\n\r\nrouter: public(Router)\r\ntokens: public(address[2])\r\ntarget: public(uint256[2])\r\npair: public(ERC20)\r\nbalances: public(HashMap[address, HashMap[uint256, uint256]])  # address -> index -> balance\r\ntotals: public(HashMap[uint256, uint256])  # index -> balance\r\nliquidity: public(uint256)\r\nexpiry: public(uint256)\r\nlocktime: public(uint256)\r\nunlock: public(uint256)\r\n\r\n\r\n@external\r\ndef __init__(router: address, tokens: address[2], target: uint256[2], duration: uint256, locktime: uint256):\r\n    \"\"\"\r\n    @notice Set up a new seed liquidity contract\r\n\r\n    @param router UniswapRouter address, e.g. 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n    @param tokens Tokens which comprise a pair\r\n    @param target Amounts of tokens to provide, also determines the initial price\r\n    @param duration Duration over which the contract accepts deposits, in seconds\r\n    @param locktime How long the liquidity will stay locked, in seconds\r\n    \"\"\"\r\n    self.router = Router(router)\r\n    self.tokens = tokens\r\n    self.target = target\r\n    factory: address = self.router.factory()\r\n    pair: address = Factory(factory).getPair(tokens[0], tokens[1])\r\n    if pair == ZERO_ADDRESS:\r\n        pair = Factory(factory).createPair(tokens[0], tokens[1])\r\n    self.pair = ERC20(pair)\r\n    self.expiry = block.timestamp + duration\r\n    self.locktime = locktime\r\n    assert self.pair.totalSupply() == 0  # dev: pair already liquid\r\n\r\n\r\n@external\r\ndef deposit(amounts: uint256[2]):\r\n    \"\"\"\r\n    @notice Deposit token amounts into the contract\r\n    @dev\r\n        A user must have approved the contract to spend both tokens.\r\n        The token amounts are clamped to not exceed their targets.\r\n        This function only works up to the moment when liquidity is provided\r\n        or the contract has expired, whichever comes first.\r\n\r\n    @param amounts Token amounts to deposit\r\n    \"\"\"\r\n    assert self.liquidity == 0  # dev: liquidity already seeded\r\n    assert block.timestamp < self.expiry  # dev: contract has expired\r\n    amount: uint256 = 0\r\n    for i in range(2):\r\n        amount = min(amounts[i], self.target[i] - self.totals[i])\r\n        if amount == 0:\r\n            continue\r\n        assert ERC20(self.tokens[i]).transferFrom(msg.sender, self, amount)\r\n        self.balances[msg.sender][i] += amount\r\n        self.totals[i] += amount\r\n\r\n\r\n@external\r\ndef provide():\r\n    \"\"\"\r\n    @notice Bootstrap a new Uniswap pair using the assets in the contract\r\n    @dev\r\n        This function can only be called once and before the contract has expired.\r\n        Requires the target to be reached for both tokens.\r\n        Requires the pool to have no liquidity in it.\r\n    \"\"\"\r\n    assert self.liquidity == 0  # dev: liquidity already seeded\r\n    assert block.timestamp < self.expiry  # dev: contract has expired\r\n    assert self.pair.totalSupply() == 0  # dev: cannot seed a liquid pair\r\n    amount: uint256 = 0\r\n    for i in range(2):\r\n        assert self.totals[i] == self.target[i]  # dev: target not reached\r\n        assert ERC20(self.tokens[i]).approve(self.router.address, self.totals[i])\r\n    \r\n    self.router.addLiquidity(\r\n        self.tokens[0],\r\n        self.tokens[1],\r\n        self.totals[0],\r\n        self.totals[1],\r\n        self.totals[0],  # don't allow slippage\r\n        self.totals[1],\r\n        self,\r\n        block.timestamp\r\n    )\r\n    \r\n    self.unlock = block.timestamp + self.locktime\r\n    self.liquidity = self.pair.balanceOf(self)\r\n    assert self.liquidity > 0  # dev: no liquidity provided\r\n\r\n\r\n@external\r\ndef claim():\r\n    \"\"\"\r\n    @notice Claim the received LP tokens\r\n    @dev\r\n        Can be called after liquidity is provided.\r\n        The token amount is distributed pro-rata to the contribution.\r\n    \"\"\"\r\n    assert self.liquidity != 0  # dev: liquidity not seeded\r\n    assert block.timestamp >= self.unlock # dev: liquidity is locked\r\n    amount: uint256 = 0\r\n    for i in range(2):\r\n        amount += self.balances[msg.sender][i] * self.liquidity / self.totals[i] / 2\r\n        self.balances[msg.sender][i] = 0\r\n    assert self.pair.transfer(msg.sender, amount)\r\n\r\n\r\n@external\r\ndef bail():\r\n    \"\"\"\r\n    @notice Withdraw the tokens if the contract has expired without providing liquidity\r\n    @dev\r\n        Can be called after expiry given no liquidity has been provided.\r\n    \"\"\"\r\n    assert self.liquidity == 0  # dev: liquidity already seeded, use `claim()`\r\n    assert block.timestamp >= self.expiry  # dev: contract not expired\r\n    amount: uint256 = 0\r\n    for i in range(2):\r\n        amount = self.balances[msg.sender][i]\r\n        self.balances[msg.sender][i] = 0\r\n        ERC20(self.tokens[i]).transfer(msg.sender, amount)","ABI":"[{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"router\"},{\"type\":\"address[2]\",\"name\":\"tokens\"},{\"type\":\"uint256[2]\",\"name\":\"target\"},{\"type\":\"uint256\",\"name\":\"duration\"},{\"type\":\"uint256\",\"name\":\"locktime\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"deposit\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256[2]\",\"name\":\"amounts\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":155236},{\"name\":\"provide\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":95286},{\"name\":\"claim\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":51277},{\"name\":\"bail\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":48606},{\"name\":\"router\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1181},{\"name\":\"tokens\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1320},{\"name\":\"target\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1350},{\"name\":\"pair\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1271},{\"name\":\"balances\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"},{\"type\":\"uint256\",\"name\":\"arg1\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1631},{\"name\":\"totals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1446},{\"name\":\"liquidity\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1361},{\"name\":\"expiry\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1391},{\"name\":\"locktime\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1421},{\"name\":\"unlock\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1451}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.8","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000057b946008913b82e4df85f501cbaed910e58d26c000000000000000000000000000000000000000000000000000000174876e8000000000000000000000000000000000000000000000583b8b02231b86c6800000000000000000000000000000000000000000000000000000000000000001c200000000000000000000000000000000000000000000000000000000000015180","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}