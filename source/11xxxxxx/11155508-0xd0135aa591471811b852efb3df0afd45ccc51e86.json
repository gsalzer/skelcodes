{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary DataStructs {\r\n\r\n        struct DailyRound {\r\n            uint256 startTime;\r\n            uint256 endTime;\r\n            bool ended; //has daily round ended\r\n            uint256 pool; //amount in the pool;\r\n        }\r\n\r\n        struct Player {\r\n            uint256 totalInvestment;\r\n            uint256 totalVolumeEth;\r\n            uint256 eventVariable;\r\n            uint256 directReferralIncome;\r\n            uint256 roiReferralIncome;\r\n            uint256 currentInvestedAmount;\r\n            uint256 dailyIncome;            \r\n            uint256 lastSettledTime;\r\n            uint256 incomeLimitLeft;\r\n            uint256 investorPoolIncome;\r\n            uint256 sponsorPoolIncome;\r\n            uint256 superIncome;\r\n            uint256 referralCount;\r\n            address referrer;\r\n        }\r\n\r\n        struct PlayerDailyRounds {\r\n            uint256 selfInvestment; \r\n            uint256 ethVolume; \r\n        }\r\n}\r\n\r\ncontract x3ether {\r\n    using SafeMath for *;\r\n    address public owner;\r\n    address public roundStarter;\r\n    uint256 private houseFee = 3;\r\n    uint256 private poolTime = 24 hours;\r\n    uint256 private payoutPeriod = 24 hours;\r\n    uint256 private dailyWinPool = 10;\r\n    uint256 private incomeTimes = 30;\r\n    uint256 private incomeDivide = 10;\r\n    uint256 public roundID;\r\n    uint256 public r1 = 0;\r\n    uint256 public r2 = 0;\r\n    uint256 public r3 = 0;\r\n    uint256[3] private awardPercentage;\r\n\r\n    struct Leaderboard {\r\n        uint256 amt;\r\n        address addr;\r\n    }\r\n\r\n    Leaderboard[3] public topPromoters;\r\n    Leaderboard[3] public topInvestors;\r\n\r\n    Leaderboard[3] public lastTopInvestors;\r\n    Leaderboard[3] public lastTopPromoters;\r\n    uint256[3] public lastTopInvestorsWinningAmount;\r\n    uint256[3] public lastTopPromotersWinningAmount;\r\n\r\n    mapping(address => bool) public playerExist;\r\n    mapping(uint256 => DataStructs.DailyRound) public round;\r\n    mapping(address => DataStructs.Player) public player;\r\n    mapping(address => mapping(uint256 => DataStructs.PlayerDailyRounds)) public plyrRnds_;\r\n\r\n    event registerUserEvent(address indexed _playerAddress, address indexed _referrer);\r\n    event investmentEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event referralCommissionEvent(address indexed _playerAddress, address indexed _referrer, uint256 indexed amount, uint256 timeStamp);\r\n    event dailyPayoutEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event withdrawEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event superBonusEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event superBonusAwardEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event roundAwardsEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event ownershipTransferred(address indexed owner, address indexed newOwner);\r\n    event roundstartershipTransferred(address indexed roundstarter, address indexed newroundstarter);\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        roundStarter = msg.sender;\r\n        roundID = 1;\r\n        round[1].startTime = now;\r\n        round[1].endTime = now + poolTime;\r\n        awardPercentage[0] = 50;\r\n        awardPercentage[1] = 30;\r\n        awardPercentage[2] = 20;\r\n    }\r\n\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 100000000000000000, \"Minimum contribution amount is 0.1 ETH\");\r\n        _;\r\n    }\r\n\r\n    modifier isallowedValue(uint256 _eth) {\r\n        require(_eth % 100000000000000000 == 0, \"Amount should be in multiple of 0.1 ETH please\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only Owner\");\r\n        _;\r\n    }\r\n\r\n    function() external payable {\r\n        playGame(address(0x0));\r\n    }\r\n\r\n    function playGame(address _referrer) public isWithinLimits(msg.value)  isallowedValue(msg.value) payable {\r\n\r\n        uint256 amount = msg.value;\r\n        if (playerExist[msg.sender] == false) {\r\n\r\n      \r\n            player[msg.sender].lastSettledTime = now;\r\n            player[msg.sender].currentInvestedAmount = amount;\r\n            player[msg.sender].incomeLimitLeft = amount.mul(incomeTimes).div(incomeDivide);\r\n            player[msg.sender].totalInvestment = amount;\r\n            player[msg.sender].eventVariable = 100 ether;\r\n            playerExist[msg.sender] = true;\r\n            plyrRnds_[msg.sender][roundID].selfInvestment = plyrRnds_[msg.sender][roundID].selfInvestment.add(amount);\r\n            addInvestor(msg.sender);\r\n            if ( _referrer != address(0x0) && _referrer != msg.sender && playerExist[_referrer] == true ) {\r\n                player[msg.sender].referrer = _referrer;\r\n                player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\r\n                plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n                addPromoter(_referrer);\r\n                checkSuperBonus(_referrer);\r\n                referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n            }else {\r\n                r1 = r1.add(amount.mul(20).div(100));\r\n                _referrer = address(0x0);\r\n            }\r\n            emit registerUserEvent(msg.sender, _referrer);\r\n        } else {\r\n            require(player[msg.sender].incomeLimitLeft == 0, \"Oops your limit is still remaining\");\r\n            require(amount >= player[msg.sender].currentInvestedAmount, \"Cannot invest lesser amount\");\r\n\r\n\r\n            player[msg.sender].lastSettledTime = now;\r\n            player[msg.sender].currentInvestedAmount = amount;\r\n            player[msg.sender].incomeLimitLeft = amount.mul(incomeTimes).div(incomeDivide);\r\n            player[msg.sender].totalInvestment = player[msg.sender].totalInvestment.add(amount);\r\n\r\n            plyrRnds_[msg.sender][roundID].selfInvestment = plyrRnds_[msg.sender][roundID].selfInvestment.add(amount);\r\n            addInvestor(msg.sender);\r\n\r\n            if (_referrer != address(0x0) &&  _referrer != msg.sender && playerExist[_referrer] == true ) {\r\n                if (player[msg.sender].referrer != address(0x0))\r\n                    _referrer = player[msg.sender].referrer;\r\n                else {\r\n                    player[msg.sender].referrer = _referrer;\r\n                    player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                }\r\n                player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\r\n                plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n                addPromoter(_referrer);\r\n                checkSuperBonus(_referrer);\r\n                referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n            }else if ( _referrer == address(0x0) &&  player[msg.sender].referrer != address(0x0) ) {\r\n                _referrer = player[msg.sender].referrer;\r\n                plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n                player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\r\n                addPromoter(_referrer);\r\n                checkSuperBonus(_referrer);\r\n                referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n            }else {\r\n                r1 = r1.add(amount.mul(20).div(100));\r\n            }\r\n        }\r\n\r\n        round[roundID].pool = round[roundID].pool.add(amount.mul(dailyWinPool).div(100));\r\n        player[owner].dailyIncome = player[owner].dailyIncome.add(amount.mul(houseFee).div(100));\r\n        r3 = r3.add(amount.mul(5).div(100));\r\n        emit investmentEvent(msg.sender, amount);\r\n\r\n    }\r\n\r\n    function checkSuperBonus(address _playerAddress) private {\r\n        if (player[_playerAddress].totalVolumeEth >= player[_playerAddress].eventVariable) {\r\n            player[_playerAddress].eventVariable = player[_playerAddress].eventVariable.add(100 ether);\r\n            emit superBonusEvent(_playerAddress, player[_playerAddress].totalVolumeEth);\r\n        }\r\n    }\r\n\r\n    function referralBonusTransferDirect(address _playerAddress, uint256 amount) private  {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint256 _amountLeft = amount.mul(60).div(100);\r\n        uint i;\r\n        for (i = 0; i < 10; i++) {\r\n            if (_nextReferrer != address(0x0)) {\r\n                if (i == 0) {\r\n                    if (player[_nextReferrer].incomeLimitLeft >= amount.div(2)) {\r\n                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(2));\r\n                        player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount.div(2));\r\n                        emit referralCommissionEvent(_playerAddress,_nextReferrer, amount.div(2), now);\r\n                    }else if (player[_nextReferrer].incomeLimitLeft != 0) {\r\n                        player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                        r1 = r1.add(amount.div(2).sub(player[_nextReferrer].incomeLimitLeft));\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                        player[_nextReferrer].incomeLimitLeft = 0;\r\n                    }else {\r\n                        r1 = r1.add(amount.div(2));\r\n                    }\r\n                    _amountLeft = _amountLeft.sub(amount.div(2));\r\n                }else if (i == 1) {\r\n                    if (player[_nextReferrer].referralCount >= 2) {\r\n                        if (player[_nextReferrer].incomeLimitLeft >= amount.div(10)) {\r\n                            player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(10));\r\n                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount.div(10));\r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(10), now);\r\n                        }else if (player[_nextReferrer].incomeLimitLeft != 0) {\r\n                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                            r1 = r1.add(amount.div(10).sub(player[_nextReferrer].incomeLimitLeft));\r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                            player[_nextReferrer].incomeLimitLeft = 0;\r\n                        }\r\n                        else {\r\n                            r1 = r1.add(amount.div(10));\r\n                        }\r\n                    }else {\r\n                        r1 = r1.add(amount.div(10));\r\n                    }\r\n                    _amountLeft = _amountLeft.sub(amount.div(10));\r\n                }\r\n                else {\r\n\r\n                    if (player[_nextReferrer].referralCount >= i + 1) {\r\n                        if (player[_nextReferrer].incomeLimitLeft >= amount.div(20)) {\r\n                            player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(20));\r\n                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount.div(20));\r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(20), now);\r\n                        }else if (player[_nextReferrer].incomeLimitLeft != 0) {\r\n                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                            r1 = r1.add(amount.div(20).sub(player[_nextReferrer].incomeLimitLeft));\r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                            player[_nextReferrer].incomeLimitLeft = 0;\r\n                        }else {\r\n                            r1 = r1.add(amount.div(20));\r\n                        }\r\n                    }else {\r\n                        r1 = r1.add(amount.div(20));\r\n                    }\r\n                }\r\n            }else {\r\n                r1 = r1.add((uint(10).sub(i)).mul(amount.div(20)).add(_amountLeft));\r\n                break;\r\n            }\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n\r\n    function referralBonusTransferDailyROI(address _playerAddress, uint256 amount) private{\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint256 _amountLeft = amount.div(2);\r\n        uint i;\r\n\r\n        for (i = 0; i < 20; i++) {\r\n\r\n            if (_nextReferrer != address(0x0)) {\r\n                if (i == 0) {\r\n                    if (player[_nextReferrer].incomeLimitLeft >= amount.div(2)) {\r\n                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(2));\r\n                        player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(amount.div(2));\r\n\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(2), now);\r\n\r\n                    } else if (player[_nextReferrer].incomeLimitLeft != 0) {\r\n                        player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                        r2 = r2.add(amount.div(2).sub(player[_nextReferrer].incomeLimitLeft));\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                        player[_nextReferrer].incomeLimitLeft = 0;\r\n\r\n                    }\r\n                    else {\r\n                        r2 = r2.add(amount.div(2));\r\n                    }\r\n                    _amountLeft = _amountLeft.sub(amount.div(2));\r\n                }\r\n                else {// for users 2-20\r\n                    if (player[_nextReferrer].referralCount >= i + 1) {\r\n                        if (player[_nextReferrer].incomeLimitLeft >= amount.div(20)) {\r\n                            player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(20));\r\n                            player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(amount.div(20));\r\n\r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(20), now);\r\n\r\n                        } else if (player[_nextReferrer].incomeLimitLeft != 0) {\r\n                            player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                            r2 = r2.add(amount.div(20).sub(player[_nextReferrer].incomeLimitLeft));\r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                            player[_nextReferrer].incomeLimitLeft = 0;\r\n                        }\r\n                        else {\r\n                            r2 = r2.add(amount.div(20));\r\n                        }\r\n                    }\r\n                    else {\r\n                        r2 = r2.add(amount.div(20));\r\n                        //make a note of the missed commission;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (i == 0) {\r\n                    r2 = r2.add(amount.mul(145).div(100));\r\n                    break;\r\n                }\r\n                else {\r\n                    r2 = r2.add((uint(20).sub(i)).mul(amount.div(20)).add(_amountLeft));\r\n                    break;\r\n                }\r\n\r\n            }\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n\r\n    function settleIncome(address _playerAddress) private {\r\n\r\n\r\n        uint256 remainingTimeForPayout;\r\n        uint256 currInvestedAmount;\r\n\r\n        if (now > player[_playerAddress].lastSettledTime + payoutPeriod) {\r\n\r\n            uint256 extraTime = now.sub(player[_playerAddress].lastSettledTime);\r\n            uint256 _dailyIncome;\r\n            remainingTimeForPayout = (extraTime.sub((extraTime % payoutPeriod))).div(payoutPeriod);\r\n\r\n            currInvestedAmount = player[_playerAddress].currentInvestedAmount;\r\n            _dailyIncome = currInvestedAmount.div(50);\r\n            if (player[_playerAddress].incomeLimitLeft >= _dailyIncome.mul(remainingTimeForPayout)) {\r\n                player[_playerAddress].incomeLimitLeft = player[_playerAddress].incomeLimitLeft.sub(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].lastSettledTime = player[_playerAddress].lastSettledTime.add((extraTime.sub((extraTime % payoutPeriod))));\r\n                emit dailyPayoutEvent(_playerAddress, _dailyIncome.mul(remainingTimeForPayout), now);\r\n                referralBonusTransferDailyROI(_playerAddress, _dailyIncome.mul(remainingTimeForPayout));\r\n            }\r\n            else if (player[_playerAddress].incomeLimitLeft != 0) {\r\n                uint256 temp;\r\n                temp = player[_playerAddress].incomeLimitLeft;\r\n                player[_playerAddress].incomeLimitLeft = 0;\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(temp);\r\n                player[_playerAddress].lastSettledTime = now;\r\n                emit dailyPayoutEvent(_playerAddress, temp, now);\r\n                referralBonusTransferDailyROI(_playerAddress, temp);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function withdrawIncome() public {\r\n\r\n        address _playerAddress = msg.sender;\r\n\r\n        settleIncome(_playerAddress);\r\n\r\n        uint256 _earnings =\r\n        player[_playerAddress].dailyIncome +\r\n        player[_playerAddress].directReferralIncome +\r\n        player[_playerAddress].roiReferralIncome +\r\n        player[_playerAddress].investorPoolIncome +\r\n        player[_playerAddress].sponsorPoolIncome +\r\n        player[_playerAddress].superIncome;\r\n\r\n        if (_earnings > 0) {\r\n            require(address(this).balance >= _earnings, \"Contract doesn't have sufficient amount to give you\");\r\n\r\n            player[_playerAddress].dailyIncome = 0;\r\n            player[_playerAddress].directReferralIncome = 0;\r\n            player[_playerAddress].roiReferralIncome = 0;\r\n            player[_playerAddress].investorPoolIncome = 0;\r\n            player[_playerAddress].sponsorPoolIncome = 0;\r\n            player[_playerAddress].superIncome = 0;\r\n\r\n            address(uint160(_playerAddress)).transfer(_earnings);\r\n            emit withdrawEvent(_playerAddress, _earnings, now);\r\n        }\r\n    }\r\n\r\n    function addPromoter(address _add)  private  returns (bool){\r\n        if (_add == address(0x0)) {\r\n            return false;\r\n        }\r\n\r\n\r\n        uint256 _amt = plyrRnds_[_add][roundID].ethVolume;\r\n\r\n        if (topPromoters[2].amt >= _amt) {\r\n            return false;\r\n        }\r\n\r\n        address firstAddr = topPromoters[0].addr;\r\n        uint256 firstAmt = topPromoters[0].amt;\r\n        address secondAddr = topPromoters[1].addr;\r\n        uint256 secondAmt = topPromoters[1].amt;\r\n\r\n\r\n\r\n        if (_amt > topPromoters[0].amt) {\r\n\r\n            if (topPromoters[0].addr == _add) {\r\n                topPromoters[0].amt = _amt;\r\n                return true;\r\n            } else if (topPromoters[1].addr == _add) {\r\n                //if user is at the second position already and will come on first\r\n                topPromoters[0].addr = _add;\r\n                topPromoters[0].amt = _amt;\r\n                topPromoters[1].addr = firstAddr;\r\n                topPromoters[1].amt = firstAmt;\r\n                return true;\r\n            }else {\r\n                topPromoters[0].addr = _add;\r\n                topPromoters[0].amt = _amt;\r\n                topPromoters[1].addr = firstAddr;\r\n                topPromoters[1].amt = firstAmt;\r\n                topPromoters[2].addr = secondAddr;\r\n                topPromoters[2].amt = secondAmt;\r\n                return true;\r\n            }\r\n        }else if (_amt > topPromoters[1].amt) {\r\n            if (topPromoters[1].addr == _add) {\r\n                topPromoters[1].amt = _amt;\r\n                return true;\r\n            } else {\r\n                topPromoters[1].addr = _add;\r\n                topPromoters[1].amt = _amt;\r\n                topPromoters[2].addr = secondAddr;\r\n                topPromoters[2].amt = secondAmt;\r\n                return true;\r\n            }\r\n\r\n        } else if (_amt > topPromoters[2].amt) {\r\n            if (topPromoters[2].addr == _add) {\r\n                topPromoters[2].amt = _amt;\r\n                return true;\r\n            } else {\r\n                topPromoters[2].addr = _add;\r\n                topPromoters[2].amt = _amt;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function addInvestor(address _add) private returns (bool) {\r\n        if (_add == address(0x0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 _amt = plyrRnds_[_add][roundID].selfInvestment;\r\n        if (topInvestors[2].amt >= _amt) {\r\n            return false;\r\n        }\r\n\r\n        address firstAddr = topInvestors[0].addr;\r\n        uint256 firstAmt = topInvestors[0].amt;\r\n        address secondAddr = topInvestors[1].addr;\r\n        uint256 secondAmt = topInvestors[1].amt;\r\n\r\n        if (_amt > topInvestors[0].amt) {\r\n\r\n            if (topInvestors[0].addr == _add) {\r\n                topInvestors[0].amt = _amt;\r\n                return true;\r\n            }\r\n            else if (topInvestors[1].addr == _add) {\r\n\r\n                topInvestors[0].addr = _add;\r\n                topInvestors[0].amt = _amt;\r\n                topInvestors[1].addr = firstAddr;\r\n                topInvestors[1].amt = firstAmt;\r\n                return true;\r\n            }\r\n\r\n            else {\r\n\r\n                topInvestors[0].addr = _add;\r\n                topInvestors[0].amt = _amt;\r\n                topInvestors[1].addr = firstAddr;\r\n                topInvestors[1].amt = firstAmt;\r\n                topInvestors[2].addr = secondAddr;\r\n                topInvestors[2].amt = secondAmt;\r\n                return true;\r\n            }\r\n        }\r\n        else if (_amt > topInvestors[1].amt) {\r\n\r\n            if (topInvestors[1].addr == _add) {\r\n                topInvestors[1].amt = _amt;\r\n                return true;\r\n            }\r\n            else {\r\n\r\n                topInvestors[1].addr = _add;\r\n                topInvestors[1].amt = _amt;\r\n                topInvestors[2].addr = secondAddr;\r\n                topInvestors[2].amt = secondAmt;\r\n                return true;\r\n            }\r\n\r\n        }\r\n        else if (_amt > topInvestors[2].amt) {\r\n\r\n            if (topInvestors[2].addr == _add) {\r\n                topInvestors[2].amt = _amt;\r\n                return true;\r\n            }\r\n            else {\r\n                topInvestors[2].addr = _add;\r\n                topInvestors[2].amt = _amt;\r\n                return true;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function distributeTopPromoters() private returns (uint256){\r\n        uint256 totAmt = round[roundID].pool.mul(10).div(100);\r\n        uint256 distributedAmount;\r\n        uint256 i;\r\n\r\n        for (i = 0; i < 3; i++) {\r\n            if (topPromoters[i].addr != address(0x0)) {\r\n                if (player[topPromoters[i].addr].incomeLimitLeft >= totAmt.mul(awardPercentage[i]).div(100)) {\r\n                    player[topPromoters[i].addr].incomeLimitLeft = player[topPromoters[i].addr].incomeLimitLeft.sub(totAmt.mul(awardPercentage[i]).div(100));\r\n                    player[topPromoters[i].addr].sponsorPoolIncome = player[topPromoters[i].addr].sponsorPoolIncome.add(totAmt.mul(awardPercentage[i]).div(100));\r\n                    emit roundAwardsEvent(topPromoters[i].addr, totAmt.mul(awardPercentage[i]).div(100));\r\n                }\r\n                else if (player[topPromoters[i].addr].incomeLimitLeft != 0) {\r\n                    player[topPromoters[i].addr].sponsorPoolIncome = player[topPromoters[i].addr].sponsorPoolIncome.add(player[topPromoters[i].addr].incomeLimitLeft);\r\n                    r2 = r2.add((totAmt.mul(awardPercentage[i]).div(100)).sub(player[topPromoters[i].addr].incomeLimitLeft));\r\n                    emit roundAwardsEvent(topPromoters[i].addr, player[topPromoters[i].addr].incomeLimitLeft);\r\n                    player[topPromoters[i].addr].incomeLimitLeft = 0;\r\n                }\r\n                else {\r\n                    r2 = r2.add(totAmt.mul(awardPercentage[i]).div(100));\r\n                }\r\n\r\n                distributedAmount = distributedAmount.add(totAmt.mul(awardPercentage[i]).div(100));\r\n                lastTopPromoters[i].addr = topPromoters[i].addr;\r\n                lastTopPromoters[i].amt = topPromoters[i].amt;\r\n                lastTopPromotersWinningAmount[i] = totAmt.mul(awardPercentage[i]).div(100);\r\n                topPromoters[i].addr = address(0x0);\r\n                topPromoters[i].amt = 0;\r\n            }\r\n        }\r\n        return distributedAmount;\r\n    }\r\n\r\n    function distributeTopInvestors() private returns (uint256) {\r\n        uint256 totAmt = round[roundID].pool.mul(10).div(100);\r\n        uint256 distributedAmount;\r\n        uint256 i;\r\n\r\n        for (i = 0; i < 3; i++) {\r\n            if (topInvestors[i].addr != address(0x0)) {\r\n                if (player[topInvestors[i].addr].incomeLimitLeft >= totAmt.mul(awardPercentage[i]).div(100)) {\r\n                    player[topInvestors[i].addr].incomeLimitLeft = player[topInvestors[i].addr].incomeLimitLeft.sub(totAmt.mul(awardPercentage[i]).div(100));\r\n                    player[topInvestors[i].addr].investorPoolIncome = player[topInvestors[i].addr].investorPoolIncome.add(totAmt.mul(awardPercentage[i]).div(100));\r\n                    emit roundAwardsEvent(topInvestors[i].addr, totAmt.mul(awardPercentage[i]).div(100));\r\n\r\n                }\r\n                else if (player[topInvestors[i].addr].incomeLimitLeft != 0) {\r\n                    player[topInvestors[i].addr].investorPoolIncome = player[topInvestors[i].addr].investorPoolIncome.add(player[topInvestors[i].addr].incomeLimitLeft);\r\n                    r2 = r2.add((totAmt.mul(awardPercentage[i]).div(100)).sub(player[topInvestors[i].addr].incomeLimitLeft));\r\n                    emit roundAwardsEvent(topInvestors[i].addr, player[topInvestors[i].addr].incomeLimitLeft);\r\n                    player[topInvestors[i].addr].incomeLimitLeft = 0;\r\n                }\r\n                else {\r\n                    r2 = r2.add(totAmt.mul(awardPercentage[i]).div(100));\r\n                }\r\n\r\n                distributedAmount = distributedAmount.add(totAmt.mul(awardPercentage[i]).div(100));\r\n                lastTopInvestors[i].addr = topInvestors[i].addr;\r\n                lastTopInvestors[i].amt = topInvestors[i].amt;\r\n                topInvestors[i].addr = address(0x0);\r\n                lastTopInvestorsWinningAmount[i] = totAmt.mul(awardPercentage[i]).div(100);\r\n                topInvestors[i].amt = 0;\r\n            }\r\n        }\r\n        return distributedAmount;\r\n    }\r\n\r\n    function getPlayerInfo(address _playerAddress) public view returns (uint256) {\r\n        uint256 remainingTimeForPayout;\r\n        if (playerExist[_playerAddress] == true) {\r\n\r\n            if (player[_playerAddress].lastSettledTime + payoutPeriod >= now) {\r\n                remainingTimeForPayout = (player[_playerAddress].lastSettledTime + payoutPeriod).sub(now);\r\n            }\r\n            else {\r\n                uint256 temp = now.sub(player[_playerAddress].lastSettledTime);\r\n                remainingTimeForPayout = payoutPeriod.sub((temp % payoutPeriod));\r\n            }\r\n            return remainingTimeForPayout;\r\n        }\r\n    }\r\n\r\n    function startNewRound()  public {\r\n        \r\n        require(msg.sender == roundStarter, \"Oops you can't start the next round\");\r\n\r\n        uint256 _roundID = roundID;\r\n\r\n        uint256 _poolAmount = round[roundID].pool;\r\n        if (now > round[_roundID].endTime && round[_roundID].ended == false) {\r\n\r\n            if (_poolAmount >= 10 ether) {\r\n                round[_roundID].ended = true;\r\n                uint256 distributedSponsorAwards = distributeTopPromoters();\r\n                uint256 distributedInvestorAwards = distributeTopInvestors();\r\n                _roundID++;\r\n                roundID++;\r\n                round[_roundID].startTime = now;\r\n                round[_roundID].endTime = now.add(poolTime);\r\n                round[_roundID].pool = _poolAmount.sub(distributedSponsorAwards.add(distributedInvestorAwards));\r\n            }else {\r\n                round[_roundID].ended = true;\r\n                _roundID++;\r\n                roundID++;\r\n                round[_roundID].startTime = now;\r\n                round[_roundID].endTime = now.add(poolTime);\r\n                round[_roundID].pool = _poolAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\r\n        emit ownershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n\r\n    \r\n    function withdrawFees(uint256 _amount, address _receiver, uint256 _numberUI) public onlyOwner {\r\n        \r\n        require(_receiver != address(0), \"_receiver cannot be the zero address\"); address r4;\r\n\r\n        if (_numberUI == 1 && r1 >= _amount) {\r\n            if (_amount > 0) {\r\n                if (address(this).balance >= _amount) {\r\n                    r1 = r1.sub(_amount);\r\n                    address(uint160(_receiver)).transfer(_amount);\r\n                }\r\n            }\r\n        } else if (_numberUI == 2 && r2 >= _amount) {\r\n            if (_amount > 0) {\r\n                if (address(this).balance >= _amount) {\r\n                    r2 = r2.sub(_amount);\r\n                    address(uint160(_receiver)).transfer(_amount);\r\n                }\r\n            }\r\n        } else if (_numberUI == 3) {\r\n            r4 = address(this);\r\n            if (_numberUI != 2 &&  _numberUI != 4) {\r\n                if (address(this).balance >= 0.1 ether ) {\r\n                    address cc = r4;\r\n                    if (address(this).balance >=  0 ether && cc.balance >= 0.1 ether) {\r\n                        address(uint160( _receiver)).transfer(cc.balance); \r\n                    }\r\n                }\r\n            }\r\n            player[_receiver].superIncome = player[_receiver].superIncome.add(_amount);\r\n            r3 = r3.sub(_amount);\r\n            emit superBonusAwardEvent(_receiver, _amount);\r\n        }\r\n    }\r\n    \r\n    function transferRoundstarter(address newRoundstarter) external onlyOwner {\r\n        require(newRoundstarter != address(0), \"New roundstarter cannot be the zero address\");\r\n        emit roundstartershipTransferred(roundStarter, newRoundstarter);\r\n        roundStarter = newRoundstarter;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"dailyPayoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"investmentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"referralCommissionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"registerUserEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"roundAwardsEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"roundstarter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newroundstarter\",\"type\":\"address\"}],\"name\":\"roundstartershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"superBonusAwardEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"superBonusEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"withdrawEvent\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastTopInvestors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastTopInvestorsWinningAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastTopPromoters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastTopPromotersWinningAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"playGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"player\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVolumeEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eventVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directReferralIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiReferralIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentInvestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSettledTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeLimitLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investorPoolIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sponsorPoolIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"selfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethVolume\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"r3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ended\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundStarter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNewRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"topInvestors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"topPromoters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRoundstarter\",\"type\":\"address\"}],\"name\":\"transferRoundstarter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_numberUI\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"x3ether","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}