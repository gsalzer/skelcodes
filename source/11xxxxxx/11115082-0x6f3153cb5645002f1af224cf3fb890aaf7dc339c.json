{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n\r\n * GearProtocol's Liquidity Provider Vault\r\n \r\n * Smart contract to incentivize GEAR liquidity providers with a limited supply utility token, GearAutomatic (AUTO).\r\n\r\n * Official Website: \r\n   https://www.GearProtocol.com\r\n \r\n */\r\n\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ninterface ERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function approveAndCall(address spender, uint tokens, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath \r\n{\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0) \r\n        {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) \r\n    {\r\n        uint256 c = add(a,m);\r\n        uint256 d = sub(c,1);\r\n        return mul(div(d,m),m);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract GearLPvault_v2 {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    ERC20 constant liquidityToken = ERC20(0x850C581e52759Da131e06c37B5Af479a2E4e4525);\r\n    ERC20 constant autoToken = ERC20(0xAD1F5e38edD65Cb2F0C447214f0A0Ea2c191CFD9);\r\n    \r\n    mapping (address => uint256) private balances;\r\n\r\n    uint256 public fullUnitsFarmed_total = 0;\r\n    uint256 public totalFarmers = 0;\r\n    uint8  constant tokenDecimals = 18;\r\n    mapping (address => bool) public isFarming;\r\n\r\n    uint256 _totalRewardsPerUnit = 0;\r\n    uint256 private farmingRewards = 0;\r\n    mapping (address => uint256) private _totalRewardsPerUnit_positions;\r\n    mapping (address => uint256) private _savedRewards;\r\n    mapping (address => uint256) private _savedBalances;\r\n    \r\n    //these addresses won't be affected by harvest fee \r\n    mapping(address => bool) public whitelistTo;\r\n    event WhitelistTo(address _addr, bool _whitelisted);\r\n    \r\n    address cowner = msg.sender;\r\n    uint256 public lastAutoDistribution = now;\r\n    \r\n\r\n     modifier onlyOwner() {\r\n        require(msg.sender == cowner, \"only owner\");\r\n        _;\r\n       }\r\n     \r\n     function totalSupply() public view returns (uint256) \r\n      {\r\n        return liquidityToken.totalSupply();\r\n      }\r\n        \r\n       function balanceOf(address owner) public view returns (uint256) \r\n      {\r\n        return liquidityToken.balanceOf(owner);\r\n      }\r\n      \r\n      function AutoBalanceOf(address owner) public view returns (uint256) \r\n      {\r\n        return autoToken.balanceOf(owner);\r\n      }\r\n      \r\n      function fullUnitsFarmed(address owner) external view returns (uint256) \r\n       {\r\n        return isFarming[owner] ? toFullUnits(_savedBalances[owner]) : 0;\r\n       }\r\n    \r\n     function toFullUnits(uint256 valueWithDecimals) public pure returns (uint256) \r\n       {\r\n        return valueWithDecimals.div(10**uint256(tokenDecimals));\r\n       }    \r\n    \r\n    //Distribute a daily quota of AUTO token reward to all liquidity providers currently farming.\r\n    function distributeAuto() external {\r\n        uint256 autoBalance = autoToken.balanceOf(address(this));\r\n        require(lastAutoDistribution < now);\r\n        uint256 Percent = autoBalance.mul(1).div(1000);\r\n        \r\n         \r\n        if(fullUnitsFarmed_total > 0)\r\n        {\r\n            farmingRewards = farmingRewards.add(Percent);\r\n            \r\n            //split up to rewards per unit in farm\r\n            uint256 rewardsPerUnit = farmingRewards.div(fullUnitsFarmed_total);\r\n            //apply reward\r\n            _totalRewardsPerUnit = _totalRewardsPerUnit.add(rewardsPerUnit);\r\n            balances[address(this)] = balances[address(this)].add(farmingRewards);\r\n            farmingRewards = 0;\r\n            \r\n        }\r\n        \r\n            lastAutoDistribution = lastAutoDistribution + 24 hours;\r\n    } \r\n    \r\n    \r\n\r\n    //catch up with the current total harvest rewards. \r\n    function updateRewardsFor(address farmer) private\r\n    {\r\n        _savedRewards[farmer] = viewHarvest(farmer);\r\n        _totalRewardsPerUnit_positions[farmer] = _totalRewardsPerUnit;\r\n    }\r\n    \r\n    //get all harvest rewards that have not been claimed yet\r\n    function viewHarvest(address farmer) public view returns (uint256)\r\n    {\r\n        if(!isFarming[farmer])\r\n            return _savedRewards[farmer];\r\n        uint256 newRewardsPerUnit = _totalRewardsPerUnit.sub(_totalRewardsPerUnit_positions[farmer]);\r\n        \r\n        uint256 newRewards = newRewardsPerUnit.mul(toFullUnits(liquidityToken.balanceOf(farmer)));\r\n        return _savedRewards[farmer].add(newRewards);\r\n    }\r\n    \r\n    \r\n    //pay out unclaimed harvest rewards\r\n    function harvest() public\r\n    {\r\n        updateRewardsFor(msg.sender);\r\n        uint256 rewards = _savedRewards[msg.sender];\r\n        require(rewards > 0 && rewards <= balances[address(this)]);\r\n        require(_savedBalances[msg.sender] == liquidityToken.balanceOf(msg.sender));\r\n        \r\n        _savedRewards[msg.sender] = 0;\r\n        \r\n         uint256 fivePercent = 0;\r\n         uint256 reward = 0;\r\n        \r\n         if(!whitelistTo[msg.sender]) \r\n         {\r\n            fivePercent = rewards.mul(3).div(100);\r\n         \r\n            //set a minimum  rate to prevent no harvest-fee-txs due to precision loss\r\n            if(fivePercent == 0 && rewards > 0) \r\n                fivePercent = 1;\r\n        }\r\n        \r\n        reward = rewards.sub(fivePercent);\r\n        \r\n       // Distribute daily AUTO incentive \r\n       if(lastAutoDistribution < now)\r\n       {\r\n        uint256 autoBalance = autoToken.balanceOf(address(this));\r\n        \r\n        uint256 Percent = autoBalance.mul(1).div(1000);\r\n        \r\n         \r\n        if(fullUnitsFarmed_total > 0)\r\n        \r\n            farmingRewards = farmingRewards.add(Percent);\r\n            //split up to rewards per unit in farm\r\n            uint256 rewardsPerUnit = farmingRewards.div(fullUnitsFarmed_total);\r\n            //apply reward\r\n            _totalRewardsPerUnit = _totalRewardsPerUnit.add(rewardsPerUnit);\r\n            balances[address(this)] = balances[address(this)].add(farmingRewards);\r\n            farmingRewards = 0;\r\n        \r\n             lastAutoDistribution = lastAutoDistribution + 24 hours;\r\n        } \r\n\r\n         //transfer\r\n         balances[address(this)] = balances[address(this)].sub(rewards);\r\n         autoToken.transfer(msg.sender, reward);\r\n         autoToken.transfer(cowner, fivePercent);\r\n    }\r\n    \r\n    function enableFarming() public { _enableFarming(msg.sender);  }\r\n    \r\n    function disableFarming() public { _disableFarming(msg.sender); }\r\n    \r\n    //enable farming\r\n    function _enableFarming(address farmer) private\r\n    {\r\n        require(!isFarming[farmer]);\r\n        updateRewardsFor(farmer);\r\n        isFarming[farmer] = true;\r\n        fullUnitsFarmed_total = fullUnitsFarmed_total.add(toFullUnits(liquidityToken.balanceOf(farmer)));\r\n        _savedBalances[farmer] = liquidityToken.balanceOf(farmer);\r\n        totalFarmers = totalFarmers.add(1);\r\n       \r\n       // Distribute daily AUTO incentive \r\n       if(lastAutoDistribution < now)\r\n       {\r\n        uint256 autoBalance = autoToken.balanceOf(address(this));\r\n        \r\n        uint256 Percent = autoBalance.mul(1).div(1000);\r\n        \r\n         \r\n        if(fullUnitsFarmed_total > 0)\r\n        \r\n            farmingRewards = farmingRewards.add(Percent);\r\n            //split up to rewards per unit in farm\r\n            uint256 rewardsPerUnit = farmingRewards.div(fullUnitsFarmed_total);\r\n            //apply reward\r\n            _totalRewardsPerUnit = _totalRewardsPerUnit.add(rewardsPerUnit);\r\n            balances[address(this)] = balances[address(this)].add(farmingRewards);\r\n            farmingRewards = 0;\r\n        \r\n            lastAutoDistribution = lastAutoDistribution + 24 hours;\r\n        } \r\n    }\r\n    \r\n    \r\n    //disable farming\r\n    function _disableFarming(address farmer) private\r\n    {\r\n        require(isFarming[farmer]);\r\n        harvest();\r\n        isFarming[farmer] = false;\r\n        fullUnitsFarmed_total = fullUnitsFarmed_total.sub(toFullUnits(_savedBalances[farmer]));\r\n        _savedBalances[farmer] = 0;\r\n        totalFarmers = totalFarmers.sub(1);\r\n        \r\n        // Distribute daily AUTO incentive \r\n       if(lastAutoDistribution < now)\r\n       {\r\n        uint256 autoBalance = autoToken.balanceOf(address(this));\r\n        \r\n        uint256 Percent = autoBalance.mul(1).div(1000);\r\n        \r\n         \r\n        if(fullUnitsFarmed_total > 0)\r\n        \r\n            farmingRewards = farmingRewards.add(Percent);\r\n            //split up to rewards per unit in farm\r\n            uint256 rewardsPerUnit = farmingRewards.div(fullUnitsFarmed_total);\r\n            //apply reward\r\n            _totalRewardsPerUnit = _totalRewardsPerUnit.add(rewardsPerUnit);\r\n            balances[address(this)] = balances[address(this)].add(farmingRewards);\r\n            farmingRewards = 0;\r\n        \r\n             lastAutoDistribution = lastAutoDistribution + 24 hours;\r\n        } \r\n    }\r\n    \r\n    \r\n     //disable farming for target address \r\n     function disableFarmingFor(address farmer) public onlyOwner\r\n      {\r\n        require(isFarming[farmer]); \r\n        isFarming[farmer] = false;\r\n        fullUnitsFarmed_total = fullUnitsFarmed_total.sub(toFullUnits(_savedBalances[farmer]));\r\n        _savedBalances[farmer] = 0;\r\n        totalFarmers = totalFarmers.sub(1);\r\n        \r\n        // Distribute daily AUTO incentive \r\n       if(lastAutoDistribution < now)\r\n       {\r\n        uint256 autoBalance = autoToken.balanceOf(address(this));\r\n        \r\n        uint256 OnePercent = autoBalance.mul(1).div(1000);\r\n        \r\n         \r\n        if(fullUnitsFarmed_total > 0)\r\n        \r\n            farmingRewards = farmingRewards.add(OnePercent);\r\n            //split up to rewards per unit in farm\r\n            uint256 rewardsPerUnit = farmingRewards.div(fullUnitsFarmed_total);\r\n            //apply reward\r\n            _totalRewardsPerUnit = _totalRewardsPerUnit.add(rewardsPerUnit);\r\n            balances[address(this)] = balances[address(this)].add(farmingRewards);\r\n            farmingRewards = 0;\r\n        \r\n            lastAutoDistribution = lastAutoDistribution + 24 hours;\r\n        } \r\n        \r\n      }\r\n    \r\n    \r\n    //withdraw tokens that were sent to this contract by accident\r\n    function withdrawERC20Tokens(address tokenAddress, uint256 amount) public payable onlyOwner\r\n    {\r\n        ERC20(tokenAddress).transfer(msg.sender, amount);\r\n    }\r\n    \r\n    //no fees if receiver is whitelisted\r\n    function setWhitelistedTo(address _addr, bool _whitelisted) external onlyOwner {\r\n        emit WhitelistTo(_addr, _whitelisted);\r\n        whitelistTo[_addr] = _whitelisted;\r\n    }\r\n\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"WhitelistTo\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AutoBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableFarming\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farmer\",\"type\":\"address\"}],\"name\":\"disableFarmingFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeAuto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableFarming\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"fullUnitsFarmed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fullUnitsFarmed_total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFarming\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAutoDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"valueWithDecimals\",\"type\":\"uint256\"}],\"name\":\"toFullUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFarmers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farmer\",\"type\":\"address\"}],\"name\":\"viewHarvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20Tokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"GearLPvault_v2","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://657e38c87a6d83166677daf33dccb1c8c38dbfd445447aaaeb8cefc8d9885d08"}]}