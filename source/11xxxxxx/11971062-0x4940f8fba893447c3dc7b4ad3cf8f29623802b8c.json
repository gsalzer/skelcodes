{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Lib.sol\\\";\\n\\n\\n/// @title MinimalProxy Factory\\n/// @author coinstructor.io\\n/// @dev Refer to https://eips.ethereum.org/EIPS/eip-1167 for details\\n/// @notice The Factory contract creates Minimal Proxies using EIP1167,\\n/// @notice which point to ERC20 contracts implementation, this saving on gas\\ncontract ERC20Factory {\\n  // Service fee for each MinimalProxy creation\\n  uint256 constant serviceFee = 50000000000000000; // 0.05 ETH\\n\\n  // The owner of the contract, who receives the funds\\n  address payable immutable public owner;\\n\\n  address immutable public signer;\\n  bool public requireSigned;\\n\\n  /// @notice Event will be emitted every time a new ERC20 MinimalProxy is created\\n  /// @param newERC20Address is an address of the newly created ERC20 token MinimalProxy\\n  event ERC20Created(address newERC20Address);\\n\\n  // EIP712 niceties\\n  bytes32 public DOMAIN_SEPARATOR;\\n\\n  string public constant version = \\\"1\\\";\\n\\n  constructor(address payable _owner, address _signer) {\\n    owner = _owner;\\n    signer = _signer;\\n    uint256 chainId = 0;\\n    assembly {\\n        chainId := chainid()\\n    }\\n    DOMAIN_SEPARATOR = keccak256(abi.encode(\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n        keccak256(bytes(\\\"ERC20Factory\\\")),\\n        keccak256(bytes(version)),\\n        1, //chainId,\\n        address(this)\\n    ));\\n  }\\n\\n  /// @notice Creates a MinimalProxy contract via EIP1167 assembly code\\n  /// @dev Using this implementation: https://github.com/optionality/clone-factory\\n  /// @param target is an address of implementation, to which the MinimalProxy will point to\\n  /// @return result is an address of a newly created MinimalProxy\\n  function createClone(address target) internal returns (address result) {\\n    bytes20 targetBytes = bytes20(target);\\n    assembly {\\n      let clone := mload(0x40)\\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n      mstore(add(clone, 0x14), targetBytes)\\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n      result := create(0, clone, 0x37)\\n    }\\n  }\\n\\n  /// @notice Tests if MinimalProxy instance really points to the correct implementation\\n  /// @param target is an address of implementation, to which the MinimalProxy should point to\\n  /// @param query is an address of MinimalProxy that needs to be tested\\n  /// @return result is true if MinimalProxy really points to the implementation address\\n  function isClone(address target, address query) external view returns (bool result) {\\n    bytes20 targetBytes = bytes20(target);\\n    assembly {\\n      let clone := mload(0x40)\\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\\n      mstore(add(clone, 0xa), targetBytes)\\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n\\n      let other := add(clone, 0x40)\\n      extcodecopy(query, other, 0, 0x2d)\\n      result := and(\\n        eq(mload(clone), mload(other)),\\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\\n      )\\n    }\\n  }\\n\\n  /// @notice Pays out all Factory ETH balance to owners address\\n  function payout() external {\\n    require(owner.send(address(this).balance));\\n  }\\n\\n  /// @notice Pays out all Factory ERC20 token balance to owners address\\n  /// @param _tokenAddress is an address of the ERC20 token to payout\\n  function payoutToken(address _tokenAddress) external {\\n    IERC20Lib token = IERC20Lib(_tokenAddress);\\n    uint256 amount = token.balanceOf(address(this));\\n    require(amount \\u003e 0, \\\"Nothing to payout\\\");\\n    token.transfer(owner, amount);\\n  }\\n\\n  /// @notice Creates and initializes the ERC20 MinimalProxy contract\\n  /// @param libraryAddress_ is an address of implementation, to which the MinimalProxy should point to\\n  /// @param name_ is the ERC20 token name\\n  /// @param symbol_ is the ERC20 token symbol\\n  /// @param totalSupply_ is the ERC20 token totalSupply that will be minted to msg.sender\\n  function createERC20(address libraryAddress_, string memory name_, string memory symbol_, uint256 totalSupply_) payable external {\\n    // The service fee should be paid when calling this function\\n    require(msg.value \\u003e= serviceFee, \\\"Service Fee of 0.05ETH wasn\\u0027t paid\\\");\\n    address clone = createClone(libraryAddress_);\\n    IERC20Lib(clone).init(msg.sender, name_, symbol_, totalSupply_);\\n    emit ERC20Created(clone);\\n  }\\n\\n  /// @notice Creates and initializes the ERC20 MinimalProxy contract\\n  /// @param libraryAddress_ is an address of implementation, to which the MinimalProxy should point to\\n  /// @param name_ is the ERC20 token name\\n  /// @param symbol_ is the ERC20 token symbol\\n  /// @param totalSupply_ is the ERC20 token totalSupply that will be minted to msg.sender\\n  /// @param referral_ is the referral, who will receive 0.01 ETH from the deployment\\n  function createERC20WithReferral(address libraryAddress_, string memory name_, string memory symbol_, uint256 totalSupply_, address payable referral_) payable external {\\n    // The service fee should be paid when calling this function\\n    require(msg.value \\u003e= serviceFee, \\\"Service Fee of 0.05ETH wasn\\u0027t paid\\\");\\n    require(requireSigned == false, \\\"Only Signed referrals are allowed\\\");\\n    address clone = createClone(libraryAddress_);\\n    IERC20Lib(clone).init(msg.sender, name_, symbol_, totalSupply_);\\n    emit ERC20Created(clone);\\n\\n    // Referral must accept money, otherwise he will not be paid (saves gas and eliminates security risks)\\n    referral_.send(0.01 ether);\\n  }\\n\\n  /// @notice Restricts referral creation to be signed by the service\\n  /// @param requireSigned_ true if signature is required\\n  function setRequireSigned(bool requireSigned_) external {\\n    require(msg.sender == signer);\\n    requireSigned = requireSigned_;\\n  }\\n\\n  bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"createERC20WithReferralSigned(address libraryAddress,string name,string symbol,uint256 totalSupply,address referral)\\\");\\n\\n  /// @notice Creates and initializes the ERC20 MinimalProxy contract using a referral link and signatures\\n  /// @param libraryAddress_ is an address of implementation, to which the MinimalProxy should point to\\n  /// @param name_ is the ERC20 token name\\n  /// @param symbol_ is the ERC20 token symbol\\n  /// @param totalSupply_ is the ERC20 token totalSupply that will be minted to msg.sender\\n  /// @param referral_ is the referral, who will receive 0.01 ETH from the deployment\\n  /// @param v_ A final byte of signature (ECDSA component)\\n  /// @param r_ The first 32 bytes of signature (ECDSA component)\\n  /// @param s_ The second 32 bytes of signature (ECDSA component)\\n  function createERC20WithReferralSigned(address libraryAddress_,\\n                                   string memory name_,\\n                                   string memory symbol_,\\n                                   uint256 totalSupply_,\\n                                   address payable referral_,\\n                                   uint8 v_,\\n                                   bytes32 r_,\\n                                   bytes32 s_) payable external {\\n    // The service fee should be paid when calling this function\\n    require(msg.value \\u003e= serviceFee, \\\"Service Fee of 0.05ETH wasn\\u0027t paid\\\");\\n\\n    bytes32 digest = keccak256(abi.encodePacked(\\n                                \\\"\\\\x19\\\\x01\\\",\\n                                DOMAIN_SEPARATOR,\\n                                keccak256(abi.encode(\\n                                  PERMIT_TYPEHASH,\\n                                  libraryAddress_,\\n                                  keccak256(bytes(name_)),\\n                                  keccak256(bytes(symbol_)),\\n                                  totalSupply_,\\n                                  referral_\\n                                ))\\n                              ));\\n    \\n    require(signer == ecrecover(digest, v_, r_, s_), \\\"invalid signature or parameters\\\");\\n\\n    address clone = createClone(libraryAddress_);\\n    IERC20Lib(clone).init(msg.sender, name_, symbol_, totalSupply_);\\n\\n    emit ERC20Created(clone);\\n\\n    // Referral must accept money, otherwise he will not be paid (saves gas and eliminates security risks)\\n    referral_.send(0.01 ether);\\n  }\\n}\"},\"IERC20Lib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20Lib {\\n  function init(address owner_, string memory name_, string memory symbol_, uint256 totalSupply_) external;\\n  function balanceOf(address account) external view returns (uint256);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newERC20Address\",\"type\":\"address\"}],\"name\":\"ERC20Created\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"libraryAddress_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"}],\"name\":\"createERC20\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"libraryAddress_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"referral_\",\"type\":\"address\"}],\"name\":\"createERC20WithReferral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"libraryAddress_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"referral_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v_\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s_\",\"type\":\"bytes32\"}],\"name\":\"createERC20WithReferralSigned\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"query\",\"type\":\"address\"}],\"name\":\"isClone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"payoutToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requireSigned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"requireSigned_\",\"type\":\"bool\"}],\"name\":\"setRequireSigned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ERC20Factory","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000862ab2a5e8feeca125519b5c6f948eb7954cfacb00000000000000000000000094889a2f6c4c30f59f18ca18f3c0906825f40383","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://929c19ff52cbce79a698f75eec9f8f508af5893349a41927ac71acdd4faeefc1"}]}