{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Stabilizer.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\ninterface IStrat {\\n    function invest() external; // underlying amount must be sent from vault to strat address before\\n    function divest(uint amount) external; // should send requested amount to vault directly, not less or more\\n    function calcTotalValue() external returns (uint);\\n    function underlying() external view returns (address);\\n}\\n\\n// WARNING: This contract assumes synth and reserve are equally valuable and share the same decimals (e.g. Dola and Dai)\\n// DO NOT USE WITH USDC OR USDT\\n// DO NOT USE WITH NON-STANDARD ERC20 TOKENS\\ncontract Stabilizer {\\n    using SafeMath for uint;\\n\\n    uint public constant MAX_FEE = 1000; // 10%\\n    uint public constant FEE_DENOMINATOR = 10000;\\n    uint public buyFee;\\n    uint public sellFee;\\n    uint public supplyCap;\\n    uint public supply;\\n    ERC20 public synth;\\n    ERC20 public reserve;\\n    address public operator;\\n    IStrat public strat;\\n    address public governance;\\n\\n    constructor(ERC20 synth_, ERC20 reserve_, address gov_, uint buyFee_, uint sellFee_, uint supplyCap_) public {\\n        require(buyFee_ <= MAX_FEE, \\\"buyFee_ too high\\\");\\n        require(sellFee_ <= MAX_FEE, \\\"sellFee_ too high\\\");\\n        synth = synth_;\\n        reserve = reserve_;\\n        governance = gov_;\\n        buyFee = buyFee_;\\n        sellFee = sellFee_;\\n        operator = msg.sender;\\n        supplyCap = supplyCap_;\\n    }\\n\\n    modifier onlyOperator {\\n        require(msg.sender == operator || msg.sender == governance, \\\"ONLY OPERATOR OR GOV\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernance {\\n        require(msg.sender == governance, \\\"ONLY GOV\\\");\\n        _;\\n    }\\n\\n    function setOperator(address operator_) public {\\n        require(msg.sender == governance || msg.sender == operator, \\\"ONLY GOV OR OPERATOR\\\");\\n        require(operator_ != address(0), \\\"NO ADDRESS ZERO\\\");\\n        operator = operator_;\\n    }\\n\\n    function setBuyFee(uint amount) public onlyGovernance {\\n        require(amount <= MAX_FEE, \\\"amount too high\\\");\\n        buyFee = amount;\\n    }\\n\\n    function setSellFee(uint amount) public onlyGovernance {\\n        require(amount <= MAX_FEE, \\\"amount too high\\\");\\n        sellFee = amount;\\n    }\\n    \\n    function setCap(uint amount) public onlyOperator {\\n        supplyCap = amount;\\n    }\\n\\n    function setGovernance(address gov_) public onlyGovernance {\\n        require(gov_ != address(0), \\\"NO ADDRESS ZERO\\\");\\n        governance = gov_;\\n    }\\n\\n    function setStrat(IStrat newStrat) public onlyGovernance {\\n        require(newStrat.underlying() == address(reserve), \\\"Invalid strat\\\");\\n        if(address(strat) != address(0)) {\\n            uint prevTotalValue = strat.calcTotalValue();\\n            strat.divest(prevTotalValue);\\n        }\\n        reserve.transfer(address(newStrat), reserve.balanceOf(address(this)));\\n        newStrat.invest();\\n        strat = newStrat;\\n    }\\n\\n    function removeStrat() public onlyGovernance {\\n        uint prevTotalValue = strat.calcTotalValue();\\n        strat.divest(prevTotalValue);\\n\\n        strat = IStrat(address(0));\\n    }\\n\\n    function takeProfit() public {\\n        uint totalReserves = getTotalReserves();\\n        if(totalReserves > supply) {\\n            uint profit = totalReserves - supply; // underflow prevented by if condition\\n            if(address(strat) != address(0)) {\\n                uint bal = reserve.balanceOf(address(this));\\n                if(bal < profit) {\\n                    strat.divest(profit - bal); // underflow prevented by if condition\\n                }\\n            }\\n            reserve.transfer(governance, profit);\\n        }\\n    }\\n\\n    function buy(uint amount) public {\\n        require(supply.add(amount) <= supplyCap, \\\"supply exceeded cap\\\");\\n        if(address(strat) != address(0)) {\\n            reserve.transferFrom(msg.sender, address(strat), amount);\\n            strat.invest();\\n        } else {\\n            reserve.transferFrom(msg.sender, address(this), amount);\\n        }\\n\\n        if(buyFee > 0) {\\n            uint fee = amount.mul(buyFee).div(FEE_DENOMINATOR);\\n            reserve.transferFrom(msg.sender, governance, fee);\\n            emit Buy(msg.sender, amount, amount.add(fee));\\n        } else {\\n            emit Buy(msg.sender, amount, amount);\\n        }\\n\\n        synth.mint(msg.sender, amount);\\n        supply = supply.add(amount);\\n    }\\n\\n    function sell(uint amount) public {\\n        synth.transferFrom(msg.sender, address(this), amount);\\n        synth.burn(amount);\\n\\n        uint reserveBal = reserve.balanceOf(address(this));\\n        if(address(strat) != address(0) && reserveBal < amount) {\\n            strat.divest(amount - reserveBal); // underflow prevented by if condition\\n        }\\n\\n        uint afterFee;\\n        if(sellFee > 0) {\\n            uint fee = amount.mul(sellFee).div(FEE_DENOMINATOR);\\n            afterFee = amount.sub(fee);\\n            reserve.transfer(governance, fee);\\n        } else {\\n            afterFee = amount;\\n        }\\n        \\n        reserve.transfer(msg.sender, afterFee);\\n        supply = supply.sub(amount);\\n        emit Sell(msg.sender, amount, afterFee);\\n    }\\n\\n    function rescue(ERC20 token) public onlyGovernance {\\n        require(token != reserve, \\\"RESERVE CANNOT BE RESCUED\\\");\\n        token.transfer(governance, token.balanceOf(address(this)));\\n    }\\n\\n    function getTotalReserves() internal returns (uint256 bal) { // new view function because strat.calcTotalValue() is not view function\\n        bal = reserve.balanceOf(address(this));\\n        if(address(strat) != address(0)) {\\n            bal = bal.add(strat.calcTotalValue());\\n        }\\n    }\\n\\n    event Buy(address indexed user, uint purchased, uint spent);\\n    event Sell(address indexed user, uint sold, uint received);\\n}\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract ERC20 {\\n    using SafeMath for uint;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n    uint  public totalSupply;\\n    address public operator;\\n    address public pendingOperator;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n    mapping (address => bool) public minters;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint) public nonces;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event AddMinter(address indexed minter);\\n    event RemoveMinter(address indexed minter);\\n    event ChangeOperator(address indexed newOperator);\\n\\n    modifier onlyOperator {\\n        require(msg.sender == operator, \\\"ONLY OPERATOR\\\");\\n        _;\\n    }\\n\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) public {\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n        operator = msg.sender;\\n        uint chainId;\\n        assembly {\\n            chainId := chainid\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes(name)),\\n                keccak256(bytes('1')),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function setPendingOperator(address newOperator_) public onlyOperator {\\n        pendingOperator = newOperator_;\\n    }\\n\\n    function claimOperator() public {\\n        require(msg.sender == pendingOperator, \\\"ONLY PENDING OPERATOR\\\");\\n        operator = pendingOperator;\\n        pendingOperator = address(0);\\n        emit ChangeOperator(operator);\\n    }\\n\\n    function addMinter(address minter_) public onlyOperator {\\n        minters[minter_] = true;\\n        emit AddMinter(minter_);\\n    }\\n\\n    function removeMinter(address minter_) public onlyOperator {\\n        minters[minter_] = false;\\n        emit RemoveMinter(minter_);\\n    }\\n\\n    function mint(address to, uint amount) public {\\n        require(minters[msg.sender] == true || msg.sender == operator, \\\"ONLY MINTERS OR OPERATOR\\\");\\n        _mint(to, amount);\\n    }\\n\\n    function burn(uint amount) public {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    function _mint(address to, uint value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        require(deadline >= block.timestamp, 'EXPIRED');\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\\n        _approve(owner, spender, value);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"synth_\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"reserve_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gov_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCap_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spent\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeStrat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBuyFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"gov_\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSellFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IStrat\",\"name\":\"newStrat\",\"type\":\"address\"}],\"name\":\"setStrat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strat\",\"outputs\":[{\"internalType\":\"contract IStrat\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synth\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"takeProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Stabilizer","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000865377367054516e17014ccded1e7d814edc9ce40000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000926df14a23be491164dcf93f4c468a50ef659d5b000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000d3c21bcecceda1000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}