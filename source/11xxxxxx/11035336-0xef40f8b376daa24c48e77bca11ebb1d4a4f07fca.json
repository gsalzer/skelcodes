{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath64 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        uint64 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\r\n        require(b <= a, errorMessage);\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint64 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint64 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/interfaces/IMemberRoles.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMemberRoles {\r\n\r\n    event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\r\n    \r\n    enum Role {UnAssigned, AdvisoryBoard, TokenHolder, DisputeResolution}\r\n\r\n    function setInititorAddress(address _initiator) external;\r\n\r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function addRole(bytes32 _roleName, string memory _roleDescription, address _authorized) public;\r\n\r\n    /// @dev Assign or Delete a member from specific role.\r\n    /// @param _memberAddress Address of Member\r\n    /// @param _roleId RoleId to update\r\n    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\r\n    function updateRole(address _memberAddress, uint _roleId, bool _active) public;\r\n\r\n    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\r\n    /// @param _roleId roleId to update its Authorized Address\r\n    /// @param _authorized New authorized address against role id\r\n    function changeAuthorized(uint _roleId, address _authorized) public;\r\n\r\n    /// @dev Return number of member roles\r\n    function totalRoles() public view returns(uint256);\r\n\r\n    /// @dev Gets the member addresses assigned by a specific role\r\n    /// @param _memberRoleId Member role id\r\n    /// @return roleId Role id\r\n    /// @return allMemberAddress Member addresses of specified role id\r\n    function members(uint _memberRoleId) public view returns(uint, address[] memory allMemberAddress);\r\n\r\n    /// @dev Gets all members' length\r\n    /// @param _memberRoleId Member role id\r\n    /// @return memberRoleData[_memberRoleId].memberAddress.length Member length\r\n    function numberOfMembers(uint _memberRoleId) public view returns(uint);\r\n    \r\n    /// @dev Return member address who holds the right to add/remove any member from specific role.\r\n    function authorized(uint _memberRoleId) public view returns(address);\r\n\r\n    /// @dev Get All role ids array that has been assigned to a member so far.\r\n    function roles(address _memberAddress) public view returns(uint[] memory assignedRoles);\r\n\r\n    /// @dev Returns true if the given role id is assigned to a member.\r\n    /// @param _memberAddress Address of member\r\n    /// @param _roleId Checks member's authenticity with the roleId.\r\n    /// i.e. Returns true if this roleId is assigned to member\r\n    function checkRole(address _memberAddress, uint _roleId) public view returns(bool);   \r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/Governed.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMaster {\r\n    mapping(address => bool) public whitelistedSponsor;\r\n    function dAppToken() public view returns(address);\r\n    function isInternal(address _address) public view returns(bool);\r\n    function getLatestAddress(bytes2 _module) public view returns(address);\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool);\r\n}\r\n\r\n\r\ncontract Governed {\r\n\r\n    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\r\n\r\n    /// @dev modifier that allows only the authorized addresses to execute the function\r\n    modifier onlyAuthorizedToGovern() {\r\n        IMaster ms = IMaster(masterAddress);\r\n        require(ms.getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    /// @dev checks if an address is authorized to govern\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool) {\r\n        IMaster ms = IMaster(masterAddress);\r\n        return (ms.getLatestAddress(\"GV\") == _toCheck);\r\n    } \r\n\r\n}\r\n\r\n// File: contracts/external/proxy/Proxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n            }\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n}\r\n\r\n// File: contracts/external/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param _newImplementation address representing the new implementation to be set\r\n    */\r\n    function _setImplementation(address _newImplementation) internal {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n        sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address _newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor(address _implementation) public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\r\n        require(_newOwner != address(0));\r\n        _setUpgradeabilityOwner(_newOwner);\r\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param _implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address _implementation) public onlyProxyOwner {\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            sstore(position, _newProxyOwner)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/Iupgradable.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract Iupgradable {\r\n\r\n    /**\r\n     * @dev change master address\r\n     */\r\n    function setMasterAddress() public;\r\n}\r\n\r\n// File: contracts/interfaces/ITokenController.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract ITokenController {\r\n\taddress public token;\r\n    address public bLOTToken;\r\n\r\n    /**\r\n    * @dev Swap BLOT token.\r\n    * account.\r\n    * @param amount The amount that will be swapped.\r\n    */\r\n    function swapBLOT(address _of, address _to, uint256 amount) public;\r\n\r\n    function totalBalanceOf(address _of)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burnCommissionTokens(uint256 amount) external returns(bool);\r\n \r\n    function initiateVesting(address _vesting) external;\r\n\r\n    function lockForGovernanceVote(address _of, uint _days) public;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function mint(address _member, uint _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/MemberRoles.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MemberRoles is IMemberRoles, Governed, Iupgradable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    ITokenController internal tokenController;\r\n    struct MemberRoleDetails {\r\n        uint256 memberCounter;\r\n        mapping(address => uint256) memberIndex;\r\n        address[] memberAddress;\r\n        address authorized;\r\n    }\r\n\r\n    MemberRoleDetails[] internal memberRoleData;\r\n    bool internal constructorCheck;\r\n    address internal initiator;\r\n    uint256 internal minLockAmountForDR;\r\n    uint256 internal lockTimeForDR;\r\n\r\n    modifier checkRoleAuthority(uint256 _memberRoleId) {\r\n        if (memberRoleData[_memberRoleId].authorized != address(0))\r\n            require(\r\n                msg.sender == memberRoleData[_memberRoleId].authorized,\r\n                \"Not authorized\"\r\n            );\r\n        else require(isAuthorizedToGovern(msg.sender), \"Not Authorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev to swap advisory board member\r\n     * @param _newABAddress is address of new AB member\r\n     * @param _removeAB is advisory board member to be removed\r\n     */\r\n    function swapABMember(address _newABAddress, address _removeAB)\r\n        external\r\n        checkRoleAuthority(uint256(Role.AdvisoryBoard))\r\n    {\r\n        _updateRole(_newABAddress, uint256(Role.AdvisoryBoard), true);\r\n        _updateRole(_removeAB, uint256(Role.AdvisoryBoard), false);\r\n    }\r\n\r\n    /**\r\n     * @dev to change the master address\r\n     */\r\n    function setMasterAddress() public {\r\n        OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(\r\n            address(uint160(address(this)))\r\n        );\r\n        require(msg.sender == proxy.proxyOwner(), \"Sender is not proxy owner.\");\r\n\r\n        require(masterAddress == address(0), \"Master address already set\");\r\n        masterAddress = msg.sender;\r\n        IMaster masterInstance = IMaster(masterAddress);\r\n        tokenController = ITokenController(\r\n            masterInstance.getLatestAddress(\"TC\")\r\n        );\r\n        minLockAmountForDR = 500 ether;\r\n        lockTimeForDR = 15 days;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the authorized address to add the initial roles and members\r\n     * @param _initiator is address of the initiator\r\n     */\r\n    function setInititorAddress(address _initiator) external {\r\n        OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(\r\n            address(uint160(address(this)))\r\n        );\r\n        require(msg.sender == proxy.proxyOwner(), \"Sender is not proxy owner.\");\r\n        require(initiator == address(0), \"Already Set\");\r\n        initiator = _initiator;\r\n    }\r\n\r\n    /**\r\n     * @dev to initiate the member roles and add initial AB, DR board members\r\n     * @param _abArray is array of addresses of the Initial AB members\r\n     */\r\n    function memberRolesInitiate(\r\n        address[] calldata _abArray\r\n    ) external {\r\n        require(msg.sender == initiator);\r\n        require(!constructorCheck, \"Already constructed\");\r\n        _addInitialMemberRoles();\r\n        for (uint256 i = 0; i < _abArray.length; i++) {\r\n            _updateRole(_abArray[i], uint256(Role.AdvisoryBoard), true);\r\n        }\r\n        constructorCheck = true;\r\n    }\r\n\r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function addRole(\r\n        //solhint-disable-line\r\n        bytes32 _roleName,\r\n        string memory _roleDescription,\r\n        address _authorized\r\n    ) public onlyAuthorizedToGovern {\r\n        _addRole(_roleName, _roleDescription, _authorized);\r\n    }\r\n\r\n    /// @dev Assign or Delete a member from specific role.\r\n    /// @param _memberAddress Address of Member\r\n    /// @param _roleId RoleId to update\r\n    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\r\n    function updateRole(\r\n        //solhint-disable-line\r\n        address _memberAddress,\r\n        uint256 _roleId,\r\n        bool _active\r\n    ) public checkRoleAuthority(_roleId) {\r\n        _updateRole(_memberAddress, _roleId, _active);\r\n    }\r\n\r\n    /// @dev Return number of member roles\r\n    function totalRoles() public view returns (uint256) {\r\n        //solhint-disable-line\r\n        return memberRoleData.length;\r\n    }\r\n\r\n    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\r\n    /// @param _roleId roleId to update its Authorized Address\r\n    /// @param _newAuthorized New authorized address against role id\r\n    function changeAuthorized(uint256 _roleId, address _newAuthorized)\r\n        public\r\n        checkRoleAuthority(_roleId)\r\n    {\r\n        //solhint-disable-line\r\n        memberRoleData[_roleId].authorized = _newAuthorized;\r\n    }\r\n\r\n    /// @dev Gets the member addresses assigned by a specific role\r\n    /// @param _memberRoleId Member role id\r\n    /// @return roleId Role id\r\n    /// @return allMemberAddress Member addresses of specified role id\r\n    function members(uint256 _memberRoleId)\r\n        public\r\n        view\r\n        returns (uint256, address[] memory memberArray)\r\n    {\r\n        return (_memberRoleId, memberRoleData[_memberRoleId].memberAddress);\r\n    }\r\n\r\n    /// @dev Gets all members' length\r\n    /// @param _memberRoleId Member role id\r\n    /// @return memberRoleData[_memberRoleId].memberCounter Member length\r\n    function numberOfMembers(uint256 _memberRoleId)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //solhint-disable-line\r\n        return memberRoleData[_memberRoleId].memberCounter;\r\n    }\r\n\r\n    /// @dev Return member address who holds the right to add/remove any member from specific role.\r\n    function authorized(uint256 _memberRoleId) public view returns (address) {\r\n        //solhint-disable-line\r\n        return memberRoleData[_memberRoleId].authorized;\r\n    }\r\n\r\n    /// @dev Get All role ids array that has been assigned to a member so far.\r\n    function roles(address _memberAddress)\r\n        public\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        //solhint-disable-line\r\n        uint256 length = memberRoleData.length;\r\n        uint256[] memory assignedRoles = new uint256[](length);\r\n        uint256 counter = 0;\r\n        for (uint256 i = 1; i < length; i++) {\r\n            if (memberRoleData[i].memberIndex[_memberAddress] > 0) {\r\n                assignedRoles[counter] = i;\r\n                counter++;\r\n            }\r\n        }\r\n        if (tokenController.totalBalanceOf(_memberAddress) > 0) {\r\n            assignedRoles[counter] = uint256(Role.TokenHolder);\r\n            counter++;\r\n        }\r\n        if (tokenController.tokensLockedAtTime(_memberAddress, \"DR\", (lockTimeForDR).add(now)) >= minLockAmountForDR) {\r\n            assignedRoles[counter] = uint256(Role.DisputeResolution);\r\n        }\r\n        return assignedRoles;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public onlyAuthorizedToGovern {\r\n        if(code == \"MNLOCKDR\") { //Minimum lock amount to consider user as DR member\r\n            minLockAmountForDR = val;\r\n        } else if (code == \"TLOCDR\") { // Lock period required for DR\r\n            lockTimeForDR = val * (1 days);\r\n        } \r\n    }\r\n\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n        if(code == \"MNLOCKDR\") {\r\n            val = minLockAmountForDR;\r\n        } else if (code == \"TLOCDR\") { // Lock period required for DR\r\n            val = lockTimeForDR / (1 days);\r\n        } \r\n    }\r\n\r\n\r\n    /// @dev Returns true if the given role id is assigned to a member.\r\n    /// @param _memberAddress Address of member\r\n    /// @param _roleId Checks member's authenticity with the roleId.\r\n    /// i.e. Returns true if this roleId is assigned to member\r\n    function checkRole(address _memberAddress, uint256 _roleId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        //solhint-disable-line\r\n        if (_roleId == uint256(Role.UnAssigned)) {\r\n            return true;\r\n        } else if (_roleId == uint256(Role.TokenHolder)) {\r\n            if (tokenController.totalBalanceOf(_memberAddress) > 0) {\r\n                return true;\r\n            }\r\n        } else if (_roleId == uint256(Role.DisputeResolution)) {\r\n            if (tokenController.tokensLockedAtTime(_memberAddress, \"DR\", (lockTimeForDR).add(now)) >= minLockAmountForDR) {\r\n                return true;\r\n            }\r\n        } else if (memberRoleData[_roleId].memberIndex[_memberAddress] > 0) {\r\n            //solhint-disable-line\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Return total number of members assigned against each role id.\r\n    /// @return totalMembers Total members in particular role id\r\n    function getMemberLengthForAllRoles()\r\n        public\r\n        view\r\n        returns (uint256[] memory totalMembers)\r\n    {\r\n        //solhint-disable-line\r\n        totalMembers = new uint256[](memberRoleData.length);\r\n        for (uint256 i = 0; i < memberRoleData.length; i++) {\r\n            totalMembers[i] = numberOfMembers(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to update the member roles\r\n     * @param _memberAddress in concern\r\n     * @param _roleId the id of role\r\n     * @param _active if active is true, add the member, else remove it\r\n     */\r\n    function _updateRole(\r\n        address _memberAddress,\r\n        uint256 _roleId,\r\n        bool _active\r\n    ) internal {\r\n        require(\r\n            _roleId != uint256(Role.TokenHolder) && _roleId != uint256(Role.DisputeResolution),\r\n            \"Membership to this role is detected automatically\"\r\n        );\r\n        if (_active) {\r\n            require(\r\n                memberRoleData[_roleId].memberIndex[_memberAddress] == 0,\r\n                \"already active\"\r\n            );\r\n\r\n            memberRoleData[_roleId].memberCounter = SafeMath.add(\r\n                memberRoleData[_roleId].memberCounter,\r\n                1\r\n            );\r\n            memberRoleData[_roleId]\r\n                .memberIndex[_memberAddress] = memberRoleData[_roleId]\r\n                .memberAddress\r\n                .length;\r\n            memberRoleData[_roleId].memberAddress.push(_memberAddress);\r\n        } else {\r\n            //Remove the selected member and swap its index with the member at last index\r\n            require(\r\n                memberRoleData[_roleId].memberIndex[_memberAddress] > 0,\r\n                \"not active\"\r\n            );\r\n            uint256 _memberIndex = memberRoleData[_roleId]\r\n                .memberIndex[_memberAddress];\r\n            address _topElement = memberRoleData[_roleId]\r\n                .memberAddress[memberRoleData[_roleId].memberCounter];\r\n            memberRoleData[_roleId].memberIndex[_topElement] = _memberIndex;\r\n            memberRoleData[_roleId].memberCounter = SafeMath.sub(\r\n                memberRoleData[_roleId].memberCounter,\r\n                1\r\n            );\r\n            memberRoleData[_roleId].memberAddress[_memberIndex] = _topElement;\r\n            memberRoleData[_roleId].memberAddress.length--;\r\n            delete memberRoleData[_roleId].memberIndex[_memberAddress];\r\n        }\r\n    }\r\n\r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function _addRole(\r\n        bytes32 _roleName,\r\n        string memory _roleDescription,\r\n        address _authorized\r\n    ) internal {\r\n        emit MemberRole(memberRoleData.length, _roleName, _roleDescription);\r\n        memberRoleData.push(\r\n            MemberRoleDetails(0, new address[](1), _authorized)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev to add initial member roles\r\n     */\r\n    function _addInitialMemberRoles() internal {\r\n        _addRole(\"Unassigned\", \"Unassigned\", address(0));\r\n        _addRole(\r\n            \"Advisory Board\",\r\n            \"Selected few members that are deeply entrusted by the dApp. An ideal advisory board should be a mix of skills of domain, governance, research, technology, consulting etc to improve the performance of the dApp.\", //solhint-disable-line\r\n            address(0)\r\n        );\r\n        _addRole(\r\n            \"Token Holder\",\r\n            \"Represents all users who hold dApp tokens. This is the most general category and anyone holding token balance is a part of this category by default.\", //solhint-disable-line\r\n            address(0)\r\n        );\r\n        _addRole(\r\n            \"DisputeResolution\",\r\n            \"Represents members who are assigned to vote on resolving disputes\", //solhint-disable-line\r\n            address(0)\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_memberRoleId\",\"type\":\"uint256\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_memberRoleId\",\"type\":\"uint256\"}],\"name\":\"numberOfMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_toCheck\",\"type\":\"address\"}],\"name\":\"isAuthorizedToGovern\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roleName\",\"type\":\"bytes32\"},{\"name\":\"_roleDescription\",\"type\":\"string\"},{\"name\":\"_authorized\",\"type\":\"address\"}],\"name\":\"addRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_memberAddress\",\"type\":\"address\"},{\"name\":\"_roleId\",\"type\":\"uint256\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"updateRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initiator\",\"type\":\"address\"}],\"name\":\"setInititorAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_memberAddress\",\"type\":\"address\"},{\"name\":\"_roleId\",\"type\":\"uint256\"}],\"name\":\"checkRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_memberRoleId\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"memberArray\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"bytes8\"}],\"name\":\"getUintParameters\",\"outputs\":[{\"name\":\"codeVal\",\"type\":\"bytes8\"},{\"name\":\"val\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMemberLengthForAllRoles\",\"outputs\":[{\"name\":\"totalMembers\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRoles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_memberAddress\",\"type\":\"address\"}],\"name\":\"roles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"bytes8\"},{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"updateUintParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roleId\",\"type\":\"uint256\"},{\"name\":\"_newAuthorized\",\"type\":\"address\"}],\"name\":\"changeAuthorized\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newABAddress\",\"type\":\"address\"},{\"name\":\"_removeAB\",\"type\":\"address\"}],\"name\":\"swapABMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_abArray\",\"type\":\"address[]\"}],\"name\":\"memberRolesInitiate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"roleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"roleDescription\",\"type\":\"string\"}],\"name\":\"MemberRole\",\"type\":\"event\"}]","ContractName":"MemberRoles","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c29d9f4776775a349ed0e866fd284b245101a96a5a51919a9c5133d78f2ad774"}]}