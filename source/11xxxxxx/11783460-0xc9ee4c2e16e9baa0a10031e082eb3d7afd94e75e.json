{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.7.4;\r\n\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\ninterface ITrollbox {\r\n    function withdrawWinnings(uint voterId) external;\r\n    function updateAccount(uint voterId, uint tournamentId, uint roundId) external;\r\n    function isSynced(uint voterId, uint tournamentId, uint roundId) external view returns (bool);\r\n    function roundAlreadyResolved(uint tournamentId, uint roundId) external view returns (bool);\r\n    function resolveRound(uint tournamentId, uint roundId, uint winningOption) external;\r\n    function getCurrentRoundId(uint tournamentId) external returns (uint);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ChainLinkOracle {\r\n\r\n    struct Proposal {\r\n        uint id;\r\n        uint time;\r\n        bool confirmed;\r\n        uint roundId;\r\n        uint winnerIndex;\r\n        uint challengeWinnerIndex;\r\n        address challenger;\r\n    }\r\n\r\n    mapping (bytes32 => address) public feedMap; // ticker symbol => price aggregator address\r\n    mapping (bytes32 => int) public prices; // symbol => price\r\n    mapping (uint => Proposal) public proposals;\r\n\r\n    address public management;\r\n    ITrollbox public trollbox;\r\n    IERC20 public token;\r\n\r\n    int constant public PRECISION = 1000000;\r\n    uint public numProposals = 0;\r\n    uint public challengeDeposit = 0;\r\n    uint public challengePeriodSeconds = 60 * 60 * 24;\r\n    uint public tournamentId = 1;\r\n\r\n    bytes32[] public tickerSymbols;\r\n\r\n    // mgmt events\r\n    event FeedUpdated(bytes32 indexed key, address indexed feedAddr);\r\n    event ManagementUpdated(address oldManagement, address newManagement);\r\n    event DepositUpdated(uint oldDeposit, uint newDeposit);\r\n    event ChallengePeriodUpdated(uint oldPeriod, uint newPeriod);\r\n    event TickerSymbolsUpdated(bytes32[] oldKeys, bytes32[] newKeys);\r\n\r\n    // winner events\r\n    event WinnerProposed(uint indexed roundId, uint indexed proposalId, uint winnerIndex);\r\n    event WinnerConfirmed(uint indexed roundId, uint indexed proposalId, int[] prices);\r\n\r\n    // challenger events\r\n    event ChallengeMade(uint indexed proposalId, address indexed challenger, uint indexed claimedWinner);\r\n    event ChallengerSlashed(uint indexed proposalId, address indexed challenger, uint indexed slashAmount);\r\n    event ChallengerVindicated(uint indexed proposalId, address indexed challenger);\r\n\r\n    modifier managementOnly() {\r\n        require (msg.sender == management, 'Only management may call this');\r\n        _;\r\n    }\r\n\r\n    modifier latestProposalConfirmed() {\r\n        require (proposals[numProposals].confirmed == true || numProposals == 0, 'Unconfirmed proposal present');\r\n        _;\r\n    }\r\n\r\n    constructor(address mgmt, address trollboxAddr, address tokenAddr, uint tournament, bytes32[] memory initialSymbols, int[] memory initialPrices) {\r\n        management = mgmt;\r\n        trollbox = ITrollbox(trollboxAddr);\r\n        token = IERC20(tokenAddr);\r\n        tournamentId = tournament;\r\n        tickerSymbols = initialSymbols;\r\n        setPricesInternal(initialPrices);\r\n    }\r\n\r\n    function setManagement(address newMgmt) public managementOnly {\r\n        address oldMgmt = management;\r\n        management =  newMgmt;\r\n        emit ManagementUpdated(oldMgmt, newMgmt);\r\n    }\r\n\r\n    function setChallengeDeposit(uint newDeposit) public managementOnly latestProposalConfirmed {\r\n        uint oldDeposit = challengeDeposit;\r\n        challengeDeposit = newDeposit;\r\n        emit DepositUpdated(oldDeposit, newDeposit);\r\n    }\r\n\r\n    function setChallengePeriod(uint newPeriod) public managementOnly latestProposalConfirmed {\r\n        uint oldPeriod = challengePeriodSeconds;\r\n        challengePeriodSeconds = newPeriod;\r\n        emit ChallengePeriodUpdated(oldPeriod, newPeriod);\r\n    }\r\n\r\n    function setPricesInternal(int[] memory newPrices) internal {\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            prices[tickerSymbols[i]] = newPrices[i];\r\n        }\r\n    }\r\n\r\n    function getTickerSymbols() public view returns (bytes32[] memory) {\r\n        return tickerSymbols;\r\n    }\r\n\r\n    function setTickerSymbols(bytes32[] memory newKeys) public managementOnly latestProposalConfirmed {\r\n        bytes32[] memory oldKeys = tickerSymbols;\r\n        tickerSymbols = newKeys;\r\n        emit TickerSymbolsUpdated(oldKeys, newKeys);\r\n    }\r\n\r\n    function addFeed(bytes32 key, address feedAddr) public managementOnly {\r\n        feedMap[key] = feedAddr;\r\n        emit FeedUpdated(key, feedAddr);\r\n    }\r\n\r\n    function getWinner() public view returns (int[] memory, uint) {\r\n        int256 maxPriceDiff = -100 * PRECISION;\r\n        uint winnerIndex = 0;\r\n        int[] memory pricesLocal = new int[](tickerSymbols.length);\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            bytes32 key = tickerSymbols[i];\r\n            int priceBefore = prices[key];\r\n            AggregatorV3Interface chainlink = AggregatorV3Interface(feedMap[key]);\r\n            (,int256 priceNow,,,) = chainlink.latestRoundData();\r\n            pricesLocal[i] = priceNow;\r\n            int256 priceDiff = ((priceNow - priceBefore) * PRECISION) / priceBefore;\r\n            if (priceDiff > maxPriceDiff) {\r\n                maxPriceDiff = priceDiff;\r\n                // add one to index to account for 1 based indexing on Trollbox contract\r\n                winnerIndex = i + 1;\r\n            }\r\n        }\r\n        return (pricesLocal, winnerIndex);\r\n    }\r\n\r\n    function proposeWinner(uint roundId) public latestProposalConfirmed {\r\n        require(trollbox.roundAlreadyResolved(tournamentId, roundId) == false, 'Round already resolve');\r\n        require(trollbox.getCurrentRoundId(tournamentId) > roundId + 1, 'Round not ready to resolve');\r\n        Proposal storage proposal = proposals[++numProposals];\r\n        proposal.id = numProposals;\r\n        proposal.time = block.timestamp;\r\n        proposal.roundId = roundId;\r\n        (int[] memory newPrices, uint winnerIndex) = getWinner();\r\n        setPricesInternal(newPrices);\r\n        proposal.winnerIndex = winnerIndex;\r\n        emit WinnerProposed(roundId, numProposals, proposal.winnerIndex);\r\n    }\r\n\r\n    function challengeWinner(uint proposalId, uint claimedWinner) public {\r\n        token.transferFrom(msg.sender, address(this), challengeDeposit);\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.challenger == address(0), 'Proposal already challenged');\r\n        require(claimedWinner != proposal.winnerIndex, 'Must claim different winner than proposed winner');\r\n        require(block.timestamp - proposal.time < challengePeriodSeconds, 'Challenge period has passed');\r\n        proposal.challenger = msg.sender;\r\n        proposal.challengeWinnerIndex = claimedWinner;\r\n        emit ChallengeMade(proposalId, msg.sender, claimedWinner);\r\n    }\r\n\r\n    function confirmWinnerUnchallenged(uint proposalId) public {\r\n        Proposal memory proposal = proposals[proposalId];\r\n        require(proposal.challenger == address(0), 'Proposal has been challenged');\r\n        require(block.timestamp - proposal.time > challengePeriodSeconds, 'Challenge period has not passed');\r\n        confirmWinnerInternal(proposalId);\r\n    }\r\n\r\n    function confirmWinnerChallenged(uint proposalId, uint chosenWinnerIndex, int[] memory localPrices) public managementOnly {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.challenger != address(0), 'Proposal has not been challenged');\r\n        require(chosenWinnerIndex <= tickerSymbols.length, 'Winner index out of range');\r\n        require(chosenWinnerIndex > 0, 'Winner index must be positive');\r\n        require(localPrices.length == tickerSymbols.length, 'Must specify prices for all ticker symbols');\r\n\r\n        // set official winner\r\n        proposal.winnerIndex = chosenWinnerIndex;\r\n\r\n        // record prices\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            prices[tickerSymbols[i]] = localPrices[i];\r\n        }\r\n\r\n        confirmWinnerInternal(proposalId);\r\n\r\n        // if challenger failed, slash their deposit\r\n        if (chosenWinnerIndex != proposal.challengeWinnerIndex) {\r\n            token.transfer(address(0), challengeDeposit);\r\n            emit ChallengerSlashed(proposalId, proposal.challenger, challengeDeposit);\r\n        // else send it back to them\r\n        } else {\r\n            token.transfer(proposal.challenger, challengeDeposit);\r\n            emit ChallengerVindicated(proposalId, proposal.challenger);\r\n        }\r\n    }\r\n\r\n    function confirmWinnerInternal(uint proposalId) internal {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.id == proposalId, 'Invalid proposalId');\r\n        require(proposal.confirmed == false, 'Already confirmed proposal');\r\n        proposal.confirmed = true;\r\n        int[] memory pricesLocal = new int[](tickerSymbols.length);\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            pricesLocal[i] = prices[tickerSymbols[i]];\r\n        }\r\n        emit WinnerConfirmed(proposal.roundId, proposalId, pricesLocal);\r\n        trollbox.resolveRound(tournamentId, proposal.roundId, proposal.winnerIndex);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trollboxAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tournament\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"initialSymbols\",\"type\":\"bytes32[]\"},{\"internalType\":\"int256[]\",\"name\":\"initialPrices\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"claimedWinner\",\"type\":\"uint256\"}],\"name\":\"ChallengeMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"ChallengePeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"slashAmount\",\"type\":\"uint256\"}],\"name\":\"ChallengerSlashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"ChallengerVindicated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"DepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feedAddr\",\"type\":\"address\"}],\"name\":\"FeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManagement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManagement\",\"type\":\"address\"}],\"name\":\"ManagementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"oldKeys\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"newKeys\",\"type\":\"bytes32[]\"}],\"name\":\"TickerSymbolsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"prices\",\"type\":\"int256[]\"}],\"name\":\"WinnerConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winnerIndex\",\"type\":\"uint256\"}],\"name\":\"WinnerProposed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"feedAddr\",\"type\":\"address\"}],\"name\":\"addFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengePeriodSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedWinner\",\"type\":\"uint256\"}],\"name\":\"challengeWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chosenWinnerIndex\",\"type\":\"uint256\"},{\"internalType\":\"int256[]\",\"name\":\"localPrices\",\"type\":\"int256[]\"}],\"name\":\"confirmWinnerChallenged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"confirmWinnerUnchallenged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"feedMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTickerSymbols\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWinner\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winnerIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengeWinnerIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"proposeWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"setChallengeDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"setChallengePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"newKeys\",\"type\":\"bytes32[]\"}],\"name\":\"setTickerSymbols\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tickerSymbols\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tournamentId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trollbox\",\"outputs\":[{\"internalType\":\"contract ITrollbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ChainLinkOracle","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b000000000000000000000000ea6556e350cd0c61452a26ab34e69ebf6f1808ba00000000000000000000000045080a6531d671ddff20db42f93792a489685e32000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000000a554d4100000000000000000000000000000000000000000000000000000000004c494e4b000000000000000000000000000000000000000000000000000000004441490000000000000000000000000000000000000000000000000000000000554e490000000000000000000000000000000000000000000000000000000000434f4d50000000000000000000000000000000000000000000000000000000004659490000000000000000000000000000000000000000000000000000000000534e58000000000000000000000000000000000000000000000000000000000052454e000000000000000000000000000000000000000000000000000000000057425443000000000000000000000000000000000000000000000000000000004d4b520000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000096fd865af440000000000000000000000000000000000000000000000000000137005044488100000000000000000000000000000000000000000000000000000de19a135095a000000000000000000000000000000000000000000000000000f33f9316981f2000000000000000000000000000000000000000000000000012a1cbb0ffd5c200000000000000000000000000000000000000000000000006542177040f997e0000000000000000000000000000000000000000000000000000ec483e6636bb7000000000000000000000000000000000000000000000000000088613a5550b80000000000000000000000000000000000000000000000006fe6398140ec639000000000000000000000000000000000000000000000000004f44e2ab620dfb4000","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6d11283fd37eab9e92ebae44377d0ab20d5d07491270afbe19a7c4684b24d492"}]}