{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\GFarmTokenInterface.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.5;\r\n\r\ninterface GFarmTokenInterface{\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function burn(address from, uint256 amount) external;\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n\r\n// File: contracts\\GFarmNFTInterface.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\ninterface GFarmNFTInterface{\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function getLeverageFromID(uint id) external view returns(uint16);\r\n    function leverageID(uint16 _leverage) external pure returns(uint16);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\math\\SafeMath.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @uniswap\\v2-core\\contracts\\interfaces\\IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts\\GFarmTrading.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\n\r\n\r\n\r\n\r\ncontract GFarmTrading{\r\n\r\n    using SafeMath for uint;\r\n\r\n    // Tokens\r\n    GFarmTokenInterface immutable token;\r\n    IUniswapV2Pair immutable gfarmEthPair;\r\n    GFarmNFTInterface immutable nft;\r\n\r\n    // Trading\r\n    uint constant MAX_GAIN_P = 900; // 10x\r\n    uint constant STOP_LOSS_P = 90; // liquidated when -90% => 10% reward\r\n    uint constant PRECISION = 1e5;  // computations decimals\r\n\r\n    // Important uniswap addresses / pairs\r\n\taddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    IUniswapV2Pair constant ethDaiPair = IUniswapV2Pair(0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11);\r\n    IUniswapV2Pair constant ethUsdtPair = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);\r\n    IUniswapV2Pair constant ethUsdcPair = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\r\n\r\n    // Dev fund\r\n    address public immutable DEV_FUND;\r\n    uint constant DEV_FUND_FEE_P = 1;\r\n\r\n    // Info about each trade\r\n    struct Trade{\r\n        uint openBlock;\r\n        address initiator;\r\n        bool buy; // True = up, False = down\r\n        uint openPrice; // divide by PRECISION for real price\r\n        uint ethPositionSize; // in wei\r\n        uint16 leverage; // Used for custom leverage if user has the corresponding NFT\r\n    }\r\n    mapping(address => Trade) public trades;\r\n\r\n    // Info about each user gains\r\n    struct Gains{\r\n        uint value; // Divide by PRECISION for real value\r\n        uint lastTradeClosed;\r\n    }\r\n    mapping(address => Gains) public gains;\r\n\r\n    // Useful to list open trades & trades that can be liquidated\r\n    address[] public addressesTradeOpen;\r\n    mapping(address => uint) private addressTradeOpenID;\r\n\r\n    /*uint public fakeEthDaiPrice = 200*PRECISION;\r\n    uint public fakeEthDaiReserve = 100*1e18;\r\n    uint public fakeEthUsdtPrice = 300*PRECISION;\r\n    uint public fakeEthUsdtReserve = 200*1e18;\r\n    uint public fakeEthUsdcPrice = 400*PRECISION;\r\n    uint public fakeEthUsdcReserve = 300*1e18;\r\n    uint public fakeGFarmEthPrice = 10000;\r\n    uint public fakeBlockNumber; // REPLACE EVERYWHERE BY BLOCK.NUMBER*/\r\n\r\n    constructor(\r\n        GFarmTokenInterface _token,\r\n        IUniswapV2Pair _gfarmEthPair,\r\n        GFarmNFTInterface _nft){\r\n\r\n        token = _token;\r\n        gfarmEthPair = _gfarmEthPair;\r\n        nft = _nft;\r\n        DEV_FUND = msg.sender;\r\n\r\n        //fakeBlockNumber = block.number;\r\n    }\r\n\r\n    /*function increaseBlock(uint b) external { fakeBlockNumber += b; }\r\n    function decreaseBlock(uint b) external { fakeBlockNumber -= b; }\r\n    function setFakeEthDaiInfo(uint p, uint r) external { fakeEthDaiPrice = p; fakeEthDaiReserve = r; }\r\n    function setFakeEthUsdtInfo(uint p, uint r) external { fakeEthUsdtPrice = p; fakeEthUsdtReserve = r; }\r\n    function setFakeEthUsdcInfo(uint p, uint r) external { fakeEthUsdcPrice = p; fakeEthUsdcReserve = r; }\r\n    function setFakeGFarmEthPrice(uint p) external { fakeGFarmEthPrice = p; }*/\r\n    \r\n    // PRICING FUNCTIONS\r\n\r\n    // Get current ETH price from ETH/DAI pool and current ETH reserve\r\n    // Divide price by PRECISION for real value\r\n    function pairInfoDAI() private view returns(uint, uint){\r\n        (uint112 reserves0, uint112 reserves1, ) = ethDaiPair.getReserves();\r\n        uint reserveDAI;\r\n        uint reserveETH;\r\n        if(WETH == ethDaiPair.token0()){\r\n            reserveETH = reserves0;\r\n            reserveDAI = reserves1;\r\n        }else{\r\n            reserveDAI = reserves0;\r\n            reserveETH = reserves1;\r\n        }\r\n        // Divide number of DAI by number of ETH\r\n        return (reserveDAI.mul(PRECISION).div(reserveETH), reserveETH);\r\n        \r\n        //return (fakeEthDaiPrice, fakeEthDaiReserve);\r\n    }\r\n    // Get current ETH price from ETH/USDT pool and current ETH reserve\r\n    // Divide price by PRECISION for real value\r\n    function pairInfoUSDT() private view returns(uint, uint){\r\n        (uint112 reserves0, uint112 reserves1, ) = ethUsdtPair.getReserves();\r\n        uint reserveUSDT;\r\n        uint reserveETH;\r\n        if(WETH == ethUsdtPair.token0()){\r\n            reserveETH = reserves0;\r\n            reserveUSDT = reserves1;\r\n        }else{\r\n            reserveUSDT = reserves0;\r\n            reserveETH = reserves1;\r\n        }\r\n        // Divide number of USDT by number of ETH\r\n        // we multiply by 1e12 because USDT only has 6 decimals\r\n        return (reserveUSDT.mul(1e12).mul(PRECISION).div(reserveETH), reserveETH);\r\n    \r\n        //return (fakeEthUsdtPrice, fakeEthUsdtReserve);\r\n    }\r\n    // Get current ETH price from ETH/USDC pool and current ETH reserve\r\n    // Divide price by PRECISION for real value\r\n    function pairInfoUSDC() private view returns(uint, uint){\r\n        (uint112 reserves0, uint112 reserves1, ) = ethUsdcPair.getReserves();\r\n        uint reserveUSDC;\r\n        uint reserveETH;\r\n        if(WETH == ethUsdcPair.token0()){\r\n            reserveETH = reserves0;\r\n            reserveUSDC = reserves1;\r\n        }else{\r\n            reserveUSDC = reserves0;\r\n            reserveETH = reserves1;\r\n        }\r\n        // Divide number of USDC by number of ETH\r\n        // we multiply by 1e12 because USDC only has 6 decimals\r\n        return (reserveUSDC.mul(1e12).mul(PRECISION).div(reserveETH), reserveETH);\r\n    \r\n        //return (fakeEthUsdcPrice, fakeEthUsdcReserve);\r\n    }\r\n    // Get current Ethereum price as a weighted average of the 3 pools based on liquidity\r\n    // Divide by PRECISION for real value\r\n    function getEthPrice() public view returns(uint){\r\n        (uint priceEthDAI, uint reserveEthDAI) = pairInfoDAI();\r\n        (uint priceEthUSDT, uint reserveEthUSDT) = pairInfoUSDT();\r\n        (uint priceEthUSDC, uint reserveEthUSDC) = pairInfoUSDC();\r\n\r\n        uint reserveEth = reserveEthDAI.add(reserveEthUSDT).add(reserveEthUSDC);\r\n\r\n    \treturn (\r\n                priceEthDAI.mul(reserveEthDAI).add(\r\n                    priceEthUSDT.mul(reserveEthUSDT)\r\n                ).add(\r\n                    priceEthUSDC.mul(reserveEthUSDC)\r\n                )\r\n            ).div(reserveEth);\r\n    }\r\n    // Get current GFarm price in ETH from the Uniswap pool\r\n    // Divide by precision for real value\r\n    function getGFarmPriceEth() private view returns(uint){\r\n        (uint112 reserves0, uint112 reserves1, ) = gfarmEthPair.getReserves();\r\n\r\n        uint reserveETH;\r\n        uint reserveGFARM;\r\n\r\n        if(WETH == gfarmEthPair.token0()){\r\n            reserveETH = reserves0;\r\n            reserveGFARM = reserves1;\r\n        }else{\r\n            reserveGFARM = reserves0;\r\n            reserveETH = reserves1;\r\n        }\r\n\r\n        // Divide number of ETH by number of GFARM\r\n        return reserveETH.mul(PRECISION).div(reserveGFARM);\r\n\r\n        //return fakeGFarmEthPrice;\r\n    }\r\n\r\n    // MAX GFARM POS (important for security)\r\n\r\n    // Maximum position size in GFARM\r\n    function getMaxPosGFARM() public view returns(uint){\r\n        (, uint reserveEthDAI) = pairInfoDAI();\r\n        (, uint reserveEthUSDT) = pairInfoUSDT();\r\n        (, uint reserveEthUSDC) = pairInfoUSDC();\r\n\r\n        uint totalReserveETH = reserveEthDAI.add(reserveEthUSDT).add(reserveEthUSDC);\r\n        uint sqrt10 = 3162277660168379331; // 1e18 precision\r\n\r\n        return totalReserveETH.mul(sqrt10).sub(totalReserveETH.mul(1e18)).div(getGFarmPriceEth().mul(750000)).div(1e18/PRECISION);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n    \r\n    // Divide by PRECISION for real value\r\n    function percentDiff(uint a, uint b) private pure returns(int){\r\n        return (int(b) - int(a))*100*int(PRECISION)/int(a);\r\n    }\r\n    // Divide by PRECISION for real value\r\n    function currentPercentProfit(uint _openPrice, uint _currentPrice, bool _buy, uint16 _leverage) private pure returns(int p){\r\n        if(_buy){\r\n            p = percentDiff(_openPrice, _currentPrice)*int(_leverage);\r\n        }else{\r\n        \tp = percentDiff(_openPrice, _currentPrice)*(-1)*int(_leverage);\r\n        }\r\n        int maxLossPercentage = -100 * int(PRECISION);\r\n        int maxGainPercentage = int(MAX_GAIN_P * PRECISION);\r\n        if(p < maxLossPercentage){\r\n            p = maxLossPercentage;\r\n        }else if(p > maxGainPercentage){\r\n        \tp = maxGainPercentage;\r\n        }\r\n    }\r\n    function canLiquidatePure(uint _openPrice, uint _currentPrice, bool _buy, uint16 _leverage) private pure returns(bool){\r\n        if(_buy){\r\n            return currentPercentProfit(_openPrice, _currentPrice, _buy, _leverage) <= (-1)*int(STOP_LOSS_P*PRECISION);\r\n        }else{\r\n            return currentPercentProfit(_openPrice, _currentPrice, _buy, _leverage) <= (-1)*int(STOP_LOSS_P*PRECISION);\r\n        }\r\n    }\r\n    // Remove trade from list of open trades (useful to list liquidations)\r\n    function unregisterOpenTrade(address a) private{\r\n        delete trades[a];\r\n\r\n        if(addressesTradeOpen.length > 1){\r\n            addressesTradeOpen[addressTradeOpenID[a]] = addressesTradeOpen[addressesTradeOpen.length - 1];\r\n            addressTradeOpenID[addressesTradeOpen[addressesTradeOpen.length - 1]] = addressTradeOpenID[a];\r\n        }\r\n\r\n        addressesTradeOpen.pop();\r\n        delete addressTradeOpenID[a];\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS (used internally and externally)\r\n\r\n    function hasOpenTrade(address a) public view returns(bool){\r\n        return trades[a].openBlock != 0;\r\n    }\r\n    function canLiquidate(address a) public view returns(bool){\r\n        require(hasOpenTrade(a), \"This address has no open trade.\");\r\n        Trade memory t = trades[a];\r\n        return canLiquidatePure(t.openPrice, getEthPrice(), t.buy, t.leverage);\r\n    }\r\n    // Compute position size in GFARM based on GFARM/ETH price and ETH position size\r\n    function positionSizeGFARM(address a) public view returns(uint){\r\n        return trades[a].ethPositionSize.mul(PRECISION).div(getGFarmPriceEth());\r\n    }\r\n    // Token PNL in GFARM\r\n    function myTokenPNL() public view returns(int){\r\n        if(!hasOpenTrade(msg.sender)){ return 0; }\r\n        Trade memory t = trades[msg.sender];\r\n        return int(positionSizeGFARM(msg.sender)) * currentPercentProfit(t.openPrice, getEthPrice(), t.buy, t.leverage) / int(100*PRECISION);\r\n    }\r\n    // Amount you get when liquidating trade open by an address (GFARM)\r\n    function liquidateAmountGFARM(address a) public view returns(uint){\r\n        return positionSizeGFARM(a).mul((100 - STOP_LOSS_P)).div(100);\r\n    }\r\n    function myNftsCount() public view returns(uint){\r\n        return nft.balanceOf(msg.sender);\r\n    }\r\n\r\n    // EXTERNAL TRADING FUNCTIONS\r\n    \r\n    function openTrade(bool _buy, uint _positionSize, uint16 _leverage) external{\r\n        require(!hasOpenTrade(msg.sender), \"You can only have 1 trade open at a time.\");\r\n        require(_positionSize > 0, \"Opening a trade with 0 tokens.\");\r\n        require(_positionSize <= getMaxPosGFARM(), \"Your position size exceeds the max authorized position size.\");\r\n\r\n        if(_leverage > 50){\r\n            uint nftCount = myNftsCount();\r\n            require(nftCount > 0, \"You don't own any GFarm NFT.\");\r\n\r\n            bool hasCorrespondingNFT = false;\r\n\r\n            for(uint i = 0; i < nftCount; i++){\r\n                uint nftID = nft.tokenOfOwnerByIndex(msg.sender, i);\r\n                uint correspondingLeverage = nft.getLeverageFromID(nftID);\r\n                if(correspondingLeverage == _leverage){\r\n                    hasCorrespondingNFT = true;\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            require(hasCorrespondingNFT, \"You don't own the corresponding NFT for this leverage.\");            \r\n        }\r\n        \r\n        token.transferFrom(msg.sender, address(this), _positionSize);\r\n        token.burn(address(this), _positionSize);\r\n\r\n        uint DEV_FUND_fee = _positionSize.mul(DEV_FUND_FEE_P).div(100);\r\n        uint positionSizeMinusFee = _positionSize.sub(DEV_FUND_fee);\r\n\r\n        token.mint(DEV_FUND, DEV_FUND_fee);\r\n\r\n        uint ethPosSize = positionSizeMinusFee.mul(getGFarmPriceEth()).div(PRECISION);\r\n\r\n        trades[msg.sender] = Trade(block.number, msg.sender, _buy, getEthPrice(), ethPosSize, _leverage);\r\n        addressesTradeOpen.push(msg.sender);\r\n        addressTradeOpenID[msg.sender] = addressesTradeOpen.length.sub(1);\r\n    }\r\n    function closeTrade() external{\r\n        require(hasOpenTrade(msg.sender), \"You have no open trade.\");\r\n        Trade memory t = trades[msg.sender];\r\n        require(block.number >= t.openBlock.add(3), \"Trade must be open for at least 3 blocks.\");\r\n\r\n        if(!canLiquidate(msg.sender)){\r\n            uint tokensBack = positionSizeGFARM(msg.sender);\r\n            int pnl = myTokenPNL();\r\n\r\n            // Gain\r\n            if(pnl > 0){ \r\n                Gains storage userGains = gains[msg.sender];\r\n                userGains.value = userGains.value.add(uint(pnl));\r\n                userGains.lastTradeClosed = block.number;\r\n            // Loss\r\n            }else if(pnl < 0){\r\n                tokensBack = tokensBack.sub(uint(pnl*(-1)));\r\n            }\r\n\r\n            token.mint(msg.sender, tokensBack);\r\n        }\r\n\r\n        unregisterOpenTrade(msg.sender);\r\n    }\r\n    function liquidate(address a) external{\r\n        require(canLiquidate(a), \"No trade to liquidate for this address.\");\r\n        require(myNftsCount() > 0 || msg.sender == DEV_FUND, \"You don't own any GFarm NFT.\");\r\n\r\n        token.mint(msg.sender, liquidateAmountGFARM(a));\r\n        unregisterOpenTrade(a);\r\n    }\r\n    function claimGains() external{\r\n        Gains storage userGains = gains[msg.sender];\r\n        require(block.number.sub(userGains.lastTradeClosed) >= 3, \"You must wait 3 block after you close a trade.\");\r\n        token.mint(msg.sender, userGains.value);\r\n        userGains.value = 0;\r\n    }\r\n\r\n    // UI VIEW FUNCTIONS (READ-ONLY)\r\n\r\n    function myGains() external view returns(uint){\r\n        return gains[msg.sender].value;\r\n    }\r\n    function canClaimGains() external view returns(bool){\r\n        return block.number.sub(gains[msg.sender].lastTradeClosed) >= 3 && gains[msg.sender].value > 0;\r\n    }\r\n    // Divide by PRECISION for real value\r\n    function myPercentPNL() external view returns(int){\r\n        if(!hasOpenTrade(msg.sender)){ return 0; }\r\n\r\n        Trade memory t = trades[msg.sender];\r\n        return currentPercentProfit(t.openPrice, getEthPrice(), t.buy, t.leverage);\r\n    }\r\n    function myOpenPrice() external view returns(uint){\r\n        return trades[msg.sender].openPrice;\r\n    }\r\n    function myPositionSizeETH() external view returns(uint){\r\n        return trades[msg.sender].ethPositionSize;\r\n    }\r\n    function myPositionSizeGFARM() external view returns(uint){\r\n        return positionSizeGFARM(msg.sender);\r\n    }\r\n    function myDirection() external view returns(string memory){\r\n        if(trades[msg.sender].buy){ return 'Buy'; }\r\n        return 'Sell';\r\n    }\r\n    function myLeverage() external view returns(uint){\r\n        return trades[msg.sender].leverage;\r\n    }\r\n    function tradeOpenSinceThreeBlocks() external view returns(bool){\r\n        Trade memory t = trades[msg.sender];\r\n        if(!hasOpenTrade(msg.sender) || block.number < t.openBlock){ return false; }\r\n        return block.number.sub(t.openBlock) >= 3;\r\n    }\r\n    function getAddressesTradeOpen() external view returns(address[] memory){\r\n        return addressesTradeOpen;\r\n    }\r\n    function unlockedLeverages() external view returns(uint16[8] memory leverages){\r\n        for(uint i = 0; i < myNftsCount(); i++){\r\n            uint16 leverage = nft.getLeverageFromID(nft.tokenOfOwnerByIndex(msg.sender, i));\r\n            uint id = nft.leverageID(leverage);\r\n            leverages[id] = leverage;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract GFarmTokenInterface\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"_gfarmEthPair\",\"type\":\"address\"},{\"internalType\":\"contract GFarmNFTInterface\",\"name\":\"_nft\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DEV_FUND\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressesTradeOpen\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canClaimGains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"canLiquidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimGains\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTradeClosed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddressesTradeOpen\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEthPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxPosGFARM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"hasOpenTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"liquidateAmountGFARM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myDirection\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myGains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myNftsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myOpenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myPercentPNL\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myPositionSizeETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myPositionSizeGFARM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myTokenPNL\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_positionSize\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_leverage\",\"type\":\"uint16\"}],\"name\":\"openTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"positionSizeGFARM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeOpenSinceThreeBlocks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"trades\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"openBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"openPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethPositionSize\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"leverage\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockedLeverages\",\"outputs\":[{\"internalType\":\"uint16[8]\",\"name\":\"leverages\",\"type\":\"uint16[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GFarmTrading","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000544288176bb6d7d198302a2d18fad38442e69b25000000000000000000000000708da4bc0b6c1e3ca4b1f7ba8effb826ead8e18f000000000000000000000000df58594a52f38092001527e59d843e4734384228","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d79f68a717ef79397b61ffaf621f7586a5f6457151bec805727e1d2ba899e539"}]}