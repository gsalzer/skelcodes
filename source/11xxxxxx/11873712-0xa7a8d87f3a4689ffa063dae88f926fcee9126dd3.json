{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IArmorMaster {\r\n    function registerModule(bytes32 _key, address _module) external;\r\n    function getModule(bytes32 _key) external view returns(address);\r\n    function keep() external;\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * \r\n * @dev Completely default OpenZeppelin.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initializeOwnable() internal {\r\n        require(_owner == address(0), \"already initialized\");\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"msg.sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _pendingOwner = newOwner;\r\n    }\r\n\r\n    function receiveOwnership() public {\r\n        require(msg.sender == _pendingOwner, \"only pending owner can call this function\");\r\n        _transferOwnership(_pendingOwner);\r\n        _pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\nlibrary Bytes32 {\r\n    function toString(bytes32 x) internal pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint256 j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint256 j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Each arCore contract is a module to enable simple communication and interoperability. ArmorMaster.sol is master.\r\n**/\r\ncontract ArmorModule {\r\n    IArmorMaster internal _master;\r\n\r\n    using Bytes32 for bytes32;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == Ownable(address(_master)).owner(), \"only owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier doKeep() {\r\n        _master.keep();\r\n        _;\r\n    }\r\n\r\n    modifier onlyModule(bytes32 _module) {\r\n        string memory message = string(abi.encodePacked(\"only module \", _module.toString(),\" can call this function\"));\r\n        require(msg.sender == getModule(_module), message);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Used when multiple can call.\r\n    **/\r\n    modifier onlyModules(bytes32 _moduleOne, bytes32 _moduleTwo) {\r\n        string memory message = string(abi.encodePacked(\"only module \", _moduleOne.toString(),\" or \", _moduleTwo.toString(),\" can call this function\"));\r\n        require(msg.sender == getModule(_moduleOne) || msg.sender == getModule(_moduleTwo), message);\r\n        _;\r\n    }\r\n\r\n    function initializeModule(address _armorMaster) internal {\r\n        require(address(_master) == address(0), \"already initialized\");\r\n        require(_armorMaster != address(0), \"master cannot be zero address\");\r\n        _master = IArmorMaster(_armorMaster);\r\n    }\r\n\r\n    function changeMaster(address _newMaster) external onlyOwner {\r\n        _master = IArmorMaster(_newMaster);\r\n    }\r\n\r\n    function getModule(bytes32 _key) internal view returns(address) {\r\n        return _master.getModule(_key);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IARNXMVault {\r\n    function unwrapWnxm() external;\r\n}\r\n\r\ninterface IClaimManager {\r\n    function initialize(address _armorMaster) external;\r\n    function transferNft(address _to, uint256 _nftId) external;\r\n    function exchangeWithdrawal(uint256 _amount) external;\r\n}\r\n\r\n/**\r\n * @dev Quick interface for the Nexus Mutual contract to work with the Armor Contracts.\r\n **/\r\n\r\n// to get nexus mutual contract address\r\ninterface INXMMaster {\r\n    function tokenAddress() external view returns(address);\r\n    function owner() external view returns(address);\r\n    function pauseTime() external view returns(uint);\r\n    function masterInitialized() external view returns(bool);\r\n    function isPause() external view returns(bool check);\r\n    function isMember(address _add) external view returns(bool);\r\n    function getLatestAddress(bytes2 _contractName) external view returns(address payable contractAddress);\r\n}\r\n\r\ninterface INXMPool {\r\n    function buyNXM(uint minTokensOut) external payable;\r\n}\r\n\r\ninterface IBFactory {\r\n    function isBPool(address _pool) external view returns(bool);\r\n}\r\n\r\ninterface IBPool {\r\n    function swapExactAmountIn(address tokenin, uint256 inamount, address out, uint256 minreturn, uint256 maxprice) external returns(uint tokenAmountOut, uint spotPriceAfter);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactETHForTokens(uint256 minReturn, address[] calldata path, address to, uint256 deadline) external payable returns(uint256[] memory);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 amount) external;\r\n}\r\n\r\n/**\r\n * ExchangeManager contract enables us to slowly exchange excess claim funds for wNXM then transfer to the arNXM vault. \r\n**/\r\ncontract ExchangeManager is ArmorModule {\r\n    \r\n    address public exchanger;\r\n    IARNXMVault public constant ARNXM_VAULT = IARNXMVault(0x1337DEF1FC06783D4b03CB8C1Bf3EBf7D0593FC4);\r\n    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    IERC20 public constant WNXM = IERC20(0x0d438F3b5175Bebc262bF23753C1E53d03432bDE);\r\n    INXMMaster public constant NXM_MASTER = INXMMaster(0x01BFd82675DBCc7762C84019cA518e701C0cD07e);\r\n    IBFactory public constant BALANCER_FACTORY = IBFactory(0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd);\r\n    IUniswapV2Router02 public constant UNI_ROUTER = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    IUniswapV2Router02 public constant SUSHI_ROUTER = IUniswapV2Router02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n\r\n    // Address allowed to exchange tokens.\r\n    modifier onlyExchanger {\r\n        require(msg.sender == exchanger, \"Sender is not approved to exchange.\");\r\n        _;\r\n    }\r\n\r\n    // ClaimManager will be sending Ether to this contract.\r\n    receive() external payable { }\r\n    \r\n    /**\r\n     * @dev Initialize master for the contract. Owner must also add module for ExchangeManager to master upon deployment.\r\n     * @param _armorMaster Address of the ArmorMaster contract.\r\n    **/\r\n    function initialize(address _armorMaster, address _exchanger)\r\n      external\r\n    {\r\n        initializeModule(_armorMaster);\r\n        exchanger = _exchanger;\r\n    }\r\n    \r\n    /**\r\n     * @dev Main function to withdraw Ether from ClaimManager, exchange, then transfer to arNXM Vault.\r\n     * @param _amount Amount of Ether (in Wei) to withdraw from ClaimManager.\r\n     * @param _minReturn Minimum amount of wNXM we will accept in return for the Ether exchanged.\r\n    **/\r\n    function buyWNxmUni(uint256 _amount, uint256 _minReturn, address[] memory _path)\r\n      external\r\n      onlyExchanger\r\n    {\r\n        _requestFunds(_amount);\r\n        _exchangeAndSendToVault(address(UNI_ROUTER), _minReturn, _path);\r\n    }\r\n    \r\n    /**\r\n     * @dev Main function to withdraw Ether from ClaimManager, exchange, then transfer to arNXM Vault.\r\n     * @param _amount Amount of Ether (in Wei) to withdraw from ClaimManager.\r\n     * @param _minReturn Minimum amount of wNXM we will accept in return for the Ether exchanged.\r\n    **/\r\n    function buyWNxmSushi(uint256 _amount, uint256 _minReturn, address[] memory _path)\r\n      external\r\n      onlyExchanger\r\n    {\r\n        _requestFunds(_amount);\r\n        _exchangeAndSendToVault(address(SUSHI_ROUTER), _minReturn, _path);\r\n    }\r\n\r\n    function buyWNxmBalancer(uint256 _amount, address _bpool, uint256 _minReturn, uint256 _maxPrice)\r\n      external\r\n      onlyExchanger\r\n    {\r\n        require(BALANCER_FACTORY.isBPool(_bpool), \"NOT_BPOOL\");\r\n        _requestFunds(_amount);\r\n        uint256 balance = address(this).balance;\r\n        IWETH(address(WETH)).deposit{value:balance}();\r\n        WETH.approve(_bpool, balance);\r\n        IBPool(_bpool).swapExactAmountIn(address(WETH), balance, address(WNXM), _minReturn, _maxPrice);\r\n        _transferWNXM();\r\n        ARNXM_VAULT.unwrapWnxm();\r\n    }\r\n    \r\n    /**\r\n     * @dev Main function to withdraw Ether from ClaimManager, exchange, then transfer to arNXM Vault.\r\n     * @param _ethAmount Amount of Ether (in Wei) to withdraw from ClaimManager.\r\n     * @param _minNxm Minimum amount of NXM we will accept in return for the Ether exchanged.\r\n    **/\r\n    function buyNxm(uint256 _ethAmount, uint256 _minNxm)\r\n      external\r\n      onlyExchanger\r\n    {\r\n        _requestFunds(_ethAmount);\r\n        INXMPool pool = INXMPool(NXM_MASTER.getLatestAddress(\"P1\"));\r\n        pool.buyNXM{value:_ethAmount}(_minNxm);\r\n        _transferNXM();\r\n    }\r\n\r\n    /**\r\n     * @dev Call ClaimManager to request Ether from the contract.\r\n     * @param _amount Ether (in Wei) to withdraw from ClaimManager.\r\n    **/\r\n    function _requestFunds(uint256 _amount)\r\n      internal\r\n    {\r\n        IClaimManager( getModule(\"CLAIM\") ).exchangeWithdrawal(_amount);\r\n    }\r\n \r\n    /**\r\n     * @dev Exchange all Ether for wNXM on uniswap-like exchanges\r\n     * @param _router router address of uniswap-like protocols(uni/sushi)\r\n     * @param _minReturn Minimum amount of wNXM we wish to receive from the exchange.\r\n    **/\r\n    function _exchangeAndSendToVault(address _router, uint256 _minReturn, address[] memory _path)\r\n      internal\r\n    {\r\n        uint256 ethBalance = address(this).balance;\r\n        IUniswapV2Router02(_router).swapExactETHForTokens{value:ethBalance}(_minReturn, _path, address(ARNXM_VAULT), uint256(~0) );\r\n        ARNXM_VAULT.unwrapWnxm();\r\n    }\r\n    \r\n    /**\r\n     * @dev Transfer all wNXM directly to arNXM. This will not mint more arNXM so it will add value to arNXM.\r\n    **/\r\n    function _transferWNXM()\r\n      internal\r\n    {\r\n        uint256 wNxmBalance = WNXM.balanceOf( address(this) );\r\n        WNXM.transfer(address(ARNXM_VAULT), wNxmBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer all NXM directly to arNXM. This will not mint more arNXM so it will add value to arNXM.\r\n    **/\r\n    function _transferNXM()\r\n      internal\r\n    {\r\n        IERC20 NXM = IERC20(NXM_MASTER.tokenAddress());\r\n        uint256 nxmBalance = NXM.balanceOf( address(this) );\r\n        NXM.transfer(address(ARNXM_VAULT), nxmBalance);\r\n    }\r\n    \r\n    /**\r\n     * @dev Owner may change the address allowed to exchange tokens.\r\n     * @param _newExchanger New address to make exchanger.\r\n    **/\r\n    function changeExchanger(address _newExchanger)\r\n      external\r\n      onlyOwner\r\n    {\r\n        exchanger = _newExchanger;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"name\":\"ARNXM_VAULT\",\"outputs\":[{\"internalType\":\"contract IARNXMVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BALANCER_FACTORY\",\"outputs\":[{\"internalType\":\"contract IBFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NXM_MASTER\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUSHI_ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNI_ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WNXM\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minNxm\",\"type\":\"uint256\"}],\"name\":\"buyNxm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_bpool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"buyWNxmBalancer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"buyWNxmSushi\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"buyWNxmUni\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newExchanger\",\"type\":\"address\"}],\"name\":\"changeExchanger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMaster\",\"type\":\"address\"}],\"name\":\"changeMaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchanger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_armorMaster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchanger\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ExchangeManager","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://353e47f1bd7c02c6418baaa3a401c27e08c7999eb12a486454f3d722a528b030"}]}