{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Tellor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\nimport \\\"./TellorStake.sol\\\";\\nimport \\\"./TellorGetters.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\nimport \\\"./ITellor.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title Tellor Oracle System\\n * @dev Oracle contract where miners can submit the proof of work along with the value.\\n */\\ncontract Tellor is TellorStake {\\n    using SafeMath for uint256;\\n\\n    event TipAdded(\\n        address indexed _sender,\\n        uint256 indexed _requestId,\\n        uint256 _tip,\\n        uint256 _totalTips\\n    );\\n    //emits when a new challenge is created (either on mined block or when a new request is pushed forward on waiting system)\\n    event NewChallenge(\\n        bytes32 indexed _currentChallenge,\\n        uint256[5] _currentRequestId,\\n        uint256 _difficulty,\\n        uint256 _totalTips\\n    );\\n    //Emits upon a successful Mine, indicates the blockTime at point of the mine and the value mined\\n    event NewValue(\\n        uint256[5] _requestId,\\n        uint256 _time,\\n        uint256[5] _value,\\n        uint256 _totalTips,\\n        bytes32 indexed _currentChallenge\\n    );\\n    //Emits upon each mine (5 total) and shows the miner, nonce, and value submitted\\n    event NonceSubmitted(\\n        address indexed _miner,\\n        string _nonce,\\n        uint256[5] _requestId,\\n        uint256[5] _value,\\n        bytes32 indexed _currentChallenge,\\n        uint256 _slot\\n    );\\n\\n    /**\\n     * @dev This is an internal function used by the function migrate  that helps to\\n     *  swap old trb tokens for new ones based on the user's old Tellor balance\\n     * @param _user is the msg.sender address of the user to migrate the balance from\\n     */\\n    function _migrate(address _user) internal {\\n        require(!migrated[_user], \\\"alredy migrated\\\");\\n        _doMint(_user, ITellor(addresses[_OLD_TELLOR]).balanceOf(_user));\\n        migrated[_user] = true;\\n    }\\n\\n    /**\\n     * @dev This function allows users to swap old trb tokens for new ones based\\n     * on the user's old Tellor balance\\n     */\\n    function migrate() external {\\n        _migrate(msg.sender);\\n    }\\n\\n    /**\\n     * @dev  allows for the deity to update the TellorStake contract address\\n     * @param _tGetters the address of the new Tellor Contract\\n     */\\n    function changeTellorGetters(address _tGetters) external {\\n        require(msg.sender == addresses[_DEITY]);\\n        addresses[_TELLOR_GETTERS] = _tGetters;\\n    }\\n\\n    /**\\n     * @dev This function allows miners to submit their mining solution and data requested\\n     * @param _nonce is the mining solution\\n     * @param _requestIds iare the 5 request ids being mined\\n     * @param _values are the 5 values correspoding to the 5 request ids\\n     */\\n    function submitMiningSolution(\\n        string calldata _nonce,\\n        uint256[5] calldata _requestIds,\\n        uint256[5] calldata _values\\n    ) external {\\n        bytes32 _hashMsgSender = keccak256(abi.encode(msg.sender));\\n        require(\\n            uints[_hashMsgSender] == 0 ||\\n                block.timestamp - uints[_hashMsgSender] > 15 minutes,\\n            \\\"Miner can only win rewards once per 15 min\\\"\\n        );\\n        if (uints[_SLOT_PROGRESS] != 4) {\\n            _verifyNonce(_nonce);\\n        }\\n        uints[_hashMsgSender] = block.timestamp;\\n        _submitMiningSolution(_nonce, _requestIds, _values);\\n    }\\n\\n    /**\\n     * @dev This is an internal function used by submitMiningSolution to  allows miners to submit\\n     * their mining solution and data requested. It checks the miner is staked, has not\\n     * won in the las 15 min, and checks they are submitting all the correct requestids\\n     * @param _nonce is the mining solution\\n     * @param _requestIds iare the 5 request ids being mined\\n     * @param _values are the 5 values correspoding to the 5 request ids\\n     */\\n    function _submitMiningSolution(\\n        string memory _nonce,\\n        uint256[5] memory _requestIds,\\n        uint256[5] memory _values\\n    ) internal {\\n        //Verifying Miner Eligibility\\n        bytes32 _hashMsgSender = keccak256(abi.encode(msg.sender));\\n        require(\\n            stakerDetails[msg.sender].currentStatus == 1,\\n            \\\"Miner status is not staker\\\"\\n        );\\n\\n        require(\\n            _requestIds[0] == currentMiners[0].value,\\n            \\\"Request ID is wrong\\\"\\n        );\\n        require(\\n            _requestIds[1] == currentMiners[1].value,\\n            \\\"Request ID is wrong\\\"\\n        );\\n        require(\\n            _requestIds[2] == currentMiners[2].value,\\n            \\\"Request ID is wrong\\\"\\n        );\\n        require(\\n            _requestIds[3] == currentMiners[3].value,\\n            \\\"Request ID is wrong\\\"\\n        );\\n        require(\\n            _requestIds[4] == currentMiners[4].value,\\n            \\\"Request ID is wrong\\\"\\n        );\\n        uints[_hashMsgSender] = block.timestamp;\\n\\n        bytes32 _currChallenge = bytesVars[_CURRENT_CHALLENGE];\\n        uint256 _slotP = uints[_SLOT_PROGRESS];\\n        //Checking and updating Miner Status\\n        require(\\n            minersByChallenge[_currChallenge][msg.sender] == false,\\n            \\\"Miner already submitted the value\\\"\\n        );\\n        //Update the miner status to true once they submit a value so they don't submit more than once\\n        minersByChallenge[_currChallenge][msg.sender] = true;\\n        //Updating Request\\n        Request storage _tblock = requestDetails[uints[_T_BLOCK]];\\n        //Assigning directly is cheaper than using a for loop\\n        _tblock.valuesByTimestamp[0][_slotP] = _values[0];\\n        _tblock.valuesByTimestamp[1][_slotP] = _values[1];\\n        _tblock.valuesByTimestamp[2][_slotP] = _values[2];\\n        _tblock.valuesByTimestamp[3][_slotP] = _values[3];\\n        _tblock.valuesByTimestamp[4][_slotP] = _values[4];\\n        _tblock.minersByValue[0][_slotP] = msg.sender;\\n        _tblock.minersByValue[1][_slotP] = msg.sender;\\n        _tblock.minersByValue[2][_slotP] = msg.sender;\\n        _tblock.minersByValue[3][_slotP] = msg.sender;\\n        _tblock.minersByValue[4][_slotP] = msg.sender;\\n\\n        if (_slotP + 1 == 4) {\\n            _adjustDifficulty();\\n        }\\n\\n        if (_slotP + 1 == 5) {\\n            //slotProgress has been incremented, but we're using the variable on stack to save gas\\n            _newBlock(_nonce, _requestIds);\\n            uints[_SLOT_PROGRESS] = 0;\\n        } else {\\n            uints[_SLOT_PROGRESS]++;\\n        }\\n        emit NonceSubmitted(\\n            msg.sender,\\n            _nonce,\\n            _requestIds,\\n            _values,\\n            _currChallenge,\\n            _slotP\\n        );\\n    }\\n\\n    /**\\n     * @dev This is an internal function used by submitMiningSolution to allows miners to submit\\n     * their mining solution and data requested. It checks the miner has submitted a\\n     * valid nonce or allows any solution if 15 minutes or more have passed since last\\n     *  mine values\\n     * @param _nonce is the mining solution\\n     */\\n    function _verifyNonce(string memory _nonce) internal view {\\n        require(\\n            uint256(\\n                sha256(\\n                    abi.encodePacked(\\n                        ripemd160(\\n                            abi.encodePacked(\\n                                keccak256(\\n                                    abi.encodePacked(\\n                                        bytesVars[_CURRENT_CHALLENGE],\\n                                        msg.sender,\\n                                        _nonce\\n                                    )\\n                                )\\n                            )\\n                        )\\n                    )\\n                )\\n            ) %\\n                uints[_DIFFICULTY] ==\\n                0 ||\\n                block.timestamp - uints[_TIME_OF_LAST_NEW_VALUE] >= 15 minutes,\\n            \\\"Incorrect nonce for current challenge\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev This is an internal function used by submitMiningSolution and adjusts the difficulty\\n     * based on the the difference between the target time and how long it took to solve\\n     * the previous challenge otherwise it sets it to 1\\n     */\\n    function _adjustDifficulty() internal {\\n        // If the difference between the timeTarget and how long it takes to solve the challenge this updates the challenge\\n        //difficulty up or down by the difference between the target time and how long it took to solve the previous challenge\\n        //otherwise it sets it to 1\\n        uint256 timeDiff = block.timestamp - uints[_TIME_OF_LAST_NEW_VALUE];\\n        int256 _change = int256(SafeMath.min(1200, timeDiff));\\n        int256 _diff = int256(uints[_DIFFICULTY]);\\n        _change = (_diff * (int256(uints[_TIME_TARGET]) - _change)) / 4000;\\n        if (_change == 0) {\\n            _change = 1;\\n        }\\n        uints[_DIFFICULTY] = uint256(SafeMath.max(_diff + _change, 1));\\n    }\\n\\n    /**\\n     * @dev This is an internal function used by submitMiningSolution to\\n     * calculate and pay rewards to miners\\n     * @param miners are the 5 miners to reward\\n     * @param _previousTime is the previous mine time based on the 4th entry\\n     */\\n    function _payReward(address[5] memory miners, uint256 _previousTime)\\n        internal\\n    {\\n        //_timeDiff is how many seconds passed since last block\\n        uint256 _timeDiff = block.timestamp - _previousTime;\\n        uint256 reward = (_timeDiff * uints[_CURRENT_REWARD]) / 300;\\n        uint256 _tip = uints[_CURRENT_TOTAL_TIPS] / 10;\\n        uint256 _devShare = reward / 2;\\n\\n        _doMint(miners[0], reward + _tip);\\n        _doMint(miners[1], reward + _tip);\\n        _doMint(miners[2], reward + _tip);\\n        _doMint(miners[3], reward + _tip);\\n        _doMint(miners[4], reward + _tip);\\n\\n        _doMint(addresses[_OWNER], _devShare);\\n        uints[_CURRENT_TOTAL_TIPS] = 0;\\n    }\\n\\n    /**\\n     * @dev This is an internal function called by submitMiningSolution and adjusts the difficulty,\\n     * sorts and stores the first 5 values received, pays the miners, the dev share and\\n     * assigns a new challenge\\n     * @param _nonce or solution for the PoW  for the requestId\\n     * @param _requestIds for the current request being mined\\n     */\\n    function _newBlock(string memory _nonce, uint256[5] memory _requestIds)\\n        internal\\n    {\\n        Request storage _tblock = requestDetails[uints[_T_BLOCK]];\\n        bytes32 _currChallenge = bytesVars[_CURRENT_CHALLENGE];\\n        uint256 _previousTime = uints[_TIME_OF_LAST_NEW_VALUE];\\n        uint256 _timeOfLastNewValueVar = block.timestamp;\\n        uints[_TIME_OF_LAST_NEW_VALUE] = _timeOfLastNewValueVar;\\n        //this loop sorts the values and stores the median as the official value\\n        uint256[5] memory a;\\n        uint256[5] memory b;\\n        for (uint256 k = 0; k < 5; k++) {\\n            for (uint256 i = 1; i < 5; i++) {\\n                uint256 temp = _tblock.valuesByTimestamp[k][i];\\n                address temp2 = _tblock.minersByValue[k][i];\\n                uint256 j = i;\\n                while (j > 0 && temp < _tblock.valuesByTimestamp[k][j - 1]) {\\n                    _tblock.valuesByTimestamp[k][j] = _tblock.valuesByTimestamp[\\n                        k\\n                    ][j - 1];\\n                    _tblock.minersByValue[k][j] = _tblock.minersByValue[k][\\n                        j - 1\\n                    ];\\n                    j--;\\n                }\\n                if (j < i) {\\n                    _tblock.valuesByTimestamp[k][j] = temp;\\n                    _tblock.minersByValue[k][j] = temp2;\\n                }\\n            }\\n            Request storage _request = requestDetails[_requestIds[k]];\\n            //Save the official(finalValue), timestamp of it, 5 miners and their submitted values for it, and its block number\\n            a = _tblock.valuesByTimestamp[k];\\n            _request.finalValues[_timeOfLastNewValueVar] = a[2];\\n            b[k] = a[2];\\n            _request.minersByValue[_timeOfLastNewValueVar] = _tblock\\n                .minersByValue[k];\\n            _request.valuesByTimestamp[_timeOfLastNewValueVar] = _tblock\\n                .valuesByTimestamp[k];\\n            delete _tblock.minersByValue[k];\\n            delete _tblock.valuesByTimestamp[k];\\n            _request.requestTimestamps.push(_timeOfLastNewValueVar);\\n            _request.minedBlockNum[_timeOfLastNewValueVar] = block.number;\\n            _request.apiUintVars[_TOTAL_TIP] = 0;\\n        }\\n        emit NewValue(\\n            _requestIds,\\n            _timeOfLastNewValueVar,\\n            b,\\n            uints[_CURRENT_TOTAL_TIPS],\\n            _currChallenge\\n        );\\n        //add timeOfLastValue to the newValueTimestamps array\\n        newValueTimestamps.push(_timeOfLastNewValueVar);\\n        address[5] memory miners =\\n            requestDetails[_requestIds[0]].minersByValue[\\n                _timeOfLastNewValueVar\\n            ];\\n        //pay Miners Rewards\\n        _payReward(miners, _previousTime);\\n        uints[_T_BLOCK]++;\\n        uint256[5] memory _topId = _getTopRequestIDs();\\n        for (uint256 i = 0; i < 5; i++) {\\n            currentMiners[i].value = _topId[i];\\n            requestQ[\\n                requestDetails[_topId[i]].apiUintVars[_REQUEST_Q_POSITION]\\n            ] = 0;\\n            uints[_CURRENT_TOTAL_TIPS] += requestDetails[_topId[i]].apiUintVars[\\n                _TOTAL_TIP\\n            ];\\n        }\\n        //Issue the the next challenge\\n        _currChallenge = keccak256(\\n            abi.encode(_nonce, _currChallenge, blockhash(block.number - 1))\\n        );\\n        bytesVars[_CURRENT_CHALLENGE] = _currChallenge; // Save hash for next proof\\n        emit NewChallenge(\\n            _currChallenge,\\n            _topId,\\n            uints[_DIFFICULTY],\\n            uints[_CURRENT_TOTAL_TIPS]\\n        );\\n    }\\n\\n    /**\\n     * @dev Add tip to Request value from oracle\\n     * @param _requestId being requested to be mined\\n     * @param _tip amount the requester is willing to pay to be get on queue. Miners\\n     * mine the onDeckQueryHash, or the api with the highest payout pool\\n     */\\n    function addTip(uint256 _requestId, uint256 _tip) external {\\n        require(_requestId != 0, \\\"RequestId is 0\\\");\\n        require(_tip != 0, \\\"Tip should be greater than 0\\\");\\n        uint256 _count = uints[_REQUEST_COUNT] + 1;\\n        if (_requestId == _count) {\\n            uints[_REQUEST_COUNT] = _count;\\n        } else {\\n            require(_requestId < _count, \\\"RequestId is not less than count\\\");\\n        }\\n        _doBurn(msg.sender, _tip);\\n        //Update the information for the request that should be mined next based on the tip submitted\\n        updateOnDeck(_requestId, _tip);\\n        emit TipAdded(\\n            msg.sender,\\n            _requestId,\\n            _tip,\\n            requestDetails[_requestId].apiUintVars[_TOTAL_TIP]\\n        );\\n    }\\n\\n    /**\\n     * @dev This function updates the requestQ when addTip are ran\\n     * @param _requestId being requested\\n     * @param _tip is the tip to add\\n     */\\n    function updateOnDeck(uint256 _requestId, uint256 _tip) internal {\\n        Request storage _request = requestDetails[_requestId];\\n        _request.apiUintVars[_TOTAL_TIP] = _request.apiUintVars[_TOTAL_TIP].add(\\n            _tip\\n        );\\n        if (\\n            currentMiners[0].value == _requestId ||\\n            currentMiners[1].value == _requestId ||\\n            currentMiners[2].value == _requestId ||\\n            currentMiners[3].value == _requestId ||\\n            currentMiners[4].value == _requestId\\n        ) {\\n            uints[_CURRENT_TOTAL_TIPS] += _tip;\\n        } else {\\n            //if the request is not part of the requestQ[51] array\\n            //then add to the requestQ[51] only if the _payout/tip is greater than the minimum(tip) in the requestQ[51] array\\n            if (_request.apiUintVars[_REQUEST_Q_POSITION] == 0) {\\n                uint256 _min;\\n                uint256 _index;\\n                (_min, _index) = _getMin(requestQ);\\n                //we have to zero out the oldOne\\n                //if the _payout is greater than the current minimum payout in the requestQ[51] or if the minimum is zero\\n                //then add it to the requestQ array and map its index information to the requestId and the apiUintVars\\n                if (_request.apiUintVars[_TOTAL_TIP] > _min || _min == 0) {\\n                    requestQ[_index] = _request.apiUintVars[_TOTAL_TIP];\\n                    requestDetails[requestIdByRequestQIndex[_index]]\\n                        .apiUintVars[_REQUEST_Q_POSITION] = 0;\\n                    requestIdByRequestQIndex[_index] = _requestId;\\n                    _request.apiUintVars[_REQUEST_Q_POSITION] = _index;\\n                }\\n                // else if the requestId is part of the requestQ[51] then update the tip for it\\n            } else {\\n                requestQ[_request.apiUintVars[_REQUEST_Q_POSITION]] += _tip;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is an internal function called by updateOnDeck that gets the min value\\n     * @param data is an array [51] to determine the min from\\n     * @return min the min value and it's index  in the data array\\n     */\\n    function _getMin(uint256[51] memory data)\\n        internal\\n        pure\\n        returns (uint256 min, uint256 minIndex)\\n    {\\n        minIndex = data.length - 1;\\n        min = data[minIndex];\\n        for (uint256 i = data.length - 2; i > 0; i--) {\\n            if (data[i] < min) {\\n                min = data[i];\\n                minIndex = i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is an internal function called by updateOnDeck that gets the top 5 values\\n     * @param data is an array [51] to determine the top 5 values from\\n     * @return max the top 5 values and their index values in the data array\\n     */\\n    function _getMax5(uint256[51] memory data)\\n        internal\\n        pure\\n        returns (uint256[5] memory max, uint256[5] memory maxIndex)\\n    {\\n        uint256 min5 = data[1];\\n        uint256 minI = 0;\\n        for (uint256 j = 0; j < 5; j++) {\\n            max[j] = data[j + 1]; //max[0]=data[1]\\n            maxIndex[j] = j + 1; //maxIndex[0]= 1\\n            if (max[j] < min5) {\\n                min5 = max[j];\\n                minI = j;\\n            }\\n        }\\n        for (uint256 i = 6; i < data.length; i++) {\\n            if (data[i] > min5) {\\n                max[minI] = data[i];\\n                maxIndex[minI] = i;\\n                min5 = data[i];\\n                for (uint256 j = 0; j < 5; j++) {\\n                    if (max[j] < min5) {\\n                        min5 = max[j];\\n                        minI = j;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Getter function for the top 5 requests with highest payouts.\\n     * This function is used within the newBlock function\\n     * @return _requestIds the top 5 requests ids based on tips or the last 5 requests ids mined\\n     */\\n    function _getTopRequestIDs()\\n        internal\\n        view\\n        returns (uint256[5] memory _requestIds)\\n    {\\n        uint256[5] memory _max;\\n        uint256[5] memory _index;\\n        (_max, _index) = _getMax5(requestQ);\\n        for (uint256 i = 0; i < 5; i++) {\\n            if (_max[i] != 0) {\\n                _requestIds[i] = requestIdByRequestQIndex[_index[i]];\\n            } else {\\n                _requestIds[i] = currentMiners[4 - i].value;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is an internal function called within the fallback function to help delegate calls.\\n     * This functions helps delegate calls to the TellorGetters\\n     * contract.\\n     */\\n    function _delegate(address implementation)\\n        internal\\n        virtual\\n        returns (bool succ, bytes memory ret)\\n    {\\n        (succ, ret) = implementation.delegatecall(msg.data);\\n    }\\n\\n    /**\\n     * @dev The tellor logic does not fit in one contract so it has been split into two:\\n     * Tellor and TellorGetters This functions helps delegate calls to the TellorGetters\\n     * contract.\\n     */\\n    fallback() external payable {\\n        address addr = addresses[_TELLOR_GETTERS];\\n        (bool result, ) = _delegate(addr);\\n        assembly {\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n                // delegatecall returns 0 on error.\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TellorStake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\nimport \\\"./TellorTransfer.sol\\\";\\nimport \\\"./TellorGetters.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\n\\n/**\\n * title Tellor Stake\\n * @dev Contains the methods related to miners staking, unstaking, initiating disputes,\\n * voting on them. Tellor.sol\\n * references this library for function's logic.\\n */\\n\\ncontract TellorStake is TellorTransfer {\\n    using SafeMath for uint256;\\n    using SafeMath for int256;\\n\\n    //emitted when a new dispute is initialized\\n    event NewDispute(\\n        uint256 indexed _disputeId,\\n        uint256 indexed _requestId,\\n        uint256 _timestamp,\\n        address _miner\\n    );\\n    //emitted when a new vote happens\\n    event Voted(\\n        uint256 indexed _disputeID,\\n        bool _position,\\n        address indexed _voter,\\n        uint256 indexed _voteWeight\\n    );\\n    //emitted upon dispute tally\\n    event DisputeVoteTallied(\\n        uint256 indexed _disputeID,\\n        int256 _result,\\n        address indexed _reportedMiner,\\n        address _reportingParty,\\n        bool _active\\n    );\\n    event NewStake(address indexed _sender); //Emits upon new staker\\n    event StakeWithdrawn(address indexed _sender); //Emits when a staker is block.timestamp no longer staked\\n    event StakeWithdrawRequested(address indexed _sender); //Emits when a staker begins the 7 day withdraw period\\n\\n    /*Functions*/\\n    /**\\n     * @dev This function allows stakers to request to withdraw their stake (no longer stake)\\n     * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\\n     * can withdraw the deposit\\n     */\\n    function requestStakingWithdraw() public {\\n        StakeInfo storage stakes = stakerDetails[msg.sender];\\n        //Require that the miner is staked\\n        require(stakes.currentStatus == 1, \\\"Miner is not staked\\\");\\n\\n        //Change the miner staked to locked to be withdrawStake\\n        stakes.currentStatus = 2;\\n\\n        //Change the startDate to block.timestamp since the lock up period begins block.timestamp\\n        //and the miner can only withdraw 7 days later from block.timestamp(check the withdraw function)\\n        stakes.startDate = block.timestamp - (block.timestamp % 86400);\\n\\n        //Reduce the staker count\\n        uints[_STAKE_COUNT] -= 1;\\n\\n        //Update the minimum dispute fee that is based on the number of stakers\\n        updateMinDisputeFee();\\n        emit StakeWithdrawRequested(msg.sender);\\n    }\\n\\n    /**\\n     * @dev This function allows users to withdraw their stake after a 7 day waiting\\n     * period from request\\n     */\\n    function withdrawStake() public {\\n        StakeInfo storage stakes = stakerDetails[msg.sender];\\n        //Require the staker has locked for withdraw(currentStatus ==2) and that 7 days have\\n        //passed by since they locked for withdraw\\n        require(\\n            block.timestamp - (block.timestamp % 86400) - stakes.startDate >=\\n                7 days,\\n            \\\"7 days didn't pass\\\"\\n        );\\n        require(\\n            stakes.currentStatus == 2,\\n            \\\"Miner was not locked for withdrawal\\\"\\n        );\\n        stakes.currentStatus = 0;\\n        emit StakeWithdrawn(msg.sender);\\n    }\\n\\n    /**\\n     * @dev This function allows miners to deposit their stake.\\n     */\\n    function depositStake() public {\\n        newStake(msg.sender);\\n        updateMinDisputeFee();\\n    }\\n\\n    /**\\n     * @dev This internal function is used the depositStake function to successfully stake miners.\\n     * The function updates their status/state and status start date so they are locked it so they can't withdraw\\n     * and updates the number of stakers in the system.\\n     */\\n    function newStake(address _staker) internal {\\n        require(\\n            balanceOf(_staker) >= uints[_STAKE_AMOUNT],\\n            \\\"Balance is lower than stake amount\\\"\\n        );\\n        //Ensure they can only stake if they are not currently staked or if their stake time frame has ended\\n        //and they are currently locked for withdraw\\n        require(\\n            stakerDetails[_staker].currentStatus == 0 ||\\n                stakerDetails[_staker].currentStatus == 2,\\n            \\\"Miner is in the wrong state\\\"\\n        );\\n        uints[_STAKE_COUNT] += 1;\\n        stakerDetails[_staker] = StakeInfo({\\n            currentStatus: 1, //this resets their stake start date to today\\n            startDate: block.timestamp - (block.timestamp % 86400)\\n        });\\n        emit NewStake(_staker);\\n    }\\n\\n    /**\\n     * @dev Helps initialize a dispute by assigning it a disputeId\\n     * when a miner returns a false/bad value on the validate array(in Tellor.ProofOfWork) it sends the\\n     * invalidated value information to POS voting\\n     * @param _requestId being disputed\\n     * @param _timestamp being disputed\\n     * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\\n     * requires 5 miners to submit a value.\\n     */\\n    function beginDispute(\\n        uint256 _requestId,\\n        uint256 _timestamp,\\n        uint256 _minerIndex\\n    ) public {\\n        Request storage _request = requestDetails[_requestId];\\n        require(_request.minedBlockNum[_timestamp] != 0, \\\"Mined block is 0\\\");\\n        require(_minerIndex < 5, \\\"Miner index is wrong\\\");\\n\\n        //_miner is the miner being disputed. For every mined value 5 miners are saved in an array and the _minerIndex\\n        //provided by the party initiating the dispute\\n        address _miner = _request.minersByValue[_timestamp][_minerIndex];\\n        bytes32 _hash =\\n            keccak256(abi.encodePacked(_miner, _requestId, _timestamp));\\n\\n        //Increase the dispute count by 1\\n        uint256 disputeId = uints[_DISPUTE_COUNT] + 1;\\n        uints[_DISPUTE_COUNT] = disputeId;\\n\\n        //Ensures that a dispute is not already open for the that miner, requestId and timestamp\\n        uint256 hashId = disputeIdByDisputeHash[_hash];\\n        if (hashId != 0) {\\n            disputesById[disputeId].disputeUintVars[_ORIGINAL_ID] = hashId;\\n        } else {\\n            disputeIdByDisputeHash[_hash] = disputeId;\\n            hashId = disputeId;\\n        }\\n        uint256 origID = hashId;\\n        uint256 dispRounds =\\n            disputesById[origID].disputeUintVars[_DISPUTE_ROUNDS] + 1;\\n        disputesById[origID].disputeUintVars[_DISPUTE_ROUNDS] = dispRounds;\\n        disputesById[origID].disputeUintVars[\\n            keccak256(abi.encode(dispRounds))\\n        ] = disputeId;\\n        if (disputeId != origID) {\\n            uint256 lastID =\\n                disputesById[origID].disputeUintVars[\\n                    keccak256(abi.encode(dispRounds - 1))\\n                ];\\n            require(\\n                disputesById[lastID].disputeUintVars[_MIN_EXECUTION_DATE] <=\\n                    block.timestamp,\\n                \\\"Dispute is already open\\\"\\n            );\\n            if (disputesById[lastID].executed) {\\n                require(\\n                    block.timestamp -\\n                        disputesById[lastID].disputeUintVars[_TALLY_DATE] <=\\n                        1 days,\\n                    \\\"Time for voting haven't elapsed\\\"\\n                );\\n            }\\n        }\\n        uint256 _fee;\\n        if (_minerIndex == 2) {\\n            requestDetails[_requestId].apiUintVars[_DISPUTE_COUNT] =\\n                requestDetails[_requestId].apiUintVars[_DISPUTE_COUNT] +\\n                1;\\n            //update dispute fee for this case\\n            _fee =\\n                uints[_STAKE_AMOUNT] *\\n                requestDetails[_requestId].apiUintVars[_DISPUTE_COUNT];\\n        } else {\\n            _fee = uints[_DISPUTE_FEE] * dispRounds;\\n        }\\n\\n        //maps the dispute to the Dispute struct\\n        disputesById[disputeId].hash = _hash;\\n        disputesById[disputeId].isPropFork = false;\\n        disputesById[disputeId].reportedMiner = _miner;\\n        disputesById[disputeId].reportingParty = msg.sender;\\n        disputesById[disputeId].proposedForkAddress = address(0);\\n        disputesById[disputeId].executed = false;\\n        disputesById[disputeId].disputeVotePassed = false;\\n        disputesById[disputeId].tally = 0;\\n\\n        //Saves all the dispute variables for the disputeId\\n        disputesById[disputeId].disputeUintVars[_REQUEST_ID] = _requestId;\\n        disputesById[disputeId].disputeUintVars[_TIMESTAMP] = _timestamp;\\n        disputesById[disputeId].disputeUintVars[_VALUE] = _request\\n            .valuesByTimestamp[_timestamp][_minerIndex];\\n        disputesById[disputeId].disputeUintVars[_MIN_EXECUTION_DATE] =\\n            block.timestamp +\\n            2 days *\\n            dispRounds;\\n        disputesById[disputeId].disputeUintVars[_BLOCK_NUMBER] = block.number;\\n        disputesById[disputeId].disputeUintVars[_MINER_SLOT] = _minerIndex;\\n        disputesById[disputeId].disputeUintVars[_FEE] = _fee;\\n        _doTransfer(msg.sender, address(this), _fee);\\n\\n        //Values are sorted as they come in and the official value is the median of the first five\\n        //So the \\\"official value\\\" miner is always minerIndex==2. If the official value is being\\n        //disputed, it sets its status to inDispute(currentStatus = 3) so that users are made aware it is under dispute\\n        if (_minerIndex == 2) {\\n            _request.inDispute[_timestamp] = true;\\n            _request.finalValues[_timestamp] = 0;\\n        }\\n        stakerDetails[_miner].currentStatus = 3;\\n        emit NewDispute(disputeId, _requestId, _timestamp, _miner);\\n    }\\n\\n    /**\\n     * @dev Allows token holders to vote\\n     * @param _disputeId is the dispute id\\n     * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\\n     */\\n    function vote(uint256 _disputeId, bool _supportsDispute) public {\\n        Dispute storage disp = disputesById[_disputeId];\\n\\n        //Get the voteWeight or the balance of the user at the time/blockNumber the dispute began\\n        uint256 voteWeight =\\n            balanceOfAt(msg.sender, disp.disputeUintVars[_BLOCK_NUMBER]);\\n\\n        //Require that the msg.sender has not voted\\n        require(disp.voted[msg.sender] != true, \\\"Sender has already voted\\\");\\n\\n        //Require that the user had a balance >0 at time/blockNumber the dispute began\\n        require(voteWeight != 0, \\\"User balance is 0\\\");\\n\\n        //ensures miners that are under dispute cannot vote\\n        require(\\n            stakerDetails[msg.sender].currentStatus != 3,\\n            \\\"Miner is under dispute\\\"\\n        );\\n\\n        //Update user voting status to true\\n        disp.voted[msg.sender] = true;\\n\\n        //Update the number of votes for the dispute\\n        disp.disputeUintVars[_NUM_OF_VOTES] += 1;\\n\\n        //If the user supports the dispute increase the tally for the dispute by the voteWeight\\n        //otherwise decrease it\\n        if (_supportsDispute) {\\n            disp.tally = disp.tally.add(int256(voteWeight));\\n        } else {\\n            disp.tally = disp.tally.sub(int256(voteWeight));\\n        }\\n\\n        //Let the network kblock.timestamp the user has voted on the dispute and their casted vote\\n        emit Voted(_disputeId, _supportsDispute, msg.sender, voteWeight);\\n    }\\n\\n    /**\\n     * @dev tallies the votes and locks the stake disbursement(currentStatus = 4) if the vote passes\\n     * @param _disputeId is the dispute id\\n     */\\n    function tallyVotes(uint256 _disputeId) public {\\n        Dispute storage disp = disputesById[_disputeId];\\n        //Ensure this has not already been executed/tallied\\n        require(disp.executed == false, \\\"Dispute has been already executed\\\");\\n        require(\\n            block.timestamp >= disp.disputeUintVars[_MIN_EXECUTION_DATE],\\n            \\\"Time for voting haven't elapsed\\\"\\n        );\\n        require(\\n            disp.reportingParty != address(0),\\n            \\\"reporting Party is address 0\\\"\\n        );\\n        int256 _tally = disp.tally;\\n        if (_tally > 0) {\\n            //Set the dispute state to passed/true\\n            disp.disputeVotePassed = true;\\n        }\\n        //If the vote is not a proposed fork\\n        if (disp.isPropFork == false) {\\n            //Ensure the time for voting has elapsed\\n            StakeInfo storage stakes = stakerDetails[disp.reportedMiner];\\n            //If the vote for disputing a value is successful(disp.tally >0) then unstake the reported\\n            // miner and transfer the stakeAmount and dispute fee to the reporting party\\n            if (stakes.currentStatus == 3) {\\n                stakes.currentStatus = 4;\\n            }\\n        }\\n        disp.disputeUintVars[_TALLY_DATE] = block.timestamp;\\n        disp.executed = true;\\n        emit DisputeVoteTallied(\\n            _disputeId,\\n            _tally,\\n            disp.reportedMiner,\\n            disp.reportingParty,\\n            disp.disputeVotePassed\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows disputer to unlock the dispute fee\\n     * @param _disputeId to unlock fee from\\n     */\\n    function unlockDisputeFee(uint256 _disputeId) public {\\n        uint256 origID = disputeIdByDisputeHash[disputesById[_disputeId].hash];\\n        uint256 lastID =\\n            disputesById[origID].disputeUintVars[\\n                keccak256(\\n                    abi.encode(\\n                        disputesById[origID].disputeUintVars[_DISPUTE_ROUNDS]\\n                    )\\n                )\\n            ];\\n        if (lastID == 0) {\\n            lastID = origID;\\n        }\\n        Dispute storage disp = disputesById[origID];\\n        Dispute storage last = disputesById[lastID];\\n        //disputeRounds is increased by 1 so that the _id is not a negative number when it is the first time a dispute is initiated\\n        uint256 dispRounds = disp.disputeUintVars[_DISPUTE_ROUNDS];\\n        if (dispRounds == 0) {\\n            dispRounds = 1;\\n        }\\n        uint256 _id;\\n        require(disp.disputeUintVars[_PAID] == 0, \\\"already paid out\\\");\\n        require(\\n            block.timestamp - last.disputeUintVars[_TALLY_DATE] > 1 days,\\n            \\\"Time for voting haven't elapsed\\\"\\n        );\\n        StakeInfo storage stakes = stakerDetails[disp.reportedMiner];\\n        disp.disputeUintVars[_PAID] = 1;\\n        if (last.disputeVotePassed == true) {\\n            //Changing the currentStatus and startDate unstakes the reported miner and transfers the stakeAmount\\n            stakes.startDate = block.timestamp - (block.timestamp % 86400);\\n\\n            //Reduce the staker count\\n            uints[_STAKE_COUNT] -= 1;\\n\\n            //Update the minimum dispute fee that is based on the number of stakers\\n            updateMinDisputeFee();\\n            //Decreases the stakerCount since the miner's stake is being slashed\\n            if (stakes.currentStatus == 4) {\\n                stakes.currentStatus = 5;\\n                _doTransfer(\\n                    disp.reportedMiner,\\n                    disp.reportingParty,\\n                    uints[_STAKE_AMOUNT]\\n                );\\n                stakes.currentStatus = 0;\\n            }\\n            for (uint256 i = 0; i < dispRounds; i++) {\\n                _id = disp.disputeUintVars[\\n                    keccak256(abi.encode(dispRounds - i))\\n                ];\\n                if (_id == 0) {\\n                    _id = origID;\\n                }\\n                Dispute storage disp2 = disputesById[_id];\\n                //transfer fee adjusted based on number of miners if the minerIndex is not 2(official value)\\n                _doTransfer(\\n                    address(this),\\n                    disp2.reportingParty,\\n                    disp2.disputeUintVars[_FEE]\\n                );\\n            }\\n        } else {\\n            stakes.currentStatus = 1;\\n            TellorStorage.Request storage _request =\\n                requestDetails[disp.disputeUintVars[_REQUEST_ID]];\\n            if (disp.disputeUintVars[_MINER_SLOT] == 2) {\\n                //note we still don't put timestamp back into array (is this an issue? (shouldn't be))\\n                _request.finalValues[disp.disputeUintVars[_TIMESTAMP]] = disp\\n                    .disputeUintVars[_VALUE];\\n            }\\n            if (_request.inDispute[disp.disputeUintVars[_TIMESTAMP]] == true) {\\n                _request.inDispute[disp.disputeUintVars[_TIMESTAMP]] = false;\\n            }\\n            for (uint256 i = 0; i < dispRounds; i++) {\\n                _id = disp.disputeUintVars[\\n                    keccak256(abi.encode(dispRounds - i))\\n                ];\\n                if (_id != 0) {\\n                    last = disputesById[_id]; //handling if happens during an upgrade\\n                }\\n                _doTransfer(\\n                    address(this),\\n                    last.reportedMiner,\\n                    disputesById[_id].disputeUintVars[_FEE]\\n                );\\n            }\\n        }\\n\\n        if (disp.disputeUintVars[_MINER_SLOT] == 2) {\\n            requestDetails[disp.disputeUintVars[_REQUEST_ID]].apiUintVars[\\n                _DISPUTE_COUNT\\n            ]--;\\n        }\\n    }\\n\\n    /**\\n     * @dev This function updates the minimum dispute fee as a function of the amount\\n     * of staked miners\\n     */\\n    function updateMinDisputeFee() public {\\n        uint256 _stakeAmt = uints[_STAKE_AMOUNT];\\n        uint256 _trgtMiners = uints[_TARGET_MINERS];\\n        uints[_DISPUTE_FEE] = SafeMath.max(\\n            15e18,\\n            (_stakeAmt -\\n                ((_stakeAmt *\\n                    (SafeMath.min(_trgtMiners, uints[_STAKE_COUNT]) * 1000)) /\\n                    _trgtMiners) /\\n                1000)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TellorGetters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.4;\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./TellorStorage.sol\\\";\\r\\nimport \\\"./TellorVariables.sol\\\";\\r\\nimport \\\"./Utilities.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Tellor Getters\\r\\n * @dev Oracle contract with all tellor getter functions\\r\\n */\\r\\ncontract TellorGetters is TellorStorage, TellorVariables, Utilities {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n     * @dev This function tells you if a given challenge has been completed by a given miner\\r\\n     * @param _challenge the challenge to search for\\r\\n     * @param _miner address that you want to know if they solved the challenge\\r\\n     * @return true if the _miner address provided solved the\\r\\n     */\\r\\n    function didMine(bytes32 _challenge, address _miner)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return minersByChallenge[_challenge][_miner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if an address voted in a given dispute\\r\\n     * @param _disputeId to look up\\r\\n     * @param _address to look up\\r\\n     * @return bool of whether or not party voted\\r\\n     */\\r\\n    function didVote(uint256 _disputeId, address _address)\\r\\n        external\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return disputesById[_disputeId].voted[_address];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev allows Tellor to read data from the addressVars mapping\\r\\n     * @param _data is the keccak256(\\\"variable_name\\\") of the variable that is being accessed.\\r\\n     * These are examples of how the variables are saved within other functions:\\r\\n     * addressVars[keccak256(\\\"_owner\\\")]\\r\\n     * addressVars[keccak256(\\\"tellorContract\\\")]\\r\\n     * @return address of the requested variable\\r\\n     */\\r\\n    function getAddressVars(bytes32 _data) external view returns (address) {\\r\\n        return addresses[_data];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets all dispute variables\\r\\n     * @param _disputeId to look up\\r\\n     * @return bytes32 hash of dispute\\r\\n     * bool executed where true if it has been voted on\\r\\n     * bool disputeVotePassed\\r\\n     * bool isPropFork true if the dispute is a proposed fork\\r\\n     * address of reportedMiner\\r\\n     * address of reportingParty\\r\\n     * address of proposedForkAddress\\r\\n     * uint of requestId\\r\\n     * uint of timestamp\\r\\n     * uint of value\\r\\n     * uint of minExecutionDate\\r\\n     * uint of numberOfVotes\\r\\n     * uint of blocknumber\\r\\n     * uint of minerSlot\\r\\n     * uint of quorum\\r\\n     * uint of fee\\r\\n     * int count of the current tally\\r\\n     */\\r\\n    function getAllDisputeVars(uint256 _disputeId)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            bytes32,\\r\\n            bool,\\r\\n            bool,\\r\\n            bool,\\r\\n            address,\\r\\n            address,\\r\\n            address,\\r\\n            uint256[9] memory,\\r\\n            int256\\r\\n        )\\r\\n    {\\r\\n        Dispute storage disp = disputesById[_disputeId];\\r\\n        return (\\r\\n            disp.hash,\\r\\n            disp.executed,\\r\\n            disp.disputeVotePassed,\\r\\n            disp.isPropFork,\\r\\n            disp.reportedMiner,\\r\\n            disp.reportingParty,\\r\\n            disp.proposedForkAddress,\\r\\n            [\\r\\n                disp.disputeUintVars[_REQUEST_ID],\\r\\n                disp.disputeUintVars[_TIMESTAMP],\\r\\n                disp.disputeUintVars[_VALUE],\\r\\n                disp.disputeUintVars[_MIN_EXECUTION_DATE],\\r\\n                disp.disputeUintVars[_NUM_OF_VOTES],\\r\\n                disp.disputeUintVars[_BLOCK_NUMBER],\\r\\n                disp.disputeUintVars[_MINER_SLOT],\\r\\n                disp.disputeUintVars[keccak256(\\\"quorum\\\")],\\r\\n                disp.disputeUintVars[_FEE]\\r\\n            ],\\r\\n            disp.tally\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if a given hash of miner,requestId has been disputed\\r\\n     * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId,_timestamp));\\r\\n     * @return uint disputeId\\r\\n     */\\r\\n    function getDisputeIdByDisputeHash(bytes32 _hash)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return disputeIdByDisputeHash[_hash];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks for uint variables in the disputeUintVars mapping based on the disputeId\\r\\n     * @param _disputeId is the dispute id;\\r\\n     * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\r\\n     * the variables/strings used to save the data in the mapping. The variables names are\\r\\n     * commented out under the disputeUintVars under the Dispute struct\\r\\n     * @return uint value for the bytes32 data submitted\\r\\n     */\\r\\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return disputesById[_disputeId].disputeUintVars[_data];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the a value for the latest timestamp available\\r\\n     * @return value for timestamp of last proof of work submitted\\r\\n     * @return true if the is a timestamp for the lastNewValue\\r\\n     */\\r\\n    function getLastNewValue() external view returns (uint256, bool) {\\r\\n        return (\\r\\n            retrieveData(\\r\\n                requestIdByTimestamp[uints[_TIME_OF_LAST_NEW_VALUE]],\\r\\n                uints[_TIME_OF_LAST_NEW_VALUE]\\r\\n            ),\\r\\n            true\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the a value for the latest timestamp available\\r\\n     * @param _requestId being requested\\r\\n     * @return value for timestamp of last proof of work submitted and if true if it exist or 0 and false if it doesn't\\r\\n     */\\r\\n    function getLastNewValueById(uint256 _requestId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256, bool)\\r\\n    {\\r\\n        Request storage _request = requestDetails[_requestId];\\r\\n        if (_request.requestTimestamps.length != 0) {\\r\\n            return (\\r\\n                retrieveData(\\r\\n                    _requestId,\\r\\n                    _request.requestTimestamps[\\r\\n                        _request.requestTimestamps.length - 1\\r\\n                    ]\\r\\n                ),\\r\\n                true\\r\\n            );\\r\\n        } else {\\r\\n            return (0, false);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets blocknumber for mined timestamp\\r\\n     * @param _requestId to look up\\r\\n     * @param _timestamp is the timestamp to look up blocknumber\\r\\n     * @return uint of the blocknumber which the dispute was mined\\r\\n     */\\r\\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestDetails[_requestId].minedBlockNum[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\r\\n     * @param _requestId to look up\\r\\n     * @param _timestamp is the timestamp to look up miners for\\r\\n     * @return the 5 miners' addresses\\r\\n     */\\r\\n    function getMinersByRequestIdAndTimestamp(\\r\\n        uint256 _requestId,\\r\\n        uint256 _timestamp\\r\\n    ) external view returns (address[5] memory) {\\r\\n        return requestDetails[_requestId].minersByValue[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Counts the number of values that have been submitted for the request\\r\\n     * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\\r\\n     * request so far\\r\\n     * @param _requestId the requestId to look up\\r\\n     * @return uint count of the number of values received for the requestId\\r\\n     */\\r\\n    function getNewValueCountbyRequestId(uint256 _requestId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestDetails[_requestId].requestTimestamps.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for the specified requestQ index\\r\\n     * @param _index to look up in the requestQ array\\r\\n     * @return uint of requestId\\r\\n     */\\r\\n    function getRequestIdByRequestQIndex(uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(_index <= 50, \\\"RequestQ index is above 50\\\");\\r\\n        return requestIdByRequestQIndex[_index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for requestId based on timestamp\\r\\n     * @param _timestamp to check requestId\\r\\n     * @return uint of requestId\\r\\n     */\\r\\n    function getRequestIdByTimestamp(uint256 _timestamp)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestIdByTimestamp[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for the requestQ array\\r\\n     * @return the requestQ array\\r\\n     */\\r\\n    function getRequestQ() public view returns (uint256[51] memory) {\\r\\n        return requestQ;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows access to the uint variables saved in the apiUintVars under the requestDetails struct\\r\\n     * for the requestId specified\\r\\n     * @param _requestId to look up\\r\\n     * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\r\\n     * the variables/strings used to save the data in the mapping. The variables names are\\r\\n     * commented out under the apiUintVars under the requestDetails struct\\r\\n     * @return uint value of the apiUintVars specified in _data for the requestId specified\\r\\n     */\\r\\n    function getRequestUintVars(uint256 _requestId, bytes32 _data)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestDetails[_requestId].apiUintVars[_data];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the API struct variables that are not mappings\\r\\n     * @param _requestId to look up\\r\\n     * @return uint of index in requestQ array\\r\\n     * @return uint of current payout/tip for this requestId\\r\\n     */\\r\\n    function getRequestVars(uint256 _requestId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        Request storage _request = requestDetails[_requestId];\\r\\n        return (\\r\\n            _request.apiUintVars[_REQUEST_Q_POSITION],\\r\\n            _request.apiUintVars[_TOTAL_TIP]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This function allows users to retrieve all information about a staker\\r\\n     * @param _staker address of staker inquiring about\\r\\n     * @return uint current state of staker\\r\\n     * @return uint startDate of staking\\r\\n     */\\r\\n    function getStakerInfo(address _staker)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        return (\\r\\n            stakerDetails[_staker].currentStatus,\\r\\n            stakerDetails[_staker].startDate\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\r\\n     * @param _requestId to look up\\r\\n     * @param _timestamp is the timestamp to look up miners for\\r\\n     * @return address[5] array of 5 addresses of miners that mined the requestId\\r\\n     */\\r\\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[5] memory)\\r\\n    {\\r\\n        return requestDetails[_requestId].valuesByTimestamp[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the timestamp for the value based on their index\\r\\n     * @param _requestID is the requestId to look up\\r\\n     * @param _index is the value index to look up\\r\\n     * @return uint timestamp\\r\\n     */\\r\\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestDetails[_requestID].requestTimestamps[_index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter for the variables saved under the TellorStorageStruct uints variable\\r\\n     * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\")\\r\\n     * where variable_name is the variables/strings used to save the data in the mapping.\\r\\n     * The variables names in the TellorVariables contract\\r\\n     * @return uint of specified variable\\r\\n     */\\r\\n    function getUintVar(bytes32 _data) public view returns (uint256) {\\r\\n        return uints[_data];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\r\\n     * @param _requestId to look up\\r\\n     * @param _timestamp is the timestamp to look up miners for\\r\\n     * @return bool true if requestId/timestamp is under dispute\\r\\n     */\\r\\n    function isInDispute(uint256 _requestId, uint256 _timestamp)\\r\\n        external\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return requestDetails[_requestId].inDispute[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieve value from oracle based on timestamp\\r\\n     * @param _requestId being requested\\r\\n     * @param _timestamp to retrieve data/value from\\r\\n     * @return value for timestamp submitted\\r\\n     */\\r\\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return requestDetails[_requestId].finalValues[_timestamp];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter for the total_supply of oracle tokens\\r\\n     * @return uint total supply\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256) {\\r\\n        return uints[_TOTAL_SUPPLY];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows users to access the token's name\\r\\n     */\\r\\n    function name() external pure returns (string memory) {\\r\\n        return \\\"Tellor Tributes\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows users to access the token's symbol\\r\\n     */\\r\\n    function symbol() external pure returns (string memory) {\\r\\n        return \\\"TRB\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows users to access the number of decimals\\r\\n     */\\r\\n    function decimals() external pure returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for the requestId being mined\\r\\n     * returns the currentChallenge, array of requestIDs, difficulty, and the current Tip of the 5 IDs\\r\\n     */\\r\\n    function getNewCurrentVariables()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            bytes32 _challenge,\\r\\n            uint256[5] memory _requestIds,\\r\\n            uint256 _diff,\\r\\n            uint256 _tip\\r\\n        )\\r\\n    {\\r\\n        for (uint256 i = 0; i < 5; i++) {\\r\\n            _requestIds[i] = currentMiners[i].value;\\r\\n        }\\r\\n        return (\\r\\n            bytesVars[_CURRENT_CHALLENGE],\\r\\n            _requestIds,\\r\\n            uints[_DIFFICULTY],\\r\\n            uints[_CURRENT_TOTAL_TIPS]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for next requestIds on queue/request with highest payouts at time the function is called\\r\\n     */\\r\\n    function getNewVariablesOnDeck()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck)\\r\\n    {\\r\\n        idsOnDeck = getTopRequestIDs();\\r\\n        for (uint256 i = 0; i < 5; i++) {\\r\\n            tipsOnDeck[i] = requestDetails[idsOnDeck[i]].apiUintVars[\\r\\n                _TOTAL_TIP\\r\\n            ];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter function for the top 5 requests with highest payouts. This function is used within the getNewVariablesOnDeck function\\r\\n     */\\r\\n    function getTopRequestIDs()\\r\\n        public\\r\\n        view\\r\\n        returns (uint256[5] memory _requestIds)\\r\\n    {\\r\\n        uint256[5] memory _max;\\r\\n        uint256[5] memory _index;\\r\\n        (_max, _index) = getMax5(requestQ);\\r\\n        for (uint256 i = 0; i < 5; i++) {\\r\\n            if (_max[i] != 0) {\\r\\n                _requestIds[i] = requestIdByRequestQIndex[_index[i]];\\r\\n            } else {\\r\\n                _requestIds[i] = currentMiners[4 - i].value;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Utilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\n//Functions for retrieving min and Max in 51 length array (requestQ)\\n//Taken partly from: https://github.com/modular-network/ethereum-libraries-array-utils/blob/master/contracts/Array256Lib.sol\\n\\ncontract Utilities {\\n    /**\\n     * @dev This is an internal function called by updateOnDeck that gets the top 5 values\\n     * @param data is an array [51] to determine the top 5 values from\\n     * @return max the top 5 values and their index values in the data array\\n     */\\n    function getMax5(uint256[51] memory data)\\n        public\\n        view\\n        returns (uint256[5] memory max, uint256[5] memory maxIndex)\\n    {\\n        uint256 min5 = data[1];\\n        uint256 minI = 0;\\n        for (uint256 j = 0; j < 5; j++) {\\n            max[j] = data[j + 1]; //max[0]=data[1]\\n            maxIndex[j] = j + 1; //maxIndex[0]= 1\\n            if (max[j] < min5) {\\n                min5 = max[j];\\n                minI = j;\\n            }\\n        }\\n        for (uint256 i = 6; i < data.length; i++) {\\n            if (data[i] > min5) {\\n                max[minI] = data[i];\\n                maxIndex[minI] = i;\\n                min5 = data[i];\\n                for (uint256 j = 0; j < 5; j++) {\\n                    if (max[j] < min5) {\\n                        min5 = max[j];\\n                        minI = j;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ITellor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\nabstract contract ITellor {\\n    event NewTellorAddress(address _newTellor);\\n    event NewDispute(\\n        uint256 indexed _disputeId,\\n        uint256 indexed _requestId,\\n        uint256 _timestamp,\\n        address _miner\\n    );\\n    event Voted(\\n        uint256 indexed _disputeID,\\n        bool _position,\\n        address indexed _voter,\\n        uint256 indexed _voteWeight\\n    );\\n    event DisputeVoteTallied(\\n        uint256 indexed _disputeID,\\n        int256 _result,\\n        address indexed _reportedMiner,\\n        address _reportingParty,\\n        bool _active\\n    );\\n    event TipAdded(\\n        address indexed _sender,\\n        uint256 indexed _requestId,\\n        uint256 _tip,\\n        uint256 _totalTips\\n    );\\n    event NewChallenge(\\n        bytes32 indexed _currentChallenge,\\n        uint256[5] _currentRequestId,\\n        uint256 _difficulty,\\n        uint256 _totalTips\\n    );\\n    event NewValue(\\n        uint256[5] _requestId,\\n        uint256 _time,\\n        uint256[5] _value,\\n        uint256 _totalTips,\\n        bytes32 indexed _currentChallenge\\n    );\\n    event NonceSubmitted(\\n        address indexed _miner,\\n        string _nonce,\\n        uint256[5] _requestId,\\n        uint256[5] _value,\\n        bytes32 indexed _currentChallenge\\n    );\\n    event OwnershipTransferred(\\n        address indexed _previousOwner,\\n        address indexed _newOwner\\n    );\\n    event OwnershipProposed(\\n        address indexed _previousOwner,\\n        address indexed _newOwner\\n    );\\n    event NewStake(address indexed _sender); //Emits upon new staker\\n    event StakeWithdrawn(address indexed _sender); //Emits when a staker is now no longer staked\\n    event StakeWithdrawRequested(address indexed _sender); //Emits when a staker begins the 7 day withdraw period\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _spender,\\n        uint256 _value\\n    ); //ERC20 Approval event\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value); //ERC20 Transfer Event\\n\\n    function changeDeity(address _newDeity) external virtual;\\n\\n    function changeTellorContract(address _tellorContract) external virtual;\\n\\n    function allowance(address _user, address _spender)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function allowedToTrade(address _user, uint256 _amount)\\n        external\\n        view\\n        virtual\\n        returns (bool);\\n\\n    function balanceOf(address _user) external view virtual returns (uint256);\\n\\n    function balanceOfAt(address _user, uint256 _blockNumber)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function didMine(bytes32 _challenge, address _miner)\\n        external\\n        view\\n        virtual\\n        returns (bool);\\n\\n    function didVote(uint256 _disputeId, address _address)\\n        external\\n        view\\n        virtual\\n        returns (bool);\\n\\n    function getAddressVars(bytes32 _data)\\n        external\\n        view\\n        virtual\\n        returns (address);\\n\\n    function getAllDisputeVars(uint256 _disputeId)\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes32,\\n            bool,\\n            bool,\\n            bool,\\n            address,\\n            address,\\n            address,\\n            uint256[9] memory,\\n            int256\\n        );\\n\\n    function getCurrentVariables()\\n        external\\n        view\\n        virtual\\n        returns (\\n            bytes32,\\n            uint256,\\n            uint256,\\n            string memory,\\n            uint256,\\n            uint256\\n        );\\n\\n    function getDisputeIdByDisputeHash(bytes32 _hash)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getLastNewValue() external view virtual returns (uint256, bool);\\n\\n    function getLastNewValueById(uint256 _requestId)\\n        external\\n        view\\n        virtual\\n        returns (uint256, bool);\\n\\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getMinersByRequestIdAndTimestamp(\\n        uint256 _requestId,\\n        uint256 _timestamp\\n    ) external view virtual returns (address[5] memory);\\n\\n    function getNewValueCountbyRequestId(uint256 _requestId)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getRequestIdByRequestQIndex(uint256 _index)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getRequestIdByTimestamp(uint256 _timestamp)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getRequestIdByQueryHash(bytes32 _request)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getRequestQ() public view virtual returns (uint256[51] memory);\\n\\n    function getRequestUintVars(uint256 _requestId, bytes32 _data)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getRequestVars(uint256 _requestId)\\n        external\\n        view\\n        virtual\\n        returns (uint256, uint256);\\n\\n    function getStakerInfo(address _staker)\\n        external\\n        view\\n        virtual\\n        returns (uint256, uint256);\\n\\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp)\\n        external\\n        view\\n        virtual\\n        returns (uint256[5] memory);\\n\\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getUintVar(bytes32 _data) public view virtual returns (uint256);\\n\\n    function getVariablesOnDeck()\\n        external\\n        view\\n        virtual\\n        returns (\\n            uint256,\\n            uint256,\\n            string memory\\n        );\\n\\n    function isInDispute(uint256 _requestId, uint256 _timestamp)\\n        external\\n        view\\n        virtual\\n        returns (bool);\\n\\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function totalSupply() external view virtual returns (uint256);\\n\\n    function beginDispute(\\n        uint256 _requestId,\\n        uint256 _timestamp,\\n        uint256 _minerIndex\\n    ) external virtual;\\n\\n    function vote(uint256 _disputeId, bool _supportsDispute) external virtual;\\n\\n    function tallyVotes(uint256 _disputeId) external virtual;\\n\\n    function proposeFork(address _propNewTellorAddress) external virtual;\\n\\n    function addTip(uint256 _requestId, uint256 _tip) external virtual;\\n\\n    function submitMiningSolution(\\n        string calldata _nonce,\\n        uint256[5] calldata _requestId,\\n        uint256[5] calldata _value\\n    ) external virtual;\\n\\n    function proposeOwnership(address payable _pendingOwner) external virtual;\\n\\n    function claimOwnership() external virtual;\\n\\n    function depositStake() external virtual;\\n\\n    function requestStakingWithdraw() external virtual;\\n\\n    function withdrawStake() external virtual;\\n\\n    function approve(address _spender, uint256 _amount)\\n        external\\n        virtual\\n        returns (bool);\\n\\n    function transfer(address _to, uint256 _amount)\\n        external\\n        virtual\\n        returns (bool);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external virtual returns (bool);\\n\\n    function name() external pure virtual returns (string memory);\\n\\n    function symbol() external pure virtual returns (string memory);\\n\\n    function decimals() external pure virtual returns (uint8);\\n\\n    function getNewCurrentVariables()\\n        external\\n        view\\n        virtual\\n        returns (\\n            bytes32 _challenge,\\n            uint256[5] memory _requestIds,\\n            uint256 _difficutly,\\n            uint256 _tip\\n        );\\n\\n    function getTopRequestIDs()\\n        external\\n        view\\n        virtual\\n        returns (uint256[5] memory _requestIds);\\n\\n    function getNewVariablesOnDeck()\\n        external\\n        view\\n        virtual\\n        returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck);\\n\\n    function updateTellor(uint256 _disputeId) external virtual;\\n\\n    function unlockDisputeFee(uint256 _disputeId) external virtual;\\n\\n    //Test Functions\\n    function theLazyCoon(address _address, uint256 _amount) external virtual;\\n\\n    function testSubmitMiningSolution(\\n        string calldata _nonce,\\n        uint256[5] calldata _requestId,\\n        uint256[5] calldata _value\\n    ) external virtual;\\n\\n    function manuallySetDifficulty(uint256 _diff) external virtual {}\\n\\n    function migrate() external {}\\n\\n    function getMax(uint256[51] memory data)\\n        public\\n        view\\n        virtual\\n        returns (uint256 max, uint256 maxIndex);\\n\\n    function getMin(uint256[51] memory data)\\n        public\\n        view\\n        virtual\\n        returns (uint256 min, uint256 minIndex);\\n\\n    function getMax5(uint256[51] memory data)\\n        public\\n        view\\n        virtual\\n        returns (uint256[5] memory max, uint256[5] memory maxIndex);\\n\\n    function changeTellorGetters(address _tGetters) external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\n//Slightly modified SafeMath library - includes a min and max function, removes useless div function\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n\\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (b > 0) {\\n            c = a + b;\\n            assert(c >= a);\\n        } else {\\n            c = a + b;\\n            assert(c <= a);\\n        }\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function max(int256 a, int256 b) internal pure returns (uint256) {\\n        return a > b ? uint256(a) : uint256(b);\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a * b;\\n        assert(a == 0 || c / a == b);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (b > 0) {\\n            c = a - b;\\n            assert(c <= a);\\n        } else {\\n            c = a - b;\\n            assert(c >= a);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TellorTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./TellorStorage.sol\\\";\\nimport \\\"./TellorVariables.sol\\\";\\n\\n/**\\n * @title Tellor Transfer\\n * @dev Contains the methods related to transfers and ERC20, its storage and hashes of tellor variable\\n * that are used to save gas on transactions.\\n */\\ncontract TellorTransfer is TellorStorage, TellorVariables {\\n    using SafeMath for uint256;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /*Functions*/\\n\\n    /**\\n     * @dev Allows for a transfer of tokens to _to\\n     * @param _to The address to send tokens to\\n     * @param _amount The amount of tokens to send\\n     */\\n    function transfer(address _to, uint256 _amount)\\n        public\\n        returns (bool success)\\n    {\\n        _doTransfer(msg.sender, _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Send _amount tokens to _to from _from on the condition it\\n     * is approved by _from\\n     * @param _from The address holding the tokens being transferred\\n     * @param _to The address of the recipient\\n     * @param _amount The amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) public returns (bool success) {\\n        require(\\n            _allowances[_from][msg.sender] >= _amount,\\n            \\\"Allowance is wrong\\\"\\n        );\\n        _allowances[_from][msg.sender] -= _amount;\\n        _doTransfer(_from, _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev This function approves a _spender an _amount of tokens to use\\n     * @param _spender address\\n     * @param _amount amount the spender is being approved for\\n     * @return true if spender approved successfully\\n     */\\n    function approve(address _spender, uint256 _amount) public returns (bool) {\\n        require(\\n            msg.sender != address(0),\\n            \\\"ERC20: approve from the zero address\\\"\\n        );\\n        require(_spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[msg.sender][_spender] = _amount;\\n        emit Approval(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Getter function for remaining spender balance\\n     * @param _user address of party with the balance\\n     * @param _spender address of spender of parties said balance\\n     * @return Returns the remaining allowance of tokens granted to the _spender from the _user\\n     */\\n    function allowance(address _user, address _spender)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _allowances[_user][_spender];\\n    }\\n\\n    /**\\n     * @dev Completes transfers by updating the balances on the current block number\\n     * and ensuring the amount does not contain tokens staked for mining\\n     * @param _from address to transfer from\\n     * @param _to address to transfer to\\n     * @param _amount to transfer\\n     */\\n    function _doTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        require(_amount != 0, \\\"Tried to send non-positive amount\\\");\\n        require(_to != address(0), \\\"Receiver is 0 address\\\");\\n        require(\\n            allowedToTrade(_from, _amount),\\n            \\\"Should have sufficient balance to trade\\\"\\n        );\\n        uint256 previousBalance = balanceOf(_from);\\n        updateBalanceAtNow(_from, previousBalance - _amount);\\n        previousBalance = balanceOf(_to);\\n        require(\\n            previousBalance + _amount >= previousBalance,\\n            \\\"Overflow happened\\\"\\n        ); // Check for overflow\\n        updateBalanceAtNow(_to, previousBalance + _amount);\\n        emit Transfer(_from, _to, _amount);\\n    }\\n\\n    /**\\n     * @dev Helps swap the old Tellor contract Tokens to the new one\\n     * @param _to is the adress to send minted amount to\\n     * @param _amount is the amount of TRB to send\\n     */\\n    function _doMint(address _to, uint256 _amount) internal {\\n        require(_amount != 0, \\\"Tried to mint non-positive amount\\\");\\n        require(_to != address(0), \\\"Receiver is 0 address\\\");\\n        uint256 previousBalance = balanceOf(_to);\\n        require(\\n            previousBalance + _amount >= previousBalance,\\n            \\\"Overflow happened\\\"\\n        ); // Check for overflow\\n        uint256 previousSupply = uints[_TOTAL_SUPPLY];\\n        require(\\n            previousSupply + _amount >= previousSupply,\\n            \\\"Overflow happened\\\"\\n        );\\n        uints[_TOTAL_SUPPLY] += _amount;\\n        updateBalanceAtNow(_to, previousBalance + _amount);\\n        emit Transfer(address(0), _to, _amount);\\n    }\\n\\n    /**\\n     * @dev Helps burn TRB Tokens\\n     * @param _from is the adress to burn or remove TRB amount\\n     * @param _amount is the amount of TRB to burn\\n     */\\n    function _doBurn(address _from, uint256 _amount) internal {\\n        if (_amount == 0) return;\\n        uint256 previousBalance = balanceOf(_from);\\n        require(\\n            previousBalance - _amount <= previousBalance,\\n            \\\"Overflow happened\\\"\\n        ); // Check for overflow\\n        uint256 previousSupply = uints[_TOTAL_SUPPLY];\\n        require(\\n            previousSupply - _amount <= previousSupply,\\n            \\\"Overflow happened\\\"\\n        );\\n        updateBalanceAtNow(_from, previousBalance - _amount);\\n        uints[_TOTAL_SUPPLY] -= _amount;\\n    }\\n\\n    /**\\n     * @dev Gets balance of owner specified\\n     * @param _user is the owner address used to look up the balance\\n     * @return Returns the balance associated with the passed in _user\\n     */\\n    function balanceOf(address _user) public view returns (uint256) {\\n        return balanceOfAt(_user, block.number);\\n    }\\n\\n    /**\\n     * @dev Queries the balance of _user at a specific _blockNumber\\n     * @param _user The address from which the balance will be retrieved\\n     * @param _blockNumber The block number when the balance is queried\\n     * @return The balance at _blockNumber specified\\n     */\\n    function balanceOfAt(address _user, uint256 _blockNumber)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        TellorStorage.Checkpoint[] storage checkpoints = balances[_user];\\n        if (\\n            checkpoints.length == 0 || checkpoints[0].fromBlock > _blockNumber\\n        ) {\\n            return 0;\\n        } else {\\n            if (_blockNumber >= checkpoints[checkpoints.length - 1].fromBlock)\\n                return checkpoints[checkpoints.length - 1].value;\\n            // Binary search of the value in the array\\n            uint256 min = 0;\\n            uint256 max = checkpoints.length - 2;\\n            while (max > min) {\\n                uint256 mid = (max + min + 1) / 2;\\n                if (checkpoints[mid].fromBlock == _blockNumber) {\\n                    return checkpoints[mid].value;\\n                } else if (checkpoints[mid].fromBlock < _blockNumber) {\\n                    min = mid;\\n                } else {\\n                    max = mid - 1;\\n                }\\n            }\\n            return checkpoints[min].value;\\n        }\\n    }\\n\\n    /**\\n     * @dev This function returns whether or not a given user is allowed to trade a given amount\\n     * and removing the staked amount from their balance if they are staked\\n     * @param _user address of user\\n     * @param _amount to check if the user can spend\\n     * @return true if they are allowed to spend the amount being checked\\n     */\\n    function allowedToTrade(address _user, uint256 _amount)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        if (\\n            stakerDetails[_user].currentStatus != 0 &&\\n            stakerDetails[_user].currentStatus < 5\\n        ) {\\n            //Subtracts the stakeAmount from balance if the _user is staked\\n            if (balanceOf(_user) - uints[_STAKE_AMOUNT] >= _amount) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return (balanceOf(_user) >= _amount);\\n    }\\n\\n    /**\\n     * @dev Updates balance for from and to on the current block number via doTransfer\\n     * @param _value is the new balance\\n     */\\n    function updateBalanceAtNow(address _user, uint256 _value) public {\\n        Checkpoint[] storage checkpoints = balances[_user];\\n        if (\\n            checkpoints.length == 0 ||\\n            checkpoints[checkpoints.length - 1].fromBlock != block.number\\n        ) {\\n            checkpoints.push(\\n                TellorStorage.Checkpoint({\\n                    fromBlock: uint128(block.number),\\n                    value: uint128(_value)\\n                })\\n            );\\n        } else {\\n            TellorStorage.Checkpoint storage oldCheckPoint =\\n                checkpoints[checkpoints.length - 1];\\n            oldCheckPoint.value = uint128(_value);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TellorStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\n/**\\n * @title Tellor Oracle Storage Library\\n * @dev Contains all the variables/structs used by Tellor\\n */\\n\\ncontract TellorStorage {\\n    //Internal struct for use in proof-of-work submission\\n    struct Details {\\n        uint256 value;\\n        address miner;\\n    }\\n\\n    struct Dispute {\\n        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\\n        int256 tally; //current tally of votes for - against measure\\n        bool executed; //is the dispute settled\\n        bool disputeVotePassed; //did the vote pass?\\n        bool isPropFork; //true for fork proposal NEW\\n        address reportedMiner; //miner who submitted the 'bad value' will get disputeFee if dispute vote fails\\n        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\\n        address proposedForkAddress; //new fork address (if fork proposal)\\n        mapping(bytes32 => uint256) disputeUintVars;\\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\\n        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\\\"requestId\\\")]\\n        //These are the variables saved in this mapping:\\n        // uint keccak256(\\\"requestId\\\");//apiID of disputed value\\n        // uint keccak256(\\\"timestamp\\\");//timestamp of disputed value\\n        // uint keccak256(\\\"value\\\"); //the value being disputed\\n        // uint keccak256(\\\"minExecutionDate\\\");//7 days from when dispute initialized\\n        // uint keccak256(\\\"numberOfVotes\\\");//the number of parties who have voted on the measure\\n        // uint keccak256(\\\"blockNumber\\\");// the blocknumber for which votes will be calculated from\\n        // uint keccak256(\\\"minerSlot\\\"); //index in dispute array\\n        // uint keccak256(\\\"fee\\\"); //fee paid corresponding to dispute\\n        mapping(address => bool) voted; //mapping of address to whether or not they voted\\n    }\\n\\n    struct StakeInfo {\\n        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\\n        uint256 startDate; //stake start date\\n    }\\n\\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\\n    struct Checkpoint {\\n        uint128 fromBlock; // fromBlock is the block number that the value was generated from\\n        uint128 value; // value is the amount of tokens at a specific block number\\n    }\\n\\n    struct Request {\\n        uint256[] requestTimestamps; //array of all newValueTimestamps requested\\n        mapping(bytes32 => uint256) apiUintVars;\\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\\\"totalTip\\\")]\\n        //These are the variables saved in this mapping:\\n        // uint keccak256(\\\"requestQPosition\\\"); //index in requestQ\\n        // uint keccak256(\\\"totalTip\\\");//bonus portion of payout\\n        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\\n        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\\n        mapping(uint256 => uint256) finalValues;\\n        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\\n        mapping(uint256 => address[5]) minersByValue;\\n        mapping(uint256 => uint256[5]) valuesByTimestamp;\\n    }\\n\\n    uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\\n    uint256[] public newValueTimestamps; //array of all timestamps requested\\n    //Address fields in the Tellor contract are saved the addressVars mapping\\n    //e.g. addressVars[keccak256(\\\"tellorContract\\\")] = address\\n    //These are the variables saved in this mapping:\\n    // address keccak256(\\\"tellorContract\\\");//Tellor address\\n    // address  keccak256(\\\"_owner\\\");//Tellor Owner address\\n    // address  keccak256(\\\"_deity\\\");//Tellor Owner that can do things at will\\n    // address  keccak256(\\\"pending_owner\\\"); // The proposed new owner\\n    //uint fields in the Tellor contract are saved the uintVars mapping\\n    //e.g. uintVars[keccak256(\\\"decimals\\\")] = uint\\n    //These are the variables saved in this mapping:\\n    // keccak256(\\\"decimals\\\");    //18 decimal standard ERC20\\n    // keccak256(\\\"disputeFee\\\");//cost to dispute a mined value\\n    // keccak256(\\\"disputeCount\\\");//totalHistoricalDisputes\\n    // keccak256(\\\"total_supply\\\"); //total_supply of the token in circulation\\n    // keccak256(\\\"stakeAmount\\\");//stakeAmount for miners (we can cut gas if we just hardcoded it in...or should it be variable?)\\n    // keccak256(\\\"stakerCount\\\"); //number of parties currently staked\\n    // keccak256(\\\"timeOfLastNewValue\\\"); // time of last challenge solved\\n    // keccak256(\\\"difficulty\\\"); // Difficulty of current block\\n    // keccak256(\\\"currentTotalTips\\\"); //value of highest api/timestamp PayoutPool\\n    // keccak256(\\\"currentRequestId\\\"); //API being mined--updates with the ApiOnQ Id\\n    // keccak256(\\\"requestCount\\\"); // total number of requests through the system\\n    // keccak256(\\\"slotProgress\\\");//Number of miners who have mined this value so far\\n    // keccak256(\\\"miningReward\\\");//Mining Reward in PoWo tokens given to all miners per value\\n    // keccak256(\\\"timeTarget\\\"); //The time between blocks (mined Oracle values)\\n    // keccak256(\\\"_tblock\\\"); //\\n    // keccak256(\\\"runningTips\\\"); // VAriable to track running tips\\n    // keccak256(\\\"currentReward\\\"); // The current reward\\n    // keccak256(\\\"devShare\\\"); // The amount directed towards th devShare\\n    // keccak256(\\\"currentTotalTips\\\"); //\\n\\n    //This is a boolean that tells you if a given challenge has been completed by a given miner\\n    mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\\n    mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\\n    mapping(uint256 => Dispute) public disputesById; //disputeId=> Dispute details\\n    mapping(bytes32 => uint256) public requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\\n    mapping(bytes32 => uint256) public disputeIdByDisputeHash; //maps a hash to an ID for each dispute\\n    mapping(bytes32 => mapping(address => bool)) public minersByChallenge;\\n    Details[5] public currentMiners; //This struct is for organizing the five mined values to find the median\\n    mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\\n    mapping(uint256 => Request) requestDetails;\\n\\n    mapping(bytes32 => uint256) public uints;\\n    mapping(bytes32 => address) public addresses;\\n    mapping(bytes32 => bytes32) public bytesVars;\\n\\n    //ERC20 storage\\n    mapping(address => Checkpoint[]) public balances;\\n    mapping(address => mapping(address => uint256)) public _allowances;\\n\\n    //Migration storage\\n    mapping(address => bool) public migrated;\\n}\\n\"\r\n    },\r\n    \"contracts/TellorVariables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\n\\n// Helper contract to store hashes of variables\\ncontract TellorVariables {\\n    bytes32 constant _BLOCK_NUMBER =\\n        0x4b4cefd5ced7569ef0d091282b4bca9c52a034c56471a6061afd1bf307a2de7c; //keccak256(\\\"_BLOCK_NUMBER\\\");\\n    bytes32 constant _CURRENT_CHALLENGE =\\n        0xd54702836c9d21d0727ffacc3e39f57c92b5ae0f50177e593bfb5ec66e3de280; //keccak256(\\\"_CURRENT_CHALLENGE\\\");\\n    bytes32 constant _CURRENT_REQUESTID =\\n        0xf5126bb0ac211fbeeac2c0e89d4c02ac8cadb2da1cfb27b53c6c1f4587b48020; //keccak256(\\\"_CURRENT_REQUESTID\\\");\\n    bytes32 constant _CURRENT_REWARD =\\n        0xd415862fd27fb74541e0f6f725b0c0d5b5fa1f22367d9b78ec6f61d97d05d5f8; //keccak256(\\\"_CURRENT_REWARD\\\");\\n    bytes32 constant _CURRENT_TOTAL_TIPS =\\n        0x09659d32f99e50ac728058418d38174fe83a137c455ff1847e6fb8e15f78f77a; //keccak256(\\\"_CURRENT_TOTAL_TIPS\\\");\\n    bytes32 constant _DEITY =\\n        0x5fc094d10c65bc33cc842217b2eccca0191ff24148319da094e540a559898961; //keccak256(\\\"_DEITY\\\");\\n    bytes32 constant _DIFFICULTY =\\n        0xf758978fc1647996a3d9992f611883adc442931dc49488312360acc90601759b; //keccak256(\\\"_DIFFICULTY\\\");\\n    bytes32 constant _DISPUTE_COUNT =\\n        0x310199159a20c50879ffb440b45802138b5b162ec9426720e9dd3ee8bbcdb9d7; //keccak256(\\\"_DISPUTE_COUNT\\\");\\n    bytes32 constant _DISPUTE_FEE =\\n        0x675d2171f68d6f5545d54fb9b1fb61a0e6897e6188ca1cd664e7c9530d91ecfc; //keccak256(\\\"_DISPUTE_FEE\\\");\\n    bytes32 constant _DISPUTE_ROUNDS =\\n        0x6ab2b18aafe78fd59c6a4092015bddd9fcacb8170f72b299074f74d76a91a923; //keccak256(\\\"_DISPUTE_ROUNDS\\\");\\n    bytes32 constant _FEE =\\n        0x1da95f11543c9b03927178e07951795dfc95c7501a9d1cf00e13414ca33bc409; //keccak256(\\\"FEE\\\");\\n    bytes32 constant _MIN_EXECUTION_DATE =\\n        0x46f7d53798d31923f6952572c6a19ad2d1a8238d26649c2f3493a6d69e425d28; //keccak256(\\\"_MIN_EXECUTION_DATE\\\");\\n    bytes32 constant _MINER_SLOT =\\n        0x6de96ee4d33a0617f40a846309c8759048857f51b9d59a12d3c3786d4778883d; //keccak256(\\\"_MINER_SLOT\\\");\\n    bytes32 constant _NUM_OF_VOTES =\\n        0x1da378694063870452ce03b189f48e04c1aa026348e74e6c86e10738514ad2c4; //keccak256(\\\"_NUM_OF_VOTES\\\");\\n    bytes32 constant _OLD_TELLOR =\\n        0x56e0987db9eaec01ed9e0af003a0fd5c062371f9d23722eb4a3ebc74f16ea371; //keccak256(\\\"_OLD_TELLOR\\\");\\n    bytes32 constant _ORIGINAL_ID =\\n        0xed92b4c1e0a9e559a31171d487ecbec963526662038ecfa3a71160bd62fb8733; //keccak256(\\\"_ORIGINAL_ID\\\");\\n    bytes32 constant _OWNER =\\n        0x7a39905194de50bde334d18b76bbb36dddd11641d4d50b470cb837cf3bae5def; //keccak256(\\\"_OWNER\\\");\\n    bytes32 constant _PAID =\\n        0x29169706298d2b6df50a532e958b56426de1465348b93650fca42d456eaec5fc; //keccak256(\\\"_PAID\\\");\\n    bytes32 constant _PENDING_OWNER =\\n        0x7ec081f029b8ac7e2321f6ae8c6a6a517fda8fcbf63cabd63dfffaeaafa56cc0; //keccak256(\\\"_PENDING_OWNER\\\");\\n    bytes32 constant _REQUEST_COUNT =\\n        0x3f8b5616fa9e7f2ce4a868fde15c58b92e77bc1acd6769bf1567629a3dc4c865; //keccak256(\\\"_REQUEST_COUNT\\\");\\n    bytes32 constant _REQUEST_ID =\\n        0x9f47a2659c3d32b749ae717d975e7962959890862423c4318cf86e4ec220291f; //keccak256(\\\"_REQUEST_ID\\\");\\n    bytes32 constant _REQUEST_Q_POSITION =\\n        0xf68d680ab3160f1aa5d9c3a1383c49e3e60bf3c0c031245cbb036f5ce99afaa1; //keccak256(\\\"_REQUEST_Q_POSITION\\\");\\n    bytes32 constant _SLOT_PROGRESS =\\n        0xdfbec46864bc123768f0d134913175d9577a55bb71b9b2595fda21e21f36b082; //keccak256(\\\"_SLOT_PROGRESS\\\");\\n    bytes32 constant _STAKE_AMOUNT =\\n        0x5d9fadfc729fd027e395e5157ef1b53ef9fa4a8f053043c5f159307543e7cc97; //keccak256(\\\"_STAKE_AMOUNT\\\");\\n    bytes32 constant _STAKE_COUNT =\\n        0x10c168823622203e4057b65015ff4d95b4c650b308918e8c92dc32ab5a0a034b; //keccak256(\\\"_STAKE_COUNT\\\");\\n    bytes32 constant _T_BLOCK =\\n        0xf3b93531fa65b3a18680d9ea49df06d96fbd883c4889dc7db866f8b131602dfb; //keccak256(\\\"_T_BLOCK\\\");\\n    bytes32 constant _TALLY_DATE =\\n        0xf9e1ae10923bfc79f52e309baf8c7699edb821f91ef5b5bd07be29545917b3a6; //keccak256(\\\"_TALLY_DATE\\\");\\n    bytes32 constant _TARGET_MINERS =\\n        0x0b8561044b4253c8df1d9ad9f9ce2e0f78e4bd42b2ed8dd2e909e85f750f3bc1; //keccak256(\\\"_TARGET_MINERS\\\");\\n    bytes32 constant _TELLOR_CONTRACT =\\n        0x0f1293c916694ac6af4daa2f866f0448d0c2ce8847074a7896d397c961914a08; //keccak256(\\\"_TELLOR_CONTRACT\\\");\\n    bytes32 constant _TELLOR_GETTERS =\\n        0xabd9bea65759494fe86471c8386762f989e1f2e778949e94efa4a9d1c4b3545a; //keccak256(\\\"_TELLOR_GETTERS\\\");\\n    bytes32 constant _TIME_OF_LAST_NEW_VALUE =\\n        0x2c8b528fbaf48aaf13162a5a0519a7ad5a612da8ff8783465c17e076660a59f1; //keccak256(\\\"_TIME_OF_LAST_NEW_VALUE\\\");\\n    bytes32 constant _TIME_TARGET =\\n        0xd4f87b8d0f3d3b7e665df74631f6100b2695daa0e30e40eeac02172e15a999e1; //keccak256(\\\"_TIME_TARGET\\\");\\n    bytes32 constant _TIMESTAMP =\\n        0x2f9328a9c75282bec25bb04befad06926366736e0030c985108445fa728335e5; //keccak256(\\\"_TIMESTAMP\\\");\\n    bytes32 constant _TOTAL_SUPPLY =\\n        0xe6148e7230ca038d456350e69a91b66968b222bfac9ebfbea6ff0a1fb7380160; //keccak256(\\\"_TOTAL_SUPPLY\\\");\\n    bytes32 constant _TOTAL_TIP =\\n        0x1590276b7f31dd8e2a06f9a92867333eeb3eddbc91e73b9833e3e55d8e34f77d; //keccak256(\\\"_TOTAL_TIP\\\");\\n    bytes32 constant _VALUE =\\n        0x9147231ab14efb72c38117f68521ddef8de64f092c18c69dbfb602ffc4de7f47; //keccak256(\\\"_VALUE\\\");\\n    bytes32 constant _EIP_SLOT =\\n        0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"_result\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reportedMiner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_reportingParty\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"DisputeVoteTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_currentChallenge\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256[5]\",\"name\":\"_currentRequestId\",\"type\":\"uint256[5]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_difficulty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalTips\",\"type\":\"uint256\"}],\"name\":\"NewChallenge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_miner\",\"type\":\"address\"}],\"name\":\"NewDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"NewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[5]\",\"name\":\"_requestId\",\"type\":\"uint256[5]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[5]\",\"name\":\"_value\",\"type\":\"uint256[5]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalTips\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_currentChallenge\",\"type\":\"bytes32\"}],\"name\":\"NewValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_miner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_nonce\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256[5]\",\"name\":\"_requestId\",\"type\":\"uint256[5]\"},{\"indexed\":false,\"internalType\":\"uint256[5]\",\"name\":\"_value\",\"type\":\"uint256[5]\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_currentChallenge\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_slot\",\"type\":\"uint256\"}],\"name\":\"NonceSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"StakeWithdrawRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"StakeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tip\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalTips\",\"type\":\"uint256\"}],\"name\":\"TipAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_disputeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_position\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_voteWeight\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tip\",\"type\":\"uint256\"}],\"name\":\"addTip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"allowedToTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"fromBlock\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minerIndex\",\"type\":\"uint256\"}],\"name\":\"beginDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"bytesVars\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tGetters\",\"type\":\"address\"}],\"name\":\"changeTellorGetters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"disputeIdByDisputeHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"disputesById\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"int256\",\"name\":\"tally\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disputeVotePassed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPropFork\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"reportedMiner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reportingParty\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposedForkAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"migrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minersByChallenge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"newValueTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requestIdByQueryHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestStakingWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_nonce\",\"type\":\"string\"},{\"internalType\":\"uint256[5]\",\"name\":\"_requestIds\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"_values\",\"type\":\"uint256[5]\"}],\"name\":\"submitMiningSolution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"tallyVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"uints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"unlockDisputeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateBalanceAtNow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateMinDisputeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_supportsDispute\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Tellor","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}