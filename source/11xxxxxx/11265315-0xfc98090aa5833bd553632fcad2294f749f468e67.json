{"status":"1","message":"OK","result":[{"SourceCode":"# (c) 2020 Greenwood\r\n# @title Greenwood Core\r\n# @author Greenwood (Attribution: Max Wolff, http://maxcwolff.com/rhoSpec.pdf)\r\n# @notice An automated market maker for cryptocurrency interest rate swaps\r\n\r\ninterface TOKEN:\r\n    def balanceOf(_user: address) -> uint256: view\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n\r\ninterface CALCULATOR:\r\n    def getBorrowIndex() -> uint256: view\r\n    def getBorrowApy() -> uint256: nonpayable\r\n    def getFee(_total_liquidity: int128, _fee_base: int128, _active_collateral: int128, _utilization_inflection: int128, _fee_sensitivity: int128, _utilization_multiplier: int128) -> uint256: view\r\n\r\ninterface SWAP_METRICS:\r\n    def updateMetrics(_swap_type: String[4], _notional: int128, _collateral: int128): nonpayable\r\n\r\nCONTRACT_PRECISION: constant(decimal) = 0.0000000001\r\nDAYS_IN_YEAR: constant(decimal) = 365.0\r\nBLOCKS_PER_DAY: constant(decimal) = 5760.0\r\nDECIMAL_ZERO: constant(decimal) = 0.0\r\nSECONDS_PER_DAY: constant(decimal) = 86400.0\r\nMIN_DEPOSIT_TIME: constant(decimal) = 60.0\r\nETH_PRECISION: constant(decimal) = 1000000000000000000.0\r\n\r\nstruct LiquidityAccount:\r\n    amount: decimal\r\n    lastDepositTime: decimal\r\n    depositSupplyIndex: decimal\r\n\r\nstruct LiquidityAccount128:\r\n    amount: int128\r\n    lastDepositTime: int128\r\n    depositSupplyIndex: int128\r\n\r\nstruct Swap:\r\n    swapType: String[4]\r\n    notional: decimal\r\n    initTime: decimal\r\n    swapRate: decimal\r\n    owner: address\r\n    initIndex: decimal\r\n    userCollateral: decimal\r\n    isClosed: bool\r\n\r\nstruct Swap128:\r\n    notional: int128\r\n    initTime: int128\r\n    swapRate: int128\r\n    initIndex: int128\r\n    userCollateral: int128\r\n    isClosed: bool\r\n\r\nstruct State:\r\n    avgFixedRateReceiving: int128\r\n    avgFixedRatePaying: int128\r\n    totalLiquidity: int128\r\n    fixedToPay: int128\r\n    fixedToReceive: int128\r\n    activeCollateral: int128\r\n    totalDeposits: int128\r\n    swapDuration: int128\r\n    rateFactor: int128\r\n    yOffset: int128\r\n    slopeFactor: int128\r\n    rateFactorSensitivity: int128\r\n    feeBase: int128\r\n    feeSensitivity: int128\r\n    rateRange: int128\r\n    minPayoutRate: int128\r\n    maxPayoutRate: int128\r\n\r\nadmin: address\r\ntokenHandle: TOKEN\r\ncalculatorHandle: CALCULATOR\r\nmetricsHandle: SWAP_METRICS\r\nmantissa: decimal\r\nyOffset: decimal\r\nslopeFactor: decimal\r\nrateFactorSensitivity: decimal\r\nfeeBase: decimal\r\nfeeSensitivity: decimal\r\nrateRange: decimal\r\nutilizationInflection: decimal\r\nutilizationMultiplier: decimal\r\nminPayoutRate: decimal\r\nmaxPayoutRate: decimal\r\nlastCheckpointTime: decimal\r\navgFixedRateReceiving: decimal\r\nnotionalReceivingFixed: decimal\r\navgFixedRatePaying: decimal\r\nnotionalPayingFixed:decimal\r\nnotionalPayingFloat: decimal\r\nlastBorrowIndex: decimal\r\nnotionalReceivingFloat: decimal\r\ntotalLiquidity: decimal\r\nfixedToPay: decimal\r\nfixedToReceive: decimal\r\nsupplyIndex: decimal\r\nnotionalDaysPayingFloat: decimal\r\nnotionalDaysReceivingFloat: decimal\r\nactiveCollateral: decimal\r\nswapDuration: decimal\r\nrateFactor: decimal\r\ntotalDeposits: decimal\r\nisPaused: bool\r\nliquidityAccounts: HashMap[address, LiquidityAccount]\r\nswaps: HashMap[bytes32, Swap]\r\nswapNumbers: public(HashMap[address, uint256])\r\ncloseSwapOverride: bool\r\nclosePeriodInDays: decimal\r\n\r\n@external\r\ndef __init__( \r\n        _admin: address, \r\n        _token_addr:address, \r\n        _calculator_addr: address, \r\n        _metrics_addr: address, \r\n        _mantissa: uint256, \r\n        _swap_duration: uint256, \r\n        _y_offset: uint256, \r\n        _slope_factor: uint256,\r\n        _rate_factor_sensitivity: uint256,\r\n        _fee_base: uint256,\r\n        _fee_sensitivity: uint256,\r\n        _rate_range: uint256,\r\n        _utilization_inflection: uint256,\r\n        _utilization_multiplier: uint256, \r\n        _min_payout_rate: uint256,\r\n        _max_payout_rate: uint256,\r\n        _borrow_index: uint256,\r\n        _close_period: uint256\r\n    ):\r\n\r\n    self.admin = _admin\r\n\r\n    self.tokenHandle = TOKEN(_token_addr)\r\n    self.calculatorHandle = CALCULATOR(_calculator_addr)\r\n    self.metricsHandle = SWAP_METRICS(_metrics_addr)\r\n\r\n    self.mantissa = convert(_mantissa, decimal)\r\n    self.swapDuration = convert(_swap_duration, decimal) / SECONDS_PER_DAY\r\n    self.lastCheckpointTime = convert(block.timestamp, decimal)\r\n    self.yOffset = convert(_y_offset, decimal) * CONTRACT_PRECISION\r\n    self.slopeFactor = convert(_slope_factor, decimal) * CONTRACT_PRECISION\r\n    self.rateFactorSensitivity = convert(_rate_factor_sensitivity, decimal) * CONTRACT_PRECISION\r\n    self.feeBase = convert(_fee_base, decimal) * CONTRACT_PRECISION\r\n    self.feeSensitivity = convert(_fee_sensitivity, decimal) * CONTRACT_PRECISION\r\n    self.rateRange = convert(_rate_range, decimal) * CONTRACT_PRECISION\r\n    self.utilizationInflection = convert(_utilization_inflection, decimal) * CONTRACT_PRECISION\r\n    self.utilizationMultiplier = convert(_utilization_multiplier, decimal) * CONTRACT_PRECISION\r\n    self.minPayoutRate = convert(_min_payout_rate, decimal) * CONTRACT_PRECISION\r\n    self.maxPayoutRate = convert(_max_payout_rate, decimal) * CONTRACT_PRECISION\r\n    self.lastBorrowIndex = convert(_borrow_index, decimal) * CONTRACT_PRECISION\r\n    self.closePeriodInDays = convert(_close_period, decimal) / SECONDS_PER_DAY\r\n    \r\n    self.supplyIndex = 1.0\r\n\r\n@external\r\ndef updateModel(\r\n        _y_offset: uint256,\r\n        _slope_factor:uint256,\r\n        _rate_factor_sensitivity: uint256,\r\n        _fee_base: uint256,\r\n        _fee_sensitivity: uint256,\r\n        _range: uint256,\r\n        _utilization_inflection: uint256,\r\n        _utilization_multiplier: uint256,\r\n        _min_payout_rate: uint256,\r\n        _max_payout_rate:uint256,\r\n        _close_period: uint256,\r\n        _is_paused: bool,\r\n        _close_swap_override: bool\r\n    ):\r\n\r\n    assert msg.sender == self.admin\r\n    \r\n    self.yOffset = convert(_y_offset, decimal) * CONTRACT_PRECISION\r\n    self.slopeFactor = convert(_slope_factor, decimal) * CONTRACT_PRECISION\r\n    self.rateFactorSensitivity = convert(_rate_factor_sensitivity, decimal) * CONTRACT_PRECISION\r\n    self.feeBase = convert(_fee_base, decimal) * CONTRACT_PRECISION\r\n    self.feeSensitivity = convert(_fee_sensitivity, decimal) * CONTRACT_PRECISION\r\n    self.rateRange = convert(_range, decimal) * CONTRACT_PRECISION\r\n    self.utilizationInflection = convert(_utilization_inflection, decimal) * CONTRACT_PRECISION\r\n    self.utilizationMultiplier = convert(_utilization_multiplier, decimal) * CONTRACT_PRECISION\r\n    self.minPayoutRate = convert(_min_payout_rate, decimal) * CONTRACT_PRECISION\r\n    self.maxPayoutRate = convert(_max_payout_rate, decimal) * CONTRACT_PRECISION\r\n    self.closePeriodInDays = convert(_close_period, decimal) / SECONDS_PER_DAY\r\n    self.isPaused = _is_paused\r\n    self.closeSwapOverride = _close_swap_override\r\n\r\n@internal\r\ndef accrueProtocolCashflowAndUpdateActiveCollateral(\r\n        _update_active_collateral: bool\r\n    ):\r\n\r\n    accruedDays: decimal = (convert(block.timestamp, decimal) - self.lastCheckpointTime) / SECONDS_PER_DAY\r\n    newBorrowIndex: decimal = convert(self.calculatorHandle.getBorrowIndex(), decimal) / ETH_PRECISION\r\n\r\n    cachedNotionalReceivingFixed: decimal = self.notionalReceivingFixed\r\n    cachedLastBorrowIndex: decimal = self.lastBorrowIndex\r\n    cachedTotalLiquidity: decimal = self.totalLiquidity\r\n    cachedSupplyIndex: decimal = self.supplyIndex\r\n    cachedNotionalPayingFixed: decimal = self.notionalPayingFixed\r\n    cachedNotionalPayingFloat: decimal = self.notionalPayingFloat\r\n    cachedNotionalReceivingFloat: decimal = self.notionalReceivingFloat\r\n\r\n    fixedReceived: decimal = (self.avgFixedRateReceiving * cachedNotionalReceivingFixed * accruedDays) / DAYS_IN_YEAR\r\n    fixedPaid: decimal = (self.avgFixedRatePaying * cachedNotionalPayingFixed * accruedDays) / DAYS_IN_YEAR\r\n    floatPaid: decimal = cachedNotionalPayingFloat * (newBorrowIndex / cachedLastBorrowIndex - 1.0)\r\n    floatReceived: decimal = cachedNotionalReceivingFloat * (newBorrowIndex / cachedLastBorrowIndex - 1.0)\r\n    profitAccrued: decimal = fixedReceived + floatReceived - fixedPaid - floatPaid\r\n\r\n    if cachedTotalLiquidity == DECIMAL_ZERO:\r\n        profitRate: decimal = DECIMAL_ZERO\r\n        self.supplyIndex = cachedSupplyIndex * (1.0 + profitRate)\r\n    else:\r\n        profitRate: decimal = (profitAccrued / cachedTotalLiquidity)\r\n        self.supplyIndex = cachedSupplyIndex * (1.0 + profitRate)\r\n    \r\n    if profitAccrued != DECIMAL_ZERO:\r\n        self.totalLiquidity = cachedTotalLiquidity + profitAccrued\r\n\r\n    self.fixedToPay -= max(fixedPaid, DECIMAL_ZERO)\r\n    self.fixedToReceive -= max(fixedReceived, DECIMAL_ZERO)\r\n    \r\n    if cachedLastBorrowIndex != DECIMAL_ZERO:\r\n        self.notionalPayingFloat = cachedNotionalPayingFloat * (newBorrowIndex / cachedLastBorrowIndex)\r\n        self.notionalReceivingFloat = cachedNotionalReceivingFloat * (newBorrowIndex / cachedLastBorrowIndex)\r\n    \r\n    if _update_active_collateral == True:\r\n        self.notionalDaysPayingFloat -= max(cachedNotionalReceivingFixed * accruedDays, DECIMAL_ZERO)\r\n        self.notionalDaysReceivingFloat -= max(cachedNotionalPayingFixed * accruedDays, DECIMAL_ZERO)\r\n        minFloatToReceive: decimal = (self.minPayoutRate * self.notionalDaysReceivingFloat) / DAYS_IN_YEAR\r\n        maxFloatToPay: decimal = (self.maxPayoutRate * self.notionalDaysPayingFloat) / DAYS_IN_YEAR\r\n        self.activeCollateral = max(self.fixedToPay + maxFloatToPay - self.fixedToReceive - minFloatToReceive, DECIMAL_ZERO)\r\n\r\n    self.lastBorrowIndex = newBorrowIndex\r\n\r\n@internal\r\ndef getRate(\r\n        _swap_type: String[4], \r\n        _order_notional: uint256\r\n    ) -> uint256:\r\n\r\n    cachedTotalLiquidity: decimal = self.totalLiquidity\r\n\r\n    fee: decimal = convert(self.calculatorHandle.getFee(\r\n        convert(cachedTotalLiquidity / CONTRACT_PRECISION, int128), \r\n        convert(self.feeBase / CONTRACT_PRECISION, int128), \r\n        convert(self.activeCollateral / CONTRACT_PRECISION, int128), \r\n        convert(self.utilizationInflection / CONTRACT_PRECISION, int128), \r\n        convert(self.feeSensitivity / CONTRACT_PRECISION, int128), \r\n        convert(self.utilizationMultiplier / CONTRACT_PRECISION, int128)), decimal) * CONTRACT_PRECISION\r\n\r\n    notionalAmount: decimal = convert(_order_notional, decimal) / self.mantissa\r\n    rateFactorDelta: decimal = DECIMAL_ZERO\r\n\r\n    if cachedTotalLiquidity != DECIMAL_ZERO:\r\n        rateFactorDelta = (notionalAmount * (self.rateFactorSensitivity * self.swapDuration)) / cachedTotalLiquidity\r\n\r\n    if keccak256(_swap_type) == keccak256(\"pFix\"):\r\n        self.rateFactor += rateFactorDelta\r\n    elif keccak256(_swap_type) == keccak256(\"rFix\"):\r\n        self.rateFactor -= rateFactorDelta\r\n        fee = -fee\r\n\r\n    cachedRateFactor: decimal = self.rateFactor\r\n\r\n    return convert(((self.rateRange * cachedRateFactor / (sqrt((cachedRateFactor * cachedRateFactor) + self.slopeFactor))) + self.yOffset + fee) / CONTRACT_PRECISION, uint256)\r\n\r\n@external\r\ndef addLiquidity(\r\n        _deposit_amount: uint256\r\n    ):\r\n\r\n    assert self.isPaused == False\r\n    assert _deposit_amount > 0\r\n\r\n    self.accrueProtocolCashflowAndUpdateActiveCollateral(True)\r\n\r\n    cachedMantissa: decimal = self.mantissa\r\n    cachedSupplyIndex: decimal = self.supplyIndex\r\n    cachedDepositSupplyIndex: decimal = self.liquidityAccounts[msg.sender].depositSupplyIndex\r\n    cachedTimestamp: decimal = convert(block.timestamp, decimal)\r\n\r\n    self.lastCheckpointTime = cachedTimestamp\r\n\r\n    depositDecimal: decimal = convert(_deposit_amount, decimal) / cachedMantissa\r\n    accruedAmount: decimal = DECIMAL_ZERO\r\n\r\n    self.tokenHandle.transferFrom(msg.sender, self, convert(depositDecimal * cachedMantissa, uint256))\r\n    \r\n    if cachedDepositSupplyIndex != DECIMAL_ZERO:\r\n        accruedAmount = max(((self.liquidityAccounts[msg.sender].amount * cachedSupplyIndex) / cachedDepositSupplyIndex), DECIMAL_ZERO)\r\n\r\n    newAccountLiquidity: decimal = depositDecimal + accruedAmount\r\n\r\n    self.liquidityAccounts[msg.sender].amount = newAccountLiquidity\r\n    self.liquidityAccounts[msg.sender].lastDepositTime = cachedTimestamp\r\n    self.liquidityAccounts[msg.sender].depositSupplyIndex = max(cachedSupplyIndex, DECIMAL_ZERO)\r\n    self.totalLiquidity += depositDecimal\r\n    self.totalDeposits += depositDecimal\r\n\r\n@external\r\ndef removeLiquidity(\r\n        _withdraw_amount: uint256\r\n    ):\r\n\r\n    assert _withdraw_amount > 0\r\n    assert convert(block.timestamp, decimal) - self.liquidityAccounts[msg.sender].lastDepositTime >= MIN_DEPOSIT_TIME\r\n    \r\n    self.accrueProtocolCashflowAndUpdateActiveCollateral(True)\r\n    self.lastCheckpointTime = convert(block.timestamp, decimal)\r\n\r\n    cachedSupplyIndex: decimal = self.supplyIndex\r\n    cachedMantissa: decimal = self.mantissa\r\n    cachedTotalLiquidity: decimal = self.totalLiquidity\r\n    cachedDepositSupplyIndex: decimal = self.liquidityAccounts[msg.sender].depositSupplyIndex\r\n\r\n    newAccountValue: decimal = DECIMAL_ZERO\r\n    if cachedDepositSupplyIndex != DECIMAL_ZERO:\r\n        newAccountValue = (self.liquidityAccounts[msg.sender].amount * cachedSupplyIndex) / cachedDepositSupplyIndex\r\n\r\n    withdrawAmount: decimal = DECIMAL_ZERO\r\n    if _withdraw_amount == MAX_UINT256:\r\n        withdrawAmount = newAccountValue\r\n    else:\r\n        withdrawAmount = convert(_withdraw_amount,decimal) / cachedMantissa\r\n    \r\n    assert withdrawAmount <= newAccountValue\r\n    assert cachedTotalLiquidity >= withdrawAmount\r\n    assert cachedTotalLiquidity - withdrawAmount >= self.activeCollateral\r\n\r\n    self.tokenHandle.transfer(msg.sender, convert(withdrawAmount * cachedMantissa, uint256))\r\n\r\n    self.liquidityAccounts[msg.sender].amount = newAccountValue - withdrawAmount\r\n    self.liquidityAccounts[msg.sender].lastDepositTime = convert(block.timestamp, decimal)\r\n    self.liquidityAccounts[msg.sender].depositSupplyIndex = max(cachedSupplyIndex, DECIMAL_ZERO)\r\n    self.totalLiquidity -= withdrawAmount\r\n    self.totalDeposits -= withdrawAmount\r\n\r\n@external\r\ndef openSwap(\r\n        _notional_amount: uint256,\r\n        _swap_type: String[4]\r\n    ):\r\n\r\n    assert self.isPaused == False\r\n    assert _notional_amount > 0\r\n\r\n    self.accrueProtocolCashflowAndUpdateActiveCollateral(True)\r\n\r\n    cachedMantissa: decimal = self.mantissa\r\n    cachedSwapDuration: decimal = self.swapDuration\r\n    cachedTimestamp: decimal = convert(block.timestamp, decimal)\r\n    cachedSwapNumber: uint256 = self.swapNumbers[msg.sender]\r\n\r\n    notionalAmount: decimal = convert(_notional_amount, decimal) / cachedMantissa\r\n    self.lastCheckpointTime = cachedTimestamp\r\n    \r\n    swapFixedRate: decimal = DECIMAL_ZERO\r\n    userCollateral: decimal = DECIMAL_ZERO\r\n    if keccak256(_swap_type) == keccak256(\"pFix\"):\r\n        cachedNotionalReceivingFixed: decimal = self.notionalReceivingFixed\r\n        swapFixedRate = convert(self.getRate(\"pFix\", _notional_amount), decimal) * CONTRACT_PRECISION\r\n        newFixedToReceive: decimal = (swapFixedRate * cachedSwapDuration * notionalAmount) / DAYS_IN_YEAR\r\n        newMaxFloatToPay:decimal = (notionalAmount * self.maxPayoutRate * cachedSwapDuration) / DAYS_IN_YEAR\r\n\r\n        assert self.activeCollateral + newMaxFloatToPay - newFixedToReceive < self.totalLiquidity\r\n\r\n        self.avgFixedRateReceiving = (self.avgFixedRateReceiving * cachedNotionalReceivingFixed + notionalAmount * swapFixedRate) / (cachedNotionalReceivingFixed + notionalAmount)\r\n        self.notionalReceivingFixed = cachedNotionalReceivingFixed + notionalAmount\r\n        self.notionalPayingFloat += notionalAmount\r\n        self.fixedToReceive += newFixedToReceive\r\n        self.notionalDaysPayingFloat += notionalAmount * cachedSwapDuration\r\n\r\n        userCollateral = (notionalAmount * cachedSwapDuration * swapFixedRate) / DAYS_IN_YEAR\r\n\r\n        self.tokenHandle.transferFrom(msg.sender, self, convert(userCollateral * cachedMantissa, uint256))\r\n    elif keccak256(_swap_type) == keccak256(\"rFix\"):\r\n        cachedNotionalPayingFixed: decimal = self.notionalPayingFixed\r\n        swapFixedRate = convert(self.getRate(\"rFix\", _notional_amount), decimal) * CONTRACT_PRECISION\r\n        newFixedToPay: decimal = (swapFixedRate * cachedSwapDuration * notionalAmount) / DAYS_IN_YEAR\r\n        newMinFloatToReceive: decimal = (self.minPayoutRate * cachedSwapDuration * notionalAmount) / DAYS_IN_YEAR\r\n\r\n        assert self.activeCollateral + newFixedToPay - newMinFloatToReceive < self.totalLiquidity\r\n\r\n        self.avgFixedRatePaying = (self.avgFixedRatePaying * cachedNotionalPayingFixed + notionalAmount * swapFixedRate) / (cachedNotionalPayingFixed + notionalAmount)\r\n        self.notionalPayingFixed = cachedNotionalPayingFixed + notionalAmount\r\n        self.notionalReceivingFloat += notionalAmount\r\n        self.fixedToPay += newFixedToPay\r\n        self.notionalDaysReceivingFloat += notionalAmount * cachedSwapDuration\r\n\r\n        userCollateral = (notionalAmount * cachedSwapDuration * self.maxPayoutRate) / DAYS_IN_YEAR\r\n\r\n        self.tokenHandle.transferFrom(msg.sender, self, convert(userCollateral * cachedMantissa, uint256))\r\n\r\n    if keccak256(_swap_type) == keccak256(\"pFix\") or keccak256(_swap_type) == keccak256(\"rFix\"):\r\n        swapKey: bytes32 = keccak256(concat(convert(msg.sender, bytes32), convert(cachedSwapNumber, bytes32)))\r\n\r\n        self.swaps[swapKey].swapType = _swap_type\r\n        self.swaps[swapKey].notional = notionalAmount\r\n        self.swaps[swapKey].initTime = cachedTimestamp\r\n        self.swaps[swapKey].swapRate = swapFixedRate\r\n        self.swaps[swapKey].owner = msg.sender\r\n        self.swaps[swapKey].initIndex = self.lastBorrowIndex\r\n        self.swaps[swapKey].userCollateral = userCollateral\r\n\r\n        self.swapNumbers[msg.sender] = cachedSwapNumber + 1\r\n\r\n        self.metricsHandle.updateMetrics(\r\n            _swap_type,\r\n            convert(notionalAmount / CONTRACT_PRECISION, int128),\r\n            convert(userCollateral / CONTRACT_PRECISION, int128),\r\n        )\r\n\r\n\r\n@external\r\ndef closeSwap(\r\n        _swap_key: bytes32\r\n    ):\r\n\r\n    if self.swaps[_swap_key].isClosed == False:\r\n        self.accrueProtocolCashflowAndUpdateActiveCollateral(True)\r\n\r\n        cachedSwapDuration: decimal = self.swapDuration\r\n        cachedCloseSwapOverride: bool = self.closeSwapOverride\r\n        cachedNotionalReceivingFixed: decimal = self.notionalReceivingFixed\r\n        cachedSwapNotional: decimal = self.swaps[_swap_key].notional\r\n        cachedSwapRate: decimal = self.swaps[_swap_key].swapRate\r\n        cachedSwapType: String[4] = self.swaps[_swap_key].swapType\r\n        cachedSwapUserCollateral: decimal = self.swaps[_swap_key].userCollateral\r\n        cachedSwapInitTime: decimal = self.swaps[_swap_key].initTime\r\n        cachedSwapInitIndex: decimal = self.swaps[_swap_key].initIndex\r\n        cachedNotionalPayingFixed: decimal = self.notionalPayingFixed\r\n        cachedMantissa: decimal = self.mantissa\r\n        cachedMinPayoutRate: decimal = self.minPayoutRate\r\n        cachedTimestamp: decimal = convert(block.timestamp, decimal)\r\n\r\n        newBorrowIndex:decimal = self.lastBorrowIndex\r\n        liquidationEnd: decimal = cachedSwapInitTime + (cachedSwapDuration * SECONDS_PER_DAY) + (self.closePeriodInDays * SECONDS_PER_DAY)\r\n        swapLength: decimal = cachedTimestamp - cachedSwapInitTime\r\n\r\n        if cachedCloseSwapOverride == False:\r\n            assert swapLength / SECONDS_PER_DAY >= cachedSwapDuration\r\n\r\n        lateDays:decimal = (swapLength / SECONDS_PER_DAY) - cachedSwapDuration \r\n\r\n        if keccak256(cachedSwapType) == keccak256(\"pFix\"):\r\n            newNotionalReceiving:decimal = cachedNotionalReceivingFixed - cachedSwapNotional\r\n\r\n            if newNotionalReceiving == DECIMAL_ZERO:\r\n                self.avgFixedRateReceiving = DECIMAL_ZERO\r\n            else:\r\n                self.avgFixedRateReceiving = max(((self.avgFixedRateReceiving * cachedNotionalReceivingFixed - cachedSwapRate * cachedSwapNotional) / newNotionalReceiving), DECIMAL_ZERO)\r\n\r\n            self.notionalReceivingFixed = max(self.notionalReceivingFixed - cachedSwapNotional, DECIMAL_ZERO)\r\n            self.notionalPayingFloat -= max((self.notionalPayingFloat - ((cachedSwapNotional * newBorrowIndex) / cachedSwapInitIndex)), DECIMAL_ZERO)\r\n            self.fixedToReceive = max((self.fixedToReceive + ((cachedSwapNotional * cachedSwapRate * lateDays) / DAYS_IN_YEAR)), DECIMAL_ZERO)\r\n            self.notionalDaysPayingFloat = max((self.notionalDaysPayingFloat + (cachedSwapNotional * lateDays)), DECIMAL_ZERO)\r\n\r\n        elif keccak256(cachedSwapType) == keccak256(\"rFix\"):\r\n            newNotionalPaying:decimal = cachedNotionalPayingFixed - cachedSwapNotional\r\n\r\n            if newNotionalPaying == DECIMAL_ZERO:\r\n                self.avgFixedRatePaying = DECIMAL_ZERO\r\n            else:\r\n                self.avgFixedRatePaying = max(((self.avgFixedRatePaying * cachedNotionalPayingFixed - cachedSwapRate * cachedSwapNotional) / newNotionalPaying), DECIMAL_ZERO)\r\n\r\n            self.notionalPayingFixed = max((self.notionalPayingFixed - cachedSwapNotional), DECIMAL_ZERO)\r\n            self.notionalReceivingFloat = max((self.notionalReceivingFloat - ((cachedSwapNotional * newBorrowIndex) / cachedSwapInitIndex)), DECIMAL_ZERO)\r\n            self.fixedToPay = max((self.fixedToPay + ((cachedSwapNotional * cachedSwapRate * lateDays) / DAYS_IN_YEAR)), DECIMAL_ZERO)\r\n            self.notionalDaysReceivingFloat += max((self.notionalDaysReceivingFloat + (cachedSwapNotional * lateDays)), DECIMAL_ZERO)\r\n\r\n        fixedLeg:decimal = (cachedSwapNotional * cachedSwapRate * cachedSwapDuration) / DAYS_IN_YEAR\r\n        floatLeg: decimal = DECIMAL_ZERO\r\n\r\n        swapFloatRate: decimal = DECIMAL_ZERO\r\n        if newBorrowIndex / cachedSwapInitIndex == 1.0:\r\n            swapFloatRate = convert(self.calculatorHandle.getBorrowApy(), decimal) / ETH_PRECISION\r\n            floatLeg = (cachedSwapNotional * swapFloatRate * cachedSwapDuration) / DAYS_IN_YEAR\r\n        else:\r\n            swapFloatRate = (newBorrowIndex / cachedSwapInitIndex - 1.0)\r\n            floatLeg = cachedSwapNotional * swapFloatRate\r\n\r\n        if cachedTimestamp <= liquidationEnd:\r\n            if keccak256(cachedSwapType) == keccak256(\"pFix\"):\r\n                userProfit:decimal = floatLeg - fixedLeg\r\n                ammCollateral: decimal = (cachedSwapNotional * cachedSwapDuration * self.maxPayoutRate) / DAYS_IN_YEAR\r\n                amountToSend: decimal = DECIMAL_ZERO\r\n\r\n                if userProfit > ammCollateral:\r\n                    amountToSend = ammCollateral\r\n                else:\r\n                    amountToSend = userProfit\r\n\r\n                if cachedCloseSwapOverride == True:\r\n                    self.tokenHandle.transfer(self.swaps[_swap_key].owner, convert(cachedSwapUserCollateral * cachedMantissa, uint256))\r\n                elif (amountToSend + cachedSwapUserCollateral) * cachedMantissa > DECIMAL_ZERO:\r\n                    self.tokenHandle.transfer(self.swaps[_swap_key].owner, convert((amountToSend + cachedSwapUserCollateral) * cachedMantissa, uint256))\r\n\r\n            elif keccak256(cachedSwapType) == keccak256(\"rFix\"):\r\n                if swapFloatRate < cachedMinPayoutRate:\r\n                    floatLeg = (cachedSwapNotional * cachedMinPayoutRate * cachedSwapDuration) / DAYS_IN_YEAR\r\n\r\n                userProfit: decimal = fixedLeg - floatLeg\r\n                ammCollateral: decimal = (cachedSwapNotional * cachedSwapDuration * cachedSwapRate) / DAYS_IN_YEAR\r\n                amountToSend: decimal = DECIMAL_ZERO\r\n\r\n                if userProfit > ammCollateral:\r\n                    amountToSend = ammCollateral\r\n                else:\r\n                    amountToSend = userProfit\r\n\r\n                if cachedCloseSwapOverride == True:\r\n                    self.tokenHandle.transfer(self.swaps[_swap_key].owner, convert(cachedSwapUserCollateral * cachedMantissa, uint256))\r\n                elif ((amountToSend + cachedSwapUserCollateral) * cachedMantissa > DECIMAL_ZERO):\r\n                    self.tokenHandle.transfer(self.swaps[_swap_key].owner, convert((amountToSend + cachedSwapUserCollateral) * cachedMantissa, uint256))\r\n\r\n        self.swaps[_swap_key].isClosed = True\r\n        self.lastCheckpointTime = cachedTimestamp\r\n\r\n@external\r\n@view\r\ndef getState() -> State:\r\n\r\n    return State({\r\n        avgFixedRateReceiving: convert(self.avgFixedRateReceiving / CONTRACT_PRECISION, int128),\r\n        avgFixedRatePaying: convert(self.avgFixedRatePaying / CONTRACT_PRECISION, int128),\r\n        totalLiquidity: convert(self.totalLiquidity / CONTRACT_PRECISION, int128),\r\n        fixedToPay: convert(self.fixedToPay / CONTRACT_PRECISION, int128),\r\n        fixedToReceive: convert(self.fixedToReceive / CONTRACT_PRECISION, int128),\r\n        activeCollateral: convert(self.activeCollateral / CONTRACT_PRECISION, int128),\r\n        totalDeposits: convert(self.totalDeposits / CONTRACT_PRECISION, int128),\r\n        swapDuration: convert(self.swapDuration / CONTRACT_PRECISION, int128),\r\n        rateFactor: convert(self.rateFactor / CONTRACT_PRECISION, int128),\r\n        yOffset: convert(self.yOffset / CONTRACT_PRECISION, int128),\r\n        slopeFactor: convert(self.slopeFactor / CONTRACT_PRECISION, int128),\r\n        rateFactorSensitivity: convert(self.rateFactorSensitivity / CONTRACT_PRECISION, int128),\r\n        feeBase: convert(self.feeBase / CONTRACT_PRECISION, int128),\r\n        feeSensitivity: convert(self.feeSensitivity / CONTRACT_PRECISION, int128),\r\n        rateRange: convert(self.rateRange / CONTRACT_PRECISION, int128),\r\n        minPayoutRate: convert(self.minPayoutRate / CONTRACT_PRECISION, int128),\r\n        maxPayoutRate: convert(self.maxPayoutRate / CONTRACT_PRECISION, int128)\r\n    })\r\n\r\n@external\r\n@view\r\ndef getAccount(\r\n        _liquidity_account: address\r\n    ) -> LiquidityAccount128:\r\n\r\n    return LiquidityAccount128({\r\n        amount: convert(self.liquidityAccounts[_liquidity_account].amount / CONTRACT_PRECISION, int128),\r\n        lastDepositTime: convert(self.liquidityAccounts[_liquidity_account].lastDepositTime / CONTRACT_PRECISION, int128),\r\n        depositSupplyIndex: convert(self.liquidityAccounts[_liquidity_account].depositSupplyIndex / CONTRACT_PRECISION, int128)\r\n    })\r\n\r\n@external\r\n@view\r\ndef getSwap(\r\n        _swap_key: bytes32\r\n    ) -> Swap128:\r\n\r\n    return Swap128({\r\n        notional: convert(self.swaps[_swap_key].notional * self.mantissa, int128),\r\n        initTime: convert(self.swaps[_swap_key].initTime / CONTRACT_PRECISION, int128),\r\n        swapRate: convert(self.swaps[_swap_key].swapRate / CONTRACT_PRECISION, int128),\r\n        initIndex: convert(self.swaps[_swap_key].initIndex / CONTRACT_PRECISION, int128),\r\n        userCollateral: convert(self.swaps[_swap_key].userCollateral / CONTRACT_PRECISION, int128),\r\n        isClosed: self.swaps[_swap_key].isClosed\r\n    })\r\n\r\n@external\r\n@view\r\ndef getSwapType(\r\n        _swap_key: bytes32\r\n    ) -> String[4]:\r\n    \r\n    return self.swaps[_swap_key].swapType","ABI":"[{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_admin\"},{\"type\":\"address\",\"name\":\"_token_addr\"},{\"type\":\"address\",\"name\":\"_calculator_addr\"},{\"type\":\"address\",\"name\":\"_metrics_addr\"},{\"type\":\"uint256\",\"name\":\"_mantissa\"},{\"type\":\"uint256\",\"name\":\"_swap_duration\"},{\"type\":\"uint256\",\"name\":\"_y_offset\"},{\"type\":\"uint256\",\"name\":\"_slope_factor\"},{\"type\":\"uint256\",\"name\":\"_rate_factor_sensitivity\"},{\"type\":\"uint256\",\"name\":\"_fee_base\"},{\"type\":\"uint256\",\"name\":\"_fee_sensitivity\"},{\"type\":\"uint256\",\"name\":\"_rate_range\"},{\"type\":\"uint256\",\"name\":\"_utilization_inflection\"},{\"type\":\"uint256\",\"name\":\"_utilization_multiplier\"},{\"type\":\"uint256\",\"name\":\"_min_payout_rate\"},{\"type\":\"uint256\",\"name\":\"_max_payout_rate\"},{\"type\":\"uint256\",\"name\":\"_borrow_index\"},{\"type\":\"uint256\",\"name\":\"_close_period\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"updateModel\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_y_offset\"},{\"type\":\"uint256\",\"name\":\"_slope_factor\"},{\"type\":\"uint256\",\"name\":\"_rate_factor_sensitivity\"},{\"type\":\"uint256\",\"name\":\"_fee_base\"},{\"type\":\"uint256\",\"name\":\"_fee_sensitivity\"},{\"type\":\"uint256\",\"name\":\"_range\"},{\"type\":\"uint256\",\"name\":\"_utilization_inflection\"},{\"type\":\"uint256\",\"name\":\"_utilization_multiplier\"},{\"type\":\"uint256\",\"name\":\"_min_payout_rate\"},{\"type\":\"uint256\",\"name\":\"_max_payout_rate\"},{\"type\":\"uint256\",\"name\":\"_close_period\"},{\"type\":\"bool\",\"name\":\"_is_paused\"},{\"type\":\"bool\",\"name\":\"_close_swap_override\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":460189},{\"name\":\"addLiquidity\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_deposit_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":597224},{\"name\":\"removeLiquidity\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_withdraw_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":599736},{\"name\":\"openSwap\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_notional_amount\"},{\"type\":\"string\",\"name\":\"_swap_type\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":979986},{\"name\":\"closeSwap\",\"outputs\":[],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"_swap_key\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":658398},{\"name\":\"getState\",\"outputs\":[{\"type\":\"tuple\",\"name\":\"\",\"components\":[{\"type\":\"int128\",\"name\":\"avgFixedRateReceiving\"},{\"type\":\"int128\",\"name\":\"avgFixedRatePaying\"},{\"type\":\"int128\",\"name\":\"totalLiquidity\"},{\"type\":\"int128\",\"name\":\"fixedToPay\"},{\"type\":\"int128\",\"name\":\"fixedToReceive\"},{\"type\":\"int128\",\"name\":\"activeCollateral\"},{\"type\":\"int128\",\"name\":\"totalDeposits\"},{\"type\":\"int128\",\"name\":\"swapDuration\"},{\"type\":\"int128\",\"name\":\"rateFactor\"},{\"type\":\"int128\",\"name\":\"yOffset\"},{\"type\":\"int128\",\"name\":\"slopeFactor\"},{\"type\":\"int128\",\"name\":\"rateFactorSensitivity\"},{\"type\":\"int128\",\"name\":\"feeBase\"},{\"type\":\"int128\",\"name\":\"feeSensitivity\"},{\"type\":\"int128\",\"name\":\"rateRange\"},{\"type\":\"int128\",\"name\":\"minPayoutRate\"},{\"type\":\"int128\",\"name\":\"maxPayoutRate\"}]}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":20500},{\"name\":\"getAccount\",\"outputs\":[{\"type\":\"tuple\",\"name\":\"\",\"components\":[{\"type\":\"int128\",\"name\":\"amount\"},{\"type\":\"int128\",\"name\":\"lastDepositTime\"},{\"type\":\"int128\",\"name\":\"depositSupplyIndex\"}]}],\"inputs\":[{\"type\":\"address\",\"name\":\"_liquidity_account\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":4747},{\"name\":\"getSwap\",\"outputs\":[{\"type\":\"tuple\",\"name\":\"\",\"components\":[{\"type\":\"int128\",\"name\":\"notional\"},{\"type\":\"int128\",\"name\":\"initTime\"},{\"type\":\"int128\",\"name\":\"swapRate\"},{\"type\":\"int128\",\"name\":\"initIndex\"},{\"type\":\"int128\",\"name\":\"userCollateral\"},{\"type\":\"bool\",\"name\":\"isClosed\"}]}],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"_swap_key\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":9506},{\"name\":\"getSwapType\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"_swap_key\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":7063},{\"name\":\"swapNumbers\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1635}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.3","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000e3d5260cd7f8a4207f41c3b2ac87882489f972130000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000e3047997cd548806894ecca7caf6abaeb083e5c700000000000000000000000080900735011e3c8bb27c194948481d80adee2cee0000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000000000000017b52fb200000000000000000000000000000000000000000000000000000004a817c80000000000000000000000000000000000000000000000000000000000000b71b000000000000000000000000000000000000000000000000000000000009896800000000000000000000000000000000000000000000000000000000001c9c380000000000000000000000000000000000000000000000000000000003087050a00000000000000000000000000000000000000000000000000000001a13b860000000000000000000000000000000000000000000000000000000009502f90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004d7c6d000000000000000000000000000000000000000000000000000000000270256aa20000000000000000000000000000000000000000000000000000000000001c20","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}