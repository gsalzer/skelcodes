{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\n\ncontract IERC20 {\n    function balanceOf(\n        address whom\n    )\n    external\n    view\n    returns (uint);\n\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n    public\n    returns (bool);\n\n\n\n    function decimals()\n    external\n    view\n    returns (uint);\n\n\n    function symbol()\n    external\n    view\n    returns (string);\n\n\n    function name()\n    external\n    view\n    returns (string);\n\n\n    function freezeTransfers()\n    external;\n\n\n    function unfreezeTransfers()\n    external;\n}\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITwoKeyEventSource {\n\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n    function isAddressMaintainer(address _maintainer) public view returns (bool);\n    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n    function joined(address _campaign, address _from, address _to) external;\n    function rejected(address _campaign, address _converter) external;\n\n    function convertedAcquisition(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _baseTokens,\n        uint256 _bonusTokens,\n        uint256 _conversionAmount,\n        bool _isFiatConversion,\n        uint _conversionId\n    )\n    external;\n\n    function getTwoKeyDefaultNetworkTaxPercent()\n    public\n    view\n    returns (uint);\n\n    function convertedDonation(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _conversionAmount,\n        uint256 _conversionId\n    )\n    external;\n\n    function executed(\n        address _campaignAddress,\n        address _converterPlasmaAddress,\n        uint _conversionId,\n        uint tokens\n    )\n    external;\n\n    function tokensWithdrawnFromPurchasesHandler(\n        address campaignAddress,\n        uint _conversionID,\n        uint _tokensAmountWithdrawn\n    )\n    external;\n\n    function emitDebtEvent(\n        address _plasmaAddress,\n        uint _amount,\n        bool _isAddition,\n        string _currency\n    )\n    external;\n\n    function emitReceivedTokensToDeepFreezeTokenPool(\n        address _campaignAddress,\n        uint _amountOfTokens\n    )\n    public;\n\n    function emitReceivedTokensAsModerator(\n        address _campaignAddress,\n        uint _amountOfTokens\n    )\n    public;\n\n    function emitDAIReleasedAsIncome(\n        address _campaignContractAddress,\n        uint _amountOfDAI\n    )\n    public;\n\n    function emitEndedBudgetCampaign(\n        address campaignPlasmaAddress,\n        uint contractorLeftover,\n        uint moderatorEarningsDistributed\n    )\n    public;\n\n\n    function emitUserWithdrawnNetworkEarnings(\n        address user,\n        uint amountOfTokens\n    )\n    public;\n\n    function emitRebalancedRewards(\n        uint cycleId,\n        uint difference,\n        string action\n    )\n    public;\n}\n\ncontract ITwoKeyMaintainersRegistry {\n    function checkIsAddressMaintainer(address _sender) public view returns (bool);\n    function checkIsAddressCoreDev(address _sender) public view returns (bool);\n\n    function addMaintainers(address [] _maintainers) public;\n    function addCoreDevs(address [] _coreDevs) public;\n    function removeMaintainers(address [] _maintainers) public;\n    function removeCoreDevs(address [] _coreDevs) public;\n}\n\ncontract ITwoKeyParticipationPaymentsManager {\n    function transferTokensFromParticipationMiningPool(\n        uint amountOfTokens\n    )\n    public;\n}\n\ncontract ITwoKeyRegistry {\n    function checkIfUserExists(address _userAddress) public view returns (bool);\n    function getUserData(address _user) public view returns (bytes32,bytes32,bytes32);\n}\n\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestCampaignApprovedVersion(string campaignType) public view returns (string);\n}\n\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    * @param contractName is the name of the contract we added new version\n    */\n    event VersionAdded(string version, address implementation, string contractName);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ncontract ITwoKeyParticipationMiningPoolStorage is IStructuredStorage {\n\n}\n\nlibrary Call {\n    function params0(address c, bytes _method) public view returns (uint answer) {\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n        //    dc = c;\n        bytes4 sig = bytes4(keccak256(_method));\n        assembly {\n        // move pointer to free memory spot\n            let ptr := mload(0x40)\n        // put function sig at memory spot\n            mstore(ptr,sig)\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n            15000, // gas limit\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n            0, // not transfer any ether (comment if using staticcall)\n            ptr, // Inputs are stored at location ptr\n            0x04, // Inputs are 0 bytes long\n            ptr,  //Store output over input\n            0x20) //Outputs are 1 bytes long\n\n            if eq(result, 0) {\n                revert(0, 0)\n            }\n\n            answer := mload(ptr) // Assign output to answer var\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n        }\n    }\n\n    function params1(address c, bytes _method, uint _val) public view returns (uint answer) {\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n        //    dc = c;\n        bytes4 sig = bytes4(keccak256(_method));\n        assembly {\n        // move pointer to free memory spot\n            let ptr := mload(0x40)\n        // put function sig at memory spot\n            mstore(ptr,sig)\n        // append argument after function sig\n            mstore(add(ptr,0x04), _val)\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n            15000, // gas limit\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n            0, // not transfer any ether (comment if using staticcall)\n            ptr, // Inputs are stored at location ptr\n            0x24, // Inputs are 0 bytes long\n            ptr,  //Store output over input\n            0x20) //Outputs are 1 bytes long\n\n            if eq(result, 0) {\n                revert(0, 0)\n            }\n\n            answer := mload(ptr) // Assign output to answer var\n            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space\n        }\n    }\n\n    function params2(address c, bytes _method, uint _val1, uint _val2) public view returns (uint answer) {\n        // https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c\n        //    dc = c;\n        bytes4 sig = bytes4(keccak256(_method));\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n            // put function sig at memory spot\n            mstore(ptr,sig)\n            // append argument after function sig\n            mstore(add(ptr,0x04), _val1)\n            mstore(add(ptr,0x24), _val2)\n\n            let result := call(  // use WARNING because this should be staticcall BUT geth crash!\n            15000, // gas limit\n            c, // sload(dc_slot),  // to addr. append var to _slot to access storage variable\n            0, // not transfer any ether (comment if using staticcall)\n            ptr, // Inputs are stored at location ptr\n            0x44, // Inputs are 4 bytes for signature and 2 uint256\n            ptr,  //Store output over input\n            0x20) //Outputs are 1 uint long\n\n            answer := mload(ptr) // Assign output to answer var\n            mstore(0x40,add(ptr,0x20)) // Set storage pointer to new space\n        }\n    }\n\n    function loadAddress(bytes sig, uint idx) public pure returns (address) {\n        address influencer;\n        idx += 20;\n        assembly\n        {\n            influencer := mload(add(sig, idx))\n        }\n        return influencer;\n    }\n\n    function loadUint8(bytes sig, uint idx) public pure returns (uint8) {\n        uint8 weight;\n        idx += 1;\n        assembly\n        {\n            weight := mload(add(sig, idx))\n        }\n        return weight;\n    }\n\n\n    function recoverHash(bytes32 hash, bytes sig, uint idx) public pure returns (address) {\n        // same as recoverHash in utils/sign.js\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        require (sig.length >= 65+idx, 'bad signature length');\n        idx += 32;\n        bytes32 r;\n        assembly\n        {\n            r := mload(add(sig, idx))\n        }\n\n        idx += 32;\n        bytes32 s;\n        assembly\n        {\n            s := mload(add(sig, idx))\n        }\n\n        idx += 1;\n        uint8 v;\n        assembly\n        {\n            v := mload(add(sig, idx))\n        }\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n            v -= 32;\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\n            hash = keccak256(abi.encodePacked(prefix, hash));\n        }\n        if (v <= 1) v += 27;\n        require(v==27 || v==28,'bad sig v');\n        //https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol#L57\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'bad sig s');\n        return ecrecover(hash, v, r, s);\n\n    }\n\n    function recoverSigMemory(bytes sig) private pure returns (address[], address[], uint8[], uint[], uint) {\n        uint8 version = loadUint8(sig, 0);\n        uint msg_len = (version == 1) ? 1+65+20 : 1+20+20;\n        uint n_influencers = (sig.length-21) / (65+msg_len);\n        uint8[] memory weights = new uint8[](n_influencers);\n        address[] memory keys = new address[](n_influencers);\n        if ((sig.length-21) % (65+msg_len) > 0) {\n            n_influencers++;\n        }\n        address[] memory influencers = new address[](n_influencers);\n        uint[] memory offsets = new uint[](n_influencers);\n\n        return (influencers, keys, weights, offsets, msg_len);\n    }\n\n    function recoverSigParts(bytes sig, address last_address) private pure returns (address[], address[], uint8[], uint[]) {\n        // sig structure:\n        // 1 byte version 0 or 1\n        // 20 bytes are the address of the contractor or the influencer who created sig.\n        //  this is the \"anchor\" of the link\n        //  It must have a public key aleady stored for it in public_link_key\n        // Begining of a loop on steps in the link:\n        // * 65 bytes are step-signature using the secret from previous step\n        // * message of the step that is going to be hashed and used to compute the above step-signature.\n        //   message length depend on version 41 (version 0) or 86 (version 1):\n        //   * 1 byte cut (percentage) each influencer takes from the bounty. the cut is stored in influencer2cut or weight for voting\n        //   * 20 bytes address of influencer (version 0) or 65 bytes of signature of cut using the influencer address to sign\n        //   * 20 bytes public key of the last secret\n        // In the last step the message can be optional. If it is missing the message used is the address of the sender\n        uint idx = 0;\n        uint msg_len;\n        uint8[] memory weights;\n        address[] memory keys;\n        address[] memory influencers;\n        uint[] memory offsets;\n        (influencers, keys, weights, offsets, msg_len) = recoverSigMemory(sig);\n        idx += 1;  // skip version\n\n        idx += 20; // skip old_address which should be read by the caller in order to get old_key\n        uint count_influencers = 0;\n\n        while (idx + 65 <= sig.length) {\n            offsets[count_influencers] = idx;\n            idx += 65;  // idx was increased by 65 for the signature at the begining which we will process later\n\n            if (idx + msg_len <= sig.length) {  // its  a < and not a <= because we dont want this to be the final iteration for the converter\n                weights[count_influencers] = loadUint8(sig, idx);\n                require(weights[count_influencers] > 0,'weight not defined (1..255)');  // 255 are used to indicate default (equal part) behaviour\n                idx++;\n\n\n                if (msg_len == 41)  // 1+20+20 version 0\n                {\n                    influencers[count_influencers] = loadAddress(sig, idx);\n                    idx += 20;\n                    keys[count_influencers] = loadAddress(sig, idx);\n                    idx += 20;\n                } else if (msg_len == 86)  // 1+65+20 version 1\n                {\n                    keys[count_influencers] = loadAddress(sig, idx+65);\n                    influencers[count_influencers] = recoverHash(\n                        keccak256(\n                            abi.encodePacked(\n                                keccak256(abi.encodePacked(\"bytes binding to weight\",\"bytes binding to public\")),\n                                keccak256(abi.encodePacked(weights[count_influencers],keys[count_influencers]))\n                            )\n                        ),sig,idx);\n                    idx += 65;\n                    idx += 20;\n                }\n\n            } else {\n                // handle short signatures generated with free_take\n                influencers[count_influencers] = last_address;\n            }\n            count_influencers++;\n        }\n        require(idx == sig.length,'illegal message size');\n\n        return (influencers, keys, weights, offsets);\n    }\n\n    function recoverSig(bytes sig, address old_key, address last_address) public pure returns (address[], address[], uint8[]) {\n        // validate sig AND\n        // recover the information from the signature: influencers, public_link_keys, weights/cuts\n        // influencers may have one more address than the keys and weights arrays\n        //\n        require(old_key != address(0),'no public link key');\n\n        address[] memory influencers;\n        address[] memory keys;\n        uint8[] memory weights;\n        uint[] memory offsets;\n        (influencers, keys, weights, offsets) = recoverSigParts(sig, last_address);\n\n        // check if we received a valid signature\n        for(uint i = 0; i < influencers.length; i++) {\n            if (i < weights.length) {\n                require (recoverHash(keccak256(abi.encodePacked(weights[i], keys[i], influencers[i])),sig,offsets[i]) == old_key, 'illegal signature');\n                old_key = keys[i];\n            } else {\n                // signed message for the last step is the address of the converter\n                require (recoverHash(keccak256(abi.encodePacked(influencers[i])),sig,offsets[i]) == old_key, 'illegal last signature');\n            }\n        }\n\n        return (influencers, keys, weights);\n    }\n}\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\ncontract ITwoKeySingletonUtils {\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    // Modifier to restrict method calls only to maintainers\n    modifier onlyMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressMaintainer(msg.sender));\n        _;\n    }\n\n    /**\n     * @notice Function to get any singleton contract proxy address from TwoKeySingletonRegistry contract\n     * @param contractName is the name of the contract we're looking for\n     */\n    function getAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getContractProxyAddress(contractName);\n    }\n\n    function getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getNonUpgradableContractAddress(contractName);\n    }\n}\n\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\n\ncontract TokenPool is Upgradeable, ITwoKeySingletonUtils {\n\n    bool initialized = false;\n\n    string constant _twoKeyAdmin = \"TwoKeyAdmin\";\n    string constant _twoKeyEconomy = \"TwoKeyEconomy\";\n\n    modifier onlyTwoKeyAdmin {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(_twoKeyAdmin);\n        require(msg.sender == twoKeyAdmin);\n        _;\n    }\n\n    /**\n     * @notice Function to retrieve the balance of tokens on the contract\n     */\n    function getContractBalance()\n    public\n    view\n    returns (uint)\n    {\n        address twoKeyEconomy = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy);\n        return IERC20(twoKeyEconomy).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Function to transfer tokens\n     */\n    function transferTokens(\n        address receiver,\n        uint amount\n    )\n    internal\n    {\n        address twoKeyEconomy = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy);\n        IERC20(twoKeyEconomy).transfer(receiver,amount);\n    }\n\n}\n\ncontract TwoKeyParticipationMiningPool is TokenPool {\n\n    using SafeMath for *;\n    using Call for *;\n\n    /**\n     * Constant keys for storage contract\n     */\n    string constant _isAddressWhitelisted = \"isAddressWhitelisted\";\n    string constant _epochInsideYear = \"epochInsideYear\";\n    string constant _isExistingSignature = \"isExistingSignature\";\n    string constant _dateStartingCountingMonths = \"dateStartingCountingMonths\";\n\n    // Initial amount of tokens is 120M\n    uint constant public initialAmountOfTokens = 120 * (1e6) * (1e18);\n    // 1M tokens monthly allowance\n    uint constant public monthlyTransferAllowance = 1 * (1e6) * (1e18);\n\n    string constant _signatoryAddress = \"signatoryAddress\";\n    string constant _twoKeyParticipationsManager = \"TwoKeyParticipationPaymentsManager\";\n\n    /**\n     * Pointer to it's proxy storage contract\n     */\n    ITwoKeyParticipationMiningPoolStorage public PROXY_STORAGE_CONTRACT;\n\n    /**\n     * @notice Modifier to restrict calls only to TwoKeyAdmin or\n     * some of whitelisted addresses inside this contract\n     */\n    modifier onlyTwoKeyAdminOrWhitelistedAddress {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(_twoKeyAdmin);\n        require(msg.sender == twoKeyAdmin || isAddressWhitelisted(msg.sender));\n        _;\n    }\n\n    modifier onlyTwoKeyCongress {\n        address twoKeyCongress = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"TwoKeyCongress\");\n        require(msg.sender == twoKeyCongress);\n        _;\n    }\n\n    function setInitialParams(\n        address twoKeySingletonesRegistry,\n        address _proxyStorage\n    )\n    external\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = twoKeySingletonesRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyParticipationMiningPoolStorage(_proxyStorage);\n\n        initialized = true;\n    }\n\n    function setBool(\n        bytes32 key,\n        bool value\n    )\n    internal\n    {\n        PROXY_STORAGE_CONTRACT.setBool(key,value);\n    }\n\n    function getBool(\n        bytes32 key\n    )\n    internal\n    view\n    returns (bool)\n    {\n        return PROXY_STORAGE_CONTRACT.getBool(key);\n    }\n\n\n    // Internal wrapper method to manipulate storage contract\n    function setUint(\n        bytes32 key,\n        uint value\n    )\n    internal\n    {\n        PROXY_STORAGE_CONTRACT.setUint(key, value);\n    }\n\n    // Internal wrapper method to manipulate storage contract\n    function getUint(\n        bytes32 key\n    )\n    internal\n    view\n    returns (uint)\n    {\n        return PROXY_STORAGE_CONTRACT.getUint(key);\n    }\n\n    function setSignatureIsExisting(\n        bytes signature\n    )\n    internal\n    {\n        setBool(keccak256(_isExistingSignature,signature), true);\n    }\n\n    function isMaintainer(\n        address _address\n    )\n    internal\n    view\n    returns (bool)\n    {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        return ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressMaintainer(_address);\n    }\n\n\n    /**\n     * @notice          Function where congress can set signatory address\n     *                  and that's the only address eligible to sign the rewards messages\n     * @param           signatoryAddress is the address which will be used to sign rewards\n     */\n    function setSignatoryAddress(\n        address signatoryAddress\n    )\n    public\n    onlyTwoKeyCongress\n    {\n        PROXY_STORAGE_CONTRACT.setAddress(\n            keccak256(_signatoryAddress),\n            signatoryAddress\n        );\n    }\n\n\n    /**\n     * @notice Function which can only be called by TwoKeyAdmin contract\n     * to add new whitelisted addresses to the contract. Whitelisted address\n     * can send tokens out of this contract\n     * @param _newWhitelistedAddress is the new whitelisted address we want to add\n     */\n    function addWhitelistedAddress(\n        address _newWhitelistedAddress\n    )\n    public\n    onlyTwoKeyAdmin\n    {\n        bytes32 keyHash = keccak256(_isAddressWhitelisted,_newWhitelistedAddress);\n        PROXY_STORAGE_CONTRACT.setBool(keyHash, true);\n    }\n\n\n    /**\n     * @notice Function which can only be called by TwoKeyAdmin contract\n     * to remove any whitelisted address from the contract.\n     * @param _addressToBeRemovedFromWhitelist is the new whitelisted address we want to remove\n     */\n    function removeWhitelistedAddress(\n        address _addressToBeRemovedFromWhitelist\n    )\n    public\n    onlyTwoKeyAdmin\n    {\n        bytes32 keyHash = keccak256(_isAddressWhitelisted, _addressToBeRemovedFromWhitelist);\n        PROXY_STORAGE_CONTRACT.setBool(keyHash, false);\n    }\n\n\n    /**\n     * @notice          Function where maintainer can set withdrawal parameters\n     * @param           dateStartingCountingMonths is the date (unix timestamp) from which\n     *                  the tokens are getting unlocked\n     */\n    function setWithdrawalParameters(\n        uint dateStartingCountingMonths\n    )\n    public\n    onlyMaintainer\n    {\n        // Require that this function can be called only once\n        require(getUint(keccak256(_dateStartingCountingMonths)) == 0);\n\n        // Set date when counting months starts\n        setUint(\n            keccak256(_dateStartingCountingMonths),\n            dateStartingCountingMonths\n        );\n    }\n\n\n    /**\n     * @notice Function which does transfer with special requirements with annual limit\n     * @param amountOfTokens is the amount of tokens sent\n     * @dev Only TwoKeyAdmin or Whitelisted address contract can issue this call\n     */\n    function transferTokensToAddress(\n        uint amountOfTokens\n    )\n    public\n    onlyTwoKeyAdminOrWhitelistedAddress\n    {\n        // Assert that amount of tokens to be withdrawn is less than amount of tokens unlocked\n        require(amountOfTokens < getAmountOfTokensUnlockedForWithdrawal(block.timestamp));\n\n        //We're always sending tokens to ParticipationPaymentsManager\n        address receiver = getAddressFromTwoKeySingletonRegistry(_twoKeyParticipationsManager);\n\n        // Transfer the tokens\n        super.transferTokens(receiver,amountOfTokens);\n\n        //Alert that tokens have been transferred\n        ITwoKeyParticipationPaymentsManager(receiver).transferTokensFromParticipationMiningPool(\n            amountOfTokens\n        );\n\n    }\n\n\n    /**\n     * @notice          Function where user can come with signature taken on plasma and\n     *                  withdraw tokens he has earned\n     * @param           signature is the signature created by signatory address for withdrawal\n     * @param           amountOfTokens is the exact amount of tokens signed inside this signature\n     */\n    function withdrawTokensWithSignature(\n        bytes signature,\n        uint amountOfTokens\n    )\n    public\n    {\n        // Assert that amount of tokens to be withdrawn is less than amount of tokens unlocked\n        require(amountOfTokens < getAmountOfTokensUnlockedForWithdrawal(block.timestamp));\n\n        // recover signer of signature\n        address messageSigner = recoverSignature(\n            msg.sender,\n            amountOfTokens,\n            signature\n        );\n\n        // Assert that this signature is created by signatory address\n        require(getSignatoryAddress() == messageSigner);\n\n        // First check if this signature is used\n        require(isExistingSignature(signature) == false);\n\n        // Set that signature is existing and can't be used anymore\n        setSignatureIsExisting(signature);\n\n        // Emit event that user have withdrawn his network earnings\n        ITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\")).emitUserWithdrawnNetworkEarnings(\n            msg.sender,\n            amountOfTokens\n        );\n\n        // Transfer ERC20 tokens from pool to user\n        super.transferTokens(msg.sender, amountOfTokens);\n    }\n\n\n    /**\n     * @notice Function to check if the selected address is whitelisted\n     * @param _address is the address we want to get this information\n     * @return result of address being whitelisted\n     */\n    function isAddressWhitelisted(\n        address _address\n    )\n    public\n    view\n    returns (bool)\n    {\n        bytes32 keyHash = keccak256(_isAddressWhitelisted, _address);\n        return PROXY_STORAGE_CONTRACT.getBool(keyHash);\n    }\n\n\n    /**\n     * @notice          Function to calculate amount of tokens available to be withdrawn\n     *                  at current moment which will take care about monthly allowances\n     * @param           timestamp is the timestamp of withdrawal\n     */\n    function getAmountOfTokensUnlockedForWithdrawal(\n        uint timestamp\n    )\n    public\n    view\n    returns (uint)\n    {\n        uint dateStartedCountingMonths = getDateStartingCountingMonths();\n\n        // We do sub here mostly because of underflow\n        uint totalTimePassedFromUnlockingDay = timestamp.sub(dateStartedCountingMonths);\n\n        // Calculate total amount of tokens being unlocked by now\n        uint totalUnlockedByNow = ((totalTimePassedFromUnlockingDay) / (30 days) + 1) * monthlyTransferAllowance;\n\n        // Get total amount already transferred\n        uint totalTokensTransferedByNow = getTotalAmountOfTokensTransfered();\n\n        // Return tokens available at this moment\n        return (totalUnlockedByNow.sub(totalTokensTransferedByNow));\n    }\n\n\n    /**\n     * @notice          Function where maintainer can check who signed the message\n     * @param           userAddress is the address of user for who we signed message\n     * @param           amountOfTokens is the amount of pending rewards user wants to claim\n     * @param           signature is the signature created by maintainer\n     */\n    function recoverSignature(\n        address userAddress,\n        uint amountOfTokens,\n        bytes signature\n    )\n    public\n    view\n    returns (address)\n    {\n        // Generate hash\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                keccak256(abi.encodePacked('bytes binding user rewards')),\n                keccak256(abi.encodePacked(userAddress,amountOfTokens))\n            )\n        );\n\n        // Recover signer message from signature\n        return Call.recoverHash(hash,signature,0);\n    }\n\n\n    /**\n     * @notice          Function to check if signature is already existing,\n                        means that is has been used, and can't be used anymore\n     * @param           signature is the signature created by maintainer\n     */\n    function isExistingSignature(\n        bytes signature\n    )\n    public\n    view\n    returns (bool)\n    {\n        return getBool(keccak256(_isExistingSignature,signature));\n    }\n\n\n    /**\n     * @notice          Function to get total amount of tokens transfered by now\n     */\n    function getTotalAmountOfTokensTransfered()\n    public\n    view\n    returns (uint)\n    {\n        // Sub from initial amount of tokens current balance\n        return initialAmountOfTokens.sub(\n            IERC20(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy)).balanceOf(address(this))\n        );\n    }\n\n\n    /**\n     * @notice          Function to get the first date from which the time started to unlock\n     */\n    function getDateStartingCountingMonths()\n    public\n    view\n    returns (uint)\n    {\n        return getUint(keccak256(_dateStartingCountingMonths));\n    }\n\n\n    /**\n     * @notice          Function to get how many tokens are getting unlocked every month\n     */\n    function getMonthlyTransferAllowance()\n    public\n    view\n    returns (uint)\n    {\n        return monthlyTransferAllowance;\n    }\n\n    /**\n     * @notice          Function to fetch signatory address\n     */\n    function getSignatoryAddress()\n    public\n    view\n    returns (address)\n    {\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(_signatoryAddress));\n    }\n}\n\n","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getTotalAmountOfTokensTransfered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"twoKeySingletonesRegistry\",\"type\":\"address\"},{\"name\":\"_proxyStorage\",\"type\":\"address\"}],\"name\":\"setInitialParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signatoryAddress\",\"type\":\"address\"}],\"name\":\"setSignatoryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROXY_STORAGE_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dateStartingCountingMonths\",\"type\":\"uint256\"}],\"name\":\"setWithdrawalParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isAddressWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDateStartingCountingMonths\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getAmountOfTokensUnlockedForWithdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWhitelistedAddress\",\"type\":\"address\"}],\"name\":\"addWhitelistedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"},{\"name\":\"amountOfTokens\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"recoverSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressToBeRemovedFromWhitelist\",\"type\":\"address\"}],\"name\":\"removeWhitelistedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSignatoryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_KEY_SINGLETON_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transferTokensToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMonthlyTransferAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"monthlyTransferAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawTokensWithSignature\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isExistingSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialAmountOfTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TwoKeyParticipationMiningPool","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"Call:eefce35a5f748ab47d574214897b90d5d09f6047","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}