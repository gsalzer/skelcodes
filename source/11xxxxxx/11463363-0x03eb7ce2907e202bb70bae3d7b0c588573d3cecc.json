{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: erc20permit/contracts/IERC2612.sol\r\n\r\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC2612 standard as defined in the EIP.\r\n *\r\n * Adds the {permit} method, which can be used to change one's\r\n * {IERC20-allowance} without having to send a transaction, by signing a\r\n * message. This allows users to spend tokens without having to hold Ether.\r\n *\r\n * See https://eips.ethereum.org/EIPS/eip-2612.\r\n */\r\ninterface IERC2612 {\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    /**\r\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n}\r\n\r\n// File: erc20permit/contracts/ERC20Permit.sol\r\n\r\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @author Georgios Konstantopoulos\r\n * @dev Extension of {ERC20} that allows token holders to use their tokens\r\n * without sending any transactions by setting {IERC20-allowance} with a\r\n * signature using the {permit} method, and then spend them via\r\n * {IERC20-transferFrom}.\r\n *\r\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\r\n */\r\nabstract contract ERC20Permit is ERC20, IERC2612 {\r\n    mapping (address => uint256) public override nonces;\r\n\r\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public immutable DOMAIN_SEPARATOR;\r\n\r\n    constructor(string memory name_, string memory symbol_) internal ERC20(name_, symbol_) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                keccak256(bytes(name_)),\r\n                keccak256(bytes(\"1\")),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC2612-permit}.\r\n     *\r\n     * In cases where the free option is not a concern, deadline can simply be\r\n     * set to uint(-1), so it should be seen as an optional parameter\r\n     */\r\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\r\n        require(deadline >= block.timestamp, \"ERC20Permit: expired deadline\");\r\n\r\n        bytes32 hashStruct = keccak256(\r\n            abi.encode(\r\n                PERMIT_TYPEHASH,\r\n                owner,\r\n                spender,\r\n                amount,\r\n                nonces[owner]++,\r\n                deadline\r\n            )\r\n        );\r\n\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                hashStruct\r\n            )\r\n        );\r\n\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(\r\n            signer != address(0) && signer == owner,\r\n            \"ERC20Permit: invalid signature\"\r\n        );\r\n\r\n        _approve(owner, spender, amount);\r\n    }\r\n}\r\n\r\n// File: contracts/IUSM.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface IUSM {\r\n    function mint(address to, uint minUsmOut) external payable returns (uint);\r\n    function burn(address from, address payable to, uint usmToBurn, uint minEthOut) external returns (uint);\r\n    function fund(address to, uint minFumOut) external payable returns (uint);\r\n    function defund(address from, address payable to, uint fumToBurn, uint minEthOut) external returns (uint);\r\n    function defundFromFUM(address from, address payable to, uint fumToBurn, uint minEthOut) external returns (uint);\r\n}\r\n\r\n// File: contracts/Delegable.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n/// @dev Delegable enables users to delegate their account management to other users.\r\n/// Delegable implements addDelegateBySignature, to add delegates using a signature instead of a separate transaction.\r\ncontract Delegable {\r\n    event Delegate(address indexed user, address indexed delegate, bool enabled);\r\n\r\n    // keccak256(\"Signature(address user,address delegate,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public immutable SIGNATURE_TYPEHASH = 0x0d077601844dd17f704bafff948229d27f33b57445915754dfe3d095fda2beb7;\r\n    bytes32 public immutable DELEGABLE_DOMAIN;\r\n    mapping(address => uint) public signatureCount;\r\n\r\n    mapping(address => mapping(address => bool)) public delegated;\r\n\r\n    constructor () public {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n\r\n        DELEGABLE_DOMAIN = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes('USMFUM')),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @dev Require that msg.sender is the account holder or a delegate\r\n    modifier onlyHolderOrDelegate(address holder, string memory errorMessage) {\r\n        require(\r\n            msg.sender == holder || delegated[holder][msg.sender],\r\n            errorMessage\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Enable a delegate to act on the behalf of caller\r\n    function addDelegate(address delegate) public {\r\n        _addDelegate(msg.sender, delegate);\r\n    }\r\n\r\n    /// @dev Stop a delegate from acting on the behalf of caller\r\n    function revokeDelegate(address delegate) public {\r\n        _revokeDelegate(msg.sender, delegate);\r\n    }\r\n\r\n    /// @dev Add a delegate through an encoded signature\r\n    function addDelegateBySignature(address user, address delegate, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\r\n        require(deadline >= block.timestamp, 'Delegable: Signature expired');\r\n\r\n        bytes32 hashStruct = keccak256(\r\n            abi.encode(\r\n                SIGNATURE_TYPEHASH,\r\n                user,\r\n                delegate,\r\n                signatureCount[user]++,\r\n                deadline\r\n            )\r\n        );\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DELEGABLE_DOMAIN,\r\n                hashStruct\r\n            )\r\n        );\r\n        address signer = ecrecover(digest, v, r, s);\r\n        require(\r\n            signer != address(0) && signer == user,\r\n            'Delegable: Invalid signature'\r\n        );\r\n\r\n        _addDelegate(user, delegate);\r\n    }\r\n\r\n    /// @dev Enable a delegate to act on the behalf of an user\r\n    function _addDelegate(address user, address delegate) internal {\r\n        require(!delegated[user][delegate], \"Delegable: Already delegated\");\r\n        delegated[user][delegate] = true;\r\n        emit Delegate(user, delegate, true);\r\n    }\r\n\r\n    /// @dev Stop a delegate from acting on the behalf of an user\r\n    function _revokeDelegate(address user, address delegate) internal {\r\n        require(delegated[user][delegate], \"Delegable: Already undelegated\");\r\n        delegated[user][delegate] = false;\r\n        emit Delegate(user, delegate, false);\r\n    }\r\n}\r\n\r\n// File: contracts/WadMath.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n/**\r\n * @title Fixed point arithmetic library\r\n * @author Alberto Cuesta Cañada, Jacob Eliosoff, Alex Roan\r\n */\r\nlibrary WadMath {\r\n    using SafeMath for uint;\r\n\r\n    enum Round {Down, Up}\r\n\r\n    uint private constant WAD = 10 ** 18;\r\n    uint private constant WAD_MINUS_1 = WAD - 1;\r\n    uint private constant WAD_SQUARED = WAD * WAD;\r\n    uint private constant WAD_SQUARED_MINUS_1 = WAD_SQUARED - 1;\r\n    uint private constant WAD_OVER_10 = WAD / 10;\r\n    uint private constant WAD_OVER_20 = WAD / 20;\r\n    uint private constant HALF_TO_THE_ONE_TENTH = 933032991536807416;\r\n    uint private constant TWO_WAD = 2 * WAD;\r\n\r\n    function wadMul(uint x, uint y, Round upOrDown) internal pure returns (uint) {\r\n        return upOrDown == Round.Down ? wadMulDown(x, y) : wadMulUp(x, y);\r\n    }\r\n\r\n    function wadMulDown(uint x, uint y) internal pure returns (uint) {\r\n        return x.mul(y) / WAD;\r\n    }\r\n\r\n    function wadMulUp(uint x, uint y) internal pure returns (uint) {\r\n        return (x.mul(y)).add(WAD_MINUS_1) / WAD;\r\n    }\r\n\r\n    function wadSquaredDown(uint x) internal pure returns (uint) {\r\n        return (x.mul(x)) / WAD;\r\n    }\r\n\r\n    function wadSquaredUp(uint x) internal pure returns (uint) {\r\n        return (x.mul(x)).add(WAD_MINUS_1) / WAD;\r\n    }\r\n\r\n    function wadCubedDown(uint x) internal pure returns (uint) {\r\n        return (x.mul(x)).mul(x) / WAD_SQUARED;\r\n    }\r\n\r\n    function wadCubedUp(uint x) internal pure returns (uint) {\r\n        return ((x.mul(x)).mul(x)).add(WAD_SQUARED_MINUS_1) / WAD_SQUARED;\r\n    }\r\n\r\n    function wadDiv(uint x, uint y, Round upOrDown) internal pure returns (uint) {\r\n        return upOrDown == Round.Down ? wadDivDown(x, y) : wadDivUp(x, y);\r\n    }\r\n\r\n    function wadDivDown(uint x, uint y) internal pure returns (uint) {\r\n        return (x.mul(WAD)).div(y);\r\n    }\r\n\r\n    function wadDivUp(uint x, uint y) internal pure returns (uint) {\r\n        return ((x.mul(WAD)).add(y - 1)).div(y);    // Can use \"-\" instead of sub() since div(y) will catch y = 0 case anyway\r\n    }\r\n\r\n    function wadHalfExp(uint power) internal pure returns (uint) {\r\n        return wadHalfExp(power, uint(-1));\r\n    }\r\n\r\n    // Returns a loose but \"gas-efficient\" approximation of 0.5**power, where power is rounded to the nearest 0.1, and is\r\n    // capped at maxPower.  Note power is WAD-scaled (eg, 2.7364 * WAD), but maxPower is just a plain unscaled uint (eg, 10).\r\n    // Negative powers are not handled (as implied by power being a uint).\r\n    function wadHalfExp(uint power, uint maxPower) internal pure returns (uint) {\r\n        uint powerInTenthsUnscaled = power.add(WAD_OVER_20) / WAD_OVER_10;\r\n        if (powerInTenthsUnscaled / 10 > maxPower) {\r\n            return 0;\r\n        }\r\n        return wadPow(HALF_TO_THE_ONE_TENTH, powerInTenthsUnscaled);\r\n    }\r\n\r\n    // Adapted from rpow() in https://github.com/dapphub/ds-math/blob/master/src/math.sol - thank you!\r\n    //\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function wadPow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : WAD;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = wadSquaredDown(x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = wadMulDown(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Using Newton's method (see eg https://stackoverflow.com/a/8827111/3996653), but with WAD fixed-point math.\r\n    function wadCbrtDown(uint y) internal pure returns (uint root) {\r\n        if (y > 0 ) {\r\n            uint newRoot = y.add(TWO_WAD) / 3;\r\n            uint yTimesWadSquared = y.mul(WAD_SQUARED);\r\n            do {\r\n                root = newRoot;\r\n                newRoot = (root + root + (yTimesWadSquared / (root * root))) / 3;\r\n            } while (newRoot < root);\r\n        }\r\n        //require(root**3 <= y.mul(WAD_SQUARED) && y.mul(WAD_SQUARED) < (root + 1)**3);\r\n    }\r\n\r\n    function wadCbrtUp(uint y) internal pure returns (uint root) {\r\n        root = wadCbrtDown(y);\r\n        // The only case where wadCbrtUp(y) *isn't* equal to wadCbrtDown(y) + 1 is when y is a perfect cube; so check for that.\r\n        // These \"*\"s are safe because: 1. root**3 <= y.mul(WAD_SQUARED), and 2. y.mul(WAD_SQUARED) is calculated (safely) above.\r\n        if (root * root * root != y * WAD_SQUARED ) {\r\n            ++root;\r\n        }\r\n        //require((root - 1)**3 < y.mul(WAD_SQUARED) && y.mul(WAD_SQUARED) <= root**3);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/MinOut.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\nlibrary MinOut {\r\n    function parseMinTokenOut(uint ethIn) internal pure returns (uint minTokenOut) {\r\n        uint minPrice = ethIn % 100000000000;\r\n        if (minPrice != 0 && minPrice < 10000000) {\r\n            minTokenOut = ethIn * minPrice / 100;\r\n        }\r\n    }\r\n\r\n    function parseMinEthOut(uint tokenIn) internal pure returns (uint minEthOut) {\r\n        uint maxPrice = tokenIn % 100000000000;\r\n        if (maxPrice != 0 && maxPrice < 10000000) {\r\n            minEthOut = tokenIn * 100 / maxPrice;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/FUM.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n/**\r\n * @title FUM Token\r\n * @author Alberto Cuesta Cañada, Jacob Eliosoff, Alex Roan\r\n *\r\n * @notice This should be owned by the stablecoin.\r\n */\r\ncontract FUM is ERC20Permit, Ownable {\r\n    IUSM public immutable usm;\r\n\r\n    constructor(IUSM usm_) public ERC20Permit(\"Minimal Funding\", \"FUM\") {\r\n        usm = usm_;\r\n    }\r\n\r\n    /**\r\n     * @notice If anyone sends ETH here, assume they intend it as a `fund`.\r\n     * If decimals 8 to 11 (included) of the amount of Ether received are `0000` then the next 7 will\r\n     * be parsed as the minimum Ether price accepted, with 2 digits before and 5 digits after the comma.\r\n     */\r\n    receive() external payable {\r\n        usm.fund{ value: msg.value }(msg.sender, MinOut.parseMinTokenOut(msg.value));\r\n    }\r\n\r\n    /**\r\n     * @notice If a user sends FUM tokens directly to this contract (or to the USM contract), assume they intend it as a `defund`.\r\n     * If using `transfer`/`transferFrom` as `defund`, and if decimals 8 to 11 (included) of the amount transferred received\r\n     * are `0000` then the next 7 will be parsed as the maximum FUM price accepted, with 5 digits before and 2 digits after the comma.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\r\n        if (recipient == address(this) || recipient == address(usm) || recipient == address(0)) {\r\n            usm.defundFromFUM(sender, payable(sender), amount, MinOut.parseMinEthOut(amount));\r\n        } else {\r\n            super._transfer(sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Mint new FUM to the _recipient\r\n     *\r\n     * @param _recipient address to mint to\r\n     * @param _amount amount to mint\r\n     */\r\n    function mint(address _recipient, uint _amount) external onlyOwner {\r\n        _mint(_recipient, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn FUM from _holder\r\n     *\r\n     * @param _holder address to burn from\r\n     * @param _amount amount to burn\r\n     */\r\n    function burn(address _holder, uint _amount) external onlyOwner {\r\n        _burn(_holder, _amount);\r\n    }\r\n}\r\n\r\n// File: contracts/oracles/Oracle.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\nabstract contract Oracle {\r\n    function latestPrice() public virtual view returns (uint price);    // Prices must be WAD-scaled - 18 decimal places\r\n\r\n    /**\r\n     * @dev This pure virtual implementation, which is intended to be (optionally) overridden by stateful implementations,\r\n     * confuses solhint into giving a \"Function state mutability can be restricted to view\" warning.  Unfortunately there seems\r\n     * to be no elegant/gas-free workaround as yet: see https://github.com/ethereum/solidity/issues/3529.\r\n     */\r\n    function cacheLatestPrice() public virtual returns (uint price) {\r\n        price = latestPrice();  // Default implementation doesn't do any cacheing, just returns price.  But override as needed\r\n    }\r\n}\r\n\r\n// File: contracts/USMTemplate.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n\r\n\r\n// import \"@nomiclabs/buidler/console.sol\";\r\n\r\n/**\r\n * @title USMTemplate\r\n * @author Alberto Cuesta Cañada, Jacob Eliosoff, Alex Roan\r\n * @notice Concept by Jacob Eliosoff (@jacob-eliosoff).\r\n *\r\n * This abstract USM contract must be inherited by a concrete implementation, that also adds an Oracle implementation - eg, by\r\n * also inheriting a concrete Oracle implementation.  See USM (and MockUSM) for an example.\r\n *\r\n * We use this inheritance-based design (rather than the more natural, and frankly normally more correct, composition-based design\r\n * of storing the Oracle here as a variable), because inheriting the Oracle makes all the latestPrice() calls *internal* rather\r\n * than calls to a separate oracle contract (or multiple contracts) - which leads to a significant saving in gas.\r\n */\r\nabstract contract USMTemplate is IUSM, Oracle, ERC20Permit, Delegable {\r\n    using Address for address payable;\r\n    using SafeMath for uint;\r\n    using WadMath for uint;\r\n\r\n    enum Side {Buy, Sell}\r\n\r\n    event MinFumBuyPriceChanged(uint previous, uint latest);\r\n    event BuySellAdjustmentChanged(uint previous, uint latest);\r\n\r\n    uint public constant WAD = 10 ** 18;\r\n    uint public constant MAX_DEBT_RATIO = WAD * 8 / 10;                 // 80%\r\n    uint public constant MIN_FUM_BUY_PRICE_HALF_LIFE = 1 days;          // Solidity for 1 * 24 * 60 * 60\r\n    uint public constant BUY_SELL_ADJUSTMENT_HALF_LIFE = 1 minutes;     // Solidity for 1 * 60\r\n\r\n    FUM public immutable fum;\r\n\r\n    uint256 deadline; // Second at which the trial expires and `mint` and `fund` get disabled.\r\n\r\n    struct TimedValue {\r\n        uint32 timestamp;\r\n        uint224 value;\r\n    }\r\n\r\n    TimedValue public minFumBuyPriceStored;\r\n    TimedValue public buySellAdjustmentStored = TimedValue({ timestamp: 0, value: uint224(WAD) });\r\n\r\n    constructor() public ERC20Permit(\"Minimal USD\", \"USM\")\r\n    {\r\n        fum = new FUM(this);\r\n        deadline = now + (60 * 60 * 24 * 28); // Four weeks into the future\r\n    }\r\n\r\n    /** EXTERNAL TRANSACTIONAL FUNCTIONS **/\r\n\r\n    /**\r\n     * @notice Mint new USM, sending it to the given address, and only if the amount minted >= minUsmOut.  The amount of ETH is\r\n     * passed in as msg.value.\r\n     * @param to address to send the USM to.\r\n     * @param minUsmOut Minimum accepted USM for a successful mint.\r\n     */\r\n    function mint(address to, uint minUsmOut) external payable override returns (uint usmOut) {\r\n        usmOut = _mintUsm(to, minUsmOut);\r\n    }\r\n\r\n    /**\r\n     * @dev Burn USM in exchange for ETH.\r\n     * @param from address to deduct the USM from.\r\n     * @param to address to send the ETH to.\r\n     * @param usmToBurn Amount of USM to burn.\r\n     * @param minEthOut Minimum accepted ETH for a successful burn.\r\n     */\r\n    function burn(address from, address payable to, uint usmToBurn, uint minEthOut)\r\n        external override\r\n        onlyHolderOrDelegate(from, \"Only holder or delegate\")\r\n        returns (uint ethOut)\r\n    {\r\n        ethOut = _burnUsm(from, to, usmToBurn, minEthOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Funds the pool with ETH, minting new FUM and sending it to the given address, but only if the amount minted >=\r\n     * minFumOut.  The amount of ETH is passed in as msg.value.\r\n     * @param to address to send the FUM to.\r\n     * @param minFumOut Minimum accepted FUM for a successful fund.\r\n     */\r\n    function fund(address to, uint minFumOut) external payable override returns (uint fumOut) {\r\n        fumOut = _fundFum(to, minFumOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Defunds the pool by redeeming FUM in exchange for equivalent ETH from the pool.\r\n     * @param from address to deduct the FUM from.\r\n     * @param to address to send the ETH to.\r\n     * @param fumToBurn Amount of FUM to burn.\r\n     * @param minEthOut Minimum accepted ETH for a successful defund.\r\n     */\r\n    function defund(address from, address payable to, uint fumToBurn, uint minEthOut)\r\n        external override\r\n        onlyHolderOrDelegate(from, \"Only holder or delegate\")\r\n        returns (uint ethOut)\r\n    {\r\n        ethOut = _defundFum(from, to, fumToBurn, minEthOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Defunds the pool by redeeming FUM from an arbitrary address in exchange for equivalent ETH from the pool.\r\n     * Called only by the FUM contract, when FUM is sent to it.\r\n     * @param from address to deduct the FUM from.\r\n     * @param to address to send the ETH to.\r\n     * @param fumToBurn Amount of FUM to burn.\r\n     * @param minEthOut Minimum accepted ETH for a successful defund.\r\n     */\r\n    function defundFromFUM(address from, address payable to, uint fumToBurn, uint minEthOut)\r\n        external override\r\n        returns (uint ethOut)\r\n    {\r\n        require(msg.sender == address(fum), \"Restricted to FUM\");\r\n        ethOut = _defundFum(from, to, fumToBurn, minEthOut);\r\n    }\r\n\r\n    /**\r\n     * @notice If anyone sends ETH here, assume they intend it as a `mint`.\r\n     * If decimals 8 to 11 (included) of the amount of Ether received are `0000` then the next 7 will\r\n     * be parsed as the minimum Ether price accepted, with 2 digits before and 5 digits after the comma.\r\n     */\r\n    receive() external payable {\r\n        _mintUsm(msg.sender, MinOut.parseMinTokenOut(msg.value));\r\n    }\r\n\r\n    /**\r\n     * @notice If a user sends USM tokens directly to this contract (or to the FUM contract), assume they intend it as a `burn`.\r\n     * If using `transfer`/`transferFrom` as `burn`, and if decimals 8 to 11 (included) of the amount transferred received\r\n     * are `0000` then the next 7 will be parsed as the maximum USM price accepted, with 5 digits before and 2 digits after the comma.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\r\n        if (recipient == address(this) || recipient == address(fum) || recipient == address(0)) {\r\n            _burnUsm(sender, payable(sender), amount, MinOut.parseMinEthOut(amount));\r\n        } else {\r\n            super._transfer(sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    /** INTERNAL TRANSACTIONAL FUNCTIONS */\r\n\r\n    function _mintUsm(address to, uint minUsmOut) internal returns (uint usmOut)\r\n    {\r\n        // 1. Check that fund() has been called first - no minting before funding:\r\n        uint rawEthInPool = ethPool();\r\n        uint ethInPool = rawEthInPool.sub(msg.value);   // Backing out the ETH just received, which our calculations should ignore\r\n        require(ethInPool > 0, \"Fund before minting\");\r\n\r\n        // 2. Calculate usmOut:\r\n        uint ethUsmPrice = cacheLatestPrice();\r\n        uint usmTotalSupply = totalSupply();\r\n        uint oldDebtRatio = debtRatio(ethUsmPrice, ethInPool, usmTotalSupply);\r\n        usmOut = usmFromMint(ethUsmPrice, msg.value, ethInPool, usmTotalSupply, oldDebtRatio);\r\n        require(usmOut >= minUsmOut, \"Limit not reached\");\r\n\r\n        // 3. Update buySellAdjustmentStored and mint the user's new USM:\r\n        uint newDebtRatio = debtRatio(ethUsmPrice, rawEthInPool, usmTotalSupply.add(usmOut));\r\n        _updateBuySellAdjustment(oldDebtRatio, newDebtRatio, buySellAdjustment());\r\n        _mint(to, usmOut);\r\n\r\n        require(now <= deadline, \"Trial expired, remove assets\");\r\n        require(msg.value <= 1e18, \"Capped at 1 ETH per tx\");\r\n        require(ethPool() <= 1e20, \"Capped at 100 pooled ETH\");\r\n    }\r\n\r\n    function _burnUsm(address from, address payable to, uint usmToBurn, uint minEthOut) internal returns (uint ethOut)\r\n    {\r\n        // 1. Calculate ethOut:\r\n        uint ethUsmPrice = cacheLatestPrice();\r\n        uint ethInPool = ethPool();\r\n        uint usmTotalSupply = totalSupply();\r\n        uint oldDebtRatio = debtRatio(ethUsmPrice, ethInPool, usmTotalSupply);\r\n        ethOut = ethFromBurn(ethUsmPrice, usmToBurn, ethInPool, usmTotalSupply, oldDebtRatio);\r\n        require(ethOut >= minEthOut, \"Limit not reached\");\r\n\r\n        // 2. Burn the input USM, update buySellAdjustmentStored, and return the user's ETH:\r\n        uint newDebtRatio = debtRatio(ethUsmPrice, ethInPool.sub(ethOut), usmTotalSupply.sub(usmToBurn));\r\n        require(newDebtRatio <= WAD, \"Debt ratio > 100%\");\r\n        _burn(from, usmToBurn);\r\n        _updateBuySellAdjustment(oldDebtRatio, newDebtRatio, buySellAdjustment());\r\n        to.sendValue(ethOut);\r\n    }\r\n\r\n    function _fundFum(address to, uint minFumOut) internal returns (uint fumOut)\r\n    {\r\n        // 1. Refresh mfbp:\r\n        uint ethUsmPrice = cacheLatestPrice();\r\n        uint rawEthInPool = ethPool();\r\n        uint ethInPool = rawEthInPool.sub(msg.value);   // Backing out the ETH just received, which our calculations should ignore\r\n        uint usmTotalSupply = totalSupply();\r\n        uint oldDebtRatio = debtRatio(ethUsmPrice, ethInPool, usmTotalSupply);\r\n        uint fumTotalSupply = fum.totalSupply();\r\n        _updateMinFumBuyPrice(oldDebtRatio, ethInPool, fumTotalSupply);\r\n\r\n        // 2. Calculate fumOut:\r\n        uint adjustment = buySellAdjustment();\r\n        fumOut = fumFromFund(ethUsmPrice, msg.value, ethInPool, usmTotalSupply, fumTotalSupply, adjustment);\r\n        require(fumOut >= minFumOut, \"Limit not reached\");\r\n\r\n        // 3. Update buySellAdjustmentStored and mint the user's new FUM:\r\n        uint newDebtRatio = debtRatio(ethUsmPrice, rawEthInPool, usmTotalSupply);\r\n        _updateBuySellAdjustment(oldDebtRatio, newDebtRatio, adjustment);\r\n        fum.mint(to, fumOut);\r\n\r\n        require(now <= deadline, \"Trial expired, remove assets\");\r\n        require(msg.value <= 1e18, \"Capped at 1 ETH per tx\");\r\n        require(ethPool() <= 1e20, \"Capped at 100 pooled ETH\");\r\n    }\r\n\r\n    function _defundFum(address from, address payable to, uint fumToBurn, uint minEthOut) internal returns (uint ethOut)\r\n    {\r\n        // 1. Calculate ethOut:\r\n        uint ethUsmPrice = cacheLatestPrice();\r\n        uint ethInPool = ethPool();\r\n        uint usmTotalSupply = totalSupply();\r\n        uint oldDebtRatio = debtRatio(ethUsmPrice, ethInPool, usmTotalSupply);\r\n        ethOut = ethFromDefund(ethUsmPrice, fumToBurn, ethInPool, usmTotalSupply);\r\n        require(ethOut >= minEthOut, \"Limit not reached\");\r\n\r\n        // 2. Burn the input FUM, update buySellAdjustmentStored, and return the user's ETH:\r\n        uint newDebtRatio = debtRatio(ethUsmPrice, ethInPool.sub(ethOut), usmTotalSupply);\r\n        require(newDebtRatio <= MAX_DEBT_RATIO, \"Debt ratio > max\");\r\n        fum.burn(from, fumToBurn);\r\n        _updateBuySellAdjustment(oldDebtRatio, newDebtRatio, buySellAdjustment());\r\n        to.sendValue(ethOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the min FUM price, based on the current oracle price and debt ratio. Emits a MinFumBuyPriceChanged event.\r\n     * @dev The logic for calculating a new minFumBuyPrice is as follows.  We want to set it to the FUM price, in ETH terms, at\r\n     * which debt ratio was exactly MAX_DEBT_RATIO.  So we can assume:\r\n     *\r\n     *     usmToEth(totalSupply()) / ethPool() = MAX_DEBT_RATIO, or in other words:\r\n     *     usmToEth(totalSupply()) = MAX_DEBT_RATIO * ethPool()\r\n     *\r\n     * And with this assumption, we calculate the FUM price (buffer / FUM qty) like so:\r\n     *\r\n     *     minFumBuyPrice = ethBuffer() / fum.totalSupply()\r\n     *                    = (ethPool() - usmToEth(totalSupply())) / fum.totalSupply()\r\n     *                    = (ethPool() - (MAX_DEBT_RATIO * ethPool())) / fum.totalSupply()\r\n     *                    = (1 - MAX_DEBT_RATIO) * ethPool() / fum.totalSupply()\r\n     */\r\n    function _updateMinFumBuyPrice(uint debtRatio_, uint ethInPool, uint fumTotalSupply) internal {\r\n        uint previous = minFumBuyPriceStored.value;\r\n        if (debtRatio_ <= MAX_DEBT_RATIO) {                 // We've dropped below (or were already below, whatev) max debt ratio\r\n            if (previous != 0) {\r\n                minFumBuyPriceStored.timestamp = 0;         // Clear mfbp\r\n                minFumBuyPriceStored.value = 0;\r\n                emit MinFumBuyPriceChanged(previous, 0);\r\n            }\r\n        } else if (previous == 0) {                         // We were < max debt ratio, but have now crossed above - so set mfbp\r\n            // See reasoning in @dev comment above\r\n            minFumBuyPriceStored.timestamp = uint32(block.timestamp);\r\n            minFumBuyPriceStored.value = uint224((WAD - MAX_DEBT_RATIO).wadMulUp(ethInPool).wadDivUp(fumTotalSupply));\r\n            emit MinFumBuyPriceChanged(previous, minFumBuyPriceStored.value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update the buy/sell adjustment factor, as of the current block time, after a price-moving operation.\r\n     * @param oldDebtRatio The debt ratio before the operation (eg, mint()) was done\r\n     * @param newDebtRatio The current, post-op debt ratio\r\n     */\r\n    function _updateBuySellAdjustment(uint oldDebtRatio, uint newDebtRatio, uint oldAdjustment) internal {\r\n        // Skip this if either the old or new debt ratio == 0.  Normally this will only happen on the system's first couple of\r\n        // calls, but in principle it could happen later if every single USM holder burns all their USM.  This seems\r\n        // vanishingly unlikely though if the system gets any uptake at all, and anyway if it does happen it will just mean a\r\n        // couple of skipped updates to the buySellAdjustment - no big deal.\r\n        if (oldDebtRatio != 0 && newDebtRatio != 0) {\r\n            uint previous = buySellAdjustmentStored.value; // Not nec the same as oldAdjustment, because of the time decay!\r\n\r\n            // Eg: if a user operation reduced debt ratio from 70% to 50%, it was either a fund() or a burn().  These are both\r\n            // \"long-ETH\" operations.  So we can take (old / new)**2 = (70% / 50%)**2 = 1.4**2 = 1.96 as the ratio by which to\r\n            // increase buySellAdjustment, which is intended as a measure of \"how long-ETH recent user activity has been\":\r\n            uint newAdjustment = (oldAdjustment.mul(oldDebtRatio).mul(oldDebtRatio) / newDebtRatio) / newDebtRatio;\r\n            buySellAdjustmentStored.timestamp = uint32(block.timestamp);\r\n            buySellAdjustmentStored.value = uint224(newAdjustment);\r\n            emit BuySellAdjustmentChanged(previous, newAdjustment);\r\n        }\r\n    }\r\n\r\n    /** PUBLIC AND INTERNAL VIEW FUNCTIONS **/\r\n\r\n    /**\r\n     * @notice Total amount of ETH in the pool (ie, in the contract).\r\n     * @return pool ETH pool\r\n     */\r\n    function ethPool() public view returns (uint pool) {\r\n        pool = address(this).balance;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount of ETH in the buffer.\r\n     * @return buffer ETH buffer\r\n     */\r\n    function ethBuffer(uint ethUsmPrice, uint ethInPool, uint usmTotalSupply, WadMath.Round upOrDown)\r\n        internal pure returns (int buffer)\r\n    {\r\n        // Reverse the input upOrDown, since we're using it for usmToEth(), which will be *subtracted* from ethInPool below:\r\n        WadMath.Round downOrUp = (upOrDown == WadMath.Round.Down ? WadMath.Round.Up : WadMath.Round.Down);\r\n        buffer = int(ethInPool) - int(usmToEth(ethUsmPrice, usmTotalSupply, downOrUp));\r\n        require(buffer <= int(ethInPool), \"Underflow error\");\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate debt ratio for a given eth to USM price: ratio of the outstanding USM (amount of USM in total supply), to\r\n     * the current ETH pool amount.\r\n     * @return ratio Debt ratio\r\n     */\r\n    function debtRatio(uint ethUsmPrice, uint ethInPool, uint usmTotalSupply) internal pure returns (uint ratio) {\r\n        uint ethPoolValueInUsd = ethInPool.wadMulDown(ethUsmPrice);\r\n        ratio = (ethInPool == 0 ? 0 : usmTotalSupply.wadDivUp(ethPoolValueInUsd));\r\n    }\r\n\r\n    /**\r\n     * @notice Convert ETH amount to USM using a ETH/USD price.\r\n     * @param ethAmount The amount of ETH to convert\r\n     * @return usmOut The amount of USM\r\n     */\r\n    function ethToUsm(uint ethUsmPrice, uint ethAmount, WadMath.Round upOrDown) internal pure returns (uint usmOut) {\r\n        usmOut = ethAmount.wadMul(ethUsmPrice, upOrDown);\r\n    }\r\n\r\n    /**\r\n     * @notice Convert USM amount to ETH using a ETH/USD price.\r\n     * @param usmAmount The amount of USM to convert\r\n     * @return ethOut The amount of ETH\r\n     */\r\n    function usmToEth(uint ethUsmPrice, uint usmAmount, WadMath.Round upOrDown) internal pure returns (uint ethOut) {\r\n        ethOut = usmAmount.wadDiv(ethUsmPrice, upOrDown);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the *marginal* price of USM (in ETH terms) - that is, of the next unit, before the price start sliding.\r\n     * @return price USM price in ETH terms\r\n     */\r\n    function usmPrice(Side side, uint ethUsmPrice, uint debtRatio_) internal view returns (uint price) {\r\n        WadMath.Round upOrDown = (side == Side.Buy ? WadMath.Round.Up : WadMath.Round.Down);\r\n        price = usmToEth(ethUsmPrice, WAD, upOrDown);\r\n\r\n        uint adjustment = buySellAdjustment();\r\n        if (debtRatio_ <= WAD) {\r\n            if ((side == Side.Buy && adjustment < WAD) || (side == Side.Sell && adjustment > WAD)) {\r\n                price = price.wadDiv(adjustment, upOrDown);\r\n            }\r\n        } else {    // See comment at the bottom of usmFromMint() explaining this special case where debtRatio > 100%\r\n            if ((side == Side.Buy && adjustment > WAD) || (side == Side.Sell && adjustment < WAD)) {\r\n                price = price.wadMul(adjustment, upOrDown);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the *marginal* price of FUM (in ETH terms) - that is, of the next unit, before the price start sliding.\r\n     * @return price FUM price in ETH terms\r\n     */\r\n    function fumPrice(Side side, uint ethUsmPrice, uint ethInPool, uint usmTotalSupply, uint fumTotalSupply, uint adjustment)\r\n        internal view returns (uint price)\r\n    {\r\n        WadMath.Round upOrDown = (side == Side.Buy ? WadMath.Round.Up : WadMath.Round.Down);\r\n        if (fumTotalSupply == 0) {\r\n            return usmToEth(ethUsmPrice, WAD, upOrDown);    // if no FUM issued yet, default fumPrice to 1 USD (in ETH terms)\r\n        }\r\n        int buffer = ethBuffer(ethUsmPrice, ethInPool, usmTotalSupply, upOrDown);\r\n        price = (buffer <= 0 ? 0 : uint(buffer).wadDiv(fumTotalSupply, upOrDown));\r\n\r\n        if (side == Side.Buy) {\r\n            if (adjustment > WAD) {\r\n                price = price.wadMulUp(adjustment);\r\n            }\r\n            // Floor the buy price at minFumBuyPrice:\r\n            uint mfbp = minFumBuyPrice();\r\n            if (price < mfbp) {\r\n                price = mfbp;\r\n            }\r\n        } else {\r\n            if (adjustment < WAD) {\r\n                price = price.wadMulDown(adjustment);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice How much USM a minter currently gets back for ethIn ETH, accounting for adjustment and sliding prices.\r\n     * @param ethIn The amount of ETH passed to mint()\r\n     * @return usmOut The amount of USM to receive in exchange\r\n     */\r\n    function usmFromMint(uint ethUsmPrice, uint ethIn, uint ethQty0, uint usmQty0, uint debtRatio0)\r\n        internal view returns (uint usmOut)\r\n    {\r\n        uint usmPrice0 = usmPrice(Side.Buy, ethUsmPrice, debtRatio0);\r\n        uint ethQty1 = ethQty0.add(ethIn);\r\n        if (usmQty0 == 0) {\r\n            // No USM in the system, so debtRatio() == 0 which breaks the integral below - skip sliding-prices this time:\r\n            usmOut = ethIn.wadDivDown(usmPrice0);\r\n        } else if (debtRatio0 <= WAD) {\r\n            // Mint USM at a sliding-up USM price (ie, at a sliding-down ETH price).  **BASIC RULE:** anytime debtRatio()\r\n            // changes by factor k (here > 1), ETH price changes by factor 1/k**2 (ie, USM price, in ETH terms, changes by\r\n            // factor k**2).  (Earlier versions of this logic scaled ETH price based on change in ethPool(), or change in\r\n            // ethPool()**2: the latter gives simpler math - no cbrt() - but doesn't let mint/burn offset fund/defund, which\r\n            // debtRatio()**2 nicely does.)\r\n\r\n            // Math: this is an integral - sum of all USM minted at a sliding-down ETH price:\r\n            // u - u_0 = ((((e / e_0)**3 - 1) * e_0 / ubp_0 + u_0) * u_0**2)**(1/3) - u_0\r\n            uint integralFirstPart = (ethQty1.wadDivDown(ethQty0).wadCubedDown().sub(WAD)).mul(ethQty0).div(usmPrice0);\r\n            usmOut = (integralFirstPart.add(usmQty0)).wadMulDown(usmQty0.wadSquaredDown()).wadCbrtDown().sub(usmQty0);\r\n        } else {\r\n            // Here we have the special, unusual case where we're minting while debt ratio > 100%.  In this case (only),\r\n            // minting will actually *reduce* debt ratio, whereas normally it increases it.  (In short: minting always pushes\r\n            // debt ratio closer to 100%.)  Because debt ratio is decreasing as we buy, and USM buy price must *increase* as we\r\n            // buy, we need to make USM price grow proportionally to (1 / change in debt ratio)**2, rather than the usual\r\n            // (1 / change in debt ratio)**2 above.  This gives the following different integral:\r\n            // x = e0 * (e - e0) / (u0 * pu0)\r\n            // u - u_0 = u0 * x / (e - x)\r\n            uint integralFirstPart = ethQty0.mul(ethIn).div(usmQty0.wadMulUp(usmPrice0));\r\n            usmOut = usmQty0.mul(integralFirstPart).div(ethQty1.sub(integralFirstPart));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice How much ETH a burner currently gets from burning usmIn USM, accounting for adjustment and sliding prices.\r\n     * @param usmIn The amount of USM passed to burn()\r\n     * @return ethOut The amount of ETH to receive in exchange\r\n     */\r\n    function ethFromBurn(uint ethUsmPrice, uint usmIn, uint ethQty0, uint usmQty0, uint debtRatio0)\r\n        internal view returns (uint ethOut)\r\n    {\r\n        // Burn USM at a sliding-down USM price (ie, a sliding-up ETH price):\r\n        uint usmPrice0 = usmPrice(Side.Sell, ethUsmPrice, debtRatio0);\r\n        uint usmQty1 = usmQty0.sub(usmIn);\r\n\r\n        // Math: this is an integral - sum of all USM burned at a sliding price.  Follows the same mathematical invariant as\r\n        // above: if debtRatio() *= k (here, k < 1), ETH price *= 1/k**2, ie, USM price in ETH terms *= k**2.\r\n        // e_0 - e = e_0 - (e_0**2 * (e_0 - usp_0 * u_0 * (1 - (u / u_0)**3)))**(1/3)\r\n        uint integralFirstPart = usmPrice0.wadMulDown(usmQty0).wadMulDown(WAD.sub(usmQty1.wadDivUp(usmQty0).wadCubedUp()));\r\n        ethOut = ethQty0.sub(ethQty0.wadSquaredUp().wadMulUp(ethQty0.sub(integralFirstPart)).wadCbrtUp());\r\n    }\r\n\r\n    /**\r\n     * @notice How much FUM a funder currently gets back for ethIn ETH, accounting for adjustment and sliding prices.\r\n     * @param ethIn The amount of ETH passed to fund()\r\n     * @return fumOut The amount of FUM to receive in exchange\r\n     */\r\n    function fumFromFund(uint ethUsmPrice, uint ethIn, uint ethQty0, uint usmQty0, uint fumQty0, uint adjustment)\r\n        internal view returns (uint fumOut)\r\n    {\r\n        // Create FUM at a sliding-up FUM price:\r\n        uint fumPrice0 = fumPrice(Side.Buy, ethUsmPrice, ethQty0, usmQty0, fumQty0, adjustment);\r\n        if (usmQty0 == 0) {\r\n            // No USM in the system - skip sliding-prices:\r\n            fumOut = ethIn.wadDivDown(fumPrice0);\r\n        } else {\r\n            // Math: f - f_0 = e_0 * (e - e_0) / (e * fbp_0)\r\n            uint ethQty1 = ethQty0.add(ethIn);\r\n            fumOut = ethQty0.mul(ethIn).div(ethQty1.wadMulUp(fumPrice0));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice How much ETH a defunder currently gets back for fumIn FUM, accounting for adjustment and sliding prices.\r\n     * @param fumIn The amount of FUM passed to defund()\r\n     * @return ethOut The amount of ETH to receive in exchange\r\n     */\r\n    function ethFromDefund(uint ethUsmPrice, uint fumIn, uint ethQty0, uint usmQty0)\r\n        internal view returns (uint ethOut)\r\n    {\r\n        // Burn FUM at a sliding-down FUM price:\r\n        uint fumQty0 = fum.totalSupply();\r\n        uint fumPrice0 = fumPrice(Side.Sell, ethUsmPrice, ethQty0, usmQty0, fumQty0, buySellAdjustment());\r\n        if (usmQty0 == 0) {\r\n            // No USM in the system - skip sliding-prices:\r\n            ethOut = fumIn.wadMulDown(fumPrice0);\r\n        } else {\r\n            // Math: e_0 - e = e_0 * (f_0 - f) * fsp_0 / (e_0 + (f_0 - f) * fsp_0)\r\n            ethOut = ethQty0.mul(fumIn.wadMulDown(fumPrice0)).div(ethQty0.add(fumIn.wadMulUp(fumPrice0)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice The current min FUM buy price, equal to the stored value decayed by time since minFumBuyPriceTimestamp.\r\n     * @return mfbp The minFumBuyPrice, in ETH terms\r\n     */\r\n    function minFumBuyPrice() public view returns (uint mfbp) {\r\n        if (minFumBuyPriceStored.value != 0) {\r\n            uint numHalvings = block.timestamp.sub(minFumBuyPriceStored.timestamp).wadDivDown(MIN_FUM_BUY_PRICE_HALF_LIFE);\r\n            uint decayFactor = numHalvings.wadHalfExp();\r\n            mfbp = uint256(minFumBuyPriceStored.value).wadMulUp(decayFactor);\r\n        }   // Otherwise just returns 0\r\n    }\r\n\r\n    /**\r\n     * @notice The current buy/sell adjustment, equal to the stored value decayed by time since buySellAdjustmentTimestamp.  This\r\n     * adjustment is intended as a measure of \"how long-ETH recent user activity has been\", so that we can slide price\r\n     * accordingly: if recent activity was mostly long-ETH (fund() and burn()), raise FUM buy price/reduce USM sell price; if\r\n     * recent activity was short-ETH (defund() and mint()), reduce FUM sell price/raise USM buy price.  We use \"it reduced debt\r\n     * ratio\" as a rough proxy for \"the operation was long-ETH\".\r\n     *\r\n     * (There is one odd case: when debt ratio > 100%, a *short*-ETH mint() will actually reduce debt ratio.  This does no real\r\n     * harm except to make fast-succession mint()s and fund()s in such > 100% cases a little more expensive than they would be.)\r\n     *\r\n     * @return adjustment The sliding-price buy/sell adjustment\r\n     */\r\n    function buySellAdjustment() public view returns (uint adjustment) {\r\n        uint numHalvings = block.timestamp.sub(buySellAdjustmentStored.timestamp).wadDivDown(BUY_SELL_ADJUSTMENT_HALF_LIFE);\r\n        uint decayFactor = numHalvings.wadHalfExp(10);\r\n        // Here we use the idea that for any b and 0 <= p <= 1, we can crudely approximate b**p by 1 + (b-1)p = 1 + bp - p.\r\n        // Eg: 0.6**0.5 pulls 0.6 \"about halfway\" to 1 (0.8); 0.6**0.25 pulls 0.6 \"about 3/4 of the way\" to 1 (0.9).\r\n        // So b**p =~ b + (1-p)(1-b) = b + 1 - b - p + bp = 1 + bp - p.\r\n        // (Don't calculate it as 1 + (b-1)p because we're using uints, b-1 can be negative!)\r\n        adjustment = WAD.add(uint256(buySellAdjustmentStored.value).wadMulDown(decayFactor)).sub(decayFactor);\r\n    }\r\n\r\n    /** EXTERNAL VIEW FUNCTIONS */\r\n\r\n    /**\r\n     * @notice Calculate the amount of ETH in the buffer.\r\n     * @return buffer ETH buffer\r\n     */\r\n    function ethBuffer(WadMath.Round upOrDown) external view returns (int buffer) {\r\n        buffer = ethBuffer(latestPrice(), ethPool(), totalSupply(), upOrDown);\r\n    }\r\n\r\n    /**\r\n     * @notice Convert ETH amount to USM using the latest oracle ETH/USD price.\r\n     * @param ethAmount The amount of ETH to convert\r\n     * @return usmOut The amount of USM\r\n     */\r\n    function ethToUsm(uint ethAmount, WadMath.Round upOrDown) external view returns (uint usmOut) {\r\n        usmOut = ethToUsm(latestPrice(), ethAmount, upOrDown);\r\n    }\r\n\r\n    /**\r\n     * @notice Convert USM amount to ETH using the latest oracle ETH/USD price.\r\n     * @param usmAmount The amount of USM to convert\r\n     * @return ethOut The amount of ETH\r\n     */\r\n    function usmToEth(uint usmAmount, WadMath.Round upOrDown) external view returns (uint ethOut) {\r\n        ethOut = usmToEth(latestPrice(), usmAmount, upOrDown);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate debt ratio.\r\n     * @return ratio Debt ratio\r\n     */\r\n    function debtRatio() external view returns (uint ratio) {\r\n        ratio = debtRatio(latestPrice(), ethPool(), totalSupply());\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the *marginal* price of USM (in ETH terms) - that is, of the next unit, before the price start sliding.\r\n     * @return price USM price in ETH terms\r\n     */\r\n    function usmPrice(Side side) external view returns (uint price) {\r\n        uint ethUsdPrice = latestPrice();\r\n        price = usmPrice(side, ethUsdPrice, debtRatio(ethUsdPrice, ethPool(), totalSupply()));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the *marginal* price of FUM (in ETH terms) - that is, of the next unit, before the price start sliding.\r\n     * @return price FUM price in ETH terms\r\n     */\r\n    function fumPrice(Side side) external view returns (uint price) {\r\n        price = fumPrice(side, latestPrice(), ethPool(), totalSupply(), fum.totalSupply(), buySellAdjustment());\r\n    }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\r\n\r\npragma solidity >=0.6.0;\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n// File: contracts/oracles/ChainlinkOracle.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n/**\r\n * @title ChainlinkOracle\r\n */\r\ncontract ChainlinkOracle is Oracle {\r\n    using SafeMath for uint;\r\n\r\n    uint private constant SCALE_FACTOR = 10 ** 10;  // Since Chainlink has 8 dec places, and latestPrice() needs 18\r\n\r\n    AggregatorV3Interface private aggregator;\r\n\r\n    constructor(AggregatorV3Interface aggregator_) public\r\n    {\r\n        aggregator = aggregator_;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the latest price of the price oracle.\r\n     * @return price\r\n     */\r\n    function latestPrice() public virtual override view returns (uint price) {\r\n        price = latestChainlinkPrice();\r\n    }\r\n\r\n    function latestChainlinkPrice() public view returns (uint price) {\r\n        (, int rawPrice,,,) = aggregator.latestRoundData();\r\n        price = uint(rawPrice).mul(SCALE_FACTOR); // TODO: Cast safely\r\n    }\r\n}\r\n\r\n// File: contracts/oracles/CompoundOpenOracle.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface UniswapAnchoredView {\r\n    function price(string calldata symbol) external view returns (uint);\r\n}\r\n\r\n/**\r\n * @title CompoundOpenOracle\r\n */\r\ncontract CompoundOpenOracle is Oracle {\r\n    using SafeMath for uint;\r\n\r\n    uint private constant SCALE_FACTOR = 10 ** 12;  // Since Compound has 6 dec places, and latestPrice() needs 18\r\n\r\n    UniswapAnchoredView private anchoredView;\r\n\r\n    constructor(UniswapAnchoredView anchoredView_) public\r\n    {\r\n        anchoredView = anchoredView_;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the latest price of the price oracle.\r\n     * @return price\r\n     */\r\n    function latestPrice() public virtual override view returns (uint price) {\r\n        price = latestCompoundPrice();\r\n    }\r\n\r\n    function latestCompoundPrice() public view returns (uint price) {\r\n        price = anchoredView.price(\"ETH\").mul(SCALE_FACTOR);\r\n    }\r\n}\r\n\r\n// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts/oracles/OurUniswapV2TWAPOracle.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\ncontract OurUniswapV2TWAPOracle is Oracle {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * MIN_TWAP_PERIOD plays two roles:\r\n     *\r\n     * 1. Minimum age of the stored CumulativePrice we calculate our current TWAP vs.  Eg, if one of our stored prices is from\r\n     * 5 secs ago, and the other from 10 min ago, we should calculate TWAP vs the 10-min-old one, since a 5-second TWAP is too\r\n     * short - relatively easy to manipulate.\r\n     *\r\n     * 2. Minimum time gap between stored CumulativePrices.  Eg, if we stored one 5 seconds ago, we don't need to store another\r\n     * one now - and shouldn't, since then if someone else made a TWAP call a few seconds later, both stored prices would be\r\n     * too recent to calculate a robust TWAP.\r\n     *\r\n     * These roles could in principle be separated, eg: \"Require the stored price we calculate TWAP from to be >= 2 minutes\r\n     * old, but leave >= 10 minutes before storing a new price.\"  But for simplicity we keep them the same.\r\n     */\r\n    uint public constant MIN_TWAP_PERIOD = 2 minutes;\r\n\r\n    // Uniswap stores its cumulative prices in \"FixedPoint.uq112x112\" format - 112-bit fixed point:\r\n    uint public constant UNISWAP_CUM_PRICE_SCALE_FACTOR = 2 ** 112;\r\n\r\n    uint private constant UINT32_MAX = 2 ** 32 - 1;     // Should really be type(uint32).max, but that needs Solidity 0.6.8...\r\n    uint private constant UINT224_MAX = 2 ** 224 - 1;   // Ditto, type(uint224).max\r\n\r\n    IUniswapV2Pair immutable uniswapPair;\r\n    uint immutable token0Decimals;\r\n    uint immutable token1Decimals;\r\n    bool immutable tokensInReverseOrder;\r\n    uint immutable scaleFactor;\r\n\r\n    struct CumulativePrice {\r\n        uint32 timestamp;\r\n        uint224 priceSeconds;   // See cumulativePrice() below for an explanation of \"priceSeconds\"\r\n    }\r\n\r\n    /**\r\n     * We store two CumulativePrices, A and B, without specifying which is more recent.  This is so that we only need to do one\r\n     * SSTORE each time we save a new one: we can inspect them later to figure out which is newer - see orderedStoredPrices().\r\n     */\r\n    CumulativePrice private storedPriceA;\r\n    CumulativePrice private storedPriceB;\r\n\r\n    /**\r\n     * Example pairs to pass in:\r\n     * ETH/USDT: 0x0d4a11d5eeaac28ec3f61d100daf4d40471f1852, false, 18, 6 (WETH reserve is stored w/ 18 dec places, USDT w/ 18)\r\n     * USDC/ETH: 0xb4e16d0168e52d35cacd2c6185b44281ec28c9dc, true, 6, 18 (USDC reserve is stored w/ 6 dec places, WETH w/ 18)\r\n     * DAI/ETH: 0xa478c2975ab1ea89e8196811f51a7b7ade33eb11, true, 18, 18 (DAI reserve is stored w/ 18 dec places, WETH w/ 18)\r\n     */\r\n    constructor(IUniswapV2Pair uniswapPair_, uint token0Decimals_, uint token1Decimals_, bool tokensInReverseOrder_) public {\r\n        uniswapPair = uniswapPair_;\r\n        token0Decimals = token0Decimals_;\r\n        token1Decimals = token1Decimals_;\r\n        tokensInReverseOrder = tokensInReverseOrder_;\r\n\r\n        (uint aDecimals, uint bDecimals) = tokensInReverseOrder_ ?\r\n            (token1Decimals_, token0Decimals_) :\r\n            (token0Decimals_, token1Decimals_);\r\n        scaleFactor = 10 ** aDecimals.add(18).sub(bDecimals);\r\n    }\r\n\r\n    function cacheLatestPrice() public virtual override returns (uint price) {\r\n        (CumulativePrice storage olderStoredPrice, CumulativePrice storage newerStoredPrice) = orderedStoredPrices();\r\n\r\n        uint timestamp;\r\n        uint priceSeconds;\r\n        (price, timestamp, priceSeconds) = _latestPrice(newerStoredPrice);\r\n\r\n        // Store the latest cumulative price, if it's been long enough since the latest stored price:\r\n        if (areNewAndStoredPriceFarEnoughApart(timestamp, newerStoredPrice)) {\r\n            storeCumulativePrice(timestamp, priceSeconds, olderStoredPrice);\r\n        }\r\n    }\r\n\r\n    function latestPrice() public virtual override view returns (uint price) {\r\n        price = latestUniswapTWAPPrice();\r\n    }\r\n\r\n    function latestUniswapTWAPPrice() public view returns (uint price) {\r\n        (, CumulativePrice storage newerStoredPrice) = orderedStoredPrices();\r\n        (price, , ) = _latestPrice(newerStoredPrice);\r\n    }\r\n\r\n    function _latestPrice(CumulativePrice storage newerStoredPrice)\r\n        internal view returns (uint price, uint timestamp, uint priceSeconds)\r\n    {\r\n        (timestamp, priceSeconds) = cumulativePrice();\r\n\r\n        // Now that we have the current cum price, subtract-&-divide the stored one, to get the TWAP price:\r\n        CumulativePrice storage refPrice = storedPriceToCompareVs(timestamp, newerStoredPrice);\r\n        price = calculateTWAP(timestamp, priceSeconds, uint(refPrice.timestamp), uint(refPrice.priceSeconds));\r\n    }\r\n\r\n    function storeCumulativePrice(uint timestamp, uint priceSeconds, CumulativePrice storage olderStoredPrice) internal\r\n    {\r\n        require(timestamp <= UINT32_MAX, \"timestamp overflow\");\r\n        require(priceSeconds <= UINT224_MAX, \"priceSeconds overflow\");\r\n        // (Note: this assignment only stores because olderStoredPrice has modifier \"storage\" - ie, store by reference!)\r\n        (olderStoredPrice.timestamp, olderStoredPrice.priceSeconds) = (uint32(timestamp), uint224(priceSeconds));\r\n    }\r\n\r\n    function storedPriceToCompareVs(uint newTimestamp, CumulativePrice storage newerStoredPrice)\r\n        internal view returns (CumulativePrice storage refPrice)\r\n    {\r\n        bool aAcceptable = areNewAndStoredPriceFarEnoughApart(newTimestamp, storedPriceA);\r\n        bool bAcceptable = areNewAndStoredPriceFarEnoughApart(newTimestamp, storedPriceB);\r\n        if (aAcceptable) {\r\n            if (bAcceptable) {\r\n                refPrice = newerStoredPrice;        // Neither is *too* recent, so return the fresher of the two\r\n            } else {\r\n                refPrice = storedPriceA;            // Only A is acceptable\r\n            }\r\n        } else if (bAcceptable) {\r\n            refPrice = storedPriceB;                // Only B is acceptable\r\n        } else {\r\n            revert(\"Both stored prices too recent\");\r\n        }\r\n    }\r\n\r\n    function orderedStoredPrices() internal view\r\n        returns (CumulativePrice storage olderStoredPrice, CumulativePrice storage newerStoredPrice)\r\n    {\r\n        (olderStoredPrice, newerStoredPrice) = storedPriceB.timestamp > storedPriceA.timestamp ?\r\n            (storedPriceA, storedPriceB) : (storedPriceB, storedPriceA);\r\n    }\r\n\r\n    function areNewAndStoredPriceFarEnoughApart(uint newTimestamp, CumulativePrice storage storedPrice) internal view\r\n        returns (bool farEnough)\r\n    {\r\n        farEnough = newTimestamp >= storedPrice.timestamp + MIN_TWAP_PERIOD;    // No risk of overflow on a uint32\r\n    }\r\n\r\n    /**\r\n     * @return timestamp Timestamp at which Uniswap stored the priceSeconds.\r\n     * @return priceSeconds Our pair's cumulative \"price-seconds\", using Uniswap's TWAP logic.  Eg, if at time t0\r\n     * priceSeconds = 10,000,000 (returned here as 10,000,000 * 10**18, ie, in WAD fixed-point format), and during the 30\r\n     * seconds between t0 and t1 = t0 + 30, the price is $45.67, then at time t1, priceSeconds = 10,000,000 + 30 * 45.67 =\r\n     * 10,001,370.1 (stored as 10,001,370.1 * 10**18).\r\n     */\r\n    function cumulativePrice()\r\n        private view returns (uint timestamp, uint priceSeconds)\r\n    {\r\n        (, , timestamp) = uniswapPair.getReserves();\r\n\r\n        // Retrieve the current Uniswap cumulative price.  Modeled off of Uniswap's own example:\r\n        // https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\r\n        uint uniswapCumPrice = tokensInReverseOrder ?\r\n            uniswapPair.price1CumulativeLast() :\r\n            uniswapPair.price0CumulativeLast();\r\n        priceSeconds = uniswapCumPrice.mul(scaleFactor) / UNISWAP_CUM_PRICE_SCALE_FACTOR;\r\n    }\r\n\r\n    /**\r\n     * @param newTimestamp in seconds (eg, 1606764888) - not WAD-scaled!\r\n     * @param newPriceSeconds WAD-scaled.\r\n     * @param oldTimestamp in raw seconds again.\r\n     * @param oldPriceSeconds WAD-scaled.\r\n     * @return price WAD-scaled.\r\n     */\r\n    function calculateTWAP(uint newTimestamp, uint newPriceSeconds, uint oldTimestamp, uint oldPriceSeconds)\r\n        private pure returns (uint price)\r\n    {\r\n        price = (newPriceSeconds.sub(oldPriceSeconds)).div(newTimestamp.sub(oldTimestamp));\r\n    }\r\n}\r\n\r\n// File: contracts/oracles/MedianOracle.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\ncontract MedianOracle is ChainlinkOracle, CompoundOpenOracle, OurUniswapV2TWAPOracle {\r\n    using SafeMath for uint;\r\n\r\n    constructor(\r\n        AggregatorV3Interface chainlinkAggregator,\r\n        UniswapAnchoredView compoundView,\r\n        IUniswapV2Pair uniswapPair, uint uniswapToken0Decimals, uint uniswapToken1Decimals, bool uniswapTokensInReverseOrder\r\n    ) public\r\n        ChainlinkOracle(chainlinkAggregator)\r\n        CompoundOpenOracle(compoundView)\r\n        OurUniswapV2TWAPOracle(uniswapPair, uniswapToken0Decimals, uniswapToken1Decimals, uniswapTokensInReverseOrder) {}\r\n\r\n    function latestPrice() public override(ChainlinkOracle, CompoundOpenOracle, OurUniswapV2TWAPOracle)\r\n        view returns (uint price)\r\n    {\r\n        price = median(ChainlinkOracle.latestPrice(),\r\n                       CompoundOpenOracle.latestPrice(),\r\n                       OurUniswapV2TWAPOracle.latestPrice());\r\n    }\r\n\r\n    function cacheLatestPrice() public virtual override(Oracle, OurUniswapV2TWAPOracle) returns (uint price) {\r\n        price = median(ChainlinkOracle.latestPrice(),              // Not ideal to call latestPrice() on two of these\r\n                       CompoundOpenOracle.latestPrice(),           // and cacheLatestPrice() on one...  But works, and\r\n                       OurUniswapV2TWAPOracle.cacheLatestPrice()); // inheriting them like this saves significant gas\r\n    }\r\n\r\n    /**\r\n     * @notice Currently only supports three inputs\r\n     * @return median value\r\n     */\r\n    function median(uint a, uint b, uint c)\r\n        private pure returns (uint)\r\n    {\r\n        bool ab = a > b;\r\n        bool bc = b > c;\r\n        bool ca = c > a;\r\n\r\n        return (ca == ab ? a : (ab == bc ? b : c));\r\n    }\r\n}\r\n\r\n// File: contracts/USM.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ncontract USM is USMTemplate, MedianOracle {\r\n    constructor(\r\n        AggregatorV3Interface chainlinkAggregator,\r\n        UniswapAnchoredView compoundView,\r\n        IUniswapV2Pair uniswapPair, uint uniswapToken0Decimals, uint uniswapToken1Decimals, bool uniswapTokensInReverseOrder\r\n    ) public\r\n        USMTemplate()\r\n        MedianOracle(chainlinkAggregator, compoundView,\r\n                     uniswapPair, uniswapToken0Decimals, uniswapToken1Decimals, uniswapTokensInReverseOrder) {}\r\n\r\n    function cacheLatestPrice() public virtual override(Oracle, MedianOracle) returns (uint price) {\r\n        price = super.cacheLatestPrice();\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"chainlinkAggregator\",\"type\":\"address\"},{\"internalType\":\"contract UniswapAnchoredView\",\"name\":\"compoundView\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"uniswapPair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uniswapToken0Decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uniswapToken1Decimals\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"uniswapTokensInReverseOrder\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previous\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"latest\",\"type\":\"uint256\"}],\"name\":\"BuySellAdjustmentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previous\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"latest\",\"type\":\"uint256\"}],\"name\":\"MinFumBuyPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUY_SELL_ADJUSTMENT_HALF_LIFE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DELEGABLE_DOMAIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DEBT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FUM_BUY_PRICE_HALF_LIFE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_TWAP_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SIGNATURE_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_CUM_PRICE_SCALE_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"addDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"addDelegateBySignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usmToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEthOut\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySellAdjustment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"adjustment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySellAdjustmentStored\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"value\",\"type\":\"uint224\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cacheLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fumToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEthOut\",\"type\":\"uint256\"}],\"name\":\"defund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fumToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEthOut\",\"type\":\"uint256\"}],\"name\":\"defundFromFUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum WadMath.Round\",\"name\":\"upOrDown\",\"type\":\"uint8\"}],\"name\":\"ethBuffer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"buffer\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum WadMath.Round\",\"name\":\"upOrDown\",\"type\":\"uint8\"}],\"name\":\"ethToUsm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usmOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fum\",\"outputs\":[{\"internalType\":\"contract FUM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum USMTemplate.Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"fumPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFumOut\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fumOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestChainlinkPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestCompoundPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestUniswapTWAPPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFumBuyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mfbp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFumBuyPriceStored\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"value\",\"type\":\"uint224\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minUsmOut\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usmOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"revokeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"signatureCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum USMTemplate.Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"usmPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usmAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum WadMath.Round\",\"name\":\"upOrDown\",\"type\":\"uint8\"}],\"name\":\"usmToEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"USM","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419000000000000000000000000922018674c12a7f0d394ebeef9b58f186cde13c1000000000000000000000000b4e16d0168e52d35cacd2c6185b44281ec28c9dc000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fd245a8c7efcaae4a65f2731cc7c0b6ef0618a52b60ff0bd544639bc84dba515"}]}