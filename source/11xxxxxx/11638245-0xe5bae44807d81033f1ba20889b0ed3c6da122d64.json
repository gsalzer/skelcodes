{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/mcd/MCDLoanInfo.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./saver/MCDSaverProxyHelper.sol\\\";\\nimport \\\"../interfaces/Spotter.sol\\\";\\n\\ncontract MCDLoanInfo is MCDSaverProxyHelper {\\n\\n    Manager public constant manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\\n    Vat public constant vat = Vat(0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B);\\n    Spotter public constant spotter = Spotter(0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3);\\n\\n    struct VaultInfo {\\n        address owner;\\n        uint256 ratio;\\n    \\tuint256 collateral;\\n    \\tuint256 debt;\\n    \\tbytes32 ilk;\\n    \\taddress urn;\\n    }\\n\\n\\t/// @notice Gets a price of the asset\\n    /// @param _ilk Ilk of the CDP\\n    function getPrice(bytes32 _ilk) public view returns (uint) {\\n        (, uint mat) = spotter.ilks(_ilk);\\n        (,,uint spot,,) = vat.ilks(_ilk);\\n\\n        return rmul(rmul(spot, spotter.par()), mat);\\n    }\\n\\n    /// @notice Gets CDP ratio\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    function getRatio(uint _cdpId, bytes32 _ilk) public view returns (uint) {\\n        uint price = getPrice( _ilk);\\n\\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\\n\\n        if (debt == 0) return 0;\\n\\n        return rdiv(wmul(collateral, price), debt);\\n    }\\n\\n    /// @notice Gets CDP info (collateral, debt, price, ilk)\\n    /// @param _cdpId Id of the CDP\\n    function getVaultInfo(uint _cdpId) public view returns (VaultInfo memory vaultInfo) {\\n        address urn = manager.urns(_cdpId);\\n        bytes32 ilk = manager.ilks(_cdpId);\\n\\n        (uint256 collateral, uint256 debt) = vat.urns(ilk, urn);\\n        (,uint rate,,,) = vat.ilks(ilk);\\n\\n        debt = rmul(debt, rate);\\n\\n        vaultInfo = VaultInfo({\\n            owner: manager.owns(_cdpId),\\n            ratio: getRatio(_cdpId, ilk),\\n            collateral: collateral,\\n            debt: debt,\\n            ilk: ilk,\\n            urn: urn\\n        });\\n    }\\n\\n    function getVaultInfos(uint256[] memory _cdps) public view returns (VaultInfo[] memory vaultInfos) {\\n    \\tvaultInfos = new VaultInfo[](_cdps.length);\\n\\n    \\tfor (uint256 i = 0; i < _cdps.length; i++) {\\n    \\t\\tvaultInfos[i] = getVaultInfo(_cdps[i]);\\n    \\t}\\n    }\\n\\n    function getRatios(uint256[] memory _cdps) public view returns (uint[] memory ratios) {\\n    \\tratios = new uint256[](_cdps.length);\\n\\n    \\tfor (uint256 i = 0; i<_cdps.length; i++) {\\n    \\t\\tbytes32 ilk = manager.ilks(_cdps[i]);\\n\\n    \\t\\tratios[i] = getRatio(_cdps[i], ilk);\\n    \\t}\\n    }\\n}\"\r\n    },\r\n    \"contracts/mcd/saver/MCDSaverProxyHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../DS/DSMath.sol\\\";\\nimport \\\"../../DS/DSProxy.sol\\\";\\nimport \\\"../../interfaces/Manager.sol\\\";\\nimport \\\"../../interfaces/Join.sol\\\";\\nimport \\\"../../interfaces/Vat.sol\\\";\\n\\n/// @title Helper methods for MCDSaverProxy\\ncontract MCDSaverProxyHelper is DSMath {\\n\\n    /// @notice Returns a normalized debt _amount based on the current rate\\n    /// @param _amount Amount of dai to be normalized\\n    /// @param _rate Current rate of the stability fee\\n    /// @param _daiVatBalance Balance od Dai in the Vat for that CDP\\n    function normalizeDrawAmount(uint _amount, uint _rate, uint _daiVatBalance) internal pure returns (int dart) {\\n        if (_daiVatBalance < mul(_amount, RAY)) {\\n            dart = toPositiveInt(sub(mul(_amount, RAY), _daiVatBalance) / _rate);\\n            dart = mul(uint(dart), _rate) < mul(_amount, RAY) ? dart + 1 : dart;\\n        }\\n    }\\n\\n    /// @notice Converts a number to Rad percision\\n    /// @param _wad The input number in wad percision\\n    function toRad(uint _wad) internal pure returns (uint) {\\n        return mul(_wad, 10 ** 27);\\n    }\\n\\n    /// @notice Converts a number to 18 decimal percision\\n    /// @param _joinAddr Join address of the collateral\\n    /// @param _amount Number to be converted\\n    function convertTo18(address _joinAddr, uint256 _amount) internal view returns (uint256) {\\n        return mul(_amount, 10 ** (18 - Join(_joinAddr).dec()));\\n    }\\n\\n    /// @notice Converts a uint to int and checks if positive\\n    /// @param _x Number to be converted\\n    function toPositiveInt(uint _x) internal pure returns (int y) {\\n        y = int(_x);\\n        require(y >= 0, \\\"int-overflow\\\");\\n    }\\n\\n    /// @notice Gets Dai amount in Vat which can be added to Cdp\\n    /// @param _vat Address of Vat contract\\n    /// @param _urn Urn of the Cdp\\n    /// @param _ilk Ilk of the Cdp\\n    function normalizePaybackAmount(address _vat, address _urn, bytes32 _ilk) internal view returns (int amount) {\\n        uint dai = Vat(_vat).dai(_urn);\\n\\n        (, uint rate,,,) = Vat(_vat).ilks(_ilk);\\n        (, uint art) = Vat(_vat).urns(_ilk, _urn);\\n\\n        amount = toPositiveInt(dai / rate);\\n        amount = uint(amount) <= art ? - amount : - toPositiveInt(art);\\n    }\\n\\n    /// @notice Gets the whole debt of the CDP\\n    /// @param _vat Address of Vat contract\\n    /// @param _usr Address of the Dai holder\\n    /// @param _urn Urn of the Cdp\\n    /// @param _ilk Ilk of the Cdp\\n    function getAllDebt(address _vat, address _usr, address _urn, bytes32 _ilk) internal view returns (uint daiAmount) {\\n        (, uint rate,,,) = Vat(_vat).ilks(_ilk);\\n        (, uint art) = Vat(_vat).urns(_ilk, _urn);\\n        uint dai = Vat(_vat).dai(_usr);\\n\\n        uint rad = sub(mul(art, rate), dai);\\n        daiAmount = rad / RAY;\\n\\n        daiAmount = mul(daiAmount, RAY) < rad ? daiAmount + 1 : daiAmount;\\n    }\\n\\n    /// @notice Gets the token address from the Join contract\\n    /// @param _joinAddr Address of the Join contract\\n    function getCollateralAddr(address _joinAddr) internal view returns (address) {\\n        return address(Join(_joinAddr).gem());\\n    }\\n\\n    /// @notice Checks if the join address is one of the Ether coll. types\\n    /// @param _joinAddr Join address to check\\n    function isEthJoinAddr(address _joinAddr) internal view returns (bool) {\\n        // if it's dai_join_addr don't check gem() it will fail\\n        if (_joinAddr == 0x9759A6Ac90977b93B58547b4A71c78317f391A28) return false;\\n\\n        // if coll is weth it's and eth type coll\\n        if (address(Join(_joinAddr).gem()) == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Gets CDP info (collateral, debt)\\n    /// @param _manager Manager contract\\n    /// @param _cdpId Id of the CDP\\n    /// @param _ilk Ilk of the CDP\\n    function getCdpInfo(Manager _manager, uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\\n        address vat = _manager.vat();\\n        address urn = _manager.urns(_cdpId);\\n\\n        (uint collateral, uint debt) = Vat(vat).urns(_ilk, urn);\\n        (,uint rate,,,) = Vat(vat).ilks(_ilk);\\n\\n        return (collateral, rmul(debt, rate));\\n    }\\n\\n    /// @notice Address that owns the DSProxy that owns the CDP\\n    /// @param _manager Manager contract\\n    /// @param _cdpId Id of the CDP\\n    function getOwner(Manager _manager, uint _cdpId) public view returns (address) {\\n        DSProxy proxy = DSProxy(uint160(_manager.owns(_cdpId)));\\n\\n        return proxy.owner();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Spotter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./PipInterface.sol\\\";\\n\\nabstract contract Spotter {\\n    struct Ilk {\\n        PipInterface pip;\\n        uint256 mat;\\n    }\\n\\n    mapping (bytes32 => Ilk) public ilks;\\n\\n    uint256 public par;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\ncontract DSMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x);\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x);\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x / y;\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint256 constant WAD = 10**18;\\n    uint256 constant RAY = 10**27;\\n\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./DSAuth.sol\\\";\\nimport \\\"./DSNote.sol\\\";\\n\\n\\nabstract contract DSProxy is DSAuth, DSNote {\\n    DSProxyCache public cache; // global cache for contracts\\n\\n    constructor(address _cacheAddr) public {\\n        require(setCache(_cacheAddr));\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {}\\n\\n    // use the proxy to execute calldata _data on contract _code\\n    // function execute(bytes memory _code, bytes memory _data)\\n    //     public\\n    //     payable\\n    //     virtual\\n    //     returns (address target, bytes32 response);\\n\\n    function execute(address _target, bytes memory _data)\\n        public\\n        payable\\n        virtual\\n        returns (bytes32 response);\\n\\n    //set new cache\\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\\n}\\n\\n\\ncontract DSProxyCache {\\n    mapping(bytes32 => address) cache;\\n\\n    function read(bytes memory _code) public view returns (address) {\\n        bytes32 hash = keccak256(_code);\\n        return cache[hash];\\n    }\\n\\n    function write(bytes memory _code) public returns (address target) {\\n        assembly {\\n            target := create(0, add(_code, 0x20), mload(_code))\\n            switch iszero(extcodesize(target))\\n                case 1 {\\n                    // throw if contract failed to deploy\\n                    revert(0, 0)\\n                }\\n        }\\n        bytes32 hash = keccak256(_code);\\n        cache[hash] = target;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Manager.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract Manager {\\n    function last(address) virtual public returns (uint);\\n    function cdpCan(address, uint, address) virtual public view returns (uint);\\n    function ilks(uint) virtual public view returns (bytes32);\\n    function owns(uint) virtual public view returns (address);\\n    function urns(uint) virtual public view returns (address);\\n    function vat() virtual public view returns (address);\\n    function open(bytes32, address) virtual public returns (uint);\\n    function give(uint, address) virtual public;\\n    function cdpAllow(uint, address, uint) virtual public;\\n    function urnAllow(address, uint) virtual public;\\n    function frob(uint, int, int) virtual public;\\n    function flux(uint, address, uint) virtual public;\\n    function move(uint, address, uint) virtual public;\\n    function exit(address, uint, address, uint) virtual public;\\n    function quit(uint, address) virtual public;\\n    function enter(address, uint) virtual public;\\n    function shift(uint, uint) virtual public;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Join.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./Gem.sol\\\";\\n\\nabstract contract Join {\\n    bytes32 public ilk;\\n\\n    function dec() virtual public view returns (uint);\\n    function gem() virtual public view returns (Gem);\\n    function join(address, uint) virtual public payable;\\n    function exit(address, uint) virtual public;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Vat.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract Vat {\\n\\n    struct Urn {\\n        uint256 ink;   // Locked Collateral  [wad]\\n        uint256 art;   // Normalised Debt    [wad]\\n    }\\n\\n    struct Ilk {\\n        uint256 Art;   // Total Normalised Debt     [wad]\\n        uint256 rate;  // Accumulated Rates         [ray]\\n        uint256 spot;  // Price with Safety Margin  [ray]\\n        uint256 line;  // Debt Ceiling              [rad]\\n        uint256 dust;  // Urn Debt Floor            [rad]\\n    }\\n\\n    mapping (bytes32 => mapping (address => Urn )) public urns;\\n    mapping (bytes32 => Ilk)                       public ilks;\\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\\n\\n    function can(address, address) virtual public view returns (uint);\\n    function dai(address) virtual public view returns (uint);\\n    function frob(bytes32, address, address, address, int, int) virtual public;\\n    function hope(address) virtual public;\\n    function move(address, address, uint) virtual public;\\n    function fork(bytes32, address, address, int, int) virtual public;\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSAuth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./DSAuthority.sol\\\";\\n\\n\\ncontract DSAuthEvents {\\n    event LogSetAuthority(address indexed authority);\\n    event LogSetOwner(address indexed owner);\\n}\\n\\n\\ncontract DSAuth is DSAuthEvents {\\n    DSAuthority public authority;\\n    address public owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        emit LogSetOwner(msg.sender);\\n    }\\n\\n    function setOwner(address owner_) public auth {\\n        owner = owner_;\\n        emit LogSetOwner(owner);\\n    }\\n\\n    function setAuthority(DSAuthority authority_) public auth {\\n        authority = authority_;\\n        emit LogSetAuthority(address(authority));\\n    }\\n\\n    modifier auth {\\n        require(isAuthorized(msg.sender, msg.sig));\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n        if (src == address(this)) {\\n            return true;\\n        } else if (src == owner) {\\n            return true;\\n        } else if (authority == DSAuthority(0)) {\\n            return false;\\n        } else {\\n            return authority.canCall(src, address(this), sig);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSNote.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\ncontract DSNote {\\n    event LogNote(\\n        bytes4 indexed sig,\\n        address indexed guy,\\n        bytes32 indexed foo,\\n        bytes32 indexed bar,\\n        uint256 wad,\\n        bytes fax\\n    ) anonymous;\\n\\n    modifier note {\\n        bytes32 foo;\\n        bytes32 bar;\\n\\n        assembly {\\n            foo := calldataload(4)\\n            bar := calldataload(36)\\n        }\\n\\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSAuthority.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract DSAuthority {\\n    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Gem.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract Gem {\\n    function dec() virtual public returns (uint);\\n    function gem() virtual public returns (Gem);\\n    function join(address, uint) virtual public payable;\\n    function exit(address, uint) virtual public;\\n\\n    function approve(address, uint) virtual public;\\n    function transfer(address, uint) virtual public returns (bool);\\n    function transferFrom(address, address, uint) virtual public returns (bool);\\n    function deposit() virtual public payable;\\n    function withdraw(uint) virtual public;\\n    function allowance(address, address) virtual public returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/PipInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract PipInterface {\\n    function read() public virtual returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Manager\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_ilk\",\"type\":\"bytes32\"}],\"name\":\"getCdpInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Manager\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ilk\",\"type\":\"bytes32\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_ilk\",\"type\":\"bytes32\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_cdps\",\"type\":\"uint256[]\"}],\"name\":\"getRatios\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ratios\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"}],\"name\":\"getVaultInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"urn\",\"type\":\"address\"}],\"internalType\":\"struct MCDLoanInfo.VaultInfo\",\"name\":\"vaultInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_cdps\",\"type\":\"uint256[]\"}],\"name\":\"getVaultInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"urn\",\"type\":\"address\"}],\"internalType\":\"struct MCDLoanInfo.VaultInfo[]\",\"name\":\"vaultInfos\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract Manager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spotter\",\"outputs\":[{\"internalType\":\"contract Spotter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract Vat\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MCDLoanInfo","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}