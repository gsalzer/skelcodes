{"status":"1","message":"OK","result":[{"SourceCode":"{\"GazeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.1;\\n\\nimport \\\"./Owned.sol\\\";\\n\\ncontract gazeERC20 is Owned {\\n    // Public variables of the token\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it\\n    uint256 public totalSupply;\\n\\n    mapping (address =\\u003e uint256) public balanceOf;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowance;\\n\\n    // Below are public events on the blockchain that will notify clients\\n\\t\\n\\t// This notifies clients about the tokens amount transfer between accounts \\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    \\n    // This notifies clients about the tokens amount approved to _spender to use on account _owner\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n\\n    // This notifies clients about the tokens amount burnt\\n    event Burn(address indexed _from, uint256 _value);\\n\\t\\n\\t// This notifies clients about the tokens amount minted\\n    event Mint(address indexed _to, uint256 _value);\\n\\n\\n    /**\\n     * Constructor function\\n     *\\n     * Initializes contract with initial supply tokens to the creator of the contract\\n\\t *\\n\\t * @param _initialSupply Total initial amount of tokens\\n     * @param _name full name of the token\\n\\t * @param _symbol short name of the token\\n     */\\n    constructor (\\n        uint256 _initialSupply,\\n        string memory _name,\\n        string memory _symbol\\n    ) public {\\n\\t\\trequire(_initialSupply\\u003e0);\\n        totalSupply = _initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\\n        balanceOf[msg.sender] = totalSupply;                \\t // Give the contract owner all initial tokens\\n        name = _name;  \\n        symbol = _symbol;\\n    }\\n\\n    /**\\n     * Internal transfer, only can be called by this contract\\n     */\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n\\t\\trequire(_from != address(0), \\\"transfer attempt from zero address\\\"); // Prevent transfer from 0x0 address.\\n        require(_to != address(0), \\\"transfer attempt to zero address\\\"); // Prevent transfer to 0x0 address.\\n        require(balanceOf[_from] \\u003e= _value, \\\"from address balance is not enough\\\");\\n        require(balanceOf[_to] + _value \\u003e= balanceOf[_to], \\\"destination address balance overflow\\\"); // Check for overflows\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n     * Transfer tokens\\n     *\\n     * Send `_value` tokens to `_to` from your account\\n     *\\n     * @param _to The address of the recipient\\n     * @param _value The amount of token minimal units (10**(-18)) to send\\n     */\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * Transfer tokens from other address\\n     *\\n     * Send `_value` tokens to `_to` on behalf of `_from`\\n     *\\n     * @param _from The address of the sender\\n     * @param _to The address of the recipient\\n     * @param _value The amount of token minimal units (10**(-18)) to send\\n     */\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\n        require(_value \\u003c= allowance[_from][msg.sender], \\\"transfer not allowed\\\");     // Check allowance\\n        allowance[_from][msg.sender] -= _value;\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * Set allowance for other address\\n     *\\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\\n     *\\n     * @param _spender The address authorized to spend\\n     * @param _value The max amount of token minimal units (10**(-18)) it can spend\\n     */\\n    function approve(address _spender, uint256 _value) public returns (bool) {\\n\\t\\trequire(_spender != address(0));\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * Destroy tokens from other account\\n     *\\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\\n     *\\n     * @param _from the address of the sender\\n     * @param _value the amount of token minimal units (10**(-18)) to burn\\n     */\\n    function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool) {\\n        require(balanceOf[_from] \\u003e= _value, \\\"address balance is smaller, than amount to burn\\\");\\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\\n        totalSupply -= _value;                              // Update totalSupply\\n        emit Burn(_from, _value);\\n\\t\\tassert(totalSupply \\u003e= 0);\\n        return true;\\n    }\\n\\t\\n   /**\\n     * Destroy tokens\\n     *\\n     * Remove `_value` tokens from the system irreversibly\\n     *\\n     * @param _value the amount of token minimal units (10**(-18)) to burn\\n     */\\n    function burn(uint256 _value) public onlyOwner returns (bool) {\\n        return burnFrom(msg.sender, _value);\\n    }\\n\\t\\n    /**\\n     * Create new tokens to account\\n\\t *\\n\\t * Create _mintAmount of new tokens to account _target\\n\\t *\\n\\t * @param _mintAmount the amount of token minimal units (10**(-18)) to mint\\n\\t * @param _target the address to own new mint tokens\\n     *\\n     * Internal function, can be called from the contract and it\\u0027s children contracts only\\n     */\\n\\tfunction _mintToken(address _target, uint256 _mintAmount) internal {\\n\\t\\trequire(_target != address(0), \\\"mint attempt to zero address\\\"); // Prevent mint to 0x0 address.\\n\\t\\trequire(totalSupply + _mintAmount \\u003e totalSupply);\\n        balanceOf[_target] += _mintAmount;\\n        totalSupply += _mintAmount;\\n        emit Mint(_target, _mintAmount);\\n    }\\n\\t\\n\\t/**\\n     * Create tokens to account\\n     *\\n     * Create `_mintAmount` tokens  and set them to _target account.\\n     *\\n     * @param _target the address for new tokens\\n     * @param _mintAmount the amount of token minimal units (10**(-18)) to create\\n     */\\n\\tfunction mintToken(address _target, uint256 _mintAmount) public onlyOwner returns (bool) {\\n\\t\\t_mintToken(_target, _mintAmount);\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t/**\\n     * Destroy contract\\n     *\\n\\t * @param _beneficiary Address to send all contract\\u0027s Ether balance\\n     */\\n\\tfunction destroy(address payable _beneficiary) public onlyOwner {\\n\\t\\trequire(_beneficiary != address(0), \\\"beneficiary is zero address\\\");\\n\\t\\tselfdestruct(_beneficiary);\\n\\t}\\n\\t\\n\\treceive() external payable { \\n\\t\\trevert();\\n\\t}\\n}\"},\"Owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.6.1;\\r\\n\\r\\ncontract Owned {\\r\\n\\taddress payable internal owner;\\r\\n\\r\\n\\tconstructor() internal {\\r\\n\\t\\towner = msg.sender;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyOwner {\\r\\n\\t\\trequire(msg.sender == owner);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tfunction transferOwnership(address payable newOwner) public onlyOwner {\\r\\n\\t\\towner = newOwner;\\r\\n\\t}\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_mintAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"gazeERC20","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000003b9aca00000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000647617a6554560000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000447415a4500000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://36bf66f3b547870b414a690b8bd80e07b8f0240d32d3da5ca5737661a1bc65fb"}]}