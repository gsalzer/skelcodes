{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath64 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        uint64 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\r\n        require(b <= a, errorMessage);\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint64 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint64 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/Proxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n            }\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n}\r\n\r\n// File: contracts/external/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param _newImplementation address representing the new implementation to be set\r\n    */\r\n    function _setImplementation(address _newImplementation) internal {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n        sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address _newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor(address _implementation) public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\r\n        require(_newOwner != address(0));\r\n        _setUpgradeabilityOwner(_newOwner);\r\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param _implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address _implementation) public onlyProxyOwner {\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            sstore(position, _newProxyOwner)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IMarketUtility.sol\r\n\r\npragma solidity 0.5.7;\r\ncontract IMarketUtility {\r\n\r\n    function initialize(address payable[] calldata _addressParams, address _initiater) external;\r\n\r\n\t/**\r\n     * @dev to Set authorized address to update parameters \r\n     */\r\n    function setAuthorizedAddres() public;\r\n\r\n\t/**\r\n     * @dev to update uint parameters in Market Config \r\n     */\r\n    function updateUintParameters(bytes8 code, uint256 value) external;\r\n\r\n    /**\r\n     * @dev to Update address parameters in Market Config \r\n     */\r\n    function updateAddressParameters(bytes8 code, address payable value) external;\r\n \r\n     /**\r\n    * @dev Get Parameters required to initiate market\r\n    * @return Addresses of tokens to be distributed as incentives\r\n    * @return Cool down time for market\r\n    * @return Rate\r\n    * @return Commission percent for predictions with ETH\r\n    * @return Commission percent for predictions with PLOT\r\n    **/\r\n    function getMarketInitialParams() public view returns(address[] memory, uint , uint, uint, uint);\r\n\r\n    function getAssetPriceUSD(address _currencyAddress) external view returns(uint latestAnswer);\r\n    \r\n    function getPriceFeedDecimals(address _priceFeed) public view returns(uint8);\r\n\r\n    function getValueAndMultiplierParameters(address _asset, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    function update() external;\r\n    \r\n    function calculatePredictionValue(uint[] memory params, address asset, address user, address marketFeedAddress, bool _checkMultiplier) public view returns(uint _predictionValue, bool _multiplierApplied);\r\n    \r\n    /**\r\n     * @dev Get basic market details\r\n     * @return Minimum amount required to predict in market\r\n     * @return Percentage of users leveraged amount to deduct when placed in wrong prediction\r\n     * @return Decimal points for prediction positions\r\n     **/\r\n    function getBasicMarketDetails()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function getDisputeResolutionParams() public view returns (uint256);\r\n    function calculateOptionPrice(uint[] memory params, address marketFeedAddress) public view returns(uint _optionPrice);\r\n\r\n    /**\r\n     * @dev Get price of provided feed address\r\n     * @param _currencyFeedAddress  Feed Address of currency on which market options are based on\r\n     * @return Current price of the market currency\r\n     **/\r\n    function getSettlemetPrice(\r\n        address _currencyFeedAddress,\r\n        uint256 _settleTime\r\n    ) public view returns (uint256 latestAnswer, uint256 roundId);\r\n\r\n    /**\r\n     * @dev Get value of provided currency address in ETH\r\n     * @param _currencyAddress Address of currency\r\n     * @param _amount Amount of provided currency\r\n     * @return Value of provided amount in ETH\r\n     **/\r\n    function getAssetValueETH(address _currencyAddress, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256 tokenEthValue);\r\n}\r\n\r\n// File: contracts/interfaces/IToken.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IToken {\r\n\r\n    function decimals() external view returns(uint8);\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param account The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param recipient The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev function that mints an amount of the token and assigns it to\r\n    * an account.\r\n    * @param account The account that will receive the created tokens.\r\n    * @param amount The amount that will be created.\r\n    */\r\n    function mint(address account, uint256 amount) external returns (bool);\r\n    \r\n     /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burn(uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param sender address The address which you want to send tokens from\r\n    * @param recipient address The address which you want to transfer to\r\n    * @param amount uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ITokenController.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract ITokenController {\r\n\taddress public token;\r\n    address public bLOTToken;\r\n\r\n    /**\r\n    * @dev Swap BLOT token.\r\n    * account.\r\n    * @param amount The amount that will be swapped.\r\n    */\r\n    function swapBLOT(address _of, address _to, uint256 amount) public;\r\n\r\n    function totalBalanceOf(address _of)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burnCommissionTokens(uint256 amount) external returns(bool);\r\n \r\n    function initiateVesting(address _vesting) external;\r\n\r\n    function lockForGovernanceVote(address _of, uint _days) public;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function mint(address _member, uint _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IMarketRegistry.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IMarketRegistry {\r\n\r\n    enum MarketType {\r\n      HourlyMarket,\r\n      DailyMarket,\r\n      WeeklyMarket\r\n    }\r\n    address public owner;\r\n    address public tokenController;\r\n    address public marketUtility;\r\n    bool public marketCreationPaused;\r\n\r\n    mapping(address => bool) public isMarket;\r\n    function() external payable{}\r\n\r\n    function marketDisputeStatus(address _marketAddress) public view returns(uint _status);\r\n\r\n    function burnDisputedProposalTokens(uint _proposaId) external;\r\n\r\n    function isWhitelistedSponsor(address _address) public view returns(bool);\r\n\r\n    function transferAssets(address _asset, address _to, uint _amount) external;\r\n\r\n    /**\r\n    * @dev Initialize the PlotX.\r\n    * @param _marketConfig The address of market config.\r\n    * @param _plotToken The address of PLOT token.\r\n    */\r\n    function initiate(address _defaultAddress, address _marketConfig, address _plotToken, address payable[] memory _configParams) public;\r\n\r\n    /**\r\n    * @dev Create proposal if user wants to raise the dispute.\r\n    * @param proposalTitle The title of proposal created by user.\r\n    * @param description The description of dispute.\r\n    * @param solutionHash The ipfs solution hash.\r\n    * @param actionHash The action hash for solution.\r\n    * @param stakeForDispute The token staked to raise the diospute.\r\n    * @param user The address who raises the dispute.\r\n    */\r\n    function createGovernanceProposal(string memory proposalTitle, string memory description, string memory solutionHash, bytes memory actionHash, uint256 stakeForDispute, address user, uint256 ethSentToPool, uint256 tokenSentToPool, uint256 proposedValue) public {\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the PlacePrediction event and sets user data.\r\n    * @param _user The address who placed prediction.\r\n    * @param _value The amount of ether user staked.\r\n    * @param _predictionPoints The positions user will get.\r\n    * @param _predictionAsset The prediction assets user will get.\r\n    * @param _prediction The option range on which user placed prediction.\r\n    * @param _leverage The leverage selected by user at the time of place prediction.\r\n    */\r\n    function setUserGlobalPredictionData(address _user,uint _value, uint _predictionPoints, address _predictionAsset, uint _prediction,uint _leverage) public{\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the claimed event.\r\n    * @param _user The address who claim their reward.\r\n    * @param _reward The reward which is claimed by user.\r\n    * @param incentives The incentives of user.\r\n    * @param incentiveToken The incentive tokens of user.\r\n    */\r\n    function callClaimedEvent(address _user , uint[] memory _reward, address[] memory predictionAssets, uint incentives, address incentiveToken) public {\r\n    }\r\n\r\n        /**\r\n    * @dev Emits the MarketResult event.\r\n    * @param _totalReward The amount of reward to be distribute.\r\n    * @param _winningOption The winning option of the market.\r\n    * @param _closeValue The closing value of the market currency.\r\n    */\r\n    function callMarketResultEvent(uint[] memory _totalReward, uint _winningOption, uint _closeValue, uint roundId) public {\r\n    }\r\n}\r\n\r\n// File: contracts/Market.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Market {\r\n    using SafeMath for *;\r\n\r\n    enum PredictionStatus {\r\n      Live,\r\n      InSettlement,\r\n      Cooling,\r\n      InDispute,\r\n      Settled\r\n    }\r\n    \r\n    struct option\r\n    {\r\n      uint predictionPoints;\r\n      mapping(address => uint256) assetStaked;\r\n      mapping(address => uint256) assetLeveraged;\r\n    }\r\n\r\n    struct MarketSettleData {\r\n      uint64 WinningOption;\r\n      uint64 settleTime;\r\n    }\r\n\r\n    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address constant marketFeedAddress = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\r\n    address constant plotToken = 0x72F020f8f3E8fd9382705723Cd26380f8D0c66Bb;\r\n\r\n    IMarketRegistry constant marketRegistry = IMarketRegistry(0xE210330d6768030e816d223836335079C7A0c851);\r\n    ITokenController constant tokenController = ITokenController(0x12d7053Efc680Ba6671F8Cb96d1421D906ce3dE2);\r\n    IMarketUtility constant marketUtility = IMarketUtility(0x2330058D49fA61D5C5405fA8B17fcD823c59F7Bb);\r\n\r\n    uint8 constant roundOfToNearest = 1;\r\n    uint constant totalOptions = 3;\r\n    uint constant MAX_LEVERAGE = 5;\r\n    uint constant ethCommissionPerc = 10; //with 2 decimals\r\n    uint constant plotCommissionPerc = 5; //with 2 decimals\r\n    bytes32 public constant marketCurrency = \"ETH/USD\";\r\n    \r\n    bool internal lockedForDispute;\r\n    address internal incentiveToken;\r\n    uint internal ethAmountToPool;\r\n    uint internal ethCommissionAmount;\r\n    uint internal plotCommissionAmount;\r\n    uint internal tokenAmountToPool;\r\n    uint internal incentiveToDistribute;\r\n    uint[] internal rewardToDistribute;\r\n    PredictionStatus internal predictionStatus;\r\n\r\n    \r\n    struct UserData {\r\n      bool claimedReward;\r\n      bool predictedWithBlot;\r\n      bool multiplierApplied;\r\n      mapping(uint => uint) predictionPoints;\r\n      mapping(address => mapping(uint => uint)) assetStaked;\r\n      mapping(address => mapping(uint => uint)) LeverageAsset;\r\n    }\r\n\r\n    struct MarketData {\r\n      uint64 startTime;\r\n      uint64 predictionTime;\r\n      uint64 neutralMinValue;\r\n      uint64 neutralMaxValue;\r\n    }\r\n\r\n    MarketData public marketData;\r\n    MarketSettleData public marketSettleData;\r\n\r\n    mapping(address => UserData) internal userData;\r\n\r\n    mapping(uint=>option) public optionsAvailable;\r\n\r\n    /**\r\n    * @dev Initialize the market.\r\n    * @param _startTime The time at which market will create.\r\n    * @param _predictionTime The time duration of market.\r\n    * @param _minValue The minimum value of neutral option range.\r\n    * @param _maxValue The maximum value of neutral option range.\r\n    */\r\n    function initiate(uint64 _startTime, uint64 _predictionTime, uint64 _minValue, uint64 _maxValue) public payable {\r\n      OwnedUpgradeabilityProxy proxy =  OwnedUpgradeabilityProxy(address(uint160(address(this))));\r\n      require(msg.sender == proxy.proxyOwner(),\"Sender is not proxy owner.\");\r\n      require(marketData.startTime == 0, \"Already initialized\");\r\n      require(_startTime.add(_predictionTime) > now);\r\n      marketData.startTime = _startTime;\r\n      marketData.predictionTime = _predictionTime;\r\n      \r\n      marketData.neutralMinValue = _minValue;\r\n      marketData.neutralMaxValue = _maxValue;\r\n    }\r\n\r\n    /**\r\n    * @dev Place prediction on the available options of the market.\r\n    * @param _asset The asset used by user during prediction whether it is plotToken address or in ether.\r\n    * @param _predictionStake The amount staked by user at the time of prediction.\r\n    * @param _prediction The option on which user placed prediction.\r\n    * @param _leverage The leverage opted by user at the time of prediction.\r\n    */\r\n    function placePrediction(address _asset, uint256 _predictionStake, uint256 _prediction,uint256 _leverage) public payable {\r\n      require(!marketRegistry.marketCreationPaused() && _prediction <= totalOptions && _leverage <= MAX_LEVERAGE);\r\n      require(now >= marketData.startTime && now <= marketExpireTime());\r\n\r\n      uint256 _commissionStake;\r\n      if(_asset == ETH_ADDRESS) {\r\n        require(_predictionStake == msg.value);\r\n        _commissionStake = _calculatePercentage(ethCommissionPerc, _predictionStake, 10000);\r\n        ethCommissionAmount = ethCommissionAmount.add(_commissionStake);\r\n      } else {\r\n        require(msg.value == 0);\r\n        if (_asset == plotToken){\r\n          tokenController.transferFrom(plotToken, msg.sender, address(this), _predictionStake);\r\n        } else {\r\n          require(_asset == tokenController.bLOTToken());\r\n          require(_leverage == MAX_LEVERAGE);\r\n          require(!userData[msg.sender].predictedWithBlot);\r\n          userData[msg.sender].predictedWithBlot = true;\r\n          tokenController.swapBLOT(msg.sender, address(this), _predictionStake);\r\n          _asset = plotToken;\r\n        }\r\n        _commissionStake = _calculatePercentage(plotCommissionPerc, _predictionStake, 10000);\r\n        plotCommissionAmount = plotCommissionAmount.add(_commissionStake);\r\n      }\r\n      _commissionStake = _predictionStake.sub(_commissionStake);\r\n\r\n\r\n      (uint predictionPoints, bool isMultiplierApplied) = calculatePredictionValue(_prediction, _commissionStake, _leverage, _asset);\r\n      if(isMultiplierApplied) {\r\n        userData[msg.sender].multiplierApplied = true; \r\n      }\r\n      require(predictionPoints > 0);\r\n\r\n      _storePredictionData(_prediction, _commissionStake, _asset, _leverage, predictionPoints);\r\n      marketRegistry.setUserGlobalPredictionData(msg.sender,_predictionStake, predictionPoints, _asset, _prediction, _leverage);\r\n    }\r\n\r\n    function calculatePredictionValue(uint _prediction, uint _predictionStake, uint _leverage, address _asset) internal view returns(uint predictionPoints, bool isMultiplierApplied) {\r\n      uint[] memory params = new uint[](11);\r\n      params[0] = _prediction;\r\n      params[1] = marketData.neutralMinValue;\r\n      params[2] = marketData.neutralMaxValue;\r\n      params[3] = marketData.startTime;\r\n      params[4] = marketExpireTime();\r\n      (params[5], params[6]) = getTotalAssetsStaked();\r\n      params[7] = optionsAvailable[_prediction].assetStaked[ETH_ADDRESS];\r\n      params[8] = optionsAvailable[_prediction].assetStaked[plotToken];\r\n      params[9] = _predictionStake;\r\n      params[10] = _leverage;\r\n      bool checkMultiplier;\r\n      if(!userData[msg.sender].multiplierApplied) {\r\n        checkMultiplier = true;\r\n      }\r\n      (predictionPoints, isMultiplierApplied) = marketUtility.calculatePredictionValue(params, _asset, msg.sender, marketFeedAddress, checkMultiplier);\r\n      \r\n    }\r\n\r\n    function getTotalAssetsStaked() public view returns(uint256 ethStaked, uint256 plotStaked) {\r\n      for(uint256 i = 1; i<= totalOptions;i++) {\r\n        ethStaked = ethStaked.add(optionsAvailable[i].assetStaked[ETH_ADDRESS]);\r\n        plotStaked = plotStaked.add(optionsAvailable[i].assetStaked[plotToken]);\r\n      }\r\n    }\r\n\r\n    function getTotalStakedValueInPLOT() public view returns(uint256) {\r\n      (uint256 ethStaked, uint256 plotStaked) = getTotalAssetsStaked();\r\n      (, ethStaked) = marketUtility.getValueAndMultiplierParameters(ETH_ADDRESS, ethStaked);\r\n      return plotStaked.add(ethStaked);\r\n    }\r\n\r\n    /**\r\n    * @dev Stores the prediction data.\r\n    * @param _prediction The option on which user place prediction.\r\n    * @param _predictionStake The amount staked by user at the time of prediction.\r\n    * @param _asset The asset used by user during prediction.\r\n    * @param _leverage The leverage opted by user during prediction.\r\n    * @param predictionPoints The positions user got during prediction.\r\n    */\r\n    function _storePredictionData(uint _prediction, uint _predictionStake, address _asset, uint _leverage, uint predictionPoints) internal {\r\n      userData[msg.sender].predictionPoints[_prediction] = userData[msg.sender].predictionPoints[_prediction].add(predictionPoints);\r\n      userData[msg.sender].assetStaked[_asset][_prediction] = userData[msg.sender].assetStaked[_asset][_prediction].add(_predictionStake);\r\n      userData[msg.sender].LeverageAsset[_asset][_prediction] = userData[msg.sender].LeverageAsset[_asset][_prediction].add(_predictionStake.mul(_leverage));\r\n      optionsAvailable[_prediction].predictionPoints = optionsAvailable[_prediction].predictionPoints.add(predictionPoints);\r\n      optionsAvailable[_prediction].assetStaked[_asset] = optionsAvailable[_prediction].assetStaked[_asset].add(_predictionStake);\r\n      optionsAvailable[_prediction].assetLeveraged[_asset] = optionsAvailable[_prediction].assetLeveraged[_asset].add(_predictionStake.mul(_leverage));\r\n    }\r\n\r\n    /**\r\n    * @dev Settle the market, setting the winning option\r\n    */\r\n    function settleMarket() external {\r\n      (uint256 _value, uint256 _roundId) = marketUtility.getSettlemetPrice(marketFeedAddress, uint256(marketSettleTime()));\r\n      if(marketStatus() == PredictionStatus.InSettlement) {\r\n        _postResult(_value, _roundId);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate the result of market.\r\n    * @param _value The current price of market currency.\r\n    */\r\n    function _postResult(uint256 _value, uint256 _roundId) internal {\r\n      require(now >= marketSettleTime(),\"Time not reached\");\r\n      require(_value > 0,\"value should be greater than 0\");\r\n      uint riskPercentage;\r\n      ( , riskPercentage, , ) = marketUtility.getBasicMarketDetails();\r\n      if(predictionStatus != PredictionStatus.InDispute) {\r\n        marketSettleData.settleTime = uint64(now);\r\n      } else {\r\n        delete marketSettleData.settleTime;\r\n      }\r\n      predictionStatus = PredictionStatus.Settled;\r\n      if(_value < marketData.neutralMinValue) {\r\n        marketSettleData.WinningOption = 1;\r\n      } else if(_value > marketData.neutralMaxValue) {\r\n        marketSettleData.WinningOption = 3;\r\n      } else {\r\n        marketSettleData.WinningOption = 2;\r\n      }\r\n      uint[] memory totalReward = new uint256[](2);\r\n      if(optionsAvailable[marketSettleData.WinningOption].assetStaked[ETH_ADDRESS] > 0 ||\r\n        optionsAvailable[marketSettleData.WinningOption].assetStaked[plotToken] > 0\r\n      ){\r\n        for(uint i=1;i <= totalOptions;i++){\r\n          if(i!=marketSettleData.WinningOption) {\r\n            uint256 leveragedAsset = _calculatePercentage(riskPercentage, optionsAvailable[i].assetLeveraged[plotToken], 100);\r\n            totalReward[0] = totalReward[0].add(leveragedAsset);\r\n            leveragedAsset = _calculatePercentage(riskPercentage, optionsAvailable[i].assetLeveraged[ETH_ADDRESS], 100);\r\n            totalReward[1] = totalReward[1].add(leveragedAsset);\r\n          }\r\n        }\r\n        rewardToDistribute = totalReward;\r\n      } else {\r\n        for(uint i=1;i <= totalOptions;i++){\r\n          uint256 leveragedAsset = _calculatePercentage(riskPercentage, optionsAvailable[i].assetLeveraged[plotToken], 100);\r\n          tokenAmountToPool = tokenAmountToPool.add(leveragedAsset);\r\n          leveragedAsset = _calculatePercentage(riskPercentage, optionsAvailable[i].assetLeveraged[ETH_ADDRESS], 100);\r\n          ethAmountToPool = ethAmountToPool.add(leveragedAsset);\r\n        }\r\n      }\r\n      _transferAsset(ETH_ADDRESS, address(marketRegistry), ethAmountToPool.add(ethCommissionAmount));\r\n      _transferAsset(plotToken, address(marketRegistry), tokenAmountToPool.add(plotCommissionAmount));\r\n      delete ethCommissionAmount;\r\n      delete plotCommissionAmount;\r\n      marketRegistry.callMarketResultEvent(rewardToDistribute, marketSettleData.WinningOption, _value, _roundId);\r\n    }\r\n\r\n    function _calculatePercentage(uint256 _percent, uint256 _value, uint256 _divisor) internal pure returns(uint256) {\r\n      return _percent.mul(_value).div(_divisor);\r\n    }\r\n\r\n    /**\r\n    * @dev Raise the dispute if wrong value passed at the time of market result declaration.\r\n    * @param proposedValue The proposed value of market currency.\r\n    * @param proposalTitle The title of proposal created by user.\r\n    * @param description The description of dispute.\r\n    * @param solutionHash The ipfs solution hash.\r\n    */\r\n    function raiseDispute(uint256 proposedValue, string memory proposalTitle, string memory description, string memory solutionHash) public {\r\n      require(getTotalStakedValueInPLOT() > 0, \"No participation\");\r\n      require(marketStatus() == PredictionStatus.Cooling);\r\n      uint _stakeForDispute =  marketUtility.getDisputeResolutionParams();\r\n      tokenController.transferFrom(plotToken, msg.sender, address(marketRegistry), _stakeForDispute);\r\n      lockedForDispute = true;\r\n      marketRegistry.createGovernanceProposal(proposalTitle, description, solutionHash, abi.encode(address(this), proposedValue), _stakeForDispute, msg.sender, ethAmountToPool, tokenAmountToPool, proposedValue);\r\n      delete ethAmountToPool;\r\n      delete tokenAmountToPool;\r\n      predictionStatus = PredictionStatus.InDispute;\r\n    }\r\n\r\n    /**\r\n    * @dev Resolve the dispute\r\n    * @param accepted Flag mentioning if dispute is accepted or not\r\n    * @param finalResult The final correct value of market currency.\r\n    */\r\n    function resolveDispute(bool accepted, uint256 finalResult) external payable {\r\n      require(msg.sender == address(marketRegistry) && marketStatus() == PredictionStatus.InDispute);\r\n      if(accepted) {\r\n        _postResult(finalResult, 0);\r\n      }\r\n      lockedForDispute = false;\r\n      predictionStatus = PredictionStatus.Settled;\r\n    }\r\n\r\n    function sponsorIncentives(address _token, uint256 _value) external {\r\n      require(marketRegistry.isWhitelistedSponsor(msg.sender));\r\n      require(marketStatus() <= PredictionStatus.InSettlement);\r\n      require(incentiveToken == address(0), \"Already sponsored\");\r\n      incentiveToken = _token;\r\n      incentiveToDistribute = _value;\r\n      tokenController.transferFrom(_token, msg.sender, address(this), _value);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Claim the return amount of the specified address.\r\n    * @param _user The address to query the claim return amount of.\r\n    * @return Flag, if 0:cannot claim, 1: Already Claimed, 2: Claimed\r\n    */\r\n    function claimReturn(address payable _user) public returns(uint256) {\r\n\r\n      if(lockedForDispute || marketStatus() != PredictionStatus.Settled || marketRegistry.marketCreationPaused()) {\r\n        return 0;\r\n      }\r\n      if(userData[_user].claimedReward) {\r\n        return 1;\r\n      }\r\n      userData[_user].claimedReward = true;\r\n      (uint[] memory _returnAmount, address[] memory _predictionAssets, uint _incentive, ) = getReturn(_user);\r\n      _transferAsset(plotToken, _user, _returnAmount[0]);\r\n      _transferAsset(ETH_ADDRESS, _user, _returnAmount[1]);\r\n      _transferAsset(incentiveToken, _user, _incentive);\r\n      marketRegistry.callClaimedEvent(_user, _returnAmount, _predictionAssets, _incentive, incentiveToken);\r\n      return 2;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer the assets to specified address.\r\n    * @param _asset The asset transfer to the specific address.\r\n    * @param _recipient The address to transfer the asset of\r\n    * @param _amount The amount which is transfer.\r\n    */\r\n    function _transferAsset(address _asset, address payable _recipient, uint256 _amount) internal {\r\n      if(_amount > 0) { \r\n        if(_asset == ETH_ADDRESS) {\r\n          _recipient.transfer(_amount);\r\n        } else {\r\n          require(IToken(_asset).transfer(_recipient, _amount));\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Get market settle time\r\n    * @return the time at which the market result will be declared\r\n    */\r\n    function marketSettleTime() public view returns(uint64) {\r\n      if(marketSettleData.settleTime > 0) {\r\n        return marketSettleData.settleTime;\r\n      }\r\n      return uint64(marketData.startTime.add(marketData.predictionTime.mul(2)));\r\n    }\r\n\r\n    /**\r\n    * @dev Get market expire time\r\n    * @return the time upto which user can place predictions in market\r\n    */\r\n    function marketExpireTime() internal view returns(uint256) {\r\n      return marketData.startTime.add(marketData.predictionTime);\r\n    }\r\n\r\n    /**\r\n    * @dev Get market cooldown time\r\n    * @return the time upto which user can raise the dispute after the market is settled\r\n    */\r\n    function marketCoolDownTime() public view returns(uint256) {\r\n      return marketSettleData.settleTime.add(marketData.predictionTime.div(4));\r\n    }\r\n\r\n    /**\r\n    * @dev Get market Feed data\r\n    * @return market currency name\r\n    * @return market currency feed address\r\n    */\r\n    function getMarketFeedData() public view returns(uint8, bytes32, address) {\r\n      return (roundOfToNearest, marketCurrency, marketFeedAddress);\r\n    }\r\n\r\n   /**\r\n    * @dev Get estimated amount of prediction points for given inputs.\r\n    * @param _prediction The option on which user place prediction.\r\n    * @param _stakeValueInEth The amount staked by user.\r\n    * @param _leverage The leverage opted by user at the time of prediction.\r\n    * @return uint256 representing the prediction points.\r\n    */\r\n    function estimatePredictionValue(uint _prediction, uint _stakeValueInEth, uint _leverage) public view returns(uint _predictionValue){\r\n      (_predictionValue, ) = calculatePredictionValue(_prediction, _stakeValueInEth, _leverage, ETH_ADDRESS);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the price of specific option.\r\n    * @param _prediction The option number to query the balance of.\r\n    * @return Price of the option.\r\n    */\r\n    function getOptionPrice(uint _prediction) public view returns(uint) {\r\n      uint[] memory params = new uint[](9);\r\n      params[0] = _prediction;\r\n      params[1] = marketData.neutralMinValue;\r\n      params[2] = marketData.neutralMaxValue;\r\n      params[3] = marketData.startTime;\r\n      params[4] = marketExpireTime();\r\n      (params[5], params[6]) = getTotalAssetsStaked();\r\n      params[7] = optionsAvailable[_prediction].assetStaked[ETH_ADDRESS];\r\n      params[8] = optionsAvailable[_prediction].assetStaked[plotToken];\r\n      return marketUtility.calculateOptionPrice(params, marketFeedAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets number of positions user got in prediction\r\n    * @param _user Address of user\r\n    * @param _option Option Id\r\n    */\r\n    function getUserPredictionPoints(address _user, uint256 _option) external view returns(uint256) {\r\n      return userData[_user].predictionPoints[_option];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the market data.\r\n    * @return _marketCurrency bytes32 representing the currency or stock name of the market.\r\n    * @return minvalue uint[] memory representing the minimum range of all the options of the market.\r\n    * @return maxvalue uint[] memory representing the maximum range of all the options of the market.\r\n    * @return _optionPrice uint[] memory representing the option price of each option ranges of the market.\r\n    * @return _ethStaked uint[] memory representing the ether staked on each option ranges of the market.\r\n    * @return _plotStaked uint[] memory representing the plot staked on each option ranges of the market.\r\n    * @return _predictionTime uint representing the type of market.\r\n    * @return _expireTime uint representing the time at which market closes for prediction\r\n    * @return _predictionStatus uint representing the status of the market.\r\n    */\r\n    function getData() public view returns\r\n       (bytes32 _marketCurrency,uint[] memory minvalue,uint[] memory maxvalue,\r\n        uint[] memory _optionPrice, uint[] memory _ethStaked, uint[] memory _plotStaked,uint _predictionTime,uint _expireTime, uint _predictionStatus){\r\n        _marketCurrency = marketCurrency;\r\n        _predictionTime = marketData.predictionTime;\r\n        _expireTime =marketExpireTime();\r\n        _predictionStatus = uint(marketStatus());\r\n        minvalue = new uint[](totalOptions);\r\n        minvalue[1] = marketData.neutralMinValue;\r\n        minvalue[2] = marketData.neutralMaxValue.add(1);\r\n        maxvalue = new uint[](totalOptions);\r\n        maxvalue[0] = marketData.neutralMinValue.sub(1);\r\n        maxvalue[1] = marketData.neutralMaxValue;\r\n        maxvalue[2] = ~uint256(0);\r\n        \r\n        _optionPrice = new uint[](totalOptions);\r\n        _ethStaked = new uint[](totalOptions);\r\n        _plotStaked = new uint[](totalOptions);\r\n        for (uint i = 0; i < totalOptions; i++) {\r\n        _ethStaked[i] = optionsAvailable[i+1].assetStaked[ETH_ADDRESS];\r\n        _plotStaked[i] = optionsAvailable[i+1].assetStaked[plotToken];\r\n        _optionPrice[i] = getOptionPrice(i+1);\r\n       }\r\n    }\r\n\r\n   /**\r\n    * @dev Gets the result of the market.\r\n    * @return uint256 representing the winning option of the market.\r\n    * @return uint256 Value of market currently at the time closing market.\r\n    * @return uint256 representing the positions of the winning option.\r\n    * @return uint[] memory representing the reward to be distributed.\r\n    * @return uint256 representing the Eth staked on winning option.\r\n    * @return uint256 representing the PLOT staked on winning option.\r\n    */\r\n    function getMarketResults() public view returns(uint256, uint256, uint256[] memory, uint256, uint256) {\r\n      return (marketSettleData.WinningOption, optionsAvailable[marketSettleData.WinningOption].predictionPoints, rewardToDistribute, optionsAvailable[marketSettleData.WinningOption].assetStaked[ETH_ADDRESS], optionsAvailable[marketSettleData.WinningOption].assetStaked[plotToken]);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the return amount of the specified address.\r\n    * @param _user The address to specify the return of\r\n    * @return returnAmount uint[] memory representing the return amount.\r\n    * @return incentive uint[] memory representing the amount incentive.\r\n    * @return _incentiveTokens address[] memory representing the incentive tokens.\r\n    */\r\n    function getReturn(address _user)public view returns (uint[] memory returnAmount, address[] memory _predictionAssets, uint incentive, address _incentiveToken){\r\n      (uint256 ethStaked, uint256 plotStaked) = getTotalAssetsStaked();\r\n      if(marketStatus() != PredictionStatus.Settled || ethStaked.add(plotStaked) ==0) {\r\n       return (returnAmount, _predictionAssets, incentive, incentiveToken);\r\n      }\r\n      _predictionAssets = new address[](2);\r\n      _predictionAssets[0] = plotToken;\r\n      _predictionAssets[1] = ETH_ADDRESS;\r\n\r\n      uint256 _totalUserPredictionPoints = 0;\r\n      uint256 _totalPredictionPoints = 0;\r\n      (returnAmount, _totalUserPredictionPoints, _totalPredictionPoints) = _calculateUserReturn(_user);\r\n      incentive = _calculateIncentives(_totalUserPredictionPoints, _totalPredictionPoints);\r\n      if(userData[_user].predictionPoints[marketSettleData.WinningOption] > 0) {\r\n        returnAmount = _addUserReward(_user, returnAmount);\r\n      }\r\n      return (returnAmount, _predictionAssets, incentive, incentiveToken);\r\n    }\r\n\r\n    /**\r\n    * @dev Get flags set for user\r\n    * @param _user User address\r\n    * @return Flag defining if user had availed multiplier\r\n    * @return Flag defining if user had predicted with bPLOT\r\n    */\r\n    function getUserFlags(address _user) external view returns(bool, bool) {\r\n      return (userData[_user].multiplierApplied, userData[_user].predictedWithBlot);\r\n    }\r\n\r\n    /**\r\n    * @dev Adds the reward in the total return of the specified address.\r\n    * @param _user The address to specify the return of.\r\n    * @param returnAmount The return amount.\r\n    * @return uint[] memory representing the return amount after adding reward.\r\n    */\r\n    function _addUserReward(address _user, uint[] memory returnAmount) internal view returns(uint[] memory){\r\n      uint reward;\r\n      for(uint j = 0; j< returnAmount.length; j++) {\r\n        reward = userData[_user].predictionPoints[marketSettleData.WinningOption].mul(rewardToDistribute[j]).div(optionsAvailable[marketSettleData.WinningOption].predictionPoints);\r\n        returnAmount[j] = returnAmount[j].add(reward);\r\n      }\r\n      return returnAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate the return of the specified address.\r\n    * @param _user The address to query the return of.\r\n    * @return _return uint[] memory representing the return amount owned by the passed address.\r\n    * @return _totalUserPredictionPoints uint representing the positions owned by the passed address.\r\n    * @return _totalPredictionPoints uint representing the total positions of winners.\r\n    */\r\n    function _calculateUserReturn(address _user) internal view returns(uint[] memory _return, uint _totalUserPredictionPoints, uint _totalPredictionPoints){\r\n      ( , uint riskPercentage, , ) = marketUtility.getBasicMarketDetails();\r\n      _return = new uint256[](2);\r\n      for(uint  i=1;i<=totalOptions;i++){\r\n        _totalUserPredictionPoints = _totalUserPredictionPoints.add(userData[_user].predictionPoints[i]);\r\n        _totalPredictionPoints = _totalPredictionPoints.add(optionsAvailable[i].predictionPoints);\r\n        _return[0] =  _callReturn(_return[0], _user, i, riskPercentage, plotToken);\r\n        _return[1] =  _callReturn(_return[1], _user, i, riskPercentage, ETH_ADDRESS);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the incentives.\r\n    * @param _totalUserPredictionPoints The positions of user.\r\n    * @param _totalPredictionPoints The total positions of winners.\r\n    * @return incentive the calculated incentive.\r\n    */\r\n    function _calculateIncentives(uint256 _totalUserPredictionPoints, uint256 _totalPredictionPoints) internal view returns(uint256 incentive){\r\n      incentive = _totalUserPredictionPoints.mul(incentiveToDistribute.div(_totalPredictionPoints));\r\n    }\r\n\r\n    // /**\r\n    // * @dev Gets the pending return.\r\n    // * @param _user The address to specify the return of.\r\n    // * @return uint representing the pending return amount.\r\n    // */\r\n    // function getPendingReturn(address _user) external view returns(uint[] memory returnAmount, address[] memory _predictionAssets, uint[] memory incentive, address[] memory _incentiveTokens){\r\n    //   if(userClaimedReward[_user]) return (0,0);\r\n    //   return getReturn(_user);\r\n    // }\r\n    \r\n    /**\r\n    * @dev Calls the total return amount internally.\r\n    */\r\n    function _callReturn(uint _return,address _user,uint i,uint riskPercentage, address _asset)internal view returns(uint){\r\n      if(i == marketSettleData.WinningOption) {\r\n        riskPercentage = 0;\r\n      }\r\n      uint256 leveragedAsset = _calculatePercentage(riskPercentage, userData[_user].LeverageAsset[_asset][i], 100);\r\n      return _return.add(userData[_user].assetStaked[_asset][i].sub(leveragedAsset));\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the status of market.\r\n    * @return PredictionStatus representing the status of market.\r\n    */\r\n    function marketStatus() internal view returns(PredictionStatus){\r\n      if(predictionStatus == PredictionStatus.Live && now >= marketExpireTime()) {\r\n        return PredictionStatus.InSettlement;\r\n      } else if(predictionStatus == PredictionStatus.Settled && now <= marketCoolDownTime()) {\r\n        return PredictionStatus.Cooling;\r\n      }\r\n      return predictionStatus;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getReturn\",\"outputs\":[{\"name\":\"returnAmount\",\"type\":\"uint256[]\"},{\"name\":\"_predictionAssets\",\"type\":\"address[]\"},{\"name\":\"incentive\",\"type\":\"uint256\"},{\"name\":\"_incentiveToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sponsorIncentives\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketCoolDownTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claimReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketFeedData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getData\",\"outputs\":[{\"name\":\"_marketCurrency\",\"type\":\"bytes32\"},{\"name\":\"minvalue\",\"type\":\"uint256[]\"},{\"name\":\"maxvalue\",\"type\":\"uint256[]\"},{\"name\":\"_optionPrice\",\"type\":\"uint256[]\"},{\"name\":\"_ethStaked\",\"type\":\"uint256[]\"},{\"name\":\"_plotStaked\",\"type\":\"uint256[]\"},{\"name\":\"_predictionTime\",\"type\":\"uint256\"},{\"name\":\"_expireTime\",\"type\":\"uint256\"},{\"name\":\"_predictionStatus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalStakedValueInPLOT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prediction\",\"type\":\"uint256\"}],\"name\":\"getOptionPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint64\"},{\"name\":\"_predictionTime\",\"type\":\"uint64\"},{\"name\":\"_minValue\",\"type\":\"uint64\"},{\"name\":\"_maxValue\",\"type\":\"uint64\"}],\"name\":\"initiate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposedValue\",\"type\":\"uint256\"},{\"name\":\"proposalTitle\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"solutionHash\",\"type\":\"string\"}],\"name\":\"raiseDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"accepted\",\"type\":\"bool\"},{\"name\":\"finalResult\",\"type\":\"uint256\"}],\"name\":\"resolveDispute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketSettleData\",\"outputs\":[{\"name\":\"WinningOption\",\"type\":\"uint64\"},{\"name\":\"settleTime\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserFlags\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prediction\",\"type\":\"uint256\"},{\"name\":\"_stakeValueInEth\",\"type\":\"uint256\"},{\"name\":\"_leverage\",\"type\":\"uint256\"}],\"name\":\"estimatePredictionValue\",\"outputs\":[{\"name\":\"_predictionValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketResults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settleMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketSettleTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_predictionStake\",\"type\":\"uint256\"},{\"name\":\"_prediction\",\"type\":\"uint256\"},{\"name\":\"_leverage\",\"type\":\"uint256\"}],\"name\":\"placePrediction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketData\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint64\"},{\"name\":\"predictionTime\",\"type\":\"uint64\"},{\"name\":\"neutralMinValue\",\"type\":\"uint64\"},{\"name\":\"neutralMaxValue\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalAssetsStaked\",\"outputs\":[{\"name\":\"ethStaked\",\"type\":\"uint256\"},{\"name\":\"plotStaked\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"optionsAvailable\",\"outputs\":[{\"name\":\"predictionPoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_option\",\"type\":\"uint256\"}],\"name\":\"getUserPredictionPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Market","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://98b1283931390455f5ca6bbff29e5ac85cfb8e6742ea874b10dd55d8636d9e4c"}]}