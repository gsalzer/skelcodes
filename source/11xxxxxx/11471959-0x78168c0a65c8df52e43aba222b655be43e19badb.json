{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/djagya/projects/erc20-contract/contracts/BoostCrowdsale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/crowdsale/Crowdsale.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\nimport \\\"./crowdsale/WithrawableCrowdsale.sol\\\";\\nimport \\\"./crowdsale/ReferralsCrowdsale.sol\\\";\\nimport \\\"./crowdsale/IndividualCrowdsale.sol\\\";\\nimport \\\"./crowdsale/RoundsCrowdsale.sol\\\";\\nimport \\\"./crowdsale/PostDeliveryCrowdsale.sol\\\";\\nimport \\\"./crowdsale/MinMaxCrowdsale.sol\\\";\\nimport \\\"./crowdsale/WhitelistCrowdsale.sol\\\";\\nimport \\\"./crowdsale/TimedCrowdsale.sol\\\";\\n\\n/**\\n *     ____  ____  ____  ___________\\n *    / __ )/ __ \\\\/ __ \\\\/ ___/_  __/\\n *   / __  / / / / / / /\\\\__ \\\\ / /\\n *  / /_/ / /_/ / /_/ /___/ // /\\n * /_____/\\\\____/\\\\____//____//_/\\n */\\ncontract BoostCrowdsale is\\nOwnable,\\nCrowdsale,\\nWhitelistAdminRole,\\nTimedCrowdsale,\\nWithrawableCrowdsale,\\nMinMaxCrowdsale,\\nPostDeliveryCrowdsale,\\nRoundsCrowdsale,\\nReferralsCrowdsale,\\nIndividualCrowdsale\\n{\\n    using SafeMath for uint256;\\n\\n    uint constant ROUNDS = 1;\\n    uint256 constant ROUND_CAP = 195000 ether;\\n    uint256 constant INIT_RATE = 2500;\\n    uint256 constant RATE_DECREMENT = 150;\\n\\n    constructor(\\n        IERC20 token,\\n        uint256 openingTime,\\n        uint256 closingTime\\n    )\\n    Crowdsale(INIT_RATE, msg.sender, token)\\n    RoundsCrowdsale(ROUNDS, ROUND_CAP, INIT_RATE, RATE_DECREMENT)\\n    TimedCrowdsale(block.timestamp, closingTime)\\n    public {}\\n}\\n\"\r\n    },\r\n    \"/Users/djagya/projects/erc20-contract/contracts/crowdsale/IndividualCrowdsale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/crowdsale/Crowdsale.sol\\\";\\n\\n/**\\n * Track individual contributions and enforce the cap per address.\\n */\\ncontract IndividualCrowdsale is Crowdsale {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _contributions;\\n    uint public contributorsCount;\\n\\n    uint256 public individualCap = 3e18;\\n\\n    function getContribution(address beneficiary) public view returns (uint256) {\\n        return _contributions[beneficiary];\\n    }\\n\\n    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\\n        super._updatePurchasingState(beneficiary, weiAmount);\\n\\n        if (_contributions[beneficiary] == 0) {\\n            contributorsCount += 1;\\n        }\\n\\n        _contributions[beneficiary] = _contributions[beneficiary].add(weiAmount);\\n\\n        require(_contributions[beneficiary] < individualCap, \\\"IndividualCrowdsale: contributions cap is reached\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/djagya/projects/erc20-contract/contracts/crowdsale/MinMaxCrowdsale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/crowdsale/Crowdsale.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\n\\ncontract MinMaxCrowdsale is Crowdsale, WhitelistAdminRole {\\n    using SafeMath for uint256;\\n\\n    // Min-max contribution limits: 0.02 and 3\\n    uint256 private _minContribution = 5e16;\\n    uint256 private _maxContribution = 3e18;\\n\\n    function getContributionLimits() public view returns (uint256, uint256) {\\n        return (_minContribution, _maxContribution);\\n    }\\n\\n    function setMinContribution(uint256 min) public onlyWhitelistAdmin {\\n        require(min > 0, 'MinMaxCrowdsale: min is 0');\\n        require(_maxContribution > min, 'MinMaxCrowdsale: max is less than min');\\n        _minContribution = min;\\n    }\\n\\n    function setMaxContribution(uint256 max) public onlyWhitelistAdmin {\\n        require(max > 0, 'MinMaxCrowdsale: max is 0');\\n        require(max > _minContribution, 'MinMaxCrowdsale: max is less than min');\\n        _maxContribution = max;\\n    }\\n\\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\\n        super._preValidatePurchase(beneficiary, weiAmount);\\n        require(weiAmount >= _minContribution, \\\"MinMaxCrowdsale: weiAmount is less than allowed minimum\\\");\\n        require(weiAmount <= _maxContribution, \\\"MinMaxCrowdsale: weiAmount is bigger than allowed maximum\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/djagya/projects/erc20-contract/contracts/crowdsale/PostDeliveryCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./TimedCrowdsale.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Secondary.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\n\\n/**\\n * @title PostDeliveryCrowdsale\\n * @dev Crowdsale that locks tokens from withdrawal until it ends.\\n */\\ncontract PostDeliveryCrowdsale is WhitelistAdminRole, TimedCrowdsale {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n    __unstable__TokenVault private _vault;\\n\\n    constructor() public {\\n        _vault = new __unstable__TokenVault();\\n    }\\n\\n    /**\\n     * @dev Withdraw tokens only after crowdsale ends.\\n     * @param beneficiary Whose tokens will be withdrawn.\\n     */\\n    function withdrawTokens(address beneficiary) public {\\n        require(hasClosed(), \\\"PostDeliveryCrowdsale: not closed\\\");\\n        uint256 amount = _balances[beneficiary];\\n        require(amount > 0, \\\"PostDeliveryCrowdsale: beneficiary is not due any tokens\\\");\\n\\n        _balances[beneficiary] = 0;\\n        _vault.transfer(token(), beneficiary, amount);\\n    }\\n\\n    /**\\n     * @return the balance of an account.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function getVaultAddress() public view onlyWhitelistAdmin returns (address) {\\n        return address(_vault);\\n    }\\n\\n    /**\\n     * @dev Overrides parent by storing due balances, and delivering tokens to the vault instead of the end user. This\\n     * ensures that the tokens will be available by the time they are withdrawn (which may not be the case if\\n     * `_deliverTokens` was called later).\\n     * @param beneficiary Token purchaser\\n     * @param tokenAmount Amount of tokens purchased\\n     */\\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\\n        _balances[beneficiary] = _balances[beneficiary].add(tokenAmount);\\n        _deliverTokens(address(_vault), tokenAmount);\\n    }\\n}\\n\\n/**\\n * @title __unstable__TokenVault\\n * @dev Similar to an Escrow for tokens, this contract allows its primary account to spend its tokens as it sees fit.\\n * This contract is an internal helper for PostDeliveryCrowdsale, and should not be used outside of this context.\\n */\\n// solhint-disable-next-line contract-name-camelcase\\ncontract __unstable__TokenVault is Secondary {\\n    function transfer(IERC20 token, address to, uint256 amount) public onlyPrimary {\\n        token.transfer(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/djagya/projects/erc20-contract/contracts/crowdsale/ReferralsCrowdsale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/crowdsale/Crowdsale.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\n\\n/**\\n * Referrals consist of two parts:\\n *\\n * 1) When user -- referral -- is using someone's -- referrer's -- code,\\n *  he receives a bonus of _percent on top of the purchased amounts.\\n *  For example, buying 5000 tokens, will result in 500 bonus tokens, if they were bought using a referral code.\\n *\\n * 2) Referrer has a separate percent which also equals _percent at the start.\\n *  When referrer earns more than increaseThreshold (e.g. 20ETH) from referrals, the percent increases.\\n *  So, for example, when someone buys 5000 tokens using the referrer code:\\n *      - referrer receives 10% of ETH value bonus converted to tokens: 5000 * 10% = 500\\n *      - when reached 20ETH earnings, referrer receives 20% of ETH value: 5000 * 20% = 1000\\n *\\n * When all referral funds (_cap) are spent, further purchases won't earn bonuses for anyone.\\n */\\ncontract ReferralsCrowdsale is Crowdsale, WhitelistAdminRole {\\n    using SafeMath for uint256;\\n\\n    // How much the referrer and referred receive.\\n    uint private _percent = 10;\\n    uint private _increasedPercent = 20;\\n    // After 20ETH referrer bonus increases\\n    uint256 private _increaseThreshold = 20 ether;\\n    uint256 private _cap;\\n    uint256 private _totalEarned;\\n\\n    bool public referralsEnabled = true;\\n\\n    struct Referral {\\n        address addr; // Who used the referral\\n        address referrer;\\n        uint256 earned; // How much tokens earned\\n        bool isActive;\\n    }\\n\\n    struct Referrer {\\n        address addr; // The referral address, used by others to associate with it\\n        // How much % a referrer gets from referrals purchases. Referrals always get _percent\\n        uint percent;\\n        uint256 earnedTokens; // Total tokens earned\\n        uint256 earnedEth; // accumulated 10% from all referral purchases\\n        uint num; // Total referrals\\n        address[] addresses; // Keys for the map\\n        mapping(address => ReferrerRef) earnings; // Referral -> earned\\n    }\\n\\n    struct ReferrerRef {\\n        address addr;\\n        uint256 earned;\\n        uint256 earnedEth;\\n        uint timestamp;\\n    }\\n\\n    // States of people whose codes were used\\n    mapping(address => Referrer) private _referrers;\\n    // States of people who used someone's referral\\n    mapping(address => Referral) private _referrals;\\n\\n    event ReferralEarned(address indexed beneficiary, address indexed from, uint256 amount);\\n    event ReferralActive(address indexed beneficiary, bool isActive);\\n    event NotEnoughReferralFunds(uint256 tried, uint256 remaining);\\n\\n    function refTokensRemaining() public view returns (uint256) {\\n        return _cap.sub(_totalEarned);\\n    }\\n\\n    function setReferrerPercent(address referrer, uint percent) public onlyWhitelistAdmin {\\n        require(percent > 0, \\\"ReferralsCrowdsale: percent is zero\\\");\\n        _referrers[referrer].percent = percent;\\n    }\\n\\n    function setReferralsCap(uint256 cap) public onlyWhitelistAdmin {\\n        require(cap > 0, \\\"ReferralsCrowdsale: cap is zero\\\");\\n        require(cap > _totalEarned, \\\"ReferralsCrowdsale: cap is less than already earned\\\");\\n        _cap = cap;\\n    }\\n\\n    function enableReferrals() public onlyWhitelistAdmin {\\n        referralsEnabled = true;\\n    }\\n\\n    function disableReferrals() public onlyWhitelistAdmin {\\n        referralsEnabled = false;\\n    }\\n\\n    /**\\n     * Referral stats: how much this used earned from using someones referral code.\\n     */\\n    function getReferralStats(address addr) public view returns (address, bool, address, uint, uint256) {\\n        Referral storage ref = _referrals[addr];\\n        uint percent = ref.isActive ? _percent : 0;\\n\\n        return (ref.addr, ref.isActive, ref.referrer, percent, ref.earned);\\n    }\\n\\n    /**\\n     * When buying tokens with a specified referral address, associate the buying user with it.\\n     * Update/init the referrer (whose code was used) stats.\\n     */\\n    function buyTokensWithReferral(address beneficiary, address referral) public payable {\\n        require(referralsEnabled == true, \\\"ReferralsCrowdsale: referrals are disabled\\\");\\n        require(_cap > 0, \\\"ReferralsCrowdsale: cap is not set\\\");\\n        require(referral != address(0), \\\"ReferralsCrowdsale: referral is the zero address\\\");\\n        require(referral != msg.sender, \\\"ReferralsCrowdsale: referral can't be the sender address\\\");\\n\\n        // Activate a referral or switch the referrer address.\\n        Referral storage userReferral = _referrals[msg.sender];\\n        if (!userReferral.isActive || referral != userReferral.referrer) {\\n            userReferral.addr = msg.sender;\\n            userReferral.referrer = referral;\\n            userReferral.isActive = true;\\n\\n            emit ReferralActive(msg.sender, userReferral.isActive);\\n        }\\n\\n        buyTokens(beneficiary);\\n    }\\n\\n    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\\n        super._updatePurchasingState(beneficiary, weiAmount);\\n\\n        if (!referralsEnabled) {\\n            return;\\n        }\\n\\n        // User must have an active associated referral.\\n        Referral storage currentReferral = _referrals[msg.sender];\\n        if (!currentReferral.isActive) {\\n            return;\\n        }\\n\\n        Referrer storage referrer = _referrers[currentReferral.referrer];\\n        referrer.percent = referrer.percent > 0 ? referrer.percent : _percent;\\n\\n        uint256 amount = _getTokenAmount(weiAmount);\\n        uint256 referralBonus = amount.mul(_percent).div(100);\\n\\n        uint256 referrerBonusEth = weiAmount.mul(referrer.percent).div(100);\\n        uint256 referrerBonus = _getTokenAmount(referrerBonusEth);\\n\\n        uint256 totalBonus = referralBonus.add(referrerBonus);\\n\\n        // If there's not enough referral funds remaining, proceed without giving referrals\\n        if (totalBonus > _cap.sub(_totalEarned)) {\\n            emit NotEnoughReferralFunds(totalBonus, _cap.sub(_totalEarned));\\n            return;\\n        }\\n        _totalEarned = _totalEarned.add(totalBonus);\\n\\n        // Update referral stats\\n        currentReferral.earned = currentReferral.earned.add(referralBonus);\\n\\n        // If current user wasn't previously added in the list of referrer's earnings, count it in\\n        if (referrer.earnings[msg.sender].addr == address(0)) {\\n            referrer.addr = currentReferral.referrer;\\n            referrer.addresses.push(msg.sender);\\n            referrer.num += 1;\\n        }\\n\\n        // Update referrer stats and increase the bonus if user earned more than threshold (e.g. > 20ETH) from referrals\\n        referrer.earnedTokens = referrer.earnedTokens.add(referrerBonus);\\n        referrer.earnedEth = referrer.earnedEth.add(referrerBonusEth);\\n        if (referrer.earnedEth > _increaseThreshold) {\\n            referrer.percent = _increasedPercent;\\n        }\\n        _referrers[currentReferral.referrer] = referrer;\\n\\n        // Track the specific referral, so referrer knows how much earned per referral\\n        ReferrerRef storage referrerRef = referrer.earnings[msg.sender];\\n        referrerRef.addr = msg.sender;\\n        referrerRef.earned = referrerRef.earned.add(referrerBonus);\\n        referrerRef.earnedEth = referrerRef.earnedEth.add(referrerBonusEth);\\n        referrerRef.timestamp = block.timestamp;\\n        _referrers[currentReferral.referrer].earnings[msg.sender] = referrerRef;\\n\\n        // Transfer bonus tokens\\n        _processPurchase(msg.sender, referralBonus);\\n        emit ReferralEarned(msg.sender, currentReferral.referrer, referralBonus);\\n\\n        _processPurchase(referrer.addr, referrerBonus);\\n        emit ReferralEarned(referrer.addr, msg.sender, referrerBonus);\\n    }\\n\\n    /**\\n     * Referrer stats: stats for people who used the code.\\n     */\\n    function getReferrerStats(address referrer) public view\\n    returns (\\n        uint,\\n        uint,\\n        uint256,\\n        uint256,\\n        uint[] memory,\\n        address[] memory,\\n        uint256[] memory,\\n        uint256[] memory\\n    ) {\\n        Referrer storage state = _referrers[referrer];\\n        uint percent = state.percent > 0 ? state.percent : _percent;\\n\\n        address[] memory addrs = new address[](state.num);\\n        uint256[] memory earnedTokens = new uint256[](state.num);\\n        uint256[] memory earnedEth = new uint256[](state.num);\\n        uint[] memory timestamps = new uint[](state.num);\\n\\n        for (uint i = 0; i < state.num; i++) {\\n            address refAddr = state.addresses[i];\\n            ReferrerRef storage ref = state.earnings[refAddr];\\n            addrs[i] = ref.addr;\\n            earnedTokens[i] = ref.earned;\\n            earnedEth[i] = ref.earnedEth;\\n            timestamps[i] = ref.timestamp;\\n        }\\n\\n        return (state.num, percent, state.earnedTokens, state.earnedEth, timestamps, addrs, earnedTokens, earnedEth);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/djagya/projects/erc20-contract/contracts/crowdsale/RoundsCrowdsale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/crowdsale/Crowdsale.sol\\\";\\nimport \\\"./TimedCrowdsale.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\n\\ncontract RoundsCrowdsale is Crowdsale, WhitelistAdminRole, TimedCrowdsale {\\n    using SafeMath for uint256;\\n\\n    struct Round {\\n        bool isOpen;\\n        uint n;\\n        uint256 rate;\\n        uint bonusPercent;\\n        uint contributors;\\n        uint256 raised;\\n        uint256 tokensLeft;\\n    }\\n\\n    uint256 public contributionCap = 3 ether;\\n    uint public currentRound;\\n\\n    // Min amount to buy with 550 rate per min 0.1ETH = 55 tokens, + bonus of 10%.\\n    uint256 constant _roundTokensLeftThreshold = 80 ether;\\n\\n    uint private _roundsCount;\\n    mapping(uint => Round) private _rounds;\\n    // User -> [round -> value]\\n    mapping(address => mapping(uint => uint256)) private _contributions;\\n\\n    event RoundOpened(uint n);\\n    event RoundBonusEarned(address beneficiary, uint256 amount);\\n\\n    constructor(uint roundsCount, uint256 cap, uint256 initRate, uint256 rateDecrement) public {\\n        require(roundsCount > 0, \\\"RoundsCrowdsale: roundsCount is 0\\\");\\n        require(cap > 0, \\\"RoundsCrowdsale: cap is 0\\\");\\n\\n        _roundsCount = roundsCount;\\n\\n        uint[1] memory bonuses = [uint(10)];\\n\\n        for (uint i = 0; i < _roundsCount; i++) {\\n            _rounds[i].tokensLeft = cap;\\n            _rounds[i].rate = initRate.sub(rateDecrement.mul(i));\\n            _rounds[i].bonusPercent = bonuses[i];\\n        }\\n\\n        currentRound = 0;\\n        _rounds[currentRound].isOpen = super.isOpen();\\n    }\\n\\n    function isOpen() public view returns (bool) {\\n        bool crowdsaleIsOpen = super.isOpen();\\n        // Open a previously closed first round when the crowdsale starts.\\n        bool roundIsOpen = _rounds[currentRound].isOpen || (crowdsaleIsOpen && currentRound == 0);\\n        return crowdsaleIsOpen && roundIsOpen;\\n    }\\n\\n    function closeRound() public onlyWhitelistAdmin {\\n        _rounds[currentRound].isOpen = false;\\n        if (currentRound < _roundsCount - 1) {\\n            currentRound += 1;\\n            _rounds[currentRound].isOpen = true;\\n            emit RoundOpened(currentRound);\\n        }\\n    }\\n\\n    function openRound(uint n) public onlyWhitelistAdmin {\\n        _rounds[currentRound].isOpen = false;\\n        _rounds[n].isOpen = true;\\n    }\\n\\n    function rate() public view returns (uint256) {\\n        revert(\\\"IncreasingPriceCrowdsale: rate() called\\\");\\n    }\\n\\n    function getRoundsContributions(address beneficiary) public view returns (uint256[] memory) {\\n        uint256[] memory contributions = new uint256[](_roundsCount);\\n        for (uint i = 0; i < _roundsCount; i++) {\\n            contributions[i] = _contributions[beneficiary][i];\\n        }\\n\\n        return contributions;\\n    }\\n\\n    /**\\n     * @dev Returns the rate of tokens per wei at the present time.\\n     * Note that, as price _increases_ with time, the rate _decreases_.\\n     * @return The number of tokens a buyer gets per wei at a given time\\n     */\\n    function getCurrentRate() public view returns (uint256) {\\n        if (!isOpen()) {\\n            return 0;\\n        }\\n\\n        return _rounds[currentRound].rate;\\n    }\\n\\n    /**\\n     * @dev Overrides parent method taking into account variable rate.\\n     * @param weiAmount The value in wei to be converted into tokens\\n     * @return The number of tokens _weiAmount wei will buy at present time\\n     */\\n    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\\n        uint256 currentRate = getCurrentRate();\\n        return currentRate.mul(weiAmount);\\n    }\\n\\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {\\n        super._preValidatePurchase(beneficiary, weiAmount);\\n\\n        Round storage round = _rounds[currentRound];\\n        uint256 tokens = _getTokenAmount(weiAmount);\\n        uint256 bonusTokens = round.bonusPercent > 0 ? tokens.mul(round.bonusPercent).div(100) : 0;\\n\\n        require(tokens.add(bonusTokens) <= round.tokensLeft, \\\"RoundsCrowdsale: round cap exceeded\\\");\\n    }\\n\\n    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\\n        super._updatePurchasingState(beneficiary, weiAmount);\\n\\n        // Open the first round if the timed crowdsale started\\n        if (currentRound == 0 && !_rounds[currentRound].isOpen && super.isOpen()) {\\n            _rounds[currentRound].isOpen = true;\\n        }\\n\\n        // Update round stats\\n        Round storage round = _rounds[currentRound];\\n        round.raised = round.raised.add(weiAmount);\\n\\n        uint256 tokens = _getTokenAmount(weiAmount);\\n\\n        // If current contributor wasn't in the list, count it\\n        if (_contributions[msg.sender][currentRound] == 0) {\\n            round.contributors += 1;\\n        }\\n\\n        // Update individual stats\\n        _contributions[msg.sender][currentRound] = _contributions[msg.sender][currentRound].add(weiAmount);\\n        require(_contributions[msg.sender][currentRound] < contributionCap, \\\"RoundsCrowdsale: individual contributions cap exceeded\\\");\\n\\n        // Send round bonus to purchaser\\n        uint256 bonusTokens = 0;\\n        if (round.bonusPercent > 0) {\\n            bonusTokens = tokens.mul(round.bonusPercent).div(100);\\n            _processPurchase(msg.sender, bonusTokens);\\n            emit RoundBonusEarned(msg.sender, bonusTokens);\\n        }\\n\\n        // Close depleted round\\n        round.tokensLeft = round.tokensLeft.sub(tokens).sub(bonusTokens);\\n        if (round.tokensLeft <= _roundTokensLeftThreshold) {\\n            round.isOpen = false;\\n        }\\n\\n        // If the current round is closed, open the next round (if there are any remaining)\\n        if (!round.isOpen && currentRound < _roundsCount - 1) {\\n            currentRound += 1;\\n            _rounds[currentRound].isOpen = true;\\n\\n            emit RoundOpened(currentRound);\\n        }\\n    }\\n\\n    /**\\n     * Rounds getter.\\n     */\\n    function getRounds() public view\\n    returns (\\n        uint[] memory,\\n        bool[] memory,\\n        uint256[] memory,\\n        uint[] memory,\\n        uint[] memory,\\n        uint256[] memory,\\n        uint256[] memory\\n    ) {\\n        uint[] memory n = new uint[](_roundsCount);\\n        bool[] memory openings = new bool[](_roundsCount);\\n        uint256[] memory rates = new uint256[](_roundsCount);\\n        uint[] memory bonuses = new uint[](_roundsCount);\\n        uint[] memory contributors = new uint[](_roundsCount);\\n        uint256[] memory raised = new uint256[](_roundsCount);\\n        uint256[] memory tokensLeft = new uint256[](_roundsCount);\\n\\n        for (uint i = 0; i < _roundsCount; i++) {\\n            Round storage round = _rounds[i];\\n            n[i] = i;\\n            openings[i] = super.isOpen() && round.isOpen;\\n            rates[i] = round.rate;\\n            bonuses[i] = round.bonusPercent;\\n            contributors[i] = round.contributors;\\n            raised[i] = round.raised;\\n            tokensLeft[i] = round.tokensLeft;\\n        }\\n\\n        return (n, openings, rates, bonuses, contributors, raised, tokensLeft);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/djagya/projects/erc20-contract/contracts/crowdsale/TimedCrowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/crowdsale/Crowdsale.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\n\\n/**\\n * @title TimedCrowdsale\\n * @dev Crowdsale accepting contributions only within a time frame.\\n */\\ncontract TimedCrowdsale is Crowdsale, WhitelistAdminRole {\\n    using SafeMath for uint256;\\n\\n    uint256 private _openingTime;\\n    uint256 private _closingTime;\\n\\n    /**\\n     * Event for crowdsale extending\\n     * @param newClosingTime new closing time\\n     * @param prevClosingTime old closing time\\n     */\\n    event TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime);\\n    event TimedCrowdsaleClosed();\\n\\n    /**\\n     * @dev Reverts if not in crowdsale time range.\\n     */\\n    modifier onlyWhileOpen {\\n        require(isOpen(), \\\"TimedCrowdsale: not open\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Constructor, takes crowdsale opening and closing times.\\n     * @param openingTime Crowdsale opening time\\n     * @param closingTime Crowdsale closing time\\n     */\\n    constructor (uint256 openingTime, uint256 closingTime) public {\\n        // solhint-disable-next-line not-rely-on-time\\n        require(openingTime >= block.timestamp, \\\"TimedCrowdsale: opening time is before current time\\\");\\n        // solhint-disable-next-line max-line-length\\n        require(closingTime > openingTime, \\\"TimedCrowdsale: opening time is not before closing time\\\");\\n\\n        _openingTime = openingTime;\\n        _closingTime = closingTime;\\n    }\\n\\n    /**\\n     * @return the crowdsale opening time.\\n     */\\n    function openingTime() public view returns (uint256) {\\n        return _openingTime;\\n    }\\n\\n    /**\\n     * @return the crowdsale closing time.\\n     */\\n    function closingTime() public view returns (uint256) {\\n        return _closingTime;\\n    }\\n\\n    /**\\n     * @return true if the crowdsale is open, false otherwise.\\n     */\\n    function isOpen() public view returns (bool) {\\n        // solhint-disable-next-line not-rely-on-time\\n        return block.timestamp >= _openingTime && block.timestamp <= _closingTime;\\n    }\\n\\n    function closeCrowdsale() public onlyWhitelistAdmin {\\n        require(isOpen(), \\\"TimedCrowdsale: is not open yet\\\");\\n        _closingTime = block.timestamp;\\n        emit TimedCrowdsaleClosed();\\n    }\\n\\n    /**\\n     * @dev Checks whether the period in which the crowdsale is open has already elapsed.\\n     * @return Whether crowdsale period has elapsed\\n     */\\n    function hasClosed() public view returns (bool) {\\n        // solhint-disable-next-line not-rely-on-time\\n        return block.timestamp > _closingTime;\\n    }\\n\\n    /**\\n     * @dev Extend parent behavior requiring to be within contributing period.\\n     * @param beneficiary Token purchaser\\n     * @param weiAmount Amount of wei contributed\\n     */\\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {\\n        super._preValidatePurchase(beneficiary, weiAmount);\\n    }\\n\\n    /**\\n     * @dev Extend crowdsale.\\n     * @param newClosingTime Crowdsale closing time\\n     */\\n    function _extendTime(uint256 newClosingTime) internal {\\n        require(!hasClosed(), \\\"TimedCrowdsale: already closed\\\");\\n        // solhint-disable-next-line max-line-length\\n        require(newClosingTime > _closingTime, \\\"TimedCrowdsale: new closing time is before current closing time\\\");\\n\\n        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);\\n        _closingTime = newClosingTime;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/djagya/projects/erc20-contract/contracts/crowdsale/WhitelistCrowdsale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/crowdsale/Crowdsale.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\n\\ncontract WhitelistCrowdsale is Crowdsale, WhitelistAdminRole {\\n    address public whitelister;\\n    bool public whitelistEnabled = false;\\n\\n    constructor(address _whitelister) public {\\n        whitelister = _whitelister;\\n    }\\n\\n    function isWhitelisted(address _address) external view returns (bool) {\\n    \\treturn IWhitelister(whitelister).whitelisted(_address);\\n    }\\n\\n    function validateWhitelisted(address beneficiary) internal view returns (bool) {\\n        return !whitelistEnabled || this.isWhitelisted(beneficiary);\\n    }\\n\\n    function toggleWhitelistEnabled() external onlyWhitelistAdmin {\\n        whitelistEnabled = !whitelistEnabled;\\n    }\\n}\\n\\ninterface IWhitelister {\\n    function whitelisted(address _address) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"/Users/djagya/projects/erc20-contract/contracts/crowdsale/WithrawableCrowdsale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/crowdsale/Crowdsale.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\nimport \\\"./TimedCrowdsale.sol\\\";\\n\\ncontract WithrawableCrowdsale is Crowdsale, WhitelistAdminRole, TimedCrowdsale {\\n    address public burnAddr = 0x000000000000000000000000000000000000dEaD;\\n\\n    function _forwardFunds() internal {\\n        // Do nothing and keep funds in the Crowdsale.\\n    }\\n\\n    function withdrawETH(uint256 amount) public onlyWhitelistAdmin {\\n        msg.sender.transfer(amount);\\n    }\\n\\n    function burnUnsold(uint256 amount) public onlyWhitelistAdmin {\\n        require(hasClosed(), \\\"WithrawableCrowdsale: crowdsale is not closed yet\\\");\\n        require(amount <= token().balanceOf(address(this)), \\\"WithrawableCrowdsale: amount is bigger than tokens left\\\");\\n        token().transfer(burnAddr, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Roles.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"../Roles.sol\\\";\\n\\n/**\\n * @title WhitelistAdminRole\\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\\n */\\ncontract WhitelistAdminRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event WhitelistAdminAdded(address indexed account);\\n    event WhitelistAdminRemoved(address indexed account);\\n\\n    Roles.Role private _whitelistAdmins;\\n\\n    constructor () internal {\\n        _addWhitelistAdmin(_msgSender());\\n    }\\n\\n    modifier onlyWhitelistAdmin() {\\n        require(isWhitelistAdmin(_msgSender()), \\\"WhitelistAdminRole: caller does not have the WhitelistAdmin role\\\");\\n        _;\\n    }\\n\\n    function isWhitelistAdmin(address account) public view returns (bool) {\\n        return _whitelistAdmins.has(account);\\n    }\\n\\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\\n        _addWhitelistAdmin(account);\\n    }\\n\\n    function renounceWhitelistAdmin() public {\\n        _removeWhitelistAdmin(_msgSender());\\n    }\\n\\n    function _addWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.add(account);\\n        emit WhitelistAdminAdded(account);\\n    }\\n\\n    function _removeWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.remove(account);\\n        emit WhitelistAdminRemoved(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/crowdsale/Crowdsale.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../math/SafeMath.sol\\\";\\nimport \\\"../token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @title Crowdsale\\n * @dev Crowdsale is a base contract for managing a token crowdsale,\\n * allowing investors to purchase tokens with ether. This contract implements\\n * such functionality in its most fundamental form and can be extended to provide additional\\n * functionality and/or custom behavior.\\n * The external interface represents the basic interface for purchasing tokens, and conforms\\n * the base architecture for crowdsales. It is *not* intended to be modified / overridden.\\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\\n * behavior.\\n */\\ncontract Crowdsale is Context, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // The token being sold\\n    IERC20 private _token;\\n\\n    // Address where funds are collected\\n    address payable private _wallet;\\n\\n    // How many token units a buyer gets per wei.\\n    // The rate is the conversion between wei and the smallest and indivisible token unit.\\n    // So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\\n    // 1 wei will give you 1 unit, or 0.001 TOK.\\n    uint256 private _rate;\\n\\n    // Amount of wei raised\\n    uint256 private _weiRaised;\\n\\n    /**\\n     * Event for token purchase logging\\n     * @param purchaser who paid for the tokens\\n     * @param beneficiary who got the tokens\\n     * @param value weis paid for purchase\\n     * @param amount amount of tokens purchased\\n     */\\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\\n\\n    /**\\n     * @param rate Number of token units a buyer gets per wei\\n     * @dev The rate is the conversion between wei and the smallest and indivisible\\n     * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\\n     * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\\n     * @param wallet Address where collected funds will be forwarded to\\n     * @param token Address of the token being sold\\n     */\\n    constructor (uint256 rate, address payable wallet, IERC20 token) public {\\n        require(rate > 0, \\\"Crowdsale: rate is 0\\\");\\n        require(wallet != address(0), \\\"Crowdsale: wallet is the zero address\\\");\\n        require(address(token) != address(0), \\\"Crowdsale: token is the zero address\\\");\\n\\n        _rate = rate;\\n        _wallet = wallet;\\n        _token = token;\\n    }\\n\\n    /**\\n     * @dev fallback function ***DO NOT OVERRIDE***\\n     * Note that other contracts will transfer funds with a base gas stipend\\n     * of 2300, which is not enough to call buyTokens. Consider calling\\n     * buyTokens directly when purchasing tokens from a contract.\\n     */\\n    function () external payable {\\n        buyTokens(_msgSender());\\n    }\\n\\n    /**\\n     * @return the token being sold.\\n     */\\n    function token() public view returns (IERC20) {\\n        return _token;\\n    }\\n\\n    /**\\n     * @return the address where funds are collected.\\n     */\\n    function wallet() public view returns (address payable) {\\n        return _wallet;\\n    }\\n\\n    /**\\n     * @return the number of token units a buyer gets per wei.\\n     */\\n    function rate() public view returns (uint256) {\\n        return _rate;\\n    }\\n\\n    /**\\n     * @return the amount of wei raised.\\n     */\\n    function weiRaised() public view returns (uint256) {\\n        return _weiRaised;\\n    }\\n\\n    /**\\n     * @dev low level token purchase ***DO NOT OVERRIDE***\\n     * This function has a non-reentrancy guard, so it shouldn't be called by\\n     * another `nonReentrant` function.\\n     * @param beneficiary Recipient of the token purchase\\n     */\\n    function buyTokens(address beneficiary) public nonReentrant payable {\\n        uint256 weiAmount = msg.value;\\n        _preValidatePurchase(beneficiary, weiAmount);\\n\\n        // calculate token amount to be created\\n        uint256 tokens = _getTokenAmount(weiAmount);\\n\\n        // update state\\n        _weiRaised = _weiRaised.add(weiAmount);\\n\\n        _processPurchase(beneficiary, tokens);\\n        emit TokensPurchased(_msgSender(), beneficiary, weiAmount, tokens);\\n\\n        _updatePurchasingState(beneficiary, weiAmount);\\n\\n        _forwardFunds();\\n        _postValidatePurchase(beneficiary, weiAmount);\\n    }\\n\\n    /**\\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met.\\n     * Use `super` in contracts that inherit from Crowdsale to extend their validations.\\n     * Example from CappedCrowdsale.sol's _preValidatePurchase method:\\n     *     super._preValidatePurchase(beneficiary, weiAmount);\\n     *     require(weiRaised().add(weiAmount) <= cap);\\n     * @param beneficiary Address performing the token purchase\\n     * @param weiAmount Value in wei involved in the purchase\\n     */\\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\\n        require(beneficiary != address(0), \\\"Crowdsale: beneficiary is the zero address\\\");\\n        require(weiAmount != 0, \\\"Crowdsale: weiAmount is 0\\\");\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    }\\n\\n    /**\\n     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid\\n     * conditions are not met.\\n     * @param beneficiary Address performing the token purchase\\n     * @param weiAmount Value in wei involved in the purchase\\n     */\\n    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends\\n     * its tokens.\\n     * @param beneficiary Address performing the token purchase\\n     * @param tokenAmount Number of tokens to be emitted\\n     */\\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\\n        _token.safeTransfer(beneficiary, tokenAmount);\\n    }\\n\\n    /**\\n     * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send\\n     * tokens.\\n     * @param beneficiary Address receiving the tokens\\n     * @param tokenAmount Number of tokens to be purchased\\n     */\\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\\n        _deliverTokens(beneficiary, tokenAmount);\\n    }\\n\\n    /**\\n     * @dev Override for extensions that require an internal state to check for validity (current user contributions,\\n     * etc.)\\n     * @param beneficiary Address receiving the tokens\\n     * @param weiAmount Value in wei involved in the purchase\\n     */\\n    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Override to extend the way in which ether is converted to tokens.\\n     * @param weiAmount Value in wei to be converted into tokens\\n     * @return Number of tokens that can be purchased with the specified _weiAmount\\n     */\\n    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\\n        return weiAmount.mul(_rate);\\n    }\\n\\n    /**\\n     * @dev Determines how ETH is stored/forwarded on purchases.\\n     */\\n    function _forwardFunds() internal {\\n        _wallet.transfer(msg.value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/ownership/Secondary.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev A Secondary contract can only be used by its primary account (the one that created it).\\n */\\ncontract Secondary is Context {\\n    address private _primary;\\n\\n    /**\\n     * @dev Emitted when the primary contract changes.\\n     */\\n    event PrimaryTransferred(\\n        address recipient\\n    );\\n\\n    /**\\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _primary = msgSender;\\n        emit PrimaryTransferred(msgSender);\\n    }\\n\\n    /**\\n     * @dev Reverts if called from any account other than the primary.\\n     */\\n    modifier onlyPrimary() {\\n        require(_msgSender() == _primary, \\\"Secondary: caller is not the primary account\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @return the address of the primary.\\n     */\\n    function primary() public view returns (address) {\\n        return _primary;\\n    }\\n\\n    /**\\n     * @dev Transfers contract to a new primary.\\n     * @param recipient The address of new primary.\\n     */\\n    function transferPrimary(address recipient) public onlyPrimary {\\n        require(recipient != address(0), \\\"Secondary: new primary is the zero address\\\");\\n        _primary = recipient;\\n        emit PrimaryTransferred(recipient);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"openingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tried\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"name\":\"NotEnoughReferralFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"ReferralActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferralEarned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RoundBonusEarned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"RoundOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TimedCrowdsaleClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevClosingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newClosingTime\",\"type\":\"uint256\"}],\"name\":\"TimedCrowdsaleExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnUnsold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"buyTokensWithReferral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributionCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributorsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableReferrals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableReferrals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContributionLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReferralStats\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"getReferrerStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRounds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getRoundsContributions\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"individualCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"openRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refTokensRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setMaxContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"setMinContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"setReferralsCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setReferrerPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BoostCrowdsale","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000065d14e3e5ea1e0b752783837ff1136bfe0a5dd34000000000000000000000000000000000000000000000000000000005fda6740000000000000000000000000000000000000000000000000000000005fe3a1c0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}