{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.3;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract MultiOwnable {\r\n\r\n    mapping (address => bool) public isOwner;\r\n    address[] public ownerHistory;\r\n\r\n    event OwnerAddedEvent(address indexed _newOwner);\r\n    event OwnerRemovedEvent(address indexed _oldOwner);\r\n\r\n    constructor() {\r\n        // Add default owner\r\n        address owner = msg.sender;\r\n        ownerHistory.push(owner);\r\n        isOwner[owner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner[msg.sender], \"Only owners allowed\");\r\n        _;\r\n    }\r\n\r\n    function ownerHistoryCount() public view returns (uint) {\r\n        return ownerHistory.length;\r\n    }\r\n\r\n    /** Add extra owner. */\r\n    function addOwner(address owner) onlyOwner public {\r\n        require(owner != address(0), \"Only valid addresses allowed\");\r\n        require(!isOwner[owner], \"Owner is already added\");\r\n        ownerHistory.push(owner);\r\n        isOwner[owner] = true;\r\n        emit OwnerAddedEvent(owner);\r\n    }\r\n\r\n    /** Remove extra owner. */\r\n    function removeOwner(address owner) onlyOwner public {\r\n        require(isOwner[owner], \"Owner is not defined\");\r\n        isOwner[owner] = false;\r\n        emit OwnerRemovedEvent(owner);\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\nabstract contract StandardToken is ERC20 {\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    function balanceOf(address _owner) public override virtual view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transferInternal(address _from, address _to, uint256 _value) internal {\r\n        require(_to != address(0), \"Forbidden to transfer to zero address\");\r\n\r\n        trackBalance(_from);\r\n        trackBalance(_to);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function approveInternal(address _owner, address _spender, uint256 _value) internal returns (bool) {\r\n        require(_spender != address(0), \"Forbidden to approve zero address\");\r\n\r\n        allowed[_owner][_spender] = _value;\r\n        emit Approval(_owner, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public override virtual returns (bool) {\r\n        transferInternal(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) public override virtual returns (bool) {\r\n        require(_from != address(0), \"Forbidden to transfer from zero address\");\r\n        require(_to != address(0), \"Forbidden to transfer to zero address\");\r\n\r\n        trackBalance(_from);\r\n        trackBalance(_to);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    function approve(address _spender, uint256 _value) public override virtual returns (bool) {\r\n        return approveInternal(msg.sender, _spender, _value);\r\n    }\r\n\r\n    /// @dev Returns number of allowed tokens for given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) public override virtual view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function trackBalance(address account) public virtual;\r\n}\r\n\r\ncontract CommonToken is StandardToken, MultiOwnable {\r\n    using SafeMath for uint;\r\n\r\n    struct Dividend {\r\n        uint256 amount;\r\n        uint256 block;\r\n    }\r\n\r\n    struct UserDividend {\r\n        uint256 lastClaimedDividend;\r\n        uint256 balanceTillDividend;\r\n    }\r\n\r\n    string public constant name   = 'BRKROFX';\r\n    string public constant symbol = 'BRKROFX';\r\n    uint8 public constant decimals = 18;\r\n\r\n    uint256 public saleLimit;   // 30% of tokens for sale (10% presale & 20% public sale).\r\n\r\n    // The main account that holds all tokens at the beginning and during tokensale.\r\n    address public seller; // Seller address (main holder of tokens)\r\n\r\n    address public distributor; // Distributor address\r\n\r\n    uint256 public tokensSold; // (e18) Number of tokens sold through all tiers or tokensales.\r\n    uint256 public totalSales; // Total number of sales (including external sales) made through all tiers or tokensales.\r\n\r\n    // Lock the transfer functions during tokensales to prevent price speculations.\r\n    bool public locked = true;\r\n\r\n    mapping (address => uint256) public nonces;\r\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public immutable DOMAIN_SEPARATOR;\r\n\r\n    mapping (address => bool) public dividendDistributors;\r\n\r\n    Dividend [] public dividends;\r\n    mapping(address => UserDividend) public userDividends;\r\n    mapping(address => mapping(uint256 => uint256)) public balanceByDividends;\r\n\r\n    event SellEvent(address indexed _seller, address indexed _buyer, uint256 _value);\r\n    event ChangeSellerEvent(address indexed _oldSeller, address indexed _newSeller);\r\n    event Burn(address indexed _burner, uint256 _value);\r\n    event Unlock();\r\n    event DividendAdded(uint256 _dividendId, uint256 _value, uint256 _block);\r\n    event DividendClaimed(address _account, uint256 _dividendId, uint256 _value);\r\n\r\n    constructor(\r\n        address _seller\r\n    ) MultiOwnable() {\r\n\r\n        totalSupply = 1_000_000_000 ether;\r\n        saleLimit   = 300_000_000 ether;\r\n\r\n        seller = _seller;\r\n        distributor = msg.sender;\r\n\r\n        uint sellerTokens = totalSupply;\r\n        balances[seller] = sellerTokens;\r\n        emit Transfer(address(0x0), seller, sellerTokens);\r\n\r\n        uint256 chainId;\r\n        assembly {chainId := chainid()}\r\n\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    modifier ifUnlocked(address _from) {\r\n        require(!locked, \"Allowed only if unlocked\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDistributor() {\r\n        require(msg.sender == distributor, \"Allowed only for distributor\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDividendDistributor() {\r\n        require(dividendDistributors[msg.sender], \"Allowed only for dividend distributor\");\r\n        _;\r\n    }\r\n\r\n    /** Can be called once by super owner. */\r\n    function unlock() onlyOwner public {\r\n        require(locked, \"I am locked\");\r\n        locked = false;\r\n        emit Unlock();\r\n    }\r\n\r\n    /**\r\n     * An address can become a new seller only in case it has no tokens.\r\n     * This is required to prevent stealing of tokens  from newSeller via\r\n     * 2 calls of this function.\r\n     */\r\n    function changeSeller(address newSeller) onlyOwner public returns (bool) {\r\n        require(newSeller != address(0), \"Invalid seller address\");\r\n        require(seller != newSeller, \"New seller is same\");\r\n\r\n        // To prevent stealing of tokens from newSeller via 2 calls of changeSeller:\r\n        require(balances[newSeller] == 0, \"New seller balance is not empty\");\r\n\r\n        address oldSeller = seller;\r\n        uint256 unsoldTokens = balances[oldSeller];\r\n        balances[oldSeller] = 0;\r\n        balances[newSeller] = unsoldTokens;\r\n        emit Transfer(oldSeller, newSeller, unsoldTokens);\r\n\r\n        seller = newSeller;\r\n        emit ChangeSellerEvent(oldSeller, newSeller);\r\n        return true;\r\n    }\r\n\r\n    function changeDistributor(address newDistributor) onlyOwner public returns (bool) {\r\n        distributor = newDistributor;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * User-friendly alternative to sell() function.\r\n     */\r\n    function sellNoDecimals(address _to, uint256 _value) public returns (bool) {\r\n        return sell(_to, _value * 1e18);\r\n    }\r\n\r\n    function sell(address _to, uint256 _value) onlyDistributor public returns (bool) {\r\n\r\n        // Check that we are not out of limit and still can sell tokens:\r\n        require(tokensSold.add(_value) <= saleLimit, \"Sell exceeds allowed limit\");\r\n\r\n        require(_to != address(0), \"Can't sell to zero address\");\r\n        require(_value > 0, \"_value is 0\");\r\n        require(_value <= balances[seller], \"Can't sell more tokens then available\");\r\n\r\n        balances[seller] = balances[seller].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(seller, _to, _value);\r\n\r\n        totalSales++;\r\n        tokensSold = tokensSold.add(_value);\r\n        emit SellEvent(seller, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Until all tokens are sold, tokens can be transfered to/from owner's accounts.\r\n     */\r\n    function transfer(address _to, uint256 _value) ifUnlocked(msg.sender) public override returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * Until all tokens are sold, tokens can be transfered to/from owner's accounts.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) ifUnlocked(_from) public override returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function burn(uint256 _value) public returns (bool) {\r\n        require(_value > 0, \"_value is 0\");\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        emit Transfer(msg.sender, address(0x0), _value);\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\r\n        require(deadline >= block.timestamp, 'CommonToken: expired deadline');\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'CommonToken: invalid permit');\r\n\r\n        approveInternal(owner, spender, value);\r\n    }\r\n\r\n    function transferByPermit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\r\n        permit(owner, spender, value, deadline, v, r, s);\r\n\r\n        require(msg.sender == spender, \"CommonToken: spender should be method caller\");\r\n\r\n        transferFrom(owner, spender, value);\r\n    }\r\n\r\n    function dividendsCount() public view returns (uint256 count) {\r\n        return dividends.length;\r\n    }\r\n\r\n    function setDividendsDistributor(address _dividendDistributor, bool _allowed) public onlyOwner {\r\n        dividendDistributors[_dividendDistributor] = _allowed;\r\n    }\r\n\r\n    function addDividend(uint256 _dividendTokens) public onlyDividendDistributor {\r\n        require(_dividendTokens > 0, \"CommonToken: not enough dividend tokens shared\");\r\n        require(balanceOf(msg.sender) >= _dividendTokens, \"CommonToken: not enough balance to create dividend\");\r\n\r\n        dividends.push(Dividend(_dividendTokens, block.number));\r\n\r\n        transferInternal(msg.sender, address(this), _dividendTokens);\r\n\r\n        emit DividendAdded(dividends.length - 1, _dividendTokens, block.number);\r\n    }\r\n\r\n    function claimDividend() public {\r\n        claimDividendsFor(msg.sender, 1);\r\n    }\r\n\r\n    function claimDividends(uint256 _dividendsCount) public {\r\n        claimDividendsFor(msg.sender, _dividendsCount);\r\n    }\r\n\r\n    function claimAllDividends() public {\r\n        claimAllDividendsFor(msg.sender);\r\n    }\r\n\r\n    function claimDividendFor(address _account) public {\r\n        claimDividendsFor(_account, 1);\r\n    }\r\n\r\n    function claimDividendsFor(address _account, uint256 _dividendsCount) public {\r\n        require(_dividendsCount > 0, \"CommonToken: Dividends count to claim should be greater than 0\");\r\n        require(dividends.length > 0, \"CommonToken: No dividends present\");\r\n\r\n        trackBalance(_account);\r\n\r\n        uint256 _fromDividend = userDividends[_account].lastClaimedDividend;\r\n        uint256 _toDividend = _fromDividend.add(_dividendsCount);\r\n\r\n        require(_toDividend <= dividends.length, \"CommonToken: no dividends available for claim\");\r\n\r\n        uint256 totalDividends = 0;\r\n\r\n        for (uint256 i = _fromDividend; i < _toDividend; i++) {\r\n            uint256 dividendsFraction = dividends[i].amount.mul(balanceByDividends[_account][i]).div(totalSupply);\r\n            totalDividends = totalDividends.add(dividendsFraction);\r\n\r\n            emit DividendClaimed(_account, i, dividendsFraction);\r\n        }\r\n\r\n        userDividends[_account].lastClaimedDividend = _toDividend;\r\n\r\n        transferInternal(address(this), _account, totalDividends);\r\n\r\n        emit Transfer(address(this), _account, totalDividends);\r\n    }\r\n\r\n    function claimAllDividendsFor(address _account) public {\r\n        claimDividendsFor(_account, dividends.length.sub(userDividends[_account].lastClaimedDividend));\r\n    }\r\n\r\n    function trackBalance(address account) public override {\r\n        if (dividends.length == 0) {\r\n            return;\r\n        }\r\n\r\n        if (balanceOf(account) == 0 && userDividends[account].lastClaimedDividend == 0) {\r\n            userDividends[account].lastClaimedDividend = dividends.length;\r\n\r\n            return;\r\n        }\r\n\r\n        if (userDividends[account].balanceTillDividend < dividends.length) {\r\n            for (uint256 i = userDividends[account].balanceTillDividend; i < dividends.length; i++) {\r\n                balanceByDividends[account][i] = balanceOf(account);\r\n            }\r\n\r\n            userDividends[account].balanceTillDividend = dividends.length;\r\n        }\r\n    }\r\n}\r\n\r\ncontract ProdToken is CommonToken {\r\n    constructor() CommonToken(\r\n        0xF774c190CDAD67578f7181F74323F996041cAcfd\r\n    ) {}\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_burner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldSeller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newSeller\",\"type\":\"address\"}],\"name\":\"ChangeSellerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_dividendId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"DividendAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_dividendId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"DividendClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAddedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemovedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"SellEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unlock\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dividendTokens\",\"type\":\"uint256\"}],\"name\":\"addDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceByDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDistributor\",\"type\":\"address\"}],\"name\":\"changeDistributor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSeller\",\"type\":\"address\"}],\"name\":\"changeSeller\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAllDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"claimAllDividendsFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"claimDividendFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dividendsCount\",\"type\":\"uint256\"}],\"name\":\"claimDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_dividendsCount\",\"type\":\"uint256\"}],\"name\":\"claimDividendsFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dividendDistributors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerHistory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerHistoryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sellNoDecimals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dividendDistributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setDividendsDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"trackBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"transferByPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastClaimedDividend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceTillDividend\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ProdToken","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"9999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://93f6297a1d17ac9581fd26662701a03674af351435d82db2c6bd1d4ba75f9f2c"}]}