{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ChargedSettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// ChargedSettings.sol -- Part of the Charged Particles Protocol\\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./interfaces/IChargedSettings.sol\\\";\\n\\nimport \\\"./lib/Bitwise.sol\\\";\\nimport \\\"./lib/TokenInfo.sol\\\";\\nimport \\\"./lib/RelayRecipient.sol\\\";\\nimport \\\"./lib/BlackholePrevention.sol\\\";\\n\\n/**\\n * @notice Charged Particles Settings Contract\\n */\\ncontract ChargedSettings is\\n  IChargedSettings,\\n  Ownable,\\n  RelayRecipient,\\n  BlackholePrevention\\n{\\n  using SafeMath for uint256;\\n  using TokenInfo for address;\\n  using Bitwise for uint32;\\n\\n  uint256 constant internal MAX_ANNUITIES = 1e4;      // 10000  (100%)\\n\\n  // NftSettings - actionPerms\\n  uint32 constant internal PERM_CHARGE_NFT        = 1;    // NFT Contracts that can have assets Deposited into them (Charged)\\n  uint32 constant internal PERM_BASKET_NFT        = 2;    // NFT Contracts that can have other NFTs Deposited into them\\n  uint32 constant internal PERM_TIMELOCK_ANY_NFT  = 4;    // NFT Contracts that can timelock any NFT on behalf of users (primarily used for Front-run Protection)\\n  uint32 constant internal PERM_TIMELOCK_OWN_NFT  = 8;    // NFT Contracts that can timelock their own NFTs on behalf of their users\\n  uint32 constant internal PERM_RESTRICTED_ASSETS = 16;   // NFT Contracts that have restricted deposits to specific assets\\n\\n  // Current Settings for External NFT Token Contracts;\\n  //  - Any user can add any ERC721 or ERC1155 token as a Charged Particle without Limits,\\n  //    unless the Owner of the ERC721 or ERC1155 token contract registers the token\\n  //    and sets the Custom Settings for their token(s)\\n  struct NftSettings {\\n    uint32 actionPerms;\\n\\n    string requiredWalletManager;\\n    string requiredBasketManager;\\n\\n    // ERC20\\n    mapping (address => bool) allowedAssetTokens;\\n    mapping (address => uint256) depositMin;  // Asset Token Address => Min\\n    mapping (address => uint256) depositMax;  // Asset Token Address => Max\\n\\n    // ERC721 / ERC1155\\n    mapping (address => uint256) maxNfts;     // NFT Token Address => Max\\n  }\\n\\n  // Optional Configs for individual NFTs set by NFT Creator\\n  struct CreatorSettings {\\n    uint256 annuityPercent;\\n    address annuityRedirect;\\n  }\\n\\n  mapping (address => uint256) internal _depositCap;\\n  uint256 internal _tempLockExpiryBlocks;\\n\\n  // Wallet/Basket Managers (by Unique Manager ID)\\n  mapping (string => IWalletManager) internal _ftWalletManager;\\n  mapping (string => IBasketManager) internal _nftBasketManager;\\n\\n  // Settings for individual NFTs set by NFT Creator (by Token UUID)\\n  mapping (uint256 => CreatorSettings) internal _creatorSettings;\\n\\n  // Settings for External NFT Token Contracts (by Token Contract Address)\\n  mapping (address => NftSettings) internal _nftSettings;\\n\\n\\n  /***********************************|\\n  |               Public              |\\n  |__________________________________*/\\n\\n  /// @notice Checks if an Account is the Owner of an NFT Contract\\n  ///    When Custom Contracts are registered, only the \\\"owner\\\" or operator of the Contract\\n  ///    is allowed to register them and define custom rules for how their tokens are \\\"Charged\\\".\\n  ///    Otherwise, any token can be \\\"Charged\\\" according to the default rules of Charged Particles.\\n  /// @param contractAddress  The Address to the External NFT Contract to check\\n  /// @param account          The Account to check if it is the Owner of the specified Contract\\n  /// @return True if the account is the Owner of the _contract\\n  function isContractOwner(address contractAddress, address account) external view override virtual returns (bool) {\\n    return contractAddress.isContractOwner(account);\\n  }\\n\\n  function isWalletManagerEnabled(string calldata walletManagerId) external virtual override view returns (bool) {\\n    return _isWalletManagerEnabled(walletManagerId);\\n  }\\n\\n  function getWalletManager(string calldata walletManagerId) external virtual override view returns (IWalletManager) {\\n    return _ftWalletManager[walletManagerId];\\n  }\\n\\n  function isNftBasketEnabled(string calldata basketId) external virtual override view returns (bool) {\\n    return _isNftBasketEnabled(basketId);\\n  }\\n\\n  function getBasketManager(string calldata basketId) external virtual override view returns (IBasketManager) {\\n    return _nftBasketManager[basketId];\\n  }\\n\\n\\n  /// @dev Gets the amount of creator annuities reserved for the creator for the specified NFT\\n  /// @param contractAddress The Address to the Contract of the NFT\\n  /// @param tokenId         The Token ID of the NFT\\n  /// @return creator The address of the creator\\n  /// @return annuityPct The percentage amount of annuities reserved for the creator\\n  function getCreatorAnnuities(\\n    address contractAddress,\\n    uint256 tokenId\\n  )\\n    external\\n    view\\n    override\\n    virtual\\n    returns (address creator, uint256 annuityPct)\\n  {\\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\\n    creator = contractAddress.getTokenCreator(tokenId);\\n    annuityPct = _creatorSettings[tokenUuid].annuityPercent;\\n  }\\n\\n  function getCreatorAnnuitiesRedirect(address contractAddress, uint256 tokenId)\\n    external\\n    view\\n    override\\n    virtual\\n    returns (address)\\n  {\\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\\n    return _creatorSettings[tokenUuid].annuityRedirect;\\n  }\\n\\n  function getTempLockExpiryBlocks() external view override virtual returns (uint256) {\\n    return _tempLockExpiryBlocks;\\n  }\\n\\n  function getTimelockApprovals(address operator)\\n    external\\n    view\\n    override\\n    virtual\\n    returns (bool timelockAny, bool timelockOwn)\\n  {\\n    timelockAny = _nftSettings[operator].actionPerms.hasBit(PERM_TIMELOCK_ANY_NFT);\\n    timelockOwn = _nftSettings[operator].actionPerms.hasBit(PERM_TIMELOCK_OWN_NFT);\\n  }\\n\\n  function getAssetRequirements(address contractAddress, address assetToken)\\n    external\\n    view\\n    override\\n    virtual\\n    returns (\\n      string memory requiredWalletManager,\\n      bool energizeEnabled,\\n      bool restrictedAssets,\\n      bool validAsset,\\n      uint256 depositCap,\\n      uint256 depositMin,\\n      uint256 depositMax\\n    )\\n  {\\n    requiredWalletManager = _nftSettings[contractAddress].requiredWalletManager;\\n    energizeEnabled = _nftSettings[contractAddress].actionPerms.hasBit(PERM_CHARGE_NFT);\\n    restrictedAssets = _nftSettings[contractAddress].actionPerms.hasBit(PERM_RESTRICTED_ASSETS);\\n    validAsset = _nftSettings[contractAddress].allowedAssetTokens[assetToken];\\n    depositCap = _depositCap[assetToken];\\n    depositMin = _nftSettings[contractAddress].depositMin[assetToken];\\n    depositMax = _nftSettings[contractAddress].depositMax[assetToken];\\n  }\\n\\n  function getNftAssetRequirements(address contractAddress, address nftTokenAddress)\\n    external\\n    view\\n    override\\n    virtual\\n    returns (string memory requiredBasketManager, bool basketEnabled, uint256 maxNfts)\\n  {\\n    requiredBasketManager = _nftSettings[contractAddress].requiredBasketManager;\\n    basketEnabled = _nftSettings[contractAddress].actionPerms.hasBit(PERM_BASKET_NFT);\\n    maxNfts = _nftSettings[contractAddress].maxNfts[nftTokenAddress];\\n  }\\n\\n\\n  /***********************************|\\n  |         Only NFT Creator          |\\n  |__________________________________*/\\n\\n  /// @notice Sets the Custom Configuration for Creators of Proton-based NFTs\\n  /// @param contractAddress  The Address to the Proton-based NFT to configure\\n  /// @param tokenId          The token ID of the Proton-based NFT to configure\\n  /// @param creator          The creator of the Proton-based NFT\\n  /// @param annuityPercent   The percentage of interest-annuities to reserve for the creator\\n  function setCreatorAnnuities(\\n    address contractAddress,\\n    uint256 tokenId,\\n    address creator,\\n    uint256 annuityPercent\\n  )\\n    external\\n    virtual\\n    override\\n  {\\n    require(contractAddress.isTokenContractOrCreator(tokenId, creator, _msgSender()), \\\"CP:E-104\\\");\\n    require(annuityPercent <= MAX_ANNUITIES, \\\"CP:E-421\\\");\\n\\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\\n\\n    // Update Configs for External Token Creator\\n    _creatorSettings[tokenUuid].annuityPercent = annuityPercent;\\n\\n    emit TokenCreatorConfigsSet(\\n      contractAddress,\\n      tokenId,\\n      creator,\\n      annuityPercent\\n    );\\n  }\\n\\n  /// @notice Sets a Custom Receiver Address for the Creator Annuities\\n  /// @param contractAddress  The Address to the Proton-based NFT to configure\\n  /// @param tokenId          The token ID of the Proton-based NFT to configure\\n  /// @param creator          The creator of the Proton-based NFT\\n  /// @param receiver         The receiver of the Creator interest-annuities\\n  function setCreatorAnnuitiesRedirect(\\n    address contractAddress,\\n    uint256 tokenId,\\n    address creator,\\n    address receiver\\n  )\\n    external\\n    virtual\\n    override\\n  {\\n    require(contractAddress.isTokenContractOrCreator(tokenId, creator, _msgSender()), \\\"CP:E-104\\\");\\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\\n    _creatorSettings[tokenUuid].annuityRedirect = receiver;\\n    emit TokenCreatorAnnuitiesRedirected(contractAddress, tokenId, receiver);\\n  }\\n\\n  function setTrustedForwarder(address _trustedForwarder) external onlyOwner {\\n    trustedForwarder = _trustedForwarder;\\n  }\\n\\n\\n  /***********************************|\\n  |     Register Contract Settings    |\\n  |(For External Contract Integration)|\\n  |__________________________________*/\\n\\n  /// @notice Sets a Required Wallet-Manager for External NFT Contracts (otherwise set to \\\"none\\\" to allow any Wallet-Manager)\\n  /// @param contractAddress    The Address to the External NFT Contract to configure\\n  /// @param walletManager      If set, will only allow deposits from this specific Wallet-Manager\\n  function setRequiredWalletManager(\\n    address contractAddress,\\n    string calldata walletManager\\n  )\\n    external\\n    virtual\\n    override\\n    onlyValidExternalContract(contractAddress)\\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\\n  {\\n    // Update Configs for External Token Contract\\n    if (keccak256(bytes(walletManager)) == keccak256(bytes(\\\"none\\\"))) {\\n      _nftSettings[contractAddress].requiredWalletManager = \\\"\\\";\\n    } else {\\n      _nftSettings[contractAddress].requiredWalletManager = walletManager;\\n    }\\n\\n    emit RequiredWalletManagerSet(\\n      contractAddress,\\n      walletManager\\n    );\\n  }\\n\\n  /// @notice Sets a Required Basket-Manager for External NFT Contracts (otherwise set to \\\"none\\\" to allow any Basket-Manager)\\n  /// @param contractAddress    The Address to the External Contract to configure\\n  /// @param basketManager      If set, will only allow deposits from this specific Basket-Manager\\n  function setRequiredBasketManager(\\n    address contractAddress,\\n    string calldata basketManager\\n  )\\n    external\\n    virtual\\n    override\\n    onlyValidExternalContract(contractAddress)\\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\\n  {\\n    // Update Configs for External Token Contract\\n    if (keccak256(bytes(basketManager)) == keccak256(bytes(\\\"none\\\"))) {\\n      _nftSettings[contractAddress].requiredBasketManager = \\\"\\\";\\n    } else {\\n      _nftSettings[contractAddress].requiredBasketManager = basketManager;\\n    }\\n\\n    emit RequiredBasketManagerSet(\\n      contractAddress,\\n      basketManager\\n    );\\n  }\\n\\n  /// @notice Enables or Disables Asset-Token Restrictions for External NFT Contracts\\n  /// @param contractAddress      The Address to the External NFT Contract to configure\\n  /// @param restrictionsEnabled  If set, will only allow deposits from Allowed Asset Tokens\\n  function setAssetTokenRestrictions(\\n    address contractAddress,\\n    bool restrictionsEnabled\\n  )\\n    external\\n    virtual\\n    override\\n    onlyValidExternalContract(contractAddress)\\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\\n  {\\n    // Update Configs for External Token Contract\\n    if (restrictionsEnabled) {\\n      _nftSettings[contractAddress].actionPerms = _nftSettings[contractAddress].actionPerms.setBit(PERM_RESTRICTED_ASSETS);\\n    } else {\\n      _nftSettings[contractAddress].actionPerms = _nftSettings[contractAddress].actionPerms.clearBit(PERM_RESTRICTED_ASSETS);\\n    }\\n\\n    emit AssetTokenRestrictionsSet(\\n      contractAddress,\\n      restrictionsEnabled\\n    );\\n  }\\n\\n  /// @notice Enables or Disables Allowed Asset Tokens for External NFT Contracts\\n  /// @param contractAddress  The Address to the External NFT Contract to configure\\n  /// @param assetToken       The Address of the Asset Token to Allow or Disallow\\n  /// @param isAllowed        True if the Asset Token is allowed\\n  function setAllowedAssetToken(\\n    address contractAddress,\\n    address assetToken,\\n    bool isAllowed\\n  )\\n    external\\n    virtual\\n    override\\n    onlyValidExternalContract(contractAddress)\\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\\n  {\\n    // Update Configs for External Token Contract\\n    _nftSettings[contractAddress].allowedAssetTokens[assetToken] = isAllowed;\\n\\n    emit AllowedAssetTokenSet(\\n      contractAddress,\\n      assetToken,\\n      isAllowed\\n    );\\n  }\\n\\n  /// @notice Sets the Custom Configuration for External Contracts\\n  /// @param contractAddress  The Address to the External Contract to configure\\n  /// @param assetToken       The address of the Asset Token to set Limits for\\n  /// @param depositMin       If set, will define the minimum amount of Asset tokens the NFT may hold, otherwise any amount\\n  /// @param depositMax       If set, will define the maximum amount of Asset tokens the NFT may hold, otherwise any amount\\n  function setAssetTokenLimits(\\n    address contractAddress,\\n    address assetToken,\\n    uint256 depositMin,\\n    uint256 depositMax\\n  )\\n    external\\n    virtual\\n    override\\n    onlyValidExternalContract(contractAddress)\\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\\n  {\\n    // Update Configs for External Token Contract\\n    _nftSettings[contractAddress].depositMin[assetToken] = depositMin;\\n    _nftSettings[contractAddress].depositMax[assetToken] = depositMax;\\n\\n    emit AssetTokenLimitsSet(\\n      contractAddress,\\n      assetToken,\\n      depositMin,\\n      depositMax\\n    );\\n  }\\n\\n  /// @notice Sets the Max Number of NFTs that can be held by a Charged Particle NFT\\n  /// @param contractAddress  The Address to the External Contract to configure\\n  /// @param nftTokenAddress  The address of the NFT Token to set a Max for\\n  /// @param maxNfts          The maximum numbers of NFTs that can be held by a given NFT (0 = unlimited)\\n  function setMaxNfts(\\n    address contractAddress,\\n    address nftTokenAddress,\\n    uint256 maxNfts\\n  )\\n    external\\n    virtual\\n    override\\n    onlyValidExternalContract(contractAddress)\\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\\n  {\\n    // Update Configs for External Token Contract\\n    _nftSettings[contractAddress].maxNfts[nftTokenAddress] = maxNfts;\\n\\n    emit MaxNftsSet(\\n      contractAddress,\\n      nftTokenAddress,\\n      maxNfts\\n    );\\n  }\\n\\n\\n  /***********************************|\\n  |          Only Admin/DAO           |\\n  |__________________________________*/\\n\\n  function setDepositCap(address assetToken, uint256 cap) external virtual onlyOwner {\\n    _depositCap[assetToken] = cap;\\n    emit DepositCapSet(assetToken, cap);\\n  }\\n\\n  function setTempLockExpiryBlocks(uint256 numBlocks) external virtual onlyOwner {\\n    _tempLockExpiryBlocks = numBlocks;\\n    emit TempLockExpirySet(numBlocks);\\n  }\\n\\n  /// @dev Register Contracts as wallet managers with a unique liquidity provider ID\\n  function registerWalletManager(string calldata walletManagerId, address walletManager) external virtual onlyOwner {\\n    // Validate wallet manager\\n    IWalletManager newWalletMgr = IWalletManager(walletManager);\\n    require(newWalletMgr.isPaused() != true, \\\"CP:E-418\\\");\\n\\n    // Register LP ID\\n    _ftWalletManager[walletManagerId] = newWalletMgr;\\n    emit WalletManagerRegistered(walletManagerId, walletManager);\\n  }\\n\\n  /// @dev Register Contracts as basket managers with a unique basket ID\\n  function registerBasketManager(string calldata basketId, address basketManager) external virtual onlyOwner {\\n    // Validate basket manager\\n    IBasketManager newBasketMgr = IBasketManager(basketManager);\\n    require(newBasketMgr.isPaused() != true, \\\"CP:E-418\\\");\\n\\n    // Register Basket ID\\n    _nftBasketManager[basketId] = newBasketMgr;\\n    emit BasketManagerRegistered(basketId, basketManager);\\n  }\\n\\n  function enableNftContracts(address[] calldata contracts) external override virtual onlyOwner {\\n    uint count = contracts.length;\\n    for (uint i = 0; i < count; i++) {\\n      address tokenContract = contracts[i];\\n      _setPermsForCharge(tokenContract, true);\\n      _setPermsForBasket(tokenContract, true);\\n      _setPermsForTimelockSelf(tokenContract, true);\\n    }\\n  }\\n\\n  /// @dev Update the list of NFT contracts that can be Charged\\n  function setPermsForCharge(address contractAddress, bool state)\\n    external\\n    override\\n    virtual\\n    onlyOwner\\n  {\\n    _setPermsForCharge(contractAddress, state);\\n  }\\n\\n  /// @dev Update the list of NFT contracts that can hold other NFTs\\n  function setPermsForBasket(address contractAddress, bool state)\\n    external\\n    override\\n    virtual\\n    onlyOwner\\n  {\\n    _setPermsForBasket(contractAddress, state);\\n  }\\n\\n  /// @dev Update the list of NFT contracts that can Timelock any NFT for Front-run Protection\\n  function setPermsForTimelockAny(address contractAddress, bool state)\\n    external\\n    override\\n    virtual\\n    onlyOwner\\n  {\\n    _setPermsForTimelockAny(contractAddress, state);\\n  }\\n\\n  /// @dev Update the list of NFT contracts that can Timelock their own tokens\\n  function setPermsForTimelockSelf(address contractAddress, bool state)\\n    external\\n    override\\n    virtual\\n    onlyOwner\\n  {\\n    _setPermsForTimelockSelf(contractAddress, state);\\n  }\\n\\n\\n  /***********************************|\\n  |          Only Admin/DAO           |\\n  |      (blackhole prevention)       |\\n  |__________________________________*/\\n\\n  function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\\n    _withdrawEther(receiver, amount);\\n  }\\n\\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\\n    _withdrawERC20(receiver, tokenAddress, amount);\\n  }\\n\\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\\n    _withdrawERC721(receiver, tokenAddress, tokenId);\\n  }\\n\\n\\n  /***********************************|\\n  |         Private Functions         |\\n  |__________________________________*/\\n\\n  /// @dev See {ChargedParticles-isWalletManagerEnabled}.\\n  function _isWalletManagerEnabled(string calldata walletManagerId) internal view virtual returns (bool) {\\n    return (address(_ftWalletManager[walletManagerId]) != address(0x0) && !_ftWalletManager[walletManagerId].isPaused());\\n  }\\n\\n  /// @dev See {ChargedParticles-isNftBasketEnabled}.\\n  function _isNftBasketEnabled(string calldata basketId) internal view virtual returns (bool) {\\n    return (address(_nftBasketManager[basketId]) != address(0x0) && !_nftBasketManager[basketId].isPaused());\\n  }\\n\\n  /// @dev Update the list of NFT contracts that can be Charged\\n  function _setPermsForCharge(address contractAddress, bool state) internal virtual {\\n    if (state) {\\n      _nftSettings[contractAddress].actionPerms = _nftSettings[contractAddress].actionPerms.setBit(PERM_CHARGE_NFT);\\n    } else {\\n      _nftSettings[contractAddress].actionPerms = _nftSettings[contractAddress].actionPerms.clearBit(PERM_CHARGE_NFT);\\n    }\\n    emit PermsSetForCharge(contractAddress, state);\\n  }\\n\\n  /// @dev Update the list of NFT contracts that can hold other NFTs\\n  function _setPermsForBasket(address contractAddress, bool state) internal virtual {\\n    if (state) {\\n      _nftSettings[contractAddress].actionPerms = _nftSettings[contractAddress].actionPerms.setBit(PERM_BASKET_NFT);\\n    } else {\\n      _nftSettings[contractAddress].actionPerms = _nftSettings[contractAddress].actionPerms.clearBit(PERM_BASKET_NFT);\\n    }\\n    emit PermsSetForBasket(contractAddress, state);\\n  }\\n\\n  /// @dev Update the list of NFT contracts that can Timelock any NFT for Front-run Protection\\n  function _setPermsForTimelockAny(address contractAddress, bool state) internal virtual {\\n    if (state) {\\n      _nftSettings[contractAddress].actionPerms = _nftSettings[contractAddress].actionPerms.setBit(PERM_TIMELOCK_ANY_NFT);\\n    } else {\\n      _nftSettings[contractAddress].actionPerms = _nftSettings[contractAddress].actionPerms.clearBit(PERM_TIMELOCK_ANY_NFT);\\n    }\\n    emit PermsSetForTimelockAny(contractAddress, state);\\n  }\\n\\n  /// @dev Update the list of NFT contracts that can Timelock their own tokens\\n  function _setPermsForTimelockSelf(address contractAddress, bool state) internal virtual {\\n    if (state) {\\n      _nftSettings[contractAddress].actionPerms = _nftSettings[contractAddress].actionPerms.setBit(PERM_TIMELOCK_OWN_NFT);\\n    } else {\\n      _nftSettings[contractAddress].actionPerms = _nftSettings[contractAddress].actionPerms.clearBit(PERM_TIMELOCK_OWN_NFT);\\n    }\\n    emit PermsSetForTimelockSelf(contractAddress, state);\\n  }\\n\\n\\n  /***********************************|\\n  |          GSN/MetaTx Relay         |\\n  |__________________________________*/\\n\\n  /// @dev See {BaseRelayRecipient-_msgSender}.\\n  function _msgSender()\\n    internal\\n    view\\n    virtual\\n    override(BaseRelayRecipient, Context)\\n    returns (address payable)\\n  {\\n    return BaseRelayRecipient._msgSender();\\n  }\\n\\n  /// @dev See {BaseRelayRecipient-_msgData}.\\n  function _msgData()\\n    internal\\n    view\\n    virtual\\n    override(BaseRelayRecipient, Context)\\n    returns (bytes memory)\\n  {\\n    return BaseRelayRecipient._msgData();\\n  }\\n\\n\\n  /***********************************|\\n  |             Modifiers             |\\n  |__________________________________*/\\n\\n  modifier onlyValidExternalContract(address contractAddress) {\\n    require(contractAddress.isContract(), \\\"CP:E-420\\\");\\n    _;\\n  }\\n\\n  modifier onlyContractOwnerOrAdmin(address contractAddress, address sender) {\\n    require(sender == owner() || contractAddress.isContractOwner(sender), \\\"CP:E-103\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChargedSettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// IChargedSettings.sol -- Part of the Charged Particles Protocol\\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"./IWalletManager.sol\\\";\\nimport \\\"./IBasketManager.sol\\\";\\n\\n/**\\n * @notice Interface for Charged Settings\\n */\\ninterface IChargedSettings {\\n\\n  /***********************************|\\n  |             Public API            |\\n  |__________________________________*/\\n\\n  function isContractOwner(address contractAddress, address account) external view returns (bool);\\n  function getCreatorAnnuities(address contractAddress, uint256 tokenId) external view returns (address creator, uint256 annuityPct);\\n  function getCreatorAnnuitiesRedirect(address contractAddress, uint256 tokenId) external view returns (address);\\n  function getTempLockExpiryBlocks() external view returns (uint256);\\n  function getTimelockApprovals(address operator) external view returns (bool timelockAny, bool timelockOwn);\\n  function getAssetRequirements(address contractAddress, address assetToken) external view\\n    returns (string memory requiredWalletManager, bool energizeEnabled, bool restrictedAssets, bool validAsset, uint256 depositCap, uint256 depositMin, uint256 depositMax);\\n  function getNftAssetRequirements(address contractAddress, address nftTokenAddress) external view\\n    returns (string memory requiredBasketManager, bool basketEnabled, uint256 maxNfts);\\n\\n  // ERC20\\n  function isWalletManagerEnabled(string calldata walletManagerId) external view returns (bool);\\n  function getWalletManager(string calldata walletManagerId) external view returns (IWalletManager);\\n\\n  // ERC721\\n  function isNftBasketEnabled(string calldata basketId) external view returns (bool);\\n  function getBasketManager(string calldata basketId) external view returns (IBasketManager);\\n\\n  /***********************************|\\n  |         Only NFT Creator          |\\n  |__________________________________*/\\n\\n  function setCreatorAnnuities(address contractAddress, uint256 tokenId, address creator, uint256 annuityPercent) external;\\n  function setCreatorAnnuitiesRedirect(address contractAddress, uint256 tokenId, address creator, address receiver) external;\\n\\n\\n  /***********************************|\\n  |      Only NFT Contract Owner      |\\n  |__________________________________*/\\n\\n  function setRequiredWalletManager(address contractAddress, string calldata walletManager) external;\\n  function setRequiredBasketManager(address contractAddress, string calldata basketManager) external;\\n  function setAssetTokenRestrictions(address contractAddress, bool restrictionsEnabled) external;\\n  function setAllowedAssetToken(address contractAddress, address assetToken, bool isAllowed) external;\\n  function setAssetTokenLimits(address contractAddress, address assetToken, uint256 depositMin, uint256 depositMax) external;\\n  function setMaxNfts(address contractAddress, address nftTokenAddress, uint256 maxNfts) external;\\n\\n  /***********************************|\\n  |          Only Admin/DAO           |\\n  |__________________________________*/\\n\\n  function enableNftContracts(address[] calldata contracts) external;\\n  function setPermsForCharge(address contractAddress, bool state) external;\\n  function setPermsForBasket(address contractAddress, bool state) external;\\n  function setPermsForTimelockAny(address contractAddress, bool state) external;\\n  function setPermsForTimelockSelf(address contractAddress, bool state) external;\\n\\n  /***********************************|\\n  |          Particle Events          |\\n  |__________________________________*/\\n\\n  event DepositCapSet(address assetToken, uint256 depositCap);\\n  event TempLockExpirySet(uint256 expiryBlocks);\\n\\n  event WalletManagerRegistered(string indexed walletManagerId, address indexed walletManager);\\n  event BasketManagerRegistered(string indexed basketId, address indexed basketManager);\\n\\n  event RequiredWalletManagerSet(address indexed contractAddress, string walletManager);\\n  event RequiredBasketManagerSet(address indexed contractAddress, string basketManager);\\n  event AssetTokenRestrictionsSet(address indexed contractAddress, bool restrictionsEnabled);\\n  event AllowedAssetTokenSet(address indexed contractAddress, address assetToken, bool isAllowed);\\n  event AssetTokenLimitsSet(address indexed contractAddress, address assetToken, uint256 assetDepositMin, uint256 assetDepositMax);\\n  event MaxNftsSet(address indexed contractAddress, address indexed nftTokenAddress, uint256 maxNfts);\\n\\n  event TokenCreatorConfigsSet(address indexed contractAddress, uint256 indexed tokenId, address indexed creatorAddress, uint256 annuityPercent);\\n  event TokenCreatorAnnuitiesRedirected(address indexed contractAddress, uint256 indexed tokenId, address indexed redirectAddress);\\n\\n  event PermsSetForCharge(address indexed contractAddress, bool state);\\n  event PermsSetForBasket(address indexed contractAddress, bool state);\\n  event PermsSetForTimelockAny(address indexed contractAddress, bool state);\\n  event PermsSetForTimelockSelf(address indexed contractAddress, bool state);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Bitwise.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Bitwise.sol -- Part of the Charged Particles Protocol\\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\npragma solidity 0.6.12;\\n\\nlibrary Bitwise {\\n  function negate(uint32 a) internal pure returns (uint32) {\\n    return a ^ maxInt();\\n  }\\n\\n  function shiftLeft(uint32 a, uint32 n) internal pure returns (uint32) {\\n    return a * uint32(2) ** n;\\n  }\\n\\n  function shiftRight(uint32 a, uint32 n) internal pure returns (uint32) {\\n    return a / uint32(2) ** n;\\n  }\\n\\n  function maxInt() internal pure returns (uint32) {\\n    return uint32(-1);\\n  }\\n\\n  // Get bit value at position\\n  function hasBit(uint32 a, uint32 n) internal pure returns (bool) {\\n    return a & shiftLeft(0x01, n) != 0;\\n  }\\n\\n  // Set bit value at position\\n  function setBit(uint32 a, uint32 n) internal pure returns (uint32) {\\n    return a | shiftLeft(0x01, n);\\n  }\\n\\n  // Set the bit into state \\\"false\\\"\\n  function clearBit(uint32 a, uint32 n) internal pure returns (uint32) {\\n    uint32 mask = negate(shiftLeft(0x01, n));\\n    return a & mask;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TokenInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// TokenInfo.sol -- Part of the Charged Particles Protocol\\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../interfaces/IERC721Chargeable.sol\\\";\\n\\nlibrary TokenInfo {\\n  function getTokenUUID(address contractAddress, uint256 tokenId) internal pure virtual returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(contractAddress, tokenId)));\\n  }\\n\\n  function getTokenOwner(address contractAddress, uint256 tokenId) internal view virtual returns (address) {\\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\\n    return tokenInterface.ownerOf(tokenId);\\n  }\\n\\n  function getTokenCreator(address contractAddress, uint256 tokenId) internal view virtual returns (address) {\\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\\n    return tokenInterface.creatorOf(tokenId);\\n  }\\n\\n  /// @dev Checks if an account is the Owner of an External NFT contract\\n  /// @param contractAddress  The Address to the Contract of the NFT to check\\n  /// @param account          The Address of the Account to check\\n  /// @return True if the account owns the contract\\n  function isContractOwner(address contractAddress, address account) internal view virtual returns (bool) {\\n    address contractOwner = IERC721Chargeable(contractAddress).owner();\\n    return contractOwner != address(0x0) && contractOwner == account;\\n  }\\n\\n  /// @dev Checks if an account is the Creator of a Proton-based NFT\\n  /// @param contractAddress  The Address to the Contract of the Proton-based NFT to check\\n  /// @param tokenId          The Token ID of the Proton-based NFT to check\\n  /// @param sender           The Address of the Account to check\\n  /// @return True if the account is the creator of the Proton-based NFT\\n  function isTokenCreator(address contractAddress, uint256 tokenId, address sender) internal view virtual returns (bool) {\\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\\n    address tokenCreator = tokenInterface.creatorOf(tokenId);\\n    return (sender == tokenCreator);\\n  }\\n\\n  /// @dev Checks if an account is the Creator of a Proton-based NFT or the Contract itself\\n  /// @param contractAddress  The Address to the Contract of the Proton-based NFT to check\\n  /// @param tokenId          The Token ID of the Proton-based NFT to check\\n  /// @param sender           The Address of the Account to check\\n  /// @return True if the account is the creator of the Proton-based NFT or the Contract itself\\n  function isTokenContractOrCreator(address contractAddress, uint256 tokenId, address creator, address sender) internal view virtual returns (bool) {\\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\\n    address tokenCreator = tokenInterface.creatorOf(tokenId);\\n    if (sender == contractAddress && creator == tokenCreator) { return true; }\\n    return (sender == tokenCreator);\\n  }\\n\\n  /// @dev Checks if an account is the Owner or Operator of an External NFT\\n  /// @param contractAddress  The Address to the Contract of the External NFT to check\\n  /// @param tokenId          The Token ID of the External NFT to check\\n  /// @param sender           The Address of the Account to check\\n  /// @return True if the account is the Owner or Operator of the External NFT\\n  function isErc721OwnerOrOperator(address contractAddress, uint256 tokenId, address sender) internal view virtual returns (bool) {\\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\\n    address tokenOwner = tokenInterface.ownerOf(tokenId);\\n    return (sender == tokenOwner || tokenInterface.isApprovedForAll(tokenOwner, sender));\\n  }\\n\\n  /**\\n    * @dev Returns true if `account` is a contract.\\n    * @dev Taken from OpenZeppelin library\\n    *\\n    * [IMPORTANT]\\n    * ====\\n    * It is unsafe to assume that an address for which this function returns\\n    * false is an externally-owned account (EOA) and not a contract.\\n    *\\n    * Among others, `isContract` will return false for the following\\n    * types of addresses:\\n    *\\n    *  - an externally-owned account\\n    *  - a contract in construction\\n    *  - an address where a contract will be created\\n    *  - an address where a contract lived, but was destroyed\\n    * ====\\n    */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly { codehash := extcodehash(account) }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n    * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n    * `recipient`, forwarding all available gas and reverting on errors.\\n    * @dev Taken from OpenZeppelin library\\n    *\\n    * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n    * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n    * imposed by `transfer`, making them unable to receive funds via\\n    * `transfer`. {sendValue} removes this limitation.\\n    *\\n    * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n    *\\n    * IMPORTANT: because control is transferred to `recipient`, care must be\\n    * taken to not create reentrancy vulnerabilities. Consider using\\n    * {ReentrancyGuard} or the\\n    * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n    */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"TokenInfo: insufficient balance\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n    require(success, \\\"TokenInfo: unable to send value, recipient may have reverted\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/RelayRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"@opengsn/gsn/contracts/BaseRelayRecipient.sol\\\";\\n\\ncontract RelayRecipient is BaseRelayRecipient {\\n  function versionRecipient() external override view returns (string memory) {\\n    return \\\"1.0.0-beta.1/charged-particles.relay.recipient\\\";\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BlackholePrevention.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// BlackholePrevention.sol -- Part of the Charged Particles Protocol\\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/**\\n * @notice Prevents ETH or Tokens from getting stuck in a contract by allowing\\n *  the Owner/DAO to pull them out on behalf of a user\\n * This is only meant to contracts that are not expected to hold tokens, but do handle transferring them.\\n */\\ncontract BlackholePrevention {\\n  using Address for address payable;\\n  using SafeERC20 for IERC20;\\n\\n  event WithdrawStuckEther(address indexed receiver, uint256 amount);\\n  event WithdrawStuckERC20(address indexed receiver, address indexed tokenAddress, uint256 amount);\\n  event WithdrawStuckERC721(address indexed receiver, address indexed tokenAddress, uint256 indexed tokenId);\\n\\n  function _withdrawEther(address payable receiver, uint256 amount) internal virtual {\\n    require(receiver != address(0x0), \\\"BHP:E-403\\\");\\n    if (address(this).balance >= amount) {\\n      receiver.sendValue(amount);\\n      emit WithdrawStuckEther(receiver, amount);\\n    }\\n  }\\n\\n  function _withdrawERC20(address payable receiver, address tokenAddress, uint256 amount) internal virtual {\\n    require(receiver != address(0x0), \\\"BHP:E-403\\\");\\n    if (IERC20(tokenAddress).balanceOf(address(this)) >= amount) {\\n      IERC20(tokenAddress).safeTransfer(receiver, amount);\\n      emit WithdrawStuckERC20(receiver, tokenAddress, amount);\\n    }\\n  }\\n\\n  function _withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) internal virtual {\\n    require(receiver != address(0x0), \\\"BHP:E-403\\\");\\n    if (IERC721(tokenAddress).ownerOf(tokenId) == address(this)) {\\n      IERC721(tokenAddress).transferFrom(address(this), receiver, tokenId);\\n      emit WithdrawStuckERC721(receiver, tokenAddress, tokenId);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWalletManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// IWalletManager.sol -- Part of the Charged Particles Protocol\\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title Particle Wallet Manager interface\\n * @dev The wallet-manager for underlying assets attached to Charged Particles\\n * @dev Manages the link between NFTs and their respective Smart-Wallets\\n */\\ninterface IWalletManager {\\n\\n  event ControllerSet(address indexed controller);\\n  event PausedStateSet(bool isPaused);\\n  event NewSmartWallet(address indexed contractAddress, uint256 indexed tokenId, address indexed smartWallet, address creator, uint256 annuityPct);\\n  event WalletEnergized(address indexed contractAddress, uint256 indexed tokenId, address indexed assetToken, uint256 assetAmount, uint256 yieldTokensAmount);\\n  event WalletDischarged(address indexed contractAddress, uint256 indexed tokenId, address indexed assetToken, uint256 creatorAmount, uint256 receiverAmount);\\n  event WalletDischargedForCreator(address indexed contractAddress, uint256 indexed tokenId, address indexed assetToken, address creator, uint256 receiverAmount);\\n  event WalletReleased(address indexed contractAddress, uint256 indexed tokenId, address indexed receiver, address assetToken, uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount);\\n  event WalletRewarded(address indexed contractAddress, uint256 indexed tokenId, address indexed receiver, address rewardsToken, uint256 rewardsAmount);\\n\\n  function isPaused() external view returns (bool);\\n\\n  function isReserveActive(address contractAddress, uint256 tokenId, address assetToken) external view returns (bool);\\n  function getReserveInterestToken(address contractAddress, uint256 tokenId, address assetToken) external view returns (address);\\n\\n  function getTotal(address contractAddress, uint256 tokenId, address assetToken) external returns (uint256);\\n  function getPrincipal(address contractAddress, uint256 tokenId, address assetToken) external returns (uint256);\\n  function getInterest(address contractAddress, uint256 tokenId, address assetToken) external returns (uint256 creatorInterest, uint256 ownerInterest);\\n  function getRewards(address contractAddress, uint256 tokenId, address rewardToken) external returns (uint256);\\n\\n  function energize(address contractAddress, uint256 tokenId, address assetToken, uint256 assetAmount) external returns (uint256 yieldTokensAmount);\\n  function discharge(address receiver, address contractAddress, uint256 tokenId, address assetToken, address creatorRedirect) external returns (uint256 creatorAmount, uint256 receiverAmount);\\n  function dischargeAmount(address receiver, address contractAddress, uint256 tokenId, address assetToken, uint256 assetAmount, address creatorRedirect) external returns (uint256 creatorAmount, uint256 receiverAmount);\\n  function dischargeAmountForCreator(address receiver, address contractAddress, uint256 tokenId, address creator, address assetToken, uint256 assetAmount) external returns (uint256 receiverAmount);\\n  function release(address receiver, address contractAddress, uint256 tokenId, address assetToken, address creatorRedirect) external returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount);\\n  function releaseAmount(address receiver, address contractAddress, uint256 tokenId, address assetToken, uint256 assetAmount, address creatorRedirect) external returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount);\\n  function withdrawRewards(address receiver, address contractAddress, uint256 tokenId, address rewardsToken, uint256 rewardsAmount) external returns (uint256 amount);\\n  function executeForAccount(address contractAddress, uint256 tokenId, address externalAddress, uint256 ethValue, bytes memory encodedParams) external returns (bytes memory);\\n  function getWalletAddressById(address contractAddress, uint256 tokenId, address creator, uint256 annuityPct) external returns (address);\\n\\n  function withdrawEther(address contractAddress, uint256 tokenId, address payable receiver, uint256 amount) external;\\n  function withdrawERC20(address contractAddress, uint256 tokenId, address payable receiver, address tokenAddress, uint256 amount) external;\\n  function withdrawERC721(address contractAddress, uint256 tokenId, address payable receiver, address nftTokenAddress, uint256 nftTokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBasketManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// IBasketManager.sol -- Part of the Charged Particles Protocol\\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title Particle Basket Manager interface\\n * @dev The basket-manager for underlying assets attached to Charged Particles\\n * @dev Manages the link between NFTs and their respective Smart-Baskets\\n */\\ninterface IBasketManager {\\n\\n  event ControllerSet(address indexed controller);\\n  event PausedStateSet(bool isPaused);\\n  event NewSmartBasket(address indexed contractAddress, uint256 indexed tokenId, address indexed smartBasket);\\n  event BasketAdd(address indexed contractAddress, uint256 indexed tokenId, address basketTokenAddress, uint256 basketTokenId);\\n  event BasketRemove(address indexed receiver, address indexed contractAddress, uint256 indexed tokenId, address basketTokenAddress, uint256 basketTokenId);\\n\\n  function isPaused() external view returns (bool);\\n\\n  function getTokenTotalCount(address contractAddress, uint256 tokenId) external view returns (uint256);\\n  function getTokenCountByType(address contractAddress, uint256 tokenId, address basketTokenAddress, uint256 basketTokenId) external returns (uint256);\\n\\n  function addToBasket(address contractAddress, uint256 tokenId, address basketTokenAddress, uint256 basketTokenId) external returns (bool);\\n  function removeFromBasket(address receiver, address contractAddress, uint256 tokenId, address basketTokenAddress, uint256 basketTokenId) external returns (bool);\\n  function executeForAccount(address contractAddress, uint256 tokenId, address externalAddress, uint256 ethValue, bytes memory encodedParams) external returns (bytes memory);\\n  function getBasketAddressById(address contractAddress, uint256 tokenId) external returns (address);\\n\\n  function withdrawEther(address contractAddress, uint256 tokenId, address payable receiver, uint256 amount) external;\\n  function withdrawERC20(address contractAddress, uint256 tokenId, address payable receiver, address tokenAddress, uint256 amount) external;\\n  function withdrawERC721(address contractAddress, uint256 tokenId, address payable receiver, address nftTokenAddress, uint256 nftTokenId) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Chargeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// IERC721Chargeable.sol -- Part of the Charged Particles Protocol\\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in all\\n// copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n// SOFTWARE.\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol\\\";\\n\\ninterface IERC721Chargeable is IERC165Upgradeable {\\n    function owner() external view returns (address);\\n    function creatorOf(uint256 tokenId) external view returns (address);\\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) external view returns (address tokenOwner);\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function approve(address to, uint256 tokenId) external;\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n    function setApprovalForAll(address operator, bool _approved) external;\\n    function isApprovedForAll(address tokenOwner, address operator) external view returns (bool);\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@opengsn/gsn/contracts/BaseRelayRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier:MIT\\n// solhint-disable no-inline-assembly\\npragma solidity ^0.6.2;\\n\\nimport \\\"./interfaces/IRelayRecipient.sol\\\";\\n\\n/**\\n * A base contract to be inherited by any contract that want to receive relayed transactions\\n * A subclass must use \\\"_msgSender()\\\" instead of \\\"msg.sender\\\"\\n */\\nabstract contract BaseRelayRecipient is IRelayRecipient {\\n\\n    /*\\n     * Forwarder singleton we accept calls from\\n     */\\n    address public trustedForwarder;\\n\\n    function isTrustedForwarder(address forwarder) public override view returns(bool) {\\n        return forwarder == trustedForwarder;\\n    }\\n\\n    /**\\n     * return the sender of this call.\\n     * if the call came through our trusted forwarder, return the original sender.\\n     * otherwise, return `msg.sender`.\\n     * should be used in the contract anywhere instead of msg.sender\\n     */\\n    function _msgSender() internal override virtual view returns (address payable ret) {\\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\\n            // At this point we know that the sender is a trusted forwarder,\\n            // so we trust that the last bytes of msg.data are the verified sender address.\\n            // extract sender address from the end of msg.data\\n            assembly {\\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\\n            }\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    /**\\n     * return the msg.data of this call.\\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\\n     * of the msg.data - so this method will strip those 20 bytes off.\\n     * otherwise, return `msg.data`\\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\\n     * signing or hashing the\\n     */\\n    function _msgData() internal override virtual view returns (bytes memory ret) {\\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\\n            // At this point we know that the sender is a trusted forwarder,\\n            // we copy the msg.data , except the last 20 bytes (and update the total length)\\n            assembly {\\n                let ptr := mload(0x40)\\n                // copy only size-20 bytes\\n                let size := sub(calldatasize(),20)\\n                // structure RLP data as <offset> <length> <bytes>\\n                mstore(ptr, 0x20)\\n                mstore(add(ptr,32), size)\\n                calldatacopy(add(ptr,64), 0, size)\\n                return(ptr, add(size,64))\\n            }\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@opengsn/gsn/contracts/interfaces/IRelayRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier:MIT\\npragma solidity ^0.6.2;\\n\\n/**\\n * a contract must implement this interface in order to support relayed transaction.\\n * It is better to inherit the BaseRelayRecipient as its implementation.\\n */\\nabstract contract IRelayRecipient {\\n\\n    /**\\n     * return if the forwarder is trusted to forward relayed transactions to us.\\n     * the forwarder is required to verify the sender's signature, and verify\\n     * the call is not a replay.\\n     */\\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\\n\\n    /**\\n     * return the sender of this call.\\n     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes\\n     * of the msg.data.\\n     * otherwise, return `msg.sender`\\n     * should be used in the contract anywhere instead of msg.sender\\n     */\\n    function _msgSender() internal virtual view returns (address payable);\\n\\n    /**\\n     * return the msg.data of this call.\\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\\n     * of the msg.data - so this method will strip those 20 bytes off.\\n     * otherwise, return `msg.data`\\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\\n     * signing or hashing the\\n     */\\n    function _msgData() internal virtual view returns (bytes memory);\\n\\n    function versionRecipient() external virtual view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transfered from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"AllowedAssetTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetDepositMin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetDepositMax\",\"type\":\"uint256\"}],\"name\":\"AssetTokenLimitsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"restrictionsEnabled\",\"type\":\"bool\"}],\"name\":\"AssetTokenRestrictionsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"basketId\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"basketManager\",\"type\":\"address\"}],\"name\":\"BasketManagerRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositCap\",\"type\":\"uint256\"}],\"name\":\"DepositCapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxNfts\",\"type\":\"uint256\"}],\"name\":\"MaxNftsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"PermsSetForBasket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"PermsSetForCharge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"PermsSetForTimelockAny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"PermsSetForTimelockSelf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"basketManager\",\"type\":\"string\"}],\"name\":\"RequiredBasketManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"walletManager\",\"type\":\"string\"}],\"name\":\"RequiredWalletManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiryBlocks\",\"type\":\"uint256\"}],\"name\":\"TempLockExpirySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redirectAddress\",\"type\":\"address\"}],\"name\":\"TokenCreatorAnnuitiesRedirected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"annuityPercent\",\"type\":\"uint256\"}],\"name\":\"TokenCreatorConfigsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"walletManagerId\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletManager\",\"type\":\"address\"}],\"name\":\"WalletManagerRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawStuckERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"WithdrawStuckERC721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawStuckEther\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"enableNftContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToken\",\"type\":\"address\"}],\"name\":\"getAssetRequirements\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"requiredWalletManager\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"energizeEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"restrictedAssets\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"validAsset\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"depositCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositMax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"basketId\",\"type\":\"string\"}],\"name\":\"getBasketManager\",\"outputs\":[{\"internalType\":\"contract IBasketManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCreatorAnnuities\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"annuityPct\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCreatorAnnuitiesRedirect\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftTokenAddress\",\"type\":\"address\"}],\"name\":\"getNftAssetRequirements\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"requiredBasketManager\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"basketEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxNfts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTempLockExpiryBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"getTimelockApprovals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"timelockAny\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"timelockOwn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"walletManagerId\",\"type\":\"string\"}],\"name\":\"getWalletManager\",\"outputs\":[{\"internalType\":\"contract IWalletManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isContractOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"basketId\",\"type\":\"string\"}],\"name\":\"isNftBasketEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"walletManagerId\",\"type\":\"string\"}],\"name\":\"isWalletManagerEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"basketId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"basketManager\",\"type\":\"address\"}],\"name\":\"registerBasketManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"walletManagerId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"walletManager\",\"type\":\"address\"}],\"name\":\"registerWalletManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"setAllowedAssetToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositMax\",\"type\":\"uint256\"}],\"name\":\"setAssetTokenLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"restrictionsEnabled\",\"type\":\"bool\"}],\"name\":\"setAssetTokenRestrictions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"annuityPercent\",\"type\":\"uint256\"}],\"name\":\"setCreatorAnnuities\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setCreatorAnnuitiesRedirect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"setDepositCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxNfts\",\"type\":\"uint256\"}],\"name\":\"setMaxNfts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPermsForBasket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPermsForCharge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPermsForTimelockAny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPermsForTimelockSelf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"basketManager\",\"type\":\"string\"}],\"name\":\"setRequiredBasketManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"walletManager\",\"type\":\"string\"}],\"name\":\"setRequiredWalletManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numBlocks\",\"type\":\"uint256\"}],\"name\":\"setTempLockExpiryBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedForwarder\",\"type\":\"address\"}],\"name\":\"setTrustedForwarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"versionRecipient\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ChargedSettings","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}