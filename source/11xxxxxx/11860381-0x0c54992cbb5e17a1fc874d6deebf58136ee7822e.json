{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\n\npragma solidity ^0.6.0;\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextUpgradeSafe is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n\n\n    }\n\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}\n\n// File: @openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\n\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n\n\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n\n    }\n\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[49] private __gap;\n}\n\n// File: contracts/TipplyContract.sol\n\npragma solidity >=0.5.0 <0.8.0;\n\n\n\n\ninterface IERC20 {\n\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n}\n\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\ninterface IUniswapV2Pair{\n    \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n} \n\ninterface IUniswapV2Router02{\n    \n    \n     function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    \n    \n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n}\n\n\ncontract TipplyContract is OwnableUpgradeSafe {\n    \n    using SafeMath for uint256;\n    enum tx_Type { ETH,DYT,ENJ}\n    \n    address payable _recipient;\n    address public UniSwap_Address;\n    address public WETH;\n    address public EthToDYT;\n    address public ENJ_Address;\n    address public EthToEnj;\n    address public DYT_Address;\n\n    mapping (address=>bool) whiteListed;\n\n    event MintFeeDeducted(address sender , uint256 ethAmount , uint256 enjAmount);\n    event WithdrawFeeDeducted(address sender  , string _type , uint256 amount);\n    event DepositFeeDeducted(address sender  , string _type , uint256 amount);\n    \n\n    function initialize(address payable recipient) external initializer {\n        OwnableUpgradeSafe.__Ownable_init();\n        _recipient = recipient;\n        whiteListed[msg.sender] = true;\n        UniSwap_Address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n        WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n        EthToDYT = 0x5B7aD60A92e725597e4A28444d498d1999cF66b6;\n        EthToEnj = 0xE56c60B5f9f7B5FC70DE0eb79c6EE7d00eFa2625;\n        ENJ_Address = 0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c;\n        DYT_Address = 0x740623d2c797b7D8D1EcB98e9b4Afcf99Ec31E14;\n    }\n    \n\n    function isWhiteListed(address _address) external view returns(bool) {\n        return whiteListed[_address];\n    }\n\n    function changeRecipient(address payable newrecipient) onlyOwner external{\n        _recipient = newrecipient;\n    } \n    \n    function whiteListAddress(address _admin) external onlyOwner{\n        require(whiteListed[_admin]!=true,\"Already whiteListed\");\n        whiteListed[_admin] = true;\n    }\n    \n    function blackListAddress(address _admin) external onlyOwner{\n        require(whiteListed[_admin]==true,\"address not whiteListed\");\n        whiteListed[_admin] = false;\n    }\n\n    function transferMintFeas(uint256 amount) external payable {\n        require(amount>0,\"Cant transfer 0 amount\");\n        require(amount<=IERC20(ENJ_Address).balanceOf(msg.sender),\"Sender does not have enough ENJ\");\n        IERC20(ENJ_Address).transferFrom(msg.sender,_recipient,amount);\n        _recipient.call{value: msg.value}(\"\");\n        emit MintFeeDeducted(msg.sender , msg.value , amount);\n    }\n    \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n    \n    function withdrawAmount(uint256 amount , tx_Type option , uint8 v, bytes32 r, bytes32 s ,uint256 deadline , address sender ) external payable {\n        require(deadline >= block.timestamp, \"Tipply Contract:: AUTH_EXPIRED\");\n        require(msg.sender==sender,\"sender must be msg.sender\");\n        require(amount>0,\"Cant withdraw 0 amount\");\n        bytes32 encodeData = keccak256(abi.encode(sender, amount,option,deadline,userNonce[sender]));\n        require(hashGenerated[encodeData]==false,\"Same hash cannot be used twice\");\n        hashGenerated[encodeData] = true;\n        userNonce[sender] = userNonce[sender].add(1);\n        _validateSignedData(_recipient, encodeData, v, r, s);\n        if(option == tx_Type.ETH){\n             sender.call{value: amount}(\"\");\n             emit WithdrawFeeDeducted(sender , 'ETH' , amount);\n        }\n        else if(option == tx_Type.DYT){\n            IERC20(DYT_Address).transfer(sender,amount);\n            emit WithdrawFeeDeducted(sender  , 'DYT' , amount);\n        }\n        \n        else if(option == tx_Type.ENJ){\n            IERC20(ENJ_Address).transfer(sender,amount);\n            emit WithdrawFeeDeducted(sender , 'ENJ' , amount);\n        }\n    }\n    \n    function depositAmount(uint256 amount , tx_Type option) external payable {\n        require(amount>0,\"Cant deposit 0 amount\");\n        if(option == tx_Type.ETH){\n            // require(msg.value <= address(msg.sender).balance,\"Sender does not have enough ETH funds \");\n            address(this).call{value: msg.value}(\"\");\n\n            emit DepositFeeDeducted(msg.sender , 'ETH' , msg.value);\n        }\n        \n        else if(option == tx_Type.DYT){\n            require(IERC20(DYT_Address).balanceOf(msg.sender)>=amount,\"Sender does not have enough DYT funds \");\n            IERC20(DYT_Address).transferFrom(msg.sender,address(this),amount);\n            emit DepositFeeDeducted(msg.sender  , 'DYT' , amount);\n        }\n        \n        else if(option == tx_Type.ENJ){\n            require(IERC20(ENJ_Address).balanceOf(msg.sender)>=amount,\"Sender does not have enough ENJ funds \");\n            IERC20(ENJ_Address).transferFrom(msg.sender,address(this),amount);\n            emit DepositFeeDeducted(msg.sender , 'ENJ' , amount);\n        }\n       \n    }\n    \n    function batchTransfer(address[] calldata recipients ,uint256[] calldata dytAmount ,uint256[] calldata ethAmount, uint256[] calldata enjAmount) external {\n        require(whiteListed[msg.sender]==true,\"Sender not White Listed\");\n        for(uint256 i=0;i<recipients.length;i++){\n            if(dytAmount[i]>0){\n            IERC20(DYT_Address).transfer(recipients[i],dytAmount[i]);\n            }\n            if(enjAmount[i]>0){\n            IERC20(ENJ_Address).transfer(recipients[i],enjAmount[i]);\n            }\n            if(ethAmount[i]>0){\n            recipients[i].call{value: ethAmount[i]}(\"\");\n            }\n        }\n    }\n    \n    function withdrawFunds(uint256 dytAmount , uint256 enjAmount , uint256 ethAmount) external {\n        require(whiteListed[msg.sender]==true,\"Sender not White Listed\");\n        if(enjAmount>0){\n            IERC20(ENJ_Address).transfer(msg.sender,enjAmount);\n        }\n        if(dytAmount>0){\n           IERC20(DYT_Address).transfer(msg.sender,dytAmount); \n        }\n        if(ethAmount>0){\n           msg.sender.call{value: ethAmount}(\"\");\n        }\n    }\n    \n    \n    function giveUniSwapApproval() external {\n        require(whiteListed[msg.sender]==true,\"Sender not White Listed\");\n        IERC20(ENJ_Address).approve(UniSwap_Address,uint(-1));\n        IERC20(WETH).approve(UniSwap_Address,uint(-1));\n    }\n    \n     function swapETHtoDYT(uint256 ethAmount) external  {\n        require(whiteListed[msg.sender]==true,\"Sender not White Listed\");\n        address[] memory path;\n        path = new address[](2);\n        path[0] = WETH;\n        path[1] = DYT_Address;\n        \n        (uint256 reserve1 , uint256 reserve2,) = IUniswapV2Pair(EthToDYT).getReserves();\n        uint256 amountOut = getAmountOut(ethAmount,reserve2,reserve1);\n        amountOut = amountOut.sub(amountOut.mul(2).div(100));\n        uint256[] memory amounts = IUniswapV2Router02(UniSwap_Address)\n            .swapExactETHForTokens{value:ethAmount}(\n            amountOut,\n            path,\n            address(this),\n            1839591241\n        );\n    }\n    \n    function swapENJtoDYT(uint256 enjAmount) external {\n        require(whiteListed[msg.sender]==true,\"Sender not White Listed\");\n        address[] memory path;\n        path = new address[](3);\n        path[0] = ENJ_Address;\n        path[1] = WETH;\n        path[2] = DYT_Address;\n        \n        (uint256 reserve1 ,,) = IUniswapV2Pair(EthToEnj).getReserves();\n        (uint256 reserve2,,) = IUniswapV2Pair(EthToDYT).getReserves();\n        uint256 amountOut = getAmountOut(enjAmount,reserve1,reserve2);\n        amountOut = amountOut.sub(amountOut.mul(2).div(100));\n        uint256[] memory amounts = IUniswapV2Router02(UniSwap_Address)\n            .swapExactTokensForTokens(\n            enjAmount,\n            amountOut,\n            path,\n            address(this),\n            1839591241\n        );\n    }\n    \n    fallback() external payable{\n        \n        \n    }\n    bytes32 private constant EIP712DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n    bytes32 private constant NAME_HASH = 0x345b72c36b14f1cee01efb8ac4b299dc7b8d873e28b4796034548a3d371a4d2f;\n    bytes32 private constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n    mapping (address=>uint256) userNonce;\n    mapping(bytes32=>bool) hashGenerated;\n\n\n    \n    \n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(EIP712DOMAIN_HASH, NAME_HASH, VERSION_HASH, 4, address(this)));\n    }\n    \n    function _validateSignedData(\n        address signer,\n        bytes32 encodeData,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view {\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeparator(), encodeData));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"TipplyContract:: INVALID_SIGNATURE\");\n    }\n\n    function getUserNonce(address _user) public view returns(uint256){\n        return userNonce[_user];\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositFeeDeducted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"enjAmount\",\"type\":\"uint256\"}],\"name\":\"MintFeeDeducted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFeeDeducted\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DYT_Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ENJ_Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EthToDYT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EthToEnj\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UniSwap_Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"dytAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ethAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"enjAmount\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"blackListAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newrecipient\",\"type\":\"address\"}],\"name\":\"changeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum TipplyContract.tx_Type\",\"name\":\"option\",\"type\":\"uint8\"}],\"name\":\"depositAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"giveUniSwapApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"enjAmount\",\"type\":\"uint256\"}],\"name\":\"swapENJtoDYT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"swapETHtoDYT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferMintFeas\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"whiteListAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum TipplyContract.tx_Type\",\"name\":\"option\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"withdrawAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dytAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"enjAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TipplyContract","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}