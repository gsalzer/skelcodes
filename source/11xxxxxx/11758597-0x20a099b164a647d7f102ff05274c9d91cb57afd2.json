{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NISTRelayer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.6;\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\r\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\r\\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\\r\\nimport './interfaces/Staking/INitroStaking.sol';\\r\\nimport './interfaces/Chainlink/IChainLinkFeed.sol';\\r\\nimport './interfaces/Relayer/IKeep3rV1Mini.sol';\\r\\n\\r\\ncontract NISTRelayer is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    //Params for reward bonus and interval\\r\\n    uint256 public distributeInterval = 2 hours;\\r\\n    //Requirements for the relayer executing\\r\\n    uint public minBond = 500 ether;\\r\\n    uint public minEarned = 0;\\r\\n    uint public minAge = 0;\\r\\n    //Amount of users to reward each cycle\\r\\n    uint256 public stakersPerRun = 10;\\r\\n\\r\\n    uint internal _gasUsed;\\r\\n\\r\\n    uint constant public MIN = 11;\\r\\n    uint constant public MAX = 12;\\r\\n    uint constant public BASE = 10;\\r\\n    uint public TARGETBOND = 2500 ether;\\r\\n\\r\\n    IKeep3rV1Mini public RLR;\\r\\n    INitroStaking public NIST;\\r\\n    IChainLinkFeed public FASTGAS;\\r\\n\\r\\n    constructor(address nisttoken, address rlrtoken, address gasoracle) public {\\r\\n        RLR     = IKeep3rV1Mini(rlrtoken);\\r\\n        NIST    = INitroStaking(nisttoken);\\r\\n        FASTGAS = IChainLinkFeed(gasoracle);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function bonds(address keeper) public view returns (uint) {\\r\\n        return RLR.bonds(keeper, address(RLR)).add(RLR.votes(keeper));\\r\\n    }\\r\\n\\r\\n    function calculateReward(uint __gasUsed,address origin,uint _gasPrice) public view returns (uint){\\r\\n        uint _quote = (__gasUsed).mul(uint(_gasPrice));\\r\\n        // console.log(\\\"Gas used : %s\\\",__gasUsed);\\r\\n        // console.log(\\\"Gas price : %s\\\",_gasPrice);\\r\\n        uint _min = _quote.mul(MIN).div(BASE);\\r\\n        uint _boost = _quote.mul(MAX).div(BASE);\\r\\n        uint _bond = Math.min(bonds(origin), TARGETBOND);\\r\\n        return Math.max(_min, _boost.mul(_bond).div(TARGETBOND));\\r\\n    }\\r\\n\\r\\n    modifier upkeep() {\\r\\n        _gasUsed = gasleft();\\r\\n        // console.log(msg.sender);\\r\\n        require(RLR.isMinKeeper(msg.sender, minBond, minEarned, minAge), \\\"::isKeeper: relayer is not registered\\\");\\r\\n        _;\\r\\n        uint gasPrice = Math.min(tx.gasprice, uint(FASTGAS.latestAnswer()));\\r\\n        uint gasUsed = _gasUsed.sub(gasleft());\\r\\n        //reward gas spent with 10% bonus as incentive\\r\\n        uint keeperFee = calculateReward(gasUsed,msg.sender,gasPrice);\\r\\n        // console.log(keeperFee);\\r\\n        // console.log(RLR.credits(address(this), RLR.ETH()));\\r\\n        require(keeperFee <= RLR.credits(address(this), RLR.ETH()),\\\"Not enough ETH to pay back gas\\\");\\r\\n        //Reward relayer in eth\\r\\n        RLR.receiptETH(msg.sender, keeperFee);\\r\\n        uint256 newCreditbal = RLR.credits(address(this), RLR.ETH());\\r\\n        //If we still have excess after paying the keeperfee,send it back to the nist contract\\r\\n        // if(newCreditbal > 0)  RLR.receiptETH(address(NIST),newCreditbal);\\r\\n    }\\r\\n\\r\\n    // Change requirements and rewards\\r\\n    function setDistributeInterval(uint256 newInterval) external onlyOwner {\\r\\n        distributeInterval = newInterval;\\r\\n    }\\r\\n\\r\\n    function setMinBond(uint newminbond) external onlyOwner {\\r\\n        minBond = newminbond;\\r\\n    }\\r\\n\\r\\n    function setTargetBond(uint newTarget) external onlyOwner {\\r\\n        TARGETBOND = newTarget;\\r\\n    }\\r\\n\\r\\n    function setMinEarned(uint newMinEarned) external onlyOwner {\\r\\n        minEarned = newMinEarned;\\r\\n    }\\r\\n\\r\\n    function setMinAge(uint newAge) external onlyOwner {\\r\\n        minAge = newAge;\\r\\n    }\\r\\n\\r\\n    function setStakersPerRun(uint256 newCount) external onlyOwner {\\r\\n        stakersPerRun = newCount;\\r\\n    }\\r\\n\\r\\n    function workable() public view returns (bool) {\\r\\n        (address[] memory addrs,) = getData();\\r\\n        return\\r\\n         addrs.length > 0\\r\\n         &&\\r\\n         block.timestamp > NIST.previousRewardDistributionTimestamp().add(distributeInterval);\\r\\n    }\\r\\n\\r\\n    //Use this function to get data to pass to work\\r\\n    function getData() public view returns (address[] memory eligible_addresses, uint256 total_reward){\\r\\n        (eligible_addresses,total_reward) = NIST.getEligibleAddressesForAutomaticPayout(stakersPerRun);\\r\\n    }\\r\\n    function work(address[] memory stakers, uint256 tokens_to_liquidate) public upkeep {\\r\\n        NIST.processAutoRewardPayouts(stakers,tokens_to_liquidate);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Staking/INitroStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.6;\\r\\n//Interface to staking data for relayer job\\r\\ninterface INitroStaking {\\r\\n  function RelayerJob (  ) external view returns ( address );\\r\\n  function _stakes ( address ) external view returns ( uint256 stake, uint256 S_init );\\r\\n  function eth_output_per_second (  ) external view returns ( uint256 );\\r\\n  function minimumAutoPayoutBalance (  ) external view returns ( uint256 );\\r\\n  function minimumRewardBalance (  ) external view returns ( uint256 );\\r\\n  function previousRewardDistributionTimestamp (  ) external view returns ( uint256 );\\r\\n  function remainingETHToAllocate (  ) external view returns ( uint256 );\\r\\n  function maxSellRemoval (  ) external view returns ( uint256 );\\r\\n  function maxBuyBonus (  ) external view returns ( uint256 );\\r\\n  function stakeHolders (  ) external view returns ( address[] memory);\\r\\n  function totalStakes (  ) external view returns ( uint256 );\\r\\n  function totalUnclaimedRewards (  ) external view returns ( uint256 );\\r\\n  function getEligibleAddressesForAutomaticPayout ( uint256 numToFind ) external view returns ( address[] memory eligible_addresses, uint256 total_reward);\\r\\n  function getNextEligibleAddressForAutomaticPayout (  ) external view returns ( address );\\r\\n  function isStakeholder ( address _address ) external view returns ( bool, uint256 );\\r\\n  function stakeOf ( address _stakeholder ) external view returns ( uint256 );\\r\\n  function calculateReward ( address _stakeholder ) external view returns ( uint256 );\\r\\n  function approximateETHPerNISTOutput (  ) external view returns ( uint256 );\\r\\n  function claimRewards ( address _stakeholder ) external;\\r\\n  function processAutoRewardPayouts ( address[] calldata stakers, uint256 tokens_to_liquidate) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/Chainlink/IChainLinkFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity 0.6.6;\\r\\n\\r\\ninterface IChainLinkFeed {\\r\\n    function latestAnswer() external view returns (int256);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/Relayer/IKeep3rV1Mini.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.6;\\r\\ninterface IKeep3rV1Mini {\\r\\n    function isKeeper(address) external returns (bool);\\r\\n    function worked(address keeper) external;\\r\\n    function totalBonded() external view returns (uint);\\r\\n    function bonds(address keeper, address credit) external view returns (uint);\\r\\n    function votes(address keeper) external view returns (uint);\\r\\n    function isMinKeeper(address keeper, uint minBond, uint earned, uint age) external returns (bool);\\r\\n    function addCreditETH(address job) external payable;\\r\\n    function credits(address job, address credit) external view returns (uint);\\r\\n    function receipt(address credit, address keeper, uint amount) external;\\r\\n    function ETH() external view returns (address);\\r\\n    function receiptETH(address keeper, uint amount) external;\\r\\n    function addJob(address job) external;\\r\\n    function mint(uint amount) external;\\r\\n    function bond(address bonding, uint amount) external;\\r\\n    function activate(address bonding) external;\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nisttoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rlrtoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gasoracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FASTGAS\",\"outputs\":[{\"internalType\":\"contract IChainLinkFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NIST\",\"outputs\":[{\"internalType\":\"contract INitroStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RLR\",\"outputs\":[{\"internalType\":\"contract IKeep3rV1Mini\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TARGETBOND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"}],\"name\":\"bonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"__gasUsed\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"calculateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"eligible_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"total_reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newInterval\",\"type\":\"uint256\"}],\"name\":\"setDistributeInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAge\",\"type\":\"uint256\"}],\"name\":\"setMinAge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newminbond\",\"type\":\"uint256\"}],\"name\":\"setMinBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinEarned\",\"type\":\"uint256\"}],\"name\":\"setMinEarned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCount\",\"type\":\"uint256\"}],\"name\":\"setStakersPerRun\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTarget\",\"type\":\"uint256\"}],\"name\":\"setTargetBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakersPerRun\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"stakers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"tokens_to_liquidate\",\"type\":\"uint256\"}],\"name\":\"work\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"workable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"NISTRelayer","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a685de9089e258ee77b86ecafcabd9d3ac8ba4580000000000000000000000000e3ef895c59e7db27214ab5bbf56347ce115a3f4000000000000000000000000169e633a2d1e6c10dd91238ba11c4a708dfef37c","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}