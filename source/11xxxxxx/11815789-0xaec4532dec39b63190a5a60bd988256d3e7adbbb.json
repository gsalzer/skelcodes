{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract DecodeCheckpointSignerList {\r\n    \r\n    // Slice specified number of bytes from arbitrary length byte array, starting from certain index\r\n    function slice(bytes memory payload, uint256 start, uint256 length) internal pure returns (bytes memory) {\r\n\r\n        require(length + 31 >= length, \"slice_overflow\");\r\n        require(start + length >= start, \"slice_overflow\");\r\n        require(payload.length >= start + length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n\r\n            switch iszero(length)\r\n            case 0 {\r\n                tempBytes := mload(0x40)\r\n\r\n                let lengthmod := and(length, 31)\r\n\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(add(add(payload, lengthmod), mul(0x20, iszero(lengthmod))), start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, length)\r\n\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n\r\n        }\r\n\r\n        return tempBytes;\r\n        \r\n    }\r\n    \r\n    // Given input data for transaction invoking `submitHeaderBlock(bytes data, bytes sigs)`\r\n    // attempts to extract out data & signature fields\r\n    //\r\n    // Note: Function signature is also included in `payload` i.e. first 4 bytes, which will be\r\n    // stripped out ðŸ‘‡\r\n    function decodeIntoDataAndSignature(bytes calldata payload) internal pure returns (bytes memory, bytes memory) {\r\n\r\n        return abi.decode(slice(payload, 4, payload.length - 4), (bytes, bytes));\r\n\r\n    }\r\n    \r\n    // Given ðŸ‘† function call for extracting `data` from transaction input data\r\n    // has succeeded, votehash can be computed, which was signed by these check point signers\r\n    function computeVoteHash(bytes memory payload) internal pure returns (bytes32) {\r\n\r\n        return keccak256(abi.encodePacked(hex\"01\", payload));\r\n\r\n    }\r\n    \r\n    // Attempt to recover signer address, given original message & signed message\r\n    function ecrecovery(bytes32 voteHash, bytes memory sig) internal pure returns (bytes memory) {\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n          \r\n        assembly {\r\n              \r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := and(mload(add(sig, 65)), 255)\r\n\r\n        }\r\n\r\n        if (v < 27) v += 27;\r\n        \r\n        return addresstoBytes(ecrecover(voteHash, v, r, s));\r\n\r\n    }\r\n    \r\n    // Converts Ethereum address to bytes data type\r\n    function addresstoBytes(address a) internal pure returns (bytes memory) {\r\n\r\n        return abi.encodePacked(a);\r\n\r\n    }\r\n    \r\n    // Passing transaction input data of `submitHeaderBlock(bytes data, bytes sigs)` function\r\n    // call, it attempts to figure out what are those signers who signer this checkpoint\r\n    //\r\n    // Note: Sending checkpoint from Matic Network ( L2 ) to Ethereum Network ( L1 )\r\n    // is nothing but calling `submitHeaderBlock(bytes data, bytes sigs)`, defined\r\n    // in RootChain contract, deployed on Ethereum Network, with proper arguments, by some validator.\r\n    //\r\n    // RootChain :\r\n    //      0x2890bA17EfE978480615e330ecB65333b880928e [ Goerli ]\r\n    //      0x86E4Dc95c7FBdBf52e33D563BbDB00823894C287 [ Ethereum Mainnet ]\r\n    function decode(bytes calldata payload) external pure returns (bytes[] memory) {\r\n        \r\n        (bytes memory data, bytes memory sigs) = decodeIntoDataAndSignature(payload);\r\n        bytes32 voteHash = computeVoteHash(data);\r\n\r\n        bytes[] memory signers = new bytes[](sigs.length / 65);\r\n        uint256 count = 0;\r\n      \r\n        for(uint256 i = 0; i < sigs.length; i += 65) {\r\n\r\n            signers[count++] = ecrecovery(voteHash, slice(sigs, i, 65));\r\n\r\n        }\r\n      \r\n        return signers;\r\n\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"decode\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"DecodeCheckpointSignerList","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9674eeaeaecd5cfc6c97fb05bdbb3cba9fffe7637c26ecf2f6017808d36a786d"}]}