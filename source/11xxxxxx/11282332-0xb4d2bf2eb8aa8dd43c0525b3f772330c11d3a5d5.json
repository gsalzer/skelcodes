{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: -- ðŸŽ² --\r\n\r\npragma solidity ^0.7.4;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'SafeMath: addition overflow');\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, 'SafeMath: subtraction overflow');\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, 'SafeMath: multiplication overflow');\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, 'SafeMath: division by zero');\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, 'SafeMath: modulo by zero');\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract dgKeeper {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address public gateKeeper;\r\n    address public gateOverseer;\r\n    address public distributionToken;\r\n\r\n    uint256 public totalRequired;\r\n    uint256 immutable MIN_TIME_FRAME;\r\n\r\n    struct KeeperInfo {\r\n        uint256 keeperRate;\r\n        uint256 keeperFrom;\r\n        uint256 keeperTill;\r\n        uint256 keeperBalance;\r\n        uint256 keeperPayouts;\r\n        bool isImmutable;\r\n    }\r\n\r\n    mapping(address => KeeperInfo) public keeperList;\r\n\r\n    modifier onlyGateKeeper() {\r\n        require(\r\n            msg.sender == gateKeeper,\r\n            'dgKeeper: keeper denied!'\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyGateOverseer() {\r\n        require(\r\n            msg.sender == gateOverseer,\r\n            'dgKeeper: overseer denied!'\r\n        );\r\n        _;\r\n    }\r\n\r\n    event tokensScraped (\r\n        address indexed scraper,\r\n        uint256 scrapedAmount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event recipientCreated (\r\n        address indexed recipient,\r\n        uint256 timeLock,\r\n        uint256 timeReward,\r\n        uint256 instantReward,\r\n        uint256 timestamp,\r\n        bool isImmutable\r\n    );\r\n\r\n    event recipientDestroyed (\r\n        address indexed recipient,\r\n        uint256 timestamp\r\n    );\r\n\r\n    constructor(\r\n        address _distributionToken,\r\n        address _gateOverseer,\r\n        address _gateKeeper,\r\n        uint256 _minTimeFrame\r\n    ) {\r\n        require(\r\n            _minTimeFrame > 0,\r\n            'dgKeeper: increase _timeFrame'\r\n        );\r\n        distributionToken = _distributionToken;\r\n        gateOverseer = _gateOverseer;\r\n        gateKeeper = _gateKeeper;\r\n        MIN_TIME_FRAME = _minTimeFrame;\r\n    }\r\n\r\n    function allocateTokensBulk(\r\n        address[] memory _recipients,\r\n        uint256[] memory _tokensOpened,\r\n        uint256[] memory _tokensLocked,\r\n        uint256[] memory _timeFrame,\r\n        bool[] memory _immutable\r\n    )\r\n        external\r\n        onlyGateKeeper\r\n    {\r\n        for(uint i = 0; i < _recipients.length; i++) {\r\n            allocateTokens(\r\n                _recipients[i],\r\n                _tokensOpened[i],\r\n                _tokensLocked[i],\r\n                _timeFrame[i],\r\n                _immutable[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function allocateTokens(\r\n        address _recipient,\r\n        uint256 _tokensOpened,\r\n        uint256 _tokensLocked,\r\n        uint256 _timeFrame,\r\n        bool _isImmutable\r\n    )\r\n        public\r\n        onlyGateKeeper\r\n    {\r\n        require(\r\n            _timeFrame >= MIN_TIME_FRAME,\r\n            'dgKeeper: _timeFrame below minimum'\r\n        );\r\n\r\n        require(\r\n            keeperList[_recipient].keeperFrom == 0,\r\n            'dgKeeper: _recipient is active'\r\n        );\r\n\r\n        totalRequired =\r\n        totalRequired\r\n            .add(_tokensOpened)\r\n            .add(_tokensLocked);\r\n\r\n        safeBalanceOf(\r\n            distributionToken,\r\n            address(this),\r\n            totalRequired\r\n        );\r\n\r\n        keeperList[_recipient].keeperFrom = getNow();\r\n        keeperList[_recipient].keeperTill = getNow().add(_timeFrame);\r\n        keeperList[_recipient].keeperRate = _tokensLocked.div(_timeFrame);\r\n        keeperList[_recipient].keeperBalance = _tokensLocked.mod(_timeFrame);\r\n        keeperList[_recipient].isImmutable = _isImmutable;\r\n\r\n        keeperList[_recipient].keeperBalance = \r\n        keeperList[_recipient].keeperBalance.add(_tokensOpened);\r\n\r\n        emit recipientCreated (\r\n            _recipient,\r\n            _timeFrame,\r\n            _tokensLocked,\r\n            _tokensOpened,\r\n            block.timestamp,\r\n            _isImmutable\r\n        );\r\n    }\r\n\r\n    function scrapeMyTokens()\r\n        external\r\n    {\r\n        _scrapeTokens(msg.sender);\r\n    }\r\n\r\n    function scrapeTokens(\r\n        address _recipient\r\n    ) \r\n        external\r\n        onlyGateOverseer\r\n    {\r\n        _scrapeTokens(\r\n            _recipient\r\n        );\r\n    }\r\n\r\n    function _scrapeTokens(\r\n        address _recipient\r\n    )\r\n        internal\r\n    {\r\n       uint256 scrapeAmount =\r\n        availableBalance(_recipient);\r\n\r\n        keeperList[_recipient].keeperPayouts =\r\n        keeperList[_recipient].keeperPayouts.add(scrapeAmount);\r\n\r\n        safeTransfer(\r\n            distributionToken,\r\n            _recipient,\r\n            scrapeAmount\r\n        );\r\n\r\n        totalRequired =\r\n        totalRequired.sub(scrapeAmount);\r\n\r\n        emit tokensScraped (\r\n            _recipient,\r\n            scrapeAmount,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function destroyRecipient(\r\n        address _recipient\r\n    )\r\n        external\r\n        onlyGateOverseer\r\n    {\r\n        require(\r\n            keeperList[_recipient].isImmutable == false,\r\n            'dgKeeper: _recipient is immutable'\r\n        );\r\n\r\n        _scrapeTokens(_recipient);\r\n\r\n        totalRequired =\r\n        totalRequired.sub(\r\n            lockedBalance(_recipient)\r\n        );\r\n\r\n        delete keeperList[_recipient];\r\n        \r\n        emit recipientDestroyed (\r\n            _recipient,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function availableBalance(\r\n        address _recipient\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 timePassed =\r\n            getNow() < keeperList[_recipient].keeperTill\r\n                ? getNow()\r\n                    .sub(keeperList[_recipient].keeperFrom)\r\n                : keeperList[_recipient].keeperTill\r\n                    .sub(keeperList[_recipient].keeperFrom);\r\n\r\n        return keeperList[_recipient].keeperRate\r\n            .mul(timePassed)\r\n            .add(keeperList[_recipient].keeperBalance)\r\n            .sub(keeperList[_recipient].keeperPayouts);\r\n    }\r\n\r\n    function lockedBalance(address _recipient)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 timeRemaining =\r\n            keeperList[_recipient].keeperTill > getNow() ?\r\n            keeperList[_recipient].keeperTill - getNow() : 0;\r\n\r\n        return keeperList[_recipient].keeperRate\r\n            .mul(timeRemaining);\r\n    }\r\n\r\n    function getNow()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function changeDistributionToken(\r\n        address _newDistributionToken\r\n    )\r\n        external\r\n        onlyGateKeeper\r\n    {\r\n        distributionToken = _newDistributionToken;\r\n    }\r\n\r\n    function renounceKeeperOwnership()\r\n        external\r\n        onlyGateKeeper\r\n    {\r\n        gateKeeper = address(0x0);\r\n    }\r\n\r\n    function renounceOverseerOwnership()\r\n        external\r\n        onlyGateOverseer\r\n    {\r\n        gateOverseer = address(0x0);\r\n    }\r\n\r\n    bytes4 private constant TRANSFER = bytes4(\r\n        keccak256(\r\n            bytes(\r\n                'transfer(address,uint256)'\r\n            )\r\n        )\r\n    );\r\n\r\n    bytes4 private constant BALANCEOF = bytes4(\r\n        keccak256(\r\n            bytes(\r\n                'balanceOf(address)'\r\n            )\r\n        )\r\n    );\r\n\r\n    function safeTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        private\r\n    {\r\n        (bool success, bytes memory data) = _token.call(\r\n            abi.encodeWithSelector(\r\n                TRANSFER,\r\n                _to,\r\n                _value\r\n            )\r\n        );\r\n\r\n        require(\r\n            success && (\r\n                data.length == 0 || abi.decode(\r\n                    data, (bool)\r\n                )\r\n            ),\r\n            'dgKeeper: TRANSFER_FAILED'\r\n        );\r\n    }\r\n\r\n    function safeBalanceOf(\r\n        address _token,\r\n        address _owner,\r\n        uint256 _required\r\n    )\r\n        private\r\n    {\r\n        (bool success, bytes memory data) = _token.call(\r\n            abi.encodeWithSelector(\r\n                BALANCEOF,\r\n                _owner\r\n            )\r\n        );\r\n\r\n        require(\r\n            success && abi.decode(\r\n                data, (uint256)\r\n            ) >= _required,\r\n            'dgKeeper: BALANCEOF_FAILED'\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_distributionToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gateOverseer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gateKeeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minTimeFrame\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeLock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"instantReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isImmutable\",\"type\":\"bool\"}],\"name\":\"recipientCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"recipientDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"scraper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"tokensScraped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokensOpened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeFrame\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isImmutable\",\"type\":\"bool\"}],\"name\":\"allocateTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokensOpened\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokensLocked\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_timeFrame\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"_immutable\",\"type\":\"bool[]\"}],\"name\":\"allocateTokensBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"availableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDistributionToken\",\"type\":\"address\"}],\"name\":\"changeDistributionToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateOverseer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"keeperList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperTill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperPayouts\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isImmutable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"lockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceKeeperOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOverseerOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scrapeMyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"scrapeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"dgKeeper","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005b14eb6309f65ab5c5e2824ef1ed412be115985b0000000000000000000000003c383b7ffd5d2bf24ebd1fc8509cefa9b7d1976f0000000000000000000000003c383b7ffd5d2bf24ebd1fc8509cefa9b7d1976f000000000000000000000000000000000000000000000000000000000000012c","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0a35209fb6cabe6998c27c4b17d2ebfc08f14afa88654666994b83877b7a68f2"}]}