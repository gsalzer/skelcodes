{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.7.4;\r\n\r\n\r\nlibrary SafeMathLib {\r\n  function times(uint a, uint b) public pure returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b, 'Overflow detected');\r\n    return c;\r\n  }\r\n\r\n  function minus(uint a, uint b) public pure returns (uint) {\r\n    require(b <= a, 'Underflow detected');\r\n    return a - b;\r\n  }\r\n\r\n  function plus(uint a, uint b) public pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c>=a && c>=b, 'Overflow detected');\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Vault {\r\n    using SafeMathLib for uint;\r\n\r\n    IERC20 public token;\r\n    uint public startBlock = 0;\r\n    uint public numTranches = 0;\r\n\r\n\r\n    struct Tranche {\r\n        uint id;\r\n        address destination;\r\n        uint totalCoins;\r\n        uint currentCoins;\r\n        uint lockPeriodEndBlock;\r\n        uint vestingPeriodEndBlock;\r\n        uint lastWithdrawalBlock;\r\n        uint startBlock;\r\n    }\r\n\r\n    mapping (uint => Tranche) public tranches;\r\n\r\n    event WithdrawalOccurred(uint trancheId, uint numTokens, uint tokensLeft);\r\n    event TrancheAdded(uint id, address destination, uint totalCoins, uint lockPeriodBlocks, uint vestingPeriodEndBlocks, uint startBlock);\r\n\r\n    constructor(address tokenAddr, address[] memory destinations, uint[] memory tokenAllocations, uint[] memory lockPeriods, uint[] memory vestingPeriodEnds, uint[] memory startBlocks) public {\r\n        token = IERC20(tokenAddr);\r\n\r\n        for (uint i = 0; i < destinations.length; i++)  {\r\n            uint trancheId = i + 1;\r\n            tranches[trancheId] = Tranche(\r\n                trancheId,\r\n                destinations[i],\r\n                tokenAllocations[i],\r\n                tokenAllocations[i],\r\n                lockPeriods[i],\r\n                vestingPeriodEnds[i],\r\n                startBlocks[i],\r\n                startBlocks[i]\r\n            );\r\n            emit TrancheAdded(trancheId, destinations[i], tokenAllocations[i], lockPeriods[i], vestingPeriodEnds[i], startBlocks[i]);\r\n        }\r\n        numTranches = destinations.length;\r\n    }\r\n\r\n    function withdraw(uint trancheId) public {\r\n        Tranche storage tranche = tranches[trancheId];\r\n        require(block.number > tranche.lockPeriodEndBlock, 'Must wait until after lock period');\r\n        require(tranche.currentCoins >  0, 'No coins left to withdraw');\r\n        uint currentWithdrawal = 0;\r\n\r\n        // if after vesting period ends, give them the remaining coins\r\n        if (block.number >= tranche.vestingPeriodEndBlock) {\r\n            currentWithdrawal = tranche.currentCoins;\r\n        } else {\r\n            // compute allowed withdrawal\r\n            uint coinsPerBlock = tranche.totalCoins / (tranche.vestingPeriodEndBlock.minus(tranche.startBlock));\r\n            currentWithdrawal = (block.number.minus(tranche.lastWithdrawalBlock)).times(coinsPerBlock);\r\n        }\r\n\r\n        // check that we have enough tokens\r\n        // adding this so we don't have to know in advance how many LP tokens we will get\r\n        uint tokenBalance = token.balanceOf(address(this));\r\n        if (currentWithdrawal > tokenBalance) {\r\n            currentWithdrawal = tokenBalance;\r\n        }\r\n\r\n        // update struct\r\n        tranche.currentCoins = tranche.currentCoins.minus(currentWithdrawal);\r\n        tranche.lastWithdrawalBlock = block.number;\r\n\r\n        // transfer the tokens, brah\r\n        token.transfer(tranche.destination, currentWithdrawal);\r\n        emit WithdrawalOccurred(trancheId, currentWithdrawal, tranche.currentCoins);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"destinations\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAllocations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"lockPeriods\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"vestingPeriodEnds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"startBlocks\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalCoins\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockPeriodBlocks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingPeriodEndBlocks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"TrancheAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"trancheId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensLeft\",\"type\":\"uint256\"}],\"name\":\"WithdrawalOccurred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"numTranches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tranches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockPeriodEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingPeriodEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawalBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"trancheId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Vault","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000075001b3ffe0f77864c7dc64c55e1e22b205e4a0700000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a874fa6ccdccb57d9397247e088575c4ef34ec6600000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000033b2e3c9fd0803ce800000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000cc20f100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000cc20f100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000abd395","EVMVersion":"Default","Library":"SafeMathLib:82d7630c5eb722557de6d76575c9a7b8de718500","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://183bc02c640378a4cdfe99616238e259973d24a4bcc4117d04f7d1065a65c531"}]}