{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-03-02\r\n*/\r\n\r\n// Copyright (C) 2020, 2021 Lev Livnev <lev@liv.nev.org.uk>\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.5.12;\r\n\r\ninterface VatAbstract {\r\n    function wards(address) external view returns (uint256);\r\n    function rely(address) external;\r\n    function deny(address) external;\r\n    function can(address, address) external view returns (uint256);\r\n    function hope(address) external;\r\n    function nope(address) external;\r\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\r\n    function urns(bytes32, address) external view returns (uint256, uint256);\r\n    function gem(bytes32, address) external view returns (uint256);\r\n    function dai(address) external view returns (uint256);\r\n    function sin(address) external view returns (uint256);\r\n    function debt() external view returns (uint256);\r\n    function vice() external view returns (uint256);\r\n    function Line() external view returns (uint256);\r\n    function live() external view returns (uint256);\r\n    function init(bytes32) external;\r\n    function file(bytes32, uint256) external;\r\n    function file(bytes32, bytes32, uint256) external;\r\n    function cage() external;\r\n    function slip(bytes32, address, int256) external;\r\n    function flux(bytes32, address, address, uint256) external;\r\n    function move(address, address, uint256) external;\r\n    function frob(bytes32, address, address, address, int256, int256) external;\r\n    function fork(bytes32, address, address, int256, int256) external;\r\n    function grab(bytes32, address, address, address, int256, int256) external;\r\n    function heal(uint256) external;\r\n    function suck(address, address, uint256) external;\r\n    function fold(bytes32, address, int256) external;\r\n}\r\n\r\ninterface DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) external view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity >=0.4.23;\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint256           wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue()\r\n        }\r\n\r\n        _;\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    //rounds to zero if x*y < RAY / 2\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n    function S(string memory s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(abi.encodePacked(s)));\r\n    }\r\n\r\n}\r\n\r\ncontract DSValue is DSThing {\r\n    bool    has;\r\n    bytes32 val;\r\n    function peek() public view returns (bytes32, bool) {\r\n        return (val,has);\r\n    }\r\n    function read() public view returns (bytes32) {\r\n        bytes32 wut; bool haz;\r\n        (wut, haz) = peek();\r\n        require(haz, \"haz-not\");\r\n        return wut;\r\n    }\r\n    function poke(bytes32 wut) public note auth {\r\n        val = wut;\r\n        has = true;\r\n    }\r\n    function void() public note auth {  // unset the value\r\n        has = false;\r\n    }\r\n}\r\n\r\ncontract RwaLiquidationOracle {\r\n    // --- auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth {\r\n        wards[usr] = 1;\r\n        emit Rely(usr);\r\n    }\r\n    function deny(address usr) external auth {\r\n        wards[usr] = 0;\r\n        emit Deny(usr);\r\n    }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"RwaOracle/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- math ---\r\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    VatAbstract public vat;\r\n    address     public vow;\r\n    struct Ilk {\r\n        string  doc; // hash of borrower's agreement with MakerDAO\r\n        address pip; // DSValue tracking nominal loan value\r\n        uint48  tau; // pre-agreed remediation period\r\n        uint48  toc; // timestamp when liquidation initiated\r\n    }\r\n    mapping (bytes32 => Ilk) public ilks;\r\n\r\n    // Events\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n    event File(bytes32 indexed what, address data);\r\n    event Init(bytes32 indexed ilk, uint256 val, string doc, uint48 tau);\r\n    event Bump(bytes32 indexed ilk, uint256 val);\r\n    event Tell(bytes32 indexed ilk);\r\n    event Cure(bytes32 indexed ilk);\r\n    event Cull(bytes32 indexed ilk, address indexed urn);\r\n\r\n    constructor(address vat_, address vow_) public {\r\n        vat = VatAbstract(vat_);\r\n        vow = vow_;\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n        emit File(\"vow\", vow_);\r\n    }\r\n\r\n    // --- administration ---\r\n    function file(bytes32 what, address data) external auth {\r\n        if (what == \"vow\") { vow = data; }\r\n        else revert(\"RwaOracle/unrecognised-param\");\r\n        emit File(what, data);\r\n    }\r\n\r\n    function init(bytes32 ilk, uint256 val, string calldata doc, uint48 tau) external auth {\r\n        // doc, and tau can be amended, but tau cannot decrease\r\n        require(tau >= ilks[ilk].tau, \"RwaOracle/decreasing-tau\");\r\n        ilks[ilk].doc = doc;\r\n        ilks[ilk].tau = tau;\r\n        if (ilks[ilk].pip == address(0)) {\r\n            DSValue pip = new DSValue();\r\n            ilks[ilk].pip = address(pip);\r\n            pip.poke(bytes32(val));\r\n        } else {\r\n            val = uint256(DSValue(ilks[ilk].pip).read());\r\n        }\r\n        emit Init(ilk, val, doc, tau);\r\n    }\r\n\r\n    // --- valuation adjustment ---\r\n    function bump(bytes32 ilk, uint256 val) external auth {\r\n        DSValue pip = DSValue(ilks[ilk].pip);\r\n        require(address(pip) != address(0), \"RwaOracle/unknown-ilk\");\r\n        require(ilks[ilk].toc == 0, \"RwaOracle/in-remediation\");\r\n        // only cull can decrease\r\n        require(val >= uint256(pip.read()), \"RwaOracle/decreasing-val\");\r\n        pip.poke(bytes32(val));\r\n        emit Bump(ilk, val);\r\n    }\r\n    // --- liquidation ---\r\n    function tell(bytes32 ilk) external auth {\r\n        (,,,uint256 line,) = vat.ilks(ilk);\r\n        // DC must be set to zero first\r\n        require(line == 0, \"RwaOracle/nonzero-line\");\r\n        require(ilks[ilk].pip != address(0), \"RwaOracle/unknown-ilk\");\r\n        ilks[ilk].toc = uint48(block.timestamp);\r\n        emit Tell(ilk);\r\n    }\r\n    // --- remediation ---\r\n    function cure(bytes32 ilk) external auth {\r\n        require(ilks[ilk].pip != address(0), \"RwaOracle/unknown-ilk\");\r\n        require(ilks[ilk].toc > 0, \"RwaOracle/not-in-remediation\");\r\n        ilks[ilk].toc = 0;\r\n        emit Cure(ilk);\r\n    }\r\n    // --- write-off ---\r\n    function cull(bytes32 ilk, address urn) external auth {\r\n        require(ilks[ilk].pip != address(0), \"RwaOracle/unknown-ilk\");\r\n        require(block.timestamp >= add(ilks[ilk].toc, ilks[ilk].tau), \"RwaOracle/early-cull\");\r\n\r\n        DSValue(ilks[ilk].pip).poke(bytes32(uint256(0)));\r\n\r\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\r\n        require(ink <= 2 ** 255, \"RwaOracle/overflow\");\r\n        require(art <= 2 ** 255, \"RwaOracle/overflow\");\r\n\r\n        vat.grab(ilk,\r\n                 address(urn),\r\n                 address(this),\r\n                 address(vow),\r\n                 -int256(ink),\r\n                 -int256(art));\r\n        emit Cull(ilk, urn);\r\n    }\r\n\r\n    // --- liquidation check ---\r\n    // to be called by off-chain parties (e.g. a trustee) to check the standing of the loan\r\n    function good(bytes32 ilk) external view returns (bool) {\r\n        require(ilks[ilk].pip != address(0), \"RwaOracle/unknown-ilk\");\r\n        // tell not called or still in remediation period\r\n        return (ilks[ilk].toc == 0 || block.timestamp < add(ilks[ilk].toc, ilks[ilk].tau));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vat_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vow_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"Bump\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"urn\",\"type\":\"address\"}],\"name\":\"Cull\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"Cure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"doc\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"tau\",\"type\":\"uint48\"}],\"name\":\"Init\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"Tell\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"bump\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"urn\",\"type\":\"address\"}],\"name\":\"cull\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"cure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"file\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"good\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ilks\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"doc\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"pip\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"tau\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"toc\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"doc\",\"type\":\"string\"},{\"internalType\":\"uint48\",\"name\":\"tau\",\"type\":\"uint48\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"tell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract VatAbstract\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RwaLiquidationOracle","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000035D1b3F3D7966A1DFe207aa4514C12a259A0492B000000000000000000000000A950524441892A31ebddF91d3cEEFa04Bf454466","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e15deb7225711df4bf70ed86db4786bf0395886e2ea1ce3f6e642b9a0c67b926"}]}