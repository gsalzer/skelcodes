{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOAssetHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nlibrary ACOAssetHelper {\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get if the address is for Ethereum (0x0).\\r\\n     * @param _address Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address _address) internal pure returns(bool) {\\r\\n        return _address == address(0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to approve ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param spender Authorized address.\\r\\n     * @param amount Amount to authorize.\\r\\n     */\\r\\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callApproveERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callTransferERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to call transferFrom on ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param sender Address of the sender.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callTransferFromERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset symbol.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset symbol.\\r\\n     */\\r\\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetSymbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset decimals.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset decimals.\\r\\n     */\\r\\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\\r\\n        if (_isEther(asset)) {\\r\\n            return uint8(18);\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetDecimals\\\");\\r\\n            return abi.decode(returndata, (uint8));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to the asset name.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset name.\\r\\n     */\\r\\n    function _getAssetName(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"Ethereum\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetName\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset balance of an account.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param account Address of the account.\\r\\n     * @return The account balance.\\r\\n     */\\r\\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return account.balance;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetBalanceOf\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset allowance between two addresses.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @return The owner allowance for the spender.\\r\\n     */\\r\\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetAllowance\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer an asset. \\r\\n     * @param asset Address of the asset to be transferred.\\r\\n     * @param to Address of the destination.\\r\\n     * @param amount The amount to be transferred.\\r\\n     */\\r\\n    function _transferAsset(address asset, address to, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            (bool success,) = to.call{value:amount}(new bytes(0));\\r\\n            require(success, \\u0027ACOAssetHelper::_transferAsset\\u0027);\\r\\n        } else {\\r\\n            _callTransferERC20(asset, to, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to receive an asset. \\r\\n     * @param asset Address of the asset to be received.\\r\\n     * @param amount The amount to be received.\\r\\n     */\\r\\n    function _receiveAsset(address asset, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            require(msg.value == amount, \\\"ACOAssetHelper:: Invalid ETH amount\\\");\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"ACOAssetHelper:: Ether is not expected\\\");\\r\\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @param amount Amount to check allowance.\\r\\n     */\\r\\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\\r\\n        if (_getAssetAllowance(asset, owner, spender) \\u003c amount) {\\r\\n            _callApproveERC20(asset, spender, MAX_UINT);\\r\\n        }\\r\\n    }\\r\\n}\"},\"ACONameFormatter.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\u0027./BokkyPooBahsDateTimeLibrary.sol\\u0027;\\r\\nimport \\u0027./Strings.sol\\u0027;\\r\\n\\r\\nlibrary ACONameFormatter {\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the `value` formatted.\\r\\n\\t * The function returns a string for the `value` with a point (character \\u0027.\\u0027) in the proper position considering the `decimals`.\\r\\n\\t * Beyond that, the string returned presents only representative digits.\\r\\n\\t * For example, a `value` with 18 decimals:\\r\\n\\t *  - For 100000000000000000000 the return is \\\"100\\\"\\r\\n\\t *  - For 100100000000000000000 the return is \\\"100.1\\\"\\r\\n\\t *  - For 100000000000000000 the return is \\\"0.1\\\"\\r\\n\\t *  - For 100000000000000 the return is \\\"0.0001\\\"\\r\\n\\t *  - For 100000000000000000001 the return is \\\"100.000000000000000001\\\"\\r\\n\\t * @param value The number to be formatted.\\r\\n\\t * @param decimals The respective number decimals.\\r\\n     * @return The value formatted on a string.\\r\\n     */\\r\\n    function formatNumber(uint256 value, uint8 decimals) internal pure returns(string memory) {\\r\\n        uint256 digits;\\r\\n        uint256 count;\\r\\n        bool foundRepresentativeDigit = false;\\r\\n        uint256 addPointAt = 0;\\r\\n        uint256 temp = value;\\r\\n        uint256 number = value;\\r\\n        while (temp != 0) {\\r\\n            if (!foundRepresentativeDigit \\u0026\\u0026 (temp % 10 != 0 || count == uint256(decimals))) {\\r\\n                foundRepresentativeDigit = true;\\r\\n                number = temp;\\r\\n            }\\r\\n            if (foundRepresentativeDigit) {\\r\\n                if (count == uint256(decimals)) {\\r\\n                    addPointAt = digits;\\r\\n                }\\r\\n                digits++;\\r\\n            }\\r\\n            temp /= 10;\\r\\n            count++;\\r\\n        }\\r\\n        if (count \\u003c= uint256(decimals)) {\\r\\n            digits = digits + 2 + uint256(decimals) - count;\\r\\n            addPointAt = digits - 2;\\r\\n        } else if (addPointAt \\u003e 0) {\\r\\n            digits++;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        uint256 index = digits - 1;\\r\\n        temp = number;\\r\\n        for (uint256 i = 0; i \\u003c digits; ++i) {\\r\\n            if (i \\u003e 0 \\u0026\\u0026 i == addPointAt) {\\r\\n                buffer[index--] = byte(\\\".\\\");\\r\\n            } else if (number == 0) {\\r\\n                buffer[index--] = byte(\\\"0\\\");\\r\\n            } else {\\r\\n                buffer[index--] = byte(uint8(48 + number % 10));\\r\\n                number /= 10;\\r\\n            }\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the `unixTime` formatted.\\r\\n     * @param unixTime The UNIX time to be formatted.\\r\\n     * @return The unix time formatted on a string.\\r\\n     */\\r\\n    function formatTime(uint256 unixTime) internal pure returns(string memory) {\\r\\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute,) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(unixTime); \\r\\n        return string(abi.encodePacked(\\r\\n            _getDateNumberWithTwoCharacters(day),\\r\\n            _getMonthFormatted(month),\\r\\n            _getYearFormatted(year),\\r\\n            \\\"-\\\",\\r\\n            _getDateNumberWithTwoCharacters(hour),\\r\\n            _getDateNumberWithTwoCharacters(minute),\\r\\n            \\\"UTC\\\"\\r\\n            )); \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the token type description.\\r\\n     * @return The token type description.\\r\\n     */\\r\\n    function formatType(bool isCall) internal pure returns(string memory) {\\r\\n        if (isCall) {\\r\\n            return \\\"C\\\";\\r\\n        } else {\\r\\n            return \\\"P\\\";\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the year formatted with 2 characters.\\r\\n     * @return The year formatted.\\r\\n     */\\r\\n    function _getYearFormatted(uint256 year) private pure returns(string memory) {\\r\\n        bytes memory yearBytes = bytes(Strings.toString(year));\\r\\n        bytes memory result = new bytes(2);\\r\\n        uint256 startIndex = yearBytes.length - 2;\\r\\n        for (uint256 i = startIndex; i \\u003c yearBytes.length; i++) {\\r\\n            result[i - startIndex] = yearBytes[i];\\r\\n        }\\r\\n        return string(result);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the month abbreviation.\\r\\n     * @return The month abbreviation.\\r\\n     */\\r\\n    function _getMonthFormatted(uint256 month) private pure returns(string memory) {\\r\\n        if (month == 1) {\\r\\n            return \\\"JAN\\\";\\r\\n        } else if (month == 2) {\\r\\n            return \\\"FEB\\\";\\r\\n        } else if (month == 3) {\\r\\n            return \\\"MAR\\\";\\r\\n        } else if (month == 4) {\\r\\n            return \\\"APR\\\";\\r\\n        } else if (month == 5) {\\r\\n            return \\\"MAY\\\";\\r\\n        } else if (month == 6) {\\r\\n            return \\\"JUN\\\";\\r\\n        } else if (month == 7) {\\r\\n            return \\\"JUL\\\";\\r\\n        } else if (month == 8) {\\r\\n            return \\\"AUG\\\";\\r\\n        } else if (month == 9) {\\r\\n            return \\\"SEP\\\";\\r\\n        } else if (month == 10) {\\r\\n            return \\\"OCT\\\";\\r\\n        } else if (month == 11) {\\r\\n            return \\\"NOV\\\";\\r\\n        } else if (month == 12) {\\r\\n            return \\\"DEC\\\";\\r\\n        } else {\\r\\n            return \\\"INVALID\\\";\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the date number with 2 characters.\\r\\n     * @return The 2 characters for the number.\\r\\n     */\\r\\n    function _getDateNumberWithTwoCharacters(uint256 number) private pure returns(string memory) {\\r\\n        string memory _string = Strings.toString(number);\\r\\n        if (number \\u003c 10) {\\r\\n            return string(abi.encodePacked(\\\"0\\\", _string));\\r\\n        } else {\\r\\n            return _string;\\r\\n        }\\r\\n    }\\r\\n}\"},\"ACOPool.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./Ownable.sol\\u0027;\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\nimport \\u0027./ACONameFormatter.sol\\u0027;\\r\\nimport \\u0027./ACOAssetHelper.sol\\u0027;\\r\\nimport \\u0027./ERC20.sol\\u0027;\\r\\nimport \\u0027./IACOPool.sol\\u0027;\\r\\nimport \\u0027./IACOFactory.sol\\u0027;\\r\\nimport \\u0027./IACOStrategy.sol\\u0027;\\r\\nimport \\u0027./IACOToken.sol\\u0027;\\r\\nimport \\u0027./IACOFlashExercise.sol\\u0027;\\r\\nimport \\u0027./IACOAssetConverterHelper.sol\\u0027;\\r\\nimport \\u0027./IChiToken.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title ACOPool\\r\\n * @dev A pool contract to trade ACO tokens.\\r\\n */\\r\\ncontract ACOPool is Ownable, ERC20, IACOPool {\\r\\n    using Address for address;\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    uint256 internal constant POOL_PRECISION = 1000000000000000000; // 18 decimals\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Struct to store an ACO token trade data.\\r\\n     */\\r\\n    struct ACOTokenData {\\r\\n\\t\\t/**\\r\\n         * @dev Amount of tokens sold by the pool.\\r\\n         */\\r\\n        uint256 amountSold;\\r\\n\\t\\t\\r\\n\\t\\t/**\\r\\n         * @dev Amount of tokens purchased by the pool.\\r\\n         */\\r\\n        uint256 amountPurchased;\\r\\n\\t\\t\\r\\n\\t\\t/**\\r\\n         * @dev Index of the ACO token on the stored array.\\r\\n         */\\r\\n        uint256 index;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Emitted when the strategy address has been changed.\\r\\n     * @param oldStrategy Address of the previous strategy.\\r\\n     * @param newStrategy Address of the new strategy.\\r\\n     */\\r\\n    event SetStrategy(address indexed oldStrategy, address indexed newStrategy);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the base volatility has been changed.\\r\\n     * @param oldBaseVolatility Value of the previous base volatility.\\r\\n     * @param newBaseVolatility Value of the new base volatility.\\r\\n     */\\r\\n    event SetBaseVolatility(uint256 indexed oldBaseVolatility, uint256 indexed newBaseVolatility);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when a collateral has been deposited on the pool.\\r\\n     * @param account Address of the account.\\r\\n     * @param amount Amount deposited.\\r\\n     */\\r\\n    event CollateralDeposited(address indexed account, uint256 amount);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the collateral and premium have been redeemed on the pool.\\r\\n     * @param account Address of the account.\\r\\n     * @param underlyingAmount Amount of underlying asset redeemed.\\r\\n     * @param strikeAssetAmount Amount of strike asset redeemed.\\r\\n     */\\r\\n    event Redeem(address indexed account, uint256 underlyingAmount, uint256 strikeAssetAmount);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the collateral has been restored on the pool.\\r\\n     * @param amountOut Amount of the premium sold.\\r\\n     * @param collateralIn Amount of collateral restored.\\r\\n     */\\r\\n    event RestoreCollateral(uint256 amountOut, uint256 collateralIn);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when an ACO token has been redeemed.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param collateralIn Amount of collateral redeemed.\\r\\n     * @param amountSold Total amount of ACO token sold by the pool.\\r\\n     * @param amountPurchased Total amount of ACO token purchased by the pool.\\r\\n     */\\r\\n    event ACORedeem(address indexed acoToken, uint256 collateralIn, uint256 amountSold, uint256 amountPurchased);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when an ACO token has been exercised.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens exercised.\\r\\n     * @param collateralIn Amount of collateral received.\\r\\n     */\\r\\n    event ACOExercise(address indexed acoToken, uint256 tokenAmount, uint256 collateralIn);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when an ACO token has been bought or sold by the pool.\\r\\n     * @param isPoolSelling True whether the pool is selling an ACO token, otherwise the pool is buying.\\r\\n     * @param account Address of the account that is doing the swap.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens swapped.\\r\\n     * @param price Value of the premium paid in strike asset.\\r\\n     * @param protocolFee Value of the protocol fee paid in strike asset.\\r\\n     * @param underlyingPrice The underlying price in strike asset.\\r\\n     */\\r\\n    event Swap(\\r\\n        bool indexed isPoolSelling, \\r\\n        address indexed account, \\r\\n        address indexed acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 price, \\r\\n        uint256 protocolFee,\\r\\n        uint256 underlyingPrice\\r\\n    );\\r\\n    \\r\\n\\t/**\\r\\n\\t * @dev UNIX timestamp that the pool can start to trade ACO tokens.\\r\\n\\t */\\r\\n    uint256 public poolStart;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev The protocol fee percentage. (100000 = 100%)\\r\\n\\t */\\r\\n    uint256 public fee;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the ACO flash exercise contract.\\r\\n\\t */\\r\\n    IACOFlashExercise public acoFlashExercise;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the ACO factory contract.\\r\\n\\t */\\r\\n    IACOFactory public acoFactory;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the asset converter helper.\\r\\n\\t */\\r\\n    IACOAssetConverterHelper public assetConverterHelper;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the Chi gas token.\\r\\n\\t */\\r\\n    IChiToken public chiToken;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the protocol fee destination.\\r\\n\\t */\\r\\n    address public feeDestination;\\r\\n    \\r\\n\\t/**\\r\\n\\t * @dev Address of the underlying asset accepts by the pool.\\r\\n\\t */\\r\\n    address public underlying;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the strike asset accepts by the pool.\\r\\n\\t */\\r\\n    address public strikeAsset;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Value of the minimum strike price on ACO token that the pool accept to trade.\\r\\n\\t */\\r\\n    uint256 public minStrikePrice;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Value of the maximum strike price on ACO token that the pool accept to trade.\\r\\n\\t */\\r\\n    uint256 public maxStrikePrice;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Value of the minimum UNIX expiration on ACO token that the pool accept to trade.\\r\\n\\t */\\r\\n    uint256 public minExpiration;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Value of the maximum UNIX expiration on ACO token that the pool accept to trade.\\r\\n\\t */\\r\\n    uint256 public maxExpiration;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev True whether the pool accepts CALL options, otherwise the pool accepts only PUT options. \\r\\n\\t */\\r\\n    bool public isCall;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev True whether the pool can also buy ACO tokens, otherwise the pool only sells ACO tokens. \\r\\n\\t */\\r\\n    bool public canBuy;\\r\\n    \\r\\n\\t/**\\r\\n\\t * @dev Address of the strategy. \\r\\n\\t */\\r\\n    IACOStrategy public strategy;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Percentage value for the base volatility. (100000 = 100%) \\r\\n\\t */\\r\\n    uint256 public baseVolatility;\\r\\n    \\r\\n\\t/**\\r\\n\\t * @dev Total amount of collateral deposited.  \\r\\n\\t */\\r\\n    uint256 public collateralDeposited;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Total amount in strike asset spent buying ACO tokens.  \\r\\n\\t */\\r\\n    uint256 public strikeAssetSpentBuying;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Total amount in strike asset earned selling ACO tokens.  \\r\\n\\t */\\r\\n    uint256 public strikeAssetEarnedSelling;\\r\\n    \\r\\n\\t/**\\r\\n\\t * @dev Array of ACO tokens currently negotiated.  \\r\\n\\t */\\r\\n    address[] public acoTokens;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Mapping for ACO tokens data currently negotiated.  \\r\\n\\t */\\r\\n    mapping(address =\\u003e ACOTokenData) public acoTokensData;\\r\\n    \\r\\n\\t/**\\r\\n\\t * @dev Underlying asset precision. (18 decimals = 1000000000000000000)\\r\\n\\t */\\r\\n    uint256 internal underlyingPrecision;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Strike asset precision. (6 decimals = 1000000)\\r\\n\\t */\\r\\n    uint256 internal strikeAssetPrecision;\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Modifier to check if the pool is open to trade.\\r\\n     */\\r\\n    modifier open() {\\r\\n        require(isStarted() \\u0026\\u0026 notFinished(), \\\"ACOPool:: Pool is not open\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Modifier to apply the Chi gas token and save gas.\\r\\n     */\\r\\n    modifier discountCHI {\\r\\n        uint256 gasStart = gasleft();\\r\\n        _;\\r\\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\\r\\n        chiToken.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\\r\\n    }\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Function to initialize the contract.\\r\\n     * It should be called by the ACO pool factory when creating the pool.\\r\\n     * It must be called only once. The first `require` is to guarantee that behavior.\\r\\n     * @param initData The initialize data.\\r\\n     */\\r\\n    function init(InitData calldata initData) external override {\\r\\n        require(underlying == address(0) \\u0026\\u0026 strikeAsset == address(0) \\u0026\\u0026 minExpiration == 0, \\\"ACOPool::init: Already initialized\\\");\\r\\n        \\r\\n        require(initData.acoFactory.isContract(), \\\"ACOPool:: Invalid ACO Factory\\\");\\r\\n        require(initData.acoFlashExercise.isContract(), \\\"ACOPool:: Invalid ACO flash exercise\\\");\\r\\n        require(initData.chiToken.isContract(), \\\"ACOPool:: Invalid Chi Token\\\");\\r\\n\\t\\trequire(initData.assetConverterHelper.isContract(), \\\"ACOPool:: Invalid asset converter helper\\\");\\r\\n        require(initData.fee \\u003c= 12500, \\\"ACOPool:: The maximum fee allowed is 12.5%\\\");\\r\\n        require(initData.poolStart \\u003e block.timestamp, \\\"ACOPool:: Invalid pool start\\\");\\r\\n        require(initData.minExpiration \\u003e block.timestamp, \\\"ACOPool:: Invalid expiration\\\");\\r\\n        require(initData.minStrikePrice \\u003c= initData.maxStrikePrice, \\\"ACOPool:: Invalid strike price range\\\");\\r\\n        require(initData.minStrikePrice \\u003e 0, \\\"ACOPool:: Invalid strike price\\\");\\r\\n        require(initData.minExpiration \\u003c= initData.maxExpiration, \\\"ACOPool:: Invalid expiration range\\\");\\r\\n        require(initData.underlying != initData.strikeAsset, \\\"ACOPool:: Same assets\\\");\\r\\n        require(ACOAssetHelper._isEther(initData.underlying) || initData.underlying.isContract(), \\\"ACOPool:: Invalid underlying\\\");\\r\\n        require(ACOAssetHelper._isEther(initData.strikeAsset) || initData.strikeAsset.isContract(), \\\"ACOPool:: Invalid strike asset\\\");\\r\\n        \\r\\n        super.init();\\r\\n        \\r\\n        poolStart = initData.poolStart;\\r\\n        acoFlashExercise = IACOFlashExercise(initData.acoFlashExercise);\\r\\n        acoFactory = IACOFactory(initData.acoFactory);\\r\\n        chiToken = IChiToken(initData.chiToken);\\r\\n\\t\\tassetConverterHelper = IACOAssetConverterHelper(initData.assetConverterHelper);\\r\\n\\t\\t\\r\\n        fee = initData.fee;\\r\\n        feeDestination = initData.feeDestination;\\r\\n        underlying = initData.underlying;\\r\\n        strikeAsset = initData.strikeAsset;\\r\\n        minStrikePrice = initData.minStrikePrice;\\r\\n        maxStrikePrice = initData.maxStrikePrice;\\r\\n        minExpiration = initData.minExpiration;\\r\\n        maxExpiration = initData.maxExpiration;\\r\\n        isCall = initData.isCall;\\r\\n        canBuy = initData.canBuy;\\r\\n\\t\\t\\r\\n        _setStrategy(initData.strategy);\\r\\n        _setBaseVolatility(initData.baseVolatility);\\r\\n        \\r\\n        _setAssetsPrecision(initData.underlying, initData.strikeAsset);\\r\\n        \\r\\n        _approveAssetsOnConverterHelper(initData.isCall, initData.canBuy, initData.assetConverterHelper, initData.underlying, initData.strikeAsset);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the token name.\\r\\n     */\\r\\n    function name() public view override returns(string memory) {\\r\\n        return _name();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the token symbol, that it is equal to the name.\\r\\n     */\\r\\n    function symbol() public view override returns(string memory) {\\r\\n        return _name();\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to get the token decimals.\\r\\n     */\\r\\n    function decimals() public view override returns(uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to get whether the pool already started trade ACO tokens.\\r\\n     */\\r\\n    function isStarted() public view returns(bool) {\\r\\n        return block.timestamp \\u003e= poolStart;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to get whether the pool is not finished.\\r\\n     */\\r\\n    function notFinished() public view returns(bool) {\\r\\n        return block.timestamp \\u003c maxExpiration;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to get the number of ACO tokens currently negotiated.\\r\\n     */\\r\\n    function numberOfACOTokensCurrentlyNegotiated() public override view returns(uint256) {\\r\\n        return acoTokens.length;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to get the pool collateral asset.\\r\\n     */\\r\\n    function collateral() public override view returns(address) {\\r\\n        if (isCall) {\\r\\n            return underlying;\\r\\n        } else {\\r\\n            return strikeAsset;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to quote an ACO token swap.\\r\\n     * @param isBuying True whether it is quoting to buy an ACO token, otherwise it is quoting to sell an ACO token.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @return The swap price, the protocol fee charged on the swap, and the underlying price in strike asset.\\r\\n     */\\r\\n    function quote(bool isBuying, address acoToken, uint256 tokenAmount) open public override view returns(uint256, uint256, uint256) {\\r\\n        (uint256 swapPrice, uint256 protocolFee, uint256 underlyingPrice,) = _internalQuote(isBuying, acoToken, tokenAmount);\\r\\n        return (swapPrice, protocolFee, underlyingPrice);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the pool strategy address.\\r\\n     * Only can be called by the ACO pool factory contract.\\r\\n     * @param newStrategy Address of the new strategy.\\r\\n     */\\r\\n    function setStrategy(address newStrategy) onlyOwner external override {\\r\\n        _setStrategy(newStrategy);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to set the pool base volatility percentage. (100000 = 100%)\\r\\n     * Only can be called by the ACO pool factory contract.\\r\\n     * @param newBaseVolatility Value of the new base volatility.\\r\\n     */\\r\\n    function setBaseVolatility(uint256 newBaseVolatility) onlyOwner external override {\\r\\n        _setBaseVolatility(newBaseVolatility);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to deposit on the pool.\\r\\n     * Only can be called when the pool is not started.\\r\\n     * @param collateralAmount Amount of collateral to be deposited.\\r\\n     * @param to Address of the destination of the pool token.\\r\\n     * @return The amount of pool tokens minted.\\r\\n     */\\r\\n    function deposit(uint256 collateralAmount, address to) public override payable returns(uint256) {\\r\\n        require(!isStarted(), \\\"ACOPool:: Pool already started\\\");\\r\\n        require(collateralAmount \\u003e 0, \\\"ACOPool:: Invalid collateral amount\\\");\\r\\n        require(to != address(0) \\u0026\\u0026 to != address(this), \\\"ACOPool:: Invalid to\\\");\\r\\n        \\r\\n        (uint256 normalizedAmount, uint256 amount) = _getNormalizedDepositAmount(collateralAmount);\\r\\n        \\r\\n        ACOAssetHelper._receiveAsset(collateral(), amount);\\r\\n        \\r\\n        collateralDeposited = collateralDeposited.add(amount);\\r\\n        _mintAction(to, normalizedAmount);\\r\\n        \\r\\n        emit CollateralDeposited(msg.sender, amount);\\r\\n        \\r\\n        return normalizedAmount;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to swap an ACO token with the pool.\\r\\n     * Only can be called when the pool is opened.\\r\\n     * @param isBuying True whether it is quoting to buy an ACO token, otherwise it is quoting to sell an ACO token.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @param restriction Value of the swap restriction. The minimum premium to receive on a selling or the maximum value to pay on a purchase.\\r\\n     * @param to Address of the destination. ACO tokens when is buying or strike asset on a selling.\\r\\n     * @param deadline UNIX deadline for the swap to be executed.\\r\\n     * @return The amount ACO tokens received when is buying or the amount of strike asset received on a selling.\\r\\n     */\\r\\n    function swap(\\r\\n        bool isBuying, \\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 restriction, \\r\\n        address to, \\r\\n        uint256 deadline\\r\\n    ) open public override returns(uint256) {\\r\\n        return _swap(isBuying, acoToken, tokenAmount, restriction, to, deadline);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to swap an ACO token with the pool and use Chi token to save gas.\\r\\n     * Only can be called when the pool is opened.\\r\\n     * @param isBuying True whether it is quoting to buy an ACO token, otherwise it is quoting to sell an ACO token.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @param restriction Value of the swap restriction. The minimum premium to receive on a selling or the maximum value to pay on a purchase.\\r\\n     * @param to Address of the destination. ACO tokens when is buying or strike asset on a selling.\\r\\n     * @param deadline UNIX deadline for the swap to be executed.\\r\\n     * @return The amount ACO tokens received when is buying or the amount of strike asset received on a selling.\\r\\n     */\\r\\n    function swapWithGasToken(\\r\\n        bool isBuying, \\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 restriction, \\r\\n        address to, \\r\\n        uint256 deadline\\r\\n    ) open discountCHI public override returns(uint256) {\\r\\n        return _swap(isBuying, acoToken, tokenAmount, restriction, to, deadline);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to redeem the collateral and the premium from the pool.\\r\\n     * Only can be called when the pool is finished.\\r\\n     * @return The amount of underlying asset received and the amount of strike asset received.\\r\\n     */\\r\\n    function redeem() public override returns(uint256, uint256) {\\r\\n        return _redeem(msg.sender);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to redeem the collateral and the premium from the pool from an account.\\r\\n     * Only can be called when the pool is finished.\\r\\n     * The allowance must be respected.\\r\\n     * The transaction sender will receive the redeemed assets.\\r\\n     * @param account Address of the account.\\r\\n     * @return The amount of underlying asset received and the amount of strike asset received.\\r\\n     */\\r\\n    function redeemFrom(address account) public override returns(uint256, uint256) {\\r\\n        return _redeem(account);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to redeem the collateral from the ACO tokens negotiated on the pool.\\r\\n     * It redeems the collateral only if the respective ACO token is expired.\\r\\n     */\\r\\n    function redeemACOTokens() public override {\\r\\n        for (uint256 i = acoTokens.length; i \\u003e 0; --i) {\\r\\n            address acoToken = acoTokens[i - 1];\\r\\n\\t\\t\\tuint256 expiryTime = IACOToken(acoToken).expiryTime();\\r\\n            _redeemACOToken(acoToken, expiryTime);\\r\\n        }\\r\\n    }\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Function to redeem the collateral from an ACO token.\\r\\n     * It redeems the collateral only if the ACO token is expired.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     */\\r\\n\\tfunction redeemACOToken(address acoToken) public override {\\r\\n        (,uint256 expiryTime) = _getValidACOTokenStrikePriceAndExpiration(acoToken);\\r\\n\\t\\t_redeemACOToken(acoToken, expiryTime);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to exercise an ACO token negotiated on the pool.\\r\\n     * Only ITM ACO tokens are exercisable.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     */\\r\\n    function exerciseACOToken(address acoToken) public override {\\r\\n        (uint256 strikePrice, uint256 expiryTime) = _getValidACOTokenStrikePriceAndExpiration(acoToken);\\r\\n        uint256 exercisableAmount = _getExercisableAmount(acoToken);\\r\\n        require(exercisableAmount \\u003e 0, \\\"ACOPool:: Exercise is not available\\\");\\r\\n        \\r\\n        address _strikeAsset = strikeAsset;\\r\\n        address _underlying = underlying;\\r\\n        bool _isCall = isCall;\\r\\n        \\r\\n        uint256 collateralAmount;\\r\\n        address _collateral;\\r\\n        if (_isCall) {\\r\\n            _collateral = _underlying;\\r\\n            collateralAmount = exercisableAmount;\\r\\n        } else {\\r\\n            _collateral = _strikeAsset;\\r\\n            collateralAmount = IACOToken(acoToken).getCollateralAmount(exercisableAmount);\\r\\n            \\r\\n        }\\r\\n        uint256 collateralAvailable = _getPoolBalanceOf(_collateral);\\r\\n        \\r\\n        ACOTokenData storage data = acoTokensData[acoToken];\\r\\n        (bool canExercise, uint256 minIntrinsicValue) = strategy.checkExercise(IACOStrategy.CheckExercise(\\r\\n            _underlying,\\r\\n            _strikeAsset,\\r\\n            _isCall,\\r\\n            strikePrice, \\r\\n            expiryTime,\\r\\n            collateralAmount,\\r\\n            collateralAvailable,\\r\\n            data.amountPurchased,\\r\\n            data.amountSold\\r\\n        ));\\r\\n        require(canExercise, \\\"ACOPool:: Exercise is not possible\\\");\\r\\n        \\r\\n        if (IACOToken(acoToken).allowance(address(this), address(acoFlashExercise)) \\u003c exercisableAmount) {\\r\\n            _setAuthorizedSpender(acoToken, address(acoFlashExercise));    \\r\\n        }\\r\\n        acoFlashExercise.flashExercise(acoToken, exercisableAmount, minIntrinsicValue, block.timestamp);\\r\\n        \\r\\n        uint256 collateralIn = _getPoolBalanceOf(_collateral).sub(collateralAvailable);\\r\\n        emit ACOExercise(acoToken, exercisableAmount, collateralIn);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to restore the collateral on the pool by selling the other asset balance.\\r\\n     */\\r\\n    function restoreCollateral() public override {\\r\\n        address _strikeAsset = strikeAsset;\\r\\n        address _underlying = underlying;\\r\\n        bool _isCall = isCall;\\r\\n        \\r\\n        uint256 balanceOut;\\r\\n        address assetIn;\\r\\n        address assetOut;\\r\\n        if (_isCall) {\\r\\n            balanceOut = _getPoolBalanceOf(_strikeAsset);\\r\\n            assetIn = _underlying;\\r\\n            assetOut = _strikeAsset;\\r\\n        } else {\\r\\n            balanceOut = _getPoolBalanceOf(_underlying);\\r\\n            assetIn = _strikeAsset;\\r\\n            assetOut = _underlying;\\r\\n        }\\r\\n        require(balanceOut \\u003e 0, \\\"ACOPool:: No balance\\\");\\r\\n        \\r\\n        uint256 acceptablePrice = strategy.getAcceptableUnderlyingPriceToSwapAssets(_underlying, _strikeAsset, false);\\r\\n        \\r\\n        uint256 minToReceive;\\r\\n        if (_isCall) {\\r\\n            minToReceive = balanceOut.mul(underlyingPrecision).div(acceptablePrice);\\r\\n        } else {\\r\\n            minToReceive = balanceOut.mul(acceptablePrice).div(underlyingPrecision);\\r\\n        }\\r\\n        uint256 collateralIn = _swapAssetsExactAmountOut(assetOut, assetIn, minToReceive, balanceOut);\\r\\n        \\r\\n        emit RestoreCollateral(balanceOut, collateralIn);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to swap an ACO token with the pool.\\r\\n     * @param isPoolSelling True whether the pool is selling an ACO token, otherwise the pool is buying.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @param restriction Value of the swap restriction. The minimum premium to receive on a selling or the maximum value to pay on a purchase.\\r\\n     * @param to Address of the destination. ACO tokens when is buying or strike asset on a selling.\\r\\n     * @param deadline UNIX deadline for the swap to be executed.\\r\\n     * @return The amount ACO tokens received when is buying or the amount of strike asset received on a selling.\\r\\n     */\\r\\n    function _swap(\\r\\n        bool isPoolSelling, \\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 restriction, \\r\\n        address to, \\r\\n        uint256 deadline\\r\\n    ) internal returns(uint256) {\\r\\n        require(block.timestamp \\u003c= deadline, \\\"ACOPool:: Swap deadline\\\");\\r\\n        require(to != address(0) \\u0026\\u0026 to != acoToken \\u0026\\u0026 to != address(this), \\\"ACOPool:: Invalid destination\\\");\\r\\n        \\r\\n        (uint256 swapPrice, uint256 protocolFee, uint256 underlyingPrice, uint256 collateralAmount) = _internalQuote(isPoolSelling, acoToken, tokenAmount);\\r\\n        \\r\\n        uint256 amount;\\r\\n        if (isPoolSelling) {\\r\\n            amount = _internalSelling(to, acoToken, collateralAmount, tokenAmount, restriction, swapPrice, protocolFee);\\r\\n        } else {\\r\\n            amount = _internalBuying(to, acoToken, tokenAmount, restriction, swapPrice, protocolFee);\\r\\n        }\\r\\n        \\r\\n        if (protocolFee \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(strikeAsset, feeDestination, protocolFee);\\r\\n        }\\r\\n        \\r\\n        emit Swap(isPoolSelling, msg.sender, acoToken, tokenAmount, swapPrice, protocolFee, underlyingPrice);\\r\\n        \\r\\n        return amount;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to quote an ACO token price.\\r\\n     * @param isPoolSelling True whether the pool is selling an ACO token, otherwise the pool is buying.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @return The quote price, the protocol fee charged, the underlying price, and the collateral amount.\\r\\n     */\\r\\n    function _internalQuote(bool isPoolSelling, address acoToken, uint256 tokenAmount) internal view returns(uint256, uint256, uint256, uint256) {\\r\\n        require(isPoolSelling || canBuy, \\\"ACOPool:: The pool only sell\\\");\\r\\n        require(tokenAmount \\u003e 0, \\\"ACOPool:: Invalid token amount\\\");\\r\\n        (uint256 strikePrice, uint256 expiryTime) = _getValidACOTokenStrikePriceAndExpiration(acoToken);\\r\\n        require(expiryTime \\u003e block.timestamp, \\\"ACOPool:: ACO token expired\\\");\\r\\n        \\r\\n        (uint256 collateralAmount, uint256 collateralAvailable) = _getSizeData(isPoolSelling, acoToken, tokenAmount);\\r\\n        (uint256 price, uint256 underlyingPrice,) = _strategyQuote(acoToken, isPoolSelling, strikePrice, expiryTime, collateralAmount, collateralAvailable);\\r\\n        \\r\\n        price = price.mul(tokenAmount).div(underlyingPrecision);\\r\\n        \\r\\n        uint256 protocolFee = 0;\\r\\n        if (fee \\u003e 0) {\\r\\n            protocolFee = price.mul(fee).div(100000);\\r\\n            if (isPoolSelling) {\\r\\n                price = price.add(protocolFee);\\r\\n            } else {\\r\\n                price = price.sub(protocolFee);\\r\\n            }\\r\\n        }\\r\\n        require(price \\u003e 0, \\\"ACOPool:: Invalid quote\\\");\\r\\n        return (price, protocolFee, underlyingPrice, collateralAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the size data for a quote.\\r\\n     * @param isPoolSelling True whether the pool is selling an ACO token, otherwise the pool is buying.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @return The collateral amount and the collateral available on the pool.\\r\\n     */\\r\\n    function _getSizeData(bool isPoolSelling, address acoToken, uint256 tokenAmount) internal view returns(uint256, uint256) {\\r\\n        uint256 collateralAmount;\\r\\n        uint256 collateralAvailable;\\r\\n        if (isCall) {\\r\\n            collateralAvailable = _getPoolBalanceOf(underlying);\\r\\n            collateralAmount = tokenAmount; \\r\\n        } else {\\r\\n            collateralAvailable = _getPoolBalanceOf(strikeAsset);\\r\\n            collateralAmount = IACOToken(acoToken).getCollateralAmount(tokenAmount);\\r\\n            require(collateralAmount \\u003e 0, \\\"ACOPool:: Token amount is too small\\\");\\r\\n        }\\r\\n        require(!isPoolSelling || collateralAmount \\u003c= collateralAvailable, \\\"ACOPool:: Insufficient liquidity\\\");\\r\\n        \\r\\n        return (collateralAmount, collateralAvailable);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to quote on the strategy contract.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param isPoolSelling True whether the pool is selling an ACO token, otherwise the pool is buying.\\r\\n\\t * @param strikePrice ACO token strike price.\\r\\n     * @param expiryTime ACO token expiry time on UNIX.\\r\\n     * @param collateralAmount Amount of collateral for the order size.\\r\\n     * @param collateralAvailable Amount of collateral available on the pool.\\r\\n     * @return The quote price, the underlying price and the volatility.\\r\\n     */\\r\\n    function _strategyQuote(\\r\\n        address acoToken,\\r\\n        bool isPoolSelling,\\r\\n        uint256 strikePrice,\\r\\n        uint256 expiryTime,\\r\\n        uint256 collateralAmount,\\r\\n        uint256 collateralAvailable\\r\\n    ) internal view returns(uint256, uint256, uint256) {\\r\\n        ACOTokenData storage data = acoTokensData[acoToken];\\r\\n        return strategy.quote(IACOStrategy.OptionQuote(\\r\\n            isPoolSelling, \\r\\n            underlying, \\r\\n            strikeAsset, \\r\\n            isCall, \\r\\n            strikePrice, \\r\\n            expiryTime, \\r\\n            baseVolatility, \\r\\n            collateralAmount, \\r\\n            collateralAvailable,\\r\\n            collateralDeposited,\\r\\n            strikeAssetEarnedSelling,\\r\\n            strikeAssetSpentBuying,\\r\\n            data.amountPurchased,\\r\\n            data.amountSold\\r\\n        ));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to sell ACO tokens.\\r\\n     * @param to Address of the destination of the ACO tokens.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param collateralAmount Order collateral amount.\\r\\n     * @param tokenAmount Order token amount.\\r\\n     * @param maxPayment Maximum value to be paid for the ACO tokens.\\r\\n     * @param swapPrice The swap price quoted.\\r\\n     * @param protocolFee The protocol fee amount.\\r\\n     * @return The ACO token amount sold.\\r\\n     */\\r\\n    function _internalSelling(\\r\\n        address to,\\r\\n        address acoToken, \\r\\n        uint256 collateralAmount, \\r\\n        uint256 tokenAmount,\\r\\n        uint256 maxPayment,\\r\\n        uint256 swapPrice,\\r\\n        uint256 protocolFee\\r\\n    ) internal returns(uint256) {\\r\\n        require(swapPrice \\u003c= maxPayment, \\\"ACOPool:: Swap restriction\\\");\\r\\n        \\r\\n        ACOAssetHelper._callTransferFromERC20(strikeAsset, msg.sender, address(this), swapPrice);\\r\\n        \\r\\n        uint256 acoBalance = _getPoolBalanceOf(acoToken);\\r\\n\\r\\n        ACOTokenData storage acoTokenData = acoTokensData[acoToken];\\r\\n        uint256 _amountSold = acoTokenData.amountSold;\\r\\n        if (_amountSold == 0 \\u0026\\u0026 acoTokenData.amountPurchased == 0) {\\r\\n\\t\\t\\tacoTokenData.index = acoTokens.length;\\r\\n            acoTokens.push(acoToken);    \\r\\n        }\\r\\n        if (tokenAmount \\u003e acoBalance) {\\r\\n            tokenAmount = acoBalance;\\r\\n            if (acoBalance \\u003e 0) {\\r\\n                collateralAmount = IACOToken(acoToken).getCollateralAmount(tokenAmount.sub(acoBalance));\\r\\n            }\\r\\n            if (collateralAmount \\u003e 0) {\\r\\n                address _collateral = collateral();\\r\\n                if (ACOAssetHelper._isEther(_collateral)) {\\r\\n                    tokenAmount = tokenAmount.add(IACOToken(acoToken).mintPayable{value: collateralAmount}());\\r\\n                } else {\\r\\n                    if (_amountSold == 0) {\\r\\n                        _setAuthorizedSpender(_collateral, acoToken);    \\r\\n                    }\\r\\n                    tokenAmount = tokenAmount.add(IACOToken(acoToken).mint(collateralAmount));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        acoTokenData.amountSold = tokenAmount.add(_amountSold);\\r\\n        strikeAssetEarnedSelling = swapPrice.sub(protocolFee).add(strikeAssetEarnedSelling); \\r\\n        \\r\\n        ACOAssetHelper._callTransferERC20(acoToken, to, tokenAmount);\\r\\n        \\r\\n        return tokenAmount;\\r\\n    }\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Internal function to buy ACO tokens.\\r\\n     * @param to Address of the destination of the premium.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param tokenAmount Order token amount.\\r\\n     * @param minToReceive Minimum value to be received for the ACO tokens.\\r\\n     * @param swapPrice The swap price quoted.\\r\\n     * @param protocolFee The protocol fee amount.\\r\\n     * @return The premium amount transferred.\\r\\n     */\\r\\n    function _internalBuying(\\r\\n        address to,\\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 minToReceive,\\r\\n        uint256 swapPrice,\\r\\n        uint256 protocolFee\\r\\n    ) internal returns(uint256) {\\r\\n        require(swapPrice \\u003e= minToReceive, \\\"ACOPool:: Swap restriction\\\");\\r\\n        \\r\\n        uint256 requiredStrikeAsset = swapPrice.add(protocolFee);\\r\\n        if (isCall) {\\r\\n            _getStrikeAssetAmount(requiredStrikeAsset);\\r\\n        }\\r\\n        \\r\\n        ACOAssetHelper._callTransferFromERC20(acoToken, msg.sender, address(this), tokenAmount);\\r\\n        \\r\\n        ACOTokenData storage acoTokenData = acoTokensData[acoToken];\\r\\n        uint256 _amountPurchased = acoTokenData.amountPurchased;\\r\\n        if (_amountPurchased == 0 \\u0026\\u0026 acoTokenData.amountSold == 0) {\\r\\n\\t\\t\\tacoTokenData.index = acoTokens.length;\\r\\n            acoTokens.push(acoToken);    \\r\\n        }\\r\\n        acoTokenData.amountPurchased = tokenAmount.add(_amountPurchased);\\r\\n        strikeAssetSpentBuying = requiredStrikeAsset.add(strikeAssetSpentBuying);\\r\\n        \\r\\n        ACOAssetHelper._transferAsset(strikeAsset, to, swapPrice);\\r\\n        \\r\\n        return swapPrice;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the normalized deposit amount.\\r\\n\\t * The pool token has always with 18 decimals.\\r\\n     * @param collateralAmount Amount of collateral to be deposited.\\r\\n     * @return The normalized token amount and the collateral amount.\\r\\n     */\\r\\n    function _getNormalizedDepositAmount(uint256 collateralAmount) internal view returns(uint256, uint256) {\\r\\n        uint256 basePrecision = isCall ? underlyingPrecision : strikeAssetPrecision;\\r\\n        uint256 normalizedAmount;\\r\\n        if (basePrecision \\u003e POOL_PRECISION) {\\r\\n            uint256 adjust = basePrecision.div(POOL_PRECISION);\\r\\n            normalizedAmount = collateralAmount.div(adjust);\\r\\n            collateralAmount = normalizedAmount.mul(adjust);\\r\\n        } else if (basePrecision \\u003c POOL_PRECISION) {\\r\\n            normalizedAmount = collateralAmount.mul(POOL_PRECISION.div(basePrecision));\\r\\n        } else {\\r\\n            normalizedAmount = collateralAmount;\\r\\n        }\\r\\n        require(normalizedAmount \\u003e 0, \\\"ACOPool:: Invalid collateral amount\\\");\\r\\n        return (normalizedAmount, collateralAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get an amount of strike asset for the pool.\\r\\n\\t * The pool swaps the collateral for it if necessary.\\r\\n     * @param strikeAssetAmount Amount of strike asset required.\\r\\n     */\\r\\n    function _getStrikeAssetAmount(uint256 strikeAssetAmount) internal {\\r\\n        address _strikeAsset = strikeAsset;\\r\\n        uint256 balance = _getPoolBalanceOf(_strikeAsset);\\r\\n        if (balance \\u003c strikeAssetAmount) {\\r\\n            uint256 amountToPurchase = strikeAssetAmount.sub(balance);\\r\\n            address _underlying = underlying;\\r\\n            uint256 acceptablePrice = strategy.getAcceptableUnderlyingPriceToSwapAssets(_underlying, _strikeAsset, true);\\r\\n            uint256 maxPayment = amountToPurchase.mul(underlyingPrecision).div(acceptablePrice);\\r\\n            _swapAssetsExactAmountIn(_underlying, _strikeAsset, amountToPurchase, maxPayment);\\r\\n        }\\r\\n    }\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Internal function to redeem the collateral from an ACO token.\\r\\n     * It redeems the collateral only if the ACO token is expired.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param expiryTime ACO token expiry time in UNIX.\\r\\n     */\\r\\n\\tfunction _redeemACOToken(address acoToken, uint256 expiryTime) internal {\\r\\n\\t\\tif (expiryTime \\u003c= block.timestamp) {\\r\\n\\r\\n            uint256 collateralIn = 0;\\r\\n            if (IACOToken(acoToken).currentCollateralizedTokens(address(this)) \\u003e 0) {\\t\\r\\n\\t\\t\\t    collateralIn = IACOToken(acoToken).redeem();\\r\\n            }\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tACOTokenData storage data = acoTokensData[acoToken];\\r\\n\\t\\t\\tuint256 lastIndex = acoTokens.length - 1;\\r\\n\\t\\t\\tif (lastIndex != data.index) {\\r\\n\\t\\t\\t\\taddress last = acoTokens[lastIndex];\\r\\n\\t\\t\\t\\tacoTokensData[last].index = data.index;\\r\\n\\t\\t\\t\\tacoTokens[data.index] = last;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\temit ACORedeem(acoToken, collateralIn, data.amountSold, data.amountPurchased);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tacoTokens.pop();\\r\\n\\t\\t\\tdelete acoTokensData[acoToken];\\r\\n\\t\\t}\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to redeem the collateral and the premium from the pool from an account.\\r\\n     * @param account Address of the account.\\r\\n     * @return The amount of underlying asset received and the amount of strike asset received.\\r\\n     */\\r\\n    function _redeem(address account) internal returns(uint256, uint256) {\\r\\n        uint256 share = balanceOf(account);\\r\\n        require(share \\u003e 0, \\\"ACOPool:: Account with no share\\\");\\r\\n        require(!notFinished(), \\\"ACOPool:: Pool is not finished\\\");\\r\\n        \\r\\n        redeemACOTokens();\\r\\n        \\r\\n        uint256 _totalSupply = totalSupply();\\r\\n        uint256 underlyingBalance = share.mul(_getPoolBalanceOf(underlying)).div(_totalSupply);\\r\\n        uint256 strikeAssetBalance = share.mul(_getPoolBalanceOf(strikeAsset)).div(_totalSupply);\\r\\n        \\r\\n        _callBurn(account, share);\\r\\n        \\r\\n        if (underlyingBalance \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(underlying, msg.sender, underlyingBalance);\\r\\n        }\\r\\n        if (strikeAssetBalance \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(strikeAsset, msg.sender, strikeAssetBalance);\\r\\n        }\\r\\n        \\r\\n        emit Redeem(msg.sender, underlyingBalance, strikeAssetBalance);\\r\\n        \\r\\n        return (underlyingBalance, strikeAssetBalance);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to burn pool tokens.\\r\\n     * @param account Address of the account.\\r\\n     * @param tokenAmount Amount of pool tokens to be burned.\\r\\n     */\\r\\n    function _callBurn(address account, uint256 tokenAmount) internal {\\r\\n        if (account == msg.sender) {\\r\\n            super._burnAction(account, tokenAmount);\\r\\n        } else {\\r\\n            super._burnFrom(account, tokenAmount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to swap assets on the asset converter helper with an exact amount of an asset to be sold.\\r\\n     * @param assetOut Address of the asset to be sold.\\r\\n\\t * @param assetIn Address of the asset to be purchased.\\r\\n     * @param minAmountIn Minimum amount to be received.\\r\\n     * @param amountOut The exact amount to be sold.\\r\\n\\t * @return The amount of asset purchased.\\r\\n     */\\r\\n    function _swapAssetsExactAmountOut(address assetOut, address assetIn, uint256 minAmountIn, uint256 amountOut) internal returns(uint256) {\\r\\n\\t\\tuint256 etherAmount = 0;\\r\\n        if (ACOAssetHelper._isEther(assetOut)) {\\r\\n\\t\\t\\tetherAmount = amountOut;\\r\\n        }\\r\\n        return assetConverterHelper.swapExactAmountOutWithMinAmountToReceive{value: etherAmount}(assetOut, assetIn, amountOut, minAmountIn);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to swap assets on the asset converter helper with an exact amount of an asset to be purchased.\\r\\n     * @param assetOut Address of the asset to be sold.\\r\\n\\t * @param assetIn Address of the asset to be purchased.\\r\\n     * @param amountIn The exact amount to be purchased.\\r\\n     * @param maxAmountOut Maximum amount to be paid.\\r\\n\\t * @return The amount of asset sold.\\r\\n     */\\r\\n    function _swapAssetsExactAmountIn(address assetOut, address assetIn, uint256 amountIn, uint256 maxAmountOut) internal returns(uint256) {\\r\\n\\t\\tuint256 etherAmount = 0;\\r\\n        if (ACOAssetHelper._isEther(assetOut)) {\\r\\n\\t\\t\\tetherAmount = maxAmountOut;\\r\\n        }\\r\\n        return assetConverterHelper.swapExactAmountInWithMaxAmountToSold{value: etherAmount}(assetOut, assetIn, amountIn, maxAmountOut);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the strategy address.\\r\\n     * @param newStrategy Address of the new strategy.\\r\\n     */\\r\\n    function _setStrategy(address newStrategy) internal {\\r\\n        require(newStrategy.isContract(), \\\"ACOPool:: Invalid strategy\\\");\\r\\n        emit SetStrategy(address(strategy), newStrategy);\\r\\n        strategy = IACOStrategy(newStrategy);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the base volatility percentage. (100000 = 100%)\\r\\n     * @param newBaseVolatility Value of the new base volatility.\\r\\n     */\\r\\n    function _setBaseVolatility(uint256 newBaseVolatility) internal {\\r\\n        require(newBaseVolatility \\u003e 0, \\\"ACOPool:: Invalid base volatility\\\");\\r\\n        emit SetBaseVolatility(baseVolatility, newBaseVolatility);\\r\\n        baseVolatility = newBaseVolatility;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to set the pool assets precisions.\\r\\n     * @param _underlying Address of the underlying asset.\\r\\n     * @param _strikeAsset Address of the strike asset.\\r\\n     */\\r\\n    function _setAssetsPrecision(address _underlying, address _strikeAsset) internal {\\r\\n        underlyingPrecision = 10 ** uint256(ACOAssetHelper._getAssetDecimals(_underlying));\\r\\n        strikeAssetPrecision = 10 ** uint256(ACOAssetHelper._getAssetDecimals(_strikeAsset));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to infinite authorize the pool assets on the asset converter helper.\\r\\n     * @param _isCall True whether it is a CALL option, otherwise it is PUT.\\r\\n     * @param _canBuy True whether the pool can also buy ACO tokens, otherwise it only sells.\\r\\n     * @param _assetConverterHelper Address of the asset converter helper.\\r\\n     * @param _underlying Address of the underlying asset.\\r\\n     * @param _strikeAsset Address of the strike asset.\\r\\n     */\\r\\n    function _approveAssetsOnConverterHelper(\\r\\n        bool _isCall, \\r\\n        bool _canBuy, \\r\\n        address _assetConverterHelper,\\r\\n        address _underlying,\\r\\n        address _strikeAsset\\r\\n    ) internal {\\r\\n        if (_isCall) {\\r\\n            if (!ACOAssetHelper._isEther(_strikeAsset)) {\\r\\n                _setAuthorizedSpender(_strikeAsset, _assetConverterHelper);\\r\\n            }\\r\\n            if (_canBuy \\u0026\\u0026 !ACOAssetHelper._isEther(_underlying)) {\\r\\n                _setAuthorizedSpender(_underlying, _assetConverterHelper);\\r\\n            }\\r\\n        } else if (!ACOAssetHelper._isEther(_underlying)) {\\r\\n            _setAuthorizedSpender(_underlying, _assetConverterHelper);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to infinite authorize a spender on an asset.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param spender Address of the spender to be authorized.\\r\\n     */\\r\\n    function _setAuthorizedSpender(address asset, address spender) internal {\\r\\n        ACOAssetHelper._callApproveERC20(asset, spender, MAX_UINT);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the pool balance of an asset.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The pool balance.\\r\\n     */\\r\\n    function _getPoolBalanceOf(address asset) internal view returns(uint256) {\\r\\n        return ACOAssetHelper._getAssetBalanceOf(asset, address(this));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the exercible amount of an ACO token.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @return The exercisable amount.\\r\\n     */\\r\\n    function _getExercisableAmount(address acoToken) internal view returns(uint256) {\\r\\n        uint256 balance = _getPoolBalanceOf(acoToken);\\r\\n        if (balance \\u003e 0) {\\r\\n            uint256 collaterized = IACOToken(acoToken).currentCollateralizedTokens(address(this));\\r\\n            if (balance \\u003e collaterized) {\\r\\n                return balance.sub(collaterized);\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get an accepted ACO token by the pool.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @return The ACO token strike price, and the ACO token expiration.\\r\\n     */\\r\\n    function _getValidACOTokenStrikePriceAndExpiration(address acoToken) internal view returns(uint256, uint256) {\\r\\n        (address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime) = acoFactory.acoTokenData(acoToken);\\r\\n        require(\\r\\n            _underlying == underlying \\u0026\\u0026 \\r\\n            _strikeAsset == strikeAsset \\u0026\\u0026 \\r\\n            _isCall == isCall \\u0026\\u0026 \\r\\n            _strikePrice \\u003e= minStrikePrice \\u0026\\u0026\\r\\n            _strikePrice \\u003c= maxStrikePrice \\u0026\\u0026\\r\\n            _expiryTime \\u003e= minExpiration \\u0026\\u0026\\r\\n            _expiryTime \\u003c= maxExpiration,\\r\\n            \\\"ACOPool:: Invalid ACO Token\\\"\\r\\n        );\\r\\n        return (_strikePrice, _expiryTime);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the token name.\\r\\n     * The token name is assembled  with the token data:\\r\\n     * ACO POOL UNDERLYING_SYMBOL-STRIKE_ASSET_SYMBOL-TYPE-{ONLY_SELL}-MIN_STRIKE_PRICE-MAX_STRIKE_PRICE-MIN_EXPIRATION-MAX_EXPIRATION\\r\\n     * @return The token name.\\r\\n     */\\r\\n    function _name() internal view returns(string memory) {\\r\\n        uint8 strikeDecimals = ACOAssetHelper._getAssetDecimals(strikeAsset);\\r\\n        string memory strikePriceFormatted;\\r\\n        if (minStrikePrice != maxStrikePrice) {\\r\\n            strikePriceFormatted = string(abi.encodePacked(ACONameFormatter.formatNumber(minStrikePrice, strikeDecimals), \\\"-\\\", ACONameFormatter.formatNumber(maxStrikePrice, strikeDecimals)));\\r\\n        } else {\\r\\n            strikePriceFormatted = ACONameFormatter.formatNumber(minStrikePrice, strikeDecimals);\\r\\n        }\\r\\n        string memory dateFormatted;\\r\\n        if (minExpiration != maxExpiration) {\\r\\n            dateFormatted = string(abi.encodePacked(ACONameFormatter.formatTime(minExpiration), \\\"-\\\", ACONameFormatter.formatTime(maxExpiration)));\\r\\n        } else {\\r\\n            dateFormatted = ACONameFormatter.formatTime(minExpiration);\\r\\n        }\\r\\n        return string(abi.encodePacked(\\r\\n            \\\"ACO POOL \\\",\\r\\n            ACOAssetHelper._getAssetSymbol(underlying),\\r\\n            \\\"-\\\",\\r\\n            ACOAssetHelper._getAssetSymbol(strikeAsset),\\r\\n            \\\"-\\\",\\r\\n            ACONameFormatter.formatType(isCall),\\r\\n            (canBuy ? \\\"\\\" : \\\"-SELL\\\"),\\r\\n            \\\"-\\\",\\r\\n            strikePriceFormatted,\\r\\n            \\\"-\\\",\\r\\n            dateFormatted\\r\\n        ));\\r\\n    }\\r\\n}\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"BokkyPooBahsDateTimeLibrary.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// BokkyPooBah\\u0027s DateTime Library v1.01\\r\\n//\\r\\n// A gas-efficient Solidity date and time library\\r\\n//\\r\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\r\\n//\\r\\n// Tested date range 1970/01/01 to 2345/12/31\\r\\n//\\r\\n// Conventions:\\r\\n// Unit      | Range         | Notes\\r\\n// :-------- |:-------------:|:-----\\r\\n// timestamp | \\u003e= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\r\\n// year      | 1970 ... 2345 |\\r\\n// month     | 1 ... 12      |\\r\\n// day       | 1 ... 31      |\\r\\n// hour      | 0 ... 23      |\\r\\n// minute    | 0 ... 59      |\\r\\n// second    | 0 ... 59      |\\r\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\r\\n//\\r\\n//\\r\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------\\r\\n\\r\\nlibrary BokkyPooBahsDateTimeLibrary {\\r\\n\\r\\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n    uint constant SECONDS_PER_HOUR = 60 * 60;\\r\\n    uint constant SECONDS_PER_MINUTE = 60;\\r\\n    int constant OFFSET19700101 = 2440588;\\r\\n\\r\\n    uint constant DOW_MON = 1;\\r\\n    uint constant DOW_TUE = 2;\\r\\n    uint constant DOW_WED = 3;\\r\\n    uint constant DOW_THU = 4;\\r\\n    uint constant DOW_FRI = 5;\\r\\n    uint constant DOW_SAT = 6;\\r\\n    uint constant DOW_SUN = 7;\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // days = day\\r\\n    //      - 32075\\r\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\r\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\r\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\r\\n    //      - offset\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\\r\\n        require(year \\u003e= 1970);\\r\\n        int _year = int(year);\\r\\n        int _month = int(month);\\r\\n        int _day = int(day);\\r\\n\\r\\n        int __days = _day\\r\\n          - 32075\\r\\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\\r\\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\\r\\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\\r\\n          - OFFSET19700101;\\r\\n\\r\\n        _days = uint(__days);\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // int L = days + 68569 + offset\\r\\n    // int N = 4 * L / 146097\\r\\n    // L = L - (146097 * N + 3) / 4\\r\\n    // year = 4000 * (L + 1) / 1461001\\r\\n    // L = L - 1461 * year / 4 + 31\\r\\n    // month = 80 * L / 2447\\r\\n    // dd = L - 2447 * month / 80\\r\\n    // L = month / 11\\r\\n    // month = month + 2 - 12 * L\\r\\n    // year = 100 * (N - 49) + year + L\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\\r\\n        int __days = int(_days);\\r\\n\\r\\n        int L = __days + 68569 + OFFSET19700101;\\r\\n        int N = 4 * L / 146097;\\r\\n        L = L - (146097 * N + 3) / 4;\\r\\n        int _year = 4000 * (L + 1) / 1461001;\\r\\n        L = L - 1461 * _year / 4 + 31;\\r\\n        int _month = 80 * L / 2447;\\r\\n        int _day = L - 2447 * _month / 80;\\r\\n        L = _month / 11;\\r\\n        _month = _month + 2 - 12 * L;\\r\\n        _year = 100 * (N - 49) + _year + L;\\r\\n\\r\\n        year = uint(_year);\\r\\n        month = uint(_month);\\r\\n        day = uint(_day);\\r\\n    }\\r\\n\\r\\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\\r\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\r\\n    }\\r\\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\\r\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\\r\\n    }\\r\\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\\r\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\\r\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        uint secs = timestamp % SECONDS_PER_DAY;\\r\\n        hour = secs / SECONDS_PER_HOUR;\\r\\n        secs = secs % SECONDS_PER_HOUR;\\r\\n        minute = secs / SECONDS_PER_MINUTE;\\r\\n        second = secs % SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\\r\\n        if (year \\u003e= 1970 \\u0026\\u0026 month \\u003e 0 \\u0026\\u0026 month \\u003c= 12) {\\r\\n            uint daysInMonth = _getDaysInMonth(year, month);\\r\\n            if (day \\u003e 0 \\u0026\\u0026 day \\u003c= daysInMonth) {\\r\\n                valid = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\\r\\n        if (isValidDate(year, month, day)) {\\r\\n            if (hour \\u003c 24 \\u0026\\u0026 minute \\u003c 60 \\u0026\\u0026 second \\u003c 60) {\\r\\n                valid = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\\r\\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        leapYear = _isLeapYear(year);\\r\\n    }\\r\\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\\r\\n        leapYear = ((year % 4 == 0) \\u0026\\u0026 (year % 100 != 0)) || (year % 400 == 0);\\r\\n    }\\r\\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\\r\\n        weekDay = getDayOfWeek(timestamp) \\u003c= DOW_FRI;\\r\\n    }\\r\\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\\r\\n        weekEnd = getDayOfWeek(timestamp) \\u003e= DOW_SAT;\\r\\n    }\\r\\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\\r\\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        daysInMonth = _getDaysInMonth(year, month);\\r\\n    }\\r\\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\\r\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\r\\n            daysInMonth = 31;\\r\\n        } else if (month != 2) {\\r\\n            daysInMonth = 30;\\r\\n        } else {\\r\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\r\\n        }\\r\\n    }\\r\\n    // 1 = Monday, 7 = Sunday\\r\\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\\r\\n        uint _days = timestamp / SECONDS_PER_DAY;\\r\\n        dayOfWeek = (_days + 3) % 7 + 1;\\r\\n    }\\r\\n\\r\\n    function getYear(uint timestamp) internal pure returns (uint year) {\\r\\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getMonth(uint timestamp) internal pure returns (uint month) {\\r\\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getDay(uint timestamp) internal pure returns (uint day) {\\r\\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getHour(uint timestamp) internal pure returns (uint hour) {\\r\\n        uint secs = timestamp % SECONDS_PER_DAY;\\r\\n        hour = secs / SECONDS_PER_HOUR;\\r\\n    }\\r\\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\\r\\n        uint secs = timestamp % SECONDS_PER_HOUR;\\r\\n        minute = secs / SECONDS_PER_MINUTE;\\r\\n    }\\r\\n    function getSecond(uint timestamp) internal pure returns (uint second) {\\r\\n        second = timestamp % SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        year += _years;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        month += _months;\\r\\n        year += (month - 1) / 12;\\r\\n        month = (month - 1) % 12 + 1;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _seconds;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n\\r\\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        year -= _years;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        uint yearMonth = year * 12 + (month - 1) - _months;\\r\\n        year = yearMonth / 12;\\r\\n        month = yearMonth % 12 + 1;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _seconds;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n\\r\\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\r\\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\r\\n        _years = toYear - fromYear;\\r\\n    }\\r\\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\r\\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\r\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\r\\n    }\\r\\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\r\\n    }\\r\\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\r\\n    }\\r\\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\r\\n    }\\r\\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _seconds = toTimestamp - fromTimestamp;\\r\\n    }\\r\\n}\\r\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC20\\r\\n * @dev Base implementation of ERC20 token.\\r\\n */\\r\\nabstract contract ERC20 is IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    uint256 private _totalSupply;\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    function name() public view virtual returns(string memory);\\r\\n    function symbol() public view virtual returns(string memory);\\r\\n    function decimals() public view virtual returns(uint8);\\r\\n\\r\\n    function totalSupply() public view override returns(uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns(uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view override returns(uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public override returns(bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns(bool) {\\r\\n        _approveAction(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\r\\n        _transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns(bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 amount) public returns(bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(amount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 amount) public returns(bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(amount));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        _transferAction(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        _approveAction(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    function _burnFrom(address account, uint256 amount) internal {\\r\\n        _approveAction(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\r\\n        _burnAction(account, amount);\\r\\n    }\\r\\n\\r\\n    function _transferAction(address sender, address recipient, uint256 amount) internal {\\r\\n        require(sender != address(0), \\\"ERC20::_transferAction: Invalid sender\\\");\\r\\n        require(recipient != address(0), \\\"ERC20::_transferAction: Invalid recipient\\\");\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount);\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        \\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n    \\r\\n    function _approveAction(address owner, address spender, uint256 amount) internal {\\r\\n        require(owner != address(0), \\\"ERC20::_approveAction: Invalid owner\\\");\\r\\n        require(spender != address(0), \\\"ERC20::_approveAction: Invalid spender\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        \\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    function _mintAction(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20::_mintAction: Invalid account\\\");\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        \\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _burnAction(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20::_burnAction: Invalid account\\\");\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount);\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        \\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n}    \\r\\n\"},\"IACOAssetConverterHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOAssetConverterHelper {\\r\\n    function setPairTolerancePercentage(address baseAsset, address quoteAsset, uint256 tolerancePercentage) external;\\r\\n    function setAggregator(address baseAsset, address quoteAsset, address aggregator) external;\\r\\n    function setUniswapMiddleRoute(address baseAsset, address quoteAsset, address[] calldata uniswapMiddleRoute) external;\\r\\n    function withdrawStuckAsset(address asset, address destination) external;\\r\\n    function hasAggregator(address baseAsset, address quoteAsset) external view returns(bool);\\r\\n    function getPairData(address baseAsset, address quoteAsset) external view returns(address, uint256, uint256, uint256);\\r\\n    function getUniswapMiddleRouteByIndex(address baseAsset, address quoteAsset, uint256 index) external view returns(address);\\r\\n    function getPrice(address baseAsset, address quoteAsset) external view returns(uint256);\\r\\n    function getPriceWithTolerance(address baseAsset, address quoteAsset, bool isMinimumPrice) external view returns(uint256);\\r\\n    function getExpectedAmountOutToSwapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external view returns(uint256);\\r\\n    function getExpectedAmountOutToSwapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external view returns(uint256);\\r\\n    function swapExactAmountOut(address assetToSold, address assetToBuy, uint256 amountToSold) external payable returns(uint256);\\r\\n    function swapExactAmountOutWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 tolerancePercentage) external payable returns(uint256);\\r\\n    function swapExactAmountOutWithMinAmountToReceive(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 minAmountToReceive) external payable returns(uint256);\\r\\n    function swapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external payable returns(uint256);\\r\\n    function swapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external payable returns(uint256);\\r\\n    function swapExactAmountInWithMaxAmountToSold(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 maxAmountToSold) external payable returns(uint256);\\r\\n}\"},\"IACOFactory.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOFactory {\\r\\n\\tfunction init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) external;\\r\\n    function acoFee() external view returns(uint256);\\r\\n    function factoryAdmin() external view returns(address);\\r\\n    function acoTokenImplementation() external view returns(address);\\r\\n    function acoFeeDestination() external view returns(address);\\r\\n    function acoTokenData(address acoToken) external view returns(address, address, bool, uint256, uint256);\\r\\n    function createAcoToken(address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime, uint256 maxExercisedAccounts) external returns(address);\\r\\n    function setFactoryAdmin(address newFactoryAdmin) external;\\r\\n    function setAcoTokenImplementation(address newAcoTokenImplementation) external;\\r\\n    function setAcoFee(uint256 newAcoFee) external;\\r\\n    function setAcoFeeDestination(address newAcoFeeDestination) external;\\r\\n}\"},\"IACOFlashExercise.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOFlashExercise {\\r\\n    function uniswapFactory() external view returns(address);\\r\\n    function uniswapRouter() external view returns(address);\\r\\n    function weth() external view returns(address);\\r\\n    function hasFlashExercise(address acoToken) external view returns(bool);\\r\\n    function getExerciseData(address acoToken, uint256 tokenAmount, address[] calldata accounts) external view returns(uint256, uint256);\\r\\n    function getEstimatedReturn(address acoToken, uint256 tokenAmount) external view returns(uint256);\\r\\n    function flashExercise(address acoToken, uint256 tokenAmount, uint256 minimumCollateral, uint256 salt) external;\\r\\n    function flashExerciseAccounts(address acoToken, uint256 tokenAmount, uint256 minimumCollateral, address[] calldata accounts) external;\\r\\n    function uniswapV2Call(address sender, uint256 amount0Out, uint256 amount1Out, bytes calldata data) external;\\r\\n}\\r\\n\"},\"IACOPool.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\ninterface IACOPool is IERC20 {\\r\\n    struct InitData {\\r\\n        uint256 poolStart;\\r\\n        address acoFlashExercise;\\r\\n        address acoFactory;\\r\\n        address chiToken;\\r\\n\\t\\taddress assetConverterHelper;\\r\\n        uint256 fee;\\r\\n        address feeDestination;\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        uint256 minStrikePrice; \\r\\n        uint256 maxStrikePrice;\\r\\n        uint256 minExpiration;\\r\\n        uint256 maxExpiration;\\r\\n        bool isCall; \\r\\n        bool canBuy;\\r\\n        address strategy;\\r\\n        uint256 baseVolatility;    \\r\\n    }\\r\\n    \\r\\n\\tfunction init(InitData calldata initData) external;\\r\\n    function numberOfACOTokensCurrentlyNegotiated() external view returns(uint256);\\r\\n    function collateral() external view returns(address);\\r\\n    function setStrategy(address strategy) external;\\r\\n    function setBaseVolatility(uint256 baseVolatility) external;\\r\\n    function quote(bool isBuying, address acoToken, uint256 tokenAmount) external view returns(uint256 swapPrice, uint256 fee, uint256 underlyingPrice);\\r\\n    function swap(bool isBuying, address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external returns(uint256);\\r\\n    function swapWithGasToken(bool isBuying, address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external returns(uint256);\\r\\n    function exerciseACOToken(address acoToken) external;\\r\\n    function redeemACOTokens() external;\\r\\n\\tfunction redeemACOToken(address acoToken) external;\\r\\n    function deposit(uint256 collateralAmount, address to) external payable returns(uint256 acoPoolTokenAmount);\\r\\n    function redeem() external returns(uint256 underlyingReceived, uint256 strikeAssetReceived);\\r\\n    function redeemFrom(address account) external returns(uint256 underlyingReceived, uint256 strikeAssetReceived);\\r\\n    function restoreCollateral() external;\\r\\n}\"},\"IACOStrategy.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IACOStrategy {\\r\\n    \\r\\n    struct OptionQuote {\\r\\n        bool isSellingQuote;\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCallOption;\\r\\n        uint256 strikePrice; \\r\\n        uint256 expiryTime;\\r\\n        uint256 baseVolatility;\\r\\n        uint256 collateralOrderAmount;\\r\\n        uint256 collateralAvailable;\\r\\n        uint256 collateralTotalDeposited;\\r\\n        uint256 strikeAssetEarnedSelling;\\r\\n        uint256 strikeAssetSpentBuying;\\r\\n        uint256 amountPurchased;\\r\\n        uint256 amountSold;\\r\\n    }\\r\\n    \\r\\n    struct CheckExercise {\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCallOption;\\r\\n        uint256 strikePrice; \\r\\n        uint256 expiryTime;\\r\\n        uint256 collateralAmount;\\r\\n        uint256 collateralAvailable;\\r\\n        uint256 amountPurchased;\\r\\n        uint256 amountSold;\\r\\n    }\\r\\n    \\r\\n    function quote(OptionQuote calldata quoteData) external view returns(uint256 optionPrice, uint256 underlyingPrice, uint256 volatility);\\r\\n    function getUnderlyingPrice(address underlying, address strikeAsset) external view returns(uint256 underlyingPrice);\\r\\n    function getAcceptableUnderlyingPriceToSwapAssets(address underlying, address strikeAsset, bool isBuying) external view returns(uint256 acceptablePrice);\\r\\n    function checkExercise(CheckExercise calldata exerciseData) external view returns(bool canExercise, uint256 minIntrinsicValue);\\r\\n}\"},\"IACOToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IACOToken is IERC20 {\\r\\n\\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function underlying() external view returns (address);\\r\\n    function strikeAsset() external view returns (address);\\r\\n    function feeDestination() external view returns (address);\\r\\n    function isCall() external view returns (bool);\\r\\n    function strikePrice() external view returns (uint256);\\r\\n    function expiryTime() external view returns (uint256);\\r\\n    function totalCollateral() external view returns (uint256);\\r\\n    function acoFee() external view returns (uint256);\\r\\n\\tfunction maxExercisedAccounts() external view returns (uint256);\\r\\n    function underlyingSymbol() external view returns (string memory);\\r\\n    function strikeAssetSymbol() external view returns (string memory);\\r\\n    function underlyingDecimals() external view returns (uint8);\\r\\n    function strikeAssetDecimals() external view returns (uint8);\\r\\n    function currentCollateral(address account) external view returns(uint256);\\r\\n    function unassignableCollateral(address account) external view returns(uint256);\\r\\n    function assignableCollateral(address account) external view returns(uint256);\\r\\n    function currentCollateralizedTokens(address account) external view returns(uint256);\\r\\n    function unassignableTokens(address account) external view returns(uint256);\\r\\n    function assignableTokens(address account) external view returns(uint256);\\r\\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\\r\\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\\r\\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\\r\\n    function numberOfAccountsWithCollateral() external view returns(uint256);\\r\\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\\r\\n    function collateral() external view returns(address);\\r\\n    function mintPayable() external payable returns(uint256);\\r\\n    function mintToPayable(address account) external payable returns(uint256);\\r\\n    function mint(uint256 collateralAmount) external returns(uint256);\\r\\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\\r\\n    function burn(uint256 tokenAmount) external returns(uint256);\\r\\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\\r\\n    function redeem() external returns(uint256);\\r\\n    function redeemFrom(address account) external returns(uint256);\\r\\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n}\"},\"IChiToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\ninterface IChiToken is IERC20 {\\r\\n    function mint(uint256 value) external;\\r\\n    function computeAddress2(uint256 salt) external view returns(address);\\r\\n    function free(uint256 value) external returns(uint256);\\r\\n    function freeUpTo(uint256 value) external returns(uint256);\\r\\n    function freeFrom(address from, uint256 value) external returns(uint256);\\r\\n    function freeFromUpTo(address from, uint256 value) external returns(uint256);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Adapted from OpenZeppelin\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    function init() internal {\\r\\n        require(_owner == address(0), \\\"Ownable: Contract initialized\\\");\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"Strings.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        uint256 index = digits - 1;\\r\\n        temp = value;\\r\\n        while (temp != 0) {\\r\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\r\\n            temp /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralIn\",\"type\":\"uint256\"}],\"name\":\"ACOExercise\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPurchased\",\"type\":\"uint256\"}],\"name\":\"ACORedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CollateralDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strikeAssetAmount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralIn\",\"type\":\"uint256\"}],\"name\":\"RestoreCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldBaseVolatility\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newBaseVolatility\",\"type\":\"uint256\"}],\"name\":\"SetBaseVolatility\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldStrategy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"SetStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isPoolSelling\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingPrice\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acoFactory\",\"outputs\":[{\"internalType\":\"contract IACOFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acoFlashExercise\",\"outputs\":[{\"internalType\":\"contract IACOFlashExercise\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"acoTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"acoTokensData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPurchased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetConverterHelper\",\"outputs\":[{\"internalType\":\"contract IACOAssetConverterHelper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseVolatility\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chiToken\",\"outputs\":[{\"internalType\":\"contract IChiToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"}],\"name\":\"exerciseACOToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolStart\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"acoFlashExercise\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"acoFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"chiToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetConverterHelper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeDestination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStrikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStrikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxExpiration\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canBuy\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseVolatility\",\"type\":\"uint256\"}],\"internalType\":\"struct IACOPool.InitData\",\"name\":\"initData\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxExpiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStrikePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minExpiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStrikePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfACOTokensCurrentlyNegotiated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBuying\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"}],\"name\":\"redeemACOToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemACOTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"redeemFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restoreCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBaseVolatility\",\"type\":\"uint256\"}],\"name\":\"setBaseVolatility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"setStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"contract IACOStrategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strikeAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strikeAssetEarnedSelling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strikeAssetSpentBuying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBuying\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restriction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBuying\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restriction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapWithGasToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOPool","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8326d762c1cc8a54ca42ddec59494a396770cb72e50baab65274c8712cf506c0"}]}