{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.8;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/library/WadRayMath.sol\r\n\r\n\r\n/******************\r\n@title WadRayMath library\r\n@notice borrowed from Aave V1 open source code https://raw.githubusercontent.com/aave/aave-protocol/master/contracts/libraries/WadRayMath.sol\r\n@author Aave\r\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\r\n */\r\n\r\nlibrary WadRayMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant WAD = 1e18;\r\n    uint256 internal constant halfWAD = WAD / 2;\r\n\r\n    uint256 internal constant RAY = 1e27;\r\n    uint256 internal constant halfRAY = RAY / 2;\r\n\r\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n    function ray() internal pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n    function wad() internal pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    function halfRay() internal pure returns (uint256) {\r\n        return halfRAY;\r\n    }\r\n\r\n    function halfWad() internal pure returns (uint256) {\r\n        return halfWAD;\r\n    }\r\n\r\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return halfWAD.add(a.mul(b)).div(WAD);\r\n    }\r\n\r\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 halfB = b / 2;\r\n\r\n        return halfB.add(a.mul(WAD)).div(b);\r\n    }\r\n\r\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return halfRAY.add(a.mul(b)).div(RAY);\r\n    }\r\n\r\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 halfB = b / 2;\r\n\r\n        return halfB.add(a.mul(RAY)).div(b);\r\n    }\r\n\r\n    function rayToWad(uint256 a) internal pure returns (uint256) {\r\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\r\n\r\n        return halfRatio.add(a).div(WAD_RAY_RATIO);\r\n    }\r\n\r\n    function wadToRay(uint256 a) internal pure returns (uint256) {\r\n        return a.mul(WAD_RAY_RATIO);\r\n    }\r\n\r\n    /**\r\n    * @dev calculates base^exp. The code uses the ModExp precompile\r\n    * @return z base^exp, in ray\r\n    */\r\n    //solium-disable-next-line\r\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rayMul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rayMul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/GSN/Context.sol\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/access/Roles.sol\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @notice copied from openzeppelin-solidity\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/access/WhitelistAdminRole.sol\r\n\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @notice copied from openzeppelin-solidity\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(_msgSender()), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/access/WhitelistedRole.sol\r\n\r\n\r\n/**\r\n * @title WhitelistedRole\r\n * @notice copied from openzeppelin-solidity\r\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\r\n * it), and not Whitelisteds themselves.\r\n */\r\ncontract WhitelistedRole is Context, WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(_msgSender()), \"WhitelistedRole: caller does not have the Whitelisted role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(_msgSender());\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/oracle/ILinearDividendOracle.sol\r\n\r\n\r\n/**\r\n * @title ILinearDividendOracle\r\n * @notice provides dividend information and calculation strategies for linear dividends.\r\n*/\r\ninterface ILinearDividendOracle {\r\n\r\n    /**\r\n     * @notice calculate the total dividend accrued since last dividend checkpoint to now\r\n     * @param tokenAmount           amount of token being held\r\n     * @param timestamp             timestamp to start calculating dividend accrued\r\n     * @param fromIndex             index in the dividend history that the timestamp falls into\r\n     * @return amount of dividend accrued in 1e18, and the latest dividend index\r\n     */\r\n    function calculateAccruedDividends(\r\n        uint256 tokenAmount,\r\n        uint256 timestamp,\r\n        uint256 fromIndex\r\n    ) external view returns (uint256, uint256);\r\n\r\n    /**\r\n     * @notice calculate the total dividend accrued since last dividend checkpoint to (inclusive) a given dividend index\r\n     * @param tokenAmount           amount of token being held\r\n     * @param timestamp             timestamp to start calculating dividend accrued\r\n     * @param fromIndex             index in the dividend history that the timestamp falls into\r\n     * @param toIndex               index in the dividend history to stop the calculation at, inclusive\r\n     * @return amount of dividend accrued in 1e18, dividend index and timestamp to use for remaining dividends\r\n     */\r\n    function calculateAccruedDividendsBounded(\r\n        uint256 tokenAmount,\r\n        uint256 timestamp,\r\n        uint256 fromIndex,\r\n        uint256 toIndex\r\n    ) external view returns (uint256, uint256, uint256);\r\n\r\n    /**\r\n     * @notice get the current dividend index\r\n     * @return the latest dividend index\r\n     */\r\n    function getCurrentIndex() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice return the current dividend accrual rate, in USD per second\r\n     * @return dividend in USD per second\r\n     */\r\n    function getCurrentValue() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice return the dividend accrual rate, in USD per second, of a given dividend index\r\n     * @return dividend in USD per second of the corresponding dividend phase.\r\n     */\r\n    function getHistoricalValue(uint256 dividendIndex) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/oracle/ManagedLinearDividendOracle.sol\r\n\r\n\r\n/**\r\n * @title ManagedLinearDividendOracle\r\n * @notice Provides managed linear dividend rate queries, and calculations\r\n*/\r\ncontract ManagedLinearDividendOracle is ILinearDividendOracle, WhitelistedRole {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n\r\n    event DividendUpdated(uint256 value, uint256 timestamp);\r\n\r\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\r\n\r\n    struct CalcReturnInfo {\r\n        uint256 dividendInWad;\r\n        uint256 index;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    /**\r\n    * @dev records one phase of a given dividend rate\r\n    **/\r\n    struct DividendPhase {\r\n        // amount of usd accrued per second per token in 1e27\r\n        uint256 USDPerSecondInRay;\r\n\r\n        // timestamp for start of this dividend phase\r\n        uint256 start;\r\n\r\n        // timestamp for end of this dividend phase\r\n        uint256 end;\r\n    }\r\n\r\n    DividendPhase[] internal _dividendPhases;\r\n\r\n\r\n    constructor(uint256 USDPerAnnumInWad) public {\r\n        _addWhitelisted(msg.sender);\r\n\r\n        newDividendPhase(USDPerAnnumInWad);\r\n    }\r\n\r\n    /**\r\n     * @notice calculate the total dividend accrued since last dividend checkpoint to now\r\n     * @dev this contains a unbounded loop, use calculateAccruedDividendBounded for determimistic gas cost\r\n     * @param tokenAmount           amount of token being held\r\n     * @param timestamp             timestamp to start calculating dividend accrued\r\n     * @param fromIndex             index in the dividend history that the timestamp falls into\r\n     * @return amount of dividend accrued in 1e18, and the latest dividend index\r\n     */\r\n    function calculateAccruedDividends(\r\n        uint256 tokenAmount,\r\n        uint256 timestamp,\r\n        uint256 fromIndex\r\n    ) external view virtual override returns (uint256, uint256) {\r\n        (uint256 totalDividendInWad, uint256 resultIndex,) = calculateAccruedDividendsBounded(\r\n            tokenAmount,\r\n            timestamp,\r\n            fromIndex,\r\n            _dividendPhases.length.sub(1)\r\n        );\r\n\r\n        return (totalDividendInWad, resultIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice calculate the total dividend accrued since last dividend checkpoint to a given dividend index\r\n     * @param tokenAmount           amount of token being held\r\n     * @param timestamp             timestamp to start calculating dividend accrued\r\n     * @param fromIndex             index in the dividend history that the timestamp falls into\r\n     * @param toIndex               index in the dividend history to stop the calculation at\r\n     * @return amount of dividend accrued in 1e18, dividend index and timestamp to use for remaining dividends\r\n     */\r\n    function calculateAccruedDividendsBounded(\r\n        uint256 tokenAmount,\r\n        uint256 timestamp,\r\n        uint256 fromIndex,\r\n        uint256 toIndex\r\n    ) public view virtual override returns (uint256, uint256, uint256){\r\n        require(toIndex < _dividendPhases.length, \"toIndex out of bounds\");\r\n        require(fromIndex <= toIndex, \"fromIndex must be smaller than or equal to toIndex\");\r\n\r\n        // culumative dividend per token, in ray\r\n        uint256 dividendPerToken = 0;\r\n\r\n        uint256 lastIndex = _dividendPhases.length.sub(1);\r\n\r\n        // sanity check, timestamp must match fromIndex\r\n        DividendPhase storage firstPhase = _dividendPhases[fromIndex];\r\n        require(timestamp >= firstPhase.start, \"Timestamp must be within the specified starting phase\");\r\n\r\n\r\n        if (fromIndex == toIndex && toIndex == lastIndex) {\r\n            // only calculating the last dividend phase\r\n            dividendPerToken = calculatePhaseDividend(timestamp, block.timestamp, firstPhase.USDPerSecondInRay);\r\n        } else {\r\n            // start the 1st phase calculation from the timestamp to phase end\r\n            dividendPerToken = calculatePhaseDividend(timestamp, firstPhase.end, firstPhase.USDPerSecondInRay);\r\n\r\n            for (uint256 i = fromIndex.add(1); i <= toIndex && i < lastIndex; i = i.add(1)) {\r\n                DividendPhase storage phase = _dividendPhases[i];\r\n\r\n                uint256 phaseDividend = calculatePhaseDividend(phase.start, phase.end, phase.USDPerSecondInRay);\r\n\r\n                dividendPerToken = dividendPerToken.add(phaseDividend);\r\n            }\r\n\r\n            if (toIndex == lastIndex) {\r\n                DividendPhase storage lastPhase = _dividendPhases[lastIndex];\r\n\r\n                uint256 phaseDividend = calculatePhaseDividend(lastPhase.start, block.timestamp, lastPhase.USDPerSecondInRay);\r\n\r\n                dividendPerToken = dividendPerToken.add(phaseDividend);\r\n            }\r\n        }\r\n\r\n        // reduce number of local variables to avoid stack too deep\r\n        CalcReturnInfo memory result = CalcReturnInfo(0, 0, 0);\r\n\r\n        if (toIndex == lastIndex) {\r\n            result.index = lastIndex;\r\n            result.timestamp = block.timestamp;\r\n        } else {\r\n            result.index = toIndex.add(1);\r\n            result.timestamp = _dividendPhases[result.index].start;\r\n        }\r\n\r\n        result.dividendInWad = tokenAmount\r\n            .wadToRay()\r\n            .rayMul(dividendPerToken)\r\n            .rayToWad();\r\n\r\n        return (result.dividendInWad, result.index, result.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice get the current dividend index\r\n     * @return the latest dividend index\r\n     */\r\n    function getCurrentIndex() external view virtual override returns (uint256) {\r\n        return _dividendPhases.length.sub(1);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice return the current dividend accrual rate, in USD per second\r\n     * @dev the returned value in 1e18 may not be precise enough\r\n     * @return dividend in USD per second\r\n     */\r\n    function getCurrentValue() external view virtual override returns (uint256) {\r\n        return getHistoricalValue(_dividendPhases.length.sub(1));\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice return the dividend accrual rate, in USD per second, of a given dividend index\r\n     * @dev the returned value in 1e18 may not be precise enough\r\n     * @return dividend in USD per second of the corresponding dividend phase.\r\n     */\r\n    function getHistoricalValue(uint256 dividendIndex) public view virtual override returns (uint256) {\r\n        (uint256 USDPerSecondInRay,,) = getPreciseDividendData(dividendIndex);\r\n\r\n        return USDPerSecondInRay.rayToWad();\r\n    }\r\n\r\n    /**\r\n     * @notice return the precise dividend accural rate in 1e27 for a given dividend index\r\n     * @return dividend in USD per second, and timestamp, of the corresponding dividend index\r\n     */\r\n    function getPreciseDividendData(uint256 dividendIndex) public view virtual returns (uint256, uint256, uint256) {\r\n        require(dividendIndex < _dividendPhases.length, \"Dividend index out of bounds\");\r\n\r\n        // storage type here points to existing storage, thus consuming less gas than memory\r\n        DividendPhase storage dividendPhase = _dividendPhases[dividendIndex];\r\n\r\n        return (dividendPhase.USDPerSecondInRay, dividendPhase.start, dividendPhase.end);\r\n    }\r\n\r\n    /**\r\n     * @notice admin can update the dividend accrual rate by creating a new dividend phase\r\n     * @param USDPerAnnumInWad     the new USD per annum accrued in 1e18\r\n     * @return  true if success\r\n     */\r\n    function newDividendPhase(uint256 USDPerAnnumInWad) public onlyWhitelisted returns (bool) {\r\n        uint256 rateInRay = USDPerAnnumInWadToPerSecondInRay(USDPerAnnumInWad);\r\n\r\n        if (_dividendPhases.length > 0) {\r\n            DividendPhase storage previousDividendPhase = _dividendPhases[_dividendPhases.length.sub(1)];\r\n\r\n            // phase.end is exclusive in sub calc, thus end of the previous phase should equal start of next phase\r\n            previousDividendPhase.end = block.timestamp;\r\n        }\r\n\r\n        DividendPhase memory newPhase = DividendPhase({ USDPerSecondInRay: rateInRay, start: block.timestamp, end: 0});\r\n        _dividendPhases.push(newPhase);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice convenience method for converting annual dividends to per second dividends with higher precision\r\n     * @param USDPerAnnumInWad       amount of USD accrued over a year in 1e18\r\n     * @return amount of USD accrued per second in 1e27\r\n     */\r\n    function USDPerAnnumInWadToPerSecondInRay(uint256 USDPerAnnumInWad) public pure returns (uint256) {\r\n        return USDPerAnnumInWad\r\n            .wadToRay()\r\n            .div(SECONDS_PER_YEAR);\r\n    }\r\n\r\n    /**\r\n     * @notice calculate the dividend between a time range\r\n     * @param start         start of dividend phase\r\n     * @param end           end of dividend phase\r\n     * @param USDPerSecondInRay     dividend accrual rate\r\n     * @return amount of USD accrued per second in 1e27\r\n     */\r\n    function calculatePhaseDividend(uint256 start, uint256 end, uint256 USDPerSecondInRay) public pure returns (uint256) {\r\n        return end\r\n            .sub(start, \"Phase start end mismatch\")\r\n            .mul(USDPerSecondInRay);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"USDPerAnnumInWad\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"DividendUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"USDPerAnnumInWad\",\"type\":\"uint256\"}],\"name\":\"USDPerAnnumInWadToPerSecondInRay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"}],\"name\":\"calculateAccruedDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"}],\"name\":\"calculateAccruedDividendsBounded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"USDPerSecondInRay\",\"type\":\"uint256\"}],\"name\":\"calculatePhaseDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dividendIndex\",\"type\":\"uint256\"}],\"name\":\"getHistoricalValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dividendIndex\",\"type\":\"uint256\"}],\"name\":\"getPreciseDividendData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"USDPerAnnumInWad\",\"type\":\"uint256\"}],\"name\":\"newDividendPhase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ManagedLinearDividendOracle","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000010f12721c5cc000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://63359ca6909ff871414d3c799c112a26e9cdc7ab24cb628ae8cac9a435901b93"}]}