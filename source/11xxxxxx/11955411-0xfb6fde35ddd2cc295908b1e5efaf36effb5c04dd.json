{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n    * @notice this interface is taken from indexed-core commit hash dae7f231d0f58bfc0993f6c01199cd6b74b01895\r\n */\r\ninterface IndexPoolI {\r\n  function getDenormalizedWeight(address token) external view returns (uint256);\r\n  function getBalance(address token) external view returns (uint256);\r\n  function getUsedBalance(address token) external view returns (uint256);\r\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);\r\n  function getCurrentTokens() external view returns (address[] memory); \r\n}\r\n\r\ninterface ERC20I {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n}\r\n\r\n/**\r\n    * @notice SimpleMultiCall is a multicall-like contract for reading IndexPool information\r\n    * @notice it is intended to minimize the need for manual abi encoding/decoding\r\n    * @notice and leverage Golang's abigen to do the heavy lifting\r\n */\r\ncontract SimpleMultiCall {\r\n\r\n    // index pool methods\r\n\r\n    function getDenormalizedWeights(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory weights = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            weights[i] = IndexPoolI(poolAddress).getDenormalizedWeight(tokens[i]);\r\n        }\r\n        return (tokens, weights);\r\n    }\r\n\r\n    function getBalances(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory balances = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            balances[i] = IndexPoolI(poolAddress).getBalance(tokens[i]);\r\n        }\r\n        return (tokens, balances);\r\n    }\r\n\r\n    function getUsedBalances(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory balances = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            balances[i] = IndexPoolI(poolAddress).getUsedBalance(tokens[i]);\r\n        }\r\n        return (tokens, balances);\r\n    }\r\n\r\n    function getSpotPrices(\r\n        address poolAddress,\r\n        address[] memory inTokens,\r\n        address[] memory outTokens\r\n    )\r\n        public\r\n        view \r\n        returns (address[] memory, address[] memory, uint256[] memory)\r\n    {\r\n        require(inTokens.length == outTokens.length);\r\n        uint256[] memory prices = new uint256[](inTokens.length);\r\n        for (uint256 i = 0; i < inTokens.length; i++) {\r\n            prices[i] = IndexPoolI(poolAddress).getSpotPrice(inTokens[i], outTokens[i]);\r\n        }\r\n        return (inTokens, outTokens, prices);\r\n    }\r\n\r\n    // returns the current tokens held by a pool\r\n    // along with their ERC20 symbol names\r\n    function poolTokensFor(\r\n        address poolAddress\r\n    )\r\n        public view\r\n        returns (address[] memory, string[] memory)\r\n    {\r\n        address[] memory poolTokens = IndexPoolI(poolAddress).getCurrentTokens();\r\n        require(poolTokens.length > 0, \"no pool tokens\");\r\n        string[] memory symbols = new string[](poolTokens.length);\r\n        for (uint256 i = 0; i < poolTokens.length; i++) {\r\n            symbols[i] = ERC20I(poolTokens[i]).symbol();\r\n        }\r\n        return (poolTokens, symbols);\r\n    }\r\n\r\n    // erc20 methods\r\n\r\n    function getTotalSupplies(\r\n        address[] memory tokens\r\n    )\r\n        public\r\n        view\r\n        returns (address[] memory, uint256[] memory)\r\n    {\r\n        uint256[] memory supplies = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            supplies[i] = ERC20I(tokens[i]).totalSupply();\r\n        }\r\n        return (tokens, supplies);\r\n    }\r\n\r\n    function getDecimals(\r\n       address[] memory tokens\r\n    )\r\n        public\r\n        view\r\n        returns (address[] memory, uint8[] memory)\r\n    {\r\n        uint8[] memory decimals = new uint8[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            decimals[i] = ERC20I(tokens[i]).decimals();\r\n        }\r\n        return (tokens, decimals);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getDecimals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getDenormalizedWeights\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"inTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"outTokens\",\"type\":\"address[]\"}],\"name\":\"getSpotPrices\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getTotalSupplies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getUsedBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"poolTokensFor\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SimpleMultiCall","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ab8c0203a7944720b911a79153e9cde0ed213814da778c88075faaf71aadb90c"}]}