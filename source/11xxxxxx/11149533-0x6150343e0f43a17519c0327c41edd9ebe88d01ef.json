{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: Apache-2.0\r\n// Copyright 2017 Loopring Technology Limited.\r\npragma solidity ^0.7.0;\r\n\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title IBlockVerifier\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nabstract contract IBlockVerifier is Claimable\r\n{\r\n    // -- Events --\r\n\r\n    event CircuitRegistered(\r\n        uint8  indexed blockType,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    event CircuitDisabled(\r\n        uint8  indexed blockType,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    // -- Public functions --\r\n\r\n    /// @dev Sets the verifying key for the specified circuit.\r\n    ///      Every block permutation needs its own circuit and thus its own set of\r\n    ///      verification keys. Only a limited number of block sizes per block\r\n    ///      type are supported.\r\n    /// @param blockType The type of the block\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param vk The verification key\r\n    function registerCircuit(\r\n        uint8    blockType,\r\n        uint16   blockSize,\r\n        uint8    blockVersion,\r\n        uint[18] calldata vk\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Disables the use of the specified circuit.\r\n    ///      This will stop NEW blocks from using the given circuit, blocks that were already committed\r\n    ///      can still be verified.\r\n    /// @param blockType The type of the block\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    function disableCircuit(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Verifies blocks with the given public data and proofs.\r\n    ///      Verifying a block makes sure all requests handled in the block\r\n    ///      are correctly handled by the operator.\r\n    /// @param blockType The type of block\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param publicInputs The hash of all the public data of the blocks\r\n    /// @param proofs The ZK proofs proving that the blocks are correct\r\n    /// @return True if the block is valid, false otherwise\r\n    function verifyProofs(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        uint[] calldata publicInputs,\r\n        uint[] calldata proofs\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit with the specified parameters is registered.\r\n    /// @param blockType The type of the block\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is registered, false otherwise\r\n    function isCircuitRegistered(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit can still be used to commit new blocks.\r\n    /// @param blockType The type of the block\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is enabled, false otherwise\r\n    function isCircuitEnabled(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title ReentrancyGuard\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Exposes a modifier that guards a function against reentrancy\r\n///      Changing the value of the same storage value multiple times in a transaction\r\n///      is cheap (starting from Istanbul) so there is no need to minimize\r\n///      the number of times the value is changed\r\ncontract ReentrancyGuard\r\n{\r\n    //The default value must be 0 in order to work behind a proxy.\r\n    uint private _guardValue;\r\n\r\n    // Use this modifier on a function to prevent reentrancy\r\n    modifier nonReentrant()\r\n    {\r\n        // Check if the guard value has its original value\r\n        require(_guardValue == 0, \"REENTRANCY\");\r\n\r\n        // Set the value to something else\r\n        _guardValue = 1;\r\n\r\n        // Function body\r\n        _;\r\n\r\n        // Set the value back\r\n        _guardValue = 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n// This code is taken from https://github.com/matter-labs/Groth16BatchVerifier/blob/master/BatchedSnarkVerifier/contracts/BatchVerifier.sol\r\n// Thanks Harry from ETHSNARKS for base code\r\n\r\n\r\nlibrary BatchVerifier {\r\n    function GroupOrder ()\r\n        public pure returns (uint256)\r\n    {\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n\r\n    function NegateY( uint256 Y )\r\n        internal pure returns (uint256)\r\n    {\r\n        uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n        return q - (Y % q);\r\n    }\r\n\r\n    function getProofEntropy(\r\n        uint256[] memory in_proof,\r\n        uint256[] memory proof_inputs,\r\n        uint proofNumber\r\n    )\r\n        internal pure returns (uint256)\r\n    {\r\n        // Truncate the least significant 3 bits from the 256bit entropy so it fits the scalar field\r\n        return uint(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    in_proof[proofNumber*8 + 0], in_proof[proofNumber*8 + 1], in_proof[proofNumber*8 + 2], in_proof[proofNumber*8 + 3],\r\n                    in_proof[proofNumber*8 + 4], in_proof[proofNumber*8 + 5], in_proof[proofNumber*8 + 6], in_proof[proofNumber*8 + 7],\r\n                    proof_inputs[proofNumber]\r\n                )\r\n            )\r\n        ) >> 3;\r\n    }\r\n\r\n    function accumulate(\r\n        uint256[] memory in_proof,\r\n        uint256[] memory proof_inputs, // public inputs, length is num_inputs * num_proofs\r\n        uint256 num_proofs\r\n    ) internal view returns (\r\n        bool success,\r\n        uint256[] memory proofsAandC,\r\n        uint256[] memory inputAccumulators\r\n    ) {\r\n        uint256 q = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n        uint256 numPublicInputs = proof_inputs.length / num_proofs;\r\n        uint256[] memory entropy = new uint256[](num_proofs);\r\n        inputAccumulators = new uint256[](numPublicInputs + 1);\r\n\r\n        for (uint256 proofNumber = 0; proofNumber < num_proofs; proofNumber++) {\r\n            if (proofNumber == 0) {\r\n                entropy[proofNumber] = 1;\r\n            } else {\r\n                // entropy[proofNumber] = uint(blockhash(block.number - proofNumber)) % q;\r\n                // Safer entropy:\r\n                entropy[proofNumber] = getProofEntropy(in_proof, proof_inputs, proofNumber);\r\n            }\r\n            require(entropy[proofNumber] != 0, \"Entropy should not be zero\");\r\n            // here multiplication by 1 is implied\r\n            inputAccumulators[0] = addmod(inputAccumulators[0], entropy[proofNumber], q);\r\n            for (uint256 i = 0; i < numPublicInputs; i++) {\r\n                require(proof_inputs[proofNumber * numPublicInputs + i] < q, \"INVALID_INPUT\");\r\n                // accumulate the exponent with extra entropy mod q\r\n                inputAccumulators[i+1] = addmod(inputAccumulators[i+1], mulmod(entropy[proofNumber], proof_inputs[proofNumber * numPublicInputs + i], q), q);\r\n            }\r\n            // coefficient for +vk.alpha (mind +) is the same as inputAccumulator[0]\r\n        }\r\n\r\n        // inputs for scalar multiplication\r\n        uint256[3] memory mul_input;\r\n\r\n        // use scalar multiplications to get proof.A[i] * entropy[i]\r\n\r\n        proofsAandC = new uint256[](num_proofs*2 + 2);\r\n\r\n        proofsAandC[0] = in_proof[0];\r\n        proofsAandC[1] = in_proof[1];\r\n\r\n        for (uint256 proofNumber = 1; proofNumber < num_proofs; proofNumber++) {\r\n            require(entropy[proofNumber] < q, \"INVALID_INPUT\");\r\n            mul_input[0] = in_proof[proofNumber*8];\r\n            mul_input[1] = in_proof[proofNumber*8 + 1];\r\n            mul_input[2] = entropy[proofNumber];\r\n            assembly {\r\n                // ECMUL, output proofsA[i]\r\n                // success := staticcall(sub(gas, 2000), 7, mul_input, 0x60, add(add(proofsAandC, 0x20), mul(proofNumber, 0x40)), 0x40)\r\n                success := staticcall(sub(gas(), 2000), 7, mul_input, 0x60, mul_input, 0x40)\r\n            }\r\n            if (!success) {\r\n                return (false, proofsAandC, inputAccumulators);\r\n            }\r\n            proofsAandC[proofNumber*2] = mul_input[0];\r\n            proofsAandC[proofNumber*2 + 1] = mul_input[1];\r\n        }\r\n\r\n        // use scalar multiplication and addition to get sum(proof.C[i] * entropy[i])\r\n\r\n        uint256[4] memory add_input;\r\n\r\n        add_input[0] = in_proof[6];\r\n        add_input[1] = in_proof[7];\r\n\r\n        for (uint256 proofNumber = 1; proofNumber < num_proofs; proofNumber++) {\r\n            mul_input[0] = in_proof[proofNumber*8 + 6];\r\n            mul_input[1] = in_proof[proofNumber*8 + 7];\r\n            mul_input[2] = entropy[proofNumber];\r\n            assembly {\r\n                // ECMUL, output proofsA\r\n                success := staticcall(sub(gas(), 2000), 7, mul_input, 0x60, add(add_input, 0x40), 0x40)\r\n            }\r\n            if (!success) {\r\n                return (false, proofsAandC, inputAccumulators);\r\n            }\r\n\r\n            assembly {\r\n                // ECADD from two elements that are in add_input and output into first two elements of add_input\r\n                success := staticcall(sub(gas(), 2000), 6, add_input, 0x80, add_input, 0x40)\r\n            }\r\n            if (!success) {\r\n                return (false, proofsAandC, inputAccumulators);\r\n            }\r\n        }\r\n\r\n        proofsAandC[num_proofs*2] = add_input[0];\r\n        proofsAandC[num_proofs*2 + 1] = add_input[1];\r\n    }\r\n\r\n    function prepareBatches(\r\n        uint256[14] memory in_vk,\r\n        uint256[4] memory vk_gammaABC,\r\n        uint256[] memory inputAccumulators\r\n    ) internal view returns (\r\n        bool success,\r\n        uint256[4] memory finalVksAlphaX\r\n    ) {\r\n        // Compute the linear combination vk_x using accumulator\r\n        // First two fields are used as the sum and are initially zero\r\n        uint256[4] memory add_input;\r\n        uint256[3] memory mul_input;\r\n\r\n        // Performs a sum(gammaABC[i] * inputAccumulator[i])\r\n        for (uint256 i = 0; i < inputAccumulators.length; i++) {\r\n            mul_input[0] = vk_gammaABC[2*i];\r\n            mul_input[1] = vk_gammaABC[2*i + 1];\r\n            mul_input[2] = inputAccumulators[i];\r\n\r\n            assembly {\r\n                // ECMUL, output to the last 2 elements of `add_input`\r\n                success := staticcall(sub(gas(), 2000), 7, mul_input, 0x60, add(add_input, 0x40), 0x40)\r\n            }\r\n            if (!success) {\r\n                return (false, finalVksAlphaX);\r\n            }\r\n\r\n            assembly {\r\n                // ECADD from four elements that are in add_input and output into first two elements of add_input\r\n                success := staticcall(sub(gas(), 2000), 6, add_input, 0x80, add_input, 0x40)\r\n            }\r\n            if (!success) {\r\n                return (false, finalVksAlphaX);\r\n            }\r\n        }\r\n\r\n        finalVksAlphaX[2] = add_input[0];\r\n        finalVksAlphaX[3] = add_input[1];\r\n\r\n        // add one extra memory slot for scalar for multiplication usage\r\n        uint256[3] memory finalVKalpha;\r\n        finalVKalpha[0] = in_vk[0];\r\n        finalVKalpha[1] = in_vk[1];\r\n        finalVKalpha[2] = inputAccumulators[0];\r\n\r\n        assembly {\r\n            // ECMUL, output to first 2 elements of finalVKalpha\r\n            success := staticcall(sub(gas(), 2000), 7, finalVKalpha, 0x60, finalVKalpha, 0x40)\r\n        }\r\n        if (!success) {\r\n            return (false, finalVksAlphaX);\r\n        }\r\n\r\n        finalVksAlphaX[0] = finalVKalpha[0];\r\n        finalVksAlphaX[1] = finalVKalpha[1];\r\n    }\r\n\r\n    // original equation\r\n    // e(proof.A, proof.B)*e(-vk.alpha, vk.beta)*e(-vk_x, vk.gamma)*e(-proof.C, vk.delta) == 1\r\n    // accumulation of inputs\r\n    // gammaABC[0] + sum[ gammaABC[i+1]^proof_inputs[i] ]\r\n\r\n    function BatchVerify (\r\n        uint256[14] memory in_vk, // verifying key is always constant number of elements\r\n        uint256[4] memory vk_gammaABC, // variable length, depends on number of inputs\r\n        uint256[] memory in_proof, // proof itself, length is 8 * num_proofs\r\n        uint256[] memory proof_inputs, // public inputs, length is num_inputs * num_proofs\r\n        uint256 num_proofs\r\n    )\r\n    internal\r\n    view\r\n    returns (bool success)\r\n    {\r\n        require(in_proof.length == num_proofs * 8, \"Invalid proofs length for a batch\");\r\n        require(proof_inputs.length % num_proofs == 0, \"Invalid inputs length for a batch\");\r\n        require(((vk_gammaABC.length / 2) - 1) == proof_inputs.length / num_proofs, \"Invalid verification key\");\r\n\r\n        // strategy is to accumulate entropy separately for some proof elements\r\n        // (accumulate only for G1, can't in G2) of the pairing equation, as well as input verification key,\r\n        // postpone scalar multiplication as much as possible and check only one equation\r\n        // by using 3 + num_proofs pairings only plus 2*num_proofs + (num_inputs+1) + 1 scalar multiplications compared to naive\r\n        // 4*num_proofs pairings and num_proofs*(num_inputs+1) scalar multiplications\r\n\r\n        bool valid;\r\n        uint256[] memory proofsAandC;\r\n        uint256[] memory inputAccumulators;\r\n        (valid, proofsAandC, inputAccumulators) = accumulate(in_proof, proof_inputs, num_proofs);\r\n        if (!valid) {\r\n            return false;\r\n        }\r\n\r\n        uint256[4] memory finalVksAlphaX;\r\n        (valid, finalVksAlphaX) = prepareBatches(in_vk, vk_gammaABC, inputAccumulators);\r\n        if (!valid) {\r\n            return false;\r\n        }\r\n\r\n        uint256[] memory inputs = new uint256[](6*num_proofs + 18);\r\n        // first num_proofs pairings e(ProofA, ProofB)\r\n        for (uint256 proofNumber = 0; proofNumber < num_proofs; proofNumber++) {\r\n            inputs[proofNumber*6] = proofsAandC[proofNumber*2];\r\n            inputs[proofNumber*6 + 1] = proofsAandC[proofNumber*2 + 1];\r\n            inputs[proofNumber*6 + 2] = in_proof[proofNumber*8 + 2];\r\n            inputs[proofNumber*6 + 3] = in_proof[proofNumber*8 + 3];\r\n            inputs[proofNumber*6 + 4] = in_proof[proofNumber*8 + 4];\r\n            inputs[proofNumber*6 + 5] = in_proof[proofNumber*8 + 5];\r\n        }\r\n\r\n        // second pairing e(-finalVKaplha, vk.beta)\r\n        inputs[num_proofs*6] = finalVksAlphaX[0];\r\n        inputs[num_proofs*6 + 1] = NegateY(finalVksAlphaX[1]);\r\n        inputs[num_proofs*6 + 2] = in_vk[2];\r\n        inputs[num_proofs*6 + 3] = in_vk[3];\r\n        inputs[num_proofs*6 + 4] = in_vk[4];\r\n        inputs[num_proofs*6 + 5] = in_vk[5];\r\n\r\n        // third pairing e(-finalVKx, vk.gamma)\r\n        inputs[num_proofs*6 + 6] = finalVksAlphaX[2];\r\n        inputs[num_proofs*6 + 7] = NegateY(finalVksAlphaX[3]);\r\n        inputs[num_proofs*6 + 8] = in_vk[6];\r\n        inputs[num_proofs*6 + 9] = in_vk[7];\r\n        inputs[num_proofs*6 + 10] = in_vk[8];\r\n        inputs[num_proofs*6 + 11] = in_vk[9];\r\n\r\n        // fourth pairing e(-proof.C, finalVKdelta)\r\n        inputs[num_proofs*6 + 12] = proofsAandC[num_proofs*2];\r\n        inputs[num_proofs*6 + 13] = NegateY(proofsAandC[num_proofs*2 + 1]);\r\n        inputs[num_proofs*6 + 14] = in_vk[10];\r\n        inputs[num_proofs*6 + 15] = in_vk[11];\r\n        inputs[num_proofs*6 + 16] = in_vk[12];\r\n        inputs[num_proofs*6 + 17] = in_vk[13];\r\n\r\n        uint256 inputsLength = inputs.length * 32;\r\n        uint[1] memory out;\r\n        require(inputsLength % 192 == 0, \"Inputs length should be multiple of 192 bytes\");\r\n\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 8, add(inputs, 0x20), inputsLength, out, 0x20)\r\n        }\r\n        return success && out[0] == 1;\r\n    }\r\n}\r\n\r\n\r\n// This code is taken from https://github.com/HarryR/ethsnarks/blob/master/contracts/Verifier.sol\r\n// this code is taken from https://github.com/JacobEberhardt/ZoKrates\r\n\r\n\r\nlibrary Verifier\r\n{\r\n    function ScalarField ()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n\r\n    function NegateY( uint256 Y )\r\n        internal pure returns (uint256)\r\n    {\r\n        uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n        return q - (Y % q);\r\n    }\r\n\r\n\r\n    /*\r\n    * This implements the Solidity equivalent of the following Python code:\r\n\r\n        from py_ecc.bn128 import *\r\n\r\n        data = # ... arguments to function [in_vk, vk_gammaABC, in_proof, proof_inputs]\r\n\r\n        vk = [int(_, 16) for _ in data[0]]\r\n        ic = [FQ(int(_, 16)) for _ in data[1]]\r\n        proof = [int(_, 16) for _ in data[2]]\r\n        inputs = [int(_, 16) for _ in data[3]]\r\n\r\n        it = iter(ic)\r\n        ic = [(_, next(it)) for _ in it]\r\n        vk_alpha = [FQ(_) for _ in vk[:2]]\r\n        vk_beta = (FQ2(vk[2:4][::-1]), FQ2(vk[4:6][::-1]))\r\n        vk_gamma = (FQ2(vk[6:8][::-1]), FQ2(vk[8:10][::-1]))\r\n        vk_delta = (FQ2(vk[10:12][::-1]), FQ2(vk[12:14][::-1]))\r\n\r\n        assert is_on_curve(vk_alpha, b)\r\n        assert is_on_curve(vk_beta, b2)\r\n        assert is_on_curve(vk_gamma, b2)\r\n        assert is_on_curve(vk_delta, b2)\r\n\r\n        proof_A = [FQ(_) for _ in proof[:2]]\r\n        proof_B = (FQ2(proof[2:4][::-1]), FQ2(proof[4:-2][::-1]))\r\n        proof_C = [FQ(_) for _ in proof[-2:]]\r\n\r\n        assert is_on_curve(proof_A, b)\r\n        assert is_on_curve(proof_B, b2)\r\n        assert is_on_curve(proof_C, b)\r\n\r\n        vk_x = ic[0]\r\n        for i, s in enumerate(inputs):\r\n            vk_x = add(vk_x, multiply(ic[i + 1], s))\r\n\r\n        check_1 = pairing(proof_B, proof_A)\r\n        check_2 = pairing(vk_beta, neg(vk_alpha))\r\n        check_3 = pairing(vk_gamma, neg(vk_x))\r\n        check_4 = pairing(vk_delta, neg(proof_C))\r\n\r\n        ok = check_1 * check_2 * check_3 * check_4\r\n        assert ok == FQ12.one()\r\n    */\r\n    function Verify(\r\n        uint256[14] memory in_vk,\r\n        uint256[4] memory vk_gammaABC,\r\n        uint256[] memory in_proof,\r\n        uint256[] memory proof_inputs\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 snark_scalar_field = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n        require(((vk_gammaABC.length / 2) - 1) == proof_inputs.length, \"INVALID_VALUE\");\r\n\r\n        // Compute the linear combination vk_x\r\n        uint256[3] memory mul_input;\r\n        uint256[4] memory add_input;\r\n        bool success;\r\n        uint m = 2;\r\n\r\n        // First two fields are used as the sum\r\n        add_input[0] = vk_gammaABC[0];\r\n        add_input[1] = vk_gammaABC[1];\r\n\r\n        // Performs a sum of gammaABC[0] + sum[ gammaABC[i+1]^proof_inputs[i] ]\r\n        for (uint i = 0; i < proof_inputs.length; i++) {\r\n            require(proof_inputs[i] < snark_scalar_field, \"INVALID_INPUT\");\r\n            mul_input[0] = vk_gammaABC[m++];\r\n            mul_input[1] = vk_gammaABC[m++];\r\n            mul_input[2] = proof_inputs[i];\r\n\r\n            assembly {\r\n                // ECMUL, output to last 2 elements of `add_input`\r\n                success := staticcall(sub(gas(), 2000), 7, mul_input, 0x80, add(add_input, 0x40), 0x60)\r\n            }\r\n            if (!success) {\r\n                return false;\r\n            }\r\n\r\n            assembly {\r\n                // ECADD\r\n                success := staticcall(sub(gas(), 2000), 6, add_input, 0xc0, add_input, 0x60)\r\n            }\r\n            if (!success) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        uint[24] memory input = [\r\n            // (proof.A, proof.B)\r\n            in_proof[0], in_proof[1],                           // proof.A   (G1)\r\n            in_proof[2], in_proof[3], in_proof[4], in_proof[5], // proof.B   (G2)\r\n\r\n            // (-vk.alpha, vk.beta)\r\n            in_vk[0], NegateY(in_vk[1]),                        // -vk.alpha (G1)\r\n            in_vk[2], in_vk[3], in_vk[4], in_vk[5],             // vk.beta   (G2)\r\n\r\n            // (-vk_x, vk.gamma)\r\n            add_input[0], NegateY(add_input[1]),                // -vk_x     (G1)\r\n            in_vk[6], in_vk[7], in_vk[8], in_vk[9],             // vk.gamma  (G2)\r\n\r\n            // (-proof.C, vk.delta)\r\n            in_proof[6], NegateY(in_proof[7]),                  // -proof.C  (G1)\r\n            in_vk[10], in_vk[11], in_vk[12], in_vk[13]          // vk.delta  (G2)\r\n        ];\r\n\r\n        uint[1] memory out;\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 8, input, 768, out, 0x20)\r\n        }\r\n        return success && out[0] != 0;\r\n    }\r\n}\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\ninterface IAgent{}\r\n\r\ninterface IAgentRegistry\r\n{\r\n    /// @dev Returns whether an agent address is an agent of an account owner\r\n    /// @param owner The account owner.\r\n    /// @param agent The agent address\r\n    /// @return True if the agent address is an agent for the account owner, else false\r\n    function isAgent(\r\n        address owner,\r\n        address agent\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Returns whether an agent address is an agent of all account owners\r\n    /// @param owners The account owners.\r\n    /// @param agent The agent address\r\n    /// @return True if the agent address is an agent for the account owner, else false\r\n    function isAgent(\r\n        address[] calldata owners,\r\n        address            agent\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title IDepositContract.\r\n/// @dev   Contract storing and transferring funds for an exchange.\r\n///\r\n///        ERC1155 tokens can be supported by registering pseudo token addresses calculated\r\n///        as `address(keccak256(real_token_address, token_params))`. Then the custom\r\n///        deposit contract can look up the real token address and paramsters with the\r\n///        pseudo token address before doing the transfers.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ninterface IDepositContract\r\n{\r\n    /// @dev Returns if a token is suppoprted by this contract.\r\n    function isTokenSupported(address token)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Transfers tokens from a user to the exchange. This function will\r\n    ///      be called when a user deposits funds to the exchange.\r\n    ///      In a simple implementation the funds are simply stored inside the\r\n    ///      deposit contract directly. More advanced implementations may store the funds\r\n    ///      in some DeFi application to earn interest, so this function could directly\r\n    ///      call the necessary functions to store the funds there.\r\n    ///\r\n    ///      This function needs to throw when an error occurred!\r\n    ///\r\n    ///      This function can only be called by the exchange.\r\n    ///\r\n    /// @param from The address of the account that sends the tokens.\r\n    /// @param token The address of the token to transfer (`0x0` for ETH).\r\n    /// @param amount The amount of tokens to transfer.\r\n    /// @param extraData Opaque data that can be used by the contract to handle the deposit\r\n    /// @return amountReceived The amount to deposit to the user's account in the Merkle tree\r\n    function deposit(\r\n        address from,\r\n        address token,\r\n        uint96  amount,\r\n        bytes   calldata extraData\r\n        )\r\n        external\r\n        payable\r\n        returns (uint96 amountReceived);\r\n\r\n    /// @dev Transfers tokens from the exchange to a user. This function will\r\n    ///      be called when a withdrawal is done for a user on the exchange.\r\n    ///      In the simplest implementation the funds are simply stored inside the\r\n    ///      deposit contract directly so this simply transfers the requested tokens back\r\n    ///      to the user. More advanced implementations may store the funds\r\n    ///      in some DeFi application to earn interest so the function would\r\n    ///      need to get those tokens back from the DeFi application first before they\r\n    ///      can be transferred to the user.\r\n    ///\r\n    ///      This function needs to throw when an error occurred!\r\n    ///\r\n    ///      This function can only be called by the exchange.\r\n    ///\r\n    /// @param from The address from which 'amount' tokens are transferred.\r\n    /// @param to The address to which 'amount' tokens are transferred.\r\n    /// @param token The address of the token to transfer (`0x0` for ETH).\r\n    /// @param amount The amount of tokens transferred.\r\n    /// @param extraData Opaque data that can be used by the contract to handle the withdrawal\r\n    function withdraw(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint    amount,\r\n        bytes   calldata extraData\r\n        )\r\n        external\r\n        payable;\r\n\r\n    /// @dev Transfers tokens (ETH not supported) for a user using the allowance set\r\n    ///      for the exchange. This way the approval can be used for all functionality (and\r\n    ///      extended functionality) of the exchange.\r\n    ///      Should NOT be used to deposit/withdraw user funds, `deposit`/`withdraw`\r\n    ///      should be used for that as they will contain specialised logic for those operations.\r\n    ///      This function can be called by the exchange to transfer onchain funds of users\r\n    ///      necessary for Agent functionality.\r\n    ///\r\n    ///      This function needs to throw when an error occurred!\r\n    ///\r\n    ///      This function can only be called by the exchange.\r\n    ///\r\n    /// @param from The address of the account that sends the tokens.\r\n    /// @param to The address to which 'amount' tokens are transferred.\r\n    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\r\n    /// @param amount The amount of tokens transferred.\r\n    function transfer(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint    amount\r\n        )\r\n        external\r\n        payable;\r\n\r\n    /// @dev Checks if the given address is used for depositing ETH or not.\r\n    ///      Is used while depositing to send the correct ETH amount to the deposit contract.\r\n    ///\r\n    ///      Note that 0x0 is always registered for deposting ETH when the exchange is created!\r\n    ///      This function allows additional addresses to be used for depositing ETH, the deposit\r\n    ///      contract can implement different behaviour based on the address value.\r\n    ///\r\n    /// @param addr The address to check\r\n    /// @return True if the address is used for depositing ETH, else false.\r\n    function isETH(address addr)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n/// @title ILoopringV3\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\nabstract contract ILoopringV3 is Claimable\r\n{\r\n    // == Events ==\r\n    event ExchangeStakeDeposited(address exchangeAddr, uint amount);\r\n    event ExchangeStakeWithdrawn(address exchangeAddr, uint amount);\r\n    event ExchangeStakeBurned(address exchangeAddr, uint amount);\r\n    event SettingsUpdated(uint time);\r\n\r\n    // == Public Variables ==\r\n    mapping (address => uint) internal exchangeStake;\r\n\r\n    address public lrcAddress;\r\n    uint    public totalStake;\r\n    address public blockVerifierAddress;\r\n    uint    public forcedWithdrawalFee;\r\n    uint    public tokenRegistrationFeeLRCBase;\r\n    uint    public tokenRegistrationFeeLRCDelta;\r\n    uint8   public protocolTakerFeeBips;\r\n    uint8   public protocolMakerFeeBips;\r\n\r\n    address payable public protocolFeeVault;\r\n\r\n    // == Public Functions ==\r\n    /// @dev Updates the global exchange settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateSettings(\r\n        address payable _protocolFeeVault,   // address(0) not allowed\r\n        address _blockVerifierAddress,       // address(0) not allowed\r\n        uint    _forcedWithdrawalFee\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Updates the global protocol fee settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateProtocolFeeSettings(\r\n        uint8 _protocolTakerFeeBips,\r\n        uint8 _protocolMakerFeeBips\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Gets the amount of staked LRC for an exchange.\r\n    /// @param exchangeAddr The address of the exchange\r\n    /// @return stakedLRC The amount of LRC\r\n    function getExchangeStake(\r\n        address exchangeAddr\r\n        )\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Burns a certain amount of staked LRC for a specific exchange.\r\n    ///      This function is meant to be called only from exchange contracts.\r\n    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\r\n    ///         the staked amount, all staked LRC will be burned.\r\n    function burnExchangeStake(\r\n        uint amount\r\n        )\r\n        external\r\n        virtual\r\n        returns (uint burnedLRC);\r\n\r\n    /// @dev Stakes more LRC for an exchange.\r\n    /// @param  exchangeAddr The address of the exchange\r\n    /// @param  amountLRC The amount of LRC to stake\r\n    /// @return stakedLRC The total amount of LRC staked for the exchange\r\n    function depositExchangeStake(\r\n        address exchangeAddr,\r\n        uint    amountLRC\r\n        )\r\n        external\r\n        virtual\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Withdraws a certain amount of staked LRC for an exchange to the given address.\r\n    ///      This function is meant to be called only from within exchange contracts.\r\n    /// @param  recipient The address to receive LRC\r\n    /// @param  requestedAmount The amount of LRC to withdraw\r\n    /// @return amountLRC The amount of LRC withdrawn\r\n    function withdrawExchangeStake(\r\n        address recipient,\r\n        uint    requestedAmount\r\n        )\r\n        external\r\n        virtual\r\n        returns (uint amountLRC);\r\n\r\n    /// @dev Gets the protocol fee values for an exchange.\r\n    /// @return takerFeeBips The protocol taker fee\r\n    /// @return makerFeeBips The protocol maker fee\r\n    function getProtocolFeeValues(\r\n        )\r\n        public\r\n        virtual\r\n        view\r\n        returns (\r\n            uint8 takerFeeBips,\r\n            uint8 makerFeeBips\r\n        );\r\n}\r\n\r\n\r\n\r\n/// @title ExchangeData\r\n/// @dev All methods in this lib are internal, therefore, there is no need\r\n///      to deploy this library independently.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeData\r\n{\r\n    // -- Enums --\r\n    enum TransactionType\r\n    {\r\n        NOOP,\r\n        DEPOSIT,\r\n        WITHDRAWAL,\r\n        TRANSFER,\r\n        SPOT_TRADE,\r\n        ACCOUNT_UPDATE,\r\n        AMM_UPDATE\r\n    }\r\n\r\n    // -- Structs --\r\n    struct Token\r\n    {\r\n        address token;\r\n    }\r\n\r\n    struct ProtocolFeeData\r\n    {\r\n        uint32 syncedAt; // only valid before 2105 (85 years to go)\r\n        uint8  takerFeeBips;\r\n        uint8  makerFeeBips;\r\n        uint8  previousTakerFeeBips;\r\n        uint8  previousMakerFeeBips;\r\n    }\r\n\r\n    // General auxiliary data for each conditional transaction\r\n    struct AuxiliaryData\r\n    {\r\n        uint  txIndex;\r\n        bytes data;\r\n    }\r\n\r\n    // This is the (virtual) block the owner  needs to submit onchain to maintain the\r\n    // per-exchange (virtual) blockchain.\r\n    struct Block\r\n    {\r\n        uint8      blockType;\r\n        uint16     blockSize;\r\n        uint8      blockVersion;\r\n        bytes      data;\r\n        uint256[8] proof;\r\n\r\n        // Whether we should store the @BlockInfo for this block on-chain.\r\n        bool storeBlockInfoOnchain;\r\n\r\n        // Block specific data that is only used to help process the block on-chain.\r\n        // It is not used as input for the circuits and it is not necessary for data-availability.\r\n        AuxiliaryData[] auxiliaryData;\r\n\r\n        // Arbitrary data, mainly for off-chain data-availability, i.e.,\r\n        // the multihash of the IPFS file that contains the block data.\r\n        bytes offchainData;\r\n    }\r\n\r\n    struct BlockInfo\r\n    {\r\n        // The time the block was submitted on-chain.\r\n        uint32  timestamp;\r\n        // The public data hash of the block (the 28 most significant bytes).\r\n        bytes28 blockDataHash;\r\n    }\r\n\r\n    // Represents an onchain deposit request.\r\n    struct Deposit\r\n    {\r\n        uint96 amount;\r\n        uint64 timestamp;\r\n    }\r\n\r\n    // A forced withdrawal request.\r\n    // If the actual owner of the account initiated the request (we don't know who the owner is\r\n    // at the time the request is being made) the full balance will be withdrawn.\r\n    struct ForcedWithdrawal\r\n    {\r\n        address owner;\r\n        uint64  timestamp;\r\n    }\r\n\r\n    struct Constants\r\n    {\r\n        uint SNARK_SCALAR_FIELD;\r\n        uint MAX_OPEN_FORCED_REQUESTS;\r\n        uint MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE;\r\n        uint TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS;\r\n        uint MAX_NUM_ACCOUNTS;\r\n        uint MAX_NUM_TOKENS;\r\n        uint MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED;\r\n        uint MIN_TIME_IN_SHUTDOWN;\r\n        uint TX_DATA_AVAILABILITY_SIZE;\r\n        uint MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND;\r\n    }\r\n\r\n    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\r\n        // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n    function MAX_OPEN_FORCED_REQUESTS() internal pure returns (uint16) { return 4096; }\r\n    function MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 15 days; }\r\n    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 7 days; }\r\n    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 32; }\r\n    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 16; }\r\n    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 7 days; }\r\n    function MIN_TIME_IN_SHUTDOWN() internal pure returns (uint32) { return 30 days; }\r\n    // The amount of bytes each rollup transaction uses in the block data for data-availability.\r\n    // This is the maximum amount of bytes of all different transaction types.\r\n    function TX_DATA_AVAILABILITY_SIZE() internal pure returns (uint32) { return 68; }\r\n    function MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND() internal pure returns (uint32) { return 15 days; }\r\n    function ACCOUNTID_PROTOCOLFEE() internal pure returns (uint32) { return 0; }\r\n\r\n    function TX_DATA_AVAILABILITY_SIZE_PART_1() internal pure returns (uint32) { return 29; }\r\n    function TX_DATA_AVAILABILITY_SIZE_PART_2() internal pure returns (uint32) { return 39; }\r\n\r\n    struct AccountLeaf\r\n    {\r\n        uint32   accountID;\r\n        address  owner;\r\n        uint     pubKeyX;\r\n        uint     pubKeyY;\r\n        uint32   nonce;\r\n        uint     feeBipsAMM;\r\n    }\r\n\r\n    struct BalanceLeaf\r\n    {\r\n        uint16   tokenID;\r\n        uint96   balance;\r\n        uint96   weightAMM;\r\n        uint     storageRoot;\r\n    }\r\n\r\n    struct MerkleProof\r\n    {\r\n        ExchangeData.AccountLeaf accountLeaf;\r\n        ExchangeData.BalanceLeaf balanceLeaf;\r\n        uint[48]                 accountMerkleProof;\r\n        uint[24]                 balanceMerkleProof;\r\n    }\r\n\r\n    struct BlockContext\r\n    {\r\n        bytes32 DOMAIN_SEPARATOR;\r\n        uint32  timestamp;\r\n    }\r\n\r\n    // Represents the entire exchange state except the owner of the exchange.\r\n    struct State\r\n    {\r\n        uint32  maxAgeDepositUntilWithdrawable;\r\n        bytes32 DOMAIN_SEPARATOR;\r\n\r\n        ILoopringV3      loopring;\r\n        IBlockVerifier   blockVerifier;\r\n        IAgentRegistry   agentRegistry;\r\n        IDepositContract depositContract;\r\n\r\n\r\n        // The merkle root of the offchain data stored in a Merkle tree. The Merkle tree\r\n        // stores balances for users using an account model.\r\n        bytes32 merkleRoot;\r\n\r\n        // List of all blocks\r\n        mapping(uint => BlockInfo) blocks;\r\n        uint  numBlocks;\r\n\r\n        // List of all tokens\r\n        Token[] tokens;\r\n\r\n        // A map from a token to its tokenID + 1\r\n        mapping (address => uint16) tokenToTokenId;\r\n\r\n        // A map from an accountID to a tokenID to if the balance is withdrawn\r\n        mapping (uint32 => mapping (uint16 => bool)) withdrawnInWithdrawMode;\r\n\r\n        // A map from an account to a token to the amount withdrawable for that account.\r\n        // This is only used when the automatic distribution of the withdrawal failed.\r\n        mapping (address => mapping (uint16 => uint)) amountWithdrawable;\r\n\r\n        // A map from an account to a token to the forced withdrawal (always full balance)\r\n        mapping (uint32 => mapping (uint16 => ForcedWithdrawal)) pendingForcedWithdrawals;\r\n\r\n        // A map from an address to a token to a deposit\r\n        mapping (address => mapping (uint16 => Deposit)) pendingDeposits;\r\n\r\n        // A map from an account owner to an approved transaction hash to if the transaction is approved or not\r\n        mapping (address => mapping (bytes32 => bool)) approvedTx;\r\n\r\n        // A map from an account owner to a destination address to a tokenID to an amount to a storageID to a new recipient address\r\n        mapping (address => mapping (address => mapping (uint16 => mapping (uint => mapping (uint32 => address))))) withdrawalRecipient;\r\n\r\n\r\n        // Counter to keep track of how many of forced requests are open so we can limit the work that needs to be done by the owner\r\n        uint32 numPendingForcedTransactions;\r\n\r\n        // Cached data for the protocol fee\r\n        ProtocolFeeData protocolFeeData;\r\n\r\n        // Time when the exchange was shutdown\r\n        uint shutdownModeStartTime;\r\n\r\n        // Time when the exchange has entered withdrawal mode\r\n        uint withdrawalModeStartTime;\r\n\r\n        // Last time the protocol fee was withdrawn for a specific token\r\n        mapping (address => uint) protocolFeeLastWithdrawnTime;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title An Implementation of IBlockVerifier.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract BlockVerifier is ReentrancyGuard, IBlockVerifier\r\n{\r\n    struct Circuit\r\n    {\r\n        bool registered;\r\n        bool enabled;\r\n        uint[18] verificationKey;\r\n    }\r\n\r\n    mapping (uint8 => mapping (uint16 => mapping (uint8 => Circuit))) public circuits;\r\n\r\n    constructor() Claimable() {}\r\n\r\n    function registerCircuit(\r\n        uint8    blockType,\r\n        uint16   blockSize,\r\n        uint8    blockVersion,\r\n        uint[18] calldata vk\r\n        )\r\n        external\r\n        override\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        Circuit storage circuit = circuits[blockType][blockSize][blockVersion];\r\n        require(circuit.registered == false, \"ALREADY_REGISTERED\");\r\n\r\n        for (uint i = 0; i < 18; i++) {\r\n            circuit.verificationKey[i] = vk[i];\r\n        }\r\n        circuit.registered = true;\r\n        circuit.enabled = true;\r\n\r\n        emit CircuitRegistered(\r\n            blockType,\r\n            blockSize,\r\n            blockVersion\r\n        );\r\n    }\r\n\r\n    function disableCircuit(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        override\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        Circuit storage circuit = circuits[blockType][blockSize][blockVersion];\r\n        require(circuit.registered == true, \"NOT_REGISTERED\");\r\n        require(circuit.enabled == true, \"ALREADY_DISABLED\");\r\n\r\n        circuit.enabled = false;\r\n\r\n        emit CircuitDisabled(\r\n            blockType,\r\n            blockSize,\r\n            blockVersion\r\n        );\r\n    }\r\n\r\n    function verifyProofs(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        uint[] calldata publicInputs,\r\n        uint[] calldata proofs\r\n        )\r\n        external\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        Circuit storage circuit = circuits[blockType][blockSize][blockVersion];\r\n        require(circuit.registered == true, \"NOT_REGISTERED\");\r\n\r\n        uint[18] storage vk = circuit.verificationKey;\r\n        uint[14] memory _vk = [\r\n            vk[0], vk[1], vk[2], vk[3], vk[4], vk[5], vk[6],\r\n            vk[7], vk[8], vk[9], vk[10], vk[11], vk[12], vk[13]\r\n        ];\r\n        uint[4] memory _vk_gammaABC = [vk[14], vk[15], vk[16], vk[17]];\r\n\r\n        if (publicInputs.length == 1) {\r\n            return Verifier.Verify(_vk, _vk_gammaABC, proofs, publicInputs);\r\n        } else {\r\n            return BatchVerifier.BatchVerify(\r\n                _vk,\r\n                _vk_gammaABC,\r\n                proofs,\r\n                publicInputs,\r\n                publicInputs.length\r\n            );\r\n        }\r\n    }\r\n\r\n    function isCircuitRegistered(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return circuits[blockType][blockSize][blockVersion].registered;\r\n    }\r\n\r\n    function isCircuitEnabled(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return circuits[blockType][blockSize][blockVersion].enabled;\r\n    }\r\n\r\n    function getVerificationKey(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (uint[18] memory)\r\n    {\r\n        return circuits[blockType][blockSize][blockVersion].verificationKey;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"CircuitDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"CircuitRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"circuits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"disableCircuit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"getVerificationKey\",\"outputs\":[{\"internalType\":\"uint256[18]\",\"name\":\"\",\"type\":\"uint256[18]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"isCircuitEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"isCircuitRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"},{\"internalType\":\"uint256[18]\",\"name\":\"vk\",\"type\":\"uint256[18]\"}],\"name\":\"registerCircuit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"publicInputs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"proofs\",\"type\":\"uint256[]\"}],\"name\":\"verifyProofs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BlockVerifier","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://52848616ff8e53784711f8db52d9bd32602a5be602ee0977676d28ab79072740"}]}