{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/zeppelin/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n    * @return the address of the owner.\r\n    */\r\n    function owner() public view returns(address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return true if `msg.sender` is the owner of the contract.\r\n    */\r\n    function isOwner() public view returns(bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/HydroInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface HydroInterface {\r\n    function balances(address) external view returns (uint);\r\n    function allowed(address, address) external view returns (uint);\r\n    function transfer(address _to, uint256 _amount) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function approve(address _spender, uint256 _amount) external returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData)\r\n        external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function authenticate(uint _value, uint _challenge, uint _partnerId) external;\r\n}\r\n\r\n// File: contracts/interfaces/SnowflakeInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface SnowflakeInterface {\r\n    function deposits(uint) external view returns (uint);\r\n    function resolverAllowances(uint, address) external view returns (uint);\r\n\r\n    function identityRegistryAddress() external returns (address);\r\n    function hydroTokenAddress() external returns (address);\r\n    function clientRaindropAddress() external returns (address);\r\n\r\n    function setAddresses(address _identityRegistryAddress, address _hydroTokenAddress) external;\r\n    function setClientRaindropAddress(address _clientRaindropAddress) external;\r\n\r\n    function createIdentityDelegated(\r\n        address recoveryAddress, address associatedAddress, address[] calldata providers, string calldata casedHydroId,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external returns (uint ein);\r\n    function addProvidersFor(\r\n        address approvingAddress, address[] calldata providers, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function removeProvidersFor(\r\n        address approvingAddress, address[] calldata providers, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function upgradeProvidersFor(\r\n        address approvingAddress, address[] calldata newProviders, address[] calldata oldProviders,\r\n        uint8[2] calldata v, bytes32[2] calldata r, bytes32[2] calldata s, uint[2] calldata timestamp\r\n    ) external;\r\n    function addResolver(address resolver, bool isSnowflake, uint withdrawAllowance, bytes calldata extraData) external;\r\n    function addResolverAsProvider(\r\n        uint ein, address resolver, bool isSnowflake, uint withdrawAllowance, bytes calldata extraData\r\n    ) external;\r\n    function addResolverFor(\r\n        address approvingAddress, address resolver, bool isSnowflake, uint withdrawAllowance, bytes calldata extraData,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function changeResolverAllowances(address[] calldata resolvers, uint[] calldata withdrawAllowances) external;\r\n    function changeResolverAllowancesDelegated(\r\n        address approvingAddress, address[] calldata resolvers, uint[] calldata withdrawAllowances,\r\n        uint8 v, bytes32 r, bytes32 s\r\n    ) external;\r\n    function removeResolver(address resolver, bool isSnowflake, bytes calldata extraData) external;\r\n    function removeResolverFor(\r\n        address approvingAddress, address resolver, bool isSnowflake, bytes calldata extraData,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n\r\n    function triggerRecoveryAddressChangeFor(\r\n        address approvingAddress, address newRecoveryAddress, uint8 v, bytes32 r, bytes32 s\r\n    ) external;\r\n\r\n    function transferSnowflakeBalance(uint einTo, uint amount) external;\r\n    function withdrawSnowflakeBalance(address to, uint amount) external;\r\n    function transferSnowflakeBalanceFrom(uint einFrom, uint einTo, uint amount) external;\r\n    function withdrawSnowflakeBalanceFrom(uint einFrom, address to, uint amount) external;\r\n    function transferSnowflakeBalanceFromVia(uint einFrom, address via, uint einTo, uint amount, bytes calldata _bytes)\r\n        external;\r\n    function withdrawSnowflakeBalanceFromVia(uint einFrom, address via, address to, uint amount, bytes calldata _bytes)\r\n        external;\r\n}\r\n\r\n// File: contracts/interfaces/SnowflakeResolverInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface SnowflakeResolverInterface {\r\n    function callOnAddition() external view returns (bool);\r\n    function callOnRemoval() external view returns (bool);\r\n    function onAddition(uint ein, uint allowance, bytes calldata extraData) external returns (bool);\r\n    function onRemoval(uint ein, bytes calldata extraData) external returns (bool);\r\n}\r\n\r\n// File: contracts/SnowflakeResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract SnowflakeResolver is Ownable {\r\n    string public snowflakeName;\r\n    string public snowflakeDescription;\r\n\r\n    address public snowflakeAddress;\r\n\r\n    bool public callOnAddition;\r\n    bool public callOnRemoval;\r\n\r\n    constructor(\r\n        string memory _snowflakeName, string memory _snowflakeDescription,\r\n        address _snowflakeAddress,\r\n        bool _callOnAddition, bool _callOnRemoval\r\n    )\r\n        public\r\n    {\r\n        snowflakeName = _snowflakeName;\r\n        snowflakeDescription = _snowflakeDescription;\r\n\r\n        setSnowflakeAddress(_snowflakeAddress);\r\n\r\n        callOnAddition = _callOnAddition;\r\n        callOnRemoval = _callOnRemoval;\r\n    }\r\n\r\n    modifier senderIsSnowflake() {\r\n        require(msg.sender == snowflakeAddress, \"Did not originate from Snowflake.\");\r\n        _;\r\n    }\r\n\r\n    // this can be overriden to initialize other variables, such as e.g. an ERC20 object to wrap the HYDRO token\r\n    function setSnowflakeAddress(address _snowflakeAddress) public onlyOwner {\r\n        snowflakeAddress = _snowflakeAddress;\r\n    }\r\n\r\n    // if callOnAddition is true, onAddition is called every time a user adds the contract as a resolver\r\n    // this implementation **must** use the senderIsSnowflake modifier\r\n    // returning false will disallow users from adding the contract as a resolver\r\n    function onAddition(uint ein, uint allowance, bytes memory extraData) public returns (bool);\r\n\r\n    // if callOnRemoval is true, onRemoval is called every time a user removes the contract as a resolver\r\n    // this function **must** use the senderIsSnowflake modifier\r\n    // returning false soft prevents users from removing the contract as a resolver\r\n    // however, note that they can force remove the resolver, bypassing onRemoval\r\n    function onRemoval(uint ein, bytes memory extraData) public returns (bool);\r\n\r\n    function transferHydroBalanceTo(uint einTo, uint amount) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(hydro.approveAndCall(snowflakeAddress, amount, abi.encode(einTo)), \"Unsuccessful approveAndCall.\");\r\n    }\r\n\r\n    function withdrawHydroBalanceTo(address to, uint amount) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(hydro.transfer(to, amount), \"Unsuccessful transfer.\");\r\n    }\r\n\r\n    function transferHydroBalanceToVia(address via, uint einTo, uint amount, bytes memory snowflakeCallBytes) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(\r\n            hydro.approveAndCall(\r\n                snowflakeAddress, amount, abi.encode(true, address(this), via, einTo, snowflakeCallBytes)\r\n            ),\r\n            \"Unsuccessful approveAndCall.\"\r\n        );\r\n    }\r\n\r\n    function withdrawHydroBalanceToVia(address via, address to, uint amount, bytes memory snowflakeCallBytes) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(\r\n            hydro.approveAndCall(\r\n                snowflakeAddress, amount, abi.encode(false, address(this), via, to, snowflakeCallBytes)\r\n            ),\r\n            \"Unsuccessful approveAndCall.\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IdentityRegistryInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface IdentityRegistryInterface {\r\n    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        external pure returns (bool);\r\n\r\n    // Identity View Functions /////////////////////////////////////////////////////////////////////////////////////////\r\n    function identityExists(uint ein) external view returns (bool);\r\n    function hasIdentity(address _address) external view returns (bool);\r\n    function getEIN(address _address) external view returns (uint ein);\r\n    function isAssociatedAddressFor(uint ein, address _address) external view returns (bool);\r\n    function isProviderFor(uint ein, address provider) external view returns (bool);\r\n    function isResolverFor(uint ein, address resolver) external view returns (bool);\r\n    function getIdentity(uint ein) external view returns (\r\n        address recoveryAddress,\r\n        address[] memory associatedAddresses, address[] memory providers, address[] memory resolvers\r\n    );\r\n\r\n    // Identity Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n    function createIdentity(address recoveryAddress, address[] calldata providers, address[] calldata resolvers)\r\n        external returns (uint ein);\r\n    function createIdentityDelegated(\r\n        address recoveryAddress, address associatedAddress, address[] calldata providers, address[] calldata resolvers,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external returns (uint ein);\r\n    function addAssociatedAddress(\r\n        address approvingAddress, address addressToAdd, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function addAssociatedAddressDelegated(\r\n        address approvingAddress, address addressToAdd,\r\n        uint8[2] calldata v, bytes32[2] calldata r, bytes32[2] calldata s, uint[2] calldata timestamp\r\n    ) external;\r\n    function removeAssociatedAddress() external;\r\n    function removeAssociatedAddressDelegated(address addressToRemove, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        external;\r\n    function addProviders(address[] calldata providers) external;\r\n    function addProvidersFor(uint ein, address[] calldata providers) external;\r\n    function removeProviders(address[] calldata providers) external;\r\n    function removeProvidersFor(uint ein, address[] calldata providers) external;\r\n    function addResolvers(address[] calldata resolvers) external;\r\n    function addResolversFor(uint ein, address[] calldata resolvers) external;\r\n    function removeResolvers(address[] calldata resolvers) external;\r\n    function removeResolversFor(uint ein, address[] calldata resolvers) external;\r\n\r\n    // Recovery Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n    function triggerRecoveryAddressChange(address newRecoveryAddress) external;\r\n    function triggerRecoveryAddressChangeFor(uint ein, address newRecoveryAddress) external;\r\n    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        external;\r\n    function triggerDestruction(\r\n        uint ein, address[] calldata firstChunk, address[] calldata lastChunk, bool resetResolvers\r\n    ) external;\r\n}\r\n\r\n// File: contracts/zeppelin/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/resolvers/Charity.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n contract Charity is SnowflakeResolver{\r\n     using SafeMath for uint256;\r\n     \r\n     //states for project phases\r\n     \r\n     enum State{\r\n         Approved,\r\n         Awaiting,\r\n         Disabled\r\n     }\r\n     \r\n     //State variables\r\n     \r\n     \r\n     //max amount to be raised,refunds excess back to donators\r\n     uint256 public charityGoal;\r\n     \r\n     \r\n     //The current donations for the Charity\r\n    uint256 public currentBalance;\r\n    \r\n    //deadline set for the Charity\r\n    uint public raiseBy;\r\n    \r\n    //title for the Charity\r\n    string public title;\r\n    \r\n    //description for the Charity\r\n    string public description;\r\n    \r\n    //snowflake address\r\n    address _snowflakeAddress;\r\n    \r\n    //overlord address\r\n    address public overlord;\r\n    \r\n    //the only address that can withdraw the funds...should be set by the charity owner\r\n    address public charityOwnerAddress;\r\n    \r\n    \r\n    \r\n    address _creatorAddress;\r\n     \r\n     // initialize on create\r\n     State public state = State.Awaiting;\r\n     \r\n     //keeps track of all contributions by address\r\n     mapping(uint => uint ) public contributions;\r\n     \r\n     //keeps track of all registered participants\r\n     mapping(uint=>bool) public aParticipant;\r\n     \r\n     //emitted when funding is received\r\n     event fundingReceived(address contributor,uint amount,uint currentTotal);\r\n     \r\n     //emitted when donations are paid out to the creator\r\n     event creatorPaid(address recipient);\r\n     \r\n     //emitted when the charity is approved\r\n     event charityApproved(uint timeApproved);\r\n     \r\n     //emitted when the charity is disabled\r\n     event charityDisabled(uint timeDisabled); \r\n     \r\n     \r\n     \r\n     \r\n     //confirm current State\r\n     \r\n     modifier inState(State _state){\r\n         require(state==_state,\"this project has not been approved or has been disabled\");\r\n         _;\r\n     }\r\n     \r\n\r\n     \r\n     //checks if the ein has this contract as a resolver\r\n     modifier isParticipant(address _target){\r\n         uint _ein=checkEIN(_target);\r\n    require(aParticipant[_ein]==true, 'this EIN has not registered as a participant');\r\n    _;\r\n}\r\n\r\n     //checks if target has an ein\r\n     modifier HasEIN(address target){\r\n    require(checkforReg(target)==true);\r\n    _;\r\n}\r\n\r\n\r\n//double check that this project has not expired\r\nmodifier notExpired{\r\n    require(checkIfCharityExpired()==false,\"Project has expired\");\r\n    _;\r\n}\r\n\r\nmodifier GoalNotReached{\r\n    require (checkIfFundingComplete()==false,\"Goal has been reached\");\r\n    _;\r\n}\r\n\r\nmodifier onlyOverlord{\r\n    require (msg.sender==overlord,\"You are not the charity overlord\");\r\n    _;\r\n}\r\n\r\nmodifier onlyCharityOwner{\r\n    require (msg.sender==charityOwnerAddress,\"You are not the charity owner\");\r\n    _;\r\n}\r\n    constructor (\r\n         address snowflakeAddress,\r\n         string memory projectTitle,\r\n         string memory projectDesc,\r\n         uint charityEnd,\r\n         uint goalAmount,\r\n         address _owner,\r\n         address _overlord) SnowflakeResolver(projectTitle, projectDesc, snowflakeAddress, true, false) public {\r\n             snowflakeAddress=_snowflakeAddress;\r\n             charityOwnerAddress=_owner;\r\n             title= projectTitle;\r\n             description= projectDesc;\r\n             charityGoal = convertToRealAmount(goalAmount);\r\n            raiseBy= now+(charityEnd)*(1 days);\r\n             currentBalance = 0;\r\n             overlord=_overlord;\r\n         }\r\n         \r\n         function checkEIN(address _address) internal HasEIN(_address) returns(uint){\r\n        SnowflakeInterface snowfl = SnowflakeInterface(snowflakeAddress);\r\n    IdentityRegistryInterface idRegistry= IdentityRegistryInterface(snowfl.identityRegistryAddress());\r\n       uint Ein=idRegistry.getEIN(_address);\r\n       return Ein;\r\n   }\r\n       function convertToRealAmount(uint256 firstAmount) internal pure returns(uint){\r\n          uint256 finalAmount= firstAmount.mul(1000000000000000000);\r\n          return finalAmount;\r\n       }\r\n       \r\n       //approve a charity so it can start receiving donations\r\n       function approveCharity() public onlyOverlord {\r\n           state=State.Approved;\r\n           emit charityApproved(now);\r\n       }\r\n\r\n        //disable this charity so it can stop receive funding\r\n       function disableCharity() public onlyOverlord {\r\n           state=State.Disabled;\r\n           emit charityDisabled(now);\r\n           \r\n       }\r\n       \r\n         function checkforReg(address _target) public  returns(bool){\r\n    SnowflakeInterface snowfl = SnowflakeInterface(snowflakeAddress);\r\n    IdentityRegistryInterface idRegistry= IdentityRegistryInterface(snowfl.identityRegistryAddress());\r\n    _target=msg.sender;\r\n    bool hasId=idRegistry.hasIdentity(msg.sender);\r\n    return hasId;\r\n}\r\n\r\n //called to register any new actor in the system\r\n//makes the ein to be a participant in the system\r\nfunction onAddition(uint ein,uint /**allocation**/,bytes memory) public senderIsSnowflake() returns (bool){\r\n     aParticipant[ein]=true;\r\n    return true;\r\n   \r\n}\r\nfunction onRemoval(uint, bytes memory) public senderIsSnowflake() returns (bool) {}\r\n \r\n         //main withdraw function that can be called anytime will send all funds from the contract\r\n     function withdrawContributions(address to) public onlyCharityOwner {\r\n        SnowflakeInterface snowfl = SnowflakeInterface(snowflakeAddress);\r\n        HydroInterface hydro = HydroInterface(snowfl.hydroTokenAddress());\r\n        withdrawHydroBalanceTo(to, hydro.balanceOf(address(this)));\r\n        currentBalance=currentBalance.sub(hydro.balanceOf(address(this)));\r\n        emit creatorPaid(to);\r\n    }\r\n     \r\n     //function to allow registered participants contribute to a charity\r\n      function contribute(uint _amount) public inState(State.Approved) notExpired() isParticipant(msg.sender) {\r\n          require(checkEIN(msg.sender) !=checkEIN(charityOwnerAddress),\"you cannot donate to your own Charity\");\r\n          uint _realAmount= convertToRealAmount(_amount);\r\n            SnowflakeInterface snowfl = SnowflakeInterface(snowflakeAddress);\r\n            uint ein=checkEIN(msg.sender);\r\n             snowfl.withdrawSnowflakeBalanceFrom(ein, address(this), _realAmount);\r\n           contributions[ein]=contributions[ein].add(convertToRealAmount(_amount));\r\n           currentBalance=currentBalance.add(convertToRealAmount(_amount));\r\n           \r\n           emit fundingReceived(msg.sender,_amount,currentBalance);\r\n          \r\n           }   \r\n           \r\n    \r\n   // check if the the charity has reached its goal    \r\n     function checkIfFundingComplete() public view returns(bool){\r\n         if (currentBalance>=charityGoal){\r\n            return (true);\r\n         }\r\n         else{\r\n return false;\r\n     }\r\n     }\r\n     \r\n    \r\n     \r\n     //checks if the charity has expired\r\n     function checkIfCharityExpired() public view returns(bool){\r\n         if(now>=raiseBy){\r\n             return(true);\r\n\r\n         }\r\n     }\r\n         \r\n         //check the remaining amount before project reaches its goal\r\n         //should be run when the project has not reached its goal\r\n         function checkRemainingAmount() public view notExpired() returns(uint)  {\r\n             uint _Amount= charityGoal.sub(currentBalance);\r\n            \r\n             return(_Amount);\r\n         }\r\n         \r\n         //check remaining time before project expiration\r\n         //should be called when the project has not expired\r\n             function checkRemainingTime() public view  returns(uint)  {\r\n                 if(now>=raiseBy){\r\n             return 0;\r\n                 }\r\n                 else{\r\n                     return raiseBy;\r\n         }}\r\n         \r\n         function checkState() public view returns(State){\r\n             return state;\r\n         }\r\n       \r\n       \r\n }\r\n\r\n// File: contracts/resolvers/CharityFactory.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract charityFactory {\r\naddress snowflake;\r\naddress public globalOverlord;\r\n\r\nCharity[] public charities;\r\n\r\nevent newCharityCreated(\r\n    address indexed _deployedAddress\r\n);\r\n\r\nmodifier onlyOverlord{\r\n    require (msg.sender==globalOverlord,\"You are not the OVERLORD\");\r\n    _;\r\n}\r\n\r\nconstructor(address _snowflake) public{\r\n    snowflake=_snowflake;\r\n    \r\n    //sets the deployer of the factory contract as the overlord\r\n    globalOverlord=msg.sender;\r\n}\r\n\r\n//creates a new charity instance\r\nfunction createNewCharity(string memory _name,string memory _description,uint _days,uint _maxAmount,address _ownerAddress) public returns(address newContract){\r\n       Charity c = new Charity(snowflake,_name,_description,_days,_maxAmount,_ownerAddress,globalOverlord);\r\n       charities.push(c);\r\n       emit newCharityCreated(address(c));\r\n        return address(c);\r\n    //returns the new election contract address\r\n\r\n}\r\n\r\n //function to transfer the overlord position to another address\r\n //can only be called by the existing overlord\r\n     function transferOverlordAuthority(address _newOverlord) public onlyOverlord {\r\n        globalOverlord=_newOverlord;\r\n     }\r\n     \r\n     //returns the addresses of all charities that have all been deployed\r\n function returnAllCharities() external view returns(Charity[] memory){\r\n        return charities;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_snowflake\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_deployedAddress\",\"type\":\"address\"}],\"name\":\"newCharityCreated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"charities\",\"outputs\":[{\"internalType\":\"contract Charity\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"createNewCharity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalOverlord\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnAllCharities\",\"outputs\":[{\"internalType\":\"contract Charity[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOverlord\",\"type\":\"address\"}],\"name\":\"transferOverlordAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"charityFactory","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000032c927d1d1df373c3fae1dc32338570e85f1d4e5","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://90f143752e656a1b1b57173dbe52daea1a3de3470bf0a79c8dd7f93877c58c6f"}]}