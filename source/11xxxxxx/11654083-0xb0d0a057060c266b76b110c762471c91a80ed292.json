{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/FeePayerPoolPartyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './FeePayerPoolParty.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '../../oracle/interfaces/StoreInterface.sol';\\n\\nlibrary FeePayerPoolPartyLib {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using SafeERC20 for IERC20;\\n\\n  event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\\n  event FinalFeesPaid(uint256 indexed amount);\\n\\n  function payRegularFees(\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    StoreInterface store,\\n    uint256 time,\\n    FixedPoint.Unsigned memory collateralPool\\n  ) external returns (FixedPoint.Unsigned memory totalPaid) {\\n    if (collateralPool.isEqual(0)) {\\n      feePayerData.lastPaymentTime = time;\\n      return totalPaid;\\n    }\\n\\n    if (feePayerData.lastPaymentTime == time) {\\n      return totalPaid;\\n    }\\n\\n    FixedPoint.Unsigned memory regularFee;\\n    FixedPoint.Unsigned memory latePenalty;\\n\\n    (regularFee, latePenalty) = store.computeRegularFee(\\n      feePayerData.lastPaymentTime,\\n      time,\\n      collateralPool\\n    );\\n    feePayerData.lastPaymentTime = time;\\n\\n    totalPaid = regularFee.add(latePenalty);\\n    if (totalPaid.isEqual(0)) {\\n      return totalPaid;\\n    }\\n\\n    if (totalPaid.isGreaterThan(collateralPool)) {\\n      FixedPoint.Unsigned memory deficit = totalPaid.sub(collateralPool);\\n      FixedPoint.Unsigned memory latePenaltyReduction =\\n        FixedPoint.min(latePenalty, deficit);\\n      latePenalty = latePenalty.sub(latePenaltyReduction);\\n      deficit = deficit.sub(latePenaltyReduction);\\n      regularFee = regularFee.sub(FixedPoint.min(regularFee, deficit));\\n      totalPaid = collateralPool;\\n    }\\n\\n    emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\\n\\n    feePayerData.cumulativeFeeMultiplier._adjustCumulativeFeeMultiplier(\\n      totalPaid,\\n      collateralPool\\n    );\\n\\n    if (regularFee.isGreaterThan(0)) {\\n      feePayerData.collateralCurrency.safeIncreaseAllowance(\\n        address(store),\\n        regularFee.rawValue\\n      );\\n      store.payOracleFeesErc20(\\n        address(feePayerData.collateralCurrency),\\n        regularFee\\n      );\\n    }\\n\\n    if (latePenalty.isGreaterThan(0)) {\\n      feePayerData.collateralCurrency.safeTransfer(\\n        msg.sender,\\n        latePenalty.rawValue\\n      );\\n    }\\n    return totalPaid;\\n  }\\n\\n  function payFinalFees(\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    StoreInterface store,\\n    address payer,\\n    FixedPoint.Unsigned memory amount\\n  ) external {\\n    if (amount.isEqual(0)) {\\n      return;\\n    }\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      payer,\\n      address(this),\\n      amount.rawValue\\n    );\\n\\n    emit FinalFeesPaid(amount.rawValue);\\n\\n    feePayerData.collateralCurrency.safeIncreaseAllowance(\\n      address(store),\\n      amount.rawValue\\n    );\\n    store.payOracleFeesErc20(address(feePayerData.collateralCurrency), amount);\\n  }\\n\\n  function getFeeAdjustedCollateral(\\n    FixedPoint.Unsigned memory rawCollateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external pure returns (FixedPoint.Unsigned memory collateral) {\\n    return rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n  }\\n\\n  function convertToRawCollateral(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external pure returns (FixedPoint.Unsigned memory rawCollateral) {\\n    return collateral._convertToRawCollateral(cumulativeFeeMultiplier);\\n  }\\n\\n  function removeCollateral(\\n    FixedPoint.Unsigned storage rawCollateral,\\n    FixedPoint.Unsigned memory collateralToRemove,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external returns (FixedPoint.Unsigned memory removedCollateral) {\\n    FixedPoint.Unsigned memory initialBalance =\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n    FixedPoint.Unsigned memory adjustedCollateral =\\n      collateralToRemove._convertToRawCollateral(cumulativeFeeMultiplier);\\n    rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\\n    removedCollateral = initialBalance.sub(\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\\n    );\\n  }\\n\\n  function addCollateral(\\n    FixedPoint.Unsigned storage rawCollateral,\\n    FixedPoint.Unsigned memory collateralToAdd,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external returns (FixedPoint.Unsigned memory addedCollateral) {\\n    FixedPoint.Unsigned memory initialBalance =\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n    FixedPoint.Unsigned memory adjustedCollateral =\\n      collateralToAdd._convertToRawCollateral(cumulativeFeeMultiplier);\\n    rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\\n    addedCollateral = rawCollateral\\n      ._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\\n      .sub(initialBalance);\\n  }\\n\\n  function _adjustCumulativeFeeMultiplier(\\n    FixedPoint.Unsigned storage cumulativeFeeMultiplier,\\n    FixedPoint.Unsigned memory amount,\\n    FixedPoint.Unsigned memory currentPfc\\n  ) internal {\\n    FixedPoint.Unsigned memory effectiveFee = amount.divCeil(currentPfc);\\n    cumulativeFeeMultiplier.rawValue = cumulativeFeeMultiplier\\n      .mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee))\\n      .rawValue;\\n  }\\n\\n  function _getFeeAdjustedCollateral(\\n    FixedPoint.Unsigned memory rawCollateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) internal pure returns (FixedPoint.Unsigned memory collateral) {\\n    return rawCollateral.mul(cumulativeFeeMultiplier);\\n  }\\n\\n  function _convertToRawCollateral(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) internal pure returns (FixedPoint.Unsigned memory rawCollateral) {\\n    return collateral.div(cumulativeFeeMultiplier);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/math/SignedSafeMath.sol';\\n\\nlibrary FixedPoint {\\n  using SafeMath for uint256;\\n  using SignedSafeMath for int256;\\n\\n  uint256 private constant FP_SCALING_FACTOR = 10**18;\\n\\n  struct Unsigned {\\n    uint256 rawValue;\\n  }\\n\\n  function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.mul(FP_SCALING_FACTOR));\\n  }\\n\\n  function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  function isGreaterThan(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThan(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isGreaterThan(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue >= b.rawValue;\\n  }\\n\\n  function isLessThan(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  function isLessThan(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isLessThan(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue < b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isLessThanOrEqual(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue <= b.rawValue;\\n  }\\n\\n  function min(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  function max(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  function add(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.add(b.rawValue));\\n  }\\n\\n  function add(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return add(a, fromUnscaledUint(b));\\n  }\\n\\n  function sub(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  function sub(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return sub(a, fromUnscaledUint(b));\\n  }\\n\\n  function sub(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return sub(fromUnscaledUint(a), b);\\n  }\\n\\n  function mul(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\n  }\\n\\n  function mul(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  function mulCeil(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    uint256 mulRaw = a.rawValue.mul(b.rawValue);\\n    uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\n    uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\n    if (mod != 0) {\\n      return Unsigned(mulFloor.add(1));\\n    } else {\\n      return Unsigned(mulFloor);\\n    }\\n  }\\n\\n  function mulCeil(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  function div(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  function div(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.div(b));\\n  }\\n\\n  function div(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return div(fromUnscaledUint(a), b);\\n  }\\n\\n  function divCeil(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\n    uint256 divFloor = aScaled.div(b.rawValue);\\n    uint256 mod = aScaled.mod(b.rawValue);\\n    if (mod != 0) {\\n      return Unsigned(divFloor.add(1));\\n    } else {\\n      return Unsigned(divFloor);\\n    }\\n  }\\n\\n  function divCeil(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return divCeil(a, fromUnscaledUint(b));\\n  }\\n\\n  function pow(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory output)\\n  {\\n    output = fromUnscaledUint(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n\\n  int256 private constant SFP_SCALING_FACTOR = 10**18;\\n\\n  struct Signed {\\n    int256 rawValue;\\n  }\\n\\n  function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\n    require(a.rawValue >= 0, 'Negative value provided');\\n    return Unsigned(uint256(a.rawValue));\\n  }\\n\\n  function fromUnsigned(Unsigned memory a)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    require(a.rawValue <= uint256(type(int256).max), 'Unsigned too large');\\n    return Signed(int256(a.rawValue));\\n  }\\n\\n  function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\n    return Signed(a.mul(SFP_SCALING_FACTOR));\\n  }\\n\\n  function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  function isGreaterThan(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThan(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isGreaterThan(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue >= b.rawValue;\\n  }\\n\\n  function isLessThan(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue < fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue < b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isLessThanOrEqual(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue <= b.rawValue;\\n  }\\n\\n  function min(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  function max(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  function add(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.add(b.rawValue));\\n  }\\n\\n  function add(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return add(a, fromUnscaledInt(b));\\n  }\\n\\n  function sub(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  function sub(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return sub(a, fromUnscaledInt(b));\\n  }\\n\\n  function sub(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return sub(fromUnscaledInt(a), b);\\n  }\\n\\n  function mul(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\n  }\\n\\n  function mul(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  function mulAwayFromZero(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    int256 mulRaw = a.rawValue.mul(b.rawValue);\\n    int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\n\\n    int256 mod = mulRaw % SFP_SCALING_FACTOR;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(mulTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(mulTowardsZero);\\n    }\\n  }\\n\\n  function mulAwayFromZero(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  function div(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  function div(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.div(b));\\n  }\\n\\n  function div(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return div(fromUnscaledInt(a), b);\\n  }\\n\\n  function divAwayFromZero(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\n    int256 divTowardsZero = aScaled.div(b.rawValue);\\n\\n    int256 mod = aScaled % b.rawValue;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(divTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(divTowardsZero);\\n    }\\n  }\\n\\n  function divAwayFromZero(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return divAwayFromZero(a, fromUnscaledInt(b));\\n  }\\n\\n  function pow(Signed memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Signed memory output)\\n  {\\n    output = fromUnscaledInt(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/FeePayerPoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport '../../common/implementation/Lockable.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './FeePayerPoolPartyLib.sol';\\nimport '../../common/implementation/Testable.sol';\\n\\nimport '../../oracle/interfaces/StoreInterface.sol';\\nimport '../../oracle/interfaces/FinderInterface.sol';\\nimport '../../oracle/interfaces/AdministrateeInterface.sol';\\nimport '../../oracle/implementation/Constants.sol';\\n\\nabstract contract FeePayerPoolParty is\\n  AdministrateeInterface,\\n  Testable,\\n  Lockable\\n{\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FeePayerData;\\n  using SafeERC20 for IERC20;\\n\\n  struct FeePayerData {\\n    IERC20 collateralCurrency;\\n    FinderInterface finder;\\n    uint256 lastPaymentTime;\\n    FixedPoint.Unsigned cumulativeFeeMultiplier;\\n  }\\n\\n  FeePayerData public feePayerData;\\n\\n  event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\\n  event FinalFeesPaid(uint256 indexed amount);\\n\\n  modifier fees {\\n    payRegularFees();\\n    _;\\n  }\\n  modifier onlyThisContract {\\n    require(msg.sender == address(this), 'Caller is not this contract');\\n    _;\\n  }\\n\\n  constructor(\\n    address _collateralAddress,\\n    address _finderAddress,\\n    address _timerAddress\\n  ) public Testable(_timerAddress) {\\n    feePayerData.collateralCurrency = IERC20(_collateralAddress);\\n    feePayerData.finder = FinderInterface(_finderAddress);\\n    feePayerData.lastPaymentTime = getCurrentTime();\\n    feePayerData.cumulativeFeeMultiplier = FixedPoint.fromUnscaledUint(1);\\n  }\\n\\n  function payRegularFees()\\n    public\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory totalPaid)\\n  {\\n    StoreInterface store = _getStore();\\n    uint256 time = getCurrentTime();\\n    FixedPoint.Unsigned memory collateralPool = _pfc();\\n    totalPaid = feePayerData.payRegularFees(store, time, collateralPool);\\n    return totalPaid;\\n  }\\n\\n  function payFinalFees(address payer, FixedPoint.Unsigned memory amount)\\n    external\\n    onlyThisContract\\n  {\\n    _payFinalFees(payer, amount);\\n  }\\n\\n  function pfc()\\n    public\\n    view\\n    override\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return _pfc();\\n  }\\n\\n  function collateralCurrency()\\n    public\\n    view\\n    nonReentrantView()\\n    returns (IERC20)\\n  {\\n    return feePayerData.collateralCurrency;\\n  }\\n\\n  function _payFinalFees(address payer, FixedPoint.Unsigned memory amount)\\n    internal\\n  {\\n    StoreInterface store = _getStore();\\n    feePayerData.payFinalFees(store, payer, amount);\\n  }\\n\\n  function _pfc() internal view virtual returns (FixedPoint.Unsigned memory);\\n\\n  function _getStore() internal view returns (StoreInterface) {\\n    return\\n      StoreInterface(\\n        feePayerData.finder.getImplementationAddress(OracleInterfaces.Store)\\n      );\\n  }\\n\\n  function _computeFinalFees()\\n    internal\\n    view\\n    returns (FixedPoint.Unsigned memory finalFees)\\n  {\\n    StoreInterface store = _getStore();\\n    return store.computeFinalFee(address(feePayerData.collateralCurrency));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport './IERC20.sol';\\nimport '../../math/SafeMath.sol';\\nimport '../../utils/Address.sol';\\n\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n    );\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, value)\\n    );\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance =\\n      token.allowance(address(this), spender).sub(\\n        value,\\n        'SafeERC20: decreased allowance below zero'\\n      );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    bytes memory returndata =\\n      address(token).functionCall(data, 'SafeERC20: low-level call failed');\\n    if (returndata.length > 0) {\\n      require(\\n        abi.decode(returndata, (bool)),\\n        'SafeERC20: ERC20 operation did not succeed'\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/StoreInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\n\\ninterface StoreInterface {\\n  function payOracleFees() external payable;\\n\\n  function payOracleFeesErc20(\\n    address erc20Address,\\n    FixedPoint.Unsigned calldata amount\\n  ) external;\\n\\n  function computeRegularFee(\\n    uint256 startTime,\\n    uint256 endTime,\\n    FixedPoint.Unsigned calldata pfc\\n  )\\n    external\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory regularFee,\\n      FixedPoint.Unsigned memory latePenalty\\n    );\\n\\n  function computeFinalFee(address currency)\\n    external\\n    view\\n    returns (FixedPoint.Unsigned memory);\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SignedSafeMath {\\n  int256 private constant _INT256_MIN = -2**255;\\n\\n  function mul(int256 a, int256 b) internal pure returns (int256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    require(\\n      !(a == -1 && b == _INT256_MIN),\\n      'SignedSafeMath: multiplication overflow'\\n    );\\n\\n    int256 c = a * b;\\n    require(c / a == b, 'SignedSafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(int256 a, int256 b) internal pure returns (int256) {\\n    require(b != 0, 'SignedSafeMath: division by zero');\\n    require(\\n      !(b == -1 && a == _INT256_MIN),\\n      'SignedSafeMath: division overflow'\\n    );\\n\\n    int256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function sub(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a - b;\\n    require(\\n      (b >= 0 && c <= a) || (b < 0 && c > a),\\n      'SignedSafeMath: subtraction overflow'\\n    );\\n\\n    return c;\\n  }\\n\\n  function add(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a + b;\\n    require(\\n      (b >= 0 && c >= a) || (b < 0 && c < a),\\n      'SignedSafeMath: addition overflow'\\n    );\\n\\n    return c;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ncontract Lockable {\\n  bool private _notEntered;\\n\\n  constructor() internal {\\n    _notEntered = true;\\n  }\\n\\n  modifier nonReentrant() {\\n    _preEntranceCheck();\\n    _preEntranceSet();\\n    _;\\n    _postEntranceReset();\\n  }\\n\\n  modifier nonReentrantView() {\\n    _preEntranceCheck();\\n    _;\\n  }\\n\\n  function _preEntranceCheck() internal view {\\n    require(_notEntered, 'ReentrancyGuard: reentrant call');\\n  }\\n\\n  function _preEntranceSet() internal {\\n    _notEntered = false;\\n  }\\n\\n  function _postEntranceReset() internal {\\n    _notEntered = true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Testable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport './Timer.sol';\\n\\nabstract contract Testable {\\n  address public timerAddress;\\n\\n  constructor(address _timerAddress) internal {\\n    timerAddress = _timerAddress;\\n  }\\n\\n  modifier onlyIfTest {\\n    require(timerAddress != address(0x0));\\n    _;\\n  }\\n\\n  function setCurrentTime(uint256 time) external onlyIfTest {\\n    Timer(timerAddress).setCurrentTime(time);\\n  }\\n\\n  function getCurrentTime() public view returns (uint256) {\\n    if (timerAddress != address(0x0)) {\\n      return Timer(timerAddress).getCurrentTime();\\n    } else {\\n      return now;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/FinderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ninterface FinderInterface {\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/AdministrateeInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\n\\ninterface AdministrateeInterface {\\n  function emergencyShutdown() external;\\n\\n  function remargin() external;\\n\\n  function pfc() external view returns (FixedPoint.Unsigned memory);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nlibrary OracleInterfaces {\\n  bytes32 public constant Oracle = 'Oracle';\\n  bytes32 public constant IdentifierWhitelist = 'IdentifierWhitelist';\\n  bytes32 public constant Store = 'Store';\\n  bytes32 public constant FinancialContractsAdmin = 'FinancialContractsAdmin';\\n  bytes32 public constant Registry = 'Registry';\\n  bytes32 public constant CollateralWhitelist = 'CollateralWhitelist';\\n  bytes32 public constant OptimisticOracle = 'OptimisticOracle';\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.8.0;\\n\\nlibrary Address {\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(\\n      success,\\n      'Address: unable to send value, recipient may have reverted'\\n    );\\n  }\\n\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return functionCall(target, data, 'Address: low-level call failed');\\n  }\\n\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        'Address: low-level call with value failed'\\n      );\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance >= value,\\n      'Address: insufficient balance for call'\\n    );\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(target, data, 'Address: low-level static call failed');\\n  }\\n\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), 'Address: static call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      if (returndata.length > 0) {\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Timer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ncontract Timer {\\n  uint256 private currentTime;\\n\\n  constructor() public {\\n    currentTime = now;\\n  }\\n\\n  function setCurrentTime(uint256 time) external {\\n    currentTime = time;\\n  }\\n\\n  function getCurrentTime() public view returns (uint256) {\\n    return currentTime;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FinalFeesPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"regularFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lateFee\",\"type\":\"uint256\"}],\"name\":\"RegularFeesPaid\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"collateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"cumulativeFeeMultiplier\",\"type\":\"tuple\"}],\"name\":\"convertToRawCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"rawCollateral\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"rawCollateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"cumulativeFeeMultiplier\",\"type\":\"tuple\"}],\"name\":\"getFeeAdjustedCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"collateral\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"FeePayerPoolPartyLib","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}