{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOAssetHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nlibrary ACOAssetHelper {\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get if the address is for Ethereum (0x0).\\r\\n     * @param _address Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address _address) internal pure returns(bool) {\\r\\n        return _address == address(0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to approve ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param spender Authorized address.\\r\\n     * @param amount Amount to authorize.\\r\\n     */\\r\\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"approve\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"transfer\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to call transferFrom on ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param sender Address of the sender.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"transferFrom\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset symbol.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset symbol.\\r\\n     */\\r\\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n            require(success, \\\"symbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset decimals.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset decimals.\\r\\n     */\\r\\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\\r\\n        if (_isEther(asset)) {\\r\\n            return uint8(18);\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n            require(success, \\\"decimals\\\");\\r\\n            return abi.decode(returndata, (uint8));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to the asset name.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset name.\\r\\n     */\\r\\n    function _getAssetName(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"Ethereum\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n            require(success, \\\"name\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset balance of an account.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param account Address of the account.\\r\\n     * @return The account balance.\\r\\n     */\\r\\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return account.balance;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\\r\\n            require(success, \\\"balanceOf\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset allowance between two addresses.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @return The owner allowance for the spender.\\r\\n     */\\r\\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\\r\\n            require(success, \\\"allowance\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer an asset. \\r\\n     * @param asset Address of the asset to be transferred.\\r\\n     * @param to Address of the destination.\\r\\n     * @param amount The amount to be transferred.\\r\\n     */\\r\\n    function _transferAsset(address asset, address to, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            (bool success,) = to.call{value:amount}(new bytes(0));\\r\\n            require(success, \\\"send\\\");\\r\\n        } else {\\r\\n            _callTransferERC20(asset, to, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to receive an asset. \\r\\n     * @param asset Address of the asset to be received.\\r\\n     * @param amount The amount to be received.\\r\\n     */\\r\\n    function _receiveAsset(address asset, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            require(msg.value == amount, \\\"Invalid ETH amount\\\");\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"No payable\\\");\\r\\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @param amount Amount to check allowance.\\r\\n     */\\r\\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\\r\\n        if (_getAssetAllowance(asset, owner, spender) \\u003c amount) {\\r\\n            _callApproveERC20(asset, spender, MAX_UINT);\\r\\n        }\\r\\n    }\\r\\n}\"},\"ACOBuyer.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./ACOAssetHelper.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IACOPool2.sol\\\";\\r\\nimport \\\"./IACOFactory.sol\\\";\\r\\nimport \\\"./IChiToken.sol\\\";\\r\\n\\r\\ncontract ACOBuyer {\\r\\n    \\r\\n    IACOFactory immutable public acoFactory;\\r\\n\\tIChiToken immutable public chiToken;\\r\\n\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"ACOBuyer::Reentry\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true;\\r\\n    }\\r\\n    \\r\\n    modifier discountCHI {\\r\\n        uint256 gasStart = gasleft();\\r\\n        _;\\r\\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\\r\\n        chiToken.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\\r\\n    }\\r\\n    \\r\\n    constructor(address _acoFactory, address _chiToken) public {\\r\\n        acoFactory = IACOFactory(_acoFactory);\\r\\n\\t    chiToken = IChiToken(_chiToken);\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        require(tx.origin != msg.sender, \\\"ACOBuyer:: Not allowed\\\");\\r\\n    }\\r\\n\\r\\n    function buy(\\r\\n        address acoToken, \\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        address[] calldata acoPools,\\r\\n        uint256[] calldata amounts,\\r\\n        uint256[] calldata restrictions\\r\\n    ) \\r\\n        nonReentrant \\r\\n        external \\r\\n        payable\\r\\n    {\\r\\n        _buy(acoToken, to, deadline, acoPools, amounts, restrictions);\\r\\n    }\\r\\n    \\r\\n    function buyWithGasToken(\\r\\n        address acoToken, \\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        address[] calldata acoPools,\\r\\n        uint256[] calldata amounts,\\r\\n        uint256[] calldata restrictions\\r\\n    ) \\r\\n        discountCHI\\r\\n        nonReentrant \\r\\n        external \\r\\n        payable\\r\\n    {\\r\\n        _buy(acoToken, to, deadline, acoPools, amounts, restrictions);\\r\\n    }\\r\\n    \\r\\n    function _buy(\\r\\n        address acoToken, \\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        address[] memory acoPools,\\r\\n        uint256[] memory acoAmounts,\\r\\n        uint256[] memory restrictions\\r\\n    ) internal {\\r\\n        require(acoToken != address(0), \\\"ACOBuyer::buy: Invalid ACO token\\\");\\r\\n        require(acoPools.length \\u003e 0, \\\"ACOBuyer::buy: Invalid pools\\\");\\r\\n        require(acoPools.length == acoAmounts.length \\u0026\\u0026 acoPools.length == restrictions.length, \\\"ACOBuyer::buy: Invalid arguments\\\");\\r\\n        \\r\\n        (,address strikeAsset,,,) = acoFactory.acoTokenData(acoToken);\\r\\n        \\r\\n        uint256 amount = _getAssetAmount(acoAmounts, restrictions);\\r\\n        (uint256 previousBalance, uint256 extraAmount) = _receiveAsset(strikeAsset, amount);\\r\\n        \\r\\n        _poolSwap(strikeAsset, acoToken, to, deadline, acoPools, acoAmounts, restrictions);\\r\\n        \\r\\n        uint256 afterBalance = ACOAssetHelper._getAssetBalanceOf(strikeAsset, address(this));\\r\\n        uint256 remaining = SafeMath.add(extraAmount, SafeMath.sub(afterBalance, previousBalance));\\r\\n        if (remaining \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(strikeAsset, msg.sender, remaining);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getAssetAmount(uint256[] memory acoAmounts, uint256[] memory restrictions) internal pure returns(uint256 amount) {\\r\\n        amount = 0;\\r\\n        for (uint256 i = 0; i \\u003c acoAmounts.length; ++i) {\\r\\n            require(acoAmounts[i] \\u003e 0, \\\"ACOBuyer::buy: Invalid amount\\\");\\r\\n            require(restrictions[i] \\u003e 0, \\\"ACOBuyer::buy: Invalid restriction\\\");\\r\\n            amount = SafeMath.add(amount, restrictions[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _receiveAsset(address strikeAsset, uint256 amount) internal returns(uint256 previousBalance, uint256 extraAmount) {\\r\\n        previousBalance = ACOAssetHelper._getAssetBalanceOf(strikeAsset, address(this));\\r\\n\\r\\n        extraAmount = 0;\\r\\n        if (ACOAssetHelper._isEther(strikeAsset)) {\\r\\n            require(msg.value \\u003e= amount, \\\"ACOBuyer::buy:Invalid ETH amount\\\");\\r\\n            previousBalance = SafeMath.sub(previousBalance, msg.value);\\r\\n            extraAmount = SafeMath.sub(msg.value, amount);\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"ACOBuyer::buy:No payable\\\");\\r\\n            ACOAssetHelper._callTransferFromERC20(strikeAsset, msg.sender, address(this), amount);\\r\\n        }\\r\\n    } \\r\\n\\r\\n    function _poolSwap(\\r\\n        address strikeAsset, \\r\\n        address acoToken, \\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        address[] memory acoPools,\\r\\n        uint256[] memory acoAmounts,\\r\\n        uint256[] memory restrictions\\r\\n    ) internal {\\r\\n        for (uint256 i = 0; i \\u003c acoPools.length; ++i) {\\r\\n            uint256 etherAmount = 0; \\r\\n            if (ACOAssetHelper._isEther(strikeAsset)) {\\r\\n                etherAmount = restrictions[i];\\r\\n            } else {\\r\\n                ACOAssetHelper._setAssetInfinityApprove(strikeAsset, address(this), acoPools[i], restrictions[i]);\\r\\n            }\\r\\n            IACOPool2(acoPools[i]).swap{value: etherAmount}(acoToken, acoAmounts[i], restrictions[i], to, deadline);\\r\\n        }\\r\\n    }\\r\\n}\"},\"IACOFactory.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOFactory {\\r\\n\\tfunction init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) external;\\r\\n    function acoFee() external view returns(uint256);\\r\\n    function factoryAdmin() external view returns(address);\\r\\n    function acoTokenImplementation() external view returns(address);\\r\\n    function acoFeeDestination() external view returns(address);\\r\\n    function acoTokenData(address acoToken) external view returns(address, address, bool, uint256, uint256);\\r\\n    function creators(address acoToken) external view returns(address);\\r\\n    function createAcoToken(address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime, uint256 maxExercisedAccounts) external returns(address);\\r\\n    function newAcoToken(address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime) external returns(address);\\r\\n    function getAcoToken(address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime) external view returns(address);\\r\\n    function setFactoryAdmin(address newFactoryAdmin) external;\\r\\n    function setAcoTokenImplementation(address newAcoTokenImplementation) external;\\r\\n    function setAcoFee(uint256 newAcoFee) external;\\r\\n    function setAcoFeeDestination(address newAcoFeeDestination) external;\\r\\n}\"},\"IACOPool2.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\ninterface IACOPool2 is IERC20 {\\r\\n\\r\\n    struct InitData {\\r\\n        address acoFactory;\\r\\n        address chiToken;\\r\\n        address lendingPool;\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCall; \\r\\n        uint256 baseVolatility;  \\r\\n        address admin;\\r\\n        address strategy;  \\r\\n        PoolAcoPermissionConfig acoPermissionConfig;\\r\\n        PoolProtocolConfig protocolConfig;\\r\\n    }\\r\\n\\r\\n\\tstruct AcoData {\\r\\n        bool open;\\r\\n        uint256 valueSold;\\r\\n        uint256 collateralLocked;\\r\\n        uint256 collateralRedeemed;\\r\\n        uint256 index;\\r\\n\\t\\tuint256 openIndex;\\r\\n    }\\r\\n    \\r\\n    struct PoolAcoPermissionConfig {\\r\\n        uint256 tolerancePriceBelowMin;\\r\\n        uint256 tolerancePriceBelowMax;\\r\\n        uint256 tolerancePriceAboveMin;\\r\\n        uint256 tolerancePriceAboveMax;\\r\\n        uint256 minExpiration;\\r\\n        uint256 maxExpiration;\\r\\n    }\\r\\n    \\r\\n    struct PoolProtocolConfig {\\r\\n        uint16 lendingPoolReferral;\\r\\n        uint256 withdrawOpenPositionPenalty;\\r\\n        uint256 underlyingPriceAdjustPercentage;\\r\\n        uint256 fee;\\r\\n        uint256 maximumOpenAco;\\r\\n        address feeDestination;\\r\\n        address assetConverter;\\r\\n    }\\r\\n    \\r\\n\\tfunction init(InitData calldata initData) external;\\r\\n\\tfunction numberOfAcoTokensNegotiated() external view returns(uint256);\\r\\n    function numberOfOpenAcoTokens() external view returns(uint256);\\r\\n    function collateral() external view returns(address);\\r\\n\\tfunction canSwap(address acoToken) external view returns(bool);\\r\\n\\tfunction quote(address acoToken, uint256 tokenAmount) external view returns(\\r\\n\\t\\tuint256 swapPrice, \\r\\n\\t\\tuint256 protocolFee, \\r\\n\\t\\tuint256 underlyingPrice, \\r\\n\\t\\tuint256 volatility\\r\\n\\t);\\r\\n\\tfunction getDepositShares(uint256 collateralAmount) external view returns(uint256 shares);\\r\\n\\tfunction getWithdrawNoLockedData(uint256 shares) external view returns(\\r\\n\\t\\tuint256 underlyingWithdrawn, \\r\\n\\t\\tuint256 strikeAssetWithdrawn, \\r\\n\\t\\tbool isPossible\\r\\n\\t);\\r\\n\\tfunction getWithdrawWithLocked(uint256 shares) external view returns(\\r\\n\\t\\tuint256 underlyingWithdrawn, \\r\\n\\t\\tuint256 strikeAssetWithdrawn, \\r\\n\\t\\taddress[] memory acos, \\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t);\\r\\n\\tfunction getGeneralData() external view returns(\\r\\n        uint256 underlyingBalance,\\r\\n\\t\\tuint256 strikeAssetBalance,\\r\\n\\t\\tuint256 collateralLocked,\\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable,\\r\\n        uint256 poolSupply\\r\\n    );\\r\\n\\tfunction setLendingPoolReferral(uint16 newLendingPoolReferral) external;\\r\\n\\tfunction setPoolDataForAcoPermission(uint256 newTolerancePriceBelow, uint256 newTolerancePriceAbove, uint256 newMinExpiration, uint256 newMaxExpiration) external;\\r\\n\\tfunction setAcoPermissionConfig(PoolAcoPermissionConfig calldata newConfig) external;\\r\\n\\tfunction setPoolAdmin(uint256 newAdmin) external;\\r\\n\\tfunction setProtocolConfig(PoolProtocolConfig calldata newConfig) external;\\r\\n\\tfunction setFeeData(address newFeeDestination, uint256 newFee) external;\\r\\n\\tfunction setAssetConverter(address newAssetConverter) external;\\r\\n    function setTolerancePriceBelow(uint256 newTolerancePriceBelow) external;\\r\\n    function setTolerancePriceAbove(uint256 newTolerancePriceAbove) external;\\r\\n    function setMinExpiration(uint256 newMinExpiration) external;\\r\\n    function setMaxExpiration(uint256 newMaxExpiration) external;\\r\\n    function setFee(uint256 newFee) external;\\r\\n    function setFeeDestination(address newFeeDestination) external;\\r\\n\\tfunction setWithdrawOpenPositionPenalty(uint256 newWithdrawOpenPositionPenalty) external;\\r\\n\\tfunction setUnderlyingPriceAdjustPercentage(uint256 newUnderlyingPriceAdjustPercentage) external;\\r\\n\\tfunction setMaximumOpenAco(uint256 newMaximumOpenAco) external;\\r\\n\\tfunction setStrategy(address newStrategy) external;\\r\\n\\tfunction setBaseVolatility(uint256 newBaseVolatility) external;\\r\\n\\tfunction setValidAcoCreator(address acoCreator, bool newPermission) external;\\r\\n\\tfunction setForbiddenAcoCreator(address acoCreator, bool newStatus) external;\\r\\n    function withdrawStuckToken(address token, address destination) external;\\r\\n    function deposit(uint256 collateralAmount, uint256 minShares, address to, bool isLendingToken) external payable returns(uint256 acoPoolTokenAmount);\\r\\n\\tfunction depositWithGasToken(uint256 collateralAmount, uint256 minShares, address to, bool isLendingToken) external payable returns(uint256 acoPoolTokenAmount);\\r\\n\\tfunction withdrawNoLocked(uint256 shares, uint256 minCollateral, address account, bool withdrawLendingToken) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t);\\r\\n\\tfunction withdrawNoLockedWithGasToken(uint256 shares, uint256 minCollateral, address account, bool withdrawLendingToken) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t);\\r\\n    function withdrawWithLocked(uint256 shares, address account, bool withdrawLendingToken) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t);\\r\\n\\tfunction withdrawWithLockedWithGasToken(uint256 shares, address account, bool withdrawLendingToken) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t);\\r\\n    function swap(address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external payable;\\r\\n    function swapWithGasToken(address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external payable;\\r\\n    function redeemACOTokens() external;\\r\\n\\tfunction redeemACOToken(address acoToken) external;\\r\\n    function restoreCollateral() external;\\r\\n    function lendCollateral() external;\\r\\n}\"},\"IChiToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\ninterface IChiToken is IERC20 {\\r\\n    function mint(uint256 value) external;\\r\\n    function computeAddress2(uint256 salt) external view returns(address);\\r\\n    function free(uint256 value) external returns(uint256);\\r\\n    function freeUpTo(uint256 value) external returns(uint256);\\r\\n    function freeFrom(address from, uint256 value) external returns(uint256);\\r\\n    function freeFromUpTo(address from, uint256 value) external returns(uint256);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_acoFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chiToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"acoFactory\",\"outputs\":[{\"internalType\":\"contract IACOFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"acoPools\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"restrictions\",\"type\":\"uint256[]\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"acoPools\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"restrictions\",\"type\":\"uint256[]\"}],\"name\":\"buyWithGasToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chiToken\",\"outputs\":[{\"internalType\":\"contract IChiToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOBuyer","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000176b98ab38d1ae8ff3f30bf07f9b93e26f559c170000000000000000000000000000000000004946c0e9f43f4dee607b0ef1fa1c","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://da42b2f7cac9c12a7fd42ef20fc8b804c8cec9baf50c8ff1f5f15a34f188c208"}]}