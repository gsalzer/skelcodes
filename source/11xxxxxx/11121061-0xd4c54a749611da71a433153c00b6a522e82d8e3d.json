{"status":"1","message":"OK","result":[{"SourceCode":"// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.7;\r\n\r\nabstract contract SAFEEngineLike {\r\n    function safes(bytes32, address) virtual public view returns (uint, uint);\r\n    function approveSAFEModification(address) virtual public;\r\n    function transferCollateral(bytes32, address, address, uint) virtual public;\r\n    function transferInternalCoins(address, address, uint) virtual public;\r\n    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;\r\n    function transferSAFECollateralAndDebt(bytes32, address, address, int, int) virtual public;\r\n}\r\n\r\nabstract contract LiquidationEngineLike {\r\n    function protectSAFE(bytes32, address, address) virtual external;\r\n}\r\n\r\ncontract SAFEHandler {\r\n    constructor(address safeEngine) public {\r\n        SAFEEngineLike(safeEngine).approveSAFEModification(msg.sender);\r\n    }\r\n}\r\n\r\ncontract GebSafeManager {\r\n    address                   public safeEngine;\r\n    uint                      public safei;               // Auto incremental\r\n    mapping (uint => address) public safes;               // SAFEId => SAFEHandler\r\n    mapping (uint => List)    public safeList;            // SAFEId => Prev & Next SAFEIds (double linked list)\r\n    mapping (uint => address) public ownsSAFE;            // SAFEId => Owner\r\n    mapping (uint => bytes32) public collateralTypes;     // SAFEId => CollateralType\r\n\r\n    mapping (address => uint) public firstSAFEID;         // Owner => First SAFEId\r\n    mapping (address => uint) public lastSAFEID;          // Owner => Last SAFEId\r\n    mapping (address => uint) public safeCount;           // Owner => Amount of SAFEs\r\n\r\n    mapping (\r\n        address => mapping (\r\n            uint => mapping (\r\n                address => uint\r\n            )\r\n        )\r\n    ) public safeCan;                            // Owner => SAFEId => Allowed Addr => True/False\r\n\r\n    mapping (\r\n        address => mapping (\r\n            address => uint\r\n        )\r\n    ) public handlerCan;                        // SAFE handler => Allowed Addr => True/False\r\n\r\n    struct List {\r\n        uint prev;\r\n        uint next;\r\n    }\r\n\r\n    // --- Events ---\r\n    event AllowSAFE(\r\n        address sender,\r\n        uint safe,\r\n        address usr,\r\n        uint ok\r\n    );\r\n    event AllowHandler(\r\n        address sender,\r\n        address usr,\r\n        uint ok\r\n    );\r\n    event TransferSAFEOwnership(\r\n        address sender,\r\n        uint safe,\r\n        address dst\r\n    );\r\n    event OpenSAFE(address indexed sender, address indexed own, uint indexed safe);\r\n    event ModifySAFECollateralization(\r\n        address sender,\r\n        uint safe,\r\n        int deltaCollateral,\r\n        int deltaDebt\r\n    );\r\n    event TransferCollateral(\r\n        address sender,\r\n        uint safe,\r\n        address dst,\r\n        uint wad\r\n    );\r\n    event TransferCollateral(\r\n        address sender,\r\n        bytes32 collateralType,\r\n        uint safe,\r\n        address dst,\r\n        uint wad\r\n    );\r\n    event TransferInternalCoins(\r\n        address sender,\r\n        uint safe,\r\n        address dst,\r\n        uint rad\r\n    );\r\n    event QuitSystem(\r\n        address sender,\r\n        uint safe,\r\n        address dst\r\n    );\r\n    event EnterSystem(\r\n        address sender,\r\n        address src,\r\n        uint safe\r\n    );\r\n    event MoveSAFE(\r\n        address sender,\r\n        uint safeSrc,\r\n        uint safeDst\r\n    );\r\n    event ProtectSAFE(\r\n        address sender,\r\n        uint safe,\r\n        address liquidationEngine,\r\n        address saviour\r\n    );\r\n\r\n    modifier safeAllowed(\r\n        uint safe\r\n    ) {\r\n        require(msg.sender == ownsSAFE[safe] || safeCan[ownsSAFE[safe]][safe][msg.sender] == 1, \"safe-not-allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier handlerAllowed(\r\n        address handler\r\n    ) {\r\n        require(\r\n          msg.sender == handler ||\r\n          handlerCan[handler][msg.sender] == 1,\r\n          \"internal-system-safe-not-allowed\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address safeEngine_) public {\r\n        safeEngine = safeEngine_;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y >= 0);\r\n    }\r\n\r\n    // --- SAFE Manipulation ---\r\n\r\n    // Allow/disallow a usr address to manage the safe\r\n    function allowSAFE(\r\n        uint safe,\r\n        address usr,\r\n        uint ok\r\n    ) public safeAllowed(safe) {\r\n        safeCan[ownsSAFE[safe]][safe][usr] = ok;\r\n        emit AllowSAFE(\r\n            msg.sender,\r\n            safe,\r\n            usr,\r\n            ok\r\n        );\r\n    }\r\n\r\n    // Allow/disallow a usr address to quit to the sender handler\r\n    function allowHandler(\r\n        address usr,\r\n        uint ok\r\n    ) public {\r\n        handlerCan[msg.sender][usr] = ok;\r\n        emit AllowHandler(\r\n            msg.sender,\r\n            usr,\r\n            ok\r\n        );\r\n    }\r\n\r\n    // Open a new safe for a given usr address.\r\n    function openSAFE(\r\n        bytes32 collateralType,\r\n        address usr\r\n    ) public returns (uint) {\r\n        require(usr != address(0), \"usr-address-0\");\r\n\r\n        safei = add(safei, 1);\r\n        safes[safei] = address(new SAFEHandler(safeEngine));\r\n        ownsSAFE[safei] = usr;\r\n        collateralTypes[safei] = collateralType;\r\n\r\n        // Add new SAFE to double linked list and pointers\r\n        if (firstSAFEID[usr] == 0) {\r\n            firstSAFEID[usr] = safei;\r\n        }\r\n        if (lastSAFEID[usr] != 0) {\r\n            safeList[safei].prev = lastSAFEID[usr];\r\n            safeList[lastSAFEID[usr]].next = safei;\r\n        }\r\n        lastSAFEID[usr] = safei;\r\n        safeCount[usr] = add(safeCount[usr], 1);\r\n\r\n        emit OpenSAFE(msg.sender, usr, safei);\r\n        return safei;\r\n    }\r\n\r\n    // Give the safe ownership to a dst address.\r\n    function transferSAFEOwnership(\r\n        uint safe,\r\n        address dst\r\n    ) public safeAllowed(safe) {\r\n        require(dst != address(0), \"dst-address-0\");\r\n        require(dst != ownsSAFE[safe], \"dst-already-owner\");\r\n\r\n        // Remove transferred SAFE from double linked list of origin user and pointers\r\n        if (safeList[safe].prev != 0) {\r\n            safeList[safeList[safe].prev].next = safeList[safe].next;    // Set the next pointer of the prev safe (if exists) to the next of the transferred one\r\n        }\r\n        if (safeList[safe].next != 0) {                               // If wasn't the last one\r\n            safeList[safeList[safe].next].prev = safeList[safe].prev;    // Set the prev pointer of the next safe to the prev of the transferred one\r\n        } else {                                                    // If was the last one\r\n            lastSAFEID[ownsSAFE[safe]] = safeList[safe].prev;            // Update last pointer of the owner\r\n        }\r\n        if (firstSAFEID[ownsSAFE[safe]] == safe) {                      // If was the first one\r\n            firstSAFEID[ownsSAFE[safe]] = safeList[safe].next;           // Update first pointer of the owner\r\n        }\r\n        safeCount[ownsSAFE[safe]] = sub(safeCount[ownsSAFE[safe]], 1);\r\n\r\n        // Transfer ownership\r\n        ownsSAFE[safe] = dst;\r\n\r\n        // Add transferred SAFE to double linked list of destiny user and pointers\r\n        safeList[safe].prev = lastSAFEID[dst];\r\n        safeList[safe].next = 0;\r\n        if (lastSAFEID[dst] != 0) {\r\n            safeList[lastSAFEID[dst]].next = safe;\r\n        }\r\n        if (firstSAFEID[dst] == 0) {\r\n            firstSAFEID[dst] = safe;\r\n        }\r\n        lastSAFEID[dst] = safe;\r\n        safeCount[dst] = add(safeCount[dst], 1);\r\n\r\n        emit TransferSAFEOwnership(\r\n            msg.sender,\r\n            safe,\r\n            dst\r\n        );\r\n    }\r\n\r\n    // Modify a SAFE's collateralization ratio while keeping the generated COIN or collateral freed in the SAFE handler address.\r\n    function modifySAFECollateralization(\r\n        uint safe,\r\n        int deltaCollateral,\r\n        int deltaDebt\r\n    ) public safeAllowed(safe) {\r\n        address safeHandler = safes[safe];\r\n        SAFEEngineLike(safeEngine).modifySAFECollateralization(\r\n            collateralTypes[safe],\r\n            safeHandler,\r\n            safeHandler,\r\n            safeHandler,\r\n            deltaCollateral,\r\n            deltaDebt\r\n        );\r\n        emit ModifySAFECollateralization(\r\n            msg.sender,\r\n            safe,\r\n            deltaCollateral,\r\n            deltaDebt\r\n        );\r\n    }\r\n\r\n    // Transfer wad amount of safe collateral from the safe address to a dst address.\r\n    function transferCollateral(\r\n        uint safe,\r\n        address dst,\r\n        uint wad\r\n    ) public safeAllowed(safe) {\r\n        SAFEEngineLike(safeEngine).transferCollateral(collateralTypes[safe], safes[safe], dst, wad);\r\n        emit TransferCollateral(\r\n            msg.sender,\r\n            safe,\r\n            dst,\r\n            wad\r\n        );\r\n    }\r\n\r\n    // Transfer wad amount of any type of collateral (collateralType) from the safe address to a dst address.\r\n    // This function has the purpose to take away collateral from the system that doesn't correspond to the safe but was sent there wrongly.\r\n    function transferCollateral(\r\n        bytes32 collateralType,\r\n        uint safe,\r\n        address dst,\r\n        uint wad\r\n    ) public safeAllowed(safe) {\r\n        SAFEEngineLike(safeEngine).transferCollateral(collateralType, safes[safe], dst, wad);\r\n        emit TransferCollateral(\r\n            msg.sender,\r\n            collateralType,\r\n            safe,\r\n            dst,\r\n            wad\r\n        );\r\n    }\r\n\r\n    // Transfer rad amount of COIN from the safe address to a dst address.\r\n    function transferInternalCoins(\r\n        uint safe,\r\n        address dst,\r\n        uint rad\r\n    ) public safeAllowed(safe) {\r\n        SAFEEngineLike(safeEngine).transferInternalCoins(safes[safe], dst, rad);\r\n        emit TransferInternalCoins(\r\n            msg.sender,\r\n            safe,\r\n            dst,\r\n            rad\r\n        );\r\n    }\r\n\r\n    // Quit the system, migrating the safe (lockedCollateral, generatedDebt) to a different dst handler\r\n    function quitSystem(\r\n        uint safe,\r\n        address dst\r\n    ) public safeAllowed(safe) handlerAllowed(dst) {\r\n        (uint lockedCollateral, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralTypes[safe], safes[safe]);\r\n        int deltaCollateral = toInt(lockedCollateral);\r\n        int deltaDebt = toInt(generatedDebt);\r\n        SAFEEngineLike(safeEngine).transferSAFECollateralAndDebt(\r\n            collateralTypes[safe],\r\n            safes[safe],\r\n            dst,\r\n            deltaCollateral,\r\n            deltaDebt\r\n        );\r\n        emit QuitSystem(\r\n            msg.sender,\r\n            safe,\r\n            dst\r\n        );\r\n    }\r\n\r\n    // Import a position from src handler to the handler owned by safe\r\n    function enterSystem(\r\n        address src,\r\n        uint safe\r\n    ) public handlerAllowed(src) safeAllowed(safe) {\r\n        (uint lockedCollateral, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralTypes[safe], src);\r\n        int deltaCollateral = toInt(lockedCollateral);\r\n        int deltaDebt = toInt(generatedDebt);\r\n        SAFEEngineLike(safeEngine).transferSAFECollateralAndDebt(\r\n            collateralTypes[safe],\r\n            src,\r\n            safes[safe],\r\n            deltaCollateral,\r\n            deltaDebt\r\n        );\r\n        emit EnterSystem(\r\n            msg.sender,\r\n            src,\r\n            safe\r\n        );\r\n    }\r\n\r\n    // Move a position from safeSrc handler to the safeDst handler\r\n    function moveSAFE(\r\n        uint safeSrc,\r\n        uint safeDst\r\n    ) public safeAllowed(safeSrc) safeAllowed(safeDst) {\r\n        require(collateralTypes[safeSrc] == collateralTypes[safeDst], \"non-matching-safes\");\r\n        (uint lockedCollateral, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralTypes[safeSrc], safes[safeSrc]);\r\n        int deltaCollateral = toInt(lockedCollateral);\r\n        int deltaDebt = toInt(generatedDebt);\r\n        SAFEEngineLike(safeEngine).transferSAFECollateralAndDebt(\r\n            collateralTypes[safeSrc],\r\n            safes[safeSrc],\r\n            safes[safeDst],\r\n            deltaCollateral,\r\n            deltaDebt\r\n        );\r\n        emit MoveSAFE(\r\n            msg.sender,\r\n            safeSrc,\r\n            safeDst\r\n        );\r\n    }\r\n\r\n    // Choose a SAFE saviour inside LiquidationEngine for SAFE with id 'safe'\r\n    function protectSAFE(\r\n        uint safe,\r\n        address liquidationEngine,\r\n        address saviour\r\n    ) public safeAllowed(safe) {\r\n        LiquidationEngineLike(liquidationEngine).protectSAFE(\r\n            collateralTypes[safe],\r\n            safes[safe],\r\n            saviour\r\n        );\r\n        emit ProtectSAFE(\r\n            msg.sender,\r\n            safe,\r\n            liquidationEngine,\r\n            saviour\r\n        );\r\n    }\r\n}\r\n\r\ncontract GetSafes {\r\n    function getSafesAsc(address manager, address guy) external view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes) {\r\n        uint count = GebSafeManager(manager).safeCount(guy);\r\n        ids = new uint[](count);\r\n        safes = new address[](count);\r\n        collateralTypes = new bytes32[](count);\r\n        uint i = 0;\r\n        uint id = GebSafeManager(manager).firstSAFEID(guy);\r\n\r\n        while (id > 0) {\r\n            ids[i] = id;\r\n            safes[i] = GebSafeManager(manager).safes(id);\r\n            collateralTypes[i] = GebSafeManager(manager).collateralTypes(id);\r\n            (,id) = GebSafeManager(manager).safeList(id);\r\n            i++;\r\n        }\r\n    }\r\n\r\n    function getSafesDesc(address manager, address guy) external view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes) {\r\n        uint count = GebSafeManager(manager).safeCount(guy);\r\n        ids = new uint[](count);\r\n        safes = new address[](count);\r\n        collateralTypes = new bytes32[](count);\r\n        uint i = 0;\r\n        uint id = GebSafeManager(manager).lastSAFEID(guy);\r\n\r\n        while (id > 0) {\r\n            ids[i] = id;\r\n            safes[i] = GebSafeManager(manager).safes(id);\r\n            collateralTypes[i] = GebSafeManager(manager).collateralTypes(id);\r\n            (id,) = GebSafeManager(manager).safeList(id);\r\n            i++;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"getSafesAsc\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"safes\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"collateralTypes\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"getSafesDesc\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"safes\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"collateralTypes\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GetSafes","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://439ed44d39105af1962265b6f8213585a80743e43da3319ba9fe5ff2f044f2ea"}]}