{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.7;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n\r\n    event Deposit(address indexed dst, uint256 wad);\r\n    event Withdrawal(address indexed src, uint256 wad);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        // prettier-ignore\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    function toPayable(address account)\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(\r\n            value\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            \"SafeERC20: decreased allowance below zero\"\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\ninterface ICToken {\r\n\r\n    /*** Market Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when interest is accrued\r\n     */\r\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are minted\r\n     */\r\n    event Mint(address minter, uint mintAmount, uint mintTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are redeemed\r\n     */\r\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when underlying is borrowed\r\n     */\r\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is repaid\r\n     */\r\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is liquidated\r\n     */\r\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\r\n\r\n\r\n    /*** Admin Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when pendingAdmin is changed\r\n     */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\r\n     */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserve factor is changed\r\n     */\r\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserves are added\r\n     */\r\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserves are reduced\r\n     */\r\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\r\n\r\n    /**\r\n     * @notice EIP20 Transfer event\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n    /**\r\n     * @notice EIP20 Approval event\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n\r\n    /**\r\n     * @notice Failure event\r\n     */\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function accrualBlockNumber() external view returns (uint);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() external returns (uint);\r\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\r\n\r\n    function totalBorrows() external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n\r\n}\r\n\r\ninterface ICERC20 is ICToken {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, ICToken cTokenCollateral) external returns (uint);\r\n\r\n    function underlying() external returns (address);\r\n}\r\n\r\ninterface ICEth is ICToken {\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function liquidateBorrow(address borrower, ICToken cTokenCollateral) external payable;\r\n    function mint() external payable;\r\n}\r\n\r\ninterface IComptroller {\r\n\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cToken) external returns (uint);\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);\r\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external;\r\n\r\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint);\r\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\r\n\r\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);\r\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) external;\r\n\r\n    function repayBorrowAllowed(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function repayBorrowVerify(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint borrowerIndex) external;\r\n\r\n    function liquidateBorrowAllowed(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function liquidateBorrowVerify(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint seizeTokens) external;\r\n\r\n    function seizeAllowed(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external returns (uint);\r\n    function seizeVerify(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external;\r\n\r\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint);\r\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) external;\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        uint repayAmount) external view returns (uint, uint);\r\n\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n\r\n\r\n    /***  Comp claims ****/\r\n    function claimComp(address holder) external;\r\n    function claimComp(address holder, ICToken[] calldata cTokens) external;\r\n    function markets(address ctoken) external view returns (bool, uint, bool);\r\n\r\n    \r\n    function compSpeeds(address ctoken) external view returns (uint);\r\n\r\n    \r\n\r\n}\r\n\r\ncontract CompLender {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    \r\n    // Comptroller address for compound.finance\r\n    IComptroller public constant COMPOUND = IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B); \r\n\r\n    //Only three tokens we use\r\n    address public constant COMP  = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\r\n    ICERC20 public constant cUSDC = ICERC20(address(0x39AA39c021dfbaE8faC545936693aC917d5E7563));\r\n    ICEth   public constant cETH  = ICEth(address(0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5));\r\n    address public constant USDC  = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n\r\n    address public constant uniswapRouter = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    address public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); \r\n\r\n    //Operating variables\r\n    uint256 public collateralTarget = 0.75 ether;  // 75% \r\n\r\n    address public allocator;\r\n\r\n    constructor(address _allocator) public {\r\n        //pre-set approvals\r\n        IERC20(COMP).approve(uniswapRouter, 1);\r\n        IERC20(USDC).approve(address(cUSDC), 1);\r\n        allocator = _allocator;\r\n\r\n        address[] memory cTokens = new address[](2);\r\n        cTokens[0] = address(cUSDC);\r\n        cTokens[1] = address(cETH);\r\n        COMPOUND.enterMarkets(cTokens);\r\n    }\r\n\r\n    function depositAndBorrow() public {\r\n        IWETH(WETH).withdraw(IERC20(WETH).balanceOf(address(this)));\r\n        if (address(this).balance > 0) {\r\n            _lockETH(address(this).balance);\r\n            // _drawUSDC();\r\n        }\r\n        cETH.transfer(allocator, cETH.balanceOf(address(this)));\r\n    }\r\n\r\n    function _lockETH(uint256 eth) internal {\r\n        cETH.mint{value: eth}();\r\n    }\r\n\r\n    // function _drawUSDC() internal {\r\n    //     (uint256 error, uint256 liquidity,) = COMPOUND.getAccountLiquidity(address(this));\r\n    //     uint256 borrowed = cUSDC.borrowBalanceCurrent(address(this));\r\n    //     require(error == 0, \"error getting liquidity\");\r\n\r\n    //     // Get the total USD value of our borrowing power\r\n    //     uint256 totalBorrowPower = liquidity.add(borrowed);\r\n    //     // Get the amount we need to draw to utilize 75% of that borrowing power\r\n    //     uint256 draw = totalBorrowPower.mul(collateralTarget).div(1e18).sub(borrowed);\r\n    //     cUSDC.borrow(draw);\r\n    // }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_allocator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"COMP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COMPOUND\",\"outputs\":[{\"internalType\":\"contract IComptroller\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cETH\",\"outputs\":[{\"internalType\":\"contract ICEth\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cUSDC\",\"outputs\":[{\"internalType\":\"contract ICERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAndBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CompLender","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009e9778231e38ec2473f9addcadfb81300d5256cd","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://790bcaee2c486674205f5eeb56617b729ddc6844d51a3c73197e10b75ef5ad24"}]}