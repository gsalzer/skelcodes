{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSAUpgradeable {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(\r\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\r\n            \"ECDSA: invalid signature 's' value\"\r\n        );\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\ninterface IMintBurnToken {\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    function burn(address account, uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            cs := extcodesize(self)\r\n        }\r\n        return cs == 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title LnAdminUpgradeable\r\n *\r\n * @dev This is an upgradeable version of `LnAdmin` by replacing the constructor with\r\n * an initializer and reserving storage slots.\r\n */\r\ncontract LnAdminUpgradeable is Initializable {\r\n    event CandidateChanged(address oldCandidate, address newCandidate);\r\n    event AdminChanged(address oldAdmin, address newAdmin);\r\n\r\n    address public admin;\r\n    address public candidate;\r\n\r\n    function __LnAdminUpgradeable_init(address _admin) public initializer {\r\n        require(_admin != address(0), \"LnAdminUpgradeable: zero address\");\r\n        admin = _admin;\r\n        emit AdminChanged(address(0), _admin);\r\n    }\r\n\r\n    function setCandidate(address _candidate) external onlyAdmin {\r\n        address old = candidate;\r\n        candidate = _candidate;\r\n        emit CandidateChanged(old, candidate);\r\n    }\r\n\r\n    function becomeAdmin() external {\r\n        require(msg.sender == candidate, \"LnAdminUpgradeable: only candidate can become admin\");\r\n        address old = admin;\r\n        admin = candidate;\r\n        emit AdminChanged(old, admin);\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require((msg.sender == admin), \"LnAdminUpgradeable: only the contract admin can perform this action\");\r\n        _;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[48] private __gap;\r\n}\r\n\r\n/**\r\n * @title LnErc20Bridge\r\n *\r\n * @dev An upgradeable contract for moving ERC20 tokens across blockchains. An\r\n * off-chain relayer is responsible for signing proofs of deposits to be used on destination\r\n * chains of the transactions. A multi-relayer set up can be used for enhanced security and\r\n * decentralization.\r\n *\r\n * @dev The relayer should wait for finality on the source chain before generating a deposit\r\n * proof. Otherwise a double-spending attack is possible.\r\n *\r\n * @dev The bridge can operate in two different modes for each token: transfer mode and mint/burn\r\n * mode, depending on the nature of the token.\r\n *\r\n * @dev Note that transaction hashes shall NOT be used for re-entrance prevention as doing\r\n * so will result in false negatives when multiple transfers are made in a single\r\n * transaction (with the use of contracts).\r\n *\r\n * @dev Chain IDs in this contract currently refer to the ones introduced in EIP-155. However,\r\n * a list of custom IDs might be used instead when non-EVM compatible chains are added.\r\n */\r\ncontract LnErc20Bridge is LnAdminUpgradeable {\r\n    using ECDSAUpgradeable for bytes32;\r\n\r\n    /**\r\n     * @dev Emits when a deposit is made.\r\n     *\r\n     * @dev Addresses are represented with bytes32 to maximize compatibility with\r\n     * non-Ethereum-compatible blockchains.\r\n     *\r\n     * @param srcChainId Chain ID of the source blockchain (current chain)\r\n     * @param destChainId Chain ID of the destination blockchain\r\n     * @param depositId Unique ID of the deposit on the current chain\r\n     * @param depositor Address of the account on the current chain that made the deposit\r\n     * @param recipient Address of the account on the destination chain that will receive the amount\r\n     * @param currency A bytes32-encoded universal currency key\r\n     * @param amount Amount of tokens being deposited to recipient's address.\r\n     */\r\n    event TokenDeposited(\r\n        uint256 srcChainId,\r\n        uint256 destChainId,\r\n        uint256 depositId,\r\n        bytes32 depositor,\r\n        bytes32 recipient,\r\n        bytes32 currency,\r\n        uint256 amount\r\n    );\r\n    event TokenWithdrawn(\r\n        uint256 srcChainId,\r\n        uint256 destChainId,\r\n        uint256 depositId,\r\n        bytes32 depositor,\r\n        bytes32 recipient,\r\n        bytes32 currency,\r\n        uint256 amount\r\n    );\r\n    event RelayerChanged(address oldRelayer, address newRelayer);\r\n    event TokenAdded(bytes32 tokenKey, address tokenAddress, uint8 lockType);\r\n    event TokenRemoved(bytes32 tokenKey);\r\n    event ChainSupportForTokenAdded(bytes32 tokenKey, uint256 chainId);\r\n    event ChainSupportForTokenDropped(bytes32 tokenKey, uint256 chainId);\r\n\r\n    struct TokenInfo {\r\n        address tokenAddress;\r\n        uint8 lockType;\r\n    }\r\n\r\n    uint256 public currentChainId;\r\n    address public relayer;\r\n    uint256 public depositCount;\r\n    mapping(bytes32 => TokenInfo) public tokenInfos;\r\n    mapping(bytes32 => mapping(uint256 => bool)) public tokenSupportedOnChain;\r\n    mapping(uint256 => mapping(uint256 => bool)) public withdrawnDeposits;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR; // For EIP-712\r\n\r\n    bytes32 public constant DEPOSIT_TYPEHASH =\r\n        keccak256(\r\n            \"Deposit(uint256 srcChainId,uint256 destChainId,uint256 depositId,bytes32 depositor,bytes32 recipient,bytes32 currency,uint256 amount)\"\r\n        );\r\n\r\n    uint8 public constant TOKEN_LOCK_TYPE_TRANSFER = 1;\r\n    uint8 public constant TOKEN_LOCK_TYPE_MINT_BURN = 2;\r\n\r\n    bytes4 private constant TRANSFER_SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n    bytes4 private constant TRANSFERFROM_SELECTOR = bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\r\n\r\n    function getTokenAddress(bytes32 tokenKey) public view returns (address) {\r\n        return tokenInfos[tokenKey].tokenAddress;\r\n    }\r\n\r\n    function getTokenLockType(bytes32 tokenKey) public view returns (uint8) {\r\n        return tokenInfos[tokenKey].lockType;\r\n    }\r\n\r\n    function isTokenSupportedOnChain(bytes32 tokenKey, uint256 chainId) public view returns (bool) {\r\n        return tokenSupportedOnChain[tokenKey][chainId];\r\n    }\r\n\r\n    function __LnErc20Bridge_init(address _relayer, address _admin) public initializer {\r\n        __LnAdminUpgradeable_init(_admin);\r\n\r\n        _setRelayer(_relayer);\r\n\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        currentChainId = chainId;\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                keccak256(bytes(\"Linear\")),\r\n                keccak256(bytes(\"1\")),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function setRelayer(address _relayer) external onlyAdmin {\r\n        _setRelayer(_relayer);\r\n    }\r\n\r\n    function addToken(\r\n        bytes32 tokenKey,\r\n        address tokenAddress,\r\n        uint8 lockType\r\n    ) external onlyAdmin {\r\n        require(tokenInfos[tokenKey].tokenAddress == address(0), \"LnErc20Bridge: token already exists\");\r\n        require(tokenAddress != address(0), \"LnErc20Bridge: zero address\");\r\n        require(\r\n            lockType == TOKEN_LOCK_TYPE_TRANSFER || lockType == TOKEN_LOCK_TYPE_MINT_BURN,\r\n            \"LnErc20Bridge: unknown token lock type\"\r\n        );\r\n\r\n        tokenInfos[tokenKey] = TokenInfo({tokenAddress: tokenAddress, lockType: lockType});\r\n        emit TokenAdded(tokenKey, tokenAddress, lockType);\r\n    }\r\n\r\n    function removeToken(bytes32 tokenKey) external onlyAdmin {\r\n        require(tokenInfos[tokenKey].tokenAddress != address(0), \"LnErc20Bridge: token does not exists\");\r\n        delete tokenInfos[tokenKey];\r\n        emit TokenRemoved(tokenKey);\r\n    }\r\n\r\n    function addChainSupportForToken(bytes32 tokenKey, uint256 chainId) external onlyAdmin {\r\n        require(!tokenSupportedOnChain[tokenKey][chainId], \"LnErc20Bridge: already supported\");\r\n        tokenSupportedOnChain[tokenKey][chainId] = true;\r\n        emit ChainSupportForTokenAdded(tokenKey, chainId);\r\n    }\r\n\r\n    function dropChainSupportForToken(bytes32 tokenKey, uint256 chainId) external onlyAdmin {\r\n        require(tokenSupportedOnChain[tokenKey][chainId], \"LnErc20Bridge: not supported\");\r\n        tokenSupportedOnChain[tokenKey][chainId] = false;\r\n        emit ChainSupportForTokenDropped(tokenKey, chainId);\r\n    }\r\n\r\n    function deposit(\r\n        bytes32 token,\r\n        uint256 amount,\r\n        uint256 destChainId,\r\n        bytes32 recipient\r\n    ) external {\r\n        TokenInfo memory tokenInfo = tokenInfos[token];\r\n        require(tokenInfo.tokenAddress != address(0), \"LnErc20Bridge: token not found\");\r\n\r\n        require(amount > 0, \"LnErc20Bridge: amount must be positive\");\r\n        require(destChainId != currentChainId, \"LnErc20Bridge: dest must be different from src\");\r\n        require(isTokenSupportedOnChain(token, destChainId), \"LnErc20Bridge: token not supported on chain\");\r\n        require(recipient != 0, \"LnErc20Bridge: zero address\");\r\n\r\n        depositCount = depositCount + 1;\r\n\r\n        if (tokenInfo.lockType == TOKEN_LOCK_TYPE_TRANSFER) {\r\n            safeTransferFrom(tokenInfo.tokenAddress, msg.sender, address(this), amount);\r\n        } else if (tokenInfo.lockType == TOKEN_LOCK_TYPE_MINT_BURN) {\r\n            IMintBurnToken(tokenInfo.tokenAddress).burn(msg.sender, amount);\r\n        } else {\r\n            require(false, \"LnErc20Bridge: unknown token lock type\");\r\n        }\r\n\r\n        emit TokenDeposited(\r\n            currentChainId,\r\n            destChainId,\r\n            depositCount,\r\n            bytes32(uint256(msg.sender)),\r\n            recipient,\r\n            token,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function withdraw(\r\n        uint256 srcChainId,\r\n        uint256 destChainId,\r\n        uint256 depositId,\r\n        bytes32 depositor,\r\n        bytes32 recipient,\r\n        bytes32 currency,\r\n        uint256 amount,\r\n        bytes calldata signature\r\n    ) external {\r\n        require(destChainId == currentChainId, \"LnErc20Bridge: wrong chain\");\r\n        require(!withdrawnDeposits[srcChainId][depositId], \"LnErc20Bridge: already withdrawn\");\r\n        require(recipient != 0, \"LnErc20Bridge: zero address\");\r\n        require(amount > 0, \"LnErc20Bridge: amount must be positive\");\r\n\r\n        TokenInfo memory tokenInfo = tokenInfos[currency];\r\n        require(tokenInfo.tokenAddress != address(0), \"LnErc20Bridge: token not found\");\r\n\r\n        // Verify EIP-712 signature\r\n        bytes32 digest =\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR,\r\n                    keccak256(\r\n                        abi.encode(\r\n                            DEPOSIT_TYPEHASH,\r\n                            srcChainId,\r\n                            destChainId,\r\n                            depositId,\r\n                            depositor,\r\n                            recipient,\r\n                            currency,\r\n                            amount\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n        address recoveredAddress = digest.recover(signature);\r\n        require(recoveredAddress == relayer, \"LnErc20Bridge: invalid signature\");\r\n\r\n        withdrawnDeposits[srcChainId][depositId] = true;\r\n\r\n        address decodedRecipient = address(uint160(uint256(recipient)));\r\n\r\n        if (tokenInfo.lockType == TOKEN_LOCK_TYPE_TRANSFER) {\r\n            safeTransfer(tokenInfo.tokenAddress, decodedRecipient, amount);\r\n        } else if (tokenInfo.lockType == TOKEN_LOCK_TYPE_MINT_BURN) {\r\n            IMintBurnToken(tokenInfo.tokenAddress).mint(decodedRecipient, amount);\r\n        } else {\r\n            require(false, \"LnErc20Bridge: unknown token lock type\");\r\n        }\r\n\r\n        emit TokenWithdrawn(srcChainId, destChainId, depositId, depositor, recipient, currency, amount);\r\n    }\r\n\r\n    function _setRelayer(address _relayer) private {\r\n        require(_relayer != address(0), \"LnErc20Bridge: zero address\");\r\n        require(_relayer != relayer, \"LnErc20Bridge: relayer not changed\");\r\n\r\n        address oldRelayer = relayer;\r\n        relayer = _relayer;\r\n\r\n        emit RelayerChanged(oldRelayer, relayer);\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address recipient,\r\n        uint256 amount\r\n    ) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(TRANSFER_SELECTOR, recipient, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"LnErc20Bridge: transfer failed\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) private {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(TRANSFERFROM_SELECTOR, sender, recipient, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"LnErc20Bridge: transfer from failed\");\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldCandidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCandidate\",\"type\":\"address\"}],\"name\":\"CandidateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"ChainSupportForTokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"ChainSupportForTokenDropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRelayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRelayer\",\"type\":\"address\"}],\"name\":\"RelayerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"lockType\",\"type\":\"uint8\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currency\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"}],\"name\":\"TokenRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currency\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEPOSIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_LOCK_TYPE_MINT_BURN\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_LOCK_TYPE_TRANSFER\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"__LnAdminUpgradeable_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"__LnErc20Bridge_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"addChainSupportForToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"lockType\",\"type\":\"uint8\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"becomeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"candidate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"token\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"dropChainSupportForToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"}],\"name\":\"getTokenLockType\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"isTokenSupportedOnChain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenKey\",\"type\":\"bytes32\"}],\"name\":\"removeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"setCandidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"setRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"tokenInfos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"lockType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSupportedOnChain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"currency\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawnDeposits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LnErc20Bridge","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"istanbul","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a43d26d98a139a91bc422ec635ccb4cb15ec5b9139a4830d2d5146009bfcacc0"}]}