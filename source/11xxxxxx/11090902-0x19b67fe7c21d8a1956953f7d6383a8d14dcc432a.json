{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.1;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract IERC20 {\r\n    function balanceOf(address who) public virtual view returns (uint);\r\n    function transferFrom(address sender, address recipient, uint amount) external virtual;\r\n    function transfer(address recipient, uint amount) public virtual;\r\n}\r\n\r\ncontract PFIContract{\r\n    using SafeMath for uint256;\r\n    \r\n    modifier onlyOwner{\r\n        require(msg.sender == _owner,\"Forbidden\");\r\n        _;\r\n    }\r\n    \r\n    address internal _owner;\r\n    \r\n    uint256 internal _ethToPfiPrice = 5000000;              //1ETH = 5 PFI\r\n    uint256 internal _ethToPfiPriceDivided = 1000000;       //ETH to PFI = _ethToPfiPrice / _ethToPfiPriceDivided\r\n    \r\n    address private _pfiTokenContractAddress = 0x6096Ef5A1321e405EdC63D40e9a4C190a7ef1B98;      //PFI Contract\r\n    \r\n    uint256 internal _purchaseEndTime = 1612137600; //2021-02-01 00:00:00\r\n    \r\n    constructor () payable{\r\n        _owner = _msgSender();\r\n    }\r\n    \r\n    function updatePrice(uint256 price) external onlyOwner{\r\n         _ethToPfiPrice = price;\r\n        emit UpdatePfiPrice(price);\r\n    }\r\n    \r\n    function getPrice() external view returns(uint256){\r\n        return _ethToPfiPrice.div(_ethToPfiPriceDivided);\r\n    }\r\n    \r\n    function updatePurchaseEndTime(uint256 endTime) external onlyOwner{\r\n        _purchaseEndTime = endTime;\r\n    }\r\n    \r\n    function getPurchaseEndTime() external view returns(uint256){\r\n        return _purchaseEndTime;\r\n    }\r\n    \r\n    receive () external payable{\r\n         processPurchase();\r\n    }\r\n    \r\n    function processPurchase() internal{\r\n        require(_getNow() < _purchaseEndTime, \"Purchase token time is end\");\r\n        address sender = _msgSender();\r\n        \r\n        uint256 ethAmount = msg.value;\r\n        \r\n        //Process to pay token for sender\r\n        //Calculate ETH to token price\r\n        uint256 tokenAmount = ethAmount.mul(_ethToPfiPrice).div(_ethToPfiPriceDivided);\r\n        \r\n        IERC20 token = IERC20(_pfiTokenContractAddress);\r\n        require(token.balanceOf(address(this)) >= tokenAmount,\"System balance is not enough\");\r\n         \r\n        token.transfer(sender, tokenAmount);\r\n        emit Purchase(sender, tokenAmount);\r\n    }\r\n    \r\n    function withdrawEth() external onlyOwner{\r\n        uint256 ethBalance = address(this).balance; \r\n        require(ethBalance > 0,'Balance is zero');\r\n        msg.sender.transfer(ethBalance);\r\n        \r\n        emit WithdrawEth(ethBalance);\r\n    }\r\n    \r\n    function withdrawToken(uint256 amount) external onlyOwner{\r\n        require(amount > 0, \"Withdraw amount should be greater than 0\");\r\n        \r\n        IERC20 token = IERC20(_pfiTokenContractAddress);\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n        require(tokenBalance >= amount, \"Balance is not enough\");\r\n        \r\n        token.transfer(_msgSender(),amount);\r\n        emit WithdrawToken(amount);\r\n    }\r\n    \r\n    function _getNow() private view returns(uint256){\r\n        return block.timestamp;\r\n    }\r\n    \r\n    function _msgSender() internal view returns(address){\r\n        return msg.sender;\r\n    }\r\n    \r\n    event UpdatePfiPrice(uint256 price);\r\n    event Purchase(address sender, uint256 purchasedAmount);\r\n    event WithdrawEth(uint256 eth);\r\n    event WithdrawToken(uint256 amount);\r\n}\r\n\r\n//SPDX-License-Identifier: MIT","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchasedAmount\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"UpdatePfiPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"WithdrawEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPurchaseEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"updatePurchaseEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"PFIContract","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://499bc879cfbdf524b367aab4dd0b4f779fd3605294b6019361fb22ac3e8e73aa"}]}