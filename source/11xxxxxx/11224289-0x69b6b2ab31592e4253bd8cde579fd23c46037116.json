{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.17;\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    \r\n    function sub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a); \r\n        c = a - b; \r\n    } \r\n    \r\n    function mul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b; \r\n        require(a == 0 || c / a == b); \r\n    } \r\n    \r\n    function div(uint a, uint b) public pure returns (uint c) { \r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender == owner)\r\n            _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract YGEM is Ownable {\r\n    using SafeMath for uint;\r\n    \r\n    struct StakingInfo {\r\n        uint amount;\r\n        uint depositDate;\r\n        uint rewardPercent;\r\n    }\r\n    \r\n    uint minStakeAmount = 30 * 10**18; // YGEM token has 18 decimals\r\n    uint REWARD_DIVIDER = 10**8;\r\n    \r\n    ERC20Interface stakingToken;\r\n    uint rewardPercent; //  percent value for per second  -> set 192 if you want 5% per month reward (because it will be divided by 10^8 for getting the small float number)\r\n    string name = \"YGEM\";\r\n    \r\n    uint ownerTokensAmount;\r\n    address[] internal stakeholders;\r\n    mapping(address => StakingInfo[]) internal stakes;\r\n\r\n    //  percent value for per second  \r\n    //  set 192 if you want 5% per month reward (because it will be divided by 10^8 for getting the small float number)\r\n    //  5% per month = 5 / (30 * 24 * 60 * 60) ~ 0.00000192 (192 / 10^8)\r\n    constructor(ERC20Interface _stakingToken, uint _rewardPercent) public {\r\n        stakingToken = _stakingToken;\r\n        rewardPercent = _rewardPercent;\r\n    }\r\n    \r\n    event Staked(address staker, uint amount);\r\n    event Unstaked(address staker, uint amount);\r\n    \r\n    function changeRewardPercent(uint _rewardPercent) public onlyOwner {\r\n        rewardPercent = _rewardPercent;\r\n    }\r\n    \r\n    function changeMinStakeAmount(uint _minStakeAmount) public onlyOwner {\r\n        minStakeAmount = _minStakeAmount;\r\n    }\r\n    \r\n    function totalStakes() public view returns(uint256) {\r\n        uint _totalStakes = 0;\r\n        for (uint i = 0; i < stakeholders.length; i += 1) {\r\n            for (uint j = 0; j < stakes[stakeholders[i]].length; j += 1)\r\n             _totalStakes = _totalStakes.add(stakes[stakeholders[i]][j].amount);\r\n        }\r\n        return _totalStakes;\r\n    }\r\n    \r\n    function isStakeholder(address _address) public view returns(bool, uint256) {\r\n        for (uint256 s = 0; s < stakeholders.length; s += 1) {\r\n            if (_address == stakeholders[s]) \r\n                return (true, s);\r\n        }\r\n        return (false, 0);\r\n    }\r\n\r\n    function addStakeholder(address _stakeholder) internal {\r\n        (bool _isStakeholder, ) = isStakeholder(_stakeholder);\r\n        if (!_isStakeholder)\r\n            stakeholders.push(_stakeholder);\r\n    }\r\n\r\n    function removeStakeholder(address _stakeholder) internal {\r\n        (bool _isStakeholder, uint256 s) = isStakeholder(_stakeholder);\r\n        if (_isStakeholder) {\r\n            stakeholders[s] = stakeholders[stakeholders.length - 1];\r\n            stakeholders.pop();\r\n        }\r\n    }\r\n    \r\n    function stake(uint256 _amount) public {\r\n        require(_amount >= minStakeAmount);\r\n        require(stakingToken.transferFrom(msg.sender, address(this), _amount), \"Stake required!\");\r\n        if (stakes[msg.sender].length == 0) {\r\n            addStakeholder(msg.sender);\r\n        }\r\n        stakes[msg.sender].push(StakingInfo(_amount, now, rewardPercent));\r\n        emit Staked(msg.sender, _amount);\r\n    }\r\n\r\n    function unstake() public {\r\n        uint withdrawAmount = 0;\r\n        for (uint j = 0; j < stakes[msg.sender].length; j += 1) {\r\n            uint amount = stakes[msg.sender][j].amount;\r\n            withdrawAmount = withdrawAmount.add(amount);\r\n            \r\n            uint rewardAmount = amount.mul((now - stakes[msg.sender][j].depositDate).mul(stakes[msg.sender][j].rewardPercent));\r\n            rewardAmount = rewardAmount.div(REWARD_DIVIDER);\r\n            withdrawAmount = withdrawAmount.add(rewardAmount.div(100));\r\n        }\r\n        \r\n        require(stakingToken.transfer(msg.sender, withdrawAmount), \"Not enough tokens in contract!\");\r\n        delete stakes[msg.sender];\r\n        removeStakeholder(msg.sender);\r\n        emit Unstaked(msg.sender, withdrawAmount);\r\n    }\r\n    \r\n    function sendTokens(uint _amount) public onlyOwner {\r\n        require(stakingToken.transferFrom(msg.sender, address(this), _amount), \"Transfering not approved!\");\r\n        ownerTokensAmount = ownerTokensAmount.add(_amount);\r\n    }\r\n    \r\n    function withdrawTokens(address receiver, uint _amount) public onlyOwner {\r\n        ownerTokensAmount = ownerTokensAmount.sub(_amount);\r\n        require(stakingToken.transfer(receiver, _amount), \"Not enough tokens on contract!\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPercent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinStakeAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPercent\",\"type\":\"uint256\"}],\"name\":\"changeRewardPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isStakeholder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"YGEM","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009c790a79916296cba9d7e602933df09e0c4d6a2900000000000000000000000000000000000000000000000000000000000000c0","EVMVersion":"Default","Library":"SafeMath:45f492ebef9a34477feb5ec61d8e7ae8e3f1a881","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d171ae627defeaea2f5059fde706b5ebc130d85f28b6d2cd393d91d7115502e6"}]}