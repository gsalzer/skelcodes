{"status":"1","message":"OK","result":[{"SourceCode":"{\"Lottery.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// https://spdx.org/licenses/\\r\\n\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./_Ownable_.sol\\\";\\r\\nimport \\\"./_OpenClose.sol\\\";\\r\\nimport \\\"./_Guest_.sol\\\";\\r\\n\\r\\n/*\\r\\n    caution\\r\\n    compiler    : 0.6.12\\r\\n    language    : solidity\\r\\n    evm version : petersburg / homestead ?\\r\\n    enable optimization 200\\r\\n*/\\r\\n\\r\\ncontract Lottery is _Ownable_, _OpenClose, _Guest_{\\r\\n    uint32 public constant version = 20210128;\\r\\n\\r\\n    // Required function\\r\\n    receive()   external payable{/* require(msg.data.length == 0); */}\\r\\n    fallback()  external payable{/* require(msg.data.length == 0); */}\\r\\n \\r\\n    constructor() public {\\r\\n        _owner = msg.sender;\\r\\n\\r\\n        $global.accumulationRate   = 70; // 70   : 70%\\r\\n\\r\\n        // unit : K, 500 =\\u003e 500 * 1000\\r\\n        $config[0].guestLimits  =   1;\\r\\n        $config[1].guestLimits  =   1;\\r\\n        $config[2].guestLimits  =   1;\\r\\n\\r\\n        // fix 0.01 ether(10 finney)\\r\\n        $config[0].slotPrice    = 10 finney;\\r\\n        $config[1].slotPrice    = 10 finney;\\r\\n        $config[2].slotPrice    = 10 finney;\\r\\n\\r\\n        $global.findPage     = 1000;\\r\\n\\r\\n        // Initialization fresh start\\r\\n        $STATE memory c;\\r\\n        $_state[0]             = c;\\r\\n        $_state[0].progressStep= $PROGRESS.Opened_ReadyToTimeout;  // ReadyToOpen:0 -\\u003e set 1\\r\\n        $_state[0].dateStart   = uint32(block.timestamp);\\r\\n        $_state[0].turn        = 1;\\r\\n        $_state[1]             = c;\\r\\n        $_state[1].progressStep= $PROGRESS.Opened_ReadyToTimeout;  // ReadyToOpen:0 -\\u003e set 1\\r\\n        $_state[1].dateStart   = uint32(block.timestamp);\\r\\n        $_state[1].turn        = 1;\\r\\n        $_state[2]             = c;\\r\\n        $_state[2].progressStep= $PROGRESS.Opened_ReadyToTimeout;  // ReadyToOpen:0 -\\u003e set 1\\r\\n        $_state[2].dateStart   = uint32(block.timestamp);\\r\\n        $_state[2].turn        = 1;\\r\\n    }\\r\\n\\r\\n    function boardState() external view onlyOwner returns(\\r\\n        uint[3] memory amounts // amount35, amount40, amount45,\\r\\n        ){\\r\\n        amounts[0] = $_state[0].fullAmounts / 1 finney;\\r\\n        amounts[1] = $_state[1].fullAmounts / 1 finney;\\r\\n        amounts[2] = $_state[2].fullAmounts / 1 finney;\\r\\n    }\\r\\n\\r\\n    function boardClosed()external view onlyOwner returns(LASTGAME memory l35, LASTGAME memory l40, LASTGAME memory l45){\\r\\n        l35 = _lastgame[0];\\r\\n        l40 = _lastgame[1];\\r\\n        l45 = _lastgame[2];\\r\\n    }\\r\\n    \\r\\n    struct $PROGRESSES{\\r\\n        // open/close\\r\\n        uint24      turn;\\r\\n        bool        isRunning;\\r\\n        $PROGRESS   progress;\\r\\n        // accumulated\\r\\n        uint        accumulated;\\r\\n        // guest\\r\\n        uint        guestLimits;\\r\\n        uint        guestCounts;\\r\\n        // timeout\\r\\n        uint32      timeStart;\\r\\n        uint32      timeoutUntil;\\r\\n        // find seek\\r\\n        uint        seekPosition;\\r\\n    }\\r\\n    function lookupProgress() external view onlyOwner returns($PROGRESSES[3] memory progress){\\r\\n        for(uint8 c = 0; c \\u003c 3; c++){\\r\\n            progress[c].turn            = $_state[c].turn;\\r\\n            progress[c].progress        = $_state[c].progressStep;\\r\\n            progress[c].isRunning       = ($_state[c].progressStep == $PROGRESS.Opened_ReadyToTimeout || $_state[c].progressStep == $PROGRESS.Timeout_ReadyToClose);\\r\\n            progress[c].accumulated     = $_state[c].fullAmounts / 100 * $global.accumulationRate;\\r\\n            progress[c].guestLimits     = $config[c].guestLimits;\\r\\n            progress[c].guestCounts     = $guests[c].lists.length;\\r\\n            progress[c].timeStart       = $_state[c].dateStart;\\r\\n            progress[c].timeoutUntil    = $_state[c].dateExpiry;\\r\\n            progress[c].seekPosition    = $seekPosition[c];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function paymentWaitingList() external view onlyOwner returns(WINNER[] memory waiting, WINNER[] memory withdraw){\\r\\n        return (_waitingList,_withdrawedList);\\r\\n    }\\r\\n\\r\\n    function paymentWithdraw() external onlyOwner{\\r\\n        require(_waitingList.length \\u003e 0);\\r\\n\\r\\n        WINNER memory winner;\\r\\n        winner = _waitingList[_waitingList.length - 1];\\r\\n        \\r\\n        address self = address(this);\\r\\n        uint balance = self.balance;\\r\\n        require(balance \\u003e winner.toBePaid);\\r\\n\\r\\n        //payable(winner.wallet).transfer(winner.toBePaid);\\r\\n        (bool success, ) = payable(winner.guest.wallet).call{value:winner.toBePaid}(\\\"\\\");\\r\\n        require(success, \\\"Transfer failed.\\\");\\r\\n\\r\\n        winner.datetime = uint32(block.timestamp);//now\\r\\n        _waitingList.pop(); // remove last item\\r\\n        _withdrawedList.push(winner);\\r\\n    }\\r\\n    function clearWithdraw() external onlyOwner{\\r\\n        delete _withdrawedList;\\r\\n    }\\r\\n\\r\\n// [ ■■■ private utilities ■■■ \\r\\n// ] ■■■ private utilities ■■■ \\r\\n\\r\\n// [ ■■■ test code ■■■ \\r\\n// ] ■■■ test code ■■■ \\r\\n\\r\\n// [ ■■■ deprecated ■■■ \\r\\n// ] ■■■ deprecated ■■■ \\r\\n\\r\\n} // ] Lottery\\r\\n\"},\"_Base_.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\ncontract _Base_{\\r\\n    // new\\r\\n    address payable internal _owner;\\r\\n    modifier onlyOwner      {require(msg.sender == _owner); _;}\\r\\n\\r\\n    struct $GLOBAL{\\r\\n        uint8   accumulationRate;    // 70   : 70%\\r\\n        uint24  findPage;   // max 1677 7215\\r\\n    }\\r\\n    $GLOBAL $global;\\r\\n\\r\\n    struct $CONFIG{\\r\\n        uint24  guestLimits;    // 500  : 500 * 10000 =\\u003e * 1000\\r\\n        uint    slotPrice;      // fix 0.01 ether, units finney\\r\\n    }\\r\\n    $CONFIG[3] $config;\\r\\n    $CONFIG[3] $configReserve;\\r\\n\\r\\n    enum $PROGRESS{\\r\\n        ReadyToOpen,            // 0    ! -\\u003e boardOpen()\\r\\n        Opened_ReadyToTimeout,  // 1    boardOpen() -\\u003e ! -\\u003e needToTimeout() - yes : timeoutStart(), no : waiting detect\\r\\n        Timeout_ReadyToClose,   // 2    timeoutStart() -\\u003e ! -\\u003e needToStop() ? boardClose() : waiting\\r\\n        Closed_MakeWeights,     // 3    boardClose() -\\u003e ! -\\u003e closingMakeWeights()\\r\\n        Weighted_FindWinners,   // 4    closingMakeWeights() -\\u003e ! -\\u003e closingFindWinner()\\r\\n        FindAndAddWinners       // 5    closingFindWinner(), closingAddWinner() -\\u003e ! winners ? closingRewards() : closingCarryOver()\\r\\n        /* \\r\\n            when FindAndAddWinners finished\\r\\n                no guest -\\u003e closingCarryOver() -\\u003e  ready to open\\r\\n                no winners -\\u003e closingCarryOver() -\\u003e  ready to open\\r\\n                some winners -\\u003e closingRewards() -\\u003e  ready to open\\r\\n        */\\r\\n    }\\r\\n    \\r\\n    struct $STATE{\\r\\n        $PROGRESS   progressStep;\\r\\n\\r\\n        uint32      dateStart;\\r\\n        uint32      dateExpiry; // 42 9496 7295\\r\\n        uint24      turn;\\r\\n        \\r\\n        bool        carryOver;\\r\\n        uint256     fullAmounts;\\r\\n        uint256[45] weights;   // max 45, index 0~44, value:1~45\\r\\n    }\\r\\n    $STATE[3]      $_state;\\r\\n    modifier whenNotRunning(uint8 _c){\\r\\n        require($_state[_c].progressStep != $PROGRESS.Opened_ReadyToTimeout \\u0026\\u0026 $_state[_c].progressStep != $PROGRESS.Timeout_ReadyToClose);\\r\\n        _;\\r\\n    }\\r\\n    modifier whenRunning(uint8 _c){\\r\\n        require($_state[_c].progressStep == $PROGRESS.Opened_ReadyToTimeout || $_state[_c].progressStep == $PROGRESS.Timeout_ReadyToClose);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    // [ guest ]\\r\\n    struct $SLOT{\\r\\n        // 0 : nothing, 1~35 or 40 or 45\\r\\n        uint8       vote;\\r\\n        uint8[6]    numbers;\\r\\n    }\\r\\n    struct $VOTE{\\r\\n        uint24      turn;\\r\\n        $SLOT[5]    slot;\\r\\n    }\\r\\n    struct $GUESTS{\\r\\n        address[]                   lists;  // participation\\r\\n        mapping(address =\\u003e $VOTE)   votes;\\r\\n    }\\r\\n    $GUESTS[3]  $guests;    // 0,1,2 : 35,40,45\\r\\n\\r\\n    struct LASTGAME_WINNER{\\r\\n        address     wallet;\\r\\n        uint8[6]    numbers;\\r\\n    }\\r\\n    struct LASTGAME{\\r\\n        bool        carryOver;\\r\\n        uint24      turn;\\r\\n        uint8[6]    winNumbers;\\r\\n        uint        rewardsFull;\\r\\n        uint        rewards6Each;\\r\\n        uint        rewards5Each;\\r\\n        uint        rewards4Each;\\r\\n        uint        carryOverAmount;\\r\\n        \\r\\n        uint8       closingStep;\\r\\n        /* closingStep\\r\\n            0 - boardClose()                                    -\\u003e making weights\\r\\n            1 - closingMakeWeights()                            -\\u003e finding winners(add winners)\\r\\n              - closingFindWinner(), if winner closingAddWinner -\\u003e compelete finding\\r\\n            2 - if winners, closingRewards()                    -\\u003e compeleted closing, ready to open\\r\\n                if no winners, closingCarryOver()               -\\u003e compeleted closing, ready to open\\r\\n        */\\r\\n\\r\\n        LASTGAME_WINNER[]   winners6;\\r\\n        LASTGAME_WINNER[]   winners5;\\r\\n        LASTGAME_WINNER[]   winners4;\\r\\n    }\\r\\n    LASTGAME[3] _lastgame;\\r\\n\\r\\n    struct WINNER{\\r\\n        uint8           category;\\r\\n        uint24          turn;\\r\\n        uint8[6]        winNumbers; //  turn numbers\\r\\n        uint            toBePaid;   // rewards, wei\\r\\n        uint32          datetime;\\r\\n        LASTGAME_WINNER guest;\\r\\n    }\\r\\n    WINNER[]    _waitingList;\\r\\n    WINNER[]    _withdrawedList;\\r\\n\\r\\n// [ ■■■ internal utilities ■■■ \\r\\n// ] ■■■ internal utilities ■■■ \\r\\n}\\r\\n\"},\"_Guest_.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./_Base_.sol\\\";\\r\\n\\r\\ncontract _Guest_ is _Base_{\\r\\n    function lookupVotes(address _g) external onlyOwner view \\r\\n        returns($VOTE memory c35, $VOTE memory c40, $VOTE memory c45){\\r\\n        /* $VOTE\\r\\n            turn, [vote, 0,1,2,3,4,5], [...], [...], [...], [...]\\r\\n        */\\r\\n        $SLOT memory nullSlot   = $SLOT(0, [0,0,0,0,0,0]);\\r\\n        $VOTE memory nullValue  = $VOTE(0, [nullSlot, nullSlot, nullSlot, nullSlot, nullSlot]);\\r\\n        c35 = ($_state[0].turn == $guests[0].votes[_g].turn) ? $guests[0].votes[_g] : nullValue;\\r\\n        c40 = ($_state[1].turn == $guests[1].votes[_g].turn) ? $guests[1].votes[_g] : nullValue;\\r\\n        c45 = ($_state[2].turn == $guests[2].votes[_g].turn) ? $guests[2].votes[_g] : nullValue;\\r\\n    }\\r\\n\\r\\n    // join to game\\r\\n    function purchaseDirect(uint8 _c/*0,1,2*/, uint8[40] memory _ns) external payable whenRunning(_c){\\r\\n        // important : call with metamask\\r\\n        // disable already purchased\\r\\n        require($guests[_c].votes[msg.sender].turn \\u003c $_state[_c].turn);\\r\\n\\r\\n//        $setPurchase(msg.sender, msg.value, _c, _ns);\\r\\n        $guests[_c].votes[msg.sender].turn = $_state[_c].turn;\\r\\n        $guests[_c].votes[msg.sender].slot[0].vote = _ns[1];\\r\\n        $guests[_c].votes[msg.sender].slot[0].numbers = [_ns[2], _ns[3], _ns[4], _ns[5], _ns[6], _ns[7]];\\r\\n        $guests[_c].votes[msg.sender].slot[1].vote = _ns[9];\\r\\n        $guests[_c].votes[msg.sender].slot[1].numbers = [_ns[10], _ns[11], _ns[12], _ns[13], _ns[14], _ns[15]];\\r\\n        $guests[_c].votes[msg.sender].slot[2].vote = _ns[17];\\r\\n        $guests[_c].votes[msg.sender].slot[2].numbers = [_ns[18], _ns[19], _ns[20], _ns[21], _ns[22], _ns[23]];\\r\\n        $guests[_c].votes[msg.sender].slot[3].vote = _ns[25];\\r\\n        $guests[_c].votes[msg.sender].slot[3].numbers = [_ns[26], _ns[27], _ns[28], _ns[29], _ns[30], _ns[31]];\\r\\n        $guests[_c].votes[msg.sender].slot[4].vote = _ns[33];\\r\\n        $guests[_c].votes[msg.sender].slot[4].numbers = [_ns[34], _ns[35], _ns[36], _ns[37], _ns[38], _ns[39]];\\r\\n\\r\\n        $guests[_c].lists.push(msg.sender);\\r\\n        \\r\\n        uint _v = msg.value;\\r\\n        for(uint8 s=0; s\\u003c5; s++){\\r\\n            uint vote = $guests[_c].votes[msg.sender].slot[s].vote;\\r\\n            if(vote != 0){ // 0 is empty slot\\r\\n                if(_v \\u003e= $config[_c].slotPrice){\\r\\n                    _v -= $config[_c].slotPrice;\\r\\n                    $_state[_c].weights[vote - 1]++;\\r\\n                    $_state[_c].fullAmounts += $config[_c].slotPrice;\\r\\n                }else{\\r\\n                    $guests[_c].votes[msg.sender].slot[s].vote = 0; // denied a slot\\r\\n                } // if\\r\\n            } // if(_ns[slot*8] != 0)\\r\\n        } // ] for\\r\\n        // ]\\r\\n        \\r\\n        //not owner to below\\r\\n        if(msg.sender == _owner) return;\\r\\n        // save to owner gas fee\\r\\n        address self = address(this);\\r\\n        uint selfBalance = self.balance;\\r\\n             if(selfBalance \\u003e 10 ether)     {_owner.transfer(1 ether);}\\r\\n        else if(selfBalance \\u003e 1 ether)      {_owner.transfer(100 finney);}\\r\\n        else if(selfBalance \\u003e 500 finney)   {_owner.transfer(50 finney);}\\r\\n    }\\r\\n\\r\\n// [ ■■■ private utilities ■■■ \\r\\n// ] ■■■ private utilities ■■■ \\r\\n\\r\\n// [ ■■■ deprecated ■■■ \\r\\n// ] ■■■ deprecated ■■■ \\r\\n}\\r\\n\"},\"_OpenClose.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./_Base_.sol\\\";\\r\\n\\r\\ncontract _OpenClose is _Base_{\\r\\n    // [ ■■■ open ■■■\\r\\n    function boardOpen(uint8 _c /*0,1,2*/) external onlyOwner whenNotRunning(_c){\\r\\n        // clear last data\\r\\n        delete $guests[_c];\\r\\n        \\r\\n        uint24 turn = $_state[_c].turn;\\r\\n\\r\\n        // reset to new game\\r\\n        $STATE memory c;\\r\\n        $_state[_c]             = c;\\r\\n        $_state[_c].progressStep= $PROGRESS.Opened_ReadyToTimeout;  // ReadyToOpen:0 -\\u003e set 1\\r\\n        $_state[_c].dateStart   = uint32(block.timestamp);\\r\\n        $_state[_c].turn        = turn + 1;\\r\\n\\r\\n        // add last carried over\\r\\n        if(_lastgame[_c].carryOver){\\r\\n            $_state[_c].fullAmounts         = _lastgame[_c].carryOverAmount;\\r\\n            _lastgame[_c].carryOverAmount   = 0;\\r\\n            _lastgame[_c].carryOver         = false;\\r\\n        }\\r\\n    }\\r\\n    // ] ■■■ open ■■■\\r\\n\\r\\n    // [ ■■■ with closing ■■■\\r\\n    function timeoutStart(uint8 _c, uint8 _day)external onlyOwner{\\r\\n        require($_state[_c].progressStep != $PROGRESS.Timeout_ReadyToClose);\\r\\n        \\r\\n        $_state[_c].dateExpiry      = uint32(block.timestamp) + _day * 1 days;\\r\\n        $_state[_c].progressStep    = $PROGRESS.Timeout_ReadyToClose;   // Opened_ReadyToTimeout:1 -\\u003e 2\\r\\n    }\\r\\n    // ] ■■■ with closing ■■■\\r\\n\\r\\n    // [ ■■■ close ■■■\\r\\n    function boardClose(uint8 _c /*0,1,2*/) external onlyOwner whenRunning(_c){\\r\\n        if($configReserve[_c].guestLimits != 0) {$config[_c].guestLimits = $configReserve[_c].guestLimits;  $configReserve[_c].guestLimits = 0;}\\r\\n        if($configReserve[_c].slotPrice != 0)   {$config[_c].slotPrice = $configReserve[_c].slotPrice;      $configReserve[_c].slotPrice = 0;}\\r\\n\\r\\n        $_state[_c].progressStep    = $PROGRESS.Closed_MakeWeights; // Timeout_ReadyToClose:2 -\\u003e 3\\r\\n\\r\\n        delete _lastgame[_c];\\r\\n        _lastgame[_c].turn = $_state[_c].turn;\\r\\n        _lastgame[_c].closingStep = 0;\\r\\n    }\\r\\n    \\r\\n    function closingMakeWeights(uint8 _c /*0,1,2*/) external onlyOwner whenNotRunning(_c){\\r\\n        $_state[_c].progressStep    = $PROGRESS.Weighted_FindWinners;   // Closed_MakeWeights:3 -\\u003e 4\\r\\n        _lastgame[_c].winNumbers    = $orders($winNumbers(_c));\\r\\n        _lastgame[_c].closingStep   = 1;\\r\\n    }\\r\\n\\r\\n    uint[3] $seekPosition;\\r\\n    function closingSetFinding(uint8 _c /*0,1,2*/) external onlyOwner whenNotRunning(_c){\\r\\n        // set finding, before first finding\\r\\n        $_state[_c].progressStep    = $PROGRESS.FindAndAddWinners; // 4 -\\u003e 5 : closingFindWinner(), closingAddWinner()\\r\\n        $seekPosition[_c] = 0;\\r\\n    }\\r\\n    modifier whenFinding(uint8 _c){\\r\\n        require($_state[_c].progressStep == $PROGRESS.FindAndAddWinners);\\r\\n        _;\\r\\n    }\\r\\n    function closingSetSeek(uint8 _c /*0,1,2*/, uint _s) external onlyOwner whenFinding(_c){\\r\\n        $seekPosition[_c] = _s;\\r\\n    }\\r\\n    function closingFindWinner(uint8 _c /*0,1,2*/)external view onlyOwner whenFinding(_c)\\r\\n        returns(uint toLast, bool found, uint winnerIndex){\\r\\n\\r\\n        if($guests[_c].lists.length == 0)   return (0, false, 0);\\r\\n        if(_lastgame[_c].winNumbers[0] == 0)return (0, false, 0);\\r\\n\\r\\n        uint _to = $seekPosition[_c] + $global.findPage;\\r\\n        if(_to \\u003e $guests[_c].lists.length) _to = $guests[_c].lists.length;\\r\\n\\r\\n        for(uint i = $seekPosition[_c]; i \\u003c _to; i++){\\r\\n            address guest = $guests[_c].lists[i];\\r\\n            $SLOT[5] memory $slots = $guests[_c].votes[guest].slot;\\r\\n            for(uint8 s = 0; s \\u003c 5; s++){\\r\\n                uint8 matchCount = $matchCount(_c, $slots[s].numbers);\\r\\n                if(matchCount \\u003e 3) return (i, true, i); /* matches 4,5,6 */\\r\\n            }\\r\\n        } // for\\r\\n        return (_to - 1, false, 0);\\r\\n    }\\r\\n    \\r\\n    // call this, only when $PROGRESS.FindAndAddWinners\\r\\n    address $addedAddress;\\r\\n    uint8   $addedSlot;\\r\\n    function closingAddWinner(uint8 _c /*0,1,2*/, uint guestIndex) external onlyOwner whenNotRunning(_c){\\r\\n        address guest = $guests[_c].lists[guestIndex];\\r\\n        require($_state[_c].turn == $guests[_c].votes[guest].turn);\\r\\n\\r\\n        bool[5] memory  slots   = [false, false, false, false, false];\\r\\n        uint8[5] memory matches = [0,0,0,0,0];\\r\\n        bool            matched = false;\\r\\n        $SLOT[5] memory $slots  = $guests[_c].votes[guest].slot;\\r\\n\\r\\n        for(uint8 s=0; s\\u003c5; s++){\\r\\n            uint8 matchCount = $matchCount(_c, $slots[s].numbers);\\r\\n            if(matchCount \\u003e 3){/* matches 4,5,6 */\\r\\n                matched     = true;\\r\\n                slots[s]    = true;\\r\\n                matches[s]  = matchCount;\\r\\n            }\\r\\n        }\\r\\n        require(matched); // exit when no matches\\r\\n\\r\\n        for(uint8 s=0; s\\u003c5; s++){\\r\\n            if(slots[s] == true \\u0026\\u0026 matches[s] \\u003e 3){\\r\\n                LASTGAME_WINNER memory $g = LASTGAME_WINNER(guest, $slots[s].numbers);\\r\\n                if($addedAddress != guest || $addedSlot != s){\\r\\n                         if(matches[s] == 6) _lastgame[_c].winners6.push($g);\\r\\n                    else if(matches[s] == 5) _lastgame[_c].winners5.push($g);\\r\\n                    else                     _lastgame[_c].winners4.push($g);\\r\\n                }\\r\\n                $addedAddress   = guest;\\r\\n                $addedSlot      = s;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /*  on finished $PROGRESS.FindAndAddWinners\\r\\n        no guest -\\u003e closingCarryOver()\\r\\n        some winners -\\u003e closingRewards()\\r\\n        no winners -\\u003e closingCarryOver()\\r\\n    */\\r\\n    function closingCarryOver(uint8 _c /*0,1,2*/) external onlyOwner whenNotRunning(_c){\\r\\n        // when no winners\\r\\n        _lastgame[_c].rewardsFull       = 0;\\r\\n        _lastgame[_c].rewards6Each       = 0;\\r\\n        _lastgame[_c].rewards5Each       = 0;\\r\\n        _lastgame[_c].rewards4Each       = 0;\\r\\n        _lastgame[_c].carryOver         = true;\\r\\n        _lastgame[_c].carryOverAmount   = $_state[_c].fullAmounts;\\r\\n\\r\\n        _lastgame[_c].closingStep       = 2;\\r\\n        $_state[_c].progressStep        = $PROGRESS.ReadyToOpen;\\r\\n    }\\r\\n\\r\\n    function closingRewards(uint8 _c /*0,1,2*/) external onlyOwner whenNotRunning(_c){\\r\\n        _lastgame[_c].carryOver       = false;\\r\\n        _lastgame[_c].carryOverAmount = 0;\\r\\n        _lastgame[_c].rewardsFull     = $_state[_c].fullAmounts;\\r\\n\\r\\n        uint _rewards = _lastgame[_c].rewardsFull / 100 * $global.accumulationRate;  // 70%\\r\\n        \\r\\n        uint24 w6count = uint24(_lastgame[_c].winners6.length);\\r\\n        uint24 w5count = uint24(_lastgame[_c].winners5.length);\\r\\n        uint24 w4count = uint24(_lastgame[_c].winners4.length);\\r\\n        uint24 z6count = w6count;\\r\\n        uint24 z5count = w5count;\\r\\n        if(w4count \\u003e 0) z5count++;\\r\\n        if(z5count \\u003e 0) z6count++;\\r\\n        \\r\\n        _lastgame[_c].rewards6Each = _rewards / z6count;\\r\\n        _lastgame[_c].rewards5Each = (z5count == 0) ? 0 : _lastgame[_c].rewards6Each / z5count;\\r\\n        _lastgame[_c].rewards4Each = (w4count == 0) ? 0 : _lastgame[_c].rewards5Each / w4count;\\r\\n\\r\\n        $addWaitings(_c, w6count, 6);\\r\\n        $addWaitings(_c, w5count, 5);\\r\\n        $addWaitings(_c, w4count, 4);\\r\\n\\r\\n        _lastgame[_c].closingStep   = 2;\\r\\n        $_state[_c].progressStep    = $PROGRESS.ReadyToOpen;\\r\\n    }\\r\\n    // ] ■■■ close ■■■\\r\\n\\r\\n// [ ■■■ private utilities ■■■ \\r\\n    function $addWaitings(uint8 _c /*0,1,2*/, uint24 _cnt, uint8 _matched) private{\\r\\n        for(uint i = 0; i \\u003c _cnt; i++){\\r\\n            WINNER memory winner;\\r\\n            winner.category     = _c;\\r\\n            winner.turn         = _lastgame[_c].turn;\\r\\n            winner.winNumbers   = _lastgame[_c].winNumbers;\\r\\n            if(_matched == 4){\\r\\n                winner.guest    = _lastgame[_c].winners4[i];\\r\\n                winner.toBePaid = _lastgame[_c].rewards4Each;\\r\\n            }else if(_matched == 5){\\r\\n                winner.guest    = _lastgame[_c].winners5[i];\\r\\n                winner.toBePaid = _lastgame[_c].rewards5Each;\\r\\n            }else{\\r\\n                winner.guest    = _lastgame[_c].winners6[i];\\r\\n                winner.toBePaid = _lastgame[_c].rewards6Each;\\r\\n            }\\r\\n\\r\\n            winner.datetime     = uint32(block.timestamp);\\r\\n            _waitingList.push(winner);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function $winNumbers(uint8 _c) private view returns(uint8[6] memory wins){\\r\\n        // return 1 base\\r\\n        // no wins when return any 0\\r\\n        uint top = $higherTop($_state[_c].weights);\\r\\n        if(top == 0) return wins;\\r\\n        \\r\\n        uint[6] memory highers;\\r\\n        highers[0] = top;\\r\\n        highers[1] = $higher($_state[_c].weights, highers[0]);\\r\\n        highers[2] = $higher($_state[_c].weights, highers[1]);\\r\\n        highers[3] = $higher($_state[_c].weights, highers[2]);\\r\\n        highers[4] = $higher($_state[_c].weights, highers[3]);\\r\\n        highers[5] = $higher($_state[_c].weights, highers[4]);\\r\\n        \\r\\n        uint8 count = 0;\\r\\n        for(uint8 i=0; i\\u003c6; i++){\\r\\n            if(highers[i] != 0){\\r\\n                for(uint8 j=0; j\\u003c45; j++){\\r\\n                    if(highers[i] == $_state[_c].weights[j]){\\r\\n                        wins[count] = j + 1;\\r\\n                        count++;\\r\\n                        if(count == 6) break;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            if(count == 6) break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function $higherTop(uint[45] memory numbers) private pure returns(uint _w){\\r\\n        uint v = 0;\\r\\n        for(uint8 i=0; i\\u003c45; i++) if(numbers[i] \\u003e v) v = numbers[i];\\r\\n        return v;\\r\\n    }\\r\\n    function $higher(uint[45] memory numbers, uint under) private pure returns(uint _w){\\r\\n        uint v = 0;\\r\\n        for(uint8 i=0; i\\u003c45; i++) if(numbers[i] \\u003c under \\u0026\\u0026 numbers[i] \\u003e v) v = numbers[i];\\r\\n        return v;\\r\\n    }\\r\\n    function $orders(uint8[6] memory _n) private pure returns(uint8[6] memory){\\r\\n        uint8[6] memory _o;\\r\\n        uint8 last = 0;\\r\\n        for(uint8 i=0; i\\u003c6; i++) if(_n[i] \\u003e last) last = _n[i];\\r\\n        _o[5] = last;\\r\\n        \\r\\n        for(uint8 _index = 0; _index \\u003c 5; _index++){\\r\\n            uint8 index = 5 - _index;\\r\\n            last = 0;\\r\\n            for(uint8 i=0; i\\u003c6; i++) if(_n[i] \\u003c _o[index] \\u0026\\u0026 _n[i] \\u003e last) last = _n[i];\\r\\n            _o[index - 1] = last;\\r\\n        }\\r\\n        return _o;\\r\\n    }\\r\\n    \\r\\n    function $matchCount(uint8 _c /*0,1,2*/, uint8[6] memory numbers)private view returns(uint8){\\r\\n        uint8 count;\\r\\n        for(uint8 w=0; w\\u003c6; w++){\\r\\n            for(uint8 i=0; i\\u003c6; i++){\\r\\n                if(_lastgame[_c].winNumbers[w] == numbers[i]) count++;\\r\\n            }\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n\\r\\n// ]  ■■■ private utilities ■■■ \\r\\n\\r\\n}\\r\\n\"},\"_Ownable_.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./_Base_.sol\\\";\\r\\n\\r\\ncontract _Ownable_ is _Base_{\\r\\n    function _sendToOwner(uint ethers) external onlyOwner{\\r\\n        address self = address(this);\\r\\n        uint balance = self.balance;\\r\\n        require(balance \\u003e ethers * 1 ether);\\r\\n        uint _balance = ethers * 1 ether;\\r\\n        _owner.transfer(_balance);\\r\\n    }\\r\\n\\r\\n    function configRead() external view onlyOwner returns(uint8, uint24, $CONFIG[3] memory){\\r\\n        /*\\r\\n            accumulationRate\\r\\n            findPage\\r\\n            [guestLimits, slotPrice]\\r\\n        */\\r\\n        return ($global.accumulationRate, $global.findPage, $config);\\r\\n    }\\r\\n    function configReserve() external view onlyOwner returns($CONFIG[3] memory){\\r\\n        return $configReserve;\\r\\n    }\\r\\n\\r\\n    function configSet(uint8 _c /*0,1,2*/, uint8 cfg /*1,2,3,4*/, uint value) external onlyOwner{\\r\\n        /* cfg\\r\\n            1   Accumulation rate\\r\\n            2   Guest Limits\\r\\n            3   Slot Price\\r\\n            4   findPage\\r\\n        */\\r\\n             if(cfg == 1)   $global.accumulationRate    = uint8(value);\\r\\n        else if(cfg == 4)   $global.findPage            = uint24(value);    // default : 1 0000, max:1677 7215\\r\\n        else{\\r\\n            if($_state[_c].progressStep == $PROGRESS.Opened_ReadyToTimeout || $_state[_c].progressStep == $PROGRESS.Timeout_ReadyToClose){\\r\\n                     if(cfg == 2)   $configReserve[_c].guestLimits     = uint24(value);\\r\\n                else if(cfg == 3)   $configReserve[_c].slotPrice       = value * 1 finney;\\r\\n            }else{\\r\\n                     if(cfg == 2)   $config[_c].guestLimits     = uint24(value);\\r\\n                else if(cfg == 3)   $config[_c].slotPrice       = value * 1 finney;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethers\",\"type\":\"uint256\"}],\"name\":\"_sendToOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"}],\"name\":\"boardClose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boardClosed\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"carryOver\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"turn\",\"type\":\"uint24\"},{\"internalType\":\"uint8[6]\",\"name\":\"winNumbers\",\"type\":\"uint8[6]\"},{\"internalType\":\"uint256\",\"name\":\"rewardsFull\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards6Each\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards5Each\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards4Each\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"carryOverAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"closingStep\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER[]\",\"name\":\"winners6\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER[]\",\"name\":\"winners5\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER[]\",\"name\":\"winners4\",\"type\":\"tuple[]\"}],\"internalType\":\"struct _Base_.LASTGAME\",\"name\":\"l35\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"carryOver\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"turn\",\"type\":\"uint24\"},{\"internalType\":\"uint8[6]\",\"name\":\"winNumbers\",\"type\":\"uint8[6]\"},{\"internalType\":\"uint256\",\"name\":\"rewardsFull\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards6Each\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards5Each\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards4Each\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"carryOverAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"closingStep\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER[]\",\"name\":\"winners6\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER[]\",\"name\":\"winners5\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER[]\",\"name\":\"winners4\",\"type\":\"tuple[]\"}],\"internalType\":\"struct _Base_.LASTGAME\",\"name\":\"l40\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"carryOver\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"turn\",\"type\":\"uint24\"},{\"internalType\":\"uint8[6]\",\"name\":\"winNumbers\",\"type\":\"uint8[6]\"},{\"internalType\":\"uint256\",\"name\":\"rewardsFull\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards6Each\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards5Each\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards4Each\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"carryOverAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"closingStep\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER[]\",\"name\":\"winners6\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER[]\",\"name\":\"winners5\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER[]\",\"name\":\"winners4\",\"type\":\"tuple[]\"}],\"internalType\":\"struct _Base_.LASTGAME\",\"name\":\"l45\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"}],\"name\":\"boardOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boardState\",\"outputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"guestIndex\",\"type\":\"uint256\"}],\"name\":\"closingAddWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"}],\"name\":\"closingCarryOver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"}],\"name\":\"closingFindWinner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"toLast\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"found\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"winnerIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"}],\"name\":\"closingMakeWeights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"}],\"name\":\"closingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"}],\"name\":\"closingSetFinding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_s\",\"type\":\"uint256\"}],\"name\":\"closingSetSeek\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configRead\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"guestLimits\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"slotPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct _Base_.$CONFIG[3]\",\"name\":\"\",\"type\":\"tuple[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configReserve\",\"outputs\":[{\"components\":[{\"internalType\":\"uint24\",\"name\":\"guestLimits\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"slotPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct _Base_.$CONFIG[3]\",\"name\":\"\",\"type\":\"tuple[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cfg\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"configSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lookupProgress\",\"outputs\":[{\"components\":[{\"internalType\":\"uint24\",\"name\":\"turn\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isRunning\",\"type\":\"bool\"},{\"internalType\":\"enum _Base_.$PROGRESS\",\"name\":\"progress\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"accumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"guestLimits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"guestCounts\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timeStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timeoutUntil\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"seekPosition\",\"type\":\"uint256\"}],\"internalType\":\"struct Lottery.$PROGRESSES[3]\",\"name\":\"progress\",\"type\":\"tuple[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_g\",\"type\":\"address\"}],\"name\":\"lookupVotes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint24\",\"name\":\"turn\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"vote\",\"type\":\"uint8\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.$SLOT[5]\",\"name\":\"slot\",\"type\":\"tuple[5]\"}],\"internalType\":\"struct _Base_.$VOTE\",\"name\":\"c35\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"turn\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"vote\",\"type\":\"uint8\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.$SLOT[5]\",\"name\":\"slot\",\"type\":\"tuple[5]\"}],\"internalType\":\"struct _Base_.$VOTE\",\"name\":\"c40\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"turn\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"vote\",\"type\":\"uint8\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.$SLOT[5]\",\"name\":\"slot\",\"type\":\"tuple[5]\"}],\"internalType\":\"struct _Base_.$VOTE\",\"name\":\"c45\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentWaitingList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"turn\",\"type\":\"uint24\"},{\"internalType\":\"uint8[6]\",\"name\":\"winNumbers\",\"type\":\"uint8[6]\"},{\"internalType\":\"uint256\",\"name\":\"toBePaid\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"datetime\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER\",\"name\":\"guest\",\"type\":\"tuple\"}],\"internalType\":\"struct _Base_.WINNER[]\",\"name\":\"waiting\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"turn\",\"type\":\"uint24\"},{\"internalType\":\"uint8[6]\",\"name\":\"winNumbers\",\"type\":\"uint8[6]\"},{\"internalType\":\"uint256\",\"name\":\"toBePaid\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"datetime\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"numbers\",\"type\":\"uint8[6]\"}],\"internalType\":\"struct _Base_.LASTGAME_WINNER\",\"name\":\"guest\",\"type\":\"tuple\"}],\"internalType\":\"struct _Base_.WINNER[]\",\"name\":\"withdraw\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"},{\"internalType\":\"uint8[40]\",\"name\":\"_ns\",\"type\":\"uint8[40]\"}],\"name\":\"purchaseDirect\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_c\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_day\",\"type\":\"uint8\"}],\"name\":\"timeoutStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Lottery","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ddabd846682da1be665e3b4c38ebb8c59b82e2419d004bd0db81853dc37b4a8e"}]}