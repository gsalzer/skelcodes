{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity =0.6.11;\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        require(y > 0);\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    //rounds to zero if x*y < RAY / 2\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    //rounds to zero if x*y < RAY / 2\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeApprove: approve failed'\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeTransfer: transfer failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::transferFrom: transferFrom failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ncontract HedgehogERC20 is IERC20 {\r\n    using SafeMath for uint;\r\n    \r\n    string public override name;\r\n    string public override symbol;\r\n    uint8 public override decimals;\r\n    uint  public override totalSupply;\r\n    mapping(address => uint) public override balanceOf;\r\n    mapping(address => mapping(address => uint)) public override allowance;\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract Hedgehog is HedgehogERC20{\r\n  using SafeMath for uint256;\r\n\r\n  bool public initialized;\r\n  address public asset;\r\n\r\n  uint256 public timestamp;\r\n  uint256 public oracle;\r\n  uint256 public oracle_prev;\r\n\r\n  event Deposit(address indexed from, uint256 asset_value, uint256 token_value);\r\n  event Withdraw(address indexed from, uint256 asset_value, uint256 token_value);\r\n  event Oracle(uint256 timestamp, uint256 new_price, uint256 old_price);\r\n\r\n  uint256 private unlocked = 1;\r\n  modifier lock() {\r\n      require(unlocked == 1, 'Hedgehog: LOCKED');\r\n      unlocked = 0;\r\n      _;\r\n      unlocked = 1;\r\n  }\r\n\r\n  function initialize(address _asset) public {\r\n      require(initialized == false, \"Hedgehog_initialize: already initialized\");\r\n      asset = _asset;\r\n      initialized = true;\r\n      string memory _name = IERC20(asset).name();\r\n      name = append(\"Hedgehog \", _name);\r\n      string memory _symbol = IERC20(asset).symbol();\r\n      symbol = append(\"h\", _symbol);\r\n      decimals = 5;\r\n  }\r\n\r\n  function price() public view returns (uint256) {\r\n      uint256 token_price = calculateAssetIn(1e5);\r\n      return token_price;\r\n  }\r\n  \r\n  function deposit(uint256 token_amount, uint256 expected_assets) public lock {\r\n      uint256 asset_deposit = calculateAssetIn(token_amount);\r\n      require(asset_deposit > 0, \"Hedgehog_Deposit: zero asset deposit\"); \r\n      require(asset_deposit <= expected_assets, \"Hedgehog_Deposit: deposit assets above expected\");\r\n      _oracle();\r\n      TransferHelper.safeTransferFrom(asset, msg.sender, address(this), asset_deposit); \r\n      _mint(msg.sender, token_amount);\r\n      Deposit(msg.sender, asset_deposit, token_amount);\r\n  }\r\n\r\n  function withdraw(uint256 token_amount, uint256 expected_assets) public lock {\r\n      uint256 asset_withdraw = calculateAssetOut(token_amount);\r\n      require(asset_withdraw > 0, \"Hedgehog_withdraw: zero asset withdraw\"); \r\n      require(asset_withdraw >= expected_assets, \"Hedgehog_Deposit: withdraw assets below expected\");\r\n      _oracle();\r\n      _burn(msg.sender, token_amount);\r\n      TransferHelper.safeTransfer(asset, msg.sender, asset_withdraw);\r\n      Withdraw(msg.sender, asset_withdraw, token_amount);\r\n  }\r\n\r\n  function calculateAssetIn(uint256 token_amount) public view returns (uint256) {\r\n      uint256 asset_balance = IERC20(asset).balanceOf(address(this));\r\n      uint256 token_balance_new = totalSupply.add(token_amount);\r\n      uint256 asset_balance_new = token_balance_new.mul(token_balance_new);\r\n      return asset_balance_new.sub(asset_balance);\r\n  }\r\n\r\n  function calculateAssetOut(uint256 token_amount) public view returns (uint256) {\r\n      uint256 asset_balance = IERC20(asset).balanceOf(address(this));\r\n      uint256 token_balance_new = totalSupply.sub(token_amount);\r\n      uint256 asset_balance_new = token_balance_new.mul(token_balance_new);\r\n      return asset_balance.sub(asset_balance_new);\r\n  }\r\n\r\n  function _oracle() internal {\r\n      if (timestamp < block.timestamp && totalSupply > 0){\r\n          timestamp = block.timestamp;\r\n          oracle_prev = oracle;\r\n          oracle = price();\r\n          Oracle(timestamp, oracle, oracle_prev);\r\n      }\r\n  }\r\n\r\n  function append(string memory a, string memory b) internal pure returns (string memory) {\r\n      return string(abi.encodePacked(a, b));\r\n  }\r\n}\r\n\r\ncontract HedgehogFactory {\r\n\r\n    mapping(address =>  address) public hedgehog;\r\n    address[] public allHedgehogs;\r\n \r\n    function allHedgehogsLength() external view returns (uint) {\r\n        return allHedgehogs.length;\r\n    }\r\n    function createHedgehog(address asset) public returns (address) {\r\n        require(asset != address(0), \"HedgehogFactory: zero asset\");\r\n        require(hedgehog[asset] == address(0), \"HedgehogFactory: existing hedgehog\");\r\n        Hedgehog _hedgehog = new Hedgehog();\r\n        hedgehog[asset] = address(_hedgehog);\r\n        allHedgehogs.push(address(_hedgehog));\r\n        _hedgehog.initialize(asset);\r\n        return address(_hedgehog);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allHedgehogs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allHedgehogsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"createHedgehog\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hedgehog\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"HedgehogFactory","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://18417cca1ed3f558957da0156ac3a722cdb1e4ec6197380963a00731259a0f2a"}]}