{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DEOR.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\r\\n\\r\\nimport \\\"./library/SafeMathDEOR.sol\\\";\\r\\nimport \\\"./library/Ownable.sol\\\";\\r\\nimport \\\"./interfaces/IDEOR.sol\\\";\\r\\n\\r\\ncontract DEOR is IDEOR, Ownable {\\r\\n\\r\\n    using SafeMathDEOR for uint256;\\r\\n\\r\\n    mapping(address => uint256) _balances;\\r\\n    mapping (address => mapping (address => uint256)) _allowed;\\r\\n\\r\\n    string private _name = \\\"DEOR\\\";\\r\\n    string private _symbol = \\\"DEOR\\\";\\r\\n    uint256 private _decimals = 10;\\r\\n    uint256 private _totalSupply;\\r\\n    uint256 private _maxSupply = 100000000 * (10**_decimals);\\r\\n    bool public mintingFinished = false;\\r\\n\\tuint256 public startTime = 1488294000;\\r\\n\\r\\n    constructor() public {}\\r\\n\\r\\n    receive () external payable {\\r\\n        revert();\\r\\n    }\\r\\n\\r\\n    function name() public view virtual returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual returns (uint256) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override(IDEOR) returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _owner) external view override(IDEOR) returns (uint256) {\\r\\n        return _balances[_owner];\\r\\n    }\\r\\n\\r\\n    function transfer(address _to, uint256 _value) external override(IDEOR) returns (bool) {\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(_value);\\r\\n        _balances[_to] = _balances[_to].add(_value);\\r\\n\\r\\n        emit Transfer(msg.sender, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address _from, address _to, uint256 _value) external override(IDEOR) returns (bool) {\\r\\n        uint256 _allowance = _allowed[_from][msg.sender];\\r\\n\\r\\n        _allowed[_from][msg.sender] = _allowance.sub(_value);\\r\\n        _balances[_to] = _balances[_to].add(_value);\\r\\n        _balances[_from] = _balances[_from].sub(_value);\\r\\n\\r\\n        emit Transfer(_from, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address _spender, uint256 _value) external override(IDEOR) returns (bool) {\\r\\n        _allowed[msg.sender][_spender] = _value;\\r\\n        emit Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address _owner, address _spender) external view override(IDEOR) returns (uint256) {\\r\\n        return _allowed[_owner][_spender];\\r\\n    }\\r\\n\\r\\n\\r\\n    modifier canMint() {\\r\\n        require(!mintingFinished);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * Function to mint tokens\\r\\n    * @param _to The address that will recieve the minted tokens.\\r\\n    * @param _amount The amount of tokens to mint.\\r\\n    * @return A boolean that indicates if the operation was successful.\\r\\n    */\\r\\n    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\\r\\n        uint256 amount = _maxSupply.sub(_totalSupply);\\r\\n        if (amount > _amount) {\\r\\n            amount = _amount;\\r\\n        }\\r\\n        else {\\r\\n            mintingFinished = true;\\r\\n            emit MintFinished();\\r\\n        }\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[_to] = _balances[_to].add(amount);\\r\\n        emit Mint(_to, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * Function to stop minting new tokens.\\r\\n    * @return True if the operation was successful.\\r\\n    */\\r\\n    function finishMinting() public onlyOwner returns (bool) {\\r\\n        mintingFinished = true;\\r\\n        emit MintFinished();\\r\\n        return true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/library/SafeMathDEOR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// pragma solidity ^0.7.0;\\r\\npragma solidity >=0.6.6;\\r\\n// pragma solidity >=0.4.21 <0.6.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMathDEOR {\\r\\n  /**\\r\\n    * @dev Returns the addition of two unsigned integers, reverting on\\r\\n    * overflow.\\r\\n    *\\r\\n    * Counterpart to Solidity's `+` operator.\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - Addition cannot overflow.\\r\\n    */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n    * overflow (when the result is negative).\\r\\n    *\\r\\n    * Counterpart to Solidity's `-` operator.\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - Subtraction cannot overflow.\\r\\n    */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n    * overflow.\\r\\n    *\\r\\n    * Counterpart to Solidity's `*` operator.\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - Multiplication cannot overflow.\\r\\n    */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n    // benefit is lost if 'b' is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n    * division by zero. The result is rounded towards zero.\\r\\n    *\\r\\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n    * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - The divisor cannot be zero.\\r\\n    */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Solidity only automatically asserts when dividing by 0\\r\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n    * Reverts when dividing by zero.\\r\\n    *\\r\\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n    * invalid opcode to revert (consuming all remaining gas).\\r\\n    *\\r\\n    * Requirements:\\r\\n    * - The divisor cannot be zero.\\r\\n    */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\r\\n    return a % b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the ceiling of log_2,\\r\\n    *\\r\\n    */\\r\\n  function log_2(uint256 x) internal pure returns (uint256) {\\r\\n    uint256 idx = 1;\\r\\n    uint256 res = 0;\\r\\n    while (x > idx) {\\r\\n      idx = idx << 1;\\r\\n      res = add(res, 1);\\r\\n    }\\r\\n    return res;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/library/Ownable.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\r\\n\\r\\ncontract Ownable {\\r\\n    address public owner;\\r\\n    address public devAddr = address(0x7e9f1f3F25515F0421D44d23cC98f76bdA1db2D1);\\r\\n    address public treasury = address(0x92126534bc8448de051FD9Cb8c54C31b82525669);\\r\\n\\r\\n    /**\\r\\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n    * account.\\r\\n    */\\r\\n    constructor() public {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n    * @dev Throws if called by any account other than the owner.\\r\\n    */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n    * @param newOwner The address to transfer ownership to.\\r\\n    */\\r\\n    function transferOwnership(address newOwner, address newDev) public onlyOwner {\\r\\n        if (newOwner != address(0)) {\\r\\n            owner = newOwner;\\r\\n        }\\r\\n        if (newDev != address(0)) {\\r\\n            devAddr = newDev;\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDEOR.sol\": {\r\n      \"content\": \"// pragma solidity >=0.4.21 <0.6.0;\\r\\npragma solidity >=0.6.6;\\r\\n\\r\\ninterface IDEOR {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n    function transfer(address _to, uint256 _value) external returns (bool);\\r\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\r\\n    function approve(address _spender, uint256 _value) external returns (bool);\\r\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\r\\n\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n    event Mint(address indexed to, uint256 amount);\\r\\n    event MintFinished();\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DEOR","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}