{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  @authors: [@mtsalenc]\r\n *  @reviewers: []\r\n *  @auditors: []\r\n *  @bounties: []\r\n *  @deployments: []\r\n */\r\n\r\npragma solidity 0.8.0;\r\n\r\n/** @title TokenDecimalsView\r\n *  Utility view contract to fetch token decimals in batches.\r\n */\r\ncontract TokenDecimalsView {\r\n    \r\n    function getTokenDecimals(address[] calldata _tokens) external view returns (uint[] memory decimals) {\r\n        decimals = new uint[](_tokens.length);\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            address tokenAddress = _tokens[i];\r\n            // Call the contract's decimals() function without reverting when\r\n            // the contract does not implement it.\r\n            // \r\n            // Two things should be noted: if the contract does not implement the function\r\n            // and does not implement the contract fallback function, `success` will be set to\r\n            // false and decimals won't be set. However, in some cases (such as old contracts) \r\n            // the fallback function is implemented, and so staticcall will return true\r\n            // even though the value returned will not be correct (the number below):\r\n            // \r\n            // 22270923699561257074107342068491755213283769984150504402684791726686939079929\r\n            //\r\n            // We handle that edge case by also checking against this value.\r\n            uint returnedDecimals;\r\n            bool success;\r\n            bytes4 sig = bytes4(keccak256(\"decimals()\"));\r\n            assembly {\r\n                let x := mload(0x40)   // Find empty storage location using \"free memory pointer\"\r\n                mstore(x, sig)          // Set the signature to the first call parameter. 0x313ce567 === bytes4(keccak256(\"decimals()\")\r\n                success := staticcall(\r\n                    30000,              // 30k gas\r\n                    tokenAddress,       // The call target.\r\n                    x,                  // Inputs are stored at location x\r\n                    0x04,               // Input is 4 bytes long\r\n                    x,                  // Overwrite x with output\r\n                    0x20                // The output length\r\n                )\r\n                \r\n                returnedDecimals := mload(x)   \r\n            }\r\n            if (success && returnedDecimals != 22270923699561257074107342068491755213283769984150504402684791726686939079929) {\r\n                decimals[i] = returnedDecimals;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"getTokenDecimals\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"decimals\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenDecimalsView","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5b5648569d2d86ea7b59b3dd109304bee7644cc77f40b109d6eed9e34e1008d8"}]}