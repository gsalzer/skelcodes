{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/aaveV2/automatic/AaveSubscriptionsProxyV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../auth/ProxyPermission.sol\\\";\\nimport \\\"../../interfaces/IAaveSubscription.sol\\\";\\n\\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\\ncontract AaveSubscriptionsProxyV2 is ProxyPermission {\\n\\n    string public constant NAME = \\\"AaveSubscriptionsProxyV2\\\";\\n\\n    address public constant AAVE_SUBSCRIPTION_ADDRESS = 0x6B25043BF08182d8e86056C6548847aF607cd7CD;\\n    address public constant AAVE_MONITOR_PROXY = 0x380982902872836ceC629171DaeAF42EcC02226e;\\n\\n    /// @notice Calls subscription contract and creates a DSGuard if non existent\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalRatioBoost Ratio amount which boost should target\\n    /// @param _optimalRatioRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function subscribe(\\n        uint128 _minRatio,\\n        uint128 _maxRatio,\\n        uint128 _optimalRatioBoost,\\n        uint128 _optimalRatioRepay,\\n        bool _boostEnabled\\n    ) public {\\n        givePermission(AAVE_MONITOR_PROXY);\\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(\\n            _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\\n    }\\n\\n    /// @notice Calls subscription contract and updated existing parameters\\n    /// @dev If subscription is non existent this will create one\\n    /// @param _minRatio Minimum ratio below which repay is triggered\\n    /// @param _maxRatio Maximum ratio after which boost is triggered\\n    /// @param _optimalRatioBoost Ratio amount which boost should target\\n    /// @param _optimalRatioRepay Ratio amount which repay should target\\n    /// @param _boostEnabled Boolean determing if boost is enabled\\n    function update(\\n        uint128 _minRatio,\\n        uint128 _maxRatio,\\n        uint128 _optimalRatioBoost,\\n        uint128 _optimalRatioRepay,\\n        bool _boostEnabled\\n    ) public {\\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(_minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\\n    }\\n\\n    /// @notice Calls the subscription contract to unsubscribe the caller\\n    function unsubscribe() public {\\n        removePermission(AAVE_MONITOR_PROXY);\\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).unsubscribe();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/auth/ProxyPermission.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../DS/DSGuard.sol\\\";\\nimport \\\"../DS/DSAuth.sol\\\";\\n\\ncontract ProxyPermission {\\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\\n\\n    /// @notice Called in the context of DSProxy to authorize an address\\n    /// @param _contractAddr Address which will be authorized\\n    function givePermission(address _contractAddr) public {\\n        address currAuthority = address(DSAuth(address(this)).authority());\\n        DSGuard guard = DSGuard(currAuthority);\\n\\n        if (currAuthority == address(0)) {\\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\\n        }\\n\\n        guard.permit(_contractAddr, address(this), bytes4(keccak256(\\\"execute(address,bytes)\\\")));\\n    }\\n\\n    /// @notice Called in the context of DSProxy to remove authority of an address\\n    /// @param _contractAddr Auth address which will be removed from authority list\\n    function removePermission(address _contractAddr) public {\\n        address currAuthority = address(DSAuth(address(this)).authority());\\n        \\n        // if there is no authority, that means that contract doesn't have permission\\n        if (currAuthority == address(0)) {\\n            return;\\n        }\\n\\n        DSGuard guard = DSGuard(currAuthority);\\n        guard.forbid(_contractAddr, address(this), bytes4(keccak256(\\\"execute(address,bytes)\\\")));\\n    }\\n\\n    function proxyOwner() internal returns(address) {\\n        return DSAuth(address(this)).owner();\\n    } \\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveSubscription.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nabstract contract IAaveSubscription {\\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) public virtual;\\n    function unsubscribe() public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract DSGuard {\\n    function canCall(address src_, address dst_, bytes4 sig) public view virtual returns (bool);\\n\\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\\n\\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\\n\\n    function permit(address src, address dst, bytes32 sig) public virtual;\\n\\n    function forbid(address src, address dst, bytes32 sig) public virtual;\\n}\\n\\n\\nabstract contract DSGuardFactory {\\n    function newGuard() public virtual returns (DSGuard guard);\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSAuth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./DSAuthority.sol\\\";\\n\\n\\ncontract DSAuthEvents {\\n    event LogSetAuthority(address indexed authority);\\n    event LogSetOwner(address indexed owner);\\n}\\n\\n\\ncontract DSAuth is DSAuthEvents {\\n    DSAuthority public authority;\\n    address public owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        emit LogSetOwner(msg.sender);\\n    }\\n\\n    function setOwner(address owner_) public auth {\\n        owner = owner_;\\n        emit LogSetOwner(owner);\\n    }\\n\\n    function setAuthority(DSAuthority authority_) public auth {\\n        authority = authority_;\\n        emit LogSetAuthority(address(authority));\\n    }\\n\\n    modifier auth {\\n        require(isAuthorized(msg.sender, msg.sig));\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n        if (src == address(this)) {\\n            return true;\\n        } else if (src == owner) {\\n            return true;\\n        } else if (authority == DSAuthority(0)) {\\n            return false;\\n        } else {\\n            return authority.canCall(src, address(this), sig);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DS/DSAuthority.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\nabstract contract DSAuthority {\\n    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"AAVE_MONITOR_PROXY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AAVE_SUBSCRIPTION_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FACTORY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddr\",\"type\":\"address\"}],\"name\":\"givePermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddr\",\"type\":\"address\"}],\"name\":\"removePermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_minRatio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_maxRatio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_optimalRatioBoost\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_optimalRatioRepay\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"_boostEnabled\",\"type\":\"bool\"}],\"name\":\"subscribe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unsubscribe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_minRatio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_maxRatio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_optimalRatioBoost\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_optimalRatioRepay\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"_boostEnabled\",\"type\":\"bool\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AaveSubscriptionsProxyV2","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}