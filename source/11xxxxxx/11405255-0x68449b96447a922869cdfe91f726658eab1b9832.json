{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: Open Source\r\npragma solidity ^0.6.0;\r\n\r\ncontract DTM {\r\n    using SafeMath for uint256;\r\n    \r\n    /*==============================\r\n    =            DTM EVENTS            =\r\n    ==============================*/\r\n    \r\n    \r\n    event Approved(\r\n        address indexed spender,\r\n        address indexed recipient,\r\n        uint256 tokens\r\n    );\r\n\r\n     event Buy(\r\n         address indexed buyer,\r\n         uint256 tokensTransfered,\r\n         uint256 tokenToTransfer,\r\n         uint256 referralBal\r\n     );\r\n     \r\n      event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    \r\n     event Sells(\r\n         address indexed seller,\r\n         uint256 calculatedEtherTransfer,\r\n         uint256 tokens\r\n     );\r\n     \r\n     event stake(\r\n         address indexed staker,\r\n         uint256 amount,\r\n         uint256 timing\r\n     );\r\n     \r\n     string public token_name;\r\n     string public token_symbol;\r\n     uint8 public decimal;\r\n    \r\n    uint256 public token_price = 85000000000000;\r\n\r\n    uint256 public basePrice1 = 85000000000000;\r\n    uint256 public basePrice2 = 150000000000000;\r\n    uint256 public basePrice3 = 850000000000000;\r\n    uint256 public basePrice4 = 6800000000000000;\r\n    uint256 public basePrice5 = 34000000000000000;\r\n    \r\n     uint256 public initialPriceIncrement = 0;\r\n    \r\n     uint256 public currentPrice;\r\n     uint8 internal countAdd = 1;\r\n     uint256 public totalSupply_;\r\n     uint256 public tokenSold = 186000;\r\n     \r\n     address payable owner;\r\n     address stakeHolder;\r\n    \r\n     mapping(address => uint256) public tokenLedger;\r\n     mapping(address => address) public gen_tree;\r\n     mapping(address => uint256) public levelIncome;\r\n     mapping(address => uint256) public mode;\r\n     \r\n     mapping(address => uint256) public lastTimeSell;\r\n     mapping(address => uint256) public firstTimeBuy;\r\n     mapping(address => uint256) public all_time_selling;\r\n     mapping(address => uint256) public sold;\r\n     \r\n     mapping(address => uint256) public buy_monthly;\r\n     mapping(address => mapping(address => uint256)) public allowed;\r\n     \r\n     \r\n    \r\n     modifier onlyOwner {\r\n         require(msg.sender == owner, \"Caller is not the owner\");\r\n        _;\r\n     }\r\n    \r\n     constructor(string memory _tokenName, string memory _tokenSymbol, uint256 initialSupply) public  {\r\n        owner = msg.sender;\r\n        stakeHolder = owner;\r\n        token_name = _tokenName;\r\n        token_symbol = _tokenSymbol;\r\n        decimal = 0;\r\n        currentPrice = token_price + initialPriceIncrement;\r\n        totalSupply_ = initialSupply;\r\n        tokenLedger[owner] = tokenSold;\r\n    }\r\n    \r\n    function contractAddress() public view returns(address) {\r\n        return address(this);\r\n    }\r\n    \r\n    function get_level_income(address _customerAddress) external view returns(uint256) {\r\n        return levelIncome[_customerAddress];\r\n    }\r\n    \r\n    function get_total_earning(address _customerAddress) public view returns(uint256) {\r\n        return levelIncome[_customerAddress];\r\n    }\r\n        \r\n    function updateCurrentPrice(uint256 _newPrice) external onlyOwner returns (bool) {\r\n          currentPrice = _newPrice;\r\n          return true;\r\n    }\r\n    \r\n    \r\n    function getTaxedEther(uint256 incomingEther) public pure returns(uint256) {\r\n        uint256 deduction = incomingEther * 3000 / 100000;\r\n        uint256 taxedEther = incomingEther - deduction;\r\n        return taxedEther;\r\n    }\r\n    \r\n    \r\n    function etherToToken(uint256 incomingEtherWei) public view returns(uint256)  {\r\n        uint256 tokenToTransfer = incomingEtherWei.div(currentPrice);\r\n        return tokenToTransfer;\r\n    }\r\n\r\n    \r\n    function tokenToEther(uint256 tokenToSell) public view returns(uint256)  {\r\n        uint256 convertedEther = tokenToSell * currentPrice;\r\n        return convertedEther;\r\n    }\r\n\r\n     \r\n     function taxedTokenTransfer(uint256 incomingEther) internal view returns(uint256) {\r\n        uint256 deduction = incomingEther * 3000/100000;\r\n        uint256 taxedEther = incomingEther - deduction;\r\n        uint256 tokenToTransfer = taxedEther.div(currentPrice);\r\n        return tokenToTransfer;\r\n    }\r\n    \r\n    function balanceOf(address _customerAddress) external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenLedger[_customerAddress];\r\n    }\r\n    \r\n    function getCurrentPrice() public view returns(uint) {\r\n         return currentPrice;\r\n    }\r\n     \r\n    function name() public view returns(string memory) {\r\n        return token_name;\r\n    }\r\n\r\n\r\n     function symbol() public view returns(string memory) {\r\n         return token_symbol;\r\n     }\r\n\r\n    function decimals() public view returns(uint8){\r\n            return decimal;\r\n     }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n          return totalSupply_;\r\n    }\r\n    \r\n    function stake_funds()  public view returns(uint256) {\r\n        return tokenLedger[stakeHolder];\r\n    }\r\n    \r\n    \r\n    function setName(string memory _name)\r\n        onlyOwner\r\n        public\r\n    {\r\n        token_name = _name;\r\n    }\r\n   \r\n    function setSymbol(string memory _symbol)\r\n        onlyOwner\r\n        public\r\n    {\r\n        token_symbol = _symbol;\r\n    }\r\n    \r\n    \r\n    function add_level_income( address user, uint256 numberOfTokens) public returns(bool) {\r\n         \r\n         uint256 token_income1;\r\n         uint256 token_income2;\r\n         \r\n             if(numberOfTokens >= 1000 && numberOfTokens < 5000){\r\n                 token_income1 = 50;\r\n                 token_income2 = 25;    \r\n             }else if(numberOfTokens >= 5000 && numberOfTokens <  10000){\r\n                 token_income1 = 75;\r\n                 token_income2 = 37;\r\n             }else if(numberOfTokens >= 10000 && numberOfTokens <  25000){\r\n                 token_income1 = 100;\r\n                 token_income2 = 50;\r\n             }else if(numberOfTokens >= 25000 && numberOfTokens <  50000){\r\n                 token_income1 = 150;\r\n                 token_income2 = 75;\r\n             }else if(numberOfTokens >= 50000 ){\r\n                 token_income1 = 200;\r\n                 token_income2 = 100;\r\n             }else{\r\n                 return false;\r\n             }    \r\n          \r\n         \r\n         \r\n         address referral;\r\n         uint256 commission;\r\n         \r\n          for( uint i = 0 ; i < 2; i++ ){\r\n            referral = gen_tree[user];\r\n            \r\n            if(referral == address(0)) break;\r\n            \r\n            uint256 convertedEther = tokenLedger[referral] * currentPrice;\r\n            \r\n            // Minimum 0.04 - $24\r\n            if( convertedEther >= 40000000000000000 ){\r\n                if(i == 0){\r\n                   commission = token_income1.div(countAdd);\r\n                }else if(i == 1){\r\n                   commission = token_income2.div(countAdd);\r\n                }\r\n                \r\n                \r\n                levelIncome[referral] = levelIncome[referral].add(commission);\r\n            }\r\n            user = referral; \r\n        }\r\n    }\r\n    \r\n     \r\n     \r\n    function buy_token(address _referredBy ) external payable returns(bool) {\r\n         \r\n         address buyer = msg.sender;\r\n\r\n         require(_referredBy != msg.sender, \"Self reference not allowed\");\r\n         \r\n         uint256 etherValue = msg.value;\r\n         uint256 taxedTokenAmount = taxedTokenTransfer(etherValue);\r\n         uint256 tokenToTransfer = etherValue.div(currentPrice);\r\n\r\n         require(etherValue >= 84000000000000000, \"Minimum purchase limit is 0.084 ETH\");\r\n         require(buyer != address(0), \"Can't send to Zero address\");\r\n         uint256 referralTokenBal = tokenLedger[_referredBy];\r\n         \r\n         \r\n         uint256 tokenGiving = tokenSold + tokenToTransfer;\r\n         require(tokenGiving <= totalSupply_, \"Token Supply exceeded\");\r\n         \r\n         if(mode[buyer] == 0) {\r\n            gen_tree[buyer] = _referredBy;   \r\n            mode[buyer] = 1;\r\n         }\r\n         \r\n         add_level_income( buyer, tokenToTransfer);    \r\n     \r\n         emit Transfer(address(this), buyer, taxedTokenAmount);\r\n         tokenLedger[buyer] = tokenLedger[buyer].add(taxedTokenAmount);\r\n         tokenSold = tokenSold.add(tokenToTransfer);\r\n         \r\n         buy_monthly[buyer] = buy_monthly[buyer].add(taxedTokenAmount);\r\n         \r\n         priceAlgoBuy();\r\n         emit Buy(buyer,taxedTokenAmount, tokenToTransfer, referralTokenBal);\r\n         \r\n         if( firstTimeBuy[buyer] > 0 ) return true; \r\n         else firstTimeBuy[buyer] = block.timestamp;\r\n\r\n         return true;\r\n     }\r\n    \r\n    function sell( uint256 tokenToSell ) external returns(bool){\r\n        \r\n          require( tokenSold >= tokenToSell, \"Token sold should be greater than zero\");\r\n          require( msg.sender != address(0), \"address zero\");\r\n          require( tokenToSell <= tokenLedger[msg.sender], \"insufficient balance\");\r\n          require( tokenToSell >= 10, \"Sold limit is 10 token\");\r\n          uint256 deduction = tokenToSell * 3 / 100;\r\n          uint256 payable_token = tokenToSell - deduction;\r\n          uint256 convertedWei = etherValueTransfer(payable_token);\r\n      //Start.... .. \r\n          uint256 selling_limit = buy_monthly[msg.sender] * 30 / 100;\r\n\r\n         if( tokenToSell <= selling_limit ){\r\n             \r\n             uint256 sold_by_user = sold[msg.sender] + tokenToSell;\r\n             \r\n             if( sold_by_user <= selling_limit ){\r\n                 \r\n                   sold[msg.sender] = sold[msg.sender].add(tokenToSell);\r\n                 \r\n                 //--------------------END.\r\n                   tokenLedger[msg.sender] = tokenLedger[msg.sender].sub(tokenToSell);\r\n                   tokenSold = tokenSold.sub( tokenToSell );\r\n                   priceAlgoSell();\r\n                   msg.sender.transfer(convertedWei);\r\n                   emit Transfer(msg.sender, address(this), payable_token);\r\n                   emit Sells(msg.sender,convertedWei, tokenToSell);\r\n                   \r\n                 \r\n             }else{\r\n                revert(\"Selling Limit Exceeded.Try again With Less tokens.\");\r\n             }\r\n                 \r\n         }else{\r\n             revert(\"Selling Limit Exceeded.Try again With Less coins.\");\r\n         }\r\n          return true;\r\n     }\r\n     \r\n     \r\n     function extend_time() public  {\r\n         if(block.timestamp >= firstTimeBuy[msg.sender] + 30 days) \r\n          {\r\n              firstTimeBuy[msg.sender] = block.timestamp;\r\n              buy_monthly[msg.sender] = tokenLedger[msg.sender];\r\n              sold[msg.sender] = 0;\r\n          }\r\n     }\r\n    \r\n    function getFirstTimeBuying() external view returns(uint256) {\r\n        return firstTimeBuy[msg.sender];\r\n    }\r\n    \r\n    function getFirstBuyTime(address _customerAddress) public view returns(uint256) {\r\n        return firstTimeBuy[_customerAddress];\r\n    }\r\n     \r\n     \r\n    function etherValueTransfer(uint256 tokenToSell) public view returns(uint256) {\r\n        uint256 convertedEther = tokenToSell * currentPrice;\r\n        return convertedEther;\r\n     }\r\n      \r\n     \r\n     function totalEthereumBalance() external onlyOwner view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n     \r\n    \r\n    function mintToken(uint256 _mintedAmount) onlyOwner public {\r\n        totalSupply_ = totalSupply_.add(_mintedAmount);\r\n        countAdd++;\r\n    }\r\n    \r\n     function destruct() onlyOwner() public{\r\n        selfdestruct(owner);\r\n    }\r\n    \r\n    \r\n    function withdrawReward(uint256 numberOfTokens, address _customerAddress)\r\n        onlyOwner\r\n        public\r\n    {\r\n        tokenLedger[_customerAddress] = tokenLedger[_customerAddress].add(numberOfTokens);\r\n    }\r\n    \r\n    \r\n    function withdraw_bal(uint256 numberOfTokens, address _customerAddress)\r\n        public returns(bool)\r\n    {\r\n      require(numberOfTokens >= 10, \"Minimum withdrawal is 10 token\");\r\n      require(_customerAddress != address(0), \"address zero\");\r\n      require(numberOfTokens <= levelIncome[_customerAddress], \"insufficient bonus\");\r\n      levelIncome[_customerAddress] = levelIncome[_customerAddress].sub(numberOfTokens);\r\n      tokenLedger[_customerAddress] = tokenLedger[_customerAddress].add(numberOfTokens);\r\n      return true;\r\n    }\r\n    \r\n    \r\n    function holdStake(uint256 _amount, uint256 _timing)\r\n        public\r\n    {\r\n           address _customerAddress = msg.sender;\r\n           require(_amount <= tokenLedger[_customerAddress], \"insufficient balance\");\r\n           require(_amount >= 20, \"Minimum stake limit is 20\");\r\n           tokenLedger[_customerAddress] = tokenLedger[_customerAddress].sub(_amount);\r\n           tokenLedger[stakeHolder] = tokenLedger[stakeHolder].add(_amount);\r\n           emit stake(_customerAddress, _amount, _timing);\r\n     }\r\n       \r\n    function unstake(uint256 _amount, address _customerAddress)\r\n        onlyOwner\r\n        public\r\n    {\r\n        tokenLedger[_customerAddress] = tokenLedger[_customerAddress].add(_amount);\r\n        tokenLedger[stakeHolder] = tokenLedger[stakeHolder].sub(_amount);\r\n    }\r\n    \r\n    \r\n    function alot_tokens(uint256 _amountOfTokens, address _toAddress) onlyOwner public returns(bool) {\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfTokens <= tokenLedger[_customerAddress]);\r\n        \r\n        tokenLedger[_customerAddress] = tokenLedger[_customerAddress].sub(_amountOfTokens);\r\n        tokenLedger[_toAddress] = tokenLedger[_toAddress].add(_amountOfTokens);\r\n        return true;\r\n    }\r\n    \r\n\r\n     function transfer(address _toAddress, uint256 _amountOfTokens) onlyOwner\r\n        public\r\n        returns(bool)\r\n      {\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfTokens <= tokenLedger[_customerAddress]);\r\n        \r\n        tokenLedger[_customerAddress] = tokenLedger[_customerAddress].sub(_amountOfTokens);\r\n        tokenLedger[_toAddress] = tokenLedger[_toAddress].add(_amountOfTokens);\r\n        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function transferFrom(address _from, address _to, uint256 tokens) public returns(bool success)  {\r\n        require(tokens <= tokenLedger[_from]);\r\n        require(tokens > 0);\r\n        require(tokens <= allowed[_from][msg.sender]);\r\n        \r\n        tokenLedger[_from] = tokenLedger[_from].sub(tokens);\r\n        tokenLedger[_to] = tokenLedger[_to].add(tokens);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(tokens);\r\n        emit Transfer(_from, _to, tokens);\r\n        return true;\r\n    }\r\n    \r\n    \r\n   function priceAlgoBuy() internal{\r\n\r\n    if( tokenSold > 0 && tokenSold <= 336000 ){\r\n        currentPrice = basePrice1;\r\n        basePrice1 = currentPrice;\r\n    }\r\n\r\n    if( tokenSold > 336000 && tokenSold <= 486000 ){\r\n        currentPrice = basePrice2;\r\n        basePrice2 = currentPrice;\r\n    }\r\n\r\n    if( tokenSold > 486000 && tokenSold <= 636000 ){\r\n        currentPrice = basePrice3;\r\n        basePrice3 = currentPrice;\r\n    }\r\n\r\n    if(tokenSold > 636000 && tokenSold <= 786000){\r\n        currentPrice = basePrice4;\r\n        basePrice4 = currentPrice;\r\n    }\r\n    if(tokenSold > 786000){\r\n        currentPrice = basePrice5;\r\n        basePrice5 = currentPrice;\r\n    }\r\n}\r\n\r\n\r\n function priceAlgoSell( ) internal{\r\n\r\n    \r\n    if( tokenSold > 0 && tokenSold <= 336000 ){\r\n        currentPrice = basePrice1;\r\n        basePrice1 = currentPrice;\r\n    }\r\n\r\n    if( tokenSold > 336000 && tokenSold <= 486000 ){\r\n        currentPrice = basePrice2;\r\n        basePrice2 = currentPrice;\r\n    }\r\n    \r\n    if( tokenSold > 486000 && tokenSold <= 636000 ){\r\n        currentPrice = basePrice3;\r\n        basePrice3 = currentPrice;\r\n    }\r\n\r\n    \r\n    if(tokenSold > 636000 && tokenSold <= 786000){\r\n        \r\n        currentPrice = basePrice4;\r\n        basePrice4 = currentPrice;\r\n    }\r\n    \r\n    if(tokenSold > 786000){\r\n        currentPrice = basePrice5;\r\n        basePrice5 = currentPrice;\r\n    }\r\n   }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensTransfered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenToTransfer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralBal\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"calculatedEtherTransfer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Sells\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timing\",\"type\":\"uint256\"}],\"name\":\"stake\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"add_level_income\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"all_time_selling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"}],\"name\":\"alot_tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice4\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice5\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"buy_monthly\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy_token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimal\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"incomingEtherWei\",\"type\":\"uint256\"}],\"name\":\"etherToToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenToSell\",\"type\":\"uint256\"}],\"name\":\"etherValueTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extend_time\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"firstTimeBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gen_tree\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"getFirstBuyTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFirstTimeBuying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"incomingEther\",\"type\":\"uint256\"}],\"name\":\"getTaxedEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"get_level_income\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"get_total_earning\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timing\",\"type\":\"uint256\"}],\"name\":\"holdStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialPriceIncrement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastTimeSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"levelIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenToSell\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stake_funds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenLedger\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenToSell\",\"type\":\"uint256\"}],\"name\":\"tokenToEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"updateCurrentPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"withdraw_bal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DTM","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000e4840000000000000000000000000000000000000000000000000000000000000000844544d20434f494e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000344544d0000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://294ec24c900544ce83143c459ca1ddc6ec197248af5cac9b5791bfd38baae83e"}]}