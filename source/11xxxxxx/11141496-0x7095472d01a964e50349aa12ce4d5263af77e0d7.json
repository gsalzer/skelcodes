{"status":"1","message":"OK","result":[{"SourceCode":"#@version 0.2.7\r\n\r\nAPI_VERSION: constant(String[28]) = \"0.1.2\"\r\n\r\n# TODO: Add ETH Configuration\r\n# TODO: Add Delegated Configuration\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\ninterface DetailedERC20:\r\n    def name() -> String[42]: view\r\n    def symbol() -> String[20]: view\r\n    def decimals() -> uint256: view\r\n\r\ninterface Strategy:\r\n    def strategist() -> address: view\r\n    def estimatedTotalAssets() -> uint256: view\r\n    def withdraw(_amount: uint256): nonpayable\r\n    def migrate(_newStrategy: address): nonpayable\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\ndecimals: public(uint256)\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\ntotalSupply: public(uint256)\r\n\r\ntoken: public(ERC20)\r\ngovernance: public(address)\r\nguardian: public(address)\r\npendingGovernance: address\r\n\r\nstruct StrategyParams:\r\n    performanceFee: uint256  # Strategist's fee (basis points)\r\n    activation: uint256  # Activation block.number\r\n    debtLimit: uint256  # Maximum borrow amount\r\n    rateLimit: uint256  # Increase/decrease per block\r\n    lastReport: uint256  # block.number of the last time a report occured\r\n    totalDebt: uint256  # Total outstanding debt that Strategy has\r\n    totalReturns: uint256  # Total returns that Strategy has realized for Vault\r\n\r\nevent StrategyAdded:\r\n    strategy: indexed(address)\r\n    debtLimit: uint256  # Maximum borrow amount\r\n    rateLimit: uint256  # Increase/decrease per block\r\n    performanceFee: uint256  # Strategist's fee (basis points)\r\n\r\nevent StrategyReported:\r\n    strategy: indexed(address)\r\n    returnAdded: uint256\r\n    debtAdded: uint256\r\n    totalReturn: uint256\r\n    totalDebt: uint256\r\n    debtLimit: uint256\r\n\r\n# NOTE: Track the total for overhead targeting purposes\r\nstrategies: public(HashMap[address, StrategyParams])\r\nMAXIMUM_STRATEGIES: constant(uint256) = 20\r\n\r\n# Ordering that `withdraw` uses to determine which strategies to pull funds from\r\n# NOTE: Does *NOT* have to match the ordering of all the current strategies that\r\n#       exist, but it is recommended that it does or else withdrawal depth is\r\n#       limited to only those inside the the queue.\r\n# NOTE: Ordering is determined by governance, and should be balanced according\r\n#       to risk, slippage, and/or volitility. Can also be ordered to increase the\r\n#       withdrawal speed of a particular strategy.\r\n# NOTE: The first time a ZERO_ADDRESS is encountered, it stops withdrawing\r\nwithdrawalQueue: public(address[MAXIMUM_STRATEGIES])\r\n\r\nemergencyShutdown: public(bool)\r\n\r\ndepositLimit: public(uint256)  # Limit for totalAssets the Vault can hold\r\ndebtLimit: public(uint256)  # Debt limit for the Vault across all strategies\r\ntotalDebt: public(uint256)  # Amount of tokens that all strategies have borrowed\r\nlastReport: public(uint256)  # Number of blocks since last report\r\n\r\nrewards: public(address)  # Rewards contract where Governance fees are sent to\r\nmanagementFee: public(uint256)  # Governance Fee for management of Vault (given to `rewards`)\r\nperformanceFee: public(uint256)  # Governance Fee for performance of Vault (given to `rewards`)\r\nFEE_MAX: constant(uint256) = 10_000  # 100%, or 10k basis points\r\nBLOCKS_PER_YEAR: constant(uint256) = 2_300_000\r\n\r\n@external\r\ndef __init__(\r\n    _token: address,\r\n    _governance: address,\r\n    _rewards: address,\r\n    _nameOverride: String[64],\r\n    _symbolOverride: String[32]\r\n):\r\n    # TODO: Non-detailed Configuration?\r\n    self.token = ERC20(_token)\r\n    if _nameOverride == \"\":\r\n        self.name = concat(DetailedERC20(_token).symbol(), \" yVault\")\r\n    else:\r\n        self.name = _nameOverride\r\n    if _symbolOverride == \"\":\r\n        self.symbol = concat(\"yv\", DetailedERC20(_token).symbol())\r\n    else:\r\n        self.symbol = _symbolOverride\r\n    self.decimals = DetailedERC20(_token).decimals()\r\n    self.governance = _governance\r\n    self.rewards = _rewards\r\n    self.guardian = msg.sender\r\n    self.performanceFee = 450  # 4.5% of yield (per strategy)\r\n    self.managementFee = 200  # 2% per year\r\n    self.depositLimit = MAX_UINT256  # Start unlimited\r\n    self.lastReport = block.number\r\n\r\n\r\n@pure\r\n@external\r\ndef apiVersion() -> String[28]:\r\n    return API_VERSION\r\n\r\n\r\n@external\r\ndef setName(_name: String[42]):\r\n    assert msg.sender == self.governance\r\n    self.name = _name\r\n\r\n\r\n@external\r\ndef setSymbol(_symbol: String[20]):\r\n    assert msg.sender == self.governance\r\n    self.symbol = _symbol\r\n\r\n\r\n# 2-phase commit for a change in governance\r\n@external\r\ndef setGovernance(_governance: address):\r\n    assert msg.sender == self.governance\r\n    self.pendingGovernance = _governance\r\n\r\n\r\n@external\r\ndef acceptGovernance():\r\n    assert msg.sender == self.pendingGovernance\r\n    self.governance = msg.sender\r\n\r\n\r\n@external\r\ndef setRewards(_rewards: address):\r\n    assert msg.sender == self.governance\r\n    self.rewards = _rewards\r\n\r\n\r\n@external\r\ndef setDepositLimit(_limit: uint256):\r\n    assert msg.sender == self.governance\r\n    self.depositLimit = _limit\r\n\r\n\r\n@external\r\ndef setPerformanceFee(_fee: uint256):\r\n    assert msg.sender == self.governance\r\n    self.performanceFee = _fee\r\n\r\n\r\n@external\r\ndef setManagementFee(_fee: uint256):\r\n    assert msg.sender == self.governance\r\n    self.managementFee = _fee\r\n\r\n\r\n@external\r\ndef setGuardian(_guardian: address):\r\n    assert msg.sender in [self.guardian, self.governance]\r\n    self.guardian = _guardian\r\n\r\n\r\n@external\r\ndef setEmergencyShutdown(_active: bool):\r\n    \"\"\"\r\n    Activates Vault mode where all Strategies go into full withdrawal\r\n    \"\"\"\r\n    assert msg.sender in [self.guardian, self.governance]\r\n    self.emergencyShutdown = _active\r\n\r\n\r\n@external\r\ndef setWithdrawalQueue(_queue: address[MAXIMUM_STRATEGIES]):\r\n    assert msg.sender == self.governance\r\n    # HACK: Temporary until Vyper adds support for Dynamic arrays\r\n    for i in range(MAXIMUM_STRATEGIES):\r\n        if _queue[i] == ZERO_ADDRESS and self.withdrawalQueue[i] == ZERO_ADDRESS:\r\n            break\r\n        assert self.strategies[_queue[i]].activation > 0\r\n        self.withdrawalQueue[i] = _queue[i]\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    # Protect people from accidentally sending their shares to bad places\r\n    assert not (_to in [self, ZERO_ADDRESS])\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n@external\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    if self.allowance[_from][msg.sender] < MAX_UINT256:  # Unlimited approval (saves an SSTORE)\r\n       self.allowance[_from][msg.sender] -= _value\r\n    self._transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Approve the passed address to spend the specified amount of tokens on behalf of\r\n         msg.sender. Beware that changing an allowance with this method brings the risk\r\n         that someone may use both the old and the new allowance by unfortunate transaction\r\n         ordering. See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will spend the funds.\r\n    @param _value The amount of tokens to be spent.\r\n    \"\"\"\r\n    self.allowance[msg.sender][_spender] = _value\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@view\r\n@internal\r\ndef _totalAssets() -> uint256:\r\n    return self.token.balanceOf(self) + self.totalDebt\r\n\r\n\r\n@view\r\n@external\r\ndef totalAssets() -> uint256:\r\n    return self._totalAssets()\r\n\r\n\r\n@view\r\n@internal\r\ndef _balanceSheetOfStrategy(_strategy: address) -> uint256:\r\n    return Strategy(_strategy).estimatedTotalAssets()\r\n\r\n\r\n@view\r\n@external\r\ndef balanceSheetOfStrategy(_strategy: address) -> uint256:\r\n    return self._balanceSheetOfStrategy(_strategy)\r\n\r\n\r\n@view\r\n@external\r\ndef totalBalanceSheet(_strategies: address[2 * MAXIMUM_STRATEGIES]) -> uint256:\r\n    \"\"\"\r\n    Measure the total balance sheet of this Vault, using the list of strategies\r\n    given above. (2x the expected maximum is used for safety's sake)\r\n    NOTE: The safety of this function depends *entirely* on the list of strategies\r\n          given as the function argument. Care should be taken to choose this list\r\n          to ensure that the estimate is accurate. No additional checking is used.\r\n    NOTE: Guardian should use this value vs. `totalAssets()` to determine\r\n          if a condition exists where the Vault is experiencing a dangerous\r\n          'balance sheet' attack, leading Vault shares to be worth less than\r\n          what their price on paper is (based on their debt)\r\n    \"\"\"\r\n    balanceSheet: uint256 = self.token.balanceOf(self)\r\n\r\n    for strategy in _strategies:\r\n        if strategy == ZERO_ADDRESS:\r\n            break\r\n        balanceSheet += self._balanceSheetOfStrategy(strategy)\r\n\r\n    return balanceSheet\r\n\r\n\r\n@internal\r\ndef _issueSharesForAmount(_to: address, _amount: uint256) -> uint256:\r\n    # NOTE: shares must be issued prior to taking on new collateral,\r\n    #       or calculation will be wrong. This means that only *trusted*\r\n    #       tokens (with no capability for exploitive behavior) can be used\r\n    shares: uint256 = 0\r\n    # HACK: Saves 2 SLOADs (~4000 gas)\r\n    totalSupply: uint256 = self.totalSupply\r\n    if totalSupply > 0:\r\n        # Mint amount of shares based on what the Vault is managing overall\r\n        shares = _amount * totalSupply / self._totalAssets()\r\n    else:\r\n        # No existing shares, so mint 1:1\r\n        shares = _amount\r\n\r\n    # Mint new shares\r\n    self.totalSupply = totalSupply + shares\r\n    self.balanceOf[_to] += shares\r\n    log Transfer(ZERO_ADDRESS, _to, shares)\r\n\r\n    return shares\r\n\r\n\r\n@external\r\ndef deposit(_amount: uint256 = MAX_UINT256, _recipient: address = msg.sender) -> uint256:\r\n    assert not self.emergencyShutdown  # Deposits are locked out\r\n\r\n    amount: uint256 = _amount\r\n\r\n    # If _amount not specified, transfer the full token balance\r\n    if amount == MAX_UINT256:\r\n        amount = self.token.balanceOf(msg.sender)\r\n\r\n    # Ensure we are depositing something\r\n    assert amount > 0\r\n\r\n    # Ensure deposit limit is respected\r\n    assert self._totalAssets() + amount <= self.depositLimit\r\n\r\n    # NOTE: Measuring this based on the total outstanding debt that this contract\r\n    #       has (\"expected value\") instead of the total balance sheet it has\r\n    #       (\"estimated value\") has important security considerations, and is\r\n    #       done intentionally. If this value were measured against external\r\n    #       systems, it could be purposely manipulated by an attacker to withdraw\r\n    #       more assets than they otherwise should be able to claim by redeeming\r\n    #       their shares.\r\n    #\r\n    #       On deposit, this means that shares are issued against the total amount\r\n    #       that the deposited capital can be given in service of the debt that\r\n    #       Strategies assume. If that number were to be lower than the \"expected value\"\r\n    #       at some future point, depositing shares via this method could entitle the\r\n    #       depositor to *less* than the deposited value once the \"realized value\" is\r\n    #       updated from further reportings by the Strategies to the Vaults.\r\n    #\r\n    #       Care should be taken by integrators to account for this discrepency,\r\n    #       by using the view-only methods of this contract (both off-chain and\r\n    #       on-chain) to determine if depositing into the Vault is a \"good idea\"\r\n\r\n    # Issue new shares (needs to be done before taking deposit to be accurate)\r\n    # Shares are issued to recipient (may be different from msg.sender)\r\n    shares: uint256 = self._issueSharesForAmount(_recipient, amount)\r\n\r\n    # Get new collateral\r\n    reserve: uint256 = self.token.balanceOf(self)\r\n    # Tokens are transferred from msg.sender (may be different from _recipient)\r\n    self.token.transferFrom(msg.sender, self, amount)\r\n    # TODO: `Deflationary` configuration only\r\n    assert self.token.balanceOf(self) - reserve == amount  # Deflationary token check\r\n\r\n    return shares  # Just in case someone wants them\r\n\r\n\r\n@view\r\n@internal\r\ndef _shareValue(_shares: uint256) -> uint256:\r\n    return (_shares * (self._totalAssets())) / self.totalSupply\r\n\r\n\r\n@view\r\n@internal\r\ndef _sharesForAmount(_amount: uint256) -> uint256:\r\n    if self._totalAssets() > 0:\r\n        return (_amount * self.totalSupply) / self._totalAssets()\r\n    else:\r\n        return 0\r\n\r\n\r\n@view\r\n@external\r\ndef maxAvailableShares() -> uint256:\r\n    shares: uint256 = self._sharesForAmount(self.token.balanceOf(self))\r\n\r\n    for strategy in self.withdrawalQueue:\r\n        if strategy == ZERO_ADDRESS:\r\n            break\r\n        shares += self._sharesForAmount(self.strategies[strategy].totalDebt)\r\n\r\n    return shares\r\n\r\n\r\n@external\r\ndef withdraw(_shares: uint256 = MAX_UINT256, _recipient: address = msg.sender) -> uint256:\r\n    shares: uint256 = _shares  # May reduce this number below\r\n\r\n    # If _shares not specified, transfer full share balance\r\n    if shares == MAX_UINT256:\r\n        shares = self.balanceOf[msg.sender]\r\n\r\n    # Limit to only the shares they own\r\n    assert shares <= self.balanceOf[msg.sender]\r\n\r\n    # NOTE: Measuring this based on the total outstanding debt that this contract\r\n    #       has (\"expected value\") instead of the total balance sheet it has\r\n    #       (\"estimated value\") has important security considerations, and is\r\n    #       done intentionally. If this value were measured against external\r\n    #       systems, it could be purposely manipulated by an attacker to withdraw\r\n    #       more assets than they otherwise should be able to claim by redeeming\r\n    #       their shares.\r\n    #\r\n    #       On withdrawal, this means that shares are redeemed against the total\r\n    #       amount that the deposited capital had \"realized\" since the point it\r\n    #       was deposited, up until the point it was withdrawn. If that number\r\n    #       were to be higher than the \"expected value\" at some future point,\r\n    #       withdrawing shares via this method could entitle the depositor to\r\n    #       *more* than the expected value once the \"realized value\" is updated\r\n    #       from further reportings by the Strategies to the Vaults.\r\n    #\r\n    #       Under exceptional scenarios, this could cause earlier withdrawals to\r\n    #       earn \"more\" of the underlying assets than Users might otherwise be\r\n    #       entitled to, if the Vault's estimated value were otherwise measured\r\n    #       through external means, accounting for whatever exceptional scenarios\r\n    #       exist for the Vault (that aren't covered by the Vault's own design)\r\n    value: uint256 = self._shareValue(shares)\r\n\r\n    if value > self.token.balanceOf(self):\r\n        # We need to go get some from our strategies in the withdrawal queue\r\n        # NOTE: This performs forced withdrawals from each strategy. There is\r\n        #       a 0.5% withdrawal fee assessed on each forced withdrawal (<= 0.5% total)\r\n        for strategy in self.withdrawalQueue:\r\n            if strategy == ZERO_ADDRESS:\r\n                break  # We've exhausted the queue\r\n\r\n            amountNeeded: uint256 = value - self.token.balanceOf(self)\r\n\r\n            if amountNeeded == 0:\r\n                break  # We're done withdrawing\r\n\r\n            # NOTE: Don't withdraw more than the debt so that strategy can still\r\n            #       continue to work based on the profits it has\r\n            # NOTE: This means that user will lose out on any profits that each\r\n            #       strategy in the queue would return on next harvest, benefitting others\r\n            amountNeeded = min(amountNeeded, self.strategies[strategy].totalDebt)\r\n            if amountNeeded == 0:\r\n                continue  # Nothing to withdraw from this strategy, try the next one\r\n\r\n            # Force withdraw amount from each strategy in the order set by governance\r\n            before: uint256 = self.token.balanceOf(self)\r\n            Strategy(strategy).withdraw(amountNeeded)\r\n            withdrawn: uint256 = self.token.balanceOf(self) - before\r\n\r\n            # Reduce the strategy's debt by the amount withdrawn (\"realized returns\")\r\n            # NOTE: This doesn't add to returns as it's not earned by \"normal means\"\r\n            self.strategies[strategy].totalDebt -= withdrawn\r\n            self.totalDebt -= withdrawn\r\n\r\n    # NOTE: We have withdrawn everything possible out of the withdrawal queue\r\n    #       but we still don't have enough to fully pay them back, so adjust\r\n    #       to the total amount we've freed up through forced withdrawals\r\n    if value > self.token.balanceOf(self):\r\n        value = self.token.balanceOf(self)\r\n        shares = self._sharesForAmount(value)\r\n\r\n    # Burn shares (full value of what is being withdrawn)\r\n    self.totalSupply -= shares\r\n    self.balanceOf[msg.sender] -= shares\r\n    log Transfer(msg.sender, ZERO_ADDRESS, shares)\r\n\r\n    # Withdraw remaining balance to _recipient (may be different to msg.sender) (minus fee)\r\n    self.token.transfer(_recipient, value)\r\n\r\n    return value\r\n\r\n\r\n@view\r\n@external\r\ndef pricePerShare() -> uint256:\r\n    return self._shareValue(10 ** self.decimals)\r\n\r\n\r\n@internal\r\ndef _organizeWithdrawalQueue():\r\n    # Reorganize based on premise that if there is an empty value between two\r\n    # actual values, then the empty value should be replaced by the later value\r\n    # NOTE: Relative ordering of non-zero values is maintained\r\n    offset: uint256 = 0\r\n    for idx in range(MAXIMUM_STRATEGIES):\r\n        strategy: address = self.withdrawalQueue[idx]\r\n        if strategy == ZERO_ADDRESS:\r\n            offset += 1  # how many values we need to shift, always `<= idx`\r\n        elif offset > 0:\r\n            self.withdrawalQueue[idx-offset] = strategy\r\n            self.withdrawalQueue[idx] = ZERO_ADDRESS\r\n\r\n\r\n@external\r\ndef addStrategy(\r\n    _strategy: address,\r\n    _debtLimit: uint256,\r\n    _rateLimit: uint256,\r\n    _performanceFee: uint256,\r\n):\r\n    assert msg.sender == self.governance\r\n    assert self.strategies[_strategy].activation == 0\r\n    self.strategies[_strategy] = StrategyParams({\r\n        performanceFee: _performanceFee,\r\n        activation: block.number,\r\n        debtLimit: _debtLimit,\r\n        rateLimit: _rateLimit,\r\n        lastReport: block.number,\r\n        totalDebt: 0,\r\n        totalReturns: 0,\r\n    })\r\n    self.debtLimit += _debtLimit\r\n    log StrategyAdded(_strategy, _debtLimit, _rateLimit, _performanceFee)\r\n\r\n    # queue is full\r\n    assert self.withdrawalQueue[MAXIMUM_STRATEGIES-1] == ZERO_ADDRESS\r\n    self.withdrawalQueue[MAXIMUM_STRATEGIES-1] = _strategy\r\n    self._organizeWithdrawalQueue()\r\n\r\n\r\n@external\r\ndef updateStrategyDebtLimit(\r\n    _strategy: address,\r\n    _debtLimit: uint256,\r\n):\r\n    assert msg.sender == self.governance\r\n    assert self.strategies[_strategy].activation > 0\r\n    self.debtLimit -= self.strategies[_strategy].debtLimit\r\n    self.strategies[_strategy].debtLimit = _debtLimit\r\n    self.debtLimit += _debtLimit\r\n\r\n\r\n@external\r\ndef updateStrategyRateLimit(\r\n    _strategy: address,\r\n    _rateLimit: uint256,\r\n):\r\n    assert msg.sender == self.governance\r\n    assert self.strategies[_strategy].activation > 0\r\n    self.strategies[_strategy].rateLimit = _rateLimit\r\n\r\n\r\n@external\r\ndef updateStrategyPerformanceFee(\r\n    _strategy: address,\r\n    _performanceFee: uint256,\r\n):\r\n    assert msg.sender == self.governance\r\n    assert self.strategies[_strategy].activation > 0\r\n    self.strategies[_strategy].performanceFee = _performanceFee\r\n\r\n\r\n@external\r\ndef migrateStrategy(_oldVersion: address, _newVersion: address):\r\n    \"\"\"\r\n    Only Governance can migrate a strategy to a new version\r\n    NOTE: Strategy must successfully migrate all capital and positions to\r\n          new Strategy, or else this will upset the balance of the Vault\r\n    NOTE: The new strategy should be \"empty\" e.g. have no prior commitments\r\n          to this Vault, otherwise it could have issues\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n\r\n    assert self.strategies[_oldVersion].activation > 0\r\n    assert self.strategies[_newVersion].activation == 0\r\n\r\n    strategy: StrategyParams = self.strategies[_oldVersion]\r\n    self.strategies[_oldVersion] = empty(StrategyParams)\r\n    self.strategies[_newVersion] = strategy\r\n\r\n    Strategy(_oldVersion).migrate(_newVersion)\r\n    # TODO: Ensure a smooth transition in terms of  strategy return\r\n\r\n    for idx in range(MAXIMUM_STRATEGIES):\r\n        if self.withdrawalQueue[idx] == _oldVersion:\r\n            self.withdrawalQueue[idx] = _newVersion\r\n            return  # Don't need to reorder anything because we swapped\r\n\r\n\r\n@external\r\ndef revokeStrategy(_strategy: address = msg.sender):\r\n    \"\"\"\r\n    Governance can revoke a strategy\r\n    OR\r\n    A strategy can revoke itself (Emergency Exit Mode)\r\n    \"\"\"\r\n    assert msg.sender in [_strategy, self.governance, self.guardian]\r\n    self.debtLimit -= self.strategies[_strategy].debtLimit\r\n    self.strategies[_strategy].debtLimit = 0\r\n\r\n\r\n@external\r\ndef addStrategyToQueue(_strategy: address):\r\n    assert msg.sender == self.governance\r\n    # Must be a current strategy\r\n    assert self.strategies[_strategy].activation > 0 and self.strategies[_strategy].totalDebt > 0\r\n    # Check if queue is full\r\n    assert self.withdrawalQueue[MAXIMUM_STRATEGIES-1] == ZERO_ADDRESS\r\n    # Can't already be in the queue\r\n    for strategy in self.withdrawalQueue:\r\n        if strategy == ZERO_ADDRESS:\r\n            break\r\n        assert strategy != _strategy\r\n    self.withdrawalQueue[MAXIMUM_STRATEGIES-1] = _strategy\r\n    self._organizeWithdrawalQueue()\r\n\r\n\r\n@external\r\ndef removeStrategyFromQueue(_strategy: address):\r\n    # NOTE: We don't do this with revokeStrategy because it should still\r\n    #       be possible to withdraw from it if it's unwinding\r\n    assert msg.sender == self.governance\r\n    for idx in range(MAXIMUM_STRATEGIES):\r\n        if self.withdrawalQueue[idx] == _strategy:\r\n            self.withdrawalQueue[idx] = ZERO_ADDRESS\r\n            self._organizeWithdrawalQueue()\r\n            return  # We found the right location and cleared it\r\n    raise  # We didn't find the strategy in the queue\r\n\r\n\r\n@view\r\n@internal\r\ndef _debtOutstanding(_strategy: address) -> uint256:\r\n    \"\"\"\r\n    Amount of tokens in strtaegy that Vault wants to recall\r\n    \"\"\"\r\n    strategy_debtLimit: uint256 = self.strategies[_strategy].debtLimit\r\n    strategy_totalDebt: uint256 = self.strategies[_strategy].totalDebt\r\n\r\n    if self.emergencyShutdown:\r\n        return strategy_totalDebt\r\n    elif strategy_totalDebt <= strategy_debtLimit:\r\n        return 0\r\n    else:\r\n        return strategy_totalDebt - strategy_debtLimit\r\n\r\n\r\n@view\r\n@external\r\ndef debtOutstanding(_strategy: address = msg.sender) -> uint256:\r\n    return self._debtOutstanding(_strategy)\r\n\r\n\r\n@view\r\n@internal\r\ndef _creditAvailable(_strategy: address) -> uint256:\r\n    \"\"\"\r\n    Amount of tokens in vault a strategy has access to as a credit line\r\n    \"\"\"\r\n    if self.emergencyShutdown:\r\n        return 0\r\n\r\n    strategy_debtLimit: uint256 = self.strategies[_strategy].debtLimit\r\n    strategy_totalDebt: uint256 = self.strategies[_strategy].totalDebt\r\n    strategy_rateLimit: uint256 = self.strategies[_strategy].rateLimit\r\n    strategy_lastReport: uint256 = self.strategies[_strategy].lastReport\r\n\r\n    # Exhausted credit line\r\n    if strategy_debtLimit <= strategy_totalDebt or self.debtLimit <= self.totalDebt:\r\n        return 0\r\n\r\n    # Start with debt limit left for the strategy\r\n    available: uint256 = strategy_debtLimit - strategy_totalDebt\r\n\r\n    # Adjust by the global debt limit left\r\n    available = min(available, self.debtLimit - self.totalDebt)\r\n\r\n    # Adjust by the rate limit algorithm (limits the step size per reporting period)\r\n    blockDelta: uint256 = block.number - strategy_lastReport\r\n    # NOTE: Protect against unnecessary overflow faults here\r\n    # NOTE: Set `strategy_rateLimit` to a really high number to disable the rate limit\r\n    # NOTE: *NEVER* set `strategy_rateLimit` to 0 or else this will always throw\r\n    if available / strategy_rateLimit >= blockDelta:\r\n        available = min(available, strategy_rateLimit * blockDelta)\r\n\r\n    # Can only borrow up to what the contract has in reserve\r\n    # NOTE: Running near 100% is discouraged\r\n    return min(available, self.token.balanceOf(self))\r\n\r\n\r\n@view\r\n@external\r\ndef creditAvailable(_strategy: address = msg.sender) -> uint256:\r\n    return self._creditAvailable(_strategy)\r\n\r\n\r\n@view\r\n@internal\r\ndef _expectedReturn(_strategy: address) -> uint256:\r\n    strategy_lastReport: uint256 = self.strategies[_strategy].lastReport\r\n    strategy_totalReturns: uint256 = self.strategies[_strategy].totalReturns\r\n    strategy_activation: uint256 = self.strategies[_strategy].activation\r\n\r\n    blockDelta: uint256 = (block.number - strategy_lastReport)\r\n    if blockDelta > 0:\r\n        return (strategy_totalReturns * blockDelta) / (block.number - strategy_activation)\r\n    else:\r\n        return 0  # Covers the scenario when block.number == strategy_activation\r\n\r\n\r\n@view\r\n@external\r\ndef expectedReturn(_strategy: address = msg.sender) -> uint256:\r\n    return self._expectedReturn(_strategy)\r\n\r\n\r\n@external\r\ndef report(_return: uint256) -> uint256:\r\n    \"\"\"\r\n    Strategies call this.\r\n    _return: amount Strategy has made on it's investment since its last report,\r\n             and is free to be given back to Vault as earnings\r\n    returns: amount of debt outstanding (iff totalDebt > debtLimit)\r\n    \"\"\"\r\n    # NOTE: For approved strategies, this is the most efficient behavior.\r\n    #       Strategy reports back what it has free (usually in terms of ROI)\r\n    #       and then Vault \"decides\" here whether to take some back or give it more.\r\n    #       Note that the most it can take is `_return`, and the most it can give is\r\n    #       all of the remaining reserves. Anything outside of those bounds is abnormal\r\n    #       behavior.\r\n    # NOTE: All approved strategies must have increased diligience around\r\n    #       calling this function, as abnormal behavior could become catastrophic\r\n\r\n    # Only approved strategies can call this function\r\n    assert self.strategies[msg.sender].activation > 0\r\n\r\n    # Outstanding debt the Vault wants to take back from the Strategy (if any)\r\n    debt: uint256 = self._debtOutstanding(msg.sender)\r\n\r\n    # Issue new shares to cover fees\r\n    # NOTE: In effect, this reduces overall share price by the combined fee\r\n    governance_fee: uint256 = (\r\n        self._totalAssets() * (block.number - self.lastReport) * self.managementFee\r\n    ) / FEE_MAX / BLOCKS_PER_YEAR\r\n    self.lastReport = block.number\r\n    strategist_fee: uint256 = 0  # Only applies in certain conditions\r\n\r\n    # NOTE: Applies if strategy is not shutting down, or it is but all debt paid off\r\n    # NOTE: No fee is taken when a strategy is unwinding it's position, until all debt is paid\r\n    if  _return > debt:\r\n        strategist_fee = (\r\n            (_return - debt) * self.strategies[msg.sender].performanceFee\r\n        ) / FEE_MAX\r\n        governance_fee += (_return - debt) * self.performanceFee / FEE_MAX\r\n\r\n    # NOTE: This must be called prior to taking new collateral,\r\n    #       or the calculation will be wrong!\r\n    # NOTE: This must be done at the same time, to ensure the relative\r\n    #       ratio of governance_fee : strategist_fee is kept intact\r\n    total_fee: uint256 = governance_fee + strategist_fee\r\n    reward: uint256 = self._issueSharesForAmount(self, total_fee)\r\n\r\n    # Send the rewards out as new shares in this Vault\r\n    if strategist_fee > 0:\r\n        strategist_reward: uint256 = (strategist_fee * reward) / total_fee\r\n        self._transfer(self, Strategy(msg.sender).strategist(), strategist_reward)\r\n    # NOTE: Governance earns any dust leftover from flooring math above\r\n    self._transfer(self, self.rewards, self.balanceOf[self])\r\n\r\n    # Compute the line of credit the Vault is able to offer the Strategy (if any)\r\n    credit: uint256 = self._creditAvailable(msg.sender)\r\n\r\n    # Give/take balance to Strategy, based on the difference between the return and\r\n    # the credit increase we are offering (if any)\r\n    # NOTE: This is just used to adjust the balance of tokens between the Strategy and\r\n    #       the Vault based on the strategy's debt limit (as well as the Vault's).\r\n    if _return < credit:  # credit surplus, give to strategy\r\n        self.token.transfer(msg.sender, credit - _return)\r\n    elif _return > credit:  # credit deficit, take from strategy\r\n        self.token.transferFrom(msg.sender, self, _return - credit)\r\n\r\n    # else, don't do anything because it is performing well as is\r\n\r\n    # Update the actual debt based on the full credit we are extending to the Strategy\r\n    # or the returns if we are taking funds back\r\n    # NOTE: credit + self.strategies[msg.sender].totalDebt is always < self.debtLimit\r\n    # NOTE: At least one of `credit` or `debt` is always 0 (both can be 0)\r\n    if credit > 0:\r\n        self.strategies[msg.sender].totalDebt += credit\r\n        self.totalDebt += credit\r\n\r\n        # Returns are always \"realized gains\"\r\n        self.strategies[msg.sender].totalReturns += _return\r\n\r\n    elif debt > 0:  # We're repaying debt now, so there are no gains\r\n        if _return <= debt:\r\n            # Pay down our debt with profit\r\n            # NOTE: Cannot return more than you borrowed\r\n            self.strategies[msg.sender].totalDebt -= _return\r\n            self.totalDebt -= _return\r\n            debt -= _return  # Debt payment complete (to report back to strategy)\r\n\r\n        else:\r\n            # Finish off our debt payments here\r\n            self.totalDebt -= debt\r\n            self.strategies[msg.sender].totalDebt -= debt\r\n\r\n            # Returns are always \"realized gains\" (after we have paid off our debt)\r\n            self.strategies[msg.sender].totalReturns += _return - debt\r\n            debt = 0  # All debts paid off (to report back to strategy)\r\n\r\n    elif _return > 0:  # No debt to pay, nor credit to expand with, add to profit!\r\n        self.strategies[msg.sender].totalReturns += _return\r\n\r\n    # else, no credit/debt to manage, nor returns to report. Nothing really happened!\r\n\r\n    # Update reporting time\r\n    self.strategies[msg.sender].lastReport = block.number\r\n\r\n    log StrategyReported(\r\n        msg.sender,\r\n        _return,\r\n        credit,\r\n        self.strategies[msg.sender].totalReturns,\r\n        self.strategies[msg.sender].totalDebt,\r\n        self.strategies[msg.sender].debtLimit,\r\n    )\r\n\r\n    if self.strategies[msg.sender].totalDebt == 0 or self.emergencyShutdown:\r\n        # Take every last penny the Strategy has (Emergency Exit/revokeStrategy)\r\n        # NOTE: This is different than `debt` in order to extract *all* of the returns\r\n        return self._balanceSheetOfStrategy(msg.sender)\r\n    else:\r\n        # Otherwise, just return what we have as debt outstanding\r\n        return debt\r\n\r\n\r\n@internal\r\ndef erc20_safe_transfer(_token: address, _to: address, _value: uint256):\r\n    # HACK: Used to handle non-compliant tokens like USDT\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_to, bytes32),\r\n            convert(_value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Transfer failed!\"\r\n\r\n\r\n@external\r\ndef sweep(_token: address):\r\n    # Can't be used to steal what this Vault is protecting\r\n    assert _token != self.token.address\r\n    self.erc20_safe_transfer(_token, self.governance, ERC20(_token).balanceOf(self))","ABI":"[{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"sender\",\"indexed\":true},{\"type\":\"address\",\"name\":\"receiver\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StrategyAdded\",\"inputs\":[{\"type\":\"address\",\"name\":\"strategy\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"debtLimit\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"rateLimit\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"performanceFee\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StrategyReported\",\"inputs\":[{\"type\":\"address\",\"name\":\"strategy\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"returnAdded\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"debtAdded\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"totalReturn\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"totalDebt\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"debtLimit\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_token\"},{\"type\":\"address\",\"name\":\"_governance\"},{\"type\":\"address\",\"name\":\"_rewards\"},{\"type\":\"string\",\"name\":\"_nameOverride\"},{\"type\":\"string\",\"name\":\"_symbolOverride\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"apiVersion\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\",\"gas\":4489},{\"name\":\"setName\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_name\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":106987},{\"name\":\"setSymbol\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_symbol\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":71837},{\"name\":\"setGovernance\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_governance\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36308},{\"name\":\"acceptGovernance\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36234},{\"name\":\"setRewards\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_rewards\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36368},{\"name\":\"setDepositLimit\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_limit\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36298},{\"name\":\"setPerformanceFee\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_fee\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36328},{\"name\":\"setManagementFee\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_fee\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36358},{\"name\":\"setGuardian\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_guardian\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37715},{\"name\":\"setEmergencyShutdown\",\"outputs\":[],\"inputs\":[{\"type\":\"bool\",\"name\":\"_active\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37745},{\"name\":\"setWithdrawalQueue\",\"outputs\":[],\"inputs\":[{\"type\":\"address[20]\",\"name\":\"_queue\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":750014},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":76559},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":113994},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38154},{\"name\":\"totalAssets\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3763},{\"name\":\"balanceSheetOfStrategy\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2268},{\"name\":\"totalBalanceSheet\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address[40]\",\"name\":\"_strategies\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":72146},{\"name\":\"deposit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"deposit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"deposit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_recipient\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"maxAvailableShares\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":347071},{\"name\":\"withdraw\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"withdraw\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_shares\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"withdraw\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_shares\"},{\"type\":\"address\",\"name\":\"_recipient\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"pricePerShare\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":11031},{\"name\":\"addStrategy\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"},{\"type\":\"uint256\",\"name\":\"_debtLimit\"},{\"type\":\"uint256\",\"name\":\"_rateLimit\"},{\"type\":\"uint256\",\"name\":\"_performanceFee\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":1425403},{\"name\":\"updateStrategyDebtLimit\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"},{\"type\":\"uint256\",\"name\":\"_debtLimit\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":111376},{\"name\":\"updateStrategyRateLimit\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"},{\"type\":\"uint256\",\"name\":\"_rateLimit\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38428},{\"name\":\"updateStrategyPerformanceFee\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"},{\"type\":\"uint256\",\"name\":\"_performanceFee\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38452},{\"name\":\"migrateStrategy\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_oldVersion\"},{\"type\":\"address\",\"name\":\"_newVersion\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":1122369},{\"name\":\"revokeStrategy\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"revokeStrategy\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"addStrategyToQueue\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":1195362},{\"name\":\"removeStrategyFromQueue\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":23065728},{\"name\":\"debtOutstanding\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"debtOutstanding\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"creditAvailable\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"creditAvailable\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"expectedReturn\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"expectedReturn\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"report\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_return\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":455650},{\"name\":\"sweep\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_token\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":9721},{\"name\":\"name\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8843},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":7896},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2501},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2746},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"},{\"type\":\"address\",\"name\":\"arg1\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2991},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2591},{\"name\":\"token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2621},{\"name\":\"governance\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2651},{\"name\":\"guardian\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2681},{\"name\":\"strategies\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"performanceFee\"},{\"type\":\"uint256\",\"name\":\"activation\"},{\"type\":\"uint256\",\"name\":\"debtLimit\"},{\"type\":\"uint256\",\"name\":\"rateLimit\"},{\"type\":\"uint256\",\"name\":\"lastReport\"},{\"type\":\"uint256\",\"name\":\"totalDebt\"},{\"type\":\"uint256\",\"name\":\"totalReturns\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":9070},{\"name\":\"withdrawalQueue\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2850},{\"name\":\"emergencyShutdown\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2771},{\"name\":\"depositLimit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2801},{\"name\":\"debtLimit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2831},{\"name\":\"totalDebt\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2861},{\"name\":\"lastReport\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2891},{\"name\":\"rewards\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2921},{\"name\":\"managementFee\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2951},{\"name\":\"performanceFee\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2981}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000bb2b8038a1640196fbe3e38816f3e67cba72d940000000000000000000000000846e211e8ba920b353fb717631c015cf04061cc9000000000000000000000000feb4acf3df3cdea7399794d0869ef76a6efaff5200000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020556e697377617020763220574254432d5745544820506f6f6c20795661756c74000000000000000000000000000000000000000000000000000000000000000f7976556e692d574254432d574554480000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":""}]}