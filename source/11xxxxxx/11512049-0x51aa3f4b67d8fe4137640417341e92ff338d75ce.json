{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/staking/DonationsStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\n\\n/**\\n * @title DonationStaking contract that receives funds in ETH/DAI\\n * and stake them in the SimpleStaking contract\\n */\\ncontract DonationsStaking is Initializable {\\n\\taddress payable public avatar;\\n\\tStaking public stakingContract;\\n\\tcERC20 public DAI;\\n\\taddress public owner;\\n\\tUniswap public uniswap;\\n\\tbool public active;\\n\\tuint256 public totalETHDonated;\\n\\tuint256 public totalDAIDonated;\\n\\n\\tevent DonationStaked(\\n\\t\\taddress caller,\\n\\t\\tuint256 stakedDAI,\\n\\t\\tuint256 ethDonated,\\n\\t\\tuint256 daiDonated\\n\\t);\\n\\n\\tmodifier ownerOrAvatar() {\\n\\t\\trequire(\\n\\t\\t\\tmsg.sender == owner || msg.sender == avatar,\\n\\t\\t\\t\\\"Only owner or avatar can perform this action\\\"\\n\\t\\t);\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyAvatar() {\\n\\t\\trequire(\\n\\t\\t\\tmsg.sender == avatar,\\n\\t\\t\\t\\\"Only DAO avatar can perform this action\\\"\\n\\t\\t);\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier isActive() {\\n\\t\\trequire(active);\\n\\t\\t_;\\n\\t}\\n\\n\\treceive() external payable {}\\n\\n\\tfunction initialize(\\n\\t\\taddress payable _avatar,\\n\\t\\taddress _stakingContract,\\n\\t\\taddress _dai\\n\\t) public initializer {\\n\\t\\towner = msg.sender;\\n\\t\\tuniswap = Uniswap(address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D));\\n\\t\\tDAI = cERC20(_dai);\\n\\t\\tavatar = _avatar;\\n\\t\\tstakingContract = Staking(_stakingContract);\\n\\t\\tDAI.approve(\\n\\t\\t\\taddress(stakingContract),\\n\\t\\t\\t0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n\\t\\t); //we trust the staking contract\\n\\t\\tactive = true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev stake available funds. It\\n\\t * take balance in eth and buy DAI from uniswap then stake outstanding DAI balance.\\n\\t * anyone can call this.\\n\\t * @param _minDAIAmount enforce expected return from uniswap when converting eth balance to DAI\\n\\t */\\n\\tfunction stakeDonations(uint256 _minDAIAmount) public payable isActive {\\n\\t\\tuint256 daiDonated = DAI.balanceOf(address(this));\\n\\t\\tuint256 ethDonated = _buyDAI(_minDAIAmount);\\n\\n\\t\\tuint256 daiBalance = DAI.balanceOf(address(this));\\n\\t\\trequire(daiBalance > 0, \\\"no DAI to stake\\\");\\n\\n\\t\\tstakingContract.stakeDAI(daiBalance);\\n\\t\\ttotalETHDonated += ethDonated;\\n\\t\\ttotalDAIDonated += daiDonated;\\n\\t\\temit DonationStaked(msg.sender, daiBalance, ethDonated, daiDonated);\\n\\t}\\n\\n\\t/**\\n\\t * @dev total DAI value staked\\n\\t * @return DAI value staked\\n\\t */\\n\\tfunction totalStaked() public view returns (uint256) {\\n\\t\\tStaking.Staker memory staker = stakingContract.stakers(address(this));\\n\\t\\treturn staker.stakedDAI;\\n\\t}\\n\\n\\t/**\\n\\t * @dev internal method to buy DAI from uniswap\\n\\t * @param _minDAIAmount enforce expected return from uniswap when converting eth balance to DAI\\n\\t * @return eth value converted\\n\\t */\\n\\tfunction _buyDAI(uint256 _minDAIAmount) internal returns (uint256) {\\n\\t\\t//buy from uniwasp\\n\\t\\tuint256 ethBalance = address(this).balance;\\n\\t\\tif (ethBalance == 0) return 0;\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[1] = address(DAI);\\n\\t\\tpath[0] = uniswap.WETH();\\n\\t\\tuniswap.swapExactETHForTokens{ value: ethBalance }(\\n\\t\\t\\t_minDAIAmount,\\n\\t\\t\\tpath,\\n\\t\\t\\taddress(this),\\n\\t\\t\\tnow\\n\\t\\t);\\n\\t\\treturn ethBalance;\\n\\t}\\n\\n\\tfunction setActive(bool _active) public ownerOrAvatar {\\n\\t\\tactive = _active;\\n\\t}\\n\\n\\t/**\\n\\t * @dev withdraws all stakes and then transfer all balances to avatar\\n\\t * this can also be called by owner(Foundation) but it is safe as funds are transfered to avatarMock\\n\\t * and only avatar can upgrade this contract logic\\n\\t */\\n\\tfunction end() public ownerOrAvatar returns (uint256, uint256) {\\n\\t\\tstakingContract.withdrawStake();\\n\\t\\tuint256 daiBalance = DAI.balanceOf(address(this));\\n\\t\\tuint256 ethBalance = address(this).balance;\\n\\t\\tDAI.transfer(avatar, daiBalance);\\n\\t\\tavatar.transfer(ethBalance);\\n\\t\\tactive = false;\\n\\t\\treturn (daiBalance, ethBalance);\\n\\t}\\n\\n\\tfunction getVersion() public pure returns (string memory) {\\n\\t\\treturn \\\"1.1.0\\\";\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n * \\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n * \\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        address self = address(this);\\n        uint256 cs;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { cs := extcodesize(self) }\\n        return cs == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface cERC20 {\\n\\tfunction mint(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction redeemUnderlying(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction exchangeRateCurrent() external returns (uint256);\\n\\n\\tfunction exchangeRateStored() external view returns (uint256);\\n\\n\\tfunction balanceOf(address addr) external view returns (uint256);\\n\\n\\tfunction transfer(address to, uint256 amount) external returns (bool);\\n\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n}\\n\\ninterface GoodDollar is cERC20 {\\n\\tfunction getFees(uint256 value) external view returns (uint256, bool);\\n}\\n\\ninterface Staking {\\n\\tstruct Staker {\\n\\t\\t// The staked DAI amount\\n\\t\\tuint256 stakedDAI;\\n\\t\\t// The latest block number which the\\n\\t\\t// staker has staked tokens\\n\\t\\tuint256 lastStake;\\n\\t}\\n\\n\\tfunction stakeDAI(uint256 amount) external;\\n\\n\\tfunction withdrawStake() external;\\n\\n\\tfunction stakers(address staker) external view returns (Staker memory);\\n}\\n\\ninterface Uniswap {\\n\\tfunction swapExactETHForTokens(\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external payable returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForETH(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForTokens(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction WETH() external pure returns (address);\\n\\n\\tfunction factory() external pure returns (address);\\n\\n\\tfunction quote(\\n\\t\\tuint256 amountA,\\n\\t\\tuint256 reserveA,\\n\\t\\tuint256 reserveB\\n\\t) external pure returns (uint256 amountB);\\n\\n\\tfunction getAmountIn(\\n\\t\\tuint256 amountOut,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountIn);\\n\\n\\tfunction getAmountOut(\\n\\t\\tuint256 amountI,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountOut);\\n}\\n\\ninterface UniswapFactory {\\n\\tfunction getPair(address tokenA, address tokenB)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (address);\\n}\\n\\ninterface UniswapPair {\\n\\tfunction getReserves()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint112 reserve0,\\n\\t\\t\\tuint112 reserve1,\\n\\t\\t\\tuint32 blockTimestampLast\\n\\t\\t);\\n\\n\\tfunction kLast() external view returns (uint256);\\n}\\n\\ninterface Reserve {\\n\\tfunction buy(\\n\\t\\taddress _buyWith,\\n\\t\\tuint256 _tokenAmount,\\n\\t\\tuint256 _minReturn\\n\\t) external returns (uint256);\\n}\\n\\ninterface IIdentity {\\n\\tfunction isWhitelisted(address user) external view returns (bool);\\n\\n\\tfunction addWhitelistedWithDID(address account, string memory did) external;\\n\\n\\tfunction removeWhitelisted(address account) external;\\n}\\n\\ninterface UBIScheme {\\n\\tfunction currentDay() external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethDonated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiDonated\",\"type\":\"uint256\"}],\"name\":\"DonationStaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"contract cERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avatar\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_avatar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minDAIAmount\",\"type\":\"uint256\"}],\"name\":\"stakeDonations\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingContract\",\"outputs\":[{\"internalType\":\"contract Staking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDAIDonated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalETHDonated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap\",\"outputs\":[{\"internalType\":\"contract Uniswap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DonationsStaking","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}