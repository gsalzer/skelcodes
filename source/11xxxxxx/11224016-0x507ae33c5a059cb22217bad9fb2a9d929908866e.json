{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\n \\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\\n        uint256 c = add(a, m);\\n        uint256 d = sub(c, 1);\\n        return mul(div(d,m),m);\\n    }\\n}\\n\"},\"StakingReward.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n////////////////////////////////////////////////////////////////////////////////////\\n////////////////////////////////////////////////////////////////////////////////////\\n////////////////////////////////////////////////////////////////////////////////////\\n////////// RPEPEBLU, RPEPE.LPURPLE Staking Rewards Contract - KEK Rewards //////////\\n////////////////////////////////////////////////////////////////////////////////////\\n////////////////////////////////////////////////////////////////////////////////////\\n////////////////////////////////////////////////////////////////////////////////////\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Context.sol\\\";\\n\\ninterface IKEK {\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function balanceOf(address account) external view returns (uint256);\\n    function burn(address account, uint256 amount) external;\\n}\\n\\ninterface IFARMINGPOOL {\\n    function getTotalStakedAmount() external view returns (uint256);\\n    function getStakedAmount(address account) external view returns (uint256);\\n    function getStakers() external view returns (address[] memory);\\n}\\n\\ncontract StakingReward is Context {\\n    using SafeMath for uint256;\\n    \\n    // Events\\n    event ClaimedReward(address account, uint256 amount);\\n    \\n    // states\\n    struct Gains {\\n        uint256 RPEPEBLUPendingGains;\\n        uint256 RPEPELPURPLEPendingGains;\\n        uint256 RPEPEBLUTotalGained;\\n        uint256 RPEPELPURPLETotalGained;\\n    }\\n\\n    address private _RPEPEBLU;\\n    address private _RPEPELPURPLE;\\n    address private _KEK;\\n    \\n    uint private _lastTimestamp;\\n    uint private _timeInterval;\\n    uint256 private _rewardBlockAmount;\\n    uint256 private _totalRewardsPerDay;\\n\\n    mapping(address =\\u003e Gains) private _gains;\\n    \\n    constructor(address kek, address rpepeblu, address rpepelpurple, uint timeInterval) public {\\n        _KEK = kek;\\n        _RPEPEBLU = rpepeblu;\\n        _RPEPELPURPLE = rpepelpurple;\\n\\n        // Set the initial last timestamp\\n        _lastTimestamp = block.timestamp;\\n        // Set the initial staking reward block size\\n        _rewardBlockAmount = 260000E18;\\n        // time interval for create reward block and claim reward\\n        // This value will be 1 day\\n        _timeInterval = timeInterval;\\n    }\\n\\n    /**\\n     * @dev API to get reward block size\\n     */\\n    function getRewardBlockAmount() external view returns (uint256) {\\n        return _rewardBlockAmount;\\n    }\\n    \\n    /**\\n     * @dev API to get the staker\\u0027s pending gains in RPEPEBLU pool\\n     */\\n    function getPendingGainsInRPEPEBLU(address account) public view returns (uint256) {\\n        return _gains[account].RPEPEBLUPendingGains;\\n    }\\n\\n    /**\\n     * @dev API to get the staker\\u0027s pending gains in RPEPELPURPLE pool\\n     */\\n    function getPendingGainsInRPEPELPURPLE(address account) public view returns (uint256) {\\n        return _gains[account].RPEPELPURPLEPendingGains;\\n    }\\n\\n    /**\\n     * @dev API to get the staker\\u0027s total gained in RPEPEBLU pool\\n     */\\n    function getTotalGainedInRPEPEBLU(address account) public view returns (uint256) {\\n        return _gains[account].RPEPEBLUTotalGained;\\n    }\\n\\n    /**\\n     * @dev API to get the staker\\u0027s total gained in RPEPELPURPLE pool\\n     */\\n    function getTotalGainedInRPEPELPURPLE(address account) public view returns (uint256) {\\n        return _gains[account].RPEPELPURPLETotalGained;\\n    }\\n\\n    /**\\n     * @dev API to get total amount staked in RPEPEBLU and RPEPELPURPLE pools\\n     */\\n    function getTotalStakedAmountInPools() public view returns (uint256) {\\n        uint256 stakedAmountInPKPool = IFARMINGPOOL(_RPEPEBLU).getTotalStakedAmount();\\n        uint256 stakedAmountInLPPool = IFARMINGPOOL(_RPEPELPURPLE).getTotalStakedAmount();\\n        return stakedAmountInPKPool.add(stakedAmountInLPPool);\\n    }\\n\\n    /**\\n     * @dev API to get current daily staking rate of RPEPEBLU pool.\\n     *\\n     * Algorithm\\n     * - rate = (block size / 2) / amount of rPEPE in RPEPEBLU and RPEPELPURPLE pools.\\n     * - if block size = 260,000KEK (phase 1)\\n     *      then maximum rate=0.05KEK, minimum rate=0.005KEK\\n     * - if block size = 130,000KEK (phase 2)\\n     *      then maximum rate=0.025KEK, minimum rate=0.0025KEK\\n     * - if block size = 65,000KEK (phase 3)\\n     *      then maximum rate=0.0125KEK, minimum rate=0.00125KEK\\n     * - if block size = 32,500KEK (phase 4)\\n     *      then maximum rate=0.00625KEK, minimum rate=0.000625KEK\\n     */\\n    function getStakingRateInRPEPEBLU() public view returns (uint256) {\\n        uint256 maxRate = _getMaximunRate();\\n        uint256 minRate = _getMinimunRate();\\n        uint256 totalStakedAmount = getTotalStakedAmountInPools();\\n        uint256 rate = 0;\\n\\n        if (totalStakedAmount \\u003e 0) {\\n            rate = _rewardBlockAmount.mul(1E18).div(totalStakedAmount);\\n            if (rate \\u003c minRate) {\\n                rate = minRate;\\n            } else if (rate \\u003e maxRate) {\\n                rate = maxRate;\\n            }\\n        }\\n        return rate;\\n    }\\n\\n    /**\\n     * @dev API to get current daily staking rate of RPEPELPURPLE pool.\\n     *\\n     * Algorithm\\n     * - rate = block size / amount of rPEPE in RPEPEBLU and RPEPELPURPLE pools\\n     * - if block size = 260,000KEK (phase 1)\\n     *      then maximum rate=0.1KEK, minimum rate=0.01KEK\\n     * - if block size = 130,000KEK (phase 2)\\n     *      then maximum rate=0.05KEK, minimum rate=0.005KEK\\n     * - if block size = 65,000KEK (phase 3)\\n     *      then maximum rate=0.025KEK, minimum rate=0.0025KEK\\n     * - if block size = 32,500KEK (phase 4)\\n     *      then maximum rate=0.0125KEK, minimum rate=0.00125KEK\\n     */\\n    function getStakingRateInRPEPELPURPLE() public view returns (uint256) {\\n        uint256 maxRate = _getMaximunRate().mul(2);\\n        uint256 minRate = _getMinimunRate().mul(2);\\n        uint256 totalStakedAmount = getTotalStakedAmountInPools();\\n        uint256 rate = 0;\\n\\n        if (totalStakedAmount \\u003e 0) {\\n            rate = _rewardBlockAmount.mul(1E18).div(totalStakedAmount);\\n            if (rate \\u003c minRate) {\\n                rate = minRate;\\n            } else if (rate \\u003e maxRate) {\\n                rate = maxRate;\\n            }\\n        }\\n        return rate;\\n    }\\n\\n    /**\\n     * @dev API to harvest staker\\u0027s reward from RPEPEBLU.\\n     */\\n    function harvestFromRPEPEBLU() external {\\n        uint256 pendingGains = getPendingGainsInRPEPEBLU(_msgSender());\\n        // send tokens to the staker\\u0027s account\\n        require(IKEK(_KEK).transfer(_msgSender(), pendingGains));\\n        _gains[_msgSender()].RPEPEBLUPendingGains = 0;\\n        _gains[_msgSender()].RPEPEBLUTotalGained = _gains[_msgSender()].RPEPEBLUTotalGained.add(pendingGains);\\n        emit ClaimedReward(_msgSender(), pendingGains);\\n    }\\n\\n    /**\\n     * @dev API to harvest staker\\u0027s reward from RPEPELPURPLE.\\n     */\\n    function harvestFromRPEPELPURPLE() external {\\n        uint256 pendingGains = getPendingGainsInRPEPELPURPLE(_msgSender());\\n        // send tokens to the staker\\u0027s account\\n        require(IKEK(_KEK).transfer(_msgSender(), pendingGains));\\n        _gains[_msgSender()].RPEPELPURPLEPendingGains = 0;\\n        _gains[_msgSender()].RPEPELPURPLETotalGained = _gains[_msgSender()].RPEPELPURPLETotalGained.add(pendingGains);\\n        emit ClaimedReward(_msgSender(), pendingGains);\\n    }\\n\\n    /**\\n     * @dev API to create new staking reward block and claim reward per day.\\n     */\\n    function createRewardBlockAndClaimRewards() external {\\n        uint count = (block.timestamp - _lastTimestamp) / _timeInterval;\\n        _createRewardBlockAndClaimRewards(count);\\n        // update last timestamp\\n        _lastTimestamp = count * _timeInterval + _lastTimestamp;\\n    }\\n    \\n    /**\\n     * @dev Get maximum rate\\n     */\\n    function _getMaximunRate() internal view returns (uint256) {\\n        uint256 maxRate = 0;\\n        if (_rewardBlockAmount == 260000E18) { // for phase 1\\n            maxRate = 5E16;\\n        } else if (_rewardBlockAmount == 130000E18) { // for phase 2\\n            maxRate = 25E15;\\n        } else if (_rewardBlockAmount == 65000E18) { // for phase 3\\n            maxRate = 125E14;\\n        } else if (_rewardBlockAmount == 32500E18) { // for phase 4\\n            maxRate = 625E13;\\n        }\\n        require(maxRate \\u003e 0, \\\"Block size has been undefined\\\");\\n        return maxRate;\\n    }\\n\\n    /**\\n     * @dev Get minimum rate\\n     */\\n    function _getMinimunRate() internal view returns (uint256) {\\n        uint256 minRate = 0;\\n        if (_rewardBlockAmount == 260000E18) { // for phase 1\\n            minRate = 5E15;\\n        } else if (_rewardBlockAmount == 130000E18) { // for phase 2\\n            minRate = 25E14;\\n        } else if (_rewardBlockAmount == 65000E18) { // for phase 3\\n            minRate = 125E13;\\n        } else if (_rewardBlockAmount == 32500E18) { // for phase 4\\n            minRate = 625E12;\\n        }\\n        require(minRate \\u003e 0, \\\"Block size has been undefined\\\");\\n        return minRate;\\n    }\\n\\n    /**\\n     * @dev Create new staking reward block by calculation the remaining in staking reward.\\n     */\\n    function _createRewardBlockAndClaimRewards(uint count) internal {\\n        for (uint i = 0; i \\u003c count; i++) {\\n            _createRewardBlockAndBurn(IKEK(_KEK).balanceOf(address(this)));\\n            _claimRewardsInRPEPEBLU();\\n            _claimRewardsInRPEPELPURPLE();\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the block amount for current staking reward and burn tokens for block amount\\n     * \\n     * Formula:\\n     * - 260,000 KEK (75%-100% remaining in staking reward)\\n     * - 130,000 KEK (50%-75% remaining in staking reward)\\n     * - 65,000 KEK (25%-50% remaining in staking reward)\\n     * - 32,500 KEK (0%-25% remaining in staking reward)\\n     */\\n    function _createRewardBlockAndBurn(uint256 available) internal {\\n        require(available \\u003e 0, \\\"Available KEK amount must be more than zero.\\\");\\n        uint256 percent = available.div(49000000E10).mul(100);\\n        // Initialize total rewards per day\\n        _totalRewardsPerDay = 0;\\n\\n        if (percent \\u003e 0 \\u0026\\u0026 percent \\u003c 25) {\\n            _rewardBlockAmount = 32500E18;\\n            IKEK(_KEK).burn(address(this), 32500E18);\\n        } else if (percent \\u003e= 25 \\u0026\\u0026 percent \\u003c 50) {\\n            _rewardBlockAmount = 65000E18;\\n            IKEK(_KEK).burn(address(this), 65000E18);\\n        } else if (percent \\u003e= 50 \\u0026\\u0026 percent \\u003c 75) {\\n            _rewardBlockAmount = 130000E18;\\n            IKEK(_KEK).burn(address(this), 130000E18);\\n        } else if (percent \\u003e= 75 \\u0026\\u0026 percent \\u003c= 100) {\\n            _rewardBlockAmount = 260000E18;\\n            IKEK(_KEK).burn(address(this), 260000E18);\\n        }\\n    }\\n    \\n    /**\\n     * @dev Claim rewards to all stakers in RPEPEBLU daily\\n     */\\n    function _claimRewardsInRPEPEBLU() internal {\\n        address[] memory stakers = IFARMINGPOOL(_RPEPEBLU).getStakers();\\n        for (uint256 i = 0; i \\u003c stakers.length; i++) {\\n            _calcPendingGainsInRPEPEBLU(stakers[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Claim rewards to all stakers in RPEPELPURPLE daily\\n     */\\n    function _claimRewardsInRPEPELPURPLE() internal {\\n        address[] memory stakers = IFARMINGPOOL(_RPEPELPURPLE).getStakers();\\n        for (uint256 i = 0; i \\u003c stakers.length; i++) {\\n            _calcPendingGainsInRPEPELPURPLE(stakers[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calcuate staker\\u0027s pending gains in RPEPEBLU.\\n     */\\n    function _calcPendingGainsInRPEPEBLU(address account) internal {\\n        require(account != address(0), \\\"Invalid address\\\");\\n        uint256 rewards = (IFARMINGPOOL(_RPEPEBLU).getStakedAmount(account)).mul(getStakingRateInRPEPEBLU()).div(1E18);\\n\\n        if (_totalRewardsPerDay.add(rewards) \\u003e _rewardBlockAmount) {\\n            rewards = _rewardBlockAmount.sub(_totalRewardsPerDay);\\n        }\\n        _gains[account].RPEPEBLUPendingGains = _gains[account].RPEPEBLUPendingGains.add(rewards);\\n        _totalRewardsPerDay = _totalRewardsPerDay.add(rewards);\\n    }\\n\\n    /**\\n     * @dev Calcuate staker\\u0027s pending gains in RPEPELPURPLE.\\n     */\\n    function _calcPendingGainsInRPEPELPURPLE(address account) internal {\\n        require(account != address(0), \\\"Invalid address\\\");\\n        uint256 rewards = (IFARMINGPOOL(_RPEPELPURPLE).getStakedAmount(account)).mul(getStakingRateInRPEPELPURPLE()).div(1E18);\\n\\n        if (_totalRewardsPerDay.add(rewards) \\u003e _rewardBlockAmount) {\\n            rewards = _rewardBlockAmount.sub(_totalRewardsPerDay);\\n        }\\n        _gains[account].RPEPELPURPLEPendingGains = _gains[account].RPEPELPURPLEPendingGains.add(rewards);\\n        _totalRewardsPerDay = _totalRewardsPerDay.add(rewards);\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"kek\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rpepeblu\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rpepelpurple\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeInterval\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedReward\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"createRewardBlockAndClaimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingGainsInRPEPEBLU\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingGainsInRPEPELPURPLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardBlockAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingRateInRPEPEBLU\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingRateInRPEPELPURPLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTotalGainedInRPEPEBLU\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTotalGainedInRPEPELPURPLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakedAmountInPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestFromRPEPEBLU\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestFromRPEPELPURPLE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakingReward","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000bd0d47d7ecf0978f13878615635f3d3dc5fecde10000000000000000000000003be4bfd561f5decbcceff50c17b0320fc8d77c5a00000000000000000000000067cceeb02553e3277c16fd3cee586a714f4f70420000000000000000000000000000000000000000000000000000000000015180","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d0c8ed8ebc174094fe7fb10d3be2768f12166370a0374578c542e600f71c2212"}]}