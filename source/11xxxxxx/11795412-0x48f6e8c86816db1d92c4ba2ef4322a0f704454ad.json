{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/XNum.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\nlibrary XNum {\r\n    uint256 public constant BONE = 10**18;\r\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\r\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\r\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\r\n\r\n    function btoi(uint256 a) internal pure returns (uint256) {\r\n        return a / BONE;\r\n    }\r\n\r\n    function bfloor(uint256 a) internal pure returns (uint256) {\r\n        return btoi(a) * BONE;\r\n    }\r\n\r\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        (uint256 c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint256 c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint256 c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint256 c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\r\n        uint256 z = n % 2 != 0 ? a : BONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n    // of approximation of b^0.w\r\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\r\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint256 whole = bfloor(exp);\r\n        uint256 remain = bsub(exp, whole);\r\n\r\n        uint256 wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(\r\n        uint256 base,\r\n        uint256 exp,\r\n        uint256 precision\r\n    ) internal pure returns (uint256) {\r\n        // term 0:\r\n        uint256 a = exp;\r\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\r\n        uint256 term = BONE;\r\n        uint256 sum = term;\r\n        bool negative = false;\r\n\r\n        // term(k) = numer / denom\r\n        //         = (product(a - i + 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint256 i = 1; term >= precision; i++) {\r\n            uint256 bigK = i * BONE;\r\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/XMath.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\nlibrary XMath {\r\n    using XNum for uint256;\r\n\r\n    uint256 public constant BONE = 10**18;\r\n    uint256 public constant EXIT_ZERO_FEE = 0;\r\n\r\n    /**********************************************************************************************\r\n    // calcSpotPrice                                                                             //\r\n    // sP = spotPrice                                                                            //\r\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\r\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\r\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcSpotPrice(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 spotPrice) {\r\n        uint256 numer = tokenBalanceIn.bdiv(tokenWeightIn);\r\n        uint256 denom = tokenBalanceOut.bdiv(tokenWeightOut);\r\n        uint256 ratio = numer.bdiv(denom);\r\n        uint256 scale = BONE.bdiv(BONE.bsub(swapFee));\r\n        return (spotPrice = ratio.bmul(scale));\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcOutGivenIn                                                                            //\r\n    // aO = tokenAmountOut                                                                       //\r\n    // bO = tokenBalanceOut                                                                      //\r\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\r\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\r\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcOutGivenIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountOut) {\r\n        uint256 weightRatio;\r\n        if (tokenWeightIn == tokenWeightOut) {\r\n            weightRatio = 1 * BONE;\r\n        } else if (tokenWeightIn >> 1 == tokenWeightOut) {\r\n            weightRatio = 2 * BONE;\r\n        } else {\r\n            weightRatio = tokenWeightIn.bdiv(tokenWeightOut);\r\n        }\r\n        uint256 adjustedIn = BONE.bsub(swapFee);\r\n        adjustedIn = tokenAmountIn.bmul(adjustedIn);\r\n        uint256 y = tokenBalanceIn.bdiv(tokenBalanceIn.badd(adjustedIn));\r\n        uint256 foo;\r\n        if (tokenWeightIn == tokenWeightOut) {\r\n            foo = y;\r\n        } else if (tokenWeightIn >> 1 == tokenWeightOut) {\r\n            foo = y.bmul(y);\r\n        } else {\r\n            foo = y.bpow(weightRatio);\r\n        }\r\n        uint256 bar = BONE.bsub(foo);\r\n        tokenAmountOut = tokenBalanceOut.bmul(bar);\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcInGivenOut                                                                            //\r\n    // aI = tokenAmountIn                                                                        //\r\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\r\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\r\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\r\n    // wI = tokenWeightIn           --------------------------------------------                 //\r\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcInGivenOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountIn) {\r\n        uint256 weightRatio;\r\n        if (tokenWeightOut == tokenWeightIn) {\r\n            weightRatio = 1 * BONE;\r\n        } else if (tokenWeightOut >> 1 == tokenWeightIn) {\r\n            weightRatio = 2 * BONE;\r\n        } else {\r\n            weightRatio = tokenWeightOut.bdiv(tokenWeightIn);\r\n        }\r\n        uint256 diff = tokenBalanceOut.bsub(tokenAmountOut);\r\n        uint256 y = tokenBalanceOut.bdiv(diff);\r\n        uint256 foo;\r\n        if (tokenWeightOut == tokenWeightIn) {\r\n            foo = y;\r\n        } else if (tokenWeightOut >> 1 == tokenWeightIn) {\r\n            foo = y.bmul(y);\r\n        } else {\r\n            foo = y.bpow(weightRatio);\r\n        }\r\n        foo = foo.bsub(BONE);\r\n        tokenAmountIn = BONE.bsub(swapFee);\r\n        tokenAmountIn = tokenBalanceIn.bmul(foo).bdiv(tokenAmountIn);\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolOutGivenSingleIn                                                                  //\r\n    // pAo = poolAmountOut         /                                              \\              //\r\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\r\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\r\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\r\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\r\n    // pS = poolSupply            \\\\                    tBi               /        /             //\r\n    // sF = swapFee                \\                                              /              //\r\n    **********************************************************************************************/\r\n    function calcPoolOutGivenSingleIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 poolAmountOut) {\r\n        // Charge the trading fee for the proportion of tokenAi\r\n        ///  which is implicitly traded to the other pool tokens.\r\n        // That proportion is (1- weightTokenIn)\r\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\r\n        uint256 normalizedWeight = tokenWeightIn.bdiv(totalWeight);\r\n        uint256 zaz = BONE.bsub(normalizedWeight).bmul(swapFee);\r\n        uint256 tokenAmountInAfterFee = tokenAmountIn.bmul(BONE.bsub(zaz));\r\n\r\n        uint256 newTokenBalanceIn = tokenBalanceIn.badd(tokenAmountInAfterFee);\r\n        uint256 tokenInRatio = newTokenBalanceIn.bdiv(tokenBalanceIn);\r\n\r\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\r\n        uint256 poolRatio = tokenInRatio.bpow(normalizedWeight);\r\n        uint256 newPoolSupply = poolRatio.bmul(poolSupply);\r\n        poolAmountOut = newPoolSupply.bsub(poolSupply);\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleOutGivenPoolIn                                                                  //\r\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\r\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\r\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\r\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\r\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\r\n    // tW = totalWeight                    /     /      wO \\       \\                             //\r\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\r\n    // eF = exitFee                        \\     \\      tW /       /                             //\r\n    **********************************************************************************************/\r\n    function calcSingleOutGivenPoolIn(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountOut) {\r\n        uint256 normalizedWeight = tokenWeightOut.bdiv(totalWeight);\r\n        // charge exit fee on the pool token side\r\n        // pAiAfterExitFee = pAi*(1-exitFee)\r\n        uint256 poolAmountInAfterExitFee =\r\n            poolAmountIn.bmul(BONE.bsub(EXIT_ZERO_FEE));\r\n        uint256 newPoolSupply = poolSupply.bsub(poolAmountInAfterExitFee);\r\n        uint256 poolRatio = newPoolSupply.bdiv(poolSupply);\r\n\r\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\r\n        uint256 tokenOutRatio = poolRatio.bpow(BONE.bdiv(normalizedWeight));\r\n        uint256 newTokenBalanceOut = tokenOutRatio.bmul(tokenBalanceOut);\r\n\r\n        uint256 tokenAmountOutBeforeSwapFee =\r\n            tokenBalanceOut.bsub(newTokenBalanceOut);\r\n\r\n        // charge swap fee on the output token side\r\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\r\n        uint256 zaz = BONE.bsub(normalizedWeight).bmul(swapFee);\r\n        tokenAmountOut = tokenAmountOutBeforeSwapFee.bmul(BONE.bsub(zaz));\r\n        return tokenAmountOut;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXIT_ZERO_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolOutGivenSingleIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleOutGivenPoolIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"XMath","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"istanbul","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c5e8ec304c6258c65f2d2a5060fdf9618db8d027e8ca585dfb166299c36bb065"}]}