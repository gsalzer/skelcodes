{"status":"1","message":"OK","result":[{"SourceCode":"{\"BAEXOptions.sol\":{\"content\":\"pragma solidity 0.6.11; // 5ef660b1\\nimport \\\"Uniswap.sol\\\";\\n/* BAEX - Binary Options Smart-Contract v.1.0.2 (Â© 2020 - baex.com)\\n    \\nA smart contract source code of an open binary options platform BAEX.\\n\\nThis open-source code confirms the open binary options model used on the baex.com platform, where any user\\n\\tof the Ethereum can participate as a liquidity provider or a trader.\\n\\nThe BAEX mathematical model of binary options provides:\\n\\n1) Automatically calculated profit ratios for traders from transactions that allow\\n\\tyou to get an honestly balanced profit from trading.\\n\\n2) The opportunity to receive 10% profit for liquidity providers from held in liquidity pool BAEX tokens.\\n\\n3) Oracles of BAEX uses Yahoo Finance as a source of reliable market quotes, which are stored on the blockchain\\n\\tand always can be verified by 3d party.\\n\\nUsing this smart contract, you can earn from providing liquidity or trading on the baex.com platform\\n*/\\n\\ninterface ifaceBAEXToken {\\n    function transferOptions(address _from, address _to, uint256 _value, bool _burn_to_assets) external returns (bool);\\n    function issuePrice() external view returns (uint256);\\n\\tfunction burnPrice() external view returns (uint256);\\n\\tfunction collateral() external view returns (uint256);\\n}\\n\\n/* BAEX - smart-contract of BAEX options */\\ncontract BAEXOptions {\\n    // Fixed point math factor is 10^10\\n    uint256 constant public fmk = 10**10;\\n    address constant private super_owner = 0x2B2fD898888Fa3A97c7560B5ebEeA959E1Ca161A;\\n    address private owner;\\n    \\n    string public name;\\n    \\n    // Divider of trades period in seconds 300 is 5 minutes\\n    uint32 public period_divider;\\n    // Current max num of periods for trade\\n    uint32 public max_period;\\n    // Current min periods of trade\\n    uint32 public min_period;\\n    \\n    /* ALL STORED IN THIS CONTRACT BALANCES AND AMOUNTS HAVE PRECISION * 10 */\\n    \\n    // Min trade volume\\n    uint256 public min_trade_vol;\\n    // Max trade volume\\n    uint256 public max_trade_vol;\\n    // Flag of automatic recalc trade volume \\n    bool public recalc_max_trade_vol;\\n    \\n    // Size of liquidity pool\\n    uint256 public liquidity_pool;\\n    // Blocked amount of liquidity pool\\n    uint256 public liquidity_pool_blocked;\\n    \\n    // Current ratio of trades\\n    uint256 public liquidity_perc;\\n    \\n    // Balancing factors\\n    uint256 public liquidity_balancing_mul;\\n    uint256 public liquidity_perc_normal;\\n    uint256 public liquidity_in;\\n    uint256 public liquidity_ratio;\\n    \\n    // 5% is processing fee:\\n\\t//\\t 2.5% to the liquidity pool \\u0026 2.5% as fees for oracles\\n    uint256 constant public processing_fees_percent = 5 * fmk / 100;\\n    // Collected fees for oracles\\n    uint256 public oracle_fees;    \\n    uint32  public num_of_trades;\\n    \\n    uint256 public gas_for_process;\\n    \\n    mapping (address =\\u003e bool) oracles;\\n    \\n    address payable baex;\\n    \\n    struct TTrade {\\n        uint256 vol;\\n        uint256 fees;\\n        uint256 params;\\n        // bits of params:\\n        // 0x0001       0020        5F4B5235            5F4B5535            000000000000000000000000000007001ED00044\\n        // direction    period      place_time_stamp    result_time_stamp                                 result_vol\\n        uint256 result_vol;\\n        int256 result;\\n    }\\n    \\n    mapping(uint256 =\\u003e TTrade) public trades;\\n    mapping(uint16 =\\u003e bytes16) public valid_instruments;\\n    mapping(address =\\u003e uint256 ) public liquidity;\\n    \\n    // Stored rates of instruments in blockchain\\n    // bits:\\n    // 0x0001          5F4B5535   -\\u003e    0x000000F049EBDC05\\n    // instrument id   timestamp  -\\u003e    instrument rate * 10^8\\n    mapping(uint48 =\\u003e uint64) public instrumentRates;\\n\\n    constructor() public {\\n\\t\\tname = \\\"BAEX - Options Smart-Contract\\\";\\n\\t\\t\\n\\t\\tperiod_divider = 300;   // 5 minutes\\n\\t\\tmax_period = 288;       // 288 * 5 minutes = 24 hours\\n\\t\\tmin_period = 1;\\n\\t\\t\\n\\t\\t// Assets for trades list, can be extend later\\n\\t\\t//--------------------------------------------\\n\\t\\t// Crypto\\n\\t\\tvalid_instruments[1] = \\\"BTC-USD\\\";\\n\\t\\tvalid_instruments[2] = \\\"ETH-USD\\\";\\n\\t\\n\\t\\t// Forex\\n\\t\\tvalid_instruments[3] = \\\"EUR-USD\\\";\\n\\t\\tvalid_instruments[4] = \\\"GBP-USD\\\";\\n\\t\\tvalid_instruments[47] = \\\"USD-JPY\\\";\\n\\t\\tvalid_instruments[53] = \\\"AUD-USD\\\";\\n\\t\\tvalid_instruments[59] = \\\"EUR-JPY\\\";\\n\\t\\tvalid_instruments[62] = \\\"GBP-JPY\\\";\\n\\t\\t\\n\\t\\t// S\\u0026P 500 Index\\n\\t\\tvalid_instruments[32] = \\\"SNP\\\"; \\n\\t\\t// Dow Jones Industrial Average Index\\n\\t\\tvalid_instruments[35] = \\\"^DJI\\\";\\n\\t\\t// NASDAQ Composite Index\\n\\t\\tvalid_instruments[38] = \\\"^IXIC\\\";\\n\\t\\t// NYSE COMPOSITE (DJ) Index\\n\\t\\tvalid_instruments[41] = \\\"^NYA\\\";\\n\\t\\t\\n\\t\\t// Tesla, Inc.\\n\\t\\tvalid_instruments[5] = \\\"TSLA\\\";\\n\\t\\t// Nordstrom, Inc.\\n\\t\\tvalid_instruments[71] = \\\"JWN\\\";\\n\\t\\t// Microsoft Corporation\\n\\t\\tvalid_instruments[74] = \\\"MSFT\\\";\\n\\t\\t// Apple, Inc.\\n\\t\\tvalid_instruments[77] = \\\"AAPL\\\";\\n\\t\\t// Uber Technologies, Inc.\\n\\t\\tvalid_instruments[80] = \\\"UBER\\\";\\n\\t\\t// Advanced Micro Devices, Inc.\\n\\t\\tvalid_instruments[83] = \\\"AMD\\\";\\n\\t\\t// Bank of America Corporation\\n\\t\\tvalid_instruments[86] = \\\"BAC\\\";\\n\\t\\t// Intel Corporation\\n\\t\\tvalid_instruments[89] = \\\"INTC\\\";\\n\\t\\t// Pfizer, Inc.\\n\\t\\tvalid_instruments[95] = \\\"PFE\\\";\\n\\t\\t// Exxon Mobil Corporation\\n\\t\\tvalid_instruments[98] = \\\"XOM\\\";\\n\\t\\t// Johnson \\u0026 Johnson\\n\\t\\tvalid_instruments[101] = \\\"JNJ\\\";\\n\\t\\t// Delta Air Lines, Inc.\\n\\t\\tvalid_instruments[104] = \\\"DAL\\\";\\n\\t\\t// The Walt Disney Company\\n\\t\\tvalid_instruments[107] = \\\"DIS\\\";\\n\\t\\t// Citigroup, Inc.\\n\\t\\tvalid_instruments[110] = \\\"C\\\";\\n\\t\\t// The British Petroleum Company\\n\\t\\tvalid_instruments[113] = \\\"BP\\\";\\n\\t\\t// Amazon.com, Inc.\\n\\t\\tvalid_instruments[119] = \\\"AMZN\\\";\\n\\t\\t// Lockheed Martin Corporation\\n\\t\\tvalid_instruments[122] = \\\"LMT\\\";\\n\\t\\t//--------------------------------------------\\n\\t\\t\\n\\t\\tliquidity_balancing_mul = 100 * fmk / 100;\\n\\t\\tliquidity_perc = 95 * fmk / 100;\\n\\t\\tliquidity_perc_normal = 95 * fmk / 100;\\n\\t\\tliquidity_in = 0;\\n\\t\\tliquidity_pool = 0;\\n\\t\\tliquidity_pool_blocked = 0;\\n\\t\\tliquidity_ratio = 1 * fmk;\\n\\t\\t\\n\\t\\tmin_trade_vol = 1 * (10 ** 9);\\n\\t\\tmax_trade_vol = 50 * (10 ** 9);\\n\\t\\trecalc_max_trade_vol = true;\\n\\t\\tgas_for_process = 90000;\\n\\t\\t\\n\\t\\toracles[address(0xa6cF40A509F9847451A7ed7FeEa97F889A750490)] = true;\\n        \\n\\t\\towner = msg.sender;\\n\\t\\tnum_of_trades = 0;\\n\\t}\\n\\t\\n\\tmodifier onlyOwner() {\\n\\t\\trequire( (msg.sender == owner) || (msg.sender == super_owner), \\\"You don\\u0027t have permissions to call it\\\" );\\n\\t\\t_;\\n\\t}\\n\\t\\n\\tmodifier onlyOracle {\\n\\t\\trequire( oracles[msg.sender], \\\"Only oracles can call it\\\" );\\n\\t\\t_;\\n\\t}\\n\\t\\n\\tfunction afterChangeLiquidityPool() private {\\n\\t    if ( liquidity_pool == 0 ) {\\n\\t        liquidity_balancing_mul = 100 * fmk / 100;\\n\\t\\t    liquidity_perc = 95 * fmk / 100;\\n\\t\\t    liquidity_perc_normal = 95 * fmk / 100;\\n\\t\\t    liquidity_in = 0;\\n\\t\\t    liquidity_pool = 0;\\n\\t\\t    liquidity_pool_blocked = 0;\\n\\t\\t    liquidity_ratio = 1 * fmk;\\n\\t\\t    min_trade_vol = 1 * (10 ** 9);\\n\\t\\t    max_trade_vol = 50 * (10 ** 9);\\n\\t\\t    return;\\n\\t    }\\n\\t    if ( recalc_max_trade_vol ) {\\n            max_trade_vol = (liquidity_pool-liquidity_pool_blocked) / 50;\\n\\t    }\\n\\t    liquidity_balancing_mul = (liquidity_pool-liquidity_pool_blocked) * fmk / liquidity_in;\\n\\t    liquidity_perc = liquidity_perc_normal * liquidity_balancing_mul / fmk;\\n\\t    liquidity_ratio = liquidity_in * fmk / liquidity_pool;\\n\\t    log3(bytes20(address(this)),bytes4(\\\"LPC\\\"),bytes32(liquidity_pool\\u003c\\u003c128 | liquidity_pool_blocked),bytes32(liquidity_perc));\\n\\t}\\n    \\n    function placeLiquidity(uint256 _vol) public {\\n        _placeLiquidity( msg.sender, _vol, true );\\n    }\\n\\tfunction _placeLiquidity(address _sender, uint256 _vol, bool _need_transfer) private {\\n\\t    require( _vol \\u003e 0, \\\"Vol must be greater than zero\\\" );\\n\\t    require( _vol \\u003c 10**21, \\\"Too big volume\\\" );\\n\\t    if ( _need_transfer ) {\\n\\t        ifaceBAEXToken(baex).transferOptions(_sender,address(this),_vol,false);\\n\\t    }\\n\\t    _vol = _vol * 10;\\n        uint256 in_vol = _vol;\\n        if ( liquidity_pool != 0 ) {\\n            in_vol = _vol * liquidity_ratio / fmk;\\n        }\\n        liquidity_in = liquidity_in + in_vol;\\n        liquidity_pool = liquidity_pool + _vol;\\n        liquidity[_sender] = liquidity[_sender] + in_vol;\\n        afterChangeLiquidityPool();\\n\\t}\\n\\t\\n\\tfunction balanceOf(address _sender) public view returns (uint256) {\\n        return liquidityBalanceOf(_sender);\\n    }\\n    \\n    function getMinMaxTradeVol() public view returns (uint256, uint256) {\\n        return (min_trade_vol/10, max_trade_vol/10);\\n    }\\n    \\n    function liquidityBalanceOf(address _sender) public view returns (uint256) {\\n\\t    return liquidity[_sender] * fmk / liquidity_ratio / 10;\\n\\t}\\n\\t\\n\\tfunction withdrawLiquidity(uint256 _vol, bool _burn_to_eth) public {\\n\\t    _withdrawLiquidity( msg.sender, _vol, _burn_to_eth );\\n\\t}\\n\\tfunction _withdrawLiquidity(address _sender, uint256 _vol, bool _burn_to_eth) private {\\n\\t    require( _vol \\u003e 0, \\\"Vol must be greater than zero\\\" );\\n\\t    require( _vol \\u003c 10**21, \\\"Too big volume\\\" );\\n\\t    _vol = _vol * 10;\\n\\t    require( _vol \\u003c= (liquidity_pool-liquidity_pool_blocked), \\\"Not enough volume for withdrawal, please decrease volume to withdraw (1)\\\" );\\n\\t    uint256 in_vol = _vol * liquidity_ratio / fmk;\\n\\t    uint256 in_bal = liquidity[_sender];\\n\\t    require( in_vol \\u003c= in_bal, \\\"Not enough volume for withdrawal, please decrease volume to withdraw (2)\\\" );\\n\\t    ifaceBAEXToken(baex).transferOptions(address(this),_sender,_vol/10,_burn_to_eth);\\n\\t    if ( liquidity_pool - _vol \\u003c 3 ) {\\n            liquidity[_sender] = 0;\\n            liquidity_pool = 0;\\n            liquidity_in = 0;\\n            liquidity_ratio = fmk;\\n        } else {\\n            if ( in_bal - in_vol \\u003c 3 ) {\\n\\t            in_vol = in_bal;\\n\\t        }\\n            liquidity[_sender] = in_bal - in_vol;\\n            liquidity_pool = liquidity_pool - _vol;\\n            liquidity_in = liquidity_in - in_vol;\\n        }\\n        afterChangeLiquidityPool();\\n\\t}\\n\\t\\n\\t\\n\\tfunction placeTrade(uint16 _instrument, uint256 _vol, uint8 _direction, uint32 _trade_timestamp, uint16 _period) public {\\n\\t    _placeTrade(msg.sender, _instrument, _vol, _direction, _trade_timestamp, _period );\\n\\t}\\n\\tfunction _placeTrade(address _sender, uint16 _instrument, uint256 _vol, uint8 _direction, uint32 _timestamp, uint16 _period) private {\\n\\t    require( _vol \\u003e 0, \\\"Vol must be greater than zero\\\" );\\n\\t    require( _vol \\u003c 10**21, \\\"Too big volume\\\" );\\n\\t    _vol = _vol * 10;\\n        require( _period \\u003c= max_period, \\\"Too long period\\\" );\\n        require( _period \\u003e= min_period, \\\"Too short period\\\" );\\n        require( _direction \\u003c 2, \\\"Direction can be 0 (down) or 1 (up)\\\" );\\n        require( valid_instruments[_instrument][0] != 0, \\\"This instrument is unavailable now\\\" );\\n\\t    require( _vol \\u003e= min_trade_vol, \\\"Your trade volume less than minimal trade volume\\\" );\\n\\t    require( _vol \\u003c= max_trade_vol, \\\"Your trade volume greater than maximum trade volume\\\" );\\n\\t    require( (block.timestamp-240) \\u003c= _timestamp, \\\"Timestamp param should be not early than 4 min before timestamp of the block\\\" );\\n\\t    uint time_stamp = block.timestamp / 60 * 60;\\n\\t    uint result_time_stamp = time_stamp + _period*period_divider;\\n\\t    ifaceBAEXToken(baex).transferOptions(_sender,address(this),_vol/10,false);\\n\\t    uint256 fees = _vol * processing_fees_percent / fmk;\\n\\t    liquidity_pool = liquidity_pool + (fees - fees / 2);\\n\\t    // Recalc cost of transaction ( BAEX amount in this contract stored as amount * 10 )\\n\\t    uint256 cost_of_processing = tx.gasprice * gas_for_process / ifaceBAEXToken(baex).burnPrice() / 10;\\n\\t    if ( (fees/2) \\u003c cost_of_processing ) {\\n\\t        oracle_fees = oracle_fees + cost_of_processing;\\n\\t        fees = (fees - fees / 2) + cost_of_processing;\\n\\t    } else {\\n\\t        oracle_fees = oracle_fees + fees / 2;\\n\\t    }\\n\\t    require( _vol \\u003e fees * 2, \\\"Your trade volume is too low, please increase the trade volume\\\" );\\n\\t    _vol = _vol - fees;\\n\\t    liquidity_ratio = liquidity_in * fmk / liquidity_pool;\\n\\t    uint256 trade_id = ( uint256(_sender) \\u003c\\u003c 96 ) | ( (uint256( _instrument ) \\u003c\\u003c 64) | block.number );\\n\\t    require( trades[trade_id].vol == 0, \\\"Other your trade in this Ethereum block was detected. You can do only one trade on each instrument in one Ethereum block\\\" );\\n\\t    uint256 result_vol = _vol * liquidity_perc / fmk;\\n\\t    require( result_vol \\u003c= (liquidity_pool-liquidity_pool_blocked), \\\"Not enough liquidity for your trade\\\" );\\n\\t    uint256 trade_params = ( uint256(_direction) \\u003c\\u003c 240 ) | ( uint256(_period) \\u003c\\u003c 224 )\\n\\t                            | ( uint256(time_stamp) \\u003c\\u003c 192 ) | ( uint256(result_time_stamp) \\u003c\\u003c 160 ) | ( uint256(_instrument) \\u003c\\u003c 144 );\\n\\t    if ((result_vol/10) \\u003c (1\\u003c\\u003c144)) {\\n\\t        trade_params = trade_params | (result_vol/10);\\n\\t    }\\n\\t    trades[trade_id] = TTrade( _vol, (cost_of_processing\\u003c\\u003c128) | fees, trade_params, result_vol, 0 );\\n\\t    liquidity_pool_blocked = liquidity_pool_blocked + result_vol;\\n\\t    afterChangeLiquidityPool();\\n\\t    log4(bytes20(address(this)),bytes8(\\\"TRADE\\\"),bytes32(trade_id),bytes32(trades[trade_id].params),bytes32((uint256((fees+_vol)/10)\\u003c\\u003c128) | (fees/10)));\\n\\t    num_of_trades++;\\n\\t}\\n\\t\\n\\t// Process the trade\\n\\tfunction processTrade(uint16 _instrument, uint64 _block_number) public {\\n\\t    _processTrade(msg.sender, _instrument, _block_number);\\n\\t}\\n\\tfunction _processTrade(address _sender, uint16 _instrument, uint64 _block_number) public {\\n\\t    uint256 trade_id = ( uint256(_sender) \\u003c\\u003c 96 ) | ( (uint256( _instrument ) \\u003c\\u003c 64) | _block_number );\\n\\t    TTrade storage trade = trades[trade_id];\\n\\t    require( trade.vol \\u003e 0, \\\"Trade in this block for this addr is not found\\\");\\t    \\n\\t    require( trade.result == 0, \\\"This trade is already has been processed\\\");\\n\\t    uint32 time_stamp = uint32( ( trade.params \\u003c\\u003c 32 ) \\u003e\\u003e 224 );\\n\\t    uint32 result_time_stamp = uint32( ( trade.params \\u003c\\u003c 64 ) \\u003e\\u003e 224 );\\n\\t    uint48 its1 = uint48( uint48(_instrument) \\u003c\\u003c 32 ) | time_stamp;\\n\\t    uint48 its2 = uint48( uint48(_instrument) \\u003c\\u003c 32 ) | result_time_stamp;\\n\\t\\t// If the trade was not processed in 2000 blocks, return the trade volume to the sender\\n\\t    if ( ( trade.result == 0 ) \\u0026\\u0026 ( block.timestamp \\u003e result_time_stamp ) \\u0026\\u0026 ( (block.timestamp-result_time_stamp) \\u003e= 3600 \\u0026\\u0026 (instrumentRates[its1]==0 || instrumentRates[its2]==0) ) ) {\\n\\t        uint256 trade_fees = (trade.fees\\u003c\\u003c128) \\u003e\\u003e 128;\\n\\t        uint256 cost_of_processing = trade.fees \\u003e\\u003e 128;\\n\\t        if ( cost_of_processing \\u003e (trade_fees/2) ) {\\n\\t            if ( oracle_fees \\u003e cost_of_processing ) {\\n\\t                oracle_fees = oracle_fees - cost_of_processing;\\n\\t            } else {\\n\\t                oracle_fees = 0;\\n\\t            }\\n\\t        } else {\\n\\t            if ( oracle_fees \\u003e trade_fees/2 ) {\\n\\t                oracle_fees = oracle_fees - trade_fees/2;\\n\\t            } else {\\n\\t                oracle_fees = 0;\\n\\t            }\\n\\t        }\\n\\t        liquidity_pool_blocked = liquidity_pool_blocked - trade.result_vol;\\n\\t        trade.result_vol = trade.vol;\\n\\t\\t\\tifaceBAEXToken(baex).transferOptions(address(this),_sender,(trade.vol+trade_fees)/10,false);\\n\\t        trade.vol = 0;\\n\\t\\t\\tlog3(bytes20(address(this)),bytes8(\\\"CANCEL\\\"),bytes32(trade_id),bytes32(trade.params));\\n\\t        return;\\n\\t    }\\n\\t    __processTrade( trade_id, instrumentRates[its1], instrumentRates[its2] );\\n\\t}\\n\\t\\n\\tfunction __processTrade( uint256 trade_id, uint64 begin_rate, uint64 end_rate ) private {\\n\\t    require( begin_rate \\u003e 0, \\\"Begin rate is not saved yet in blockhain\\\");\\n\\t    require( end_rate \\u003e 0, \\\"End rate is not saved yet in blockhain\\\");\\n\\t    \\n\\t    address _addr = address( trade_id \\u003e\\u003e 96 );\\n\\t    \\n\\t    TTrade storage trade = trades[trade_id];\\n\\t    require( trade.vol \\u003e 0, \\\"Trade in this block for this addr is not found\\\");\\n\\t    require( trade.result == 0, \\\"This trade has been processed\\\");\\n\\t    require( begin_rate \\u003e 0 || end_rate \\u003e 0, \\\"Not found rates of this instrument for this timestamps\\\");\\n\\t    bool dir = ( (( 1 \\u003c\\u003c 240 ) \\u0026 trade.params) \\u003e 0 );\\n\\t    uint256 trade_fees = (trade.fees\\u003c\\u003c128) \\u003e\\u003e 128;\\n\\t    if ( ( dir \\u0026\\u0026 begin_rate \\u003c end_rate ) || ( (!dir) \\u0026\\u0026 begin_rate \\u003e= end_rate ) ) {\\n\\t        trade.result = int256( trade.result_vol );\\n\\t        log4(bytes20(address(this)),bytes4(\\\"P\\\"),bytes32(trade_id),bytes32(trade.params),bytes32((uint256((trade.vol+trade.result_vol)/10)\\u003c\\u003c128) | (trade_fees/10)));\\n\\t    } else {\\n\\t        trade.result = -int256( trade.result_vol );\\n\\t        log4(bytes20(address(this)),bytes4(\\\"L\\\"),bytes32(trade_id),bytes32(trade.params),bytes32((uint256((trade_fees+trade.vol)/10)\\u003c\\u003c128) | (trade_fees/10)));\\n\\t    }\\n\\t    liquidity_pool_blocked = liquidity_pool_blocked - trade.result_vol;\\n\\t    if ( trade.result \\u003e 0 ) {\\n\\t        ifaceBAEXToken(baex).transferOptions(address(this),_addr,(trade.result_vol + trade.vol)/10,false);\\n\\t        liquidity_pool = liquidity_pool - trade.result_vol;\\n\\t    } else {\\n\\t        liquidity_pool = liquidity_pool + trade.vol;\\n\\t    }\\n\\t    afterChangeLiquidityPool();\\n\\t}\\n\\t\\n\\t/*\\n\\t    Oracle functions\\n\\t*/\\n\\tfunction oracleStoreRatesAndProcessTrade( uint256 trade_id, uint256 _instrument_ts_rates ) public onlyOracle {\\n\\t    uint256 startGas = gasleft();\\n\\t    uint48 its1 = uint48( _instrument_ts_rates \\u003e\\u003e 192 );\\n\\t    uint48 its2 = uint48( (_instrument_ts_rates \\u003c\\u003c 128) \\u003e\\u003e 192 );\\n\\t    uint64 begin_rate = uint64( (_instrument_ts_rates \\u003c\\u003c 64) \\u003e\\u003e 192 );\\n\\t    uint64 end_rate = uint64( (_instrument_ts_rates \\u003c\\u003c 192) \\u003e\\u003e 192 );\\n\\t    \\n\\t    if ( instrumentRates[its1] == 0 ) instrumentRates[its1] = begin_rate;\\n\\t    if ( instrumentRates[its2] == 0 ) instrumentRates[its2] = end_rate;\\n\\t    \\n\\t    __processTrade( trade_id, begin_rate, end_rate );\\n\\t    // Calc new gas amount for process the trade, 30200 is the constant cost to call\\n\\t    gas_for_process = startGas - gasleft() + 30200;\\n\\t}\\n\\t\\n\\tfunction oracleStoreRates4( uint256 _instrument_and_ts, uint256 _rates ) public onlyOracle {\\n\\t    uint48 its1 = uint48( _instrument_and_ts \\u003e\\u003e 192 );\\n\\t    uint48 its2 = uint48( (_instrument_and_ts \\u003c\\u003c 64) \\u003e\\u003e 192 );\\n\\t    uint48 its3 = uint48( (_instrument_and_ts \\u003c\\u003c 128) \\u003e\\u003e 192 );\\n\\t    uint48 its4 = uint48( (_instrument_and_ts \\u003c\\u003c 192) \\u003e\\u003e 192 );\\n\\t    \\n\\t    if ( instrumentRates[its1] == 0 ) instrumentRates[its1] = uint64( _rates \\u003e\\u003e 192 );\\n\\t    if ( instrumentRates[its2] == 0 ) instrumentRates[its2] = uint64( (_rates \\u003c\\u003c 64) \\u003e\\u003e 192 );\\n\\t    if ( instrumentRates[its3] == 0 ) instrumentRates[its3] = uint64( (_rates \\u003c\\u003c 128) \\u003e\\u003e 192 );\\n\\t    if ( instrumentRates[its4] == 0 ) instrumentRates[its4] = uint64( (_rates \\u003c\\u003c 192) \\u003e\\u003e 192 );\\n\\t}\\n\\t\\n\\tfunction oracleStoreRates2( uint256 _instrument_ts_rates ) public onlyOracle {\\n\\t    uint48 its1 = uint48( _instrument_ts_rates \\u003e\\u003e 192 );\\n\\t    uint48 its2 = uint48( (_instrument_ts_rates \\u003c\\u003c 128) \\u003e\\u003e 192 );\\n\\t    \\n\\t    if ( instrumentRates[its1] == 0 ) instrumentRates[its1] = uint64( (_instrument_ts_rates \\u003c\\u003c 64) \\u003e\\u003e 192 );\\n\\t    if ( instrumentRates[its2] == 0 ) instrumentRates[its2] = uint64( (_instrument_ts_rates \\u003c\\u003c 192) \\u003e\\u003e 192 );\\n\\t}\\n\\t\\n\\t\\n\\t/* Admin functions */\\n\\tfunction transferOwnership(address newOwner) public onlyOwner {\\n\\t\\trequire(newOwner != address(0));\\n\\t\\towner = newOwner;\\n\\t}\\n\\t\\n\\tfunction setTokenAddress(address _token_address) public onlyOwner {\\n\\t    baex = payable(_token_address);\\n\\t}\\n\\t\\n\\tfunction setValidInstrument(uint16 _instrument_id, bytes16 _ticker) public onlyOwner {\\n\\t    valid_instruments[_instrument_id] = _ticker;\\n\\t}\\n\\t\\n\\tfunction setPeriodParams(uint32 _period_divider, uint32 _min_period, uint32 _max_period) public onlyOwner {\\n\\t    period_divider = _period_divider;\\n\\t    min_period = _min_period;\\n\\t    max_period = _max_period;\\n\\t}\\n\\t\\n\\tfunction setTradeVol(uint256 _min_trade_vol, uint256 _max_trade_vol, bool _recalc_max_trade_vol) public onlyOwner {\\n\\t    min_trade_vol = _min_trade_vol;\\n\\t    max_trade_vol = _max_trade_vol;\\n\\t    recalc_max_trade_vol = _recalc_max_trade_vol;\\n\\t}\\n\\t\\n\\tfunction setOracle(address _oracle_address, bool _enabled) public onlyOwner {\\n\\t    oracles[_oracle_address] = _enabled;\\n\\t}\\n\\t\\n\\tfunction onTransferTokens(address _from, address _to, uint256 _value) public returns (bool) {\\n\\t    require( msg.sender == address(baex), \\\"You don\\u0027t have permission to call it\\\" );\\n\\t    if ( _to == address(this) ) {\\n\\t        _placeLiquidity( _from, _value, false );\\n\\t    }\\n\\t}\\n\\t\\n\\tfunction withdrawOracleFees(uint256 _vol) public onlyOwner {\\n\\t    // + 10 * 10**9 because need to leave some amount of fees for the cancelled trades\\n\\t    require( oracle_fees \\u003e= (_vol * 10 + 10 * 10**9), \\\"Not enough fee on the contract\\\");\\n\\t    ifaceBAEXToken(baex).transferOptions(address(this),msg.sender,_vol,false);\\n\\t    oracle_fees = oracle_fees - _vol * 10;\\n\\t}\\n\\t\\n\\t// This function can transfer any of wrong sended ERC20 tokens to the contract exclude BAEX tokens,\\n\\t// because sendeding of the BAEX tokens to this contract is the valid operation\\n\\tfunction transferWrongSendedERC20FromContract(address _contract) public {\\n\\t    require( _contract != address(baex), \\\"Transfer of BAEX token is fortradeen\\\");\\n\\t    require( msg.sender == super_owner, \\\"Your are not super owner\\\");\\n\\t    IERC20(_contract).transfer( super_owner, IERC20(_contract).balanceOf(address(this)) );\\n\\t}\\n\\t\\n\\t// If someone send ETH to this contract it will send it back\\n\\treceive() external payable  {\\n        msg.sender.transfer(msg.value);\\n\\t}\\n\\t/*------------------*/\\n\\t\\n}\\n/* END of: BAEX - smart-contract of BAEX options */\\n\\n// SPDX-License-Identifier: UNLICENSED\"},\"Uniswap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n// Factory 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\\n// Router 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_instrument\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"_block_number\",\"type\":\"uint64\"}],\"name\":\"_processTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fmk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gas_for_process\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinMaxTradeVol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"name\":\"instrumentRates\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"liquidityBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_balancing_mul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_in\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_perc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_perc_normal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_pool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_pool_blocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_ratio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_period\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_trade_vol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"min_period\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"min_trade_vol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"num_of_trades\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"onTransferTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_instrument_ts_rates\",\"type\":\"uint256\"}],\"name\":\"oracleStoreRates2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_instrument_and_ts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rates\",\"type\":\"uint256\"}],\"name\":\"oracleStoreRates4\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"trade_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_instrument_ts_rates\",\"type\":\"uint256\"}],\"name\":\"oracleStoreRatesAndProcessTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle_fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"period_divider\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vol\",\"type\":\"uint256\"}],\"name\":\"placeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_instrument\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_vol\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_direction\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_trade_timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"_period\",\"type\":\"uint16\"}],\"name\":\"placeTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_instrument\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"_block_number\",\"type\":\"uint64\"}],\"name\":\"processTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processing_fees_percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recalc_max_trade_vol\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_period_divider\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_min_period\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_max_period\",\"type\":\"uint32\"}],\"name\":\"setPeriodParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_address\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min_trade_vol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_trade_vol\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_recalc_max_trade_vol\",\"type\":\"bool\"}],\"name\":\"setTradeVol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_instrument_id\",\"type\":\"uint16\"},{\"internalType\":\"bytes16\",\"name\":\"_ticker\",\"type\":\"bytes16\"}],\"name\":\"setValidInstrument\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"trades\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vol\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"params\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"result_vol\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"result\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"transferWrongSendedERC20FromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"valid_instruments\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vol\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_burn_to_eth\",\"type\":\"bool\"}],\"name\":\"withdrawLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vol\",\"type\":\"uint256\"}],\"name\":\"withdrawOracleFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BAEXOptions","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"1400000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2b9091ee106a76dba0497ab79c86b9d48ddc5059de7272e80c134acfecd693a4"}]}