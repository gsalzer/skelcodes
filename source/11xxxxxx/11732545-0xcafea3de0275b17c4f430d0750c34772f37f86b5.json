{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/token/TokenFunctions.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../cover/QuotationData.sol\\\";\\nimport \\\"./NXMToken.sol\\\";\\nimport \\\"./TokenController.sol\\\";\\nimport \\\"./TokenData.sol\\\";\\n\\ncontract TokenFunctions is Iupgradable {\\n  using SafeMath for uint;\\n\\n  NXMToken public tk;\\n  TokenController public tc;\\n  TokenData public td;\\n  QuotationData public qd;\\n  IPooledStaking public pooledStaking;\\n\\n  event BurnCATokens(uint claimId, address addr, uint amount);\\n\\n  /**\\n   * @dev Rewards stakers on purchase of cover on smart contract.\\n   * @param _contractAddress smart contract address.\\n   * @param _coverPriceNXM cover price in NXM.\\n   */\\n  function pushStakerRewards(address _contractAddress, uint _coverPriceNXM) external onlyInternal {\\n    uint rewardValue = _coverPriceNXM.mul(td.stakerCommissionPer()).div(100);\\n    pooledStaking.accumulateReward(_contractAddress, rewardValue);\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\\n   * @param _of address of the coverHolder.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function getUserLockedCNTokens(address _of, uint _coverId) external view returns (uint) {\\n    return _getUserLockedCNTokens(_of, _coverId);\\n  }\\n\\n  /**\\n   * @dev to get the all the cover locked tokens of a user\\n   * @param _of is the user address in concern\\n   * @return amount locked\\n   */\\n  function getUserAllLockedCNTokens(address _of) external view returns (uint amount) {\\n    for (uint i = 0; i < qd.getUserCoverLength(_of); i++) {\\n      amount = amount.add(_getUserLockedCNTokens(_of, qd.getAllCoversOfUser(_of)[i]));\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note against given coverId.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function getLockedCNAgainstCover(uint _coverId) external view returns (uint) {\\n    return _getLockedCNAgainstCover(_coverId);\\n  }\\n\\n  /**\\n   * @dev Change Dependent Contract Address\\n   */\\n  function changeDependentContractAddress() public {\\n    tk = NXMToken(ms.tokenAddress());\\n    td = TokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    tc = TokenController(ms.getLatestAddress(\\\"TC\\\"));\\n    qd = QuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n  }\\n\\n  /**\\n   * @dev Set the flag to check if cover note is deposited against the cover id\\n   * @param coverId Cover Id.\\n   */\\n  function depositCN(uint coverId) public onlyInternal returns (bool success) {\\n    require(_getLockedCNAgainstCover(coverId) > 0, \\\"No cover note available\\\");\\n    td.setDepositCN(coverId, true);\\n    success = true;\\n  }\\n\\n  /**\\n   * @param _of address of Member\\n   * @param _coverId Cover Id\\n   * @param _lockTime Pending Time + Cover Period 7*1 days\\n   */\\n  function extendCNEPOff(address _of, uint _coverId, uint _lockTime) public onlyInternal {\\n    uint timeStamp = now.add(_lockTime);\\n    uint coverValidUntil = qd.getValidityOfCover(_coverId);\\n    if (timeStamp >= coverValidUntil) {\\n      bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, _coverId));\\n      tc.extendLockOf(_of, reason, timeStamp);\\n    }\\n  }\\n\\n  /**\\n   * @dev to burn the deposited cover tokens\\n   * @param coverId is id of cover whose tokens have to be burned\\n   * @return the status of the successful burning\\n   */\\n  function burnDepositCN(uint coverId) public onlyInternal returns (bool success) {\\n    address _of = qd.getCoverMemberAddress(coverId);\\n    uint amount;\\n    (amount,) = td.depositedCN(coverId);\\n    amount = (amount.mul(50)).div(100);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, coverId));\\n    tc.burnLockedTokens(_of, reason, amount);\\n    success = true;\\n  }\\n\\n  /**\\n   * @dev Unlocks covernote locked against a given cover\\n   * @param coverId id of cover\\n   */\\n  function unlockCN(uint coverId) public onlyInternal {\\n    (, bool isDeposited) = td.depositedCN(coverId);\\n    require(!isDeposited, \\\"Cover note is deposited and can not be released\\\");\\n    uint lockedCN = _getLockedCNAgainstCover(coverId);\\n    if (lockedCN != 0) {\\n      address coverHolder = qd.getCoverMemberAddress(coverId);\\n      bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", coverHolder, coverId));\\n      tc.releaseLockedTokens(coverHolder, reason, lockedCN);\\n    }\\n  }\\n\\n  /**\\n   * @dev Burns tokens used for fraudulent voting against a claim\\n   * @param claimid Claim Id.\\n   * @param _value number of tokens to be burned\\n   * @param _of Claim Assessor's address.\\n   */\\n  function burnCAToken(uint claimid, uint _value, address _of) public {\\n\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    tc.burnLockedTokens(_of, \\\"CLA\\\", _value);\\n    emit BurnCATokens(claimid, _of, _value);\\n  }\\n\\n  /**\\n   * @dev to lock cover note tokens\\n   * @param coverNoteAmount is number of tokens to be locked\\n   * @param coverPeriod is cover period in concern\\n   * @param coverId is the cover id of cover in concern\\n   * @param _of address whose tokens are to be locked\\n   */\\n  function lockCN(\\n    uint coverNoteAmount,\\n    uint coverPeriod,\\n    uint coverId,\\n    address _of\\n  )\\n  public\\n  onlyInternal\\n  {\\n    uint validity = (coverPeriod * 1 days).add(td.lockTokenTimeAfterCoverExp());\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, coverId));\\n    td.setDepositCNAmount(coverId, coverNoteAmount);\\n    tc.lockOf(_of, reason, coverNoteAmount, validity);\\n  }\\n\\n  /**\\n   * @dev to check if a  member is locked for member vote\\n   * @param _of is the member address in concern\\n   * @return the boolean status\\n   */\\n  function isLockedForMemberVote(address _of) public view returns (bool) {\\n    return now < tk.isLockedForMV(_of);\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function _getLockedCNAgainstCover(uint _coverId) internal view returns (uint) {\\n    address coverHolder = qd.getCoverMemberAddress(_coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", coverHolder, _coverId));\\n    return tc.tokensLockedAtTime(coverHolder, reason, now);\\n  }\\n\\n  /**\\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\\n   * @param _of address of the coverHolder.\\n   * @param _coverId coverId of the cover.\\n   */\\n  function _getUserLockedCNTokens(address _of, uint _coverId) internal view returns (uint) {\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, _coverId));\\n    return tc.tokensLockedAtTime(_of, reason, now);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPooledStaking.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\ninterface IPooledStaking {\\n\\n  function accumulateReward(address contractAddress, uint amount) external;\\n\\n  function pushBurn(address contractAddress, uint amount) external;\\n\\n  function hasPendingActions() external view returns (bool);\\n\\n  function contractStake(address contractAddress) external view returns (uint);\\n\\n  function stakerReward(address staker) external view returns (uint);\\n\\n  function stakerDeposit(address staker) external view returns (uint);\\n\\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\\n\\n  function withdraw(uint amount) external;\\n\\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\\n\\n  function withdrawReward(address stakerAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/cover/QuotationData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract QuotationData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\\n\\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\\n\\n  struct Cover {\\n    address payable memberAddress;\\n    bytes4 currencyCode;\\n    uint sumAssured;\\n    uint16 coverPeriod;\\n    uint validUntil;\\n    address scAddress;\\n    uint premiumNXM;\\n  }\\n\\n  struct HoldCover {\\n    uint holdCoverId;\\n    address payable userAddress;\\n    address scAddress;\\n    bytes4 coverCurr;\\n    uint[] coverDetails;\\n    uint16 coverPeriod;\\n  }\\n\\n  address public authQuoteEngine;\\n\\n  mapping(bytes4 => uint) internal currencyCSA;\\n  mapping(address => uint[]) internal userCover;\\n  mapping(address => uint[]) public userHoldedCover;\\n  mapping(address => bool) public refundEligible;\\n  mapping(address => mapping(bytes4 => uint)) internal currencyCSAOfSCAdd;\\n  mapping(uint => uint8) public coverStatus;\\n  mapping(uint => uint) public holdedCoverIDStatus;\\n  mapping(uint => bool) public timestampRepeated;\\n\\n\\n  Cover[] internal allCovers;\\n  HoldCover[] internal allCoverHolded;\\n\\n  uint public stlp;\\n  uint public stl;\\n  uint public pm;\\n  uint public minDays;\\n  uint public tokensRetained;\\n  address public kycAuthAddress;\\n\\n  event CoverDetailsEvent(\\n    uint indexed cid,\\n    address scAdd,\\n    uint sumAssured,\\n    uint expiry,\\n    uint premium,\\n    uint premiumNXM,\\n    bytes4 curr\\n  );\\n\\n  event CoverStatusEvent(uint indexed cid, uint8 statusNum);\\n\\n  constructor(address _authQuoteAdd, address _kycAuthAdd) public {\\n    authQuoteEngine = _authQuoteAdd;\\n    kycAuthAddress = _kycAuthAdd;\\n    stlp = 90;\\n    stl = 100;\\n    pm = 30;\\n    minDays = 30;\\n    tokensRetained = 10;\\n    allCovers.push(Cover(address(0), \\\"0x00\\\", 0, 0, 0, address(0), 0));\\n    uint[] memory arr = new uint[](1);\\n    allCoverHolded.push(HoldCover(0, address(0), address(0), 0x00, arr, 0));\\n\\n  }\\n\\n  /// @dev Adds the amount in Total Sum Assured of a given currency of a given smart contract address.\\n  /// @param _add Smart Contract Address.\\n  /// @param _amount Amount to be added.\\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].add(_amount);\\n  }\\n\\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency and smart contract address.\\n  /// @param _add Smart Contract Address.\\n  /// @param _amount Amount to be subtracted.\\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].sub(_amount);\\n  }\\n\\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency.\\n  /// @param _curr Currency Name.\\n  /// @param _amount Amount to be subtracted.\\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSA[_curr] = currencyCSA[_curr].sub(_amount);\\n  }\\n\\n  /// @dev Adds the amount in Total Sum Assured of a given currency.\\n  /// @param _curr Currency Name.\\n  /// @param _amount Amount to be added.\\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\\n    currencyCSA[_curr] = currencyCSA[_curr].add(_amount);\\n  }\\n\\n  /// @dev sets bit for timestamp to avoid replay attacks.\\n  function setTimestampRepeated(uint _timestamp) external onlyInternal {\\n    timestampRepeated[_timestamp] = true;\\n  }\\n\\n  /// @dev Creates a blank new cover.\\n  function addCover(\\n    uint16 _coverPeriod,\\n    uint _sumAssured,\\n    address payable _userAddress,\\n    bytes4 _currencyCode,\\n    address _scAddress,\\n    uint premium,\\n    uint premiumNXM\\n  )\\n  external\\n  onlyInternal\\n  {\\n    uint expiryDate = now.add(uint(_coverPeriod).mul(1 days));\\n    allCovers.push(Cover(_userAddress, _currencyCode,\\n      _sumAssured, _coverPeriod, expiryDate, _scAddress, premiumNXM));\\n    uint cid = allCovers.length.sub(1);\\n    userCover[_userAddress].push(cid);\\n    emit CoverDetailsEvent(cid, _scAddress, _sumAssured, expiryDate, premium, premiumNXM, _currencyCode);\\n  }\\n\\n  /// @dev create holded cover which will process after verdict of KYC.\\n  function addHoldCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod\\n  )\\n  external\\n  onlyInternal\\n  {\\n    uint holdedCoverLen = allCoverHolded.length;\\n    holdedCoverIDStatus[holdedCoverLen] = uint(HCIDStatus.kycPending);\\n    allCoverHolded.push(HoldCover(holdedCoverLen, from, scAddress,\\n      coverCurr, coverDetails, coverPeriod));\\n    userHoldedCover[from].push(allCoverHolded.length.sub(1));\\n\\n  }\\n\\n  ///@dev sets refund eligible bit.\\n  ///@param _add user address.\\n  ///@param status indicates if user have pending kyc.\\n  function setRefundEligible(address _add, bool status) external onlyInternal {\\n    refundEligible[_add] = status;\\n  }\\n\\n  /// @dev to set current status of particular holded coverID (1 for not completed KYC,\\n  /// 2 for KYC passed, 3 for failed KYC or full refunded,\\n  /// 4 for KYC completed but cover not processed)\\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external onlyInternal {\\n    holdedCoverIDStatus[holdedCoverID] = status;\\n  }\\n\\n  /**\\n   * @dev to set address of kyc authentication\\n   * @param _add is the new address\\n   */\\n  function setKycAuthAddress(address _add) external onlyInternal {\\n    kycAuthAddress = _add;\\n  }\\n\\n  /// @dev Changes authorised address for generating quote off chain.\\n  function changeAuthQuoteEngine(address _add) external onlyInternal {\\n    authQuoteEngine = _add;\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters of a code\\n   * @param code whose details we want\\n   * @return string value of the code\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n\\n    if (code == \\\"STLP\\\") {\\n      val = stlp;\\n\\n    } else if (code == \\\"STL\\\") {\\n\\n      val = stl;\\n\\n    } else if (code == \\\"PM\\\") {\\n\\n      val = pm;\\n\\n    } else if (code == \\\"QUOMIND\\\") {\\n\\n      val = minDays;\\n\\n    } else if (code == \\\"QUOTOK\\\") {\\n\\n      val = tokensRetained;\\n\\n    }\\n\\n  }\\n\\n  /// @dev Gets Product details.\\n  /// @return  _minDays minimum cover period.\\n  /// @return  _PM Profit margin.\\n  /// @return  _STL short term Load.\\n  /// @return  _STLP short term load period.\\n  function getProductDetails()\\n  external\\n  view\\n  returns (\\n    uint _minDays,\\n    uint _pm,\\n    uint _stl,\\n    uint _stlp\\n  )\\n  {\\n\\n    _minDays = minDays;\\n    _pm = pm;\\n    _stl = stl;\\n    _stlp = stlp;\\n  }\\n\\n  /// @dev Gets total number covers created till date.\\n  function getCoverLength() external view returns (uint len) {\\n    return (allCovers.length);\\n  }\\n\\n  /// @dev Gets Authorised Engine address.\\n  function getAuthQuoteEngine() external view returns (address _add) {\\n    _add = authQuoteEngine;\\n  }\\n\\n  /// @dev Gets the Total Sum Assured amount of a given currency.\\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount) {\\n    amount = currencyCSA[_curr];\\n  }\\n\\n  /// @dev Gets all the Cover ids generated by a given address.\\n  /// @param _add User's address.\\n  /// @return allCover array of covers.\\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover) {\\n    return (userCover[_add]);\\n  }\\n\\n  /// @dev Gets total number of covers generated by a given address\\n  function getUserCoverLength(address _add) external view returns (uint len) {\\n    len = userCover[_add].length;\\n  }\\n\\n  /// @dev Gets the status of a given cover.\\n  function getCoverStatusNo(uint _cid) external view returns (uint8) {\\n    return coverStatus[_cid];\\n  }\\n\\n  /// @dev Gets the Cover Period (in days) of a given cover.\\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp) {\\n    cp = allCovers[_cid].coverPeriod;\\n  }\\n\\n  /// @dev Gets the Sum Assured Amount of a given cover.\\n  function getCoverSumAssured(uint _cid) external view returns (uint sa) {\\n    sa = allCovers[_cid].sumAssured;\\n  }\\n\\n  /// @dev Gets the Currency Name in which a given cover is assured.\\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr) {\\n    curr = allCovers[_cid].currencyCode;\\n  }\\n\\n  /// @dev Gets the validity date (timestamp) of a given cover.\\n  function getValidityOfCover(uint _cid) external view returns (uint date) {\\n    date = allCovers[_cid].validUntil;\\n  }\\n\\n  /// @dev Gets Smart contract address of cover.\\n  function getscAddressOfCover(uint _cid) external view returns (uint, address) {\\n    return (_cid, allCovers[_cid].scAddress);\\n  }\\n\\n  /// @dev Gets the owner address of a given cover.\\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add) {\\n    _add = allCovers[_cid].memberAddress;\\n  }\\n\\n  /// @dev Gets the premium amount of a given cover in NXM.\\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM) {\\n    _premiumNXM = allCovers[_cid].premiumNXM;\\n  }\\n\\n  /// @dev Provides the details of a cover Id\\n  /// @param _cid cover Id\\n  /// @return memberAddress cover user address.\\n  /// @return scAddress smart contract Address\\n  /// @return currencyCode currency of cover\\n  /// @return sumAssured sum assured of cover\\n  /// @return premiumNXM premium in NXM\\n  function getCoverDetailsByCoverID1(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    address _memberAddress,\\n    address _scAddress,\\n    bytes4 _currencyCode,\\n    uint _sumAssured,\\n    uint premiumNXM\\n  )\\n  {\\n    return (\\n    _cid,\\n    allCovers[_cid].memberAddress,\\n    allCovers[_cid].scAddress,\\n    allCovers[_cid].currencyCode,\\n    allCovers[_cid].sumAssured,\\n    allCovers[_cid].premiumNXM\\n    );\\n  }\\n\\n  /// @dev Provides details of a cover Id\\n  /// @param _cid cover Id\\n  /// @return status status of cover.\\n  /// @return sumAssured Sum assurance of cover.\\n  /// @return coverPeriod Cover Period of cover (in days).\\n  /// @return validUntil is validity of cover.\\n  function getCoverDetailsByCoverID2(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    uint8 status,\\n    uint sumAssured,\\n    uint16 coverPeriod,\\n    uint validUntil\\n  )\\n  {\\n\\n    return (\\n    _cid,\\n    coverStatus[_cid],\\n    allCovers[_cid].sumAssured,\\n    allCovers[_cid].coverPeriod,\\n    allCovers[_cid].validUntil\\n    );\\n  }\\n\\n  /// @dev Provides details of a holded cover Id\\n  /// @param _hcid holded cover Id\\n  /// @return scAddress SmartCover address of cover.\\n  /// @return coverCurr currency of cover.\\n  /// @return coverPeriod Cover Period of cover (in days).\\n  function getHoldedCoverDetailsByID1(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint16 coverPeriod\\n  )\\n  {\\n    return (\\n    _hcid,\\n    allCoverHolded[_hcid].scAddress,\\n    allCoverHolded[_hcid].coverCurr,\\n    allCoverHolded[_hcid].coverPeriod\\n    );\\n  }\\n\\n  /// @dev Gets total number holded covers created till date.\\n  function getUserHoldedCoverLength(address _add) external view returns (uint) {\\n    return userHoldedCover[_add].length;\\n  }\\n\\n  /// @dev Gets holded cover index by index of user holded covers.\\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {\\n    return userHoldedCover[_add][index];\\n  }\\n\\n  /// @dev Provides the details of a holded cover Id\\n  /// @param _hcid holded cover Id\\n  /// @return memberAddress holded cover user address.\\n  /// @return coverDetails array contains SA, Cover Currency Price,Price in NXM, Expiration time of Qoute.\\n  function getHoldedCoverDetailsByID2(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address payable memberAddress,\\n    uint[] memory coverDetails\\n  )\\n  {\\n    return (\\n    _hcid,\\n    allCoverHolded[_hcid].userAddress,\\n    allCoverHolded[_hcid].coverDetails\\n    );\\n  }\\n\\n  /// @dev Gets the Total Sum Assured amount of a given currency and smart contract address.\\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount) {\\n    amount = currencyCSAOfSCAdd[_add][_curr];\\n  }\\n\\n  //solhint-disable-next-line\\n  function changeDependentContractAddress() public {}\\n\\n  /// @dev Changes the status of a given cover.\\n  /// @param _cid cover Id.\\n  /// @param _stat New status.\\n  function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {\\n    coverStatus[_cid] = _stat;\\n    emit CoverStatusEvent(_cid, _stat);\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"STLP\\\") {\\n      _changeSTLP(val);\\n\\n    } else if (code == \\\"STL\\\") {\\n\\n      _changeSTL(val);\\n\\n    } else if (code == \\\"PM\\\") {\\n\\n      _changePM(val);\\n\\n    } else if (code == \\\"QUOMIND\\\") {\\n\\n      _changeMinDays(val);\\n\\n    } else if (code == \\\"QUOTOK\\\") {\\n\\n      _setTokensRetained(val);\\n\\n    } else {\\n\\n      revert(\\\"Invalid param code\\\");\\n    }\\n\\n  }\\n\\n  /// @dev Changes the existing Profit Margin value\\n  function _changePM(uint _pm) internal {\\n    pm = _pm;\\n  }\\n\\n  /// @dev Changes the existing Short Term Load Period (STLP) value.\\n  function _changeSTLP(uint _stlp) internal {\\n    stlp = _stlp;\\n  }\\n\\n  /// @dev Changes the existing Short Term Load (STL) value.\\n  function _changeSTL(uint _stl) internal {\\n    stl = _stl;\\n  }\\n\\n  /// @dev Changes the existing Minimum cover period (in days)\\n  function _changeMinDays(uint _days) internal {\\n    minDays = _days;\\n  }\\n\\n  /**\\n   * @dev to set the the amount of tokens retained\\n   * @param val is the amount retained\\n   */\\n  function _setTokensRetained(uint val) internal {\\n    tokensRetained = val;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/NXMToken.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./external/OZIERC20.sol\\\";\\nimport \\\"./external/OZSafeMath.sol\\\";\\n\\ncontract NXMToken is OZIERC20 {\\n  using OZSafeMath for uint256;\\n\\n  event WhiteListed(address indexed member);\\n\\n  event BlackListed(address indexed member);\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowed;\\n\\n  mapping(address => bool) public whiteListed;\\n\\n  mapping(address => uint) public isLockedForMV;\\n\\n  uint256 private _totalSupply;\\n\\n  string public name = \\\"NXM\\\";\\n  string public symbol = \\\"NXM\\\";\\n  uint8 public decimals = 18;\\n  address public operator;\\n\\n  modifier canTransfer(address _to) {\\n    require(whiteListed[_to]);\\n    _;\\n  }\\n\\n  modifier onlyOperator() {\\n    if (operator != address(0))\\n      require(msg.sender == operator);\\n    _;\\n  }\\n\\n  constructor(address _founderAddress, uint _initialSupply) public {\\n    _mint(_founderAddress, _initialSupply);\\n  }\\n\\n  /**\\n  * @dev Total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param owner The address to query the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  /**\\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n  * @param owner address The address which owns the funds.\\n  * @param spender address The address which will spend the funds.\\n  * @return A uint256 specifying the amount of tokens still available for the spender.\\n  */\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n  public\\n  view\\n  returns (uint256)\\n  {\\n    return _allowed[owner][spender];\\n  }\\n\\n  /**\\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n  * @param spender The address which will spend the funds.\\n  * @param value The amount of tokens to be spent.\\n  */\\n  function approve(address spender, uint256 value) public returns (bool) {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\\n  * approve should be called when allowed_[_spender] == 0. To increment\\n  * allowed value is better to use this function to avoid 2 calls (and wait until\\n  * the first transaction is mined)\\n  * From MonolithDAO Token.sol\\n  * @param spender The address which will spend the funds.\\n  * @param addedValue The amount of tokens to increase the allowance by.\\n  */\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  )\\n  public\\n  returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n    _allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n  * approve should be called when allowed_[_spender] == 0. To decrement\\n  * allowed value is better to use this function to avoid 2 calls (and wait until\\n  * the first transaction is mined)\\n  * From MonolithDAO Token.sol\\n  * @param spender The address which will spend the funds.\\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\\n  */\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  )\\n  public\\n  returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n    _allowed[msg.sender][spender].sub(subtractedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Adds a user to whitelist\\n  * @param _member address to add to whitelist\\n  */\\n  function addToWhiteList(address _member) public onlyOperator returns (bool) {\\n    whiteListed[_member] = true;\\n    emit WhiteListed(_member);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev removes a user from whitelist\\n  * @param _member address to remove from whitelist\\n  */\\n  function removeFromWhiteList(address _member) public onlyOperator returns (bool) {\\n    whiteListed[_member] = false;\\n    emit BlackListed(_member);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev change operator address\\n  * @param _newOperator address of new operator\\n  */\\n  function changeOperator(address _newOperator) public onlyOperator returns (bool) {\\n    operator = _newOperator;\\n    return true;\\n  }\\n\\n  /**\\n  * @dev burns an amount of the tokens of the message sender\\n  * account.\\n  * @param amount The amount that will be burnt.\\n  */\\n  function burn(uint256 amount) public returns (bool) {\\n    _burn(msg.sender, amount);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Burns a specific amount of tokens from the target address and decrements allowance\\n  * @param from address The address which you want to send tokens from\\n  * @param value uint256 The amount of token to be burned\\n  */\\n  function burnFrom(address from, uint256 value) public returns (bool) {\\n    _burnFrom(from, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev function that mints an amount of the token and assigns it to\\n  * an account.\\n  * @param account The account that will receive the created tokens.\\n  * @param amount The amount that will be created.\\n  */\\n  function mint(address account, uint256 amount) public onlyOperator {\\n    _mint(account, amount);\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {\\n\\n    require(isLockedForMV[msg.sender] < now); // if not voted under governance\\n    require(value <= _balances[msg.sender]);\\n    _transfer(to, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer tokens to the operator from the specified address\\n  * @param from The address to transfer from.\\n  * @param value The amount to be transferred.\\n  */\\n  function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {\\n    require(value <= _balances[from]);\\n    _transferFrom(from, operator, value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer tokens from one address to another\\n  * @param from address The address which you want to send tokens from\\n  * @param to address The address which you want to transfer to\\n  * @param value uint256 the amount of tokens to be transferred\\n  */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n  public\\n  canTransfer(to)\\n  returns (bool)\\n  {\\n    require(isLockedForMV[from] < now); // if not voted under governance\\n    require(value <= _balances[from]);\\n    require(value <= _allowed[from][msg.sender]);\\n    _transferFrom(from, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Lock the user's tokens\\n   * @param _of user's address.\\n   */\\n  function lockForMemberVote(address _of, uint _days) public onlyOperator {\\n    if (_days.add(now) > isLockedForMV[_of])\\n      isLockedForMV[_of] = _days.add(now);\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function _transfer(address to, uint256 value) internal {\\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(msg.sender, to, value);\\n  }\\n\\n  /**\\n  * @dev Transfer tokens from one address to another\\n  * @param from address The address which you want to send tokens from\\n  * @param to address The address which you want to transfer to\\n  * @param value uint256 the amount of tokens to be transferred\\n  */\\n  function _transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n  internal\\n  {\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  /**\\n  * @dev Internal function that mints an amount of the token and assigns it to\\n  * an account. This encapsulates the modification of balances such that the\\n  * proper events are emitted.\\n  * @param account The account that will receive the created tokens.\\n  * @param amount The amount that will be created.\\n  */\\n  function _mint(address account, uint256 amount) internal {\\n    require(account != address(0));\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n  * @dev Internal function that burns an amount of the token of a given\\n  * account.\\n  * @param account The account whose tokens will be burnt.\\n  * @param amount The amount that will be burnt.\\n  */\\n  function _burn(address account, uint256 amount) internal {\\n    require(amount <= _balances[account]);\\n\\n    _totalSupply = _totalSupply.sub(amount);\\n    _balances[account] = _balances[account].sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n  * @dev Internal function that burns an amount of the token of a given\\n  * account, deducting from the sender's allowance for said account. Uses the\\n  * internal burn function.\\n  * @param account The account whose tokens will be burnt.\\n  * @param value The amount that will be burnt.\\n  */\\n  function _burnFrom(address account, uint256 value) internal {\\n    require(value <= _allowed[account][msg.sender]);\\n\\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n    // this function needs to emit an event with the updated approval.\\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n      value);\\n    _burn(account, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/TokenController.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n  it under the terms of the GNU General Public License as published by\\n  the Free Software Foundation, either version 3 of the License, or\\n  (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n  GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n  along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"./NXMToken.sol\\\";\\nimport \\\"./external/IERC1132.sol\\\";\\n\\ncontract TokenController is IERC1132, Iupgradable {\\n  using SafeMath for uint256;\\n\\n  event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\\n\\n  NXMToken public token;\\n  IPooledStaking public pooledStaking;\\n  uint public minCALockTime = uint(30).mul(1 days);\\n  bytes32 private constant CLA = bytes32(\\\"CLA\\\");\\n\\n  /**\\n  * @dev Just for interface\\n  */\\n  function changeDependentContractAddress() public {\\n    token = NXMToken(ms.tokenAddress());\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n  }\\n\\n  /**\\n   * @dev to change the operator address\\n   * @param _newOperator is the new address of operator\\n   */\\n  function changeOperator(address _newOperator) public onlyInternal {\\n    token.changeOperator(_newOperator);\\n  }\\n\\n  /**\\n   * @dev Proxies token transfer through this contract to allow staking when members are locked for voting\\n   * @param _from   Source address\\n   * @param _to     Destination address\\n   * @param _value  Amount to transfer\\n   */\\n  function operatorTransfer(address _from, address _to, uint _value) onlyInternal external returns (bool) {\\n    require(msg.sender == address(pooledStaking), \\\"Call is only allowed from PooledStaking address\\\");\\n    require(token.operatorTransfer(_from, _value), \\\"Operator transfer failed\\\");\\n    require(token.transfer(_to, _value), \\\"Internal transfer failed\\\");\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens,\\n  *    for CLA reason and for a specified time\\n  * @param _reason The reason to lock tokens, currently restricted to CLA\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function lock(bytes32 _reason, uint256 _amount, uint256 _time) public checkPause returns (bool)\\n  {\\n    require(_reason == CLA, \\\"Restricted to reason CLA\\\");\\n    require(minCALockTime <= _time, \\\"Should lock for minimum time\\\");\\n    // If tokens are already locked, then functions extendLock or\\n    // increaseLockAmount should be used to make any changes\\n    _lock(msg.sender, _reason, _amount, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens against an address,\\n  *    for a specified reason and time\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  * @param _of address whose tokens are to be locked\\n  */\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time)\\n  public\\n  onlyInternal\\n  returns (bool)\\n  {\\n    // If tokens are already locked, then functions extendLock or\\n    // increaseLockAmount should be used to make any changes\\n    _lock(_of, _reason, _amount, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Extends lock for reason CLA for a specified time\\n  * @param _reason The reason to lock tokens, currently restricted to CLA\\n  * @param _time Lock extension time in seconds\\n  */\\n  function extendLock(bytes32 _reason, uint256 _time)\\n  public\\n  checkPause\\n  returns (bool)\\n  {\\n    require(_reason == CLA, \\\"Restricted to reason CLA\\\");\\n    _extendLock(msg.sender, _reason, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Extends lock for a specified reason and time\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock extension time in seconds\\n  */\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time)\\n  public\\n  onlyInternal\\n  returns (bool)\\n  {\\n    _extendLock(_of, _reason, _time);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Increase number of tokens locked for a CLA reason\\n  * @param _reason The reason to lock tokens, currently restricted to CLA\\n  * @param _amount Number of tokens to be increased\\n  */\\n  function increaseLockAmount(bytes32 _reason, uint256 _amount)\\n  public\\n  checkPause\\n  returns (bool)\\n  {\\n    require(_reason == CLA, \\\"Restricted to reason CLA\\\");\\n    require(_tokensLocked(msg.sender, _reason) > 0);\\n    token.operatorTransfer(msg.sender, _amount);\\n\\n    locked[msg.sender][_reason].amount = locked[msg.sender][_reason].amount.add(_amount);\\n    emit Locked(msg.sender, _reason, _amount, locked[msg.sender][_reason].validity);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev burns tokens of an address\\n   * @param _of is the address to burn tokens of\\n   * @param amount is the amount to burn\\n   * @return the boolean status of the burning process\\n   */\\n  function burnFrom(address _of, uint amount) public onlyInternal returns (bool) {\\n    return token.burnFrom(_of, amount);\\n  }\\n\\n  /**\\n  * @dev Burns locked tokens of a user\\n  * @param _of address whose tokens are to be burned\\n  * @param _reason lock reason for which tokens are to be burned\\n  * @param _amount amount of tokens to burn\\n  */\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {\\n    _burnLockedTokens(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev reduce lock duration for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock reduction time in seconds\\n  */\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {\\n    _reduceLock(_of, _reason, _time);\\n  }\\n\\n  /**\\n  * @dev Released locked tokens of an address locked for a specific reason\\n  * @param _of address whose tokens are to be released from lock\\n  * @param _reason reason of the lock\\n  * @param _amount amount of tokens to release\\n  */\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount)\\n  public\\n  onlyInternal\\n  {\\n    _releaseLockedTokens(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev Adds an address to whitelist maintained in the contract\\n  * @param _member address to add to whitelist\\n  */\\n  function addToWhitelist(address _member) public onlyInternal {\\n    token.addToWhiteList(_member);\\n  }\\n\\n  /**\\n  * @dev Removes an address from the whitelist in the token\\n  * @param _member address to remove\\n  */\\n  function removeFromWhitelist(address _member) public onlyInternal {\\n    token.removeFromWhiteList(_member);\\n  }\\n\\n  /**\\n  * @dev Mints new token for an address\\n  * @param _member address to reward the minted tokens\\n  * @param _amount number of tokens to mint\\n  */\\n  function mint(address _member, uint _amount) public onlyInternal {\\n    token.mint(_member, _amount);\\n  }\\n\\n  /**\\n   * @dev Lock the user's tokens\\n   * @param _of user's address.\\n   */\\n  function lockForMemberVote(address _of, uint _days) public onlyInternal {\\n    token.lockForMemberVote(_of, _days);\\n  }\\n\\n  /**\\n  * @dev Unlocks the unlockable tokens against CLA of a specified address\\n  * @param _of Address of user, claiming back unlockable tokens against CLA\\n  */\\n  function unlock(address _of)\\n  public\\n  checkPause\\n  returns (uint256 unlockableTokens)\\n  {\\n    unlockableTokens = _tokensUnlockable(_of, CLA);\\n    if (unlockableTokens > 0) {\\n      locked[_of][CLA].claimed = true;\\n      emit Unlocked(_of, CLA, unlockableTokens);\\n      require(token.transfer(_of, unlockableTokens));\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"MNCLT\\\") {\\n      minCALockTime = val.mul(1 days);\\n    } else {\\n      revert(\\\"Invalid param code\\\");\\n    }\\n  }\\n\\n  /**\\n  * @dev Gets the validity of locked tokens of a specified address\\n  * @param _of The address to query the validity\\n  * @param reason reason for which tokens were locked\\n  */\\n  function getLockedTokensValidity(address _of, bytes32 reason)\\n  public\\n  view\\n  returns (uint256 validity)\\n  {\\n    validity = locked[_of][reason].validity;\\n  }\\n\\n  /**\\n  * @dev Gets the unlockable tokens of a specified address\\n  * @param _of The address to query the the unlockable token count of\\n  */\\n  function getUnlockableTokens(address _of)\\n  public\\n  view\\n  returns (uint256 unlockableTokens)\\n  {\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function tokensLocked(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensLocked(_of, _reason);\\n  }\\n\\n  /**\\n  * @dev Returns unlockable tokens for a specified address for a specified reason\\n  * @param _of The address to query the the unlockable token count of\\n  * @param _reason The reason to query the unlockable tokens for\\n  */\\n  function tokensUnlockable(address _of, bytes32 _reason)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensUnlockable(_of, _reason);\\n  }\\n\\n  function totalSupply() public view returns (uint256)\\n  {\\n    return token.totalSupply();\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason at a specific time\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  * @param _time The timestamp to query the lock tokens for\\n  */\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  public\\n  view\\n  returns (uint256 amount)\\n  {\\n    return _tokensLockedAtTime(_of, _reason, _time);\\n  }\\n\\n  /**\\n  * @dev Returns the total amount of tokens held by an address:\\n  *   transferable + locked + staked for pooled staking - pending burns.\\n  *   Used by Claims and Governance in member voting to calculate the user's vote weight.\\n  *\\n  * @param _of The address to query the total balance of\\n  * @param _of The address to query the total balance of\\n  */\\n  function totalBalanceOf(address _of) public view returns (uint256 amount) {\\n\\n    amount = token.balanceOf(_of);\\n\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\\n    }\\n\\n    uint stakerReward = pooledStaking.stakerReward(_of);\\n    uint stakerDeposit = pooledStaking.stakerDeposit(_of);\\n\\n    amount = amount.add(stakerDeposit).add(stakerReward);\\n  }\\n\\n  /**\\n  * @dev Returns the total locked tokens at time\\n  *   Returns the total amount of locked and staked tokens at a given time. Used by MemberRoles to check eligibility\\n  *   for withdraw / switch membership. Includes tokens locked for Claim Assessment and staked for Risk Assessment.\\n  *   Does not take into account pending burns.\\n  *\\n  * @param _of member whose locked tokens are to be calculate\\n  * @param _time timestamp when the tokens should be locked\\n  */\\n  function totalLockedBalance(address _of, uint256 _time) public view returns (uint256 amount) {\\n\\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\\n      amount = amount.add(_tokensLockedAtTime(_of, lockReason[_of][i], _time));\\n    }\\n\\n    amount = amount.add(pooledStaking.stakerDeposit(_of));\\n  }\\n\\n  /**\\n  * @dev Locks a specified amount of tokens against an address,\\n  *    for a specified reason and time\\n  * @param _of address whose tokens are to be locked\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be locked\\n  * @param _time Lock time in seconds\\n  */\\n  function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) == 0);\\n    require(_amount != 0);\\n\\n    if (locked[_of][_reason].amount == 0) {\\n      lockReason[_of].push(_reason);\\n    }\\n\\n    require(token.operatorTransfer(_of, _amount));\\n\\n    uint256 validUntil = now.add(_time); // solhint-disable-line\\n    locked[_of][_reason] = LockToken(_amount, validUntil, false);\\n    emit Locked(_of, _reason, _amount, validUntil);\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  */\\n  function _tokensLocked(address _of, bytes32 _reason)\\n  internal\\n  view\\n  returns (uint256 amount)\\n  {\\n    if (!locked[_of][_reason].claimed) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Returns tokens locked for a specified address for a\\n  *    specified reason at a specific time\\n  *\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to query the lock tokens for\\n  * @param _time The timestamp to query the lock tokens for\\n  */\\n  function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  internal\\n  view\\n  returns (uint256 amount)\\n  {\\n    if (locked[_of][_reason].validity > _time) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Extends lock for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock extension time in seconds\\n  */\\n  function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) > 0);\\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\\n    locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\\n  }\\n\\n  /**\\n  * @dev reduce lock duration for a specified reason and time\\n  * @param _of The address whose tokens are locked\\n  * @param _reason The reason to lock tokens\\n  * @param _time Lock reduction time in seconds\\n  */\\n  function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {\\n    require(_tokensLocked(_of, _reason) > 0);\\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\\n    locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);\\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\\n  }\\n\\n  /**\\n  * @dev Returns unlockable tokens for a specified address for a specified reason\\n  * @param _of The address to query the the unlockable token count of\\n  * @param _reason The reason to query the unlockable tokens for\\n  */\\n  function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount)\\n  {\\n    if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) {\\n      amount = locked[_of][_reason].amount;\\n    }\\n  }\\n\\n  /**\\n  * @dev Burns locked tokens of a user\\n  * @param _of address whose tokens are to be burned\\n  * @param _reason lock reason for which tokens are to be burned\\n  * @param _amount amount of tokens to burn\\n  */\\n  function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {\\n    uint256 amount = _tokensLocked(_of, _reason);\\n    require(amount >= _amount);\\n\\n    if (amount == _amount) {\\n      locked[_of][_reason].claimed = true;\\n    }\\n\\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\\n    if (locked[_of][_reason].amount == 0) {\\n      _removeReason(_of, _reason);\\n    }\\n    token.burn(_amount);\\n    emit Burned(_of, _reason, _amount);\\n  }\\n\\n  /**\\n  * @dev Released locked tokens of an address locked for a specific reason\\n  * @param _of address whose tokens are to be released from lock\\n  * @param _reason reason of the lock\\n  * @param _amount amount of tokens to release\\n  */\\n  function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal\\n  {\\n    uint256 amount = _tokensLocked(_of, _reason);\\n    require(amount >= _amount);\\n\\n    if (amount == _amount) {\\n      locked[_of][_reason].claimed = true;\\n    }\\n\\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\\n    if (locked[_of][_reason].amount == 0) {\\n      _removeReason(_of, _reason);\\n    }\\n    require(token.transfer(_of, _amount));\\n    emit Unlocked(_of, _reason, _amount);\\n  }\\n\\n  function _removeReason(address _of, bytes32 _reason) internal {\\n    uint len = lockReason[_of].length;\\n    for (uint i = 0; i < len; i++) {\\n      if (lockReason[_of][i] == _reason) {\\n        lockReason[_of][i] = lockReason[_of][len.sub(1)];\\n        lockReason[_of].pop();\\n        break;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/TokenData.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/Iupgradable.sol\\\";\\n\\ncontract TokenData is Iupgradable {\\n  using SafeMath for uint;\\n\\n  address payable public walletAddress;\\n  uint public lockTokenTimeAfterCoverExp;\\n  uint public bookTime;\\n  uint public lockCADays;\\n  uint public lockMVDays;\\n  uint public scValidDays;\\n  uint public joiningFee;\\n  uint public stakerCommissionPer;\\n  uint public stakerMaxCommissionPer;\\n  uint public tokenExponent;\\n  uint public priceStep;\\n\\n  struct StakeCommission {\\n    uint commissionEarned;\\n    uint commissionRedeemed;\\n  }\\n\\n  struct Stake {\\n    address stakedContractAddress;\\n    uint stakedContractIndex;\\n    uint dateAdd;\\n    uint stakeAmount;\\n    uint unlockedAmount;\\n    uint burnedAmount;\\n    uint unLockableBeforeLastBurn;\\n  }\\n\\n  struct Staker {\\n    address stakerAddress;\\n    uint stakerIndex;\\n  }\\n\\n  struct CoverNote {\\n    uint amount;\\n    bool isDeposited;\\n  }\\n\\n  /**\\n   * @dev mapping of uw address to array of sc address to fetch\\n   * all staked contract address of underwriter, pushing\\n   * data into this array of Stake returns stakerIndex\\n   */\\n  mapping(address => Stake[]) public stakerStakedContracts;\\n\\n  /**\\n   * @dev mapping of sc address to array of UW address to fetch\\n   * all underwritters of the staked smart contract\\n   * pushing data into this mapped array returns scIndex\\n   */\\n  mapping(address => Staker[]) public stakedContractStakers;\\n\\n  /**\\n   * @dev mapping of staked contract Address to the array of StakeCommission\\n   * here index of this array is stakedContractIndex\\n   */\\n  mapping(address => mapping(uint => StakeCommission)) public stakedContractStakeCommission;\\n\\n  mapping(address => uint) public lastCompletedStakeCommission;\\n\\n  /**\\n   * @dev mapping of the staked contract address to the current\\n   * staker index who will receive commission.\\n   */\\n  mapping(address => uint) public stakedContractCurrentCommissionIndex;\\n\\n  /**\\n   * @dev mapping of the staked contract address to the\\n   * current staker index to burn token from.\\n   */\\n  mapping(address => uint) public stakedContractCurrentBurnIndex;\\n\\n  /**\\n   * @dev mapping to return true if Cover Note deposited against coverId\\n   */\\n  mapping(uint => CoverNote) public depositedCN;\\n\\n  mapping(address => uint) internal isBookedTokens;\\n\\n  event Commission(\\n    address indexed stakedContractAddress,\\n    address indexed stakerAddress,\\n    uint indexed scIndex,\\n    uint commissionAmount\\n  );\\n\\n  constructor(address payable _walletAdd) public {\\n    walletAddress = _walletAdd;\\n    bookTime = 12 hours;\\n    joiningFee = 2000000000000000; // 0.002 Ether\\n    lockTokenTimeAfterCoverExp = 35 days;\\n    scValidDays = 250;\\n    lockCADays = 7 days;\\n    lockMVDays = 2 days;\\n    stakerCommissionPer = 20;\\n    stakerMaxCommissionPer = 50;\\n    tokenExponent = 4;\\n    priceStep = 1000;\\n  }\\n\\n  /**\\n   * @dev Change the wallet address which receive Joining Fee\\n   */\\n  function changeWalletAddress(address payable _address) external onlyInternal {\\n    walletAddress = _address;\\n  }\\n\\n  /**\\n   * @dev Gets Uint Parameters of a code\\n   * @param code whose details we want\\n   * @return string value of the code\\n   * @return associated amount (time or perc or value) to the code\\n   */\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\\n    codeVal = code;\\n    if (code == \\\"TOKEXP\\\") {\\n\\n      val = tokenExponent;\\n\\n    } else if (code == \\\"TOKSTEP\\\") {\\n\\n      val = priceStep;\\n\\n    } else if (code == \\\"RALOCKT\\\") {\\n\\n      val = scValidDays;\\n\\n    } else if (code == \\\"RACOMM\\\") {\\n\\n      val = stakerCommissionPer;\\n\\n    } else if (code == \\\"RAMAXC\\\") {\\n\\n      val = stakerMaxCommissionPer;\\n\\n    } else if (code == \\\"CABOOKT\\\") {\\n\\n      val = bookTime / (1 hours);\\n\\n    } else if (code == \\\"CALOCKT\\\") {\\n\\n      val = lockCADays / (1 days);\\n\\n    } else if (code == \\\"MVLOCKT\\\") {\\n\\n      val = lockMVDays / (1 days);\\n\\n    } else if (code == \\\"QUOLOCKT\\\") {\\n\\n      val = lockTokenTimeAfterCoverExp / (1 days);\\n\\n    } else if (code == \\\"JOINFEE\\\") {\\n\\n      val = joiningFee;\\n\\n    }\\n  }\\n\\n  /**\\n  * @dev Just for interface\\n  */\\n  function changeDependentContractAddress() public {//solhint-disable-line\\n  }\\n\\n  /**\\n   * @dev to get the contract staked by a staker\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return the address of staked contract\\n   */\\n  function getStakerStakedContractByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (address stakedContractAddress)\\n  {\\n    stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked burned\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return amount burned\\n   */\\n  function getStakerStakedBurnedByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint burnedAmount)\\n  {\\n    burnedAmount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].burnedAmount;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked unlockable before the last burn\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return unlockable staked tokens\\n   */\\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint unlockable)\\n  {\\n    unlockable = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked contract index\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return is the index of the smart contract address\\n   */\\n  function getStakerStakedContractIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint scIndex)\\n  {\\n    scIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n  }\\n\\n  /**\\n   * @dev to get the staker index of the staked contract\\n   * @param _stakedContractAddress is the address of the staked contract\\n   * @param _stakedContractIndex is the index of staked contract\\n   * @return is the index of the staker\\n   */\\n  function getStakedContractStakerIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  public\\n  view\\n  returns (uint sIndex)\\n  {\\n    sIndex = stakedContractStakers[\\n    _stakedContractAddress][_stakedContractIndex].stakerIndex;\\n  }\\n\\n  /**\\n   * @dev to get the staker's initial staked amount on the contract\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return staked amount\\n   */\\n  function getStakerInitialStakedAmountOnContract(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint amount)\\n  {\\n    amount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakeAmount;\\n  }\\n\\n  /**\\n   * @dev to get the staker's staked contract length\\n   * @param _stakerAddress is the address of the staker\\n   * @return length of staked contract\\n   */\\n  function getStakerStakedContractLength(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint length)\\n  {\\n    length = stakerStakedContracts[_stakerAddress].length;\\n  }\\n\\n  /**\\n   * @dev to get the staker's unlocked tokens which were staked\\n   * @param _stakerAddress is the address of the staker\\n   * @param _stakerIndex is the index of staker\\n   * @return amount\\n   */\\n  function getStakerUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint amount)\\n  {\\n    amount = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].unlockedAmount;\\n  }\\n\\n  /**\\n   * @dev pushes the unlocked staked tokens by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker to distribute commission.\\n   * @param _amount amount to be given as commission.\\n   */\\n  function pushUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unlockedAmount.add(_amount);\\n  }\\n\\n  /**\\n   * @dev pushes the Burned tokens for a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be burned.\\n   */\\n  function pushBurnedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].burnedAmount.add(_amount);\\n  }\\n\\n  /**\\n   * @dev pushes the unLockable tokens for a staker before last burn.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be added to unlockable.\\n   */\\n  function pushUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn.add(_amount);\\n  }\\n\\n  /**\\n   * @dev sets the unLockable tokens for a staker before last burn.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker.\\n   * @param _amount amount to be added to unlockable.\\n   */\\n  function setUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakerStakedContracts[_stakerAddress][\\n    _stakerIndex].unLockableBeforeLastBurn = _amount;\\n  }\\n\\n  /**\\n   * @dev pushes the earned commission earned by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakedContractAddress address of smart contract.\\n   * @param _stakedContractIndex index of the staker to distribute commission.\\n   * @param _commissionAmount amount to be given as commission.\\n   */\\n  function pushEarnedStakeCommissions(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex,\\n    uint _commissionAmount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex].\\n    commissionEarned = stakedContractStakeCommission[_stakedContractAddress][\\n    _stakedContractIndex].commissionEarned.add(_commissionAmount);\\n\\n    emit Commission(\\n      _stakerAddress,\\n      _stakedContractAddress,\\n      _stakedContractIndex,\\n      _commissionAmount\\n    );\\n  }\\n\\n  /**\\n   * @dev pushes the redeemed commission redeemed by a staker.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker to distribute commission.\\n   * @param _amount amount to be given as commission.\\n   */\\n  function pushRedeemedStakeCommissions(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  {\\n    uint stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    address stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    stakedContractStakeCommission[stakedContractAddress][stakedContractIndex].\\n    commissionRedeemed = stakedContractStakeCommission[\\n    stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);\\n  }\\n\\n  /**\\n   * @dev Gets stake commission given to an underwriter\\n   * for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint)\\n  {\\n    return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);\\n  }\\n\\n  /**\\n   * @dev Gets stake commission redeemed by an underwriter\\n   * for particular staked contract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   * @return commissionEarned total amount given to staker.\\n   */\\n  function getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  public\\n  view\\n  returns (uint)\\n  {\\n    return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);\\n  }\\n\\n  /**\\n   * @dev Gets total stake commission given to an underwriter\\n   * @param _stakerAddress address of staker.\\n   * @return totalCommissionEarned total commission earned by staker.\\n   */\\n  function getStakerTotalEarnedStakeCommission(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint totalCommissionEarned)\\n  {\\n    totalCommissionEarned = 0;\\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\\n      totalCommissionEarned = totalCommissionEarned.\\n      add(_getStakerEarnedStakeCommission(_stakerAddress, i));\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets total stake commission given to an underwriter\\n   * @param _stakerAddress address of staker.\\n   * @return totalCommissionEarned total commission earned by staker.\\n   */\\n  function getStakerTotalReedmedStakeCommission(\\n    address _stakerAddress\\n  )\\n  public\\n  view\\n  returns (uint totalCommissionRedeemed)\\n  {\\n    totalCommissionRedeemed = 0;\\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\\n      totalCommissionRedeemed = totalCommissionRedeemed.add(\\n        _getStakerRedeemedStakeCommission(_stakerAddress, i));\\n    }\\n  }\\n\\n  /**\\n   * @dev set flag to deposit/ undeposit cover note\\n   * against a cover Id\\n   * @param coverId coverId of Cover\\n   * @param flag true/false for deposit/undeposit\\n   */\\n  function setDepositCN(uint coverId, bool flag) public onlyInternal {\\n\\n    if (flag == true) {\\n      require(!depositedCN[coverId].isDeposited, \\\"Cover note already deposited\\\");\\n    }\\n\\n    depositedCN[coverId].isDeposited = flag;\\n  }\\n\\n  /**\\n   * @dev set locked cover note amount\\n   * against a cover Id\\n   * @param coverId coverId of Cover\\n   * @param amount amount of nxm to be locked\\n   */\\n  function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {\\n\\n    depositedCN[coverId].amount = amount;\\n  }\\n\\n  /**\\n   * @dev to get the staker address on a staked contract\\n   * @param _stakedContractAddress is the address of the staked contract in concern\\n   * @param _stakedContractIndex is the index of staked contract's index\\n   * @return address of staker\\n   */\\n  function getStakedContractStakerByIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  public\\n  view\\n  returns (address stakerAddress)\\n  {\\n    stakerAddress = stakedContractStakers[\\n    _stakedContractAddress][_stakedContractIndex].stakerAddress;\\n  }\\n\\n  /**\\n   * @dev to get the length of stakers on a staked contract\\n   * @param _stakedContractAddress is the address of the staked contract in concern\\n   * @return length in concern\\n   */\\n  function getStakedContractStakersLength(\\n    address _stakedContractAddress\\n  )\\n  public\\n  view\\n  returns (uint length)\\n  {\\n    length = stakedContractStakers[_stakedContractAddress].length;\\n  }\\n\\n  /**\\n   * @dev Adds a new stake record.\\n   * @param _stakerAddress staker address.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _amount amountof NXM to be staked.\\n   */\\n  function addStake(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _amount\\n  )\\n  public\\n  onlyInternal\\n  returns (uint scIndex)\\n  {\\n    scIndex = (stakedContractStakers[_stakedContractAddress].push(\\n      Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);\\n    stakerStakedContracts[_stakerAddress].push(\\n      Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));\\n  }\\n\\n  /**\\n   * @dev books the user's tokens for maintaining Assessor Velocity,\\n   * i.e. once a token is used to cast a vote as a Claims assessor,\\n   * @param _of user's address.\\n   */\\n  function bookCATokens(address _of) public onlyInternal {\\n    require(!isCATokensBooked(_of), \\\"Tokens already booked\\\");\\n    isBookedTokens[_of] = now.add(bookTime);\\n  }\\n\\n  /**\\n   * @dev to know if claim assessor's tokens are booked or not\\n   * @param _of is the claim assessor's address in concern\\n   * @return boolean representing the status of tokens booked\\n   */\\n  function isCATokensBooked(address _of) public view returns (bool res) {\\n    if (now < isBookedTokens[_of])\\n      res = true;\\n  }\\n\\n  /**\\n   * @dev Sets the index which will receive commission.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setStakedContractCurrentCommissionIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Sets the last complete commission index\\n   * @param _stakerAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setLastCompletedStakeCommissionIndex(\\n    address _stakerAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    lastCompletedStakeCommission[_stakerAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Sets the index till which commission is distrubuted.\\n   * @param _stakedContractAddress smart contract address.\\n   * @param _index current index.\\n   */\\n  function setStakedContractCurrentBurnIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  )\\n  public\\n  onlyInternal\\n  {\\n    stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters of a code\\n   * @param code whose details we want to update\\n   * @param val value to set\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(ms.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"TOKEXP\\\") {\\n\\n      _setTokenExponent(val);\\n\\n    } else if (code == \\\"TOKSTEP\\\") {\\n\\n      _setPriceStep(val);\\n\\n    } else if (code == \\\"RALOCKT\\\") {\\n\\n      _changeSCValidDays(val);\\n\\n    } else if (code == \\\"RACOMM\\\") {\\n\\n      _setStakerCommissionPer(val);\\n\\n    } else if (code == \\\"RAMAXC\\\") {\\n\\n      _setStakerMaxCommissionPer(val);\\n\\n    } else if (code == \\\"CABOOKT\\\") {\\n\\n      _changeBookTime(val * 1 hours);\\n\\n    } else if (code == \\\"CALOCKT\\\") {\\n\\n      _changelockCADays(val * 1 days);\\n\\n    } else if (code == \\\"MVLOCKT\\\") {\\n\\n      _changelockMVDays(val * 1 days);\\n\\n    } else if (code == \\\"QUOLOCKT\\\") {\\n\\n      _setLockTokenTimeAfterCoverExp(val * 1 days);\\n\\n    } else if (code == \\\"JOINFEE\\\") {\\n\\n      _setJoiningFee(val);\\n\\n    } else {\\n      revert(\\\"Invalid param code\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev Internal function to get stake commission given to an\\n   * underwriter for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function _getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  internal\\n  view\\n  returns (uint amount)\\n  {\\n    uint _stakedContractIndex;\\n    address _stakedContractAddress;\\n    _stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    _stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    amount = stakedContractStakeCommission[\\n    _stakedContractAddress][_stakedContractIndex].commissionEarned;\\n  }\\n\\n  /**\\n   * @dev Internal function to get stake commission redeemed by an\\n   * underwriter for particular stakedcontract on given index.\\n   * @param _stakerAddress address of staker.\\n   * @param _stakerIndex index of the staker commission.\\n   */\\n  function _getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  internal\\n  view\\n  returns (uint amount)\\n  {\\n    uint _stakedContractIndex;\\n    address _stakedContractAddress;\\n    _stakedContractAddress = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractAddress;\\n    _stakedContractIndex = stakerStakedContracts[\\n    _stakerAddress][_stakerIndex].stakedContractIndex;\\n    amount = stakedContractStakeCommission[\\n    _stakedContractAddress][_stakedContractIndex].commissionRedeemed;\\n  }\\n\\n  /**\\n   * @dev to set the percentage of staker commission\\n   * @param _val is new percentage value\\n   */\\n  function _setStakerCommissionPer(uint _val) internal {\\n    stakerCommissionPer = _val;\\n  }\\n\\n  /**\\n   * @dev to set the max percentage of staker commission\\n   * @param _val is new percentage value\\n   */\\n  function _setStakerMaxCommissionPer(uint _val) internal {\\n    stakerMaxCommissionPer = _val;\\n  }\\n\\n  /**\\n   * @dev to set the token exponent value\\n   * @param _val is new value\\n   */\\n  function _setTokenExponent(uint _val) internal {\\n    tokenExponent = _val;\\n  }\\n\\n  /**\\n   * @dev to set the price step\\n   * @param _val is new value\\n   */\\n  function _setPriceStep(uint _val) internal {\\n    priceStep = _val;\\n  }\\n\\n  /**\\n   * @dev Changes number of days for which NXM needs to staked in case of underwriting\\n   */\\n  function _changeSCValidDays(uint _days) internal {\\n    scValidDays = _days;\\n  }\\n\\n  /**\\n   * @dev Changes the time period up to which tokens will be locked.\\n   *      Used to generate the validity period of tokens booked by\\n   *      a user for participating in claim's assessment/claim's voting.\\n   */\\n  function _changeBookTime(uint _time) internal {\\n    bookTime = _time;\\n  }\\n\\n  /**\\n   * @dev Changes lock CA days - number of days for which tokens\\n   * are locked while submitting a vote.\\n   */\\n  function _changelockCADays(uint _val) internal {\\n    lockCADays = _val;\\n  }\\n\\n  /**\\n   * @dev Changes lock MV days - number of days for which tokens are locked\\n   * while submitting a vote.\\n   */\\n  function _changelockMVDays(uint _val) internal {\\n    lockMVDays = _val;\\n  }\\n\\n  /**\\n   * @dev Changes extra lock period for a cover, post its expiry.\\n   */\\n  function _setLockTokenTimeAfterCoverExp(uint time) internal {\\n    lockTokenTimeAfterCoverExp = time;\\n  }\\n\\n  /**\\n   * @dev Set the joining fee for membership\\n   */\\n  function _setJoiningFee(uint _amount) internal {\\n    joiningFee = _amount;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/Iupgradable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./INXMMaster.sol\\\";\\n\\ncontract Iupgradable {\\n\\n  INXMMaster public ms;\\n  address public nxMasterAddress;\\n\\n  modifier onlyInternal {\\n    require(ms.isInternal(msg.sender));\\n    _;\\n  }\\n\\n  modifier isMemberAndcheckPause {\\n    require(ms.isPause() == false && ms.isMember(msg.sender) == true);\\n    _;\\n  }\\n\\n  modifier onlyOwner {\\n    require(ms.isOwner(msg.sender));\\n    _;\\n  }\\n\\n  modifier checkPause {\\n    require(ms.isPause() == false);\\n    _;\\n  }\\n\\n  modifier isMember {\\n    require(ms.isMember(msg.sender), \\\"Not member\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public;\\n\\n  /**\\n   * @dev change master address\\n   * @param _masterAddress is the new address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n    if (address(ms) != address(0)) {\\n      require(address(ms) == msg.sender, \\\"Not master\\\");\\n    }\\n\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/INXMMaster.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\ncontract INXMMaster {\\n\\n  address public tokenAddress;\\n\\n  address public owner;\\n\\n  uint public pauseTime;\\n\\n  function delegateCallBack(bytes32 myid) external;\\n\\n  function masterInitialized() public view returns (bool);\\n\\n  function isInternal(address _add) public view returns (bool);\\n\\n  function isPause() public view returns (bool check);\\n\\n  function isOwner(address _add) public view returns (bool);\\n\\n  function isMember(address _add) public view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) public view returns (bool);\\n\\n  function updatePauseTime(uint _time) public;\\n\\n  function dAppLocker() public view returns (address _add);\\n\\n  function dAppToken() public view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) public view returns (address payable contractAddress);\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/OZIERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface OZIERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n  external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n  external returns (bool);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n  external view returns (uint256);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/OZSafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary OZSafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/token/external/IERC1132.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC1132 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/1132\\n */\\n\\ncontract IERC1132 {\\n  /**\\n   * @dev Reasons why a user's tokens have been locked\\n   */\\n  mapping(address => bytes32[]) public lockReason;\\n\\n  /**\\n   * @dev locked token structure\\n   */\\n  struct LockToken {\\n    uint256 amount;\\n    uint256 validity;\\n    bool claimed;\\n  }\\n\\n  /**\\n   * @dev Holds number & validity of tokens locked for a given reason for\\n   *      a specified address\\n   */\\n  mapping(address => mapping(bytes32 => LockToken)) public locked;\\n\\n  /**\\n   * @dev Records data of all the tokens Locked\\n   */\\n  event Locked(\\n    address indexed _of,\\n    bytes32 indexed _reason,\\n    uint256 _amount,\\n    uint256 _validity\\n  );\\n\\n  /**\\n   * @dev Records data of all the tokens unlocked\\n   */\\n  event Unlocked(\\n    address indexed _of,\\n    bytes32 indexed _reason,\\n    uint256 _amount\\n  );\\n\\n  /**\\n   * @dev Locks a specified amount of tokens against an address,\\n   *      for a specified reason and time\\n   * @param _reason The reason to lock tokens\\n   * @param _amount Number of tokens to be locked\\n   * @param _time Lock time in seconds\\n   */\\n  function lock(bytes32 _reason, uint256 _amount, uint256 _time)\\n  public returns (bool);\\n\\n  /**\\n   * @dev Returns tokens locked for a specified address for a\\n   *      specified reason\\n   *\\n   * @param _of The address whose tokens are locked\\n   * @param _reason The reason to query the lock tokens for\\n   */\\n  function tokensLocked(address _of, bytes32 _reason)\\n  public view returns (uint256 amount);\\n\\n  /**\\n   * @dev Returns tokens locked for a specified address for a\\n   *      specified reason at a specific time\\n   *\\n   * @param _of The address whose tokens are locked\\n   * @param _reason The reason to query the lock tokens for\\n   * @param _time The timestamp to query the lock tokens for\\n   */\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n  public view returns (uint256 amount);\\n\\n  /**\\n   * @dev Returns total tokens held by an address (locked + transferable)\\n   * @param _of The address to query the total balance of\\n   */\\n  function totalBalanceOf(address _of)\\n  public view returns (uint256 amount);\\n\\n  /**\\n   * @dev Extends lock for a specified reason and time\\n   * @param _reason The reason to lock tokens\\n   * @param _time Lock extension time in seconds\\n   */\\n  function extendLock(bytes32 _reason, uint256 _time)\\n  public returns (bool);\\n\\n  /**\\n   * @dev Increase number of tokens locked for a specified reason\\n   * @param _reason The reason to lock tokens\\n   * @param _amount Number of tokens to be increased\\n   */\\n  function increaseLockAmount(bytes32 _reason, uint256 _amount)\\n  public returns (bool);\\n\\n  /**\\n   * @dev Returns unlockable tokens for a specified address for a specified reason\\n   * @param _of The address to query the the unlockable token count of\\n   * @param _reason The reason to query the unlockable tokens for\\n   */\\n  function tokensUnlockable(address _of, bytes32 _reason)\\n  public view returns (uint256 amount);\\n\\n  /**\\n   * @dev Unlocks the unlockable tokens of a specified address\\n   * @param _of Address of user, claiming back unlockable tokens\\n   */\\n  function unlock(address _of)\\n  public returns (uint256 unlockableTokens);\\n\\n  /**\\n   * @dev Gets the unlockable tokens of a specified address\\n   * @param _of The address to query the the unlockable token count of\\n   */\\n  function getUnlockableTokens(address _of)\\n  public view returns (uint256 unlockableTokens);\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurnCATokens\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"burnCAToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"burnDepositCN\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"depositCN\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_coverId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"name\":\"extendCNEPOff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coverId\",\"type\":\"uint256\"}],\"name\":\"getLockedCNAgainstCover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getUserAllLockedCNTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_coverId\",\"type\":\"uint256\"}],\"name\":\"getUserLockedCNTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"isLockedForMemberVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverNoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coverPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"lockCN\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ms\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nxMasterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pooledStaking\",\"outputs\":[{\"internalType\":\"contract IPooledStaking\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_coverPriceNXM\",\"type\":\"uint256\"}],\"name\":\"pushStakerRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"qd\",\"outputs\":[{\"internalType\":\"contract QuotationData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tc\",\"outputs\":[{\"internalType\":\"contract TokenController\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"td\",\"outputs\":[{\"internalType\":\"contract TokenData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tk\",\"outputs\":[{\"internalType\":\"contract NXMToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"unlockCN\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenFunctions","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}