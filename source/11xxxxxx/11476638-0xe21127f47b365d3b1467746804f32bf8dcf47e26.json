{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/OtokenFactory.sol\": {\r\n      \"content\": \"pragma solidity =0.6.10;\\n\\nimport {OtokenSpawner} from \\\"./OtokenSpawner.sol\\\";\\nimport {SafeMath} from \\\"./packages/oz/SafeMath.sol\\\";\\nimport {AddressBookInterface} from \\\"./interfaces/AddressBookInterface.sol\\\";\\nimport {OtokenInterface} from \\\"./interfaces/OtokenInterface.sol\\\";\\nimport {WhitelistInterface} from \\\"./interfaces/WhitelistInterface.sol\\\";\\n\\n/**\\n * SPDX-License-Identifier: UNLICENSED\\n * @title A factory to create Opyn oTokens\\n * @author Opyn Team\\n * @notice Create new oTokens and keep track of all created tokens\\n * @dev Calculate contract address before each creation with CREATE2\\n * and deploy eip-1167 minimal proxies for oToken logic contract\\n */\\ncontract OtokenFactory is OtokenSpawner {\\n    using SafeMath for uint256;\\n    /// @notice Opyn AddressBook contract that records the address of the Whitelist module and the Otoken impl address. */\\n    address public addressBook;\\n\\n    /// @notice array of all created otokens */\\n    address[] public otokens;\\n\\n    /// @dev mapping from parameters hash to its deployed address\\n    mapping(bytes32 => address) private idToAddress;\\n\\n    /// @dev max expiry that BokkyPooBahsDateTimeLibrary can handle. (2345/12/31)\\n    uint256 private constant MAX_EXPIRY = 11865398400;\\n\\n    constructor(address _addressBook) public {\\n        addressBook = _addressBook;\\n    }\\n\\n    /// @notice emitted when the factory creates a new Option\\n    event OtokenCreated(\\n        address tokenAddress,\\n        address creator,\\n        address indexed underlying,\\n        address indexed strike,\\n        address indexed collateral,\\n        uint256 strikePrice,\\n        uint256 expiry,\\n        bool isPut\\n    );\\n\\n    /**\\n     * @notice create new oTokens\\n     * @dev deploy an eip-1167 minimal proxy with CREATE2 and register it to the whitelist module\\n     * @param _underlyingAsset asset that the option references\\n     * @param _strikeAsset asset that the strike price is denominated in\\n     * @param _collateralAsset asset that is held as collateral against short/written options\\n     * @param _strikePrice strike price with decimals = 18\\n     * @param _expiry expiration timestamp as a unix timestamp\\n     * @param _isPut True if a put option, False if a call option\\n     * @return newOtoken address of the newly created option\\n     */\\n    function createOtoken(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external returns (address) {\\n        require(_expiry > now, \\\"OtokenFactory: Can't create expired option\\\");\\n        require(_expiry < MAX_EXPIRY, \\\"OtokenFactory: Can't create option with expiry > 2345/12/31\\\");\\n        // 8 hours = 3600 * 8 = 28800 seconds\\n        require(_expiry.sub(28800).mod(86400) == 0, \\\"OtokenFactory: Option has to expire 08:00 UTC\\\");\\n        bytes32 id = _getOptionId(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut);\\n        require(idToAddress[id] == address(0), \\\"OtokenFactory: Option already created\\\");\\n\\n        address whitelist = AddressBookInterface(addressBook).getWhitelist();\\n        require(\\n            WhitelistInterface(whitelist).isWhitelistedProduct(\\n                _underlyingAsset,\\n                _strikeAsset,\\n                _collateralAsset,\\n                _isPut\\n            ),\\n            \\\"OtokenFactory: Unsupported Product\\\"\\n        );\\n\\n        require(!_isPut || _strikePrice > 0, \\\"OtokenFactory: Can't create a $0 strike put option\\\");\\n\\n        address otokenImpl = AddressBookInterface(addressBook).getOtokenImpl();\\n\\n        bytes memory initializationCalldata = abi.encodeWithSelector(\\n            OtokenInterface(otokenImpl).init.selector,\\n            addressBook,\\n            _underlyingAsset,\\n            _strikeAsset,\\n            _collateralAsset,\\n            _strikePrice,\\n            _expiry,\\n            _isPut\\n        );\\n\\n        address newOtoken = _spawn(otokenImpl, initializationCalldata);\\n\\n        idToAddress[id] = newOtoken;\\n        otokens.push(newOtoken);\\n        WhitelistInterface(whitelist).whitelistOtoken(newOtoken);\\n\\n        emit OtokenCreated(\\n            newOtoken,\\n            msg.sender,\\n            _underlyingAsset,\\n            _strikeAsset,\\n            _collateralAsset,\\n            _strikePrice,\\n            _expiry,\\n            _isPut\\n        );\\n\\n        return newOtoken;\\n    }\\n\\n    /**\\n     * @notice get the total oTokens created by the factory\\n     * @return length of the oTokens array\\n     */\\n    function getOtokensLength() external view returns (uint256) {\\n        return otokens.length;\\n    }\\n\\n    /**\\n     * @notice get the oToken address for an already created oToken, if no oToken has been created with these parameters, it will return address(0)\\n     * @param _underlyingAsset asset that the option references\\n     * @param _strikeAsset asset that the strike price is denominated in\\n     * @param _collateralAsset asset that is held as collateral against short/written options\\n     * @param _strikePrice strike price with decimals = 18\\n     * @param _expiry expiration timestamp as a unix timestamp\\n     * @param _isPut True if a put option, False if a call option\\n     * @return the address of target otoken.\\n     */\\n    function getOtoken(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external view returns (address) {\\n        bytes32 id = _getOptionId(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut);\\n        return idToAddress[id];\\n    }\\n\\n    /**\\n     * @notice get the address at which a new oToken with these parameters would be deployed\\n     * @dev return the exact address that will be deployed at with _computeAddress\\n     * @param _underlyingAsset asset that the option references\\n     * @param _strikeAsset asset that the strike price is denominated in\\n     * @param _collateralAsset asset that is held as collateral against short/written options\\n     * @param _strikePrice strike price with decimals = 18\\n     * @param _expiry expiration timestamp as a unix timestamp\\n     * @param _isPut True if a put option, False if a call option\\n     * @return targetAddress the address this oToken would be deployed at\\n     */\\n    function getTargetOtokenAddress(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external view returns (address) {\\n        address otokenImpl = AddressBookInterface(addressBook).getOtokenImpl();\\n        bytes memory initializationCalldata = abi.encodeWithSelector(\\n            OtokenInterface(otokenImpl).init.selector,\\n            addressBook,\\n            _underlyingAsset,\\n            _strikeAsset,\\n            _collateralAsset,\\n            _strikePrice,\\n            _expiry,\\n            _isPut\\n        );\\n        return _computeAddress(otokenImpl, initializationCalldata);\\n    }\\n\\n    /**\\n     * @dev hash oToken parameters and return a unique option id\\n     * @param _underlyingAsset asset that the option references\\n     * @param _strikeAsset asset that the strike price is denominated in\\n     * @param _collateralAsset asset that is held as collateral against short/written options\\n     * @param _strikePrice strike price with decimals = 18\\n     * @param _expiry expiration timestamp as a unix timestamp\\n     * @param _isPut True if a put option, False if a call option\\n     * @return id the unique id of an oToken\\n     */\\n    function _getOptionId(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/OtokenSpawner.sol\": {\r\n      \"content\": \"/* SPDX-License-Identifier: UNLICENSED */\\n\\npragma solidity =0.6.10;\\n\\nimport {Spawn} from \\\"./packages/Spawn.sol\\\";\\nimport {Create2} from \\\"./packages/oz/Create2.sol\\\";\\n\\n/**\\n * @title OtokenSpawner\\n * @author Opyn Team\\n * @notice This contract spawns and initializes eip-1167 minimal proxies that\\n * point to existing logic contracts.\\n * @notice This contract was modified from Spawner.sol\\n * https://github.com/0age/Spawner/blob/master/contracts/Spawner.sol to fit into OtokenFactory\\n */\\ncontract OtokenSpawner {\\n    // fixed salt value because we will only deploy an oToken with the same init value once\\n    bytes32 private constant SALT = bytes32(0);\\n\\n    /**\\n     * @notice internal function for spawning an eip-1167 minimal proxy using `CREATE2`\\n     * @param logicContract address of the logic contract\\n     * @param initializationCalldata calldata that will be supplied to the `DELEGATECALL`\\n     * from the spawned contract to the logic contract during contract creation\\n     * @return spawnedContract the address of the newly-spawned contract\\n     */\\n    function _spawn(address logicContract, bytes memory initializationCalldata) internal returns (address) {\\n        // place the creation code and constructor args of the contract to spawn in memory\\n        bytes memory initCode = abi.encodePacked(\\n            type(Spawn).creationCode,\\n            abi.encode(logicContract, initializationCalldata)\\n        );\\n\\n        // spawn the contract using `CREATE2`\\n        return Create2.deploy(0, SALT, initCode);\\n    }\\n\\n    /**\\n     * @notice internal view function for finding the address of the standard\\n     * eip-1167 minimal proxy created using `CREATE2` with a given logic contract\\n     * and initialization calldata payload\\n     * @param logicContract address of the logic contract\\n     * @param initializationCalldata calldata that will be supplied to the `DELEGATECALL`\\n     * from the spawned contract to the logic contract during contract creation\\n     * @return target address of the next spawned minimal proxy contract with the\\n     * given parameters.\\n     */\\n    function _computeAddress(address logicContract, bytes memory initializationCalldata)\\n        internal\\n        view\\n        returns (address target)\\n    {\\n        // place the creation code and constructor args of the contract to spawn in memory\\n        bytes memory initCode = abi.encodePacked(\\n            type(Spawn).creationCode,\\n            abi.encode(logicContract, initializationCalldata)\\n        );\\n        // get target address using the constructed initialization code\\n        bytes32 initCodeHash = keccak256(initCode);\\n\\n        target = Create2.computeAddress(SALT, initCodeHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/interfaces/AddressBookInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.10;\\n\\ninterface AddressBookInterface {\\n    /* Getters */\\n\\n    function getOtokenImpl() external view returns (address);\\n\\n    function getOtokenFactory() external view returns (address);\\n\\n    function getWhitelist() external view returns (address);\\n\\n    function getController() external view returns (address);\\n\\n    function getOracle() external view returns (address);\\n\\n    function getMarginPool() external view returns (address);\\n\\n    function getMarginCalculator() external view returns (address);\\n\\n    function getLiquidationManager() external view returns (address);\\n\\n    function getAddress(bytes32 _id) external view returns (address);\\n\\n    /* Setters */\\n\\n    function setOtokenImpl(address _otokenImpl) external;\\n\\n    function setOtokenFactory(address _factory) external;\\n\\n    function setOracleImpl(address _otokenImpl) external;\\n\\n    function setWhitelist(address _whitelist) external;\\n\\n    function setController(address _controller) external;\\n\\n    function setMarginPool(address _marginPool) external;\\n\\n    function setMarginCalculator(address _calculator) external;\\n\\n    function setLiquidationManager(address _liquidationManager) external;\\n\\n    function setAddress(bytes32 _id, address _newImpl) external;\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/interfaces/OtokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.10;\\n\\ninterface OtokenInterface {\\n    function addressBook() external view returns (address);\\n\\n    function underlyingAsset() external view returns (address);\\n\\n    function strikeAsset() external view returns (address);\\n\\n    function collateralAsset() external view returns (address);\\n\\n    function strikePrice() external view returns (uint256);\\n\\n    function expiryTimestamp() external view returns (uint256);\\n\\n    function isPut() external view returns (bool);\\n\\n    function init(\\n        address _addressBook,\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external;\\n\\n    function mintOtoken(address account, uint256 amount) external;\\n\\n    function burnOtoken(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/interfaces/WhitelistInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.10;\\n\\ninterface WhitelistInterface {\\n    /* View functions */\\n\\n    function addressBook() external view returns (address);\\n\\n    function isWhitelistedProduct(\\n        address _underlying,\\n        address _strike,\\n        address _collateral,\\n        bool _isPut\\n    ) external view returns (bool);\\n\\n    function isWhitelistedCollateral(address _collateral) external view returns (bool);\\n\\n    function isWhitelistedOtoken(address _otoken) external view returns (bool);\\n\\n    function isWhitelistedCallee(address _callee) external view returns (bool);\\n\\n    /* Admin / factory only functions */\\n    function whitelistProduct(\\n        address _underlying,\\n        address _strike,\\n        address _collateral,\\n        bool _isPut\\n    ) external;\\n\\n    function blacklistProduct(\\n        address _underlying,\\n        address _strike,\\n        address _collateral,\\n        bool _isPut\\n    ) external;\\n\\n    function whitelistCollateral(address _collateral) external;\\n\\n    function blacklistCollateral(address _collateral) external;\\n\\n    function whitelistOtoken(address _otoken) external;\\n\\n    function blacklistOtoken(address _otoken) external;\\n\\n    function whitelistCallee(address _callee) external;\\n\\n    function blacklistCallee(address _callee) external;\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/Spawn.sol\": {\r\n      \"content\": \"/* solhint-disable avoid-low-level-calls, indent, no-inline-assembly */\\n/* This contract is copied from Spawner package: https://github.com/0age/Spawner */\\npragma solidity =0.6.10;\\n\\n/**\\n * @title Spawn\\n * @author 0age\\n * @notice This contract provides creation code that is used by Spawner in order\\n * to initialize and deploy eip-1167 minimal proxies for a given logic contract.\\n * SPDX-License-Identifier: MIT\\n */\\ncontract Spawn {\\n    constructor(address logicContract, bytes memory initializationCalldata) public payable {\\n        // delegatecall into the logic contract to perform initialization.\\n        (bool ok, ) = logicContract.delegatecall(initializationCalldata);\\n        if (!ok) {\\n            // pass along failure message from delegatecall and revert.\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        // place eip-1167 runtime code in memory.\\n        bytes memory runtimeCode = abi.encodePacked(\\n            bytes10(0x363d3d373d3d3d363d73),\\n            logicContract,\\n            bytes15(0x5af43d82803e903d91602b57fd5bf3)\\n        );\\n\\n        // return eip-1167 code to write it to spawned contract runtime.\\n        assembly {\\n            return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/* solhint-disable */\\n\\npragma solidity =0.6.10;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address) {\\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\\n        return address(uint256(_data));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/* solhint-disable */\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressBook\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strike\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPut\",\"type\":\"bool\"}],\"name\":\"OtokenCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addressBook\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isPut\",\"type\":\"bool\"}],\"name\":\"createOtoken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isPut\",\"type\":\"bool\"}],\"name\":\"getOtoken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOtokensLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isPut\",\"type\":\"bool\"}],\"name\":\"getTargetOtokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"otokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OtokenFactory","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000057ade7d5e9d2f45a07f8039da7228acc305fbeaf","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}