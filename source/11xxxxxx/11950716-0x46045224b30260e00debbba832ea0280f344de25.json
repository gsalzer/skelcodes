{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"temp-contracts/CirculatingMarketCapEthToDAI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@indexed-finance/uniswap-v2-oracle/contracts/lib/FixedPoint.sol\\\";\\nimport \\\"./interfaces/ICirculatingMarketCapOracle.sol\\\";\\n\\n\\n/**\\n * @dev Temporary contract to convert market caps denominated in ETH\\n * to market caps denominated in USD.\\n */\\ncontract CirculatingMarketCapEthToDAI {\\n  using FixedPoint for FixedPoint.uq112x112;\\n  using FixedPoint for FixedPoint.uq144x112;\\n\\n  address public immutable uniswapOracle;\\n  address public immutable circulatingMarketCapOracle;\\n  address public immutable dai;\\n\\n  uint32 internal constant SHORT_TWAP_MIN_TIME_ELAPSED = 20 minutes;\\n  uint32 internal constant SHORT_TWAP_MAX_TIME_ELAPSED = 2 days;\\n\\n  constructor (\\n    address uniswapOracle_,\\n    address circulatingMarketCapOracle_,\\n    address dai_\\n  ) public {\\n    uniswapOracle = uniswapOracle_;\\n    circulatingMarketCapOracle = circulatingMarketCapOracle_;\\n    dai = dai_;\\n  }\\n\\n  function getCirculatingMarketCaps(address[] calldata tokens) external view returns (uint256[] memory values) {\\n    uint256 len = tokens.length;\\n    FixedPoint.uq112x112 memory ethPriceForDai = IIndexedUniswapV2Oracle(uniswapOracle).computeAverageEthPrice(\\n      dai,\\n      SHORT_TWAP_MIN_TIME_ELAPSED,\\n      SHORT_TWAP_MAX_TIME_ELAPSED\\n    );\\n    values = ICirculatingMarketCapOracle(circulatingMarketCapOracle).getCirculatingMarketCaps(tokens);\\n    for (uint256 i = 0; i < len; i++) {\\n      values[i] = ethPriceForDai.mul(values[i]).decode144();\\n    }\\n  }\\n}\\n\\n\\ninterface IIndexedUniswapV2Oracle {\\n  function computeAverageEthPrice(\\n    address token,\\n    uint256 minTimeElapsed,\\n    uint256 maxTimeElapsed\\n  )\\n    external\\n    view\\n    returns (FixedPoint.uq112x112 memory priceAverage);\\n}\"\r\n    },\r\n    \"@indexed-finance/uniswap-v2-oracle/contracts/lib/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n\\n/************************************************************************************************\\nFrom https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/FixedPoint.sol\\n\\nCopied from the github repository at commit hash 9642a0705fdaf36b477354a4167a8cd765250860.\\n\\nModifications:\\n- Removed `sqrt` function\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n  // range: [0, 2**112 - 1]\\n  // resolution: 1 / 2**112\\n  struct uq112x112 {\\n    uint224 _x;\\n  }\\n\\n  // range: [0, 2**144 - 1]\\n  // resolution: 1 / 2**112\\n  struct uq144x112 {\\n    uint _x;\\n  }\\n\\n  uint8 private constant RESOLUTION = 112;\\n  uint private constant Q112 = uint(1) << RESOLUTION;\\n  uint private constant Q224 = Q112 << RESOLUTION;\\n\\n  // encode a uint112 as a UQ112x112\\n  function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n    return uq112x112(uint224(x) << RESOLUTION);\\n  }\\n\\n  // encodes a uint144 as a UQ144x112\\n  function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n    return uq144x112(uint256(x) << RESOLUTION);\\n  }\\n\\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\\n  function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n    require(x != 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n    return uq112x112(self._x / uint224(x));\\n  }\\n\\n  // multiply a UQ112x112 by a uint, returning a UQ144x112\\n  // reverts on overflow\\n  function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n    uint z;\\n    require(\\n      y == 0 || (z = uint(self._x) * y) / y == uint(self._x),\\n      \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\"\\n    );\\n    return uq144x112(z);\\n  }\\n\\n  // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n  // equivalent to encode(numerator).div(denominator)\\n  function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n    require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n    return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n  }\\n\\n  // decode a UQ112x112 into a uint112 by truncating after the radix point\\n  function decode(uq112x112 memory self) internal pure returns (uint112) {\\n    return uint112(self._x >> RESOLUTION);\\n  }\\n\\n  // decode a UQ144x112 into a uint144 by truncating after the radix point\\n  function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n    return uint144(self._x >> RESOLUTION);\\n  }\\n\\n  // take the reciprocal of a UQ112x112\\n  function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n    require(self._x != 0, \\\"FixedPoint: ZERO_RECIPROCAL\\\");\\n    return uq112x112(uint224(Q224 / self._x));\\n  }\\n}\"\r\n    },\r\n    \"temp-contracts/interfaces/ICirculatingMarketCapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n\\ninterface ICirculatingMarketCapOracle {\\n  function getCirculatingMarketCap(address) external view returns (uint256);\\n\\n  function getCirculatingMarketCaps(address[] calldata) external view returns (uint256[] memory);\\n\\n  function updateCirculatingMarketCaps(address[] calldata) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapOracle_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"circulatingMarketCapOracle_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dai_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"circulatingMarketCapOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getCirculatingMarketCaps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CirculatingMarketCapEthToDAI","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fa5a44d3ba93d666bf29c8804a36e725ecac659a0000000000000000000000007eee24183a36c84130d22db16f01d593114a83910000000000000000000000006b175474e89094c44da98b954eedeac495271d0f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}