{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StrategiesWhitelist.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract StrategiesWhitelist is Ownable {\\n    mapping(address => uint8) public whitelistedAllocationStrategies;\\n\\n    event AllocationStrategyWhitelisted(address indexed submittedBy, address indexed allocationStrategy);\\n    event AllocationStrategyRemovedFromWhitelist(address indexed submittedBy, address indexed allocationStrategy);\\n\\n    constructor() public {\\n        _setOwner(msg.sender);\\n    }\\n\\n    function isWhitelisted(address _allocationStrategy) external view returns (uint8 answer) {\\n        return whitelistedAllocationStrategies[_allocationStrategy];\\n    }\\n\\n    function addToWhitelist(address _allocationStrategy) external onlyOwner {\\n        whitelistedAllocationStrategies[_allocationStrategy] = 1;\\n        emit AllocationStrategyWhitelisted(msg.sender, _allocationStrategy);\\n    }\\n\\n    function removeFromWhitelist(address _allocationStrategy) external onlyOwner {\\n        whitelistedAllocationStrategies[_allocationStrategy] = 0;\\n        emit AllocationStrategyRemovedFromWhitelist(msg.sender, _allocationStrategy);\\n    }\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n// Copied from PieDAO smart pools repo. Which is audited\\n\\ncontract Ownable {\\n\\n    bytes32 constant public oSlot = keccak256(\\\"Ownable.storage.location\\\");\\n\\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\\n\\n    // Ownable struct\\n    struct os {\\n        address owner;\\n    }\\n\\n    modifier onlyOwner(){\\n        require(msg.sender == los().owner, \\\"Ownable.onlyOwner: msg.sender not owner\\\");\\n        _;\\n    }\\n\\n    /**\\n        @notice Get owner\\n        @return Address of the owner\\n    */\\n    function owner() public view returns(address) {\\n        return los().owner;\\n    }\\n\\n    /**\\n        @notice Transfer ownership to a new address\\n        @param _newOwner Address of the new owner\\n    */\\n    function transferOwnership(address _newOwner) onlyOwner external {\\n        _setOwner(_newOwner);\\n    }\\n\\n    /**\\n        @notice Internal method to set the owner\\n        @param _newOwner Address of the new owner\\n    */\\n    function _setOwner(address _newOwner) internal {\\n        emit OwnerChanged(los().owner, _newOwner);\\n        los().owner = _newOwner;\\n    }\\n\\n    /**\\n        @notice Load ownable storage\\n        @return s Storage pointer to the Ownable storage struct\\n    */\\n    function los() internal pure returns (os storage s) {\\n        bytes32 loc = oSlot;\\n        assembly {\\n            s_slot := loc\\n        }\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"submittedBy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"allocationStrategy\",\"type\":\"address\"}],\"name\":\"AllocationStrategyRemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"submittedBy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"allocationStrategy\",\"type\":\"address\"}],\"name\":\"AllocationStrategyWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_allocationStrategy\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_allocationStrategy\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"answer\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_allocationStrategy\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedAllocationStrategies\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StrategiesWhitelist","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}