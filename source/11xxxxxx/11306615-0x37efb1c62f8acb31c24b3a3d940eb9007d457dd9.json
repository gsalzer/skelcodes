{"status":"1","message":"OK","result":[{"SourceCode":"{\"ITorro.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\r\\npragma solidity 0.6.6;\\r\\n\\r\\n/// @title Interface for ERC-20 Torro governing token.\\r\\n/// @notice ERC-20 token.\\r\\n/// @author ORayskiy - @robitnik_TorroDao\\r\\ninterface ITorro {\\r\\n\\r\\n  // Initializer.\\r\\n\\r\\n  /// @notice Initializes governing token.\\r\\n  /// @param dao_ address of cloned DAO.\\r\\n  /// @param factory_ address of factory.\\r\\n  /// @param supply_ total supply of tokens.\\r\\n  function initializeCustom(address dao_, address factory_, uint256 supply_) external;\\r\\n\\r\\n  // Public calls.\\r\\n\\r\\n  /// @notice Token\\u0027s name.\\r\\n  /// @return string name of the token.\\r\\n  function name() external view returns (string memory);\\r\\n\\r\\n  /// @notice Token\\u0027s symbol.\\r\\n  /// @return string symbol of the token.\\r\\n  function symbol() external view returns (string memory);\\r\\n\\r\\n  /// @notice Token\\u0027s decimals.\\r\\n  /// @return uint8 demials of the token.\\r\\n  function decimals() external pure returns (uint8);\\r\\n\\r\\n  /// @notice Token\\u0027s total supply.\\r\\n  /// @return uint256 total supply of the token.\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  /// @notice Count of token holders.\\r\\n  /// @return uint256 number of token holders.\\r\\n  function holdersCount() external view returns (uint256);\\r\\n\\r\\n  /// @notice All token holders.\\r\\n  /// @return array of addresses of token holders.\\r\\n  function holders() external view returns (address[] memory);\\r\\n\\r\\n  /// @notice Available balance for address.\\r\\n  /// @param sender_ address to get available balance for.\\r\\n  /// @return uint256 amount of tokens available for given address.\\r\\n  function balanceOf(address sender_) external view returns (uint256);\\r\\n\\r\\n  /// @notice Staked balance for address.\\r\\n  /// @param sender_ address to get staked balance for.\\r\\n  /// @return uint256 amount of staked tokens for given address.\\r\\n  function stakedOf(address sender_) external view returns (uint256);\\r\\n\\r\\n  /// @notice Total balance for address = available + staked.\\r\\n  /// @param sender_ address to get total balance for.\\r\\n  /// @return uint256 total amount of tokens for given address.\\r\\n  function totalOf(address sender_) external view returns (uint256);\\r\\n\\r\\n  /// @notice Spending allowance.\\r\\n  /// @param owner_ token owner address.\\r\\n  /// @param spender_ token spender address.\\r\\n  /// @return uint256 amount of owner\\u0027s tokens that spender can use.\\r\\n  function allowance(address owner_, address spender_) external view returns (uint256);\\r\\n\\r\\n  /// @notice Unstaked supply of token.\\r\\n  /// @return uint256 amount of tokens in circulation that are not staked.\\r\\n  function unstakedSupply() external view returns (uint256);\\r\\n\\r\\n  /// @notice Staked supply of token.\\r\\n  /// @return uint256 amount of tokens in circulation that are staked.\\r\\n  function stakedSupply() external view returns (uint256);\\r\\n\\r\\n  // Public transactions.\\r\\n\\r\\n  /// @notice Transfer tokens to recipient.\\r\\n  /// @param recipient_ address of tokens\\u0027 recipient.\\r\\n  /// @param amount_ amount of tokens to transfer.\\r\\n  /// @return bool true if successful.\\r\\n  function transfer(address recipient_, uint256 amount_) external returns (bool);\\r\\n\\r\\n  /// @notice Approve spender to spend an allowance.\\r\\n  /// @param spender_ address that will be allowed to spend specified amount of tokens.\\r\\n  /// @param amount_ amount of tokens that spender can spend.\\r\\n  /// @return bool true if successful.\\r\\n  function approve(address spender_, uint256 amount_) external returns (bool);\\r\\n\\r\\n  /// @notice Approves DAO to spend tokens.\\r\\n  /// @param owner_ address whose tokens DAO can spend.\\r\\n  /// @param amount_ amount of tokens that DAO can spend.\\r\\n  /// @return bool true if successful.\\r\\n  function approveDao(address owner_, uint256 amount_) external returns (bool);\\r\\n\\r\\n  /// @notice Transfers tokens from owner to recipient by approved spender.\\r\\n  /// @param owner_ address of tokens\\u0027 owner whose tokens will be spent.\\r\\n  /// @param recipient_ address of recipient that will recieve tokens.\\r\\n  /// @param amount_ amount of tokens to be spent.\\r\\n  /// @return bool true if successful.\\r\\n  function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool);\\r\\n\\r\\n  /// @notice Increases allowance for given spender.\\r\\n  /// @param spender_ spender to increase allowance for.\\r\\n  /// @param addedValue_ extra amount that spender can spend.\\r\\n  /// @return bool true if successful.\\r\\n  function increaseAllowance(address spender_, uint256 addedValue_) external returns (bool);\\r\\n\\r\\n  /// @notice Decreases allowance for given spender.\\r\\n  /// @param spender_ spender to decrease allowance for.\\r\\n  /// @param subtractedValue_ removed amount that spender can spend.\\r\\n  /// @return bool true if successful.\\r\\n  function decreaseAllowance(address spender_, uint256 subtractedValue_) external returns (bool);\\r\\n\\r\\n  /// @notice Stake tokens.\\r\\n  /// @param amount_ amount of tokens to be staked.\\r\\n  /// @return bool true if successful.\\r\\n  function stake(uint256 amount_) external returns (bool);\\r\\n\\r\\n  /// @notice Unstake tokens.\\r\\n  /// @param amount_ amount of tokens to be unstaked.\\r\\n  /// @return bool true if successful.\\r\\n  function unstake(uint256 amount_) external returns (bool);\\r\\n\\r\\n  /// @notice Functionality for DAO to add benefits for all stakers.\\r\\n  /// @param amount_ amount of wei to be shared among stakers.\\r\\n  function addBenefits(uint256 amount_) external;\\r\\n\\r\\n  /// @notice Sets DAO and Factory addresses.\\r\\n  /// @param dao_ DAO address that this token governs.\\r\\n  /// @param factory_ Factory address.\\r\\n  function setDaoFactoryAddresses(address dao_, address factory_) external;\\r\\n\\r\\n  /// @notice Pauses token functionality.\\r\\n  /// @param paused_ whether token functionality is paused.\\r\\n  function setPause(bool paused_) external;\\r\\n\\r\\n  /// @notice Sets whitelist address allowing it to make token operations when paused.\\r\\n  /// @param whitelistAddress_ address to whitelist.\\r\\n  function setWhitelistAddress(address whitelistAddress_) external;\\r\\n\\r\\n  /// @notice Functionality for owner to burn tokens.\\r\\n  /// @param amount_ amount of tokens to burn.\\r\\n  function burn(uint256 amount_) external;\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"TorroIco.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\r\\npragma solidity 0.6.6;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./ITorro.sol\\\";\\r\\n\\r\\n/// @author ORayskiy - @robitnik_TorroDao\\r\\ncontract TorroIco {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  ITorro private _token;\\r\\n  address private _owner;\\r\\n  uint256 private _startRate;\\r\\n  uint256 private _rateDecrease;\\r\\n  uint256 private _currentRate;\\r\\n  uint256 private _startingBalance;\\r\\n  uint256 private _rateDecreaseBalanceStep;\\r\\n  uint256 private _rateDecreaseBalance;\\r\\n  bool private _isClosed;\\r\\n  uint256 private _weiLimit;\\r\\n  mapping (address =\\u003e uint256) private _addressSpent;\\r\\n\\r\\n  event Purchase();\\r\\n\\r\\n  // startRate = 180\\r\\n  // rateDecrease = 10\\r\\n  // rateSteps = 3\\r\\n  // startingBalance = 60,000\\r\\n  // ethLimit = 10\\r\\n  constructor(address token_, uint256 startRate_, uint256 rateDecrease_, uint256 rateSteps_, uint256 startingBalance_, uint256 ethLimit_) public {\\r\\n    require(startRate_ \\u003e 0);\\r\\n    require(token_ != address(0x0));\\r\\n    _token = ITorro(token_);\\r\\n    _owner = msg.sender;\\r\\n    _startRate = startRate_;\\r\\n    _rateDecrease = rateDecrease_;\\r\\n    _currentRate = _startRate;\\r\\n    _startingBalance = startingBalance_.mul(10**uint256(_token.decimals()));\\r\\n    _rateDecreaseBalanceStep = _startingBalance.div(rateSteps_);\\r\\n    _rateDecreaseBalance = _startingBalance.sub(_rateDecreaseBalanceStep);\\r\\n    _weiLimit = ethLimit_.mul(1 ether);\\r\\n    _isClosed = true;\\r\\n  }\\r\\n\\r\\n  receive() external payable {\\r\\n    require(_isClosed == false);\\r\\n    require(msg.sender != address(0x0));\\r\\n\\r\\n    uint256 weiAmount = msg.value;\\r\\n    require(weiAmount \\u003e 0);\\r\\n\\r\\n    uint256 alreadySpent = _addressSpent[msg.sender];\\r\\n    uint256 afterSpent = alreadySpent.add(weiAmount);\\r\\n    require(afterSpent \\u003c= _weiLimit);\\r\\n\\r\\n    (uint256 tokens, uint256 refund) = _getTokenAmount(weiAmount);\\r\\n\\r\\n    _token.transfer(msg.sender, tokens);\\r\\n\\r\\n    if (refund \\u003e 0) {\\r\\n      payable(msg.sender).transfer(refund);\\r\\n    }\\r\\n\\r\\n    _addressSpent[msg.sender] = afterSpent;\\r\\n\\r\\n    emit Purchase();\\r\\n  }\\r\\n\\r\\n  function currentRate() public view returns (uint256) {\\r\\n    return _currentRate;\\r\\n  }\\r\\n\\r\\n  function tokensLeftAtCurrentRate() public view returns (uint256) {\\r\\n    uint256 balance = _token.balanceOf(address(this));\\r\\n    if (balance \\u003c _rateDecreaseBalance) {\\r\\n      return balance;\\r\\n    }\\r\\n    return balance.sub(_rateDecreaseBalance);\\r\\n  }\\r\\n\\r\\n  function isClosed() public view returns (bool) {\\r\\n    return _isClosed;\\r\\n  }\\r\\n\\r\\n  function _getTokenAmount(uint256 weiAmount_) private returns (uint256, uint256) {\\r\\n    uint256 amount = weiAmount_.mul(_currentRate);\\r\\n    uint256 balance = _token.balanceOf(address(this));\\r\\n    if (amount \\u003e balance || balance.sub(amount) \\u003c= _rateDecreaseBalance) {\\r\\n      uint256 hiRateAmount = balance.sub(_rateDecreaseBalance);\\r\\n      uint256 hiRateWeiAmount = hiRateAmount.div(_currentRate);\\r\\n      uint256 leftOverWeiAmount = weiAmount_.sub(hiRateWeiAmount);\\r\\n\\r\\n      bool proceed = _decreaseRate();\\r\\n      if (!proceed) {\\r\\n        return (hiRateAmount, leftOverWeiAmount);\\r\\n      }\\r\\n      uint256 loRateAmount = leftOverWeiAmount.mul(_currentRate);\\r\\n      return (hiRateAmount.add(loRateAmount), 0);\\r\\n    }\\r\\n    return (amount, 0);\\r\\n  }\\r\\n\\r\\n  function _decreaseRate() private returns (bool) {\\r\\n    if (_rateDecreaseBalance == 0) {\\r\\n      _currentRate = 0;\\r\\n      _isClosed = true;\\r\\n      return false;\\r\\n    }\\r\\n    _rateDecreaseBalance = _rateDecreaseBalance.sub(_rateDecreaseBalanceStep);\\r\\n    _currentRate = _currentRate.sub(_rateDecrease);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function open() public {\\r\\n    require(msg.sender == _owner);\\r\\n    _isClosed = false;\\r\\n  }\\r\\n\\r\\n  function close() public {\\r\\n    require(msg.sender == _owner);\\r\\n    payable(_owner).transfer(address(this).balance);\\r\\n    uint256 tokensLeft = _token.balanceOf(address(this));\\r\\n    if (tokensLeft \\u003e 0) {\\r\\n      _token.transfer(msg.sender, tokensLeft);\\r\\n    }\\r\\n    _isClosed = true;\\r\\n  }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateDecrease_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateSteps_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingBalance_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethLimit_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Purchase\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensLeftAtCurrentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"TorroIco","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005287407054dd77dcb94d69ba847210674a99a35c00000000000000000000000000000000000000000000000000000000000000b4000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000ea60000000000000000000000000000000000000000000000000000000000000000a","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://910ca214bbdd7101fc405239ee769626f2ef04028baa118960e8073e40504a4a"}]}