{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src.sol/ChannelFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nimport \\\"./interfaces/IChannelFactory.sol\\\";\\nimport \\\"./interfaces/IVectorChannel.sol\\\";\\nimport \\\"./lib/LibAsset.sol\\\";\\nimport \\\"./lib/LibERC20.sol\\\";\\n\\n/// @title ChannelFactory\\n/// @author Connext <support@connext.network>\\n/// @notice Creates and sets up a new channel proxy contract\\ncontract ChannelFactory is IChannelFactory {\\n    // Creation code constants taken from EIP1167\\n    bytes private constant proxyCreationCodePrefix =\\n        hex\\\"3d602d80600a3d3981f3_363d3d373d3d3d363d73\\\";\\n    bytes private constant proxyCreationCodeSuffix =\\n        hex\\\"5af43d82803e903d91602b57fd5bf3\\\";\\n\\n    bytes32 private creationCodeHash;\\n    address private immutable mastercopy;\\n    uint256 private immutable chainId;\\n\\n    /// @dev Creates a new `ChannelFactory`\\n    /// @param _mastercopy the address of the `ChannelMastercopy` (channel logic)\\n    /// @param _chainId the chain identifier when generating the CREATE2 salt. If zero, the chain identifier used in the proxy salt will be the result of the opcode\\n    constructor(address _mastercopy, uint256 _chainId) {\\n        mastercopy = _mastercopy;\\n        chainId = _chainId;\\n        creationCodeHash = keccak256(_getProxyCreationCode(_mastercopy));\\n    }\\n\\n    ////////////////////////////////////////\\n    // Public Methods\\n\\n    /// @dev Allows us to get the mastercopy that this factory will deploy channels against\\n    function getMastercopy() external view override returns (address) {\\n        return mastercopy;\\n    }\\n\\n    /// @dev Allows us to get the chainId that this factory will use in the create2 salt\\n    function getChainId() public view override returns (uint256 _chainId) {\\n        // Hold in memory to reduce sload calls\\n        uint256 chain = chainId;\\n        if (chain == 0) {\\n            assembly {\\n                _chainId := chainid()\\n            }\\n        } else {\\n            _chainId = chain;\\n        }\\n    }\\n\\n    /// @dev Allows us to get the chainId that this factory has stored\\n    function getStoredChainId() external view override returns (uint256) {\\n        return chainId;\\n    }\\n\\n    /// @dev Returns the proxy code used to both calculate the CREATE2 address and deploy the channel proxy pointed to the `ChannelMastercopy`\\n    function getProxyCreationCode()\\n        public\\n        view\\n        override\\n        returns (bytes memory)\\n    {\\n        return _getProxyCreationCode(mastercopy);\\n    }\\n\\n    /// @dev Allows us to get the address for a new channel contract created via `createChannel`\\n    /// @param alice address of the igh fidelity channel participant\\n    /// @param bob address of the other channel participant\\n    function getChannelAddress(address alice, address bob)\\n        external\\n        view\\n        override\\n        returns (address)\\n    {\\n        return\\n            Create2.computeAddress(\\n                generateSalt(alice, bob),\\n                creationCodeHash\\n            );\\n    }\\n\\n    /// @dev Allows us to create new channel contract and get it all set up in one transaction\\n    /// @param alice address of the high fidelity channel participant\\n    /// @param bob address of the other channel participant\\n    function createChannel(address alice, address bob)\\n        public\\n        override\\n        returns (address channel)\\n    {\\n        channel = deployChannelProxy(alice, bob);\\n        IVectorChannel(channel).setup(alice, bob);\\n        emit ChannelCreation(channel);\\n    }\\n\\n    /// @dev Allows us to create a new channel contract and fund it in one transaction\\n    /// @param bob address of the other channel participant\\n    function createChannelAndDepositAlice(\\n        address alice,\\n        address bob,\\n        address assetId,\\n        uint256 amount\\n    ) external payable override returns (address channel) {\\n        channel = createChannel(alice, bob);\\n        // Deposit funds (if a token) must be approved for the\\n        // `ChannelFactory`, which then claims the funds and transfers\\n        // to the channel address. While this is inefficient, this is\\n        // the safest/clearest way to transfer funds\\n        if (!LibAsset.isEther(assetId)) {\\n            require(\\n                LibERC20.transferFrom(\\n                    assetId,\\n                    msg.sender,\\n                    address(this),\\n                    amount\\n                ),\\n                \\\"ChannelFactory: ERC20_TRANSFER_FAILED\\\"\\n            );\\n            require(\\n                LibERC20.approve(assetId, address(channel), amount),\\n                \\\"ChannelFactory: ERC20_APPROVE_FAILED\\\"\\n            );\\n        }\\n        IVectorChannel(channel).depositAlice{value: msg.value}(assetId, amount);\\n    }\\n\\n    ////////////////////////////////////////\\n    // Internal Methods\\n\\n    function _getProxyCreationCode(address _mastercopy) internal pure returns (bytes memory) {\\n      return abi.encodePacked(\\n                proxyCreationCodePrefix,\\n                _mastercopy,\\n                proxyCreationCodeSuffix\\n            );\\n    }\\n\\n    /// @dev Allows us to create new channel contact using CREATE2\\n    /// @param alice address of the high fidelity participant in the channel\\n    /// @param bob address of the other channel participant\\n    function deployChannelProxy(address alice, address bob)\\n        internal\\n        returns (address)\\n    {\\n        bytes32 salt = generateSalt(alice, bob);\\n        return Create2.deploy(0, salt, getProxyCreationCode());\\n    }\\n\\n    /// @dev Generates the unique salt for calculating the CREATE2 address of the channel proxy\\n    function generateSalt(address alice, address bob)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(alice, bob, getChainId()));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\\n        bytes32 _data = keccak256(\\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\\n        );\\n        return address(uint256(_data));\\n    }\\n}\\n\"\r\n    },\r\n    \"src.sol/interfaces/IChannelFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\ninterface IChannelFactory {\\n    event ChannelCreation(address channel);\\n\\n    function getMastercopy() external view returns (address);\\n\\n    function getChainId() external view returns (uint256);\\n\\n    function getStoredChainId() external view returns (uint256);\\n\\n    function getProxyCreationCode() external view returns (bytes memory);\\n\\n    function getChannelAddress(address alice, address bob)\\n        external\\n        view\\n        returns (address);\\n\\n    function createChannel(address alice, address bob)\\n        external\\n        returns (address);\\n\\n    function createChannelAndDepositAlice(\\n        address alice,\\n        address bob,\\n        address assetId,\\n        uint256 amount\\n    ) external payable returns (address);\\n}\\n\"\r\n    },\r\n    \"src.sol/interfaces/IVectorChannel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ICMCCore.sol\\\";\\nimport \\\"./ICMCAsset.sol\\\";\\nimport \\\"./ICMCDeposit.sol\\\";\\nimport \\\"./ICMCWithdraw.sol\\\";\\nimport \\\"./ICMCAdjudicator.sol\\\";\\n\\ninterface IVectorChannel is\\n    ICMCCore,\\n    ICMCAsset,\\n    ICMCDeposit,\\n    ICMCWithdraw,\\n    ICMCAdjudicator\\n{}\\n\"\r\n    },\r\n    \"src.sol/lib/LibAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibERC20.sol\\\";\\nimport \\\"./LibUtils.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n\\n/// @title LibAsset\\n/// @author Connext <support@connext.network>\\n/// @notice This library contains helpers for dealing with onchain transfers\\n///         of in-channel assets. It is designed to safely handle all asset\\n///         transfers out of channel in the event of an onchain dispute. Also\\n///         safely handles ERC20 transfers that may be non-compliant\\nlibrary LibAsset {\\n    address constant ETHER_ASSETID = address(0);\\n\\n    function isEther(address assetId) internal pure returns (bool) {\\n        return assetId == ETHER_ASSETID;\\n    }\\n\\n    function getOwnBalance(address assetId) internal view returns (uint256) {\\n        return\\n            isEther(assetId)\\n                ? address(this).balance\\n                : IERC20(assetId).balanceOf(address(this));\\n    }\\n\\n    function transferEther(address payable recipient, uint256 amount)\\n        internal\\n        returns (bool)\\n    {\\n        (bool success, bytes memory returnData) =\\n            recipient.call{value: amount}(\\\"\\\");\\n        LibUtils.revertIfCallFailed(success, returnData);\\n        return true;\\n    }\\n\\n    function transferERC20(\\n        address assetId,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        return LibERC20.transfer(assetId, recipient, amount);\\n    }\\n\\n    // This function is a wrapper for transfers of Ether or ERC20 tokens,\\n    // both standard-compliant ones as well as tokens that exhibit the\\n    // missing-return-value bug.\\n    // Although it behaves very much like Solidity's `transfer` function\\n    // or the ERC20 `transfer` and is, in fact, designed to replace direct\\n    // usage of those, it is deliberately named `unregisteredTransfer`,\\n    // because we need to register every transfer out of the channel.\\n    // Therefore, it should normally not be used directly, with the single\\n    // exception of the `transferAsset` function in `CMCAsset.sol`,\\n    // which combines the \\\"naked\\\" unregistered transfer given below\\n    // with a registration.\\n    // USING THIS FUNCTION SOMEWHERE ELSE IS PROBABLY WRONG!\\n    function unregisteredTransfer(\\n        address assetId,\\n        address payable recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        return\\n            isEther(assetId)\\n                ? transferEther(recipient, amount)\\n                : transferERC20(assetId, recipient, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src.sol/lib/LibERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibUtils.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/// @title LibERC20\\n/// @author Connext <support@connext.network>\\n/// @notice This library provides several functions to safely handle\\n///         noncompliant tokens (i.e. does not return a boolean from\\n///         the transfer function)\\n\\nlibrary LibERC20 {\\n    function wrapCall(address assetId, bytes memory callData)\\n        internal\\n        returns (bool)\\n    {\\n        require(Address.isContract(assetId), \\\"LibERC20: NO_CODE\\\");\\n        (bool success, bytes memory returnData) = assetId.call(callData);\\n        LibUtils.revertIfCallFailed(success, returnData);\\n        return returnData.length == 0 || abi.decode(returnData, (bool));\\n    }\\n\\n    function approve(\\n        address assetId,\\n        address spender,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        return\\n            wrapCall(\\n                assetId,\\n                abi.encodeWithSignature(\\n                    \\\"approve(address,uint256)\\\",\\n                    spender,\\n                    amount\\n                )\\n            );\\n    }\\n\\n    function transferFrom(\\n        address assetId,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        return\\n            wrapCall(\\n                assetId,\\n                abi.encodeWithSignature(\\n                    \\\"transferFrom(address,address,uint256)\\\",\\n                    sender,\\n                    recipient,\\n                    amount\\n                )\\n            );\\n    }\\n\\n    function transfer(\\n        address assetId,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        return\\n            wrapCall(\\n                assetId,\\n                abi.encodeWithSignature(\\n                    \\\"transfer(address,uint256)\\\",\\n                    recipient,\\n                    amount\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src.sol/interfaces/ICMCCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\ninterface ICMCCore {\\n    function setup(address _alice, address _bob) external;\\n\\n    function getAlice() external view returns (address);\\n\\n    function getBob() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src.sol/interfaces/ICMCAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\ninterface ICMCAsset {\\n    function getTotalTransferred(address assetId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getExitableAmount(address assetId, address owner)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function exit(\\n        address assetId,\\n        address owner,\\n        address payable recipient\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src.sol/interfaces/ICMCDeposit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\ninterface ICMCDeposit {\\n    event AliceDeposited(address assetId, uint256 amount);\\n    \\n    function getTotalDepositsAlice(address assetId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTotalDepositsBob(address assetId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function depositAlice(address assetId, uint256 amount) external payable;\\n}\\n\"\r\n    },\r\n    \"src.sol/interfaces/ICMCWithdraw.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nstruct WithdrawData {\\n    address channelAddress;\\n    address assetId;\\n    address payable recipient;\\n    uint256 amount;\\n    uint256 nonce;\\n    address callTo;\\n    bytes callData;\\n}\\n\\ninterface ICMCWithdraw {\\n    function getWithdrawalTransactionRecord(WithdrawData calldata wd)\\n        external\\n        view\\n        returns (bool);\\n\\n    function withdraw(\\n        WithdrawData calldata wd,\\n        bytes calldata aliceSignature,\\n        bytes calldata bobSignature\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src.sol/interfaces/ICMCAdjudicator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Types.sol\\\";\\n\\ninterface ICMCAdjudicator {\\n    struct CoreChannelState {\\n        address channelAddress;\\n        address alice;\\n        address bob;\\n        address[] assetIds;\\n        Balance[] balances;\\n        uint256[] processedDepositsA;\\n        uint256[] processedDepositsB;\\n        uint256[] defundNonces;\\n        uint256 timeout;\\n        uint256 nonce;\\n        bytes32 merkleRoot;\\n    }\\n\\n    struct CoreTransferState {\\n        address channelAddress;\\n        bytes32 transferId;\\n        address transferDefinition;\\n        address initiator;\\n        address responder;\\n        address assetId;\\n        Balance balance;\\n        uint256 transferTimeout;\\n        bytes32 initialStateHash;\\n    }\\n\\n    struct ChannelDispute {\\n        bytes32 channelStateHash;\\n        uint256 nonce;\\n        bytes32 merkleRoot;\\n        uint256 consensusExpiry;\\n        uint256 defundExpiry;\\n    }\\n\\n    struct TransferDispute {\\n        bytes32 transferStateHash;\\n        uint256 transferDisputeExpiry;\\n        bool isDefunded;\\n    }\\n\\n    event ChannelDisputed(\\n        address disputer,\\n        CoreChannelState state,\\n        ChannelDispute dispute\\n    );\\n\\n    event ChannelDefunded(\\n        address defunder,\\n        CoreChannelState state,\\n        ChannelDispute dispute,\\n        address[] assetIds\\n    );\\n\\n    event TransferDisputed(\\n        address disputer,\\n        CoreTransferState state,\\n        TransferDispute dispute\\n    );\\n\\n    event TransferDefunded(\\n        address defunder,\\n        CoreTransferState state,\\n        TransferDispute dispute,\\n        bytes encodedInitialState,\\n        bytes encodedResolver,\\n        Balance balance\\n    );\\n\\n    function getChannelDispute() external view returns (ChannelDispute memory);\\n\\n    function getDefundNonce(address assetId) external view returns (uint256);\\n\\n    function getTransferDispute(bytes32 transferId)\\n        external\\n        view\\n        returns (TransferDispute memory);\\n\\n    function disputeChannel(\\n        CoreChannelState calldata ccs,\\n        bytes calldata aliceSignature,\\n        bytes calldata bobSignature\\n    ) external;\\n\\n    function defundChannel(\\n        CoreChannelState calldata ccs,\\n        address[] calldata assetIds,\\n        uint256[] calldata indices\\n    ) external;\\n\\n    function disputeTransfer(\\n        CoreTransferState calldata cts,\\n        bytes32[] calldata merkleProofData\\n    ) external;\\n\\n    function defundTransfer(\\n        CoreTransferState calldata cts,\\n        bytes calldata encodedInitialTransferState,\\n        bytes calldata encodedTransferResolver,\\n        bytes calldata responderSignature\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src.sol/interfaces/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nstruct Balance {\\n    uint256[2] amount; // [alice, bob] in channel, [initiator, responder] in transfer\\n    address payable[2] to; // [alice, bob] in channel, [initiator, responder] in transfer\\n}\\n\"\r\n    },\r\n    \"src.sol/lib/LibUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/// @title LibUtils\\n/// @author Connext <support@connext.network>\\n/// @notice Contains a helper to revert if a call was not successfully\\n///         made\\nlibrary LibUtils {\\n    // If success is false, reverts and passes on the revert string.\\n    function revertIfCallFailed(bool success, bytes memory returnData)\\n        internal\\n        pure\\n    {\\n        if (!success) {\\n            assembly {\\n                revert(add(returnData, 0x20), mload(returnData))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mastercopy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"}],\"name\":\"ChannelCreation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alice\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bob\",\"type\":\"address\"}],\"name\":\"createChannel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alice\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bob\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createChannelAndDepositAlice\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alice\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bob\",\"type\":\"address\"}],\"name\":\"getChannelAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMastercopy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStoredChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ChannelFactory","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d105b6b42206dfa6db00e6a4823bc88efac004760000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6b46714e4e157ca4fcef5f14f882cae62cdcfb5e301602c8361ab37a1daaf2ab"}]}