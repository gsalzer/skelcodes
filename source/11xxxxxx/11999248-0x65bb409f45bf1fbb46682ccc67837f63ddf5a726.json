{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract,\\n   * as the code is not actually created until after the constructor finishes.\\n   * @param account address of the account to check\\n   * @return whether the target address is a contract\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n    // XXX Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address.\\n    // See https://ethereum.stackexchange.com/a/14016/36603\\n    // for more details about how this works.\\n    // TODO Check this again before the Serenity release, because all addresses will be\\n    // contracts then.\\n    // solium-disable-next-line security/no-inline-assembly\\n    assembly { size := extcodesize(account) }\\n    return size \\u003e 0;\\n  }\\n\\n}\\n\"},\"IConverter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.17;\\n\\ninterface IConverter {\\n    function convert(address) external returns (uint256);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external view returns (uint256);\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n    external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    external returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"},\"IOneSplitAudit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.17;\\n\\ninterface IOneSplitAudit {\\n    function swap(\\n        address fromToken,\\n        address destToken,\\n        uint256 amount,\\n        uint256 minReturn,\\n        uint256[] calldata distribution,\\n        uint256 flags\\n    ) external payable returns (uint256 returnAmount);\\n\\n    function getExpectedReturn(\\n        address fromToken,\\n        address destToken,\\n        uint256 amount,\\n        uint256 parts,\\n        uint256 flags // See constants in IOneSplit.sol\\n    ) external view returns (uint256 returnAmount, uint256[] memory distribution);\\n}\\n\"},\"IStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.17;\\n\\ninterface IStrategy {\\n    function want() external view returns (address);\\n\\n    function deposit() external;\\n\\n    // NOTE: must exclude any tokens used in the yield\\n    // Controller role - withdraw should return to Controller\\n    function withdraw(address) external;\\n\\n    // Controller | Vault role - withdraw should always return to Vault\\n    function withdraw(uint256) external;\\n\\n    function skim() external;\\n\\n    // Controller | Vault role - withdraw should always return to Vault\\n    function withdrawAll() external returns (uint256);\\n\\n    function balanceOf() external view returns (uint256);\\n\\n    function withdrawalFee() external view returns (uint256);\\n}\\n\"},\"RecomController.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./IStrategy.sol\\\";\\nimport \\\"./IConverter.sol\\\";\\nimport \\\"./IOneSplitAudit.sol\\\";\\n\\ncontract RecomController {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n\\n    address public governance;\\n    address public strategist;\\n\\n    address public onesplit;\\n    address public rewards;\\n    mapping(address =\\u003e address) public vaults;\\n    mapping(address =\\u003e address) public strategies;\\n    mapping(address =\\u003e mapping(address =\\u003e address)) public converters;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) public approvedStrategies;\\n\\n    uint256 public split = 495;\\n    uint256 public constant max = 10000;\\n\\n    constructor(address _rewards) public {\\n        governance = msg.sender;\\n        strategist = msg.sender;\\n        onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);\\n        rewards = _rewards;\\n    }\\n\\n    function setRewards(address _rewards) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        rewards = _rewards;\\n    }\\n\\n    function setStrategist(address _strategist) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        strategist = _strategist;\\n    }\\n\\n    function setSplit(uint256 _split) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        split = _split;\\n    }\\n\\n    function setOneSplit(address _onesplit) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        onesplit = _onesplit;\\n    }\\n\\n    function setGovernance(address _governance) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        governance = _governance;\\n    }\\n\\n    function setVault(address _token, address _vault) public {\\n        require(msg.sender == strategist || msg.sender == governance, \\\"!strategist\\\");\\n        require(vaults[_token] == address(0), \\\"vault\\\");\\n        vaults[_token] = _vault;\\n    }\\n\\n    function approveStrategy(address _token, address _strategy) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        approvedStrategies[_token][_strategy] = true;\\n    }\\n\\n    function revokeStrategy(address _token, address _strategy) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        approvedStrategies[_token][_strategy] = false;\\n    }\\n\\n    function setConverter(\\n        address _input,\\n        address _output,\\n        address _converter\\n    ) public {\\n        require(msg.sender == strategist || msg.sender == governance, \\\"!strategist\\\");\\n        converters[_input][_output] = _converter;\\n    }\\n\\n    function setStrategy(address _token, address _strategy) public {\\n        require(msg.sender == strategist || msg.sender == governance, \\\"!strategist\\\");\\n        require(approvedStrategies[_token][_strategy] == true, \\\"!approved\\\");\\n\\n        address _current = strategies[_token];\\n        if (_current != address(0)) {\\n            IStrategy(_current).withdrawAll();\\n        }\\n        strategies[_token] = _strategy;\\n    }\\n\\n    function earn(address _token, uint256 _amount) public {\\n        address _strategy = strategies[_token];\\n        address _want = IStrategy(_strategy).want();\\n        if (_want != _token) {\\n            address converter = converters[_token][_want];\\n            IERC20(_token).safeTransfer(converter, _amount);\\n            _amount = IConverter(converter).convert(_strategy);\\n            IERC20(_want).safeTransfer(_strategy, _amount);\\n        } else {\\n            IERC20(_token).safeTransfer(_strategy, _amount);\\n        }\\n        IStrategy(_strategy).deposit();\\n    }\\n\\n    function balanceOf(address _token) external view returns (uint256) {\\n        return IStrategy(strategies[_token]).balanceOf();\\n    }\\n\\n    function withdrawAll(address _token) public {\\n        require(msg.sender == strategist || msg.sender == governance, \\\"!strategist\\\");\\n        IStrategy(strategies[_token]).withdrawAll();\\n    }\\n\\n    function inCaseTokensGetStuck(address _token, uint256 _amount) public {\\n        require(msg.sender == strategist || msg.sender == governance, \\\"!governance\\\");\\n        IERC20(_token).safeTransfer(msg.sender, _amount);\\n    }\\n\\n    function inCaseStrategyTokenGetStuck(address _strategy, address _token) public {\\n        require(msg.sender == strategist || msg.sender == governance, \\\"!governance\\\");\\n        IStrategy(_strategy).withdraw(_token);\\n    }\\n\\n    function getExpectedReturn(\\n        address _strategy,\\n        address _token,\\n        uint256 parts\\n    ) public view returns (uint256 expected) {\\n        uint256 _balance = IERC20(_token).balanceOf(_strategy);\\n        address _want = IStrategy(_strategy).want();\\n        (expected, ) = IOneSplitAudit(onesplit).getExpectedReturn(_token, _want, _balance, parts, 0);\\n    }\\n\\n    // Only allows to withdraw non-core strategy tokens ~ this is over and above normal yield\\n    function yearn(\\n        address _strategy,\\n        address _token,\\n        uint256 parts\\n    ) public {\\n        require(msg.sender == strategist || msg.sender == governance, \\\"!governance\\\");\\n        // This contract should never have value in it, but just incase since this is a public call\\n        uint256 _before = IERC20(_token).balanceOf(address(this));\\n        IStrategy(_strategy).withdraw(_token);\\n        uint256 _after = IERC20(_token).balanceOf(address(this));\\n        if (_after \\u003e _before) {\\n            uint256 _amount = _after.sub(_before);\\n            address _want = IStrategy(_strategy).want();\\n            uint256[] memory _distribution;\\n            uint256 _expected;\\n            _before = IERC20(_want).balanceOf(address(this));\\n            IERC20(_token).safeApprove(onesplit, 0);\\n            IERC20(_token).safeApprove(onesplit, _amount);\\n            (_expected, _distribution) = IOneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0);\\n            IOneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0);\\n            _after = IERC20(_want).balanceOf(address(this));\\n            if (_after \\u003e _before) {\\n                _amount = _after.sub(_before);\\n                uint256 _reward = _amount.mul(split).div(max);\\n                earn(_want, _amount.sub(_reward));\\n                IERC20(_want).safeTransfer(rewards, _reward);\\n            }\\n        }\\n    }\\n\\n    function withdraw(address _token, uint256 _amount) public {\\n        require(msg.sender == vaults[_token], \\\"!vault\\\");\\n        IStrategy(strategies[_token]).withdraw(_amount);\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n\\n  using SafeMath for uint256;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    require(token.transfer(to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    require(token.transferFrom(from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n    require((value == 0) || (token.allowance(msg.sender, spender) == 0));\\n    require(token.approve(spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n    require(token.approve(spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  )\\n    internal\\n  {\\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n    require(token.approve(spender, newAllowance));\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003c= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewards\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"approveStrategy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedStrategies\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"converters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"earn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"parts\",\"type\":\"uint256\"}],\"name\":\"getExpectedReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"inCaseStrategyTokenGetStuck\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"inCaseTokensGetStuck\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"max\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onesplit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"revokeStrategy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"setConverter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_onesplit\",\"type\":\"address\"}],\"name\":\"setOneSplit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewards\",\"type\":\"address\"}],\"name\":\"setRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_split\",\"type\":\"uint256\"}],\"name\":\"setSplit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategist\",\"type\":\"address\"}],\"name\":\"setStrategist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"setStrategy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"split\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"strategies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strategist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaults\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"parts\",\"type\":\"uint256\"}],\"name\":\"yearn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RecomController","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a61cc155221c3f8725abb64d9b4e62fc9c477372","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://56e5a7c633e9cf5b9dd036118bf675cdde4ab7c988057c7305ad7d37e515c5df"}]}