{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/EnumerableSet.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n// File: contracts/IETradingNFT.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IETradingNFT {\r\n    function mint(address _to, uint256 _id, uint256 _quantity, bytes memory _data) external ;\r\n\tfunction totalSupply(uint256 _id) external view returns (uint256);\r\n    function maxSupply(uint256 _id) external view returns (uint256);\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\r\n}\r\n\r\n// File: contracts/token/interfaces/IERC20Token.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ninterface IERC20Token {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function eulerBalances(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n}\r\n\r\n// File: contracts/token/utility/Utils.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\r\n\r\n// File: contracts/token/ERC20Token.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev ERC20 Standard Token implementation\r\n*/\r\ncontract ERC20Token is IERC20Token, Utils {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    string public override name;\r\n    string public override symbol;\r\n    uint8 public override decimals;\r\n    uint256 public override totalSupply;\r\n    mapping (address => uint256) public override eulerBalances;\r\n    mapping (address => mapping (address => uint256)) public override allowance;\r\n\r\n    /**\r\n      * @dev triggered when tokens are transferred between wallets\r\n      *\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n      * @dev triggered when a wallet allows another wallet to transfer tokens from on its behalf\r\n      *\r\n      * @param _owner   wallet that approves the allowance\r\n      * @param _spender wallet that receives the allowance\r\n      * @param _value   allowance amount\r\n    */\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /**\r\n      * @dev initializes a new ERC20Token instance\r\n      *\r\n      * @param _name        token name\r\n      * @param _symbol      token symbol\r\n      * @param _totalSupply total supply of token units\r\n    */\r\n    constructor(string memory _name, string memory _symbol, uint256 _totalSupply) public {\r\n        // validate input\r\n        require(bytes(_name).length > 0, \"ERR_INVALID_NAME\");\r\n        require(bytes(_symbol).length > 0, \"ERR_INVALID_SYMBOL\");\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = 18;\r\n        totalSupply = _totalSupply;\r\n        eulerBalances[msg.sender] = _totalSupply;\r\n    }\r\n\r\n    /**\r\n      * @dev transfers tokens to a given address\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      *\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        virtual\r\n        override\r\n        validAddress(_to)\r\n        returns (bool)\r\n    {\r\n        eulerBalances[msg.sender] = eulerBalances[msg.sender].sub(_value);\r\n        eulerBalances[_to] = eulerBalances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev transfers tokens to a given address on behalf of another address\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      *\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        virtual\r\n        override\r\n        validAddress(_from)\r\n        validAddress(_to)\r\n        returns (bool)\r\n    {\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        eulerBalances[_from] = eulerBalances[_from].sub(_value);\r\n        eulerBalances[_to] = eulerBalances[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev allows another account/contract to transfers tokens on behalf of the caller\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      *\r\n      * also, to minimize the risk of the approve/transferFrom attack vector\r\n      * (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\r\n      * in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\r\n      *\r\n      * @param _spender approved address\r\n      * @param _value   allowance amount\r\n      *\r\n      * @return true if the approval was successful, false if it wasn't\r\n    */\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        virtual\r\n        override\r\n        validAddress(_spender)\r\n        returns (bool)\r\n    {\r\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0, \"ERR_INVALID_AMOUNT\");\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/token/utility/interfaces/IOwned.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ninterface IOwned {\r\n    // this function isn't since the compiler emits automatically generated getter functions as external\r\n    function owner() external view returns (address);\r\n\r\n    function transferOwnership(address _newOwner) external;\r\n    function acceptOwnership() external;\r\n}\r\n\r\n// File: contracts/token/utility/interfaces/ITokenHolder.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ninterface ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) external;\r\n}\r\n\r\n// File: contracts/token/utility/interfaces/IConverterAnchor.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n/*\r\n    Converter Anchor interface\r\n*/\r\ninterface IConverterAnchor is IOwned, ITokenHolder {\r\n}\r\n\r\n// File: contracts/token/interfaces/IEulerToken.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n/*\r\n    Euler Token interface\r\n*/\r\ninterface IEulerToken is IConverterAnchor, IERC20Token {\r\n    function disableTransfers(bool _disable) external;\r\n    function issue(address _to, uint256 _amount) external;\r\n    function destroy(address _from, uint256 _amount) external;\r\n}\r\n\r\n// File: contracts/token/utility/Owned.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public override owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier onlyOwner {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _onlyOwner() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnerUpdate(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public override onlyOwner {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() override public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/token/utility/TokenHandler.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ncontract TokenHandler {\r\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\r\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\r\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `approve` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _spender approved address\r\n      * @param _value   allowance amount\r\n    */\r\n    function safeApprove(IERC20Token _token, address _spender, uint256 _value) internal {\r\n        (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_APPROVE_FAILED');\r\n    }\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    function safeTransfer(IERC20Token _token, address _to, uint256 _value) internal {\r\n       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FAILED');\r\n    }\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\r\n       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FROM_FAILED');\r\n    }\r\n}\r\n\r\n// File: contracts/token/utility/TokenHolder.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev We consider every contract to be a 'token holder' since it's currently not possible\r\n  * for a contract to deny receiving tokens.\r\n  *\r\n  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n  * the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n  *\r\n  * Note that we use the non standard ERC-20 interface which has no return value for transfer\r\n  * in order to support both non standard as well as standard token contracts.\r\n  * see https://github.com/ethereum/solidity/issues/4116\r\n*/\r\ncontract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\r\n    /**\r\n      * @dev withdraws tokens held by the contract and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        virtual\r\n        override\r\n        onlyOwner\r\n        validAddress(address(_token))\r\n        validAddress(_to)\r\n    {\r\n        safeTransfer(_token, _to, _amount);\r\n    }\r\n}\r\n\r\n// File: contracts/token/EulerToken.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Euler Token\r\n  *\r\n  * 'Owned' is specified here for readability reasons\r\n*/\r\ncontract EulerToken is IEulerToken, Owned, ERC20Token, TokenHolder {\r\n    using SafeMath for uint256;\r\n\r\n    bool public transfersEnabled = false;    // true if transfer/transferFrom are enabled, false otherwise\r\n\r\n    /**\r\n      * @dev triggered when the total supply is increased\r\n      *\r\n      * @param _amount  amount that gets added to the supply\r\n    */\r\n    event Issuance(uint256 _amount);\r\n\r\n    /**\r\n      * @dev triggered when the total supply is decreased\r\n      *\r\n      * @param _amount  amount that gets removed from the supply\r\n    */\r\n    event Destruction(uint256 _amount);\r\n\r\n    /**\r\n      * @dev initializes a new EulerToken instance\r\n      *\r\n      * @param _name       token name\r\n      * @param _symbol     token short symbol, minimum 1 character\r\n    */\r\n    constructor(string memory _name, string memory _symbol)\r\n        public\r\n        ERC20Token(_name, _symbol, 0)\r\n    {\r\n    }\r\n\r\n    // allows execution only when transfers are enabled\r\n    modifier transfersAllowed {\r\n        _transfersAllowed();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _transfersAllowed() internal view {\r\n        require(transfersEnabled, \"ERR_TRANSFERS_DISABLED\");\r\n    }\r\n\r\n    /**\r\n      * @dev disables/enables transfers\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _disable    true to disable transfers, false to enable them\r\n    */\r\n    function disableTransfers(bool _disable) public override onlyOwner {\r\n        transfersEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n      * @dev increases the token supply and sends the new tokens to the given account\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to increase the supply by\r\n    */\r\n    function issue(address _to, uint256 _amount)\r\n        public\r\n        override\r\n        onlyOwner\r\n        validAddress(_to)\r\n    {\r\n        totalSupply = totalSupply.add(_amount);\r\n        eulerBalances[_to] = eulerBalances[_to].add(_amount);\r\n\r\n        emit Issuance(_amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n\r\n    /**\r\n      * @dev removes tokens from the given account and decreases the token supply\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _from    account to remove the amount from\r\n      * @param _amount  amount to decrease the supply by\r\n    */\r\n    function destroy(address _from, uint256 _amount) public override onlyOwner {\r\n        eulerBalances[_from] = eulerBalances[_from].sub(_amount);\r\n        totalSupply = totalSupply.sub(_amount);\r\n\r\n        emit Transfer(_from, address(0), _amount);\r\n        emit Destruction(_amount);\r\n    }\r\n\r\n    // ERC20 standard method overrides with some extra functionality\r\n\r\n    /**\r\n      * @dev send coins\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      * in addition to the standard checks, the function throws if transfers are disabled\r\n      *\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        override(IERC20Token, ERC20Token)\r\n        transfersAllowed\r\n        returns (bool)\r\n    {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n      * @dev an account/contract attempts to get the coins\r\n      * throws on any error rather then return a false flag to minimize user errors\r\n      * in addition to the standard checks, the function throws if transfers are disabled\r\n      *\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n      *\r\n      * @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        override(IERC20Token, ERC20Token)\r\n        transfersAllowed\r\n        returns (bool) \r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n}\r\n\r\n// File: contracts/EulersFormula.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IMigratorEulersFormula {\r\n    // Perform LP token migration from legacy UniswapV2 to ESwap.\r\n    // Take the current LP token address and return the new LP token address.\r\n    // Migrator should have full access to the caller's LP token.\r\n    // Return the new LP token address.\r\n    //\r\n    // XXX Migrator must have allowance access to UniswapV2 LP tokens.\r\n    // ESwap must mint EXACTLY the same amount of ESwap LP tokens or\r\n    // else something bad will happen. Traditional UniswapV2 does not\r\n    // do that so be careful!\r\n    function migrate(IERC20 token) external returns (IERC20);\r\n}\r\n\r\n/**\r\nCopyright 2020 PoolTogether Inc.\r\nThis file is part of PoolTogether.\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/**\r\n * @author Brendan Asselstine\r\n * @notice A library that uses entropy to select a random number within a bound.  Compensates for modulo bias.\r\n * @dev Thanks to https://medium.com/hownetworks/dont-waste-cycles-with-modulo-bias-35b6fdafcf94\r\n */\r\nlibrary UniformRandomNumber {\r\n  /// @notice Select a random number without modulo bias using a random seed and upper bound\r\n  /// @param _entropy The seed for randomness\r\n  /// @param _upperBound The upper bound of the desired number\r\n  /// @return A random number less than the _upperBound\r\n  function uniform(uint256 _entropy, uint256 _upperBound) internal pure returns (uint256) {\r\n    require(_upperBound > 0, \"UniformRand/min-bound\");\r\n    uint256 min = -_upperBound % _upperBound;\r\n    uint256 random = _entropy;\r\n    while (true) {\r\n      if (random >= min) {\r\n        break;\r\n      }\r\n      random = uint256(keccak256(abi.encodePacked(random)));\r\n    }\r\n    return random % _upperBound;\r\n  }\r\n}\r\n\r\ncontract Formula is EulerToken(\"Euler's Formula\", \"EULER\") {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Airdrop list\r\n    address[] public airdropList;\r\n    // Only deposit user can get airdrop.\r\n    mapping(address => bool) addressAvailable;\r\n    mapping(address => bool) addressAvailableHistory;\r\n\r\n    // Claimable enft of user.\r\n    struct UserEnftInfo {\r\n        uint256 amount;\r\n    }\r\n    // Info of each user that claimable enft.\r\n    mapping (address => mapping (uint256 => UserEnftInfo)) public userEnftInfo;\r\n\r\n    // Info of each enft.\r\n    struct EnftInfo {\r\n        uint256 enftID;            // Enft's ID. \r\n        uint256 amount;            // Distribution amount.\r\n        uint256 fixedPrice;        // Claim the enft need pay some wETH.\r\n    }\r\n    // Info of each enft.\r\n    EnftInfo[] public enftInfo;\r\n    // Total enft amount.\r\n    uint256 public totalEnftAmount = 0;\r\n    // Original total enft amount.\r\n    uint256 public originalTotalEnftAmount = 0;\r\n    // Draw Fusion\r\n    uint256 public eulersFused = 1000 * (10 ** 18);\r\n    // Base number\r\n    uint256 public base = 10 ** 6;\r\n    // Claim fee is 3%.\r\n    // Pool's fee 1%. Artist's fee 2%.\r\n    uint256 public totalFee = 3 * (base) / 100;\r\n\r\n    // Enft token.\r\n    IETradingNFT ETradingNFT;\r\n\r\n    event Reward(address indexed user, uint256 indexed enftID);\r\n    event AirDrop(address indexed user, uint256 indexed enftID);\r\n\r\n    function enftLength() public view returns (uint256) {\r\n        return enftInfo.length;\r\n    }\r\n\r\n    function eulerBalanceOf(address tokenOwner) public view returns (uint256) {\r\n        return eulerBalances[tokenOwner];\r\n    }\r\n\r\n    function userEnftBalanceOf(address tokenOwner, uint256 _enftID) public view returns (uint256) {\r\n        return userEnftInfo[tokenOwner][_enftID].amount;\r\n    }\r\n\r\n    function userUnclaimEnft(address tokenOwner) public view returns (uint256[] memory) {\r\n        uint256[] memory userEnft = new uint256[](enftInfo.length);\r\n        for(uint i = 0; i < enftInfo.length; i++) {\r\n            userEnft[i] = userEnftInfo[tokenOwner][i].amount;\r\n        }\r\n        return userEnft;\r\n    }\r\n\r\n    function enftBalanceOf(uint256 _enftID) public view returns (uint256) {\r\n        return enftInfo[_enftID].amount;\r\n    }\r\n\r\n    // Set setEulersFused. Can only be called by the owner.\r\n    function setEulersFused(uint256 _newEulersFused) public onlyOwner {\r\n        eulersFused = _newEulersFused;\r\n    }\r\n\r\n    // Set setTotalFee. Can only be called by the owner.\r\n    function setTotalFee(uint256 _newTotalFee) public onlyOwner {\r\n        totalFee = _newTotalFee;\r\n    }\r\n\r\n    // Add a new enft. Can only be called by the owner.\r\n    function addEnft(uint256 _enftID, uint256 _amount, uint256 _fixedPrice) external onlyOwner {\r\n        require(_amount.add(ETradingNFT.totalSupply(_enftID)) <= ETradingNFT.maxSupply(_enftID), \"Max supply reached\");\r\n        totalEnftAmount = totalEnftAmount.add(_amount);\r\n        originalTotalEnftAmount = originalTotalEnftAmount.add(_amount);\r\n        enftInfo.push(EnftInfo({\r\n            enftID: _enftID,\r\n            amount: _amount,\r\n            fixedPrice: _fixedPrice\r\n        }));\r\n    }\r\n\r\n    // Update enft.\r\n    // It's always decrease.\r\n    function _updateEnft(uint256 _wid, uint256 amount) internal {\r\n        EnftInfo storage enft = enftInfo[_wid];\r\n        enft.amount = enft.amount.sub(amount);\r\n        totalEnftAmount = totalEnftAmount.sub(amount);\r\n    }\r\n\r\n    // Update user enft\r\n    function _addUserEnft(address user, uint256 _wid, uint256 amount) internal {\r\n        UserEnftInfo storage userEnft = userEnftInfo[user][_wid];\r\n        userEnft.amount = userEnft.amount.add(amount);\r\n    }\r\n    function _removeUserEnft(address user, uint256 _wid, uint256 amount) internal {\r\n        UserEnftInfo storage userEnft = userEnftInfo[user][_wid];\r\n        userEnft.amount = userEnft.amount.sub(amount);\r\n    }\r\n\r\n    // Draw main function\r\n    function _draw() internal view returns (uint256) {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(now, block.difficulty, msg.sender)));\r\n        uint256 rnd = UniformRandomNumber.uniform(seed, totalEnftAmount);\r\n        // Sort by rarity. Avoid gas attacks, start from the tail.\r\n        for(uint i = enftInfo.length - 1; i > 0; --i){\r\n            if(rnd < enftInfo[i].amount){\r\n                return i;\r\n            }\r\n            rnd = rnd - enftInfo[i].amount;\r\n        }\r\n        // should not happen.\r\n        return uint256(-1);\r\n    }\r\n\r\n    // Draw a enft\r\n    function draw() external {\r\n        // EOA only\r\n        require(msg.sender == tx.origin);\r\n\r\n        require(eulerBalances[msg.sender] >= eulersFused, \"Eulers are not enough.\");\r\n        eulerBalances[msg.sender] = eulerBalances[msg.sender].sub(eulersFused);\r\n\r\n        uint256 _rwid = _draw();\r\n        // Reward reduced\r\n        _updateEnft(_rwid, 1);\r\n        _addUserEnft(msg.sender, _rwid, 1);\r\n\r\n        emit Reward(msg.sender, _rwid);\r\n    }\r\n\r\n    // Airdrop by owner\r\n    function airDrop() external onlyOwner {\r\n\r\n        uint256 _rwid = _draw();\r\n        // Reward reduced\r\n        _updateEnft(_rwid, 1);\r\n\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(now, _rwid)));\r\n        bool status = false;\r\n        uint256 rnd = 0;\r\n\r\n        while (!status) {\r\n            rnd = UniformRandomNumber.uniform(seed, airdropList.length);\r\n            status = addressAvailable[airdropList[rnd]];\r\n            seed = uint256(keccak256(abi.encodePacked(seed, rnd)));\r\n        }\r\n\r\n        _addUserEnft(airdropList[rnd], _rwid, 1);\r\n        emit AirDrop(airdropList[rnd], _rwid);\r\n    }\r\n\r\n    // Airdrop by user\r\n    function airDropByUser() external {\r\n\r\n        // EOA only\r\n        require(msg.sender == tx.origin);\r\n\r\n        require(eulerBalances[msg.sender] >= eulersFused, \"Eulers are not enough.\");\r\n        eulerBalances[msg.sender] = eulerBalances[msg.sender].sub(eulersFused);\r\n        \r\n        uint256 _rwid = _draw();\r\n        // Reward reduced\r\n        _updateEnft(_rwid, 1);\r\n\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(now, _rwid)));\r\n        bool status = false;\r\n        uint256 rnd = 0;\r\n\r\n        while (!status) {\r\n            rnd = UniformRandomNumber.uniform(seed, airdropList.length);\r\n            status = addressAvailable[airdropList[rnd]];\r\n            seed = uint256(keccak256(abi.encodePacked(seed, rnd)));\r\n        }\r\n\r\n        _addUserEnft(airdropList[rnd], _rwid, 1);\r\n        emit AirDrop(airdropList[rnd], _rwid);\r\n    }\r\n\r\n    // pool's fee & artist's fee\r\n    function withdrawFee() external onlyOwner {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    // Compute claim fee.\r\n    function claimFee(uint256 _wid, uint256 amount) public view returns (uint256){\r\n        EnftInfo storage enft = enftInfo[_wid];\r\n        return amount * enft.fixedPrice * (totalFee) / (base);\r\n    }\r\n\r\n    // User claim enft.\r\n    function claim(uint256 _wid, uint256 amount) external payable {\r\n        UserEnftInfo storage userEnft = userEnftInfo[msg.sender][_wid];\r\n        require(amount > 0, \"amount must not zero\");\r\n        require(userEnft.amount >= amount, \"amount is bad\");\r\n        require(msg.value == claimFee(_wid, amount), \"need payout claim fee\");\r\n\r\n        _removeUserEnft(msg.sender, _wid, amount);\r\n        ETradingNFT.mint(msg.sender, _wid, amount, \"\");\r\n    }\r\n}\r\n\r\n\r\ncontract EulersFormula is Formula {\r\n    // Info of each user.\r\n    struct UserLPInfo {\r\n        uint256 amount;       // How many LP tokens the user has provided.\r\n        uint256 rewardEULER; // Reward euler. \r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 lpToken;            // Address of LP token contract.\r\n        uint256 allocPoint;        // How many allocation points assigned to this pool. EULERs to distribute per block.\r\n        uint256 lastRewardBlock;   // Last block number that EULERs distribution occurs.\r\n        uint256 accEULERPerShare; // Accumulated EULERs per share, times 1e12. See below.\r\n    }\r\n    // Dev address.\r\n    address public devaddr;\r\n    // Block number when bonus EARN period ends.\r\n    uint256 public bonusEndBlock;\r\n    // EULER tokens created per block.\r\n    uint256 public eulerPerBlock = 3141592653589793238; //18 decimals\r\n    // Bonus muliplier for early euler seekers.\r\n    uint256 public bonusMultiplier = 2718281828459045235; //18 decimals\r\n    // The migrator contract. It has a lot of power. Can only be set through governance (owner).\r\n    IMigratorEulersFormula public migrator;\r\n\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping (uint256 => mapping (address => UserLPInfo)) public userLPInfo;\r\n    // Total allocation poitns. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n    // The block number when EULER mining starts.\r\n    uint256 public startBlock;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\r\n    constructor(\r\n        IETradingNFT _ETradingNFT,\r\n        address _devaddr,\r\n        uint256 _startBlock,\r\n        uint256 _bonusEndBlock\r\n    ) public {\r\n        ETradingNFT = _ETradingNFT;\r\n        devaddr = _devaddr;\r\n        startBlock = _startBlock;\r\n        bonusEndBlock = _bonusEndBlock;\r\n        enftInfo.push(EnftInfo({\r\n            enftID: 0,\r\n            amount: 0,\r\n            fixedPrice: 0\r\n        }));\r\n    }\r\n\r\n    function poolLength() external view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the owner.\r\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n            lpToken: _lpToken,\r\n            allocPoint: _allocPoint,\r\n            lastRewardBlock: lastRewardBlock,\r\n            accEULERPerShare: 0\r\n        }));\r\n    }\r\n\r\n    // Update the given pool's Eulers allocation point. Can only be called by the owner.\r\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // Set eulerPerBlock. Can only be called by the owner.\r\n    function setEULERPerBlock(uint256 _eulerPerBlock) public onlyOwner {\r\n        eulerPerBlock = _eulerPerBlock;\r\n    }\r\n\r\n    // Set startBlock. Can only be called by the owner.\r\n    function setStartBlock(uint256 _startBlock) public onlyOwner {\r\n        startBlock = _startBlock;\r\n    }\r\n\r\n    // Set bonusEndBlock. Can only be called by the owner.\r\n    function setBonusEndBlock(uint256 _bonusEndBlock) public onlyOwner {\r\n        bonusEndBlock = _bonusEndBlock;\r\n    }\r\n\r\n    // Set bonusMultiplier. Can only be called by the owner.\r\n    function setBonusMultiplier(uint256 _bonusMultiplier) public onlyOwner {\r\n        bonusMultiplier = _bonusMultiplier;\r\n    }\r\n\r\n    // Set newLpToken. Can only be called by the owner.\r\n    function setNewLpToken(uint _pid, IERC20 _newLpToken) public onlyOwner {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        pool.lpToken = _newLpToken;\r\n    }\r\n\r\n    // Set newAllocPoint. Can only be called by the owner.\r\n    function setNewAllocPoint(uint _pid, uint256 _newAllocPoint) public onlyOwner {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        pool.allocPoint = _newAllocPoint;\r\n    }\r\n\r\n    // Set the migrator contract. Can only be called by the owner.\r\n    function setMigrator(IMigratorEulersFormula _migrator) public onlyOwner {\r\n        migrator = _migrator;\r\n    }\r\n\r\n    // Migrate lp token to another lp contract. Can only be called by the owner. We trust that migrator contract is good.\r\n    function migrate(uint256 _pid) public onlyOwner {\r\n        require(address(migrator) != address(0), \"migrate: no migrator\");\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        IERC20 lpToken = pool.lpToken;\r\n        uint256 bal = lpToken.balanceOf(address(this));\r\n        lpToken.safeApprove(address(migrator), bal);\r\n        IERC20 newLpToken = migrator.migrate(lpToken);\r\n        //check balance equivalence on Migrator side\r\n        //require(bal == newLpToken.balanceOf(address(this)), \"migrate: bad\");\r\n        pool.lpToken = newLpToken;\r\n    }\r\n\r\n    // Return reward multiplier over the given _from to _to block.\r\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\r\n        if (_to <= bonusEndBlock) {\r\n            return _to.sub(_from).mul(bonusMultiplier);\r\n        } else if (_from >= bonusEndBlock) {\r\n            return _to.sub(_from);\r\n        } else {\r\n            return bonusEndBlock.sub(_from).mul(bonusMultiplier).add(\r\n                _to.sub(bonusEndBlock)\r\n            );\r\n        }\r\n    }\r\n\r\n    // View function to see pending Eulers on frontend.\r\n    function pendingEULER(uint256 _pid, address _user) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserLPInfo storage user = userLPInfo[_pid][_user];\r\n        uint256 accEULERPerShare = pool.accEULERPerShare;\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\r\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n            uint256 eulerReward = multiplier.mul(eulerPerBlock).mul(pool.allocPoint).div(totalAllocPoint).div(1e18);\r\n            accEULERPerShare = accEULERPerShare.add(eulerReward.mul(1e12).div(lpSupply));\r\n        }\r\n        return user.amount.mul(accEULERPerShare).div(1e12).sub(user.rewardEULER);\r\n    }\r\n\r\n    // Update reward vairables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n        uint256 eulerReward = multiplier.mul(eulerPerBlock).mul(pool.allocPoint).div(totalAllocPoint).div(1e18);\r\n        issue(devaddr, eulerReward);\r\n        issue(address(this), eulerReward);\r\n        pool.accEULERPerShare = pool.accEULERPerShare.add(eulerReward.mul(1e12).div(lpSupply));\r\n        pool.lastRewardBlock = block.number;\r\n    }\r\n\r\n    // Deposit LP tokens to Formula for EULER allocation.\r\n    function deposit(uint256 _pid, uint256 _amount) public {\r\n        // EOA only\r\n        require(msg.sender == tx.origin);\r\n\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserLPInfo storage user = userLPInfo[_pid][msg.sender];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pending = user.amount.mul(pool.accEULERPerShare).div(1e12).sub(user.rewardEULER);\r\n            if(pending > 0) {\r\n                safeEulerTransfer(msg.sender, pending);\r\n            }\r\n        }\r\n        if(_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            user.amount = user.amount.add(_amount);\r\n        }\r\n        user.rewardEULER = user.amount.mul(pool.accEULERPerShare).div(1e12);\r\n        if (user.amount > 0){\r\n            addressAvailable[msg.sender] = true;\r\n            if(!addressAvailableHistory[msg.sender]){\r\n                addressAvailableHistory[msg.sender] = true;\r\n                airdropList.push(msg.sender);\r\n            }\r\n        }\r\n        emit Deposit(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens from Formula.\r\n    function withdraw(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserLPInfo storage user = userLPInfo[_pid][msg.sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        updatePool(_pid);\r\n        uint256 pending = user.amount.mul(pool.accEULERPerShare).div(1e12).sub(user.rewardEULER);\r\n        if(pending > 0) {\r\n            safeEulerTransfer(msg.sender, pending);\r\n        }\r\n        if(_amount > 0) {\r\n        user.amount = user.amount.sub(_amount);\r\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n        }\r\n        user.rewardEULER = user.amount.mul(pool.accEULERPerShare).div(1e12);\r\n        if (user.amount == 0){\r\n            addressAvailable[msg.sender] = false;\r\n        }\r\n        emit Withdraw(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserLPInfo storage user = userLPInfo[_pid][msg.sender];\r\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\r\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\r\n        user.amount = 0;\r\n        user.rewardEULER = 0;\r\n        addressAvailable[msg.sender] = false;\r\n    }\r\n\r\n    // Safe euler transfer function, just in case if rounding error causes pool to not have enough EULERs.\r\n    function safeEulerTransfer(address _to, uint256 _amount) internal {\r\n        uint256 eulerBal = eulerBalanceOf(address(this));\r\n        if (_amount > eulerBal) {\r\n            transfer(_to, eulerBal);\r\n        } else {\r\n            transfer(_to, _amount);\r\n        }\r\n    }\r\n\r\n    // Update dev address by the previous dev.\r\n    function dev(address _devaddr) public {\r\n        require(msg.sender == devaddr, \"dev: wut?\");\r\n        devaddr = _devaddr;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IETradingNFT\",\"name\":\"_ETradingNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"enftID\",\"type\":\"uint256\"}],\"name\":\"AirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"enftID\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_enftID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fixedPrice\",\"type\":\"uint256\"}],\"name\":\"addEnft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airDropByUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"airdropList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"base\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devaddr\",\"type\":\"address\"}],\"name\":\"dev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devaddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"draw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_enftID\",\"type\":\"uint256\"}],\"name\":\"enftBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"enftInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"enftID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enftLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"eulerBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"eulerBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eulerPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eulersFused\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrator\",\"outputs\":[{\"internalType\":\"contract IMigratorEulersFormula\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"originalTotalEnftAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingEULER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accEULERPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"}],\"name\":\"setBonusEndBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bonusMultiplier\",\"type\":\"uint256\"}],\"name\":\"setBonusMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eulerPerBlock\",\"type\":\"uint256\"}],\"name\":\"setEULERPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newEulersFused\",\"type\":\"uint256\"}],\"name\":\"setEulersFused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMigratorEulersFormula\",\"name\":\"_migrator\",\"type\":\"address\"}],\"name\":\"setMigrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newAllocPoint\",\"type\":\"uint256\"}],\"name\":\"setNewAllocPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_newLpToken\",\"type\":\"address\"}],\"name\":\"setNewLpToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"setStartBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTotalFee\",\"type\":\"uint256\"}],\"name\":\"setTotalFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEnftAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_enftID\",\"type\":\"uint256\"}],\"name\":\"userEnftBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userEnftInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLPInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardEULER\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"userUnclaimEnft\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EulersFormula","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000028bf2d72dfc29c9a8271664d825be2ab035b82a100000000000000000000000098cd0f8f40e0f2810d69073fda46d891b9cf23810000000000000000000000000000000000000000000000000000000000af79e00000000000000000000000000000000000000000000000000000000000b71b00","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://10092e7023db6251f73fca86cd0166968385a04882102c7b1255ad6e6a213a5c"}]}