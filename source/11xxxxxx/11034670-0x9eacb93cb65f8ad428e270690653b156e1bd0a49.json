{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nB.PROTOCOL TERMS OF USE\r\n=======================\r\n\r\nTHE TERMS OF USE CONTAINED HEREIN (THESE “TERMS”) GOVERN YOUR USE OF B.PROTOCOL, WHICH IS A DECENTRALIZED PROTOCOL ON THE ETHEREUM BLOCKCHAIN (the “PROTOCOL”) THAT enables a backstop liquidity mechanism FOR DECENTRALIZED LENDING PLATFORMS (“DLPs”).  \r\nPLEASE READ THESE TERMS CAREFULLY AT https://github.com/backstop-protocol/Terms-and-Conditions, INCLUDING ALL DISCLAIMERS AND RISK FACTORS, BEFORE USING THE PROTOCOL. BY USING THE PROTOCOL, YOU ARE IRREVOCABLY CONSENTING TO BE BOUND BY THESE TERMS. \r\nIF YOU DO NOT AGREE TO ALL OF THESE TERMS, DO NOT USE THE PROTOCOL. YOUR RIGHT TO USE THE PROTOCOL IS SUBJECT AND DEPENDENT BY YOUR AGREEMENT TO ALL TERMS AND CONDITIONS SET FORTH HEREIN, WHICH AGREEMENT SHALL BE EVIDENCED BY YOUR USE OF THE PROTOCOL.\r\nMinors Prohibited: The Protocol is not directed to individuals under the age of eighteen (18) or the age of majority in your jurisdiction if the age of majority is greater. If you are under the age of eighteen or the age of majority (if greater), you are not authorized to access or use the Protocol. By using the Protocol, you represent and warrant that you are above such age.\r\n\r\nLicense; No Warranties; Limitation of Liability;\r\n(a) The software underlying the Protocol is licensed for use in accordance with the 3-clause BSD License, which can be accessed here: https://opensource.org/licenses/BSD-3-Clause.\r\n(b) THE PROTOCOL IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\", “WITH ALL FAULTS” and “AS AVAILABLE” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n(c) IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \r\n*/\r\n\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\ncontract Math {\r\n    // --- Math ---\r\n    function add(uint x, int y) internal pure returns (uint z) {\r\n        z = x + uint(y);\r\n        require(y >= 0 || z <= x);\r\n        require(y <= 0 || z >= x);\r\n    }\r\n    function sub(uint x, int y) internal pure returns (uint z) {\r\n        z = x - uint(y);\r\n        require(y <= 0 || z <= x);\r\n        require(y >= 0 || z >= x);\r\n    }\r\n    function mul(uint x, int y) internal pure returns (int z) {\r\n        z = int(x) * y;\r\n        require(int(x) >= 0);\r\n        require(y == 0 || z / y == int(x));\r\n    }\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, RAY) / y;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, y) / RAY;\r\n    }\r\n    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\r\n      assembly {\r\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\r\n        default {\r\n          switch mod(n, 2) case 0 { z := b } default { z := x }\r\n          let half := div(b, 2)  // for rounding.\r\n          for { n := div(n, 2) } n { n := div(n,2) } {\r\n            let xx := mul(x, x)\r\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n            let xxRound := add(xx, half)\r\n            if lt(xxRound, xx) { revert(0,0) }\r\n            x := div(xxRound, b)\r\n            if mod(n,2) {\r\n              let zx := mul(z, x)\r\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n              let zxRound := add(zx, half)\r\n              if lt(zxRound, zx) { revert(0,0) }\r\n              z := div(zxRound, b)\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y >= 0);\r\n    }\r\n}\r\n\r\n\r\ncontract LibNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an 'anonymous' event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize()                       // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller(),                            // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n}\r\n\r\ncontract BCdpScoreLike {\r\n    function updateScore(uint cdp, bytes32 ilk, int dink, int dart, uint time) external;\r\n}\r\n\r\ncontract BCdpScoreConnector {\r\n    BCdpScoreLike public score;\r\n    mapping(uint => uint) public left;\r\n\r\n    constructor(BCdpScoreLike score_) public {\r\n        score = score_;\r\n    }\r\n\r\n    function setScore(BCdpScoreLike bcdpScore) internal {\r\n        score = bcdpScore;\r\n    }\r\n\r\n    function updateScore(uint cdp, bytes32 ilk, int dink, int dart, uint time) internal {\r\n        if(left[cdp] == 0) score.updateScore(cdp, ilk, dink, dart, time);\r\n    }\r\n\r\n    function quitScore(uint cdp) internal {\r\n        if(left[cdp] == 0) left[cdp] = now;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract UrnHandler {\r\n    constructor(address vat) public {\r\n        VatLike(vat).hope(msg.sender);\r\n    }\r\n}\r\n\r\ncontract DssCdpManager is LibNote {\r\n    address                   public vat;\r\n    uint                      public cdpi;      // Auto incremental\r\n    mapping (uint => address) public urns;      // CDPId => UrnHandler\r\n    mapping (uint => List)    public list;      // CDPId => Prev & Next CDPIds (double linked list)\r\n    mapping (uint => address) public owns;      // CDPId => Owner\r\n    mapping (uint => bytes32) public ilks;      // CDPId => Ilk\r\n\r\n    mapping (address => uint) public first;     // Owner => First CDPId\r\n    mapping (address => uint) public last;      // Owner => Last CDPId\r\n    mapping (address => uint) public count;     // Owner => Amount of CDPs\r\n\r\n    mapping (\r\n        address => mapping (\r\n            uint => mapping (\r\n                address => uint\r\n            )\r\n        )\r\n    ) public cdpCan;                            // Owner => CDPId => Allowed Addr => True/False\r\n\r\n    mapping (\r\n        address => mapping (\r\n            address => uint\r\n        )\r\n    ) public urnCan;                            // Urn => Allowed Addr => True/False\r\n\r\n    struct List {\r\n        uint prev;\r\n        uint next;\r\n    }\r\n\r\n    event NewCdp(address indexed usr, address indexed own, uint indexed cdp);\r\n\r\n    modifier cdpAllowed(\r\n        uint cdp\r\n    ) {\r\n        require(msg.sender == owns[cdp] || cdpCan[owns[cdp]][cdp][msg.sender] == 1, \"cdp-not-allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier urnAllowed(\r\n        address urn\r\n    ) {\r\n        require(msg.sender == urn || urnCan[urn][msg.sender] == 1, \"urn-not-allowed\");\r\n        _;\r\n    }\r\n\r\n    constructor(address vat_) public {\r\n        vat = vat_;\r\n    }\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y >= 0);\r\n    }\r\n\r\n    // Allow/disallow a usr address to manage the cdp.\r\n    function cdpAllow(\r\n        uint cdp,\r\n        address usr,\r\n        uint ok\r\n    ) public cdpAllowed(cdp) {\r\n        cdpCan[owns[cdp]][cdp][usr] = ok;\r\n    }\r\n\r\n    // Allow/disallow a usr address to quit to the the sender urn.\r\n    function urnAllow(\r\n        address usr,\r\n        uint ok\r\n    ) public {\r\n        urnCan[msg.sender][usr] = ok;\r\n    }\r\n\r\n    // Open a new cdp for a given usr address.\r\n    function open(\r\n        bytes32 ilk,\r\n        address usr\r\n    ) public note returns (uint) {\r\n        require(usr != address(0), \"usr-address-0\");\r\n\r\n        cdpi = add(cdpi, 1);\r\n        urns[cdpi] = address(new UrnHandler(vat));\r\n        owns[cdpi] = usr;\r\n        ilks[cdpi] = ilk;\r\n\r\n        // Add new CDP to double linked list and pointers\r\n        if (first[usr] == 0) {\r\n            first[usr] = cdpi;\r\n        }\r\n        if (last[usr] != 0) {\r\n            list[cdpi].prev = last[usr];\r\n            list[last[usr]].next = cdpi;\r\n        }\r\n        last[usr] = cdpi;\r\n        count[usr] = add(count[usr], 1);\r\n\r\n        emit NewCdp(msg.sender, usr, cdpi);\r\n        return cdpi;\r\n    }\r\n\r\n    // Give the cdp ownership to a dst address.\r\n    function give(\r\n        uint cdp,\r\n        address dst\r\n    ) public note cdpAllowed(cdp) {\r\n        require(dst != address(0), \"dst-address-0\");\r\n        require(dst != owns[cdp], \"dst-already-owner\");\r\n\r\n        // Remove transferred CDP from double linked list of origin user and pointers\r\n        if (list[cdp].prev != 0) {\r\n            list[list[cdp].prev].next = list[cdp].next;         // Set the next pointer of the prev cdp (if exists) to the next of the transferred one\r\n        }\r\n        if (list[cdp].next != 0) {                              // If wasn't the last one\r\n            list[list[cdp].next].prev = list[cdp].prev;         // Set the prev pointer of the next cdp to the prev of the transferred one\r\n        } else {                                                // If was the last one\r\n            last[owns[cdp]] = list[cdp].prev;                   // Update last pointer of the owner\r\n        }\r\n        if (first[owns[cdp]] == cdp) {                          // If was the first one\r\n            first[owns[cdp]] = list[cdp].next;                  // Update first pointer of the owner\r\n        }\r\n        count[owns[cdp]] = sub(count[owns[cdp]], 1);\r\n\r\n        // Transfer ownership\r\n        owns[cdp] = dst;\r\n\r\n        // Add transferred CDP to double linked list of destiny user and pointers\r\n        list[cdp].prev = last[dst];\r\n        list[cdp].next = 0;\r\n        if (last[dst] != 0) {\r\n            list[last[dst]].next = cdp;\r\n        }\r\n        if (first[dst] == 0) {\r\n            first[dst] = cdp;\r\n        }\r\n        last[dst] = cdp;\r\n        count[dst] = add(count[dst], 1);\r\n    }\r\n\r\n    // Frob the cdp keeping the generated DAI or collateral freed in the cdp urn address.\r\n    function frob(\r\n        uint cdp,\r\n        int dink,\r\n        int dart\r\n    ) public note cdpAllowed(cdp) {\r\n        address urn = urns[cdp];\r\n        VatLike(vat).frob(\r\n            ilks[cdp],\r\n            urn,\r\n            urn,\r\n            urn,\r\n            dink,\r\n            dart\r\n        );\r\n    }\r\n\r\n    // Transfer wad amount of cdp collateral from the cdp address to a dst address.\r\n    function flux(\r\n        uint cdp,\r\n        address dst,\r\n        uint wad\r\n    ) public note cdpAllowed(cdp) {\r\n        VatLike(vat).flux(ilks[cdp], urns[cdp], dst, wad);\r\n    }\r\n\r\n    // Transfer wad amount of any type of collateral (ilk) from the cdp address to a dst address.\r\n    // This function has the purpose to take away collateral from the system that doesn't correspond to the cdp but was sent there wrongly.\r\n    function flux(\r\n        bytes32 ilk,\r\n        uint cdp,\r\n        address dst,\r\n        uint wad\r\n    ) public note cdpAllowed(cdp) {\r\n        VatLike(vat).flux(ilk, urns[cdp], dst, wad);\r\n    }\r\n\r\n    // Transfer wad amount of DAI from the cdp address to a dst address.\r\n    function move(\r\n        uint cdp,\r\n        address dst,\r\n        uint rad\r\n    ) public note cdpAllowed(cdp) {\r\n        VatLike(vat).move(urns[cdp], dst, rad);\r\n    }\r\n\r\n    // Quit the system, migrating the cdp (ink, art) to a different dst urn\r\n    function quit(\r\n        uint cdp,\r\n        address dst\r\n    ) public note cdpAllowed(cdp) urnAllowed(dst) {\r\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdp], urns[cdp]);\r\n        VatLike(vat).fork(\r\n            ilks[cdp],\r\n            urns[cdp],\r\n            dst,\r\n            toInt(ink),\r\n            toInt(art)\r\n        );\r\n    }\r\n\r\n    // Import a position from src urn to the urn owned by cdp\r\n    function enter(\r\n        address src,\r\n        uint cdp\r\n    ) public note urnAllowed(src) cdpAllowed(cdp) {\r\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdp], src);\r\n        VatLike(vat).fork(\r\n            ilks[cdp],\r\n            src,\r\n            urns[cdp],\r\n            toInt(ink),\r\n            toInt(art)\r\n        );\r\n    }\r\n\r\n    // Move a position from cdpSrc urn to the cdpDst urn\r\n    function shift(\r\n        uint cdpSrc,\r\n        uint cdpDst\r\n    ) public note cdpAllowed(cdpSrc) cdpAllowed(cdpDst) {\r\n        require(ilks[cdpSrc] == ilks[cdpDst], \"non-matching-cdps\");\r\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdpSrc], urns[cdpSrc]);\r\n        VatLike(vat).fork(\r\n            ilks[cdpSrc],\r\n            urns[cdpSrc],\r\n            urns[cdpDst],\r\n            toInt(ink),\r\n            toInt(art)\r\n        );\r\n    }\r\n}\r\n\r\n\r\ninterface DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) external view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract VatLike {\r\n    function urns(bytes32, address) public view returns (uint, uint);\r\n    function hope(address) external;\r\n    function flux(bytes32, address, address, uint) public;\r\n    function move(address, address, uint) public;\r\n    function frob(bytes32, address, address, address, int, int) public;\r\n    function fork(bytes32, address, address, int, int) public;\r\n    function ilks(bytes32 ilk) public view returns(uint Art, uint rate, uint spot, uint line, uint dust);\r\n\r\n}\r\n\r\ncontract CatLike {\r\n    function ilks(bytes32) public returns(address flip, uint256 chop, uint256 lump);\r\n}\r\n\r\ncontract EndLike {\r\n    function cat() public view returns(CatLike);\r\n}\r\n\r\ncontract PriceFeedLike {\r\n    function read(bytes32 ilk) external view returns(bytes32);\r\n}\r\n\r\ncontract LiquidationMachine is DssCdpManager, BCdpScoreConnector, Math {\r\n    VatLike                   public vat;\r\n    EndLike                   public end;\r\n    address                   public pool;\r\n    PriceFeedLike             public real;\r\n\r\n    mapping(uint => uint)     public tic;  // time of bite\r\n    mapping(uint => uint)     public cushion; // how much was topped in art units\r\n\r\n    uint constant             public GRACE = 1 hours;\r\n    uint constant             public WAD = 1e18;\r\n\r\n    mapping (uint => bool)    public out;\r\n\r\n    modifier onlyPool {\r\n        require(msg.sender == pool, \"not-pool\");\r\n        _;\r\n    }\r\n\r\n    constructor(VatLike vat_, EndLike end_, address pool_, PriceFeedLike real_) public {\r\n        vat = vat_;\r\n        end = end_;\r\n        pool = pool_;\r\n        real = real_;\r\n    }\r\n\r\n    function setPool(address newPool) internal {\r\n        pool = newPool;\r\n    }\r\n\r\n    function quitBLiquidation(uint cdp) internal {\r\n        untop(cdp);\r\n        out[cdp] = true;\r\n    }\r\n\r\n    function topup(uint cdp, uint dtopup) external onlyPool {\r\n        if(out[cdp]) return;\r\n\r\n        address urn = urns[cdp];\r\n        bytes32 ilk = ilks[cdp];\r\n\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        uint dtab = mul(rate, dtopup);\r\n\r\n        vat.move(pool, address(this), dtab);\r\n        vat.frob(ilk, urn, urn, address(this), 0, -toInt(dtopup));\r\n\r\n        cushion[cdp] = add(cushion[cdp], dtopup);\r\n    }\r\n\r\n    function bitten(uint cdp) public view returns(bool) {\r\n        return tic[cdp] + GRACE > now;\r\n    }\r\n\r\n    function untop(uint cdp) internal {\r\n        require(! bitten(cdp), \"untop: cdp was already bitten\");\r\n\r\n        uint top = cushion[cdp];\r\n        if(top == 0) return; // nothing to do\r\n\r\n        bytes32 ilk = ilks[cdp];\r\n        address urn = urns[cdp];\r\n\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        uint dtab = mul(rate, top);\r\n\r\n        cushion[cdp] = 0;\r\n\r\n        // move topping to pool\r\n        vat.frob(ilk, urn, urn, urn, 0, toInt(top));\r\n        vat.move(urn, pool, dtab);\r\n    }\r\n\r\n    function untopByPool(uint cdp) external onlyPool {\r\n        untop(cdp);\r\n    }\r\n\r\n    function doBite(uint dart, bytes32 ilk, address urn, uint dink) internal {\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        uint dtab = mul(rate, dart);\r\n\r\n        vat.move(pool, address(this), dtab);\r\n\r\n        vat.frob(ilk, urn, urn, address(this), 0, -toInt(dart));\r\n        vat.frob(ilk, urn, msg.sender, urn, -toInt(dink), 0);\r\n    }\r\n\r\n    function calcDink(uint dart, uint rate, bytes32 ilk) internal returns(uint dink) {\r\n        (, uint chop,) = end.cat().ilks(ilk);\r\n        uint tab = mul(mul(dart, rate), chop) / WAD;\r\n        bytes32 realtimePrice = real.read(ilk);\r\n\r\n        dink = rmul(tab, WAD) / uint(realtimePrice);\r\n    }\r\n\r\n    function bite(uint cdp, uint dart) external onlyPool returns(uint dink){\r\n        address urn = urns[cdp];\r\n        bytes32 ilk = ilks[cdp];\r\n\r\n        (uint ink, uint art) = vat.urns(ilk, urn);\r\n        art = add(art, cushion[cdp]);\r\n        (, uint rate, uint spotValue,,) = vat.ilks(ilk);\r\n\r\n        require(dart <= art, \"debt is too low\");\r\n\r\n        // verify cdp is unsafe now\r\n        if(! bitten(cdp)) {\r\n            require(mul(art, rate) > mul(ink, spotValue), \"bite: cdp is safe\");\r\n            require(cushion[cdp] > 0, \"bite: not-topped\");\r\n            tic[cdp] = now;\r\n        }\r\n\r\n        dink = calcDink(dart, rate, ilk);\r\n        updateScore(cdp, ilk, -toInt(dink), -toInt(dart), now);\r\n\r\n        uint usedCushion = mul(cushion[cdp], dart) / art;\r\n        cushion[cdp] = sub(cushion[cdp], usedCushion);\r\n        uint bart = sub(dart, usedCushion);\r\n\r\n        doBite(bart, ilk, urn, dink);\r\n    }\r\n}\r\n\r\n\r\ncontract BCdpManager is BCdpScoreConnector, LiquidationMachine, DSAuth {\r\n    constructor(address vat_, address end_, address pool_, address real_, address score_) public\r\n        DssCdpManager(vat_)\r\n        LiquidationMachine(VatLike(vat_), EndLike(end_), pool_, PriceFeedLike(real_))\r\n        BCdpScoreConnector(BCdpScoreLike(score_))\r\n    {\r\n\r\n    }\r\n\r\n    // Frob the cdp keeping the generated DAI or collateral freed in the cdp urn address.\r\n    function frob(\r\n        uint cdp,\r\n        int dink,\r\n        int dart\r\n    ) public cdpAllowed(cdp) {\r\n        bytes32 ilk = ilks[cdp];\r\n\r\n        untop(cdp);\r\n        updateScore(cdp, ilk, dink, dart, now);\r\n\r\n        super.frob(cdp, dink, dart);\r\n    }\r\n\r\n    // Quit the system, migrating the cdp (ink, art) to a different dst urn\r\n    function quit(\r\n        uint cdp,\r\n        address dst\r\n    ) public cdpAllowed(cdp) urnAllowed(dst) {\r\n        address urn = urns[cdp];\r\n        bytes32 ilk = ilks[cdp];\r\n\r\n        untop(cdp);\r\n        (uint ink, uint art) = vat.urns(ilk, urn);\r\n        updateScore(cdp, ilk, -toInt(ink), -toInt(art), now);\r\n\r\n        super.quit(cdp, dst);\r\n    }\r\n\r\n    // Import a position from src urn to the urn owned by cdp\r\n    function enter(\r\n        address src,\r\n        uint cdp\r\n    ) public urnAllowed(src) cdpAllowed(cdp) {\r\n        bytes32 ilk = ilks[cdp];\r\n\r\n        untop(cdp);\r\n        (uint ink, uint art) = vat.urns(ilk, src);\r\n        updateScore(cdp, ilk, toInt(ink), toInt(art), now);\r\n\r\n        super.enter(src, cdp);\r\n    }\r\n\r\n    // Move a position from cdpSrc urn to the cdpDst urn\r\n    function shift(\r\n        uint cdpSrc,\r\n        uint cdpDst\r\n    ) public cdpAllowed(cdpSrc) cdpAllowed(cdpDst) {\r\n        bytes32 ilkSrc = ilks[cdpSrc];\r\n\r\n        untop(cdpSrc);\r\n        untop(cdpDst);\r\n\r\n        address src = urns[cdpSrc];\r\n\r\n        (uint inkSrc, uint artSrc) = vat.urns(ilkSrc, src);\r\n\r\n        updateScore(cdpSrc, ilkSrc, -toInt(inkSrc), -toInt(artSrc), now);\r\n        updateScore(cdpDst, ilkSrc, toInt(inkSrc), toInt(artSrc), now);\r\n\r\n        super.shift(cdpSrc, cdpDst);\r\n    }\r\n\r\n    ///////////////// B specific control functions /////////////////////////////\r\n\r\n    function quitB(uint cdp) external cdpAllowed(cdp) note {\r\n        quitScore(cdp);\r\n        quitBLiquidation(cdp);\r\n    }\r\n\r\n    function setScoreContract(BCdpScoreLike _score) external auth {\r\n        super.setScore(_score);\r\n    }\r\n\r\n    function setPoolContract(address _pool) external auth {\r\n        super.setPool(_pool);\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ScoringMachine is Ownable {\r\n    struct AssetScore {\r\n        // total score so far\r\n        uint score;\r\n\r\n        // current balance\r\n        uint balance;\r\n\r\n        // time when last update was\r\n        uint last;\r\n    }\r\n\r\n    // user is bytes32 (will be the sha3 of address or cdp number)\r\n    mapping(bytes32 => mapping(bytes32 => AssetScore[])) public checkpoints;\r\n\r\n    mapping(bytes32 => mapping(bytes32 => AssetScore)) public userScore;\r\n\r\n    bytes32 constant public GLOBAL_USER = bytes32(0x0);\r\n\r\n    uint public start; // start time of the campaign;\r\n\r\n    function spin() external onlyOwner { // start a new round\r\n        start = now;\r\n    }\r\n\r\n    function assetScore(AssetScore storage score, uint time, uint spinStart) internal view returns(uint) {\r\n        uint last = score.last;\r\n        uint currentScore = score.score;\r\n        if(last < spinStart) {\r\n            last = spinStart;\r\n            currentScore = 0;\r\n        }\r\n\r\n        return add(currentScore, mul(score.balance, sub(time, last)));\r\n    }\r\n\r\n    function addCheckpoint(bytes32 user, bytes32 asset) internal {\r\n        checkpoints[user][asset].push(userScore[user][asset]);\r\n    }\r\n\r\n    function updateAssetScore(bytes32 user, bytes32 asset, int dbalance, uint time) internal {\r\n        AssetScore storage score = userScore[user][asset];\r\n\r\n        if(score.last < start) addCheckpoint(user, asset);\r\n\r\n        score.score = assetScore(score, time, start);\r\n        score.balance = add(score.balance, dbalance);\r\n        \r\n        score.last = time;\r\n    }\r\n\r\n    function updateScore(bytes32 user, bytes32 asset, int dbalance, uint time) internal {\r\n        updateAssetScore(user, asset, dbalance, time);\r\n        updateAssetScore(GLOBAL_USER, asset, dbalance, time);\r\n    }\r\n\r\n    function getScore(bytes32 user, bytes32 asset, uint time, uint spinStart, uint checkPointHint) public view returns(uint score) {\r\n        if(time >= userScore[user][asset].last) return assetScore(userScore[user][asset], time, spinStart);\r\n\r\n        // else - check the checkpoints\r\n        uint checkpointsLen = checkpoints[user][asset].length;\r\n        if(checkpointsLen == 0) return 0;\r\n\r\n        // hint is invalid\r\n        if(checkpoints[user][asset][checkPointHint].last < time) checkPointHint = checkpointsLen - 1;\r\n\r\n        for(uint i = checkPointHint ; ; i--){\r\n            if(checkpoints[user][asset][i].last <= time) return assetScore(checkpoints[user][asset][i], time, spinStart);\r\n        }\r\n\r\n        // this supposed to be unreachable\r\n        return 0;\r\n    }\r\n\r\n    function getCurrentBalance(bytes32 user, bytes32 asset) public view returns(uint balance) {\r\n        balance = userScore[user][asset].balance;\r\n    }\r\n\r\n    // Math functions without errors\r\n    // ==============================\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x + y;\r\n        if(!(z >= x)) return 0;\r\n\r\n        return z;\r\n    }\r\n\r\n    function add(uint x, int y) internal pure returns (uint z) {\r\n        z = x + uint(y);\r\n        if(!(y >= 0 || z <= x)) return 0;\r\n        if(!(y <= 0 || z >= x)) return 0;\r\n\r\n        return z;\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        if(!(y <= x)) return 0;\r\n        z = x - y;\r\n\r\n        return z;\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        if (x == 0) return 0;\r\n\r\n        z = x * y;\r\n        if(!(z / x == y)) return 0;\r\n\r\n        return z;\r\n    }\r\n}\r\n\r\n\r\ncontract BCdpScore is ScoringMachine {\r\n    BCdpManager public manager;\r\n\r\n    modifier onlyManager {\r\n        require(msg.sender == address(manager), \"not-manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager(address newManager) external onlyOwner {\r\n        manager = BCdpManager(newManager);\r\n    }\r\n\r\n    function user(uint cdp) public pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(\"BCdpScore\", cdp));\r\n    }\r\n\r\n    function artAsset(bytes32 ilk) public pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(\"BCdpScore\", \"art\", ilk));\r\n    }\r\n\r\n    function updateScore(uint cdp, bytes32 ilk, int dink, int dart, uint time) external onlyManager {\r\n        dink; // shh compiler warning\r\n        updateScore(user(cdp), artAsset(ilk), dart, time);\r\n    }\r\n\r\n    function slashScore(uint maliciousCdp) external {\r\n        address urn = manager.urns(maliciousCdp);\r\n        bytes32 ilk = manager.ilks(maliciousCdp);\r\n\r\n        (, uint realArt) = manager.vat().urns(ilk, urn);\r\n\r\n        bytes32 maliciousUser = user(maliciousCdp);\r\n        bytes32 asset = artAsset(ilk);\r\n\r\n        uint left = BCdpScoreConnector(address(manager)).left(maliciousCdp);\r\n\r\n        realArt = left > 0 ? 0 : realArt;\r\n        uint startTime = left > 0 ? left : now;\r\n\r\n        uint calculatedArt = getCurrentBalance(maliciousUser, asset);\r\n        require(realArt < calculatedArt, \"slashScore-cdp-is-ok\");\r\n        int dart = int(realArt) - int(calculatedArt);\r\n        uint time = sub(startTime, 30 days);\r\n        if(time < start) time = start;\r\n        \r\n        updateScore(maliciousUser, asset, dart, time);\r\n    }\r\n\r\n    function getArtScore(uint cdp, bytes32 ilk, uint time, uint spinStart) public view returns(uint) {\r\n        return getScore(user(cdp), artAsset(ilk), time, spinStart, 0);\r\n    }\r\n\r\n    function getArtGlobalScore(bytes32 ilk, uint time, uint spinStart) public view returns(uint) {\r\n        return getScore(GLOBAL_USER, artAsset(ilk), time, spinStart, 0);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract JarConnector is Math {\r\n    BCdpScore   public score;\r\n    BCdpManager public man;\r\n    bytes32[]   public ilks;\r\n    // ilk => supported\r\n    mapping(bytes32 => bool) public milks;\r\n\r\n    // end of every round\r\n    uint[2] public end;\r\n    // start time of every round\r\n    uint[2] public start;\r\n\r\n    uint public round;\r\n\r\n    constructor(\r\n        bytes32[] memory _ilks,\r\n        uint[2] memory _duration\r\n    ) public {\r\n        ilks = _ilks;\r\n\r\n        for(uint i = 0; i < _ilks.length; i++) {\r\n            milks[_ilks[i]] = true;\r\n        }\r\n\r\n        end[0] = now + _duration[0];\r\n        end[1] = now + _duration[0] + _duration[1];\r\n\r\n        round = 0;\r\n    }\r\n\r\n    function setManager(address _manager) public {\r\n        require(man == BCdpManager(0), \"manager-already-set\");\r\n        man = BCdpManager(_manager);\r\n        score = BCdpScore(address(man.score()));\r\n    }\r\n\r\n    // callable by anyone\r\n    function spin() public {\r\n        if(round == 0) {\r\n            round++;\r\n            score.spin();\r\n            start[0] = score.start();\r\n        }\r\n        if(round == 1 && now > end[0]) {\r\n            round++;\r\n            score.spin();\r\n            start[1] = score.start();\r\n        }\r\n        if(round == 2 && now > end[1]) {\r\n            round++;        \r\n            // score is not counted anymore, and this must be followed by contract upgrade\r\n            score.spin();\r\n        }\r\n    }\r\n\r\n    function getUserScore(bytes32 user) external view returns (uint) {\r\n        if(round == 0) return 0;\r\n\r\n        uint cdp = uint(user);\r\n        bytes32 ilk = man.ilks(cdp);\r\n\r\n        // Should return 0 score for unsupported ilk\r\n        if( ! milks[ilk]) return 0;\r\n\r\n        if(round == 1) return 2 * score.getArtScore(cdp, ilk, now, start[0]);\r\n\r\n        uint firstRoundScore = 2 * score.getArtScore(cdp, ilk, start[1], start[0]);\r\n        uint time = now;\r\n        if(round > 2) time = end[1];\r\n\r\n        return add(score.getArtScore(cdp, ilk, time, start[1]), firstRoundScore);\r\n    }\r\n\r\n    function getGlobalScore() external view returns (uint) {\r\n        if(round == 0) return 0;\r\n\r\n        if(round == 1) return 2 * getArtGlobalScore(now, start[0]);\r\n\r\n        uint firstRoundScore = 2 * getArtGlobalScore(start[1], start[0]);\r\n        uint time = now;\r\n        if(round > 2) time = end[1];\r\n\r\n        return add(getArtGlobalScore(time, start[1]), firstRoundScore);\r\n    }\r\n\r\n    function getGlobalScore(bytes32 ilk) external view returns (uint) {\r\n        if(round == 0) return 0;\r\n\r\n        if(round == 1) return 2 * score.getArtGlobalScore(ilk, now, start[0]);\r\n\r\n        uint firstRoundScore = 2 * score.getArtGlobalScore(ilk, start[1], start[0]);\r\n        uint time = now;\r\n        if(round > 2) time = end[1];\r\n\r\n        return add(score.getArtGlobalScore(ilk, time, start[1]), firstRoundScore);\r\n    }\r\n\r\n    function getArtGlobalScore(uint time, uint spinStart) internal view returns (uint totalScore) {\r\n        for(uint i = 0; i < ilks.length; i++) {\r\n            totalScore = add(totalScore, score.getArtGlobalScore(ilks[i], time, spinStart));\r\n        }\r\n    }\r\n\r\n    function toUser(bytes32 user) external view returns (address) {\r\n        return man.owns(uint(user));\r\n    }\r\n}\r\n\r\ncontract GovernanceExecutor is DSAuth, Math {\r\n\r\n    BCdpManager public man;\r\n    uint public delay;\r\n    mapping(address => uint) public requests;\r\n    address public governance;\r\n\r\n    event RequestPoolUpgrade(address indexed pool);\r\n    event PoolUpgraded(address indexed pool);\r\n\r\n    constructor(address man_, uint delay_) public {\r\n        man = BCdpManager(man_);\r\n        delay = delay_;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets governance address\r\n     * @param governance_ Address of the governance\r\n     */\r\n    function setGovernance(address governance_) external auth {\r\n        require(governance == address(0), \"governance-already-set\");\r\n        governance = governance_;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer admin of BCdpManager\r\n     * @param owner New admin address\r\n     */\r\n    function doTransferAdmin(address owner) external {\r\n        require(msg.sender == governance, \"unauthorized\");\r\n        man.setOwner(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Request pool contract upgrade\r\n     * @param pool Address of new pool contract\r\n     */\r\n    function reqUpgradePool(address pool) external auth {\r\n        requests[pool] = now;\r\n        emit RequestPoolUpgrade(pool);\r\n    }\r\n\r\n    /**\r\n     * @dev Drop upgrade pool request\r\n     * @param pool Address of pool contract\r\n     */\r\n    function dropUpgradePool(address pool) external auth {\r\n        delete requests[pool];\r\n    }\r\n\r\n    /**\r\n     * @dev Execute pool contract upgrade after delay\r\n     * @param pool Address of the new pool contract\r\n     */\r\n    function execUpgradePool(address pool) external {\r\n        uint reqTime = requests[pool];\r\n        require(reqTime != 0, \"request-not-valid\");\r\n        require(now >= add(reqTime, delay), \"delay-not-over\");\r\n        \r\n        delete requests[pool];\r\n        man.setPoolContract(pool);\r\n        emit PoolUpgraded(pool);\r\n    }\r\n}\r\n\r\ncontract Migrate is Math {\r\n\r\n    event NewProposal(uint indexed proposalId, address newOwner);\r\n    event Voted(uint indexed proposalId, uint cdp, uint score);\r\n    event VoteCancelled(uint indexed proposalId, uint cdp, uint score);\r\n    event Queued(uint indexed proposalId);\r\n    event Executed(uint indexed proposalId);\r\n\r\n    struct Proposal {\r\n        uint forVotes;\r\n        uint eta;\r\n        address newOwner;\r\n        mapping (uint => bool) voted; // cdp => voted\r\n    }\r\n\r\n    uint public constant DELAY = 2 days;\r\n\r\n    JarConnector public jarConnector;\r\n    BCdpManager public man;\r\n    GovernanceExecutor public executor;\r\n\r\n    Proposal[] public proposals;\r\n\r\n    constructor(\r\n        JarConnector jarConnector_,\r\n        BCdpManager man_,\r\n        GovernanceExecutor executor_\r\n    ) public {\r\n        jarConnector = jarConnector_;\r\n        man = man_;\r\n        executor = executor_;\r\n    }\r\n\r\n    function propose(address newOwner) external returns (uint) {\r\n        require(jarConnector.round() > 2, \"six-months-not-passed\");\r\n        require(newOwner != address(0), \"newOwner-cannot-be-zero\");\r\n\r\n        Proposal memory proposal = Proposal({\r\n            forVotes: 0,\r\n            eta: 0,\r\n            newOwner: newOwner\r\n        });\r\n\r\n        uint proposalId = sub(proposals.push(proposal), uint(1));\r\n        emit NewProposal(proposalId, newOwner);\r\n\r\n        return proposalId;\r\n    }\r\n\r\n    function vote(uint proposalId, uint cdp) external {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.newOwner != address(0), \"proposal-not-exist\");\r\n        require(! proposal.voted[cdp], \"already-voted\");\r\n        require(msg.sender == man.owns(cdp), \"not-cdp-owner\");\r\n        \r\n        uint score = jarConnector.getUserScore(bytes32(cdp));\r\n        proposal.forVotes = add(proposal.forVotes, score);\r\n        proposal.voted[cdp] = true;\r\n\r\n        emit Voted(proposalId, cdp, score);\r\n    }\r\n\r\n    function cancelVote(uint proposalId, uint cdp) external {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.newOwner != address(0), \"proposal-not-exist\");\r\n        require(proposal.voted[cdp], \"not-voted\");\r\n        require(msg.sender == man.owns(cdp), \"not-cdp-owner\");\r\n\r\n        uint score = jarConnector.getUserScore(bytes32(cdp));\r\n        proposal.forVotes = sub(proposal.forVotes, score);\r\n        proposal.voted[cdp] = false;\r\n\r\n        emit VoteCancelled(proposalId, cdp, score);\r\n    }\r\n\r\n    function queueProposal(uint proposalId) external {\r\n        uint quorum = add(jarConnector.getGlobalScore() / 2, uint(1)); // 50%\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.eta == 0, \"already-queued\");\r\n        require(proposal.newOwner != address(0), \"proposal-not-exist\");\r\n        require(proposal.forVotes >= quorum, \"quorum-not-passed\");\r\n\r\n        proposal.eta = now + DELAY;\r\n\r\n        emit Queued(proposalId);\r\n    }\r\n\r\n    function executeProposal(uint proposalId) external {\r\n        Proposal memory proposal = proposals[proposalId];\r\n        require(proposal.eta > 0, \"proposal-not-queued\");\r\n        require(now >= proposal.eta, \"delay-not-over\");\r\n\r\n        executor.doTransferAdmin(proposal.newOwner);\r\n\r\n        emit Executed(proposalId);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract JarConnector\",\"name\":\"jarConnector_\",\"type\":\"address\"},{\"internalType\":\"contract BCdpManager\",\"name\":\"man_\",\"type\":\"address\"},{\"internalType\":\"contract GovernanceExecutor\",\"name\":\"executor_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"NewProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"Queued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"}],\"name\":\"VoteCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"}],\"name\":\"cancelVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"contract GovernanceExecutor\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jarConnector\",\"outputs\":[{\"internalType\":\"contract JarConnector\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"man\",\"outputs\":[{\"internalType\":\"contract BCdpManager\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"queueProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Migrate","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002cd6eaf23f73bc4f359b69711fb34728c599c34c0000000000000000000000003320f0a2f18a5177dd53a46c59ad8145d9f7e14700000000000000000000000081c4b9b35ec847151af8c81856e434b6a8c4ac68","EVMVersion":"Default","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"bzzr://959ee840ebb40b1d988feee8c2dc0102eb9bff6681c9f0da83383bfecadfbef9"}]}