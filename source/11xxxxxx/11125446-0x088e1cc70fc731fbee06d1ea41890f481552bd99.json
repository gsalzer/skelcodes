{"status":"1","message":"OK","result":[{"SourceCode":"{\"ChangeVerifiersExternalInitializer.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\nimport \\\"ExternalInitializer.sol\\\";\\nimport \\\"Identity.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"Common.sol\\\";\\nimport \\\"LibConstants.sol\\\";\\n\\n/*\\n  This contract is simple impelementation of an external initializing contract\\n  that removes all existing verifiers and committees and insall the ones provided in parameters.\\n*/\\ncontract ChangeVerifiersExternalInitializer is\\n    ExternalInitializer,\\n    MainStorage,\\n    LibConstants\\n{\\n    using Addresses for address;\\n    uint256 constant ENTRY_NOT_FOUND = uint256(~0);\\n\\n    /*\\n      The initiatialize function gets four parameters in the bytes array:\\n      1. New verifier address,\\n      2. Keccak256 of the expected verifier id.\\n      3. New availability verifier address,\\n      4. Keccak256 of the expected availability verifier id.\\n    */\\n    function initialize(bytes calldata data) external {\\n        require(data.length == 128, \\\"UNEXPECTED_DATA_SIZE\\\");\\n        address newVerifierAddress;\\n        bytes32 verifierIdHash;\\n        address newAvailabilityVerifierAddress;\\n        bytes32 availabilityVerifierIdHash;\\n\\n        // Extract sub-contract address and hash of verifierId.\\n        (\\n            newVerifierAddress,\\n            verifierIdHash,\\n            newAvailabilityVerifierAddress,\\n            availabilityVerifierIdHash\\n        ) = abi.decode(data, (address, bytes32, address, bytes32));\\n\\n        // Flush the entire verifiers list.\\n        delete verifiersChain.list;\\n        delete availabilityVerifiersChain.list;\\n\\n        // ApprovalChain addEntry performs all the required checks for us.\\n        addEntry(verifiersChain, newVerifierAddress, MAX_VERIFIER_COUNT, verifierIdHash);\\n        addEntry(\\n            availabilityVerifiersChain, newAvailabilityVerifierAddress,\\n            MAX_VERIFIER_COUNT, availabilityVerifierIdHash);\\n\\n        emit LogExternalInitialize(data);\\n    }\\n\\n    /*\\n      The functions below are taken from ApprovalChain.sol, with minor changes:\\n      1. No governance needed (we are under the context where proxy governance is granted).\\n      2. The verifier ID is passed as hash, and not as string.\\n    */\\n    function addEntry(\\n        StarkExTypes.ApprovalChainData storage chain,\\n        address entry, uint256 maxLength, bytes32 hashExpectedId)\\n        internal\\n    {\\n        address[] storage list = chain.list;\\n        require(entry.isContract(), \\\"ADDRESS_NOT_CONTRACT\\\");\\n        bytes32 hashRealId = keccak256(abi.encodePacked(Identity(entry).identify()));\\n        require(hashRealId == hashExpectedId, \\\"UNEXPECTED_CONTRACT_IDENTIFIER\\\");\\n        require(list.length \\u003c maxLength, \\\"CHAIN_AT_MAX_CAPACITY\\\");\\n        require(findEntry(list, entry) == ENTRY_NOT_FOUND, \\\"ENTRY_ALREADY_EXISTS\\\");\\n        chain.list.push(entry);\\n        chain.unlockedForRemovalTime[entry] = 0;\\n    }\\n\\n    function findEntry(address[] storage list, address entry)\\n        internal view returns (uint256)\\n    {\\n        uint256 n_entries = list.length;\\n        for (uint256 i = 0; i \\u003c n_entries; i++) {\\n            if (list[i] == entry) {\\n                return i;\\n            }\\n        }\\n        return ENTRY_NOT_FOUND;\\n    }\\n}\\n\"},\"Common.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\n/*\\n  Common Utility librarries.\\n  I. Addresses (extending address).\\n*/\\nlibrary Addresses {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    function performEthTransfer(address recipient, uint256 amount) internal {\\n        // solium-disable-next-line security/no-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\"); // NOLINT: low-level-calls.\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*\\n      Safe wrapper around ERC20/ERC721 calls.\\n      This is required because many deployed ERC20 contracts don\\u0027t return a value.\\n      See https://github.com/ethereum/solidity/issues/4116.\\n    */\\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\\n        require(isContract(tokenAddress), \\\"BAD_TOKEN_ADDRESS\\\");\\n        // solium-disable-next-line security/no-low-level-calls\\n        // NOLINTNEXTLINE: low-level-calls.\\n        (bool success, bytes memory returndata) = address(tokenAddress).call(callData);\\n        require(success, string(returndata));\\n\\n        if (returndata.length \\u003e 0) {\\n            require(abi.decode(returndata, (bool)), \\\"TOKEN_OPERATION_FAILED\\\");\\n        }\\n    }\\n}\\n\\n/*\\n  II. StarkExTypes - Common data types.\\n*/\\nlibrary StarkExTypes {\\n\\n    // Structure representing a list of verifiers (validity/availability).\\n    // A statement is valid only if all the verifiers in the list agree on it.\\n    // Adding a verifier to the list is immediate - this is used for fast resolution of\\n    // any soundness issues.\\n    // Removing from the list is time-locked, to ensure that any user of the system\\n    // not content with the announced removal has ample time to leave the system before it is\\n    // removed.\\n    struct ApprovalChainData {\\n        address[] list;\\n        // Represents the time after which the verifier with the given address can be removed.\\n        // Removal of the verifier with address A is allowed only in the case the value\\n        // of unlockedForRemovalTime[A] != 0 and unlockedForRemovalTime[A] \\u003c (current time).\\n        mapping (address =\\u003e uint256) unlockedForRemovalTime;\\n    }\\n\\n}\\n\"},\"ExternalInitializer.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\ncontract ExternalInitializer {\\n\\n    event LogExternalInitialize(bytes data);\\n\\n    function initialize(bytes calldata data) external;\\n}\\n\"},\"GovernanceStorage.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\n/*\\n  Holds the governance slots for ALL entities, including proxy and the main contract.\\n*/\\ncontract GovernanceStorage {\\n\\n    struct GovernanceInfoStruct {\\n        mapping (address =\\u003e bool) effectiveGovernors;\\n        address candidateGovernor;\\n        bool initialized;\\n    }\\n\\n    // A map from a Governor tag to its own GovernanceInfoStruct.\\n    mapping (string =\\u003e GovernanceInfoStruct) internal governanceInfo;\\n}\\n\"},\"Identity.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\ncontract Identity {\\n\\n    /*\\n      Allows a caller, typically another contract,\\n      to ensure that the provided address is of the expected type and version.\\n    */\\n    function identify()\\n        external pure\\n        returns(string memory);\\n}\\n\"},\"IFactRegistry.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\n/*\\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\\n  business logic of the contract flow.\\n\\n  A fact registry holds a hash table of verified \\\"facts\\\" which are represented by a hash of claims\\n  that the registry hash check and found valid. This table may be queried by accessing the\\n  isValid() function of the registry with a given hash.\\n\\n  In addition, each fact registry exposes a registry specific function for submitting new claims\\n  together with their proofs. The information submitted varies from one registry to the other\\n  depending of the type of fact requiring verification.\\n\\n  For further reading on the Fact Registry design pattern see this\\n  `StarkWare blog post \\u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\\u003e`_.\\n*/\\ncontract IFactRegistry {\\n    /*\\n      Returns true if the given fact was previously registered in the contract.\\n    */\\n    function isValid(bytes32 fact)\\n        external view\\n        returns(bool);\\n}\\n\"},\"LibConstants.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\ncontract LibConstants {\\n    // Durations for time locked mechanisms (in seconds).\\n    // Note that it is known that miners can manipulate block timestamps\\n    // up to a deviation of a few seconds.\\n    // This mechanism should not be used for fine grained timing.\\n\\n    // The time required to cancel a deposit, in the case the operator does not move the funds\\n    // to the off-chain storage.\\n    uint256 public constant DEPOSIT_CANCEL_DELAY = 1 days;\\n\\n    // The time required to freeze the exchange, in the case the operator does not execute a\\n    // requested full withdrawal.\\n    uint256 public constant FREEZE_GRACE_PERIOD = 7 days;\\n\\n    // The time after which the exchange may be unfrozen after it froze. This should be enough time\\n    // for users to perform escape hatches to get back their funds.\\n    uint256 public constant UNFREEZE_DELAY = 365 days;\\n\\n    // Maximal number of verifiers which may co-exist.\\n    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);\\n\\n    // The time required to remove a verifier in case of a verifier upgrade.\\n    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);\\n\\n    uint256 constant MAX_VAULT_ID = 2**31 - 1;\\n    uint256 constant MAX_QUANTUM = 2**128 - 1;\\n\\n    address constant ZERO_ADDRESS = address(0x0);\\n\\n    uint256 constant K_MODULUS =\\n    0x800000000000011000000000000000000000000000000000000000000000001;\\n    uint256 constant K_BETA =\\n    0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\\n\\n    uint256 constant EXPIRATION_TIMESTAMP_BITS = 22;\\n\\n    uint256 internal constant MASK_250 =\\n    0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant MASK_240 =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant MINTABLE_ASSET_ID_FLAG = 1\\u003c\\u003c250;\\n}\\n\"},\"MainStorage.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\nimport \\\"IFactRegistry.sol\\\";\\nimport \\\"ProxyStorage.sol\\\";\\nimport \\\"Common.sol\\\";\\n/*\\n  Holds ALL the main contract state (storage) variables.\\n*/\\ncontract MainStorage is ProxyStorage {\\n\\n    IFactRegistry escapeVerifier_;\\n\\n    // Global dex-frozen flag.\\n    bool stateFrozen;                               // NOLINT: constable-states.\\n\\n    // Time when unFreeze can be successfully called (UNFREEZE_DELAY after freeze).\\n    uint256 unFreezeTime;                           // NOLINT: constable-states.\\n\\n    // Pending deposits.\\n    // A map STARK key =\\u003e asset id =\\u003e vault id =\\u003e quantized amount.\\n    mapping (uint256 =\\u003e mapping (uint256 =\\u003e mapping (uint256 =\\u003e uint256))) pendingDeposits;\\n\\n    // Cancellation requests.\\n    // A map STARK key =\\u003e asset id =\\u003e vault id =\\u003e request timestamp.\\n    mapping (uint256 =\\u003e mapping (uint256 =\\u003e mapping (uint256 =\\u003e uint256))) cancellationRequests;\\n\\n    // Pending withdrawals.\\n    // A map STARK key =\\u003e asset id =\\u003e quantized amount.\\n    mapping (uint256 =\\u003e mapping (uint256 =\\u003e uint256)) pendingWithdrawals;\\n\\n    // vault_id =\\u003e escape used boolean.\\n    mapping (uint256 =\\u003e bool) escapesUsed;\\n\\n    // Number of escapes that were performed when frozen.\\n    uint256 escapesUsedCount;                       // NOLINT: constable-states.\\n\\n    // Full withdrawal requests: stark key =\\u003e vaultId =\\u003e requestTime.\\n    // stark key =\\u003e vaultId =\\u003e requestTime.\\n    mapping (uint256 =\\u003e mapping (uint256 =\\u003e uint256)) fullWithdrawalRequests;\\n\\n    // State sequence number.\\n    uint256 sequenceNumber;                         // NOLINT: constable-states uninitialized-state.\\n\\n    // Vaults Tree Root \\u0026 Height.\\n    uint256 vaultRoot;                              // NOLINT: constable-states uninitialized-state.\\n    uint256 vaultTreeHeight;                        // NOLINT: constable-states uninitialized-state.\\n\\n    // Order Tree Root \\u0026 Height.\\n    uint256 orderRoot;                              // NOLINT: constable-states uninitialized-state.\\n    uint256 orderTreeHeight;                        // NOLINT: constable-states uninitialized-state.\\n\\n    // True if and only if the address is allowed to add tokens.\\n    mapping (address =\\u003e bool) tokenAdmins;\\n\\n    // True if and only if the address is allowed to register users.\\n    mapping (address =\\u003e bool) userAdmins;\\n\\n    // True if and only if the address is an operator (allowed to update state).\\n    mapping (address =\\u003e bool) operators;\\n\\n    // Mapping of contract ID to asset data.\\n    mapping (uint256 =\\u003e bytes) assetTypeToAssetInfo;    // NOLINT: uninitialized-state.\\n\\n    // Mapping of registered contract IDs.\\n    mapping (uint256 =\\u003e bool) registeredAssetType;      // NOLINT: uninitialized-state.\\n\\n    // Mapping from contract ID to quantum.\\n    mapping (uint256 =\\u003e uint256) assetTypeToQuantum;    // NOLINT: uninitialized-state.\\n\\n    // This mapping is no longer in use, remains for backwards compatibility.\\n    mapping (address =\\u003e uint256) starkKeys_DEPRECATED;  // NOLINT: naming-convention.\\n\\n    // Mapping from STARK public key to the Ethereum public key of its owner.\\n    mapping (uint256 =\\u003e address) ethKeys;               // NOLINT: uninitialized-state.\\n\\n    // Timelocked state transition and availability verification chain.\\n    StarkExTypes.ApprovalChainData verifiersChain;\\n    StarkExTypes.ApprovalChainData availabilityVerifiersChain;\\n\\n    // Batch id of last accepted proof.\\n    uint256 lastBatchId;                            // NOLINT: constable-states uninitialized-state.\\n\\n    // Mapping between sub-contract index to sub-contract address.\\n    mapping(uint256 =\\u003e address) subContracts;       // NOLINT: uninitialized-state.\\n}\\n\"},\"ProxyStorage.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.5.2;\\n\\nimport \\\"GovernanceStorage.sol\\\";\\n\\n/*\\n  Holds the Proxy-specific state variables.\\n  This contract is inherited by the GovernanceStorage (and indirectly by MainStorage)\\n  to prevent collision hazard.\\n*/\\ncontract ProxyStorage is GovernanceStorage {\\n\\n    // Stores the hash of the initialization vector of the added implementation.\\n    // Upon upgradeTo the implementation, the initialization vector is verified\\n    // to be identical to the one submitted when adding the implementation.\\n    mapping (address =\\u003e bytes32) internal initializationHash;\\n\\n    // The time after which we can switch to the implementation.\\n    mapping (address =\\u003e uint256) internal enabledTime;\\n\\n    // A central storage of the flags whether implementation has been initialized.\\n    // Note - it can be used flexibly enough to accommodate multiple levels of initialization\\n    // (i.e. using different key salting schemes for different initialization levels).\\n    mapping (bytes32 =\\u003e bool) internal initialized;\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LogExternalInitialize\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEPOSIT_CANCEL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FREEZE_GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_VERIFIER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNFREEZE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERIFIER_REMOVAL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ChangeVerifiersExternalInitializer","CompilerVersion":"v0.5.15+commit.6a57276f","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://925885939d633a4e48d41346dac5c5ca2c4b9fb47143a9dc758a0d21d9a2f584"}]}