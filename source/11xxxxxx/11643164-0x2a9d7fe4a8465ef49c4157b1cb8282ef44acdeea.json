{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BalancerContracts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.7.5;\\npragma abicoder v2;\\n\\nlibrary RightsManager {\\n    struct Rights {\\n        bool canPauseSwapping;\\n        bool canChangeSwapFee;\\n        bool canChangeWeights;\\n        bool canAddRemoveTokens;\\n        bool canWhitelistLPs;\\n        bool canChangeCap;\\n    }\\n}\\n\\nabstract contract ERC20 {\\n    function approve(address spender, uint256 amount) external virtual returns (bool);\\n\\n    function transfer(address dst, uint256 amt) external virtual returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external virtual returns (bool);\\n\\n    function balanceOf(address whom) external view virtual returns (uint256);\\n\\n    function allowance(address, address) external view virtual returns (uint256);\\n}\\n\\nabstract contract BalancerOwnable {\\n    function setController(address controller) external virtual;\\n}\\n\\nabstract contract AbstractPool is ERC20, BalancerOwnable {\\n    function setSwapFee(uint256 swapFee) external virtual;\\n\\n    function setPublicSwap(bool public_) external virtual;\\n\\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external virtual;\\n\\n    function joinswapExternAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        uint256 minPoolAmountOut\\n    ) external virtual returns (uint256 poolAmountOut);\\n}\\n\\nabstract contract BPool is AbstractPool {\\n    function finalize() external virtual;\\n\\n    function bind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) external virtual;\\n\\n    function rebind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) external virtual;\\n\\n    function unbind(address token) external virtual;\\n\\n    function isBound(address t) external view virtual returns (bool);\\n\\n    function getCurrentTokens() external view virtual returns (address[] memory);\\n\\n    function getFinalTokens() external view virtual returns (address[] memory);\\n\\n    function getBalance(address token) external view virtual returns (uint256);\\n}\\n\\nabstract contract BFactory {\\n    function newBPool() external virtual returns (BPool);\\n}\\n\\nabstract contract ConfigurableRightsPool is AbstractPool {\\n    struct PoolParams {\\n        string poolTokenSymbol;\\n        string poolTokenName;\\n        address[] constituentTokens;\\n        uint256[] tokenBalances;\\n        uint256[] tokenWeights;\\n        uint256 swapFee;\\n    }\\n\\n    struct CrpParams {\\n        uint256 initialSupply;\\n        uint256 minimumWeightChangeBlockPeriod;\\n        uint256 addTokenTimeLockInBlocks;\\n    }\\n\\n    function createPool(\\n        uint256 initialSupply,\\n        uint256 minimumWeightChangeBlockPeriod,\\n        uint256 addTokenTimeLockInBlocks\\n    ) external virtual;\\n\\n    function createPool(uint256 initialSupply) external virtual;\\n\\n    function setCap(uint256 newCap) external virtual;\\n\\n    function updateWeight(address token, uint256 newWeight) external virtual;\\n\\n    function updateWeightsGradually(\\n        uint256[] calldata newWeights,\\n        uint256 startBlock,\\n        uint256 endBlock\\n    ) external virtual;\\n\\n    function commitAddToken(\\n        address token,\\n        uint256 balance,\\n        uint256 denormalizedWeight\\n    ) external virtual;\\n\\n    function applyAddToken() external virtual;\\n\\n    function removeToken(address token) external virtual;\\n\\n    function whitelistLiquidityProvider(address provider) external virtual;\\n\\n    function removeWhitelistedLiquidityProvider(address provider) external virtual;\\n\\n    function bPool() external view virtual returns (BPool);\\n}\\n\\nabstract contract CRPFactory {\\n    function newCrp(\\n        address factoryAddress,\\n        ConfigurableRightsPool.PoolParams calldata params,\\n        RightsManager.Rights calldata rights\\n    ) external virtual returns (ConfigurableRightsPool);\\n}\\n\"\r\n    },\r\n    \"contracts/BalancerPoolDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.7.5;\\npragma abicoder v2;\\n\\nimport { BFactory, BPool, ConfigurableRightsPool, CRPFactory, ERC20, RightsManager } from \\\"./BalancerContracts.sol\\\";\\n\\n/**\\n * @title Balancer Pool Deployer\\n * @author Tom French\\n * @notice This contract allows single transaction deployment of Balancer pools (both standard and smart)\\n * @dev Implementation is taken from the Balancer BActions contract, adding pool ownership transfer to msg.sender\\n *      See: https://github.com/balancer-labs/bactions-proxy/blob/c4a2f6071bbe09388beae5a1256f116362f44395/contracts/BActions.sol\\n */\\ncontract BalancerPoolDeployer {\\n    function create(\\n        BFactory factory,\\n        address[] calldata tokens,\\n        uint256[] calldata balances,\\n        uint256[] calldata weights,\\n        uint256 swapFee,\\n        bool finalize\\n    ) external returns (BPool pool) {\\n        require(tokens.length == balances.length, \\\"ERR_LENGTH_MISMATCH\\\");\\n        require(tokens.length == weights.length, \\\"ERR_LENGTH_MISMATCH\\\");\\n\\n        pool = factory.newBPool();\\n        pool.setSwapFee(swapFee);\\n\\n        // Pull in initial balances of tokens and bind them to pool\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            ERC20 token = ERC20(tokens[i]);\\n            require(token.transferFrom(msg.sender, address(this), balances[i]), \\\"ERR_TRANSFER_FAILED\\\");\\n            token.approve(address(pool), balances[i]);\\n            pool.bind(tokens[i], balances[i], weights[i]);\\n        }\\n\\n        // If public (finalized) pool then send BPT tokens to msg.sender\\n        if (finalize) {\\n            pool.finalize();\\n            require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \\\"ERR_TRANSFER_FAILED\\\");\\n        } else {\\n            pool.setPublicSwap(true);\\n        }\\n\\n        // Set msg.sender to be controller of newly created pool\\n        pool.setController(msg.sender);\\n    }\\n\\n    function createSmartPool(\\n        CRPFactory factory,\\n        BFactory bFactory,\\n        ConfigurableRightsPool.PoolParams calldata poolParams,\\n        ConfigurableRightsPool.CrpParams calldata crpParams,\\n        RightsManager.Rights calldata rights\\n    ) external returns (ConfigurableRightsPool crp) {\\n        require(poolParams.constituentTokens.length == poolParams.tokenBalances.length, \\\"ERR_LENGTH_MISMATCH\\\");\\n        require(poolParams.constituentTokens.length == poolParams.tokenWeights.length, \\\"ERR_LENGTH_MISMATCH\\\");\\n\\n        // Deploy the CRP controller contract\\n        crp = factory.newCrp(address(bFactory), poolParams, rights);\\n\\n        // Pull in initial balances of tokens for CRP\\n        for (uint256 i = 0; i < poolParams.constituentTokens.length; i++) {\\n            ERC20 token = ERC20(poolParams.constituentTokens[i]);\\n            require(token.transferFrom(msg.sender, address(this), poolParams.tokenBalances[i]), \\\"ERR_TRANSFER_FAILED\\\");\\n            token.approve(address(crp), poolParams.tokenBalances[i]);\\n        }\\n\\n        // Deploy the underlying BPool\\n        crp.createPool(\\n            crpParams.initialSupply,\\n            crpParams.minimumWeightChangeBlockPeriod,\\n            crpParams.addTokenTimeLockInBlocks\\n        );\\n\\n        // Return BPT to msg.sender\\n        require(crp.transfer(msg.sender, crpParams.initialSupply), \\\"ERR_TRANSFER_FAILED\\\");\\n\\n        // Set msg.sender to be controller of newly created pool\\n        crp.setController(msg.sender);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract BFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finalize\",\"type\":\"bool\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"contract BPool\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract CRPFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"contract BFactory\",\"name\":\"bFactory\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"poolTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"poolTokenName\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"constituentTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenWeights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ConfigurableRightsPool.PoolParams\",\"name\":\"poolParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumWeightChangeBlockPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addTokenTimeLockInBlocks\",\"type\":\"uint256\"}],\"internalType\":\"struct ConfigurableRightsPool.CrpParams\",\"name\":\"crpParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"canPauseSwapping\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canChangeSwapFee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canChangeWeights\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canAddRemoveTokens\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canWhitelistLPs\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canChangeCap\",\"type\":\"bool\"}],\"internalType\":\"struct RightsManager.Rights\",\"name\":\"rights\",\"type\":\"tuple\"}],\"name\":\"createSmartPool\",\"outputs\":[{\"internalType\":\"contract ConfigurableRightsPool\",\"name\":\"crp\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BalancerPoolDeployer","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a129290296457de20efbb70c836c7e235a49abb48f4989ff41fa571891308bfc"}]}