{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/dispenser/contracts/Dispenser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity >=0.6.2;\\n\\ninterface IERC20 {\\n  function balanceOf (address account) external view returns (uint256);\\n\\n  function transfer (address to, uint256 value) external returns (bool);\\n}\\n\\ncontract Dispenser {\\n  uint256 public lastUpdate;\\n\\n  event NewDispenser (address contractAddress);\\n\\n  /// @notice Creates a new Dispenser.\\n  function create (\\n    address token,\\n    address payer,\\n    uint256 startTime,\\n    uint256 dripRateSeconds,\\n    address[] calldata payees,\\n    uint256[] calldata ratesPerDrip\\n  ) external returns (address addr) {\\n    uint256 len = payees.length;\\n    require(len > 0 && len == ratesPerDrip.length);\\n    require(dripRateSeconds > 0);\\n\\n    uint256 totalRate = 0;\\n    for (uint256 i = 0; i < len; i++) {\\n      uint256 tmp = totalRate + ratesPerDrip[i];\\n      // overflow + zero -check\\n      require(tmp > totalRate);\\n\\n      totalRate = tmp;\\n    }\\n\\n    addr = _createSimpleProxy();\\n    // setup the dispenser\\n    Dispenser(addr).setup();\\n    emit NewDispenser(addr);\\n  }\\n\\n  /// @notice Returns the metadata of this Dispenser.\\n  /// Only relevant with contracts created via the function `create()`.\\n  function getMetadata ()\\n  public view returns (\\n    address token,\\n    address payer,\\n    uint256 startTime,\\n    uint256 dripRateSeconds,\\n    address[] memory payees,\\n    uint256[] memory ratesPerDrip\\n  ) {\\n    assembly {\\n      let x := sub(calldatasize(), 32)\\n      let size := calldataload(x)\\n      let ptr := sub(x, size)\\n      calldatacopy(0, ptr, size)\\n      return(0, size)\\n    }\\n  }\\n\\n  /// @notice Setup this Dispenser.\\n  function setup (\\n  ) external {\\n    require(lastUpdate == 0);\\n\\n    (,,uint256 startTime,,,) = Dispenser(this).getMetadata();\\n    require(startTime > 0);\\n    lastUpdate = startTime;\\n  }\\n\\n  /// @notice Drips `ratesPerDrip` to each payee since the last drip\\n  /// and then returns any remaining balance to the `payer`.\\n  function drain (\\n  ) external {\\n    (\\n      address token,\\n      address payer,\\n      uint256 startTime,\\n      uint256 dripRateSeconds,\\n      address[] memory payees,\\n      uint256[] memory ratesPerDrip\\n    ) = Dispenser(this).getMetadata();\\n\\n    require(msg.sender == payer);\\n\\n    // drip any accumulated debt first\\n    _update(token, payer, startTime, dripRateSeconds, payees, ratesPerDrip);\\n\\n    IERC20 tokenContract = IERC20(token);\\n    uint256 balance = tokenContract.balanceOf(address(this));\\n\\n    // any remaining balance can go back to the payer\\n    if (balance > 0) {\\n      require(tokenContract.transfer(payer, balance));\\n    }\\n  }\\n\\n  /// @notice Drips `ratesPerDrip` for each `payees` from `token` since the last drip.\\n  /// Returns Satisfaction.\\n  function drip (\\n  ) external {\\n    (\\n      address token,\\n      address payer,\\n      uint256 startTime,\\n      uint256 dripRateSeconds,\\n      address[] memory payees,\\n      uint256[] memory ratesPerDrip\\n    ) = Dispenser(this).getMetadata();\\n\\n    _update(token, payer, startTime, dripRateSeconds, payees, ratesPerDrip);\\n  }\\n\\n  /// @notice Allows to recover `lostToken` other than the intended `token`.\\n  /// Transfers `lostToken` to the first payee.\\n  function recoverLostTokens (\\n    address lostToken\\n  ) external {\\n    (address token, , , , address[] memory payees,) = Dispenser(this).getMetadata();\\n    require(token != lostToken);\\n\\n    IERC20 tokenContract = IERC20(lostToken);\\n    uint256 balance = tokenContract.balanceOf(address(this));\\n    // lost tokens go to the first payee\\n    tokenContract.transfer(payees[0], balance);\\n  }\\n\\n  /// @dev The dripping logic.\\n  function _update (\\n    address token,\\n    address payer,\\n    uint256 startTime,\\n    uint256 dripRateSeconds,\\n    address[] memory payees,\\n    uint256[] memory ratesPerDrip\\n  ) internal {\\n    uint256 lastDrip = lastUpdate;\\n\\n    if (block.timestamp < lastDrip) {\\n      return;\\n    }\\n\\n    uint256 len = payees.length;\\n    uint256 totalRate = 0;\\n    for (uint256 i = 0; i < len; i++) {\\n      totalRate += ratesPerDrip[i];\\n    }\\n\\n    IERC20 tokenContract = IERC20(token);\\n    uint256 availableBalance = tokenContract.balanceOf(address(this));\\n    uint256 availableDrips = availableBalance / totalRate;\\n    uint256 maxDrips = (block.timestamp - lastDrip) / dripRateSeconds;\\n\\n    if (availableDrips > maxDrips) {\\n      // clamp\\n      availableDrips = maxDrips;\\n    }\\n\\n    if (availableDrips > 0) {\\n      // update\\n      lastUpdate = lastDrip + (availableDrips * dripRateSeconds);\\n\\n      // transfer to payees\\n      for (uint256 i = 0; i < len; i++) {\\n        uint256 rate = ratesPerDrip[i];\\n        uint256 amount = rate * availableDrips;\\n\\n        availableBalance -= amount;\\n        require(tokenContract.transfer(payees[i], amount));\\n      }\\n    }\\n\\n    // drip any dust to the payer\\n    if (availableBalance > 0 && availableBalance < totalRate) {\\n      // dust\\n      require(tokenContract.transfer(payer, availableBalance));\\n    }\\n  }\\n\\n  function _createSimpleProxy () internal returns (address addr) {\\n    // the following assembly code (init code + contract code) is a simple proxy.\\n    assembly {\\n      // # deploy code\\n      // PUSH1 11;\\n      // CODESIZE;\\n      // SUB;\\n      // DUP1;\\n      // PUSH1 11;\\n      // CALLDATASIZE;\\n      // CODECOPY;\\n      // CALLDATASIZE;\\n      // RETURN; (contract bytecode is everything after this return opcode)\\n      mstore(128, 0x600b380380600b363936f3000000000000000000000000000000000000000000)\\n\\n      // # contract code\\n      // RETURNDATASIZE; push `0` on stack\\n      // RETURNDATASIZE; 0 outSize\\n      // RETURNDATASIZE; 0 outOffset\\n\\n      // copy args\\n      // CALLDATASIZE;\\n      // RETURNDATASIZE;\\n      // RETURNDATASIZE;\\n      // CALLDATACOPY; (0, 0, calldatasize())\\n\\n      // PUSH1 55;\\n      // DUP1; 55, 55\\n      // CODESIZE;\\n      // SUB; size, 55\\n      // DUP1; size ,size, 55\\n      // SWAP2; 55, size, size\\n      // CALLDATASIZE;\\n      // CODECOPY; (calldatasize(), 55, size)\\n\\n      // CALLDATASIZE;\\n      // ADD; size+calldatasize\\n      // RETURNDATASIZE; 0 inOffset\\n      // PUSH20 0; zero is replaced with shl(96, address())\\n      // GAS;\\n      // DELEGATECALL; (gas, addr, 0, calldatasize() + metadata, 0, 0) delegatecall to this Dispenser contract;\\n      //\\n      // RETURNDATASIZE;\\n      // DUP3; 0\\n      // DUP1; 0\\n      // RETURNDATACOPY; (0, 0, returndatasize) - Copy everything into memory that the call returned\\n      //\\n      // # this is for either revert(0, returndatasize()) or return (0, returndatasize())\\n      // RETURNDATASIZE;\\n      // DUP3; 0\\n      //\\n      // DUP3; copy retCode from delegatecall() - 0 fail, 1 success\\n      // PUSH1 _SUCCESS_; push jumpdest of _SUCCESS_\\n      // JUMPI; jump if delegatecall returned `1`\\n      // REVERT; (0, returndatasize()) if delegatecall returned `0`\\n      // JUMPDEST _SUCCESS_;\\n      // RETURN; (0, returndatasize()) if delegatecall returned non-zero (1)\\n\\n      // the bytecode from the above statements\\n      mstore(139, 0x3d3d3d363d3d3760378038038091363936013d73000000000000000000000000)\\n      mstore(159, shl(96, address()))\\n      // 15 bytes\\n      mstore(179, 0x5af43d82803e3d8282603557fd5bf30000000000000000000000000000000000)\\n\\n      let size := sub(calldatasize(), 4)\\n      calldatacopy(194, 4, size)\\n      let ptr := add(194, size)\\n      mstore(ptr, size)\\n\\n      // The size is deploy code + contract code + calldatasize - 4 + 32.\\n      // Subtract 96 instead of 128 because the `ptr` is not increased after the last `mstore`.\\n      addr := create(0, 128, sub(ptr, 96))\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": false,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true,\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"NewDispenser\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dripRateSeconds\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"payees\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ratesPerDrip\",\"type\":\"uint256[]\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"drip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMetadata\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dripRateSeconds\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"payees\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ratesPerDrip\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostToken\",\"type\":\"address\"}],\"name\":\"recoverLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Dispenser","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"2","ConstructorArguments":"","EVMVersion":"istanbul","Library":"","LicenseType":"MPL-2.0","Proxy":"0","Implementation":"","SwarmSource":"none"}]}