{"status":"1","message":"OK","result":[{"SourceCode":"# MetaWhale BTC by DEFILABS\r\n#\r\n# Find out more about MetaWhale @ metawhale.io\r\n#\r\n# A TOKEN TESTED BY DEFI LABS @ HTTPS://DEFILABS.ETH.LINK\r\n# CREATOR: Dr. Mantis => @dr_mantis_defilabs\r\n#\r\n# Official Announcement Channel @ https://t.me/metawhale_official\r\n# But better join the fantastic community @ https://t.me/defilabs_community\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\ninterface IReserves:\r\n    def swapInactiveToWETH(amountIn: uint256, inactive: address) -> bool: nonpayable\r\n    def swapTokensForWETH(amountIn: uint256) -> bool: nonpayable\r\n    def addLiquidity(reserveBal: uint256) -> bool: nonpayable\r\n    def swapForSecondaryAndBurn() -> bool: nonpayable\r\n    def swapForTerciary() -> bool: nonpayable\r\n    def checkTerciarySize() -> bool: nonpayable\r\n    def close() -> bool: nonpayable\r\n    def baseAssetLP() -> address: view\r\n    def reserveAsset() -> address: view\r\n    def KingAsset() -> address: view\r\n    def AirdropAddress() -> address: view\r\n    def NFTFaucet() -> address: view\r\n    def MarketingFaucet() -> address: view\r\n    def devFaucet() -> address: view\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\ndecimals: public(uint256)\r\nmin_supply: public(uint256)\r\nfinal_supply: public(uint256)\r\nfinal_reserve: public(uint256)\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowances: HashMap[address, HashMap[address, uint256]]\r\nlast5pctmove: public(HashMap[address, uint256])\r\nlastIndividualTrade: public(HashMap[address, uint256])\r\nlastTrade: public(uint256)\r\npasslist: public(HashMap[address, bool])\r\ndexReserve: public(address)\r\ntotal_supply: uint256\r\ndeployer: public(address)\r\nreserve: public(address)\r\ninactive_sell: public(uint256)\r\ndividends: uint256\r\ndividend_split: uint256\r\nnft_total_dividend: public(HashMap[uint256, uint256])\r\ndev_total_dividend: public(HashMap[uint256, uint256])\r\nmarketing_total_dividend: public(HashMap[uint256, uint256])\r\nreserveManager: public(address[50])\r\nreservecounter: public(uint256)\r\nonepct: public(uint256)\r\nburn_pct: public(uint256)\r\nreserve_pct: public(uint256)\r\nreserve_threshold: public(uint256)\r\ntradingIO: public(bool)\r\nn_trades: public(uint256)\r\nswitcher: public(uint256)\r\nincentive: public(uint256)\r\nconclusiontime: public(uint256)\r\nAirdrop_Eligibility: public(HashMap[address, uint256])\r\nmanager: public(uint256)\r\nairdropExpiryDate: public(uint256)\r\nlpaddress: public(address)\r\nairdropAddress: public(address)\r\nnftyield_addy: public(address)\r\nmarketing_addy: public(address)\r\ndev_addy: public(address)\r\nreserve_asset: public(address)\r\ndexcheckpoint: public(uint256)\r\ndexstep: public(uint256)\r\ndexAllocation: public(uint256)\r\ndexRebaseCount: public(uint256)\r\n\r\n@external\r\ndef __init__(_name: String[64], _symbol: String[32], _decimals: uint256, _supply: uint256):\r\n    init_supply: uint256 = _supply * 10 ** _decimals\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.decimals = _decimals\r\n    self.balanceOf[msg.sender] = init_supply\r\n    self.total_supply = init_supply\r\n    self.min_supply = 1 * 10 ** _decimals\r\n    self.deployer = msg.sender\r\n    deciCalc: decimal = convert(10 ** _decimals, decimal)\r\n    self.onepct = convert(0.01 * deciCalc, uint256)\r\n    self.burn_pct = convert(0.0125 * deciCalc, uint256)\r\n    self.reserve_pct = convert(0.0125 * deciCalc, uint256)\r\n    self.inactive_sell = convert(0.06 * deciCalc, uint256)\r\n    self.reserve_threshold = convert(0.0035 * deciCalc, uint256)\r\n    self.passlist[msg.sender] = False\r\n    self.reserve = self.deployer\r\n    self.last5pctmove[self.deployer] = block.timestamp\r\n    self.tradingIO = True\r\n    self.switcher = 1\r\n    self.reservecounter = 0\r\n    self.dividends = 0\r\n    self.dividend_split = 0\r\n    self.dexRebaseCount = 0\r\n    self.lastTrade = block.timestamp\r\n    self.airdropExpiryDate = block.timestamp + 2600000\r\n    self.lpaddress = ZERO_ADDRESS\r\n    self.reserve_asset = ZERO_ADDRESS\r\n    self.airdropAddress = ZERO_ADDRESS\r\n    self.nftyield_addy = ZERO_ADDRESS\r\n    self.marketing_addy = ZERO_ADDRESS\r\n    self.dev_addy = ZERO_ADDRESS\r\n    self.manager = 3\r\n    self.incentive = 0\r\n    self.n_trades = 0\r\n    log Transfer(ZERO_ADDRESS, msg.sender, init_supply)\r\n\r\n@internal\r\ndef _pctCalc_minusScale(_value: uint256, _pct: uint256) -> uint256:\r\n    res: uint256 = (_value * _pct) / 10 ** self.decimals\r\n    return res\r\n\r\n@internal\r\ndef _pctCalc_pctofwhole(_portion: uint256, _ofWhole: uint256) -> uint256:\r\n    res: uint256 = (_portion*10**self.decimals)/_ofWhole\r\n    return res\r\n\r\n@view\r\n@external\r\ndef totalSupply() -> uint256:\r\n    return self.total_supply\r\n\r\n@view\r\n@external\r\ndef minSupply() -> uint256:\r\n    return self.min_supply\r\n\r\n@view\r\n@external\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    return self.allowances[_owner][_spender]\r\n\r\n@view\r\n@external\r\ndef nDIVIDEND() -> uint256:\r\n    return self.dividends\r\n\r\n@view\r\n@external\r\ndef nftDividend(_tranche: uint256) -> uint256:\r\n    return self.nft_total_dividend[_tranche]\r\n\r\n@view\r\n@external\r\ndef marketingDividend(_tranche: uint256) -> uint256:\r\n    return self.marketing_total_dividend[_tranche]\r\n\r\n@view\r\n@external\r\ndef devDividend(_tranche: uint256) -> uint256:\r\n    return self.dev_total_dividend[_tranche]\r\n\r\n@view\r\n@external\r\ndef showReserveManagers() -> address[50]:\r\n    return self.reserveManager\r\n\r\n@external\r\ndef setReserve(_address: address) -> bool:\r\n    assert self.manager == 3\r\n    assert msg.sender == self.deployer\r\n    assert _address != ZERO_ADDRESS\r\n    self.reserve = _address\r\n    return True\r\n\r\n@external\r\ndef setDEXcheckpointAndAllocation(_allocation: uint256) -> bool:\r\n    assert self.manager == 3\r\n    assert msg.sender == self.deployer\r\n    self.dexstep = self._pctCalc_minusScale(self.total_supply, self.onepct*5)\r\n    self.dexcheckpoint = self.total_supply - self.dexstep\r\n    self.dexAllocation = _allocation * 10 ** self.decimals\r\n    return True\r\n\r\n@external\r\ndef setPasslist(_address: address) -> bool:\r\n    assert self.manager >= 1\r\n    assert _address != ZERO_ADDRESS\r\n    assert msg.sender == self.deployer\r\n    self.passlist[_address] = True\r\n    return True\r\n\r\n@external\r\ndef remPasslist(_address: address) -> bool:\r\n    assert self.manager >= 1\r\n    assert _address != ZERO_ADDRESS\r\n    assert msg.sender == self.deployer\r\n    self.passlist[_address] = False\r\n    return True\r\n\r\n@internal\r\ndef _approve(_owner: address, _spender: address, _amount: uint256):\r\n    assert _owner != ZERO_ADDRESS, \"ERC20: Approve from zero addy\"\r\n    assert _spender != ZERO_ADDRESS, \"ERC20: Approve to zero addy\"\r\n    self.allowances[_owner][_spender] = _amount\r\n    log Approval(_owner, _spender, _amount)\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    self._approve(msg.sender, _spender, _value)\r\n    return True\r\n\r\n@internal\r\ndef _burn(_to: address, _value: uint256):\r\n    assert _to != ZERO_ADDRESS\r\n    self.total_supply -= _value\r\n    self.balanceOf[_to] -= _value\r\n    log Transfer(_to, ZERO_ADDRESS, _value)\r\n\r\n@internal\r\ndef _sendtoReserve(_from: address, _value: uint256):\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[self.reserve] += _value\r\n    log Transfer(_from, self.reserve, _value)\r\n\r\n@external\r\ndef inactivityBurn(_address: address) -> bool:\r\n    assert _address != ZERO_ADDRESS\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert self.passlist[_address] != True\r\n    assert block.timestamp > self.lastIndividualTrade[_address] + 10518972, \"MetaWhale: Addy is still active.\" #4 months \r\n    half: uint256 = self.balanceOf[_address]/2\r\n    self.balanceOf[_address] -= half\r\n    self.balanceOf[msg.sender] += half\r\n    log Transfer(_address, msg.sender, half)\r\n    self._burn(_address, self.balanceOf[_address])\r\n    return True\r\n\r\n@internal\r\ndef _mint(_to: address, _value: uint256) -> bool:\r\n    assert _to != ZERO_ADDRESS\r\n    self.total_supply += _value\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(ZERO_ADDRESS, _to, _value)\r\n    return True\r\n\r\n@external\r\ndef setAirdropEligibility(_eligibleAddresses: address[100], _amounts: uint256[100]) -> bool:\r\n    assert msg.sender == self.deployer\r\n    assert self.manager == 3\r\n    for x in range(0, 100):\r\n        if _eligibleAddresses[x] != ZERO_ADDRESS:\r\n            self.Airdrop_Eligibility[_eligibleAddresses[x]] = _amounts[x]*10**(self.decimals-4)\r\n        else:\r\n            break\r\n    return True\r\n\r\n@external\r\ndef managerLevelDecrease() -> bool:\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert msg.sender == self.deployer\r\n    assert self.manager >= 1\r\n    if self.manager == 2:\r\n        self.airdropExpiryDate = block.timestamp + 86400 #1day\r\n    self.manager -= 1\r\n    return True\r\n\r\n@external\r\ndef claimAirdrop() -> bool:\r\n    assert self.manager <= 1\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert self.Airdrop_Eligibility[msg.sender] > 0\r\n    assert block.timestamp < self.airdropExpiryDate\r\n    self._mint(msg.sender, self.Airdrop_Eligibility[msg.sender])\r\n    self.Airdrop_Eligibility[msg.sender] = 0\r\n    self.last5pctmove[msg.sender] = block.timestamp\r\n    self.lastIndividualTrade[msg.sender] = block.timestamp\r\n    return True\r\n\r\n@external\r\ndef setQuaternaryDividend() -> bool:\r\n    assert msg.sender != ZERO_ADDRESS\r\n    Polaris: address = 0x36F7E77A392a7B4a6fCB781aCE715ec2450F3Aca\r\n    self.reserve_asset = IReserves(Polaris).KingAsset()\r\n    self.airdropAddress = IReserves(Polaris).AirdropAddress()\r\n    self.nftyield_addy = IReserves(Polaris).NFTFaucet()\r\n    self.marketing_addy = IReserves(Polaris).MarketingFaucet()\r\n    self.dev_addy = IReserves(Polaris).devFaucet()\r\n    return True\r\n\r\n@external\r\ndef forcedSell(_address: address) -> bool:\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert _address != ZERO_ADDRESS\r\n    assert self.passlist[_address] != True\r\n    assert block.timestamp > self.last5pctmove[_address] + 3024000 #35days\r\n    amount: uint256 = self._pctCalc_minusScale(self.balanceOf[_address], self.inactive_sell-self.onepct)\r\n    callerIncentive: uint256 = self._pctCalc_minusScale(self.balanceOf[_address], self.onepct)\r\n    self._sendtoReserve(_address, amount)\r\n    IReserves(self.reserve).swapInactiveToWETH(amount, _address)\r\n    self.last5pctmove[_address] = block.timestamp\r\n    self.balanceOf[_address] -= callerIncentive\r\n    self.balanceOf[msg.sender] += callerIncentive\r\n    log Transfer(_address, msg.sender, callerIncentive)\r\n    return True\r\n\r\n@external\r\ndef setDEXreserve(_exReserve: address) -> bool:\r\n    assert msg.sender == self.deployer\r\n    assert self.manager >= 1\r\n    assert _exReserve != ZERO_ADDRESS\r\n    self.dexReserve = _exReserve\r\n    return True\r\n\r\n@external\r\ndef rebaseExchangeReserve() -> bool:\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert self.dexReserve != ZERO_ADDRESS\r\n    assert self.dexReserve != self\r\n    if self.dexRebaseCount == 19:\r\n        self._burn(self.dexReserve, self.balanceOf[self.dexReserve])\r\n    else:\r\n        if self.total_supply < self.dexcheckpoint:\r\n            amount: uint256 = self._pctCalc_minusScale(self.dexAllocation, self.onepct*5)\r\n            self._burn(self.dexReserve, amount)\r\n            self.dexcheckpoint -= self.dexstep\r\n            self.dexRebaseCount += 1\r\n        else:\r\n            pass\r\n    return True\r\n\r\n@external\r\ndef DEXchecker() -> bool:\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert self.dexReserve != ZERO_ADDRESS\r\n    assert self.dexReserve != self\r\n    amount: uint256 = self._pctCalc_minusScale(self.dexAllocation, self.onepct*5)\r\n    if self.balanceOf[self.dexReserve] > self.dexAllocation - (amount*self.dexRebaseCount):\r\n        amt2correct: uint256 = self.balanceOf[self.dexReserve] - (self.dexAllocation - amount*self.dexRebaseCount)\r\n        self._burn(self.dexReserve, amt2correct)\r\n    return True\r\n\r\n@internal\r\ndef _prepReserve() -> bool:\r\n    assert self.total_supply <= self.min_supply\r\n    assert self.tradingIO == True\r\n    weth_addy: address = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n    secundary_asset_addy: address = IReserves(self.reserve).reserveAsset()\r\n    self.final_supply = self.total_supply\r\n    self.final_reserve = ERC20(secundary_asset_addy).balanceOf(self)\r\n    _LPcontract: address = IReserves(self.reserve).baseAssetLP()\r\n    LPbal: uint256 = ERC20(_LPcontract).balanceOf(self)\r\n    ERC20(_LPcontract).transfer(self.reserve, LPbal)\r\n    wethbal: uint256 = ERC20(weth_addy).balanceOf(self)\r\n    ERC20(weth_addy).transfer(self.reserve, wethbal)\r\n    IReserves(self.reserve).close()\r\n    self.tradingIO = False\r\n    self.switcher = 1\r\n    self.conclusiontime = block.timestamp\r\n    return True\r\n\r\n@external\r\ndef finish() -> bool:\r\n    assert self.total_supply <= self.min_supply\r\n    assert self.tradingIO == True\r\n    assert self.manager == 0\r\n    self.switcher = 1\r\n    self._prepReserve()\r\n    return True\r\n\r\n@external\r\ndef inactivityFinish() -> bool:\r\n    assert self.tradingIO == True\r\n    assert self.manager == 0\r\n    if block.timestamp > self.lastTrade + 7889229: #3months\r\n        self.min_supply = self.total_supply\r\n        self.switcher = 1\r\n        self._prepReserve()\r\n    return True\r\n\r\n@external\r\ndef claimReserve() -> bool:\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert self.tradingIO == False\r\n    assert self.manager == 0\r\n    callerbalance: uint256 = self.balanceOf[msg.sender]\r\n    pctofbase: uint256 = self._pctCalc_pctofwhole(callerbalance, self.final_supply)\r\n    pctofreserve: uint256 = self._pctCalc_minusScale(self.final_reserve, pctofbase)\r\n    ERC20(IReserves(self.reserve).reserveAsset()).transfer(msg.sender, pctofreserve)\r\n    self._burn(msg.sender, callerbalance)\r\n    return True\r\n\r\n@external\r\ndef bigreset() -> bool:\r\n    assert self.conclusiontime != 0\r\n    assert block.timestamp > self.conclusiontime + 2629743 #1month\r\n    assert self.manager == 0\r\n    newsupply: uint256 = (1000000*10**self.decimals) - self.total_supply\r\n    self._mint(self.reserve, newsupply)\r\n    #self._mint(self.dexReserve, self.dexAllocation)\r\n    self.dexRebaseCount = 0\r\n    self.dexcheckpoint = self.total_supply - self.dexstep\r\n    self.min_supply = 1*10**self.decimals\r\n    self.conclusiontime = 0\r\n    self.switcher = 1\r\n    self.tradingIO = True\r\n    IReserves(self.reserve).swapTokensForWETH(self.balanceOf[self.reserve])\r\n    return True\r\n\r\n@internal\r\ndef _manageReserve(_caller: address) -> bool:\r\n    assert _caller != ZERO_ADDRESS\r\n    assert self.tradingIO == True\r\n    assert self.manager <= 2\r\n    if _caller in self.reserveManager:\r\n        pass\r\n    else:\r\n        if self.reservecounter == 50:\r\n            self.reservecounter = 0\r\n        rsv_check: uint256 = self._pctCalc_minusScale(self.total_supply, self.reserve_threshold)\r\n        if self.balanceOf[self.reserve] > rsv_check and self.n_trades > 40 and self.switcher == 1:\r\n            amountIn: uint256 = self._pctCalc_minusScale(self.balanceOf[self.reserve], self.onepct*85)\r\n            IReserves(self.reserve).swapTokensForWETH(amountIn)\r\n            self.reserveManager[self.reservecounter] = _caller\r\n            self.reservecounter += 1\r\n            self.switcher = 2\r\n            self.incentive = self._pctCalc_minusScale(amountIn, self.onepct)\r\n            self._mint(_caller, self.incentive*2)\r\n            return True\r\n        elif self.switcher == 2:\r\n            self._approve(self.reserve, 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, self.balanceOf[self.reserve]/2)\r\n            IReserves(self.reserve).addLiquidity(self.balanceOf[self.reserve]/2)\r\n            self.reserveManager[self.reservecounter] = _caller\r\n            self.reservecounter += 1\r\n            self.switcher = 3\r\n            self._mint(_caller, self.incentive*2)\r\n            return True\r\n        elif self.switcher == 3:\r\n            IReserves(self.reserve).swapForSecondaryAndBurn()\r\n            self.reserveManager[self.reservecounter] = _caller\r\n            self.reservecounter += 1\r\n            self.switcher = 4\r\n            self._mint(_caller, self.incentive*6)\r\n            return True\r\n        elif self.switcher == 4:\r\n            IReserves(self.reserve).swapForTerciary()\r\n            self.reserveManager[self.reservecounter] = _caller\r\n            self.reservecounter += 1\r\n            self.switcher = 5\r\n            self._mint(_caller, self.incentive*2)\r\n            return True\r\n        elif self.switcher == 5:\r\n            terciarySize: uint256 = ERC20(self.reserve_asset).balanceOf(self)\r\n            terciaryTS: uint256 = ERC20(self.reserve_asset).totalSupply()\r\n            terciaryThreshold: uint256 = self._pctCalc_minusScale(terciaryTS, self.onepct)\r\n            if terciarySize > terciaryThreshold:\r\n                self.dividend_split = terciarySize/20\r\n                ERC20(self.reserve_asset).transfer(self.airdropAddress, self.dividend_split*4)\r\n                self.reserveManager[self.reservecounter] = _caller\r\n                self.reservecounter += 1\r\n                self.switcher = 6\r\n                self._mint(_caller, self.incentive*2)\r\n            else:\r\n                self.reserveManager[self.reservecounter] = _caller\r\n                self.reservecounter += 1\r\n                self.switcher = 1\r\n                self._mint(_caller, self.incentive)\r\n            return True\r\n        elif self.switcher == 6:\r\n            pretxbal: uint256 = ERC20(self.reserve_asset).balanceOf(self.nftyield_addy)\r\n            ERC20(self.reserve_asset).transfer(self.nftyield_addy, self.dividend_split*14)\r\n            posttxbal: uint256 = ERC20(self.reserve_asset).balanceOf(self.nftyield_addy)\r\n            self.nft_total_dividend[self.dividends] = posttxbal - pretxbal\r\n            self._mint(_caller, self.incentive*2)\r\n            self.reserveManager[self.reservecounter] = _caller\r\n            self.reservecounter += 1\r\n            self.switcher = 7\r\n            return True\r\n        elif self.switcher == 7:\r\n            pretxbal: uint256 = ERC20(self.reserve_asset).balanceOf(self.marketing_addy)\r\n            ERC20(self.reserve_asset).transfer(self.marketing_addy, self.dividend_split)\r\n            posttxbal: uint256 = ERC20(self.reserve_asset).balanceOf(self.marketing_addy)\r\n            self.marketing_total_dividend[self.dividends] = posttxbal - pretxbal\r\n            self._mint(_caller, self.incentive*2)\r\n            self.reserveManager[self.reservecounter] = _caller\r\n            self.reservecounter += 1\r\n            self.switcher = 8\r\n            return True\r\n        elif self.switcher == 8:\r\n            pretxbal: uint256 = ERC20(self.reserve_asset).balanceOf(self.dev_addy)\r\n            ERC20(self.reserve_asset).transfer(self.dev_addy, self.dividend_split)\r\n            posttxbal: uint256 = ERC20(self.reserve_asset).balanceOf(self.dev_addy)\r\n            self.dev_total_dividend[self.dividends] = posttxbal - pretxbal\r\n            self._mint(_caller, self.incentive*2)\r\n            self.reserveManager[self.reservecounter] = _caller\r\n            self.reservecounter += 1\r\n            self.switcher = 1\r\n            self.dividends += 1\r\n            return True\r\n    return True\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256) -> bool:\r\n    assert self.balanceOf[_from] >= _value, \"Insufficient balance\"\r\n    assert _value != 0, \"No zero value transfer allowed\"\r\n    assert _to != ZERO_ADDRESS, \"Invalid To Address\"\r\n    assert _from != ZERO_ADDRESS, \"Invalid From Address\"\r\n    \r\n    if self.manager >= 2:\r\n        if _from != self.deployer:\r\n            if self.n_trades <= 1000:\r\n                assert _value <= 1000 * 10 ** self.decimals, \"Maximum amount allowed is 1000 MWBTC until the 100th transaction.\"\r\n                assert self.lastIndividualTrade[_to] != block.timestamp, \"One buy per block.\"\r\n            else:\r\n                pass\r\n        else:\r\n            self.manager = 2\r\n    else:\r\n        pass\r\n\r\n    if self.tradingIO == True:\r\n        if self.last5pctmove[_from] == 0:\r\n            self.last5pctmove[_from] = block.timestamp\r\n            self.lastIndividualTrade[_from] = block.timestamp\r\n        if self.last5pctmove[_to] == 0:\r\n            self.last5pctmove[_to] = block.timestamp\r\n            self.lastIndividualTrade[_to] = block.timestamp\r\n        if self.total_supply > self.min_supply:\r\n            burn_amt: uint256 = self._pctCalc_minusScale(_value, self.burn_pct)\r\n            reserve_amt: uint256 = self._pctCalc_minusScale(_value, self.reserve_pct)\r\n            minForActive: uint256 = self._pctCalc_minusScale(self.balanceOf[_from], self.inactive_sell)\r\n            if self.passlist[_from] == True and self.passlist[_to] == True:\r\n                self.balanceOf[_from] -= _value\r\n                self.balanceOf[_to] += _value\r\n                log Transfer(_from, _to, _value)\r\n            elif self.passlist[_from] == False and self.passlist[_to] == True:\r\n                rsv: uint256 = reserve_amt*3\r\n                val: uint256 = _value - burn_amt*2 - rsv\r\n                self.balanceOf[_from] -= val\r\n                self.balanceOf[_to] += val\r\n                log Transfer(_from, _to, val)\r\n                self._burn(_from, burn_amt*2)\r\n                self._sendtoReserve(_from, rsv)              \r\n                if _value > minForActive:\r\n                    self.last5pctmove[_from] = block.timestamp\r\n                self.lastIndividualTrade[_from] = block.timestamp\r\n            elif self.passlist[_from] == True and self.passlist[_to] == False:\r\n                self.balanceOf[_from] -= _value\r\n                self.balanceOf[_to] += _value\r\n                log Transfer(_from, _to, _value)\r\n                self._burn(_to, burn_amt)\r\n                self._sendtoReserve(_to, reserve_amt)\r\n                if _value > minForActive:\r\n                    self.last5pctmove[_to] = block.timestamp\r\n                self.lastIndividualTrade[_to] = block.timestamp\r\n            else:\r\n                val: uint256 = _value - burn_amt - reserve_amt\r\n                self._burn(_from, burn_amt)\r\n                self._sendtoReserve(_to, reserve_amt)\r\n                self.balanceOf[_from] -= val\r\n                self.balanceOf[_to] += val\r\n                log Transfer(_from, _to, val)\r\n                if _value > minForActive:\r\n                    self.last5pctmove[_from] = block.timestamp\r\n                self.lastIndividualTrade[_from] = block.timestamp\r\n            self.lastTrade = block.timestamp\r\n            self.n_trades += 1\r\n        else:\r\n            pass\r\n    else:\r\n        pass\r\n    return True\r\n\r\n@external\r\ndef manageReserve() -> bool:\r\n    self._manageReserve(msg.sender)\r\n    return True\r\n\r\n@external\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    assert self.allowances[_from][msg.sender] >= _value, \"Insufficient Allowance.\"\r\n    assert _from != ZERO_ADDRESS, \"Unable from Zero Addy\"\r\n    assert _to != ZERO_ADDRESS, \"Unable to Zero Addy\"\r\n    self._transfer(_from, _to, _value)\r\n    self._approve(_from, msg.sender, self.allowances[_from][msg.sender] - _value)\r\n    return True","ABI":"[{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"sender\",\"indexed\":true},{\"type\":\"address\",\"name\":\"receiver\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_name\"},{\"type\":\"string\",\"name\":\"_symbol\"},{\"type\":\"uint256\",\"name\":\"_decimals\"},{\"type\":\"uint256\",\"name\":\"_supply\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1211},{\"name\":\"minSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1241},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"},{\"type\":\"address\",\"name\":\"_spender\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1579},{\"name\":\"nDIVIDEND\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1301},{\"name\":\"nftDividend\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_tranche\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1446},{\"name\":\"marketingDividend\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_tranche\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1476},{\"name\":\"devDividend\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_tranche\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1506},{\"name\":\"showReserveManagers\",\"outputs\":[{\"type\":\"address[50]\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":45470},{\"name\":\"setReserve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37583},{\"name\":\"setDEXcheckpointAndAllocation\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_allocation\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":115604},{\"name\":\"setPasslist\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37762},{\"name\":\"remPasslist\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":22792},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":39569},{\"name\":\"inactivityBurn\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":155028},{\"name\":\"setAirdropEligibility\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address[100]\",\"name\":\"_eligibleAddresses\"},{\"type\":\"uint256[100]\",\"name\":\"_amounts\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":3770992},{\"name\":\"managerLevelDecrease\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":74892},{\"name\":\"claimAirdrop\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":170666},{\"name\":\"setQuaternaryDividend\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":177812},{\"name\":\"forcedSell\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":201527},{\"name\":\"setDEXreserve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_exReserve\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38040},{\"name\":\"rebaseExchangeReserve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":158913},{\"name\":\"DEXchecker\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":91322},{\"name\":\"finish\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":213108},{\"name\":\"inactivityFinish\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":248273},{\"name\":\"claimReserve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":88606},{\"name\":\"bigreset\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":270671},{\"name\":\"manageReserve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":431890},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":731975},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":773830},{\"name\":\"name\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8693},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":7746},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2351},{\"name\":\"min_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2381},{\"name\":\"final_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2411},{\"name\":\"final_reserve\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2441},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2625},{\"name\":\"last5pctmove\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2655},{\"name\":\"lastIndividualTrade\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2685},{\"name\":\"lastTrade\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2561},{\"name\":\"passlist\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2745},{\"name\":\"dexReserve\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2621},{\"name\":\"deployer\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2651},{\"name\":\"reserve\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2681},{\"name\":\"inactive_sell\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2711},{\"name\":\"nft_total_dividend\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2856},{\"name\":\"dev_total_dividend\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2886},{\"name\":\"marketing_total_dividend\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2916},{\"name\":\"reserveManager\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2940},{\"name\":\"reservecounter\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2861},{\"name\":\"onepct\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2891},{\"name\":\"burn_pct\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2921},{\"name\":\"reserve_pct\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2951},{\"name\":\"reserve_threshold\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2981},{\"name\":\"tradingIO\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3011},{\"name\":\"n_trades\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3041},{\"name\":\"switcher\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3071},{\"name\":\"incentive\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3101},{\"name\":\"conclusiontime\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3131},{\"name\":\"Airdrop_Eligibility\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3315},{\"name\":\"manager\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3191},{\"name\":\"airdropExpiryDate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3221},{\"name\":\"lpaddress\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3251},{\"name\":\"airdropAddress\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3281},{\"name\":\"nftyield_addy\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3311},{\"name\":\"marketing_addy\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3341},{\"name\":\"dev_addy\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3371},{\"name\":\"reserve_asset\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3401},{\"name\":\"dexcheckpoint\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3431},{\"name\":\"dexstep\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3461},{\"name\":\"dexAllocation\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3491},{\"name\":\"dexRebaseCount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3521}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.4","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000000d4d4554415748414c45204254430000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000056d77425443000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}