{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/5/Universe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//values = [100, 100, 100, 100, 100, 100, 100];\\n//stakedTokens = [\\\"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\\\", \\\"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\\\", \\\"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\\\", \\\"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\\\", \\\"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\\\", \\\"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\\\", \\\"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\\\"];\\npragma solidity >=0.4.0 <=0.8.0;\\n\\n// import \\\"./Oracle_Wrapper.sol\\\";\\n// Oracle_Wrapper_address = 0xB87c7158Cd83FC8f3300802AD9602B5569819f9a;\\n\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n}\\n\\ninterface Token {\\n    function transferOwnership(address newOwner) external;\\n    function stop() external;\\n    function start() external;\\n    function close() external;\\n    function decimals() external view returns(uint256);\\n    function symbol() external view returns(string memory);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    // function transfer(address to, uint256 value) external;\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function mint( address to, uint256 value ) external returns (bool);\\n    function increaseApproval(address spender, uint addedValue) external returns (bool);\\n    function decreaseApproval(address spender, uint subtractedValue) external returns (bool);\\n    function burn(uint256 _value) external;\\n    function burnTokens(address who,uint256 _value) external;\\n}\\n\\n//change the name to universe\\ncontract Universe {\\n    using SafeMath for uint;\\n    address public owner;\\n    Token token;\\n    // OracleWrapper oracle;\\n    \\n    struct UserDetail {\\n        uint256 id;\\n        address referrer;\\n        uint256 etherReceived;\\n        address[] rewardTokenAddresses;\\n        mapping (uint8 => LevelDetail) levels;\\n        mapping (address => uint256) tokenRewards;\\n    }\\n    \\n    struct LevelDetail {\\n        uint256 income;\\n        uint256 levelReferrals;\\n        mapping (address => bool) isReferral;\\n        bool activeStatus;\\n    }\\n    \\n    struct StakingTokenDetail {\\n        address tokenAddress;\\n        uint256 amountToStake;\\n    }\\n    \\n    struct RewardTokenDetail {\\n        uint256 currentBalance;\\n        uint256 lastBalance;\\n    }\\n    \\n    uint256 currentUserId;\\n    uint8 public Last_Level;\\n    uint8 taxPercentage;//check the uint type for this\\n    uint8 commission;\\n    uint8[] levelRate;\\n    uint256 missedEthers;\\n    address[] missedTokenAddresses;\\n    mapping (address => uint256) missedTokenRewards;\\n    address public taxTokenAddress;\\n    address public oracleWrapperAddress;\\n    mapping (address => UserDetail) public users;\\n    mapping (uint256 => address) public userIds;\\n    mapping (uint8 => StakingTokenDetail) public stakedTokens;\\n    mapping (address => RewardTokenDetail) public rewardTokens;\\n    \\n    event Registration(address indexed userAddress, address indexed referrerAddress, uint256 userId, uint256 referrerId);\\n    event LevelActivated(address indexed userAddress, uint8 level, address indexed tokenStaked, uint256 amount);\\n    event TokenUnstaked(address indexed userAddress, uint8 level, address indexed tokenUnstaked, uint256 amount);\\n    event LevelIncome(address indexed _from, address indexed receiver, uint8 level, uint256 amount, uint256 levelReferralCount);\\n    event IncomeWithdrawn(address indexed receiver, address indexed tokenAddress, uint256 amount);\\n    \\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner has the access\\\");\\n        _;\\n    }\\n    \\n    constructor(address ownerAddress) public {\\n        owner = ownerAddress;\\n        commission = 10;\\n        Last_Level = 7;\\n        // oracle = OracleWrapper(oracleWrapperAddress);\\n        currentUserId++;\\n        levelRate = [30, 20, 10, 10, 10, 10, 10];\\n        \\n        UserDetail memory user = UserDetail({\\n           id: currentUserId,\\n           referrer: address(0),\\n           etherReceived: uint256(0),\\n           rewardTokenAddresses: new address[](0)\\n        });\\n        \\n        users[owner] = user;\\n        userIds[currentUserId] = owner;\\n        for (uint8 i=1; i<=Last_Level; i++) {\\n            users[owner].levels[i].activeStatus = true;\\n        }\\n        currentUserId++;\\n        \\n    }\\n    \\n    receive() external payable {\\n        if(msg.data.length == 0) {\\n            if (isUserExists(tx.origin)) {\\n                levelIncome(tx.origin, users[tx.origin].referrer, address(0), msg.value, true);\\n            } else {\\n                missedEthers = missedEthers.add(msg.value);\\n            }\\n        }\\n    }\\n    \\n    function registration(address referrerAddress) external {\\n        UserDetail memory user = UserDetail({\\n           id: currentUserId,\\n           referrer: referrerAddress,\\n           etherReceived: uint256(0),\\n           rewardTokenAddresses: new address[](0)\\n        });\\n        \\n        users[msg.sender] = user;\\n        userIds[currentUserId] = msg.sender;\\n        currentUserId++;\\n        emit Registration(msg.sender, referrerAddress, users[msg.sender].id, users[referrerAddress].id);\\n    }\\n    \\n    function activateLevelByStaking(uint8 level) external {\\n        activateLevel(msg.sender, level);\\n    }\\n    \\n    function activateLevel(address userAddress, uint8 level) private {\\n        //add isUserExists check\\n        require(!users[userAddress].levels[level].activeStatus, \\\"Level Already activated\\\");\\n        require(level == 1 || users[userAddress].levels[level-1].activeStatus, \\\"Please activate immediate higher level\\\");\\n        address tokenAddress = stakedTokens[level].tokenAddress;\\n        uint256 amount = stakedTokens[level].amountToStake;\\n        \\n        Token(tokenAddress).transferFrom(userAddress, address(this), amount);\\n        rewardTokens[tokenAddress].lastBalance = rewardTokens[tokenAddress].lastBalance.add(amount); \\n        users[userAddress].levels[level].activeStatus = true;\\n        \\n        emit LevelActivated(userAddress, level, tokenAddress, amount);\\n    }\\n    \\n    function unstakeToken(uint8 level) public returns (bool) {\\n        require(users[msg.sender].levels[level].activeStatus, \\\"Level Not active yet\\\");\\n        address tokenAddress = stakedTokens[level].tokenAddress;\\n        uint256 amount = stakedTokens[level].amountToStake;\\n        \\n        Token(tokenAddress).transfer(msg.sender, amount);\\n        rewardTokens[tokenAddress].lastBalance = rewardTokens[tokenAddress].lastBalance.sub(amount);\\n        users[msg.sender].levels[level].activeStatus = false;\\n        emit TokenUnstaked(msg.sender, level, tokenAddress, amount);\\n        return true;\\n    }\\n    \\n    /**\\n    * who will send the poolRewards to the contract, user or any \\n    * admin\\n    */\\n    function poolRewards(address[] memory tokenAddressSuper, uint256[] memory totalAmount, address[] memory _from, address[] memory tokenAddress, uint256[] memory amount) external onlyOwner {\\n        for (uint256 i=0; i<tokenAddressSuper.length; i++) {\\n            require(totalAmount[i] >= Token(tokenAddressSuper[i]).balanceOf(address(this)).sub(rewardTokens[tokenAddressSuper[i]].lastBalance), \\\"Wrong Balance info\\\");\\n            rewardTokens[tokenAddressSuper[i]].lastBalance = rewardTokens[tokenAddressSuper[i]].lastBalance.add(totalAmount[i]);\\n            // oracle.addTypeOneMapping(tokenAddressSuper[i], chainlinkAddress[i]);\\n        }\\n        \\n        //update the last balance whenever user withdraws\\n        for (uint256 j=0; j<_from.length; j++) {\\n            if (isUserExists(_from[j])) {\\n                levelIncome(_from[j], users[_from[j]].referrer, tokenAddress[j], amount[j], false);\\n            } else {\\n                missedTokenRewards[tokenAddress[j]] = missedTokenRewards[tokenAddress[j]].add(amount[j]);\\n                missedTokenAddresses.push(tokenAddress[j]);\\n            }\\n        }\\n    }\\n    \\n    function levelIncome(address _from, address receiver, address tokenAddress, uint256 amount, bool isEther) private {\\n        for (uint8 i=0; i<Last_Level; i++) {\\n            uint256 income = (amount.mul(levelRate[i])).div(100);\\n            address eligibleReferrer = getEligibleReferrer(receiver, i+1);\\n            if (!isEther) {\\n                users[eligibleReferrer].tokenRewards[tokenAddress] = users[eligibleReferrer].tokenRewards[tokenAddress].add(income);\\n                users[eligibleReferrer].rewardTokenAddresses.push(tokenAddress);\\n            } else {\\n                users[eligibleReferrer].etherReceived = users[eligibleReferrer].etherReceived.add(income);\\n            }\\n            \\n            if (!users[eligibleReferrer].levels[i+1].isReferral[eligibleReferrer]) {\\n                users[eligibleReferrer].levels[i+1].isReferral[eligibleReferrer] = true;\\n                users[eligibleReferrer].levels[i+1].levelReferrals++;\\n            }\\n            \\n            emit LevelIncome(_from, receiver, i+1, income, users[eligibleReferrer].levels[i+1].levelReferrals);\\n            receiver = users[eligibleReferrer].referrer;\\n        }\\n    }\\n    \\n    function withdrawIncome() external {\\n        uint256 rewards;\\n        address rewardTokenAddress;\\n        uint256 size = users[msg.sender].rewardTokenAddresses.length;\\n        for (uint8 i=0; i<size; i++) {\\n            rewardTokenAddress = users[msg.sender].rewardTokenAddresses[i];\\n            rewards = users[msg.sender].tokenRewards[rewardTokenAddress];\\n            Token(rewardTokenAddress).transfer(msg.sender, rewards);\\n            emit IncomeWithdrawn(msg.sender, rewardTokenAddress, rewards);\\n            rewardTokens[rewardTokenAddress].lastBalance = rewardTokens[rewardTokenAddress].lastBalance.sub(rewards);\\n            users[msg.sender].tokenRewards[rewardTokenAddress] = users[msg.sender].tokenRewards[rewardTokenAddress].sub(rewards);\\n        }\\n        \\n        users[msg.sender].rewardTokenAddresses = new address[](0);\\n        \\n        uint256 etherRewards = users[msg.sender].etherReceived;\\n        if(etherRewards > address(this).balance) {\\n            etherRewards = address(this).balance;\\n        }\\n        \\n        address(uint160(msg.sender)).transfer(etherRewards);\\n        users[msg.sender].etherReceived = users[msg.sender].etherReceived.sub(etherRewards);\\n    }\\n    \\n    // function calculateTax(address userAddress) private {\\n        \\n    // }\\n    \\n    function checkLevelEligibility(address userAddress, uint8 level) private view returns (bool) {\\n        while (level != 0) {\\n            if (!users[userAddress].levels[level].activeStatus) {\\n                return false;\\n            }\\n            \\n            level--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    function getEligibleReferrer(address userAddress, uint8 level) private view returns(address) {\\n        while (userAddress != address(0)) {\\n            if (checkLevelEligibility(userAddress, level)) {\\n                return userAddress;\\n            }\\n            \\n            userAddress = users[userAddress].referrer;\\n        }\\n        \\n        return owner;\\n    }\\n    \\n    function isUserExists(address user) public view returns (bool) {\\n        return (users[user].id != 0);\\n    }\\n    \\n    function getStakingTokenDetail(uint8 level) public view returns (address, uint256, uint256) {\\n        return (\\n            stakedTokens[level].tokenAddress,\\n            stakedTokens[level].amountToStake,\\n            Token(stakedTokens[level].tokenAddress).balanceOf(address(this))\\n            );\\n    }\\n    \\n    function getUserDetail(address userAddress, address tokenAddress) public view returns (uint256, address[] memory, uint256) {\\n        return (\\n            users[userAddress].etherReceived,\\n            users[userAddress].rewardTokenAddresses,\\n            users[userAddress].tokenRewards[tokenAddress]\\n            );\\n    }\\n    \\n    function addStakingToken(address[] memory tokenAddress, uint256[] memory amount) public onlyOwner {\\n        for (uint8 i=0; i<tokenAddress.length; i++) {//change this to 7\\n            token = Token(tokenAddress[i]);\\n            stakedTokens[i+1].tokenAddress = tokenAddress[i];\\n            stakedTokens[i+1].amountToStake = amount[i].mul(10**(token.decimals()));\\n        }\\n    }\\n    \\n    function changeStakingToken(address tokenAddress, uint8 level) public onlyOwner {\\n        stakedTokens[level].tokenAddress = tokenAddress;\\n        // oracle.addTypeOneMapping(tokenAddress, chainlinkAddress);\\n    }\\n    \\n    function changeStakingAmount(uint256 amount, uint8 level) public onlyOwner {\\n        stakedTokens[level].amountToStake = amount.mul(Token(stakedTokens[level].tokenAddress).decimals());\\n    }\\n    \\n    function updateTaxToken(address tokenAddress) public onlyOwner {\\n        taxTokenAddress = tokenAddress;\\n        // oracle.addTypeOneMapping(tokenAddress, chainlinkAddress);\\n    }\\n    \\n    function updateCommission(uint8 newCommission) public onlyOwner {\\n        commission = newCommission;\\n    }\\n    \\n    function updateTaxPercentage(uint8 percentage) public onlyOwner {\\n        taxPercentage = percentage;\\n    }\\n    \\n    function updateOracleWrapperAddress(address newAddress) public onlyOwner {\\n        oracleWrapperAddress = newAddress;\\n    }\\n    \\n    function withdrawMissedRewards() public onlyOwner {\\n        if (missedEthers > address(this).balance) {\\n            missedEthers = address(this).balance;\\n        }\\n        \\n        address(uint160(owner)).transfer(missedEthers);\\n        missedEthers = 0;\\n        for (uint256 i=0; i<missedTokenAddresses.length; i++) {\\n            Token(missedTokenAddresses[i]).transfer(owner, missedTokenRewards[missedTokenAddresses[i]]);\\n            missedTokenRewards[missedTokenAddresses[i]] = 0;\\n        }\\n        \\n        missedTokenAddresses = new address[](0);\\n    }\\n    \\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\\n        assembly {\\n            addr := mload(add(bys, 20))\\n        }\\n    }\\n    \\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IncomeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenStaked\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LevelActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"levelReferralCount\",\"type\":\"uint256\"}],\"name\":\"LevelIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerId\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenUnstaked\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenUnstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Last_Level\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"activateLevelByStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"addStakingToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"changeStakingAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"changeStakingToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"getStakingTokenDetail\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getUserDetail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleWrapperAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddressSuper\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"totalAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_from\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"poolRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"registration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"stakedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToStake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"unstakeToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newCommission\",\"type\":\"uint8\"}],\"name\":\"updateCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateOracleWrapperAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"percentage\",\"type\":\"uint8\"}],\"name\":\"updateTaxPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"updateTaxToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userIds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"etherReceived\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawMissedRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Universe","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000fc06086661ce7fa4db38f03d79d356bdcfcc4239","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}