{"status":"1","message":"OK","result":[{"SourceCode":"{\"IBaseTokenData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\ninterface IBaseTokenData {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n}\"},\"IDoubleProxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity =0.8.0;\\n\\ninterface IDoubleProxy {\\n    function init(address[] calldata proxyList, address currentProxy) external;\\n\\n    function proxy() external view returns (address);\\n\\n    function setProxy() external;\\n\\n    function isProxy(address) external view returns (bool);\\n\\n    function proxiesLength() external view returns (uint256);\\n\\n    function proxies(uint256 start, uint256 offset) external view returns (address[] memory);\\n\\n    function proxies() external view returns (address[] memory);\\n}\\n\"},\"IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller\\u0027s tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``\\u0027s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``\\u0027s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\"},\"IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n//import \\\"./IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver {//is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\"},\"IERC1155Views.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\n/**\\n * @title IERC1155Views - An optional utility interface to improve the ERC-1155 Standard.\\n * @dev This interface introduces some additional capabilities for ERC-1155 Tokens.\\n */\\ninterface IERC1155Views {\\n\\n    /**\\n     * @dev Returns the total supply of the given token id\\n     * @param objectId the id of the token whose availability you want to know \\n     */\\n    function totalSupply(uint256 objectId) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the name of the given token id\\n     * @param objectId the id of the token whose name you want to know \\n     */\\n    function name(uint256 objectId) external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the given token id\\n     * @param objectId the id of the token whose symbol you want to know \\n     */\\n    function symbol(uint256 objectId) external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals of the given token id\\n     * @param objectId the id of the token whose decimals you want to know \\n     */\\n    function decimals(uint256 objectId) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the uri of the given token id\\n     * @param objectId the id of the token whose uri you want to know \\n     */\\n    function uri(uint256 objectId) external view returns (string memory);\\n}\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"IERC20Data.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"./IBaseTokenData.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Data is IBaseTokenData, IERC20 {\\n    function decimals() external view returns (uint256);\\n}\"},\"IERC20WrapperV1.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.0;\\r\\n\\r\\nimport \\\"./IEthItemModelBase.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC20-Based EthItem, version 1.\\r\\n * @dev All the wrapped ERC20 Tokens will be created following this Model.\\r\\n * The minting operation can be done by calling the appropriate method given in this interface.\\r\\n * The burning operation will send back the original wrapped ERC20 amount.\\r\\n * To initalize it, the original \\u0027init(address,string,string)\\u0027\\r\\n * function of the EthItem Token Standard will be used, but the first address parameter will be the original ERC20 Source Contract to Wrap, and NOT the ERC20Model, which is always taken by the Contract who creates the Wrapper.\\r\\n */\\r\\ninterface IERC20WrapperV1 is IEthItemModelBase {\\r\\n\\r\\n    /**\\r\\n     * @param objectId the Object Id you want to know info about\\r\\n     * @return erc20TokenAddress the wrapped ERC20 Token address corresponding to the given objectId\\r\\n     */\\r\\n    function source(uint256 objectId) external view returns (address erc20TokenAddress);\\r\\n\\r\\n     /**\\r\\n     * @param erc20TokenAddress the wrapped ERC20 Token address you want to know info about\\r\\n     * @return objectId the id in the collection which correspondes to the given erc20TokenAddress\\r\\n     */\\r\\n    function object(address erc20TokenAddress) external view returns (uint256 objectId);\\r\\n\\r\\n    /**\\r\\n     * @dev Mint operation.\\r\\n     * It inhibits and bypasses the original EthItem Token Standard \\u0027mint(uint256,string)\\u0027.\\r\\n     * The logic will execute a transferFrom call to the given erc20TokenAddress to transfer the chosed amount of tokens\\r\\n     * @param erc20TokenAddress The token address to wrap.\\r\\n     * @param amount The token amount to wrap\\r\\n     *\\r\\n     * @return objectId the id given by this collection to the given erc20TokenAddress. It can be brand new if it is the first time this collection is created. Otherwhise, the firstly-created objectId value will be used.\\r\\n     * @return wrapperAddress The address ethItemERC20Wrapper generated after the creation of the returned objectId\\r\\n     */\\r\\n    function mint(address erc20TokenAddress, uint256 amount) external returns (uint256 objectId, address wrapperAddress);\\r\\n\\r\\n    function mintETH() external payable returns (uint256 objectId, address wrapperAddress);\\r\\n}\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\"},\"IEthItemInteroperableInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC20Data.sol\\\";\\n\\ninterface IEthItemInteroperableInterface is IERC20, IERC20Data {\\n\\n    function init(uint256 id, string calldata name, string calldata symbol, uint256 decimals) external;\\n\\n    function mainInterface() external view returns (address);\\n\\n    function objectId() external view returns (uint256);\\n\\n    function mint(address owner, uint256 amount) external;\\n\\n    function burn(address owner, uint256 amount) external;\\n\\n    function permitNonce(address sender) external view returns(uint256);\\n\\n    function permit(address owner, address spender, uint value, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    function interoperableInterfaceVersion() external pure returns(uint256 ethItemInteroperableInterfaceVersion);\\n}\"},\"IEthItemMainInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./IERC1155Views.sol\\\";\\nimport \\\"./IEthItemInteroperableInterface.sol\\\";\\nimport \\\"./IBaseTokenData.sol\\\";\\n\\ninterface IEthItemMainInterface is IERC1155, IERC1155Views, IBaseTokenData {\\n\\n    function init(\\n        address interfaceModel,\\n        string calldata name,\\n        string calldata symbol\\n    ) external;\\n\\n    function mainInterfaceVersion() external pure returns(uint256 ethItemInteroperableVersion);\\n\\n    function toInteroperableInterfaceAmount(uint256 objectId, uint256 ethItemAmount) external view returns (uint256 interoperableInterfaceAmount);\\n\\n    function toMainInterfaceAmount(uint256 objectId, uint256 erc20WrapperAmount) external view returns (uint256 mainInterfaceAmount);\\n\\n    function interoperableInterfaceModel() external view returns (address, uint256);\\n\\n    function asInteroperable(uint256 objectId) external view returns (IEthItemInteroperableInterface);\\n\\n    function emitTransferSingleEvent(address sender, address from, address to, uint256 objectId, uint256 amount) external;\\n\\n    function mint(uint256 amount, string calldata partialUri)\\n        external\\n        returns (uint256, address);\\n\\n    function burn(\\n        uint256 objectId,\\n        uint256 amount\\n    ) external;\\n\\n    function burnBatch(\\n        uint256[] calldata objectIds,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    event NewItem(uint256 indexed objectId, address indexed tokenAddress);\\n    event Mint(uint256 objectId, address tokenAddress, uint256 amount);\\n}\\n\"},\"IEthItemModelBase.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.0;\\r\\n\\r\\nimport \\\"./IEthItemMainInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev This interface contains the commonn data provided by all the EthItem models\\r\\n */\\r\\ninterface IEthItemModelBase is IEthItemMainInterface {\\r\\n\\r\\n    /**\\r\\n     * @dev Contract Initialization, the caller of this method should be a Contract containing the logic to provide the EthItemERC20WrapperModel to be used to create ERC20-based objectIds\\r\\n     * @param name the chosen name for this NFT\\r\\n     * @param symbol the chosen symbol (Ticker) for this NFT\\r\\n     */\\r\\n    function init(string calldata name, string calldata symbol) external;\\r\\n\\r\\n    /**\\r\\n     * @return modelVersionNumber The version number of the Model, it should be progressive\\r\\n     */\\r\\n    function modelVersion() external pure returns(uint256 modelVersionNumber);\\r\\n\\r\\n    /**\\r\\n     * @return factoryAddress the address of the Contract which initialized this EthItem\\r\\n     */\\r\\n    function factory() external view returns(address factoryAddress);\\r\\n}\"},\"IEthItemOrchestrator.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\n\\n\\n\\ninterface IEthItemOrchestrator is IERC721Receiver, IERC1155Receiver {\\n\\n    function factories() external view returns(address[] memory);\\n\\n    function factory() external view returns(address);\\n\\n    function setFactory(address newFactory) external;\\n\\n    function knowledgeBases() external view returns(address[] memory);\\n\\n    function knowledgeBase() external view returns(address);\\n\\n    function setKnowledgeBase(address newKnowledgeBase) external;\\n\\n    function ENSController() external view returns (address);\\n\\n    function setENSController(address newEnsController) external;\\n\\n    function transferENS(address receiver, bytes32 domainNode, uint256 domainId, bool reclaimFirst, bool safeTransferFrom, bytes calldata payload) external;\\n\\n    /**\\n     * @dev GET - The DoubleProxy of the DFO linked to this Contract\\n     */\\n    function doubleProxy() external view returns (address);\\n\\n    /**\\n     * @dev SET - The DoubleProxy of the DFO linked to this Contract\\n     * It can be done only through a Proposal in the Linked DFO\\n     * @param newDoubleProxy the new DoubleProxy address\\n     */\\n    function setDoubleProxy(address newDoubleProxy) external;\\n\\n    /**\\n     * @dev SET - The address of the Smart Contract whose code will serve as a model for all the EthItemERC20Wrappers (please see the eth-item-token-standard for further information).\\n     * It can be done only through a Proposal in the Linked DFO\\n     */\\n    function setEthItemInteroperableInterfaceModel(address ethItemInteroperableInterfaceModelAddress) external;\\n\\n    /**\\n     * @dev SET - The address of the Native EthItem model.\\n     * It can be done only through a Proposal in the Linked DFO\\n     */\\n    function setNativeModel(address nativeModelAddress) external;\\n\\n    /**\\n     * @dev SET - The address of the ERC1155 NFT-Based EthItem model.\\n     * It can be done only through a Proposal in the Linked DFO\\n     */\\n    function setERC1155WrapperModel(address erc1155WrapperModelAddress) external;\\n\\n    /**\\n     * @dev SET - The address of the Smart Contract whose code will serve as a model for all the Wrapped ERC20 EthItems.\\n     * It can be done only through a Proposal in the Linked DFO\\n     */\\n    function setERC20WrapperModel(address erc20WrapperModelAddress) external;\\n\\n    /**\\n     * @dev SET - The address of the Smart Contract whose code will serve as a model for all the Wrapped ERC721 EthItems.\\n     * It can be done only through a Proposal in the Linked DFO\\n     */\\n    function setERC721WrapperModel(address erc721WrapperModelAddress) external;\\n\\n    /**\\n     * @dev SET - The element useful to calculate the Percentage fee\\n     * It can be done only through a Proposal in the Linked DFO\\n     */\\n    function setMintFeePercentage(uint256 mintFeePercentageNumerator, uint256 mintFeePercentageDenominator) external;\\n\\n    /**\\n     * @dev SET - The element useful to calculate the Percentage fee\\n     * It can be done only through a Proposal in the Linked DFO\\n     */\\n    function setBurnFeePercentage(uint256 burnFeePercentageNumerator, uint256 burnFeePercentageDenominator) external;\\n\\n    function createNative(bytes calldata modelInitPayload, string calldata ens)\\n        external\\n        returns (address newNativeAddress, bytes memory modelInitCallResponse);\\n\\n    function createERC20Wrapper(bytes calldata modelInitPayload)\\n        external\\n        returns (address newEthItemAddress, bytes memory modelInitCallResponse);\\n}\\n\\nimport \\\"./IMVDFunctionalitiesManager.sol\\\";\\nimport \\\"./IMVDProxy.sol\\\";\\nimport \\\"./IDoubleProxy.sol\\\";\\nimport \\\"./IStateHolder.sol\\\";\"},\"IEthItemOrchestratorDependantElement.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity =0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\ninterface IEthItemOrchestratorDependantElement is IERC165 {\\r\\n\\r\\n    /**\\r\\n     * @dev GET - The DoubleProxy of the DFO linked to this Contract\\r\\n     */\\r\\n    function doubleProxy() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev SET - The DoubleProxy of the DFO linked to this Contract\\r\\n     * It can be done only by the Factory controller\\r\\n     * @param newDoubleProxy the new DoubleProxy address\\r\\n     */\\r\\n    function setDoubleProxy(address newDoubleProxy) external;\\r\\n\\r\\n    function isAuthorizedOrchestrator(address operator) external view returns(bool);\\r\\n}\"},\"IKnowledgeBase.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity =0.8.0;\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"./IEthItemOrchestratorDependantElement.sol\\\";\\n\\n/**\\n * @title IKnowledgeBase\\n * @dev This contract represents the Factory Used to deploy all the EthItems, keeping track of them.\\n */\\ninterface IKnowledgeBase is IEthItemOrchestratorDependantElement {\\n\\n    function setERC20Wrapper(address newWrapper) external;\\n\\n    function erc20Wrappers() external view returns(address[] memory);\\n\\n    function erc20Wrapper() external view returns(address);\\n\\n    function setEthItem(address ethItem) external;\\n\\n    function isEthItem(address ethItem) external view returns(bool);\\n\\n    function setWrapped(address wrappedAddress, address ethItem) external;\\n\\n    function wrapper(address wrappedAddress, uint256 version) external view returns (address ethItem);\\n}\"},\"IMateriaFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\ninterface IMateriaFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n\\n    function feeTo() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setDefaultMateriaFee(uint256) external;\\n\\n    function setDefaultSwapFee(uint256) external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function setFees(\\n        address,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function owner() external view returns (address);\\n}\\n\"},\"IMateriaLiquidityRemover.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n    This interface represents a break in the symmetry and should not exist since a\\n    Materia Operator should be able to receive only ERC1155.\\n    Nevertheless for the moment che Materia liquidity pool token is not wrapped\\n    by the orchestrator, and for this reason it cannot be sent to the Materia\\n    Liquidity Remover as an ERC1155 token.\\n    In a future realease it may introduced the LP wrap and therefore this interface\\n    may become useless.\\n*/\\n\\ninterface IMateriaLiquidityRemover {\\n    function removeLiquidity(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        uint256 deadline\\n    ) external returns (uint256 amountBridge, uint256 amountToken);\\n}\\n\"},\"IMateriaOrchestrator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity 0.8.0;\\n\\nimport \\u0027./IERC1155Receiver.sol\\u0027;\\nimport \\u0027./IMateriaFactory.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IERC20WrapperV1.sol\\u0027;\\nimport \\u0027./IDoubleProxy.sol\\u0027;\\n\\ninterface IMateriaOrchestrator is IERC1155Receiver {\\n    function setDoubleProxy(address newDoubleProxy) external;\\n\\n    function setBridgeToken(address newBridgeToken) external;\\n\\n    function setErc20Wrapper(address newErc20Wrapper) external;\\n\\n    function setFactory(address newFactory) external;\\n\\n    function setEthereumObjectId(uint256 newEthereumObjectId) external;\\n\\n    function setSwapper(address _swapper) external;\\n\\n    function setLiquidityAdder(address _adder) external;\\n\\n    function setLiquidityRemover(address _remover) external;\\n\\n    function retire(address newOrchestrator) external;\\n\\n    function setFees(\\n        address token,\\n        uint256 materiaFee,\\n        uint256 swapFee\\n    ) external;\\n\\n    function setDefaultFees(uint256 materiaFee, uint256 swapFee) external;\\n\\n    function setFeeTo(address feeTo) external;\\n\\n    function getCrumbs(\\n        address token,\\n        uint256 amount,\\n        address receiver\\n    ) external;\\n\\n    function factory() external view returns (IMateriaFactory);\\n\\n    function bridgeToken() external view returns (IERC20);\\n\\n    function erc20Wrapper() external view returns (IERC20WrapperV1);\\n\\n    function ETHEREUM_OBJECT_ID() external view returns (uint256);\\n\\n    function swapper() external view returns (address);\\n\\n    function liquidityAdder() external view returns (address);\\n\\n    function liquidityRemover() external view returns (address);\\n\\n    function doubleProxy() external view returns (IDoubleProxy);\\n\\n    //Liquidity adding\\n\\n    function addLiquidity(\\n        address token,\\n        uint256 tokenAmountDesired,\\n        uint256 bridgeAmountDesired,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        uint256 bridgeAmountDesired,\\n        uint256 EthAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    //Liquidity removing\\n\\n    function removeLiquidity(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function removeLiquidityETH(\\n        uint256 liquidity,\\n        uint256 bridgeAmountMin,\\n        uint256 EthAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function removeLiquidityWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function removeLiquidityETHWithPermit(\\n        uint256 liquidity,\\n        uint256 ethAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    //Swapping\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    //Materia utilities\\n\\n    function isEthItem(address token)\\n        external\\n        view\\n        returns (\\n            address collection,\\n            bool ethItem,\\n            uint256 itemId\\n        );\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] memory path) external view returns (uint256[] memory amounts);\\n}\\n\"},\"IMateriaPair.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\ninterface IMateriaPair {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(\\n        address,\\n        address,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function setMateriaFee(uint256 _materiaFee) external;\\n\\n    function setSwapFee(uint256 _swapFee) external;\\n\\n    function materiaFee() external view returns (uint256);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function renounceOwnership() external;\\n\\n    function transferOwnership(address newOwner) external;\\n}\\n\"},\"IMVDFunctionalitiesManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity =0.8.0;\\n\\ninterface IMVDFunctionalitiesManager {\\n    function getProxy() external view returns (address);\\n\\n    function setProxy() external;\\n\\n    function init(\\n        address sourceLocation,\\n        uint256 getMinimumBlockNumberSourceLocationId,\\n        address getMinimumBlockNumberFunctionalityAddress,\\n        uint256 getEmergencyMinimumBlockNumberSourceLocationId,\\n        address getEmergencyMinimumBlockNumberFunctionalityAddress,\\n        uint256 getEmergencySurveyStakingSourceLocationId,\\n        address getEmergencySurveyStakingFunctionalityAddress,\\n        uint256 checkVoteResultSourceLocationId,\\n        address checkVoteResultFunctionalityAddress\\n    ) external;\\n\\n    function addFunctionality(\\n        string calldata codeName,\\n        address sourceLocation,\\n        uint256 sourceLocationId,\\n        address location,\\n        bool submitable,\\n        string calldata methodSignature,\\n        string calldata returnAbiParametersArray,\\n        bool isInternal,\\n        bool needsSender\\n    ) external;\\n\\n    function addFunctionality(\\n        string calldata codeName,\\n        address sourceLocation,\\n        uint256 sourceLocationId,\\n        address location,\\n        bool submitable,\\n        string calldata methodSignature,\\n        string calldata returnAbiParametersArray,\\n        bool isInternal,\\n        bool needsSender,\\n        uint256 position\\n    ) external;\\n\\n    function removeFunctionality(string calldata codeName) external returns (bool removed, uint256 position);\\n\\n    function isValidFunctionality(address functionality) external view returns (bool);\\n\\n    function isAuthorizedFunctionality(address functionality) external view returns (bool);\\n\\n    function setCallingContext(address location) external returns (bool);\\n\\n    function clearCallingContext() external;\\n\\n    function getFunctionalityData(string calldata codeName)\\n        external\\n        view\\n        returns (\\n            address,\\n            uint256,\\n            string memory,\\n            address,\\n            uint256\\n        );\\n\\n    function hasFunctionality(string calldata codeName) external view returns (bool);\\n\\n    function getFunctionalitiesAmount() external view returns (uint256);\\n\\n    function functionalitiesToJSON() external view returns (string memory);\\n\\n    function functionalitiesToJSON(uint256 start, uint256 l) external view returns (string memory functionsJSONArray);\\n\\n    function functionalityNames() external view returns (string memory);\\n\\n    function functionalityNames(uint256 start, uint256 l) external view returns (string memory functionsJSONArray);\\n\\n    function functionalityToJSON(string calldata codeName) external view returns (string memory);\\n\\n    function preConditionCheck(\\n        string calldata codeName,\\n        bytes calldata data,\\n        uint8 submitable,\\n        address sender,\\n        uint256 value\\n    ) external view returns (address location, bytes memory payload);\\n\\n    function setupFunctionality(address proposalAddress) external returns (bool);\\n}\\n\"},\"IMVDProxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity =0.8.0;\\n\\ninterface IMVDProxy {\\n    function init(\\n        address votingTokenAddress,\\n        address functionalityProposalManagerAddress,\\n        address stateHolderAddress,\\n        address functionalityModelsManagerAddress,\\n        address functionalitiesManagerAddress,\\n        address walletAddress,\\n        address doubleProxyAddress\\n    ) external;\\n\\n    function getDelegates() external view returns (address[] memory);\\n\\n    function getToken() external view returns (address);\\n\\n    function getMVDFunctionalityProposalManagerAddress() external view returns (address);\\n\\n    function getStateHolderAddress() external view returns (address);\\n\\n    function getMVDFunctionalityModelsManagerAddress() external view returns (address);\\n\\n    function getMVDFunctionalitiesManagerAddress() external view returns (address);\\n\\n    function getMVDWalletAddress() external view returns (address);\\n\\n    function getDoubleProxyAddress() external view returns (address);\\n\\n    function setDelegate(uint256 position, address newAddress) external returns (address oldAddress);\\n\\n    function changeProxy(address newAddress, bytes calldata initPayload) external;\\n\\n    function isValidProposal(address proposal) external view returns (bool);\\n\\n    function isAuthorizedFunctionality(address functionality) external view returns (bool);\\n\\n    function newProposal(\\n        string calldata codeName,\\n        bool emergency,\\n        address sourceLocation,\\n        uint256 sourceLocationId,\\n        address location,\\n        bool submitable,\\n        string calldata methodSignature,\\n        string calldata returnParametersJSONArray,\\n        bool isInternal,\\n        bool needsSender,\\n        string calldata replaces\\n    ) external returns (address proposalAddress);\\n\\n    function startProposal(address proposalAddress) external;\\n\\n    function disableProposal(address proposalAddress) external;\\n\\n    function transfer(\\n        address receiver,\\n        uint256 value,\\n        address token\\n    ) external;\\n\\n    function transfer721(\\n        address receiver,\\n        uint256 tokenId,\\n        bytes calldata data,\\n        bool safe,\\n        address token\\n    ) external;\\n\\n    function flushToWallet(\\n        address tokenAddress,\\n        bool is721,\\n        uint256 tokenId\\n    ) external;\\n\\n    function setProposal() external;\\n\\n    function read(string calldata codeName, bytes calldata data) external view returns (bytes memory returnData);\\n\\n    function submit(string calldata codeName, bytes calldata data) external payable returns (bytes memory returnData);\\n\\n    function callFromManager(address location, bytes calldata payload) external returns (bool, bytes memory);\\n\\n    function emitFromManager(\\n        string calldata codeName,\\n        address proposal,\\n        string calldata replaced,\\n        address replacedSourceLocation,\\n        uint256 replacedSourceLocationId,\\n        address location,\\n        bool submitable,\\n        string calldata methodSignature,\\n        bool isInternal,\\n        bool needsSender,\\n        address proposalAddress\\n    ) external;\\n\\n    function emitEvent(\\n        string calldata eventSignature,\\n        bytes calldata firstIndex,\\n        bytes calldata secondIndex,\\n        bytes calldata data\\n    ) external;\\n\\n    event ProxyChanged(address indexed newAddress);\\n    event DelegateChanged(uint256 position, address indexed oldAddress, address indexed newAddress);\\n\\n    event Proposal(address proposal);\\n    event ProposalCheck(address indexed proposal);\\n    event ProposalSet(address indexed proposal, bool success);\\n    event FunctionalitySet(\\n        string codeName,\\n        address indexed proposal,\\n        string replaced,\\n        address replacedSourceLocation,\\n        uint256 replacedSourceLocationId,\\n        address indexed replacedLocation,\\n        bool replacedWasSubmitable,\\n        string replacedMethodSignature,\\n        bool replacedWasInternal,\\n        bool replacedNeededSender,\\n        address indexed replacedProposal\\n    );\\n\\n    event Event(string indexed key, bytes32 indexed firstIndex, bytes32 indexed secondIndex, bytes data);\\n}\\n\"},\"IStateHolder.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity =0.8.0;\\n\\ninterface IStateHolder {\\n    function init() external;\\n\\n    function getProxy() external view returns (address);\\n\\n    function setProxy() external;\\n\\n    function toJSON() external view returns (string memory);\\n\\n    function toJSON(uint256 start, uint256 l) external view returns (string memory);\\n\\n    function getStateSize() external view returns (uint256);\\n\\n    function exists(string calldata varName) external view returns (bool);\\n\\n    function getDataType(string calldata varName) external view returns (string memory dataType);\\n\\n    function clear(string calldata varName) external returns (string memory oldDataType, bytes memory oldVal);\\n\\n    function setBytes(string calldata varName, bytes calldata val) external returns (bytes memory);\\n\\n    function getBytes(string calldata varName) external view returns (bytes memory);\\n\\n    function setString(string calldata varName, string calldata val) external returns (string memory);\\n\\n    function getString(string calldata varName) external view returns (string memory);\\n\\n    function setBool(string calldata varName, bool val) external returns (bool);\\n\\n    function getBool(string calldata varName) external view returns (bool);\\n\\n    function getUint256(string calldata varName) external view returns (uint256);\\n\\n    function setUint256(string calldata varName, uint256 val) external returns (uint256);\\n\\n    function getAddress(string calldata varName) external view returns (address);\\n\\n    function setAddress(string calldata varName, address val) external returns (address);\\n}\\n\"},\"IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"},\"MateriaLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity \\u003e=0.5.0;\\n\\nimport \\u0027./IMateriaPair.sol\\u0027;\\nimport \\u0027./IMateriaFactory.sol\\u0027;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\nlibrary MateriaLibrary {\\n    using SafeMath for uint256;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, \\u0027MateriaLibrary: IDENTICAL_ADDRESSES\\u0027);\\n        (token0, token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), \\u0027MateriaLibrary: ZERO_ADDRESS\\u0027);\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex\\u0027ff\\u0027,\\n                            factory,\\n                            keccak256(abi.encodePacked(token0, token1)),\\n                            hex\\u00271974917c1e01e6369c1b45f631eae6a71d24cb5108c460cc7f0b1c608b3a7c94\\u0027 // init code hash\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1, ) = IMateriaPair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_AMOUNT\\u0027);\\n        require(reserveA \\u003e 0 \\u0026\\u0026 reserveB \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountOut) {\\n        require(amountIn \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n        require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        uint256 amountInWithFee = amountIn.mul(997);\\n        uint256 numerator = amountInWithFee.mul(reserveOut);\\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountIn) {\\n        require(amountOut \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(\\n        address factory,\\n        uint256 amountIn,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length \\u003e= 2, \\u0027MateriaLibrary: INVALID_PATH\\u0027);\\n        amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint256 i; i \\u003c path.length - 1; i++) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(\\n        address factory,\\n        uint256 amountOut,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length \\u003e= 2, \\u0027MateriaLibrary: INVALID_PATH\\u0027);\\n        amounts = new uint256[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint256 i = path.length - 1; i \\u003e 0; i--) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\"},\"MateriaLiquidityAdder.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\npragma solidity 0.8.0;\\n\\nimport \\u0027./MateriaOperator.sol\\u0027;\\nimport \\u0027./IMateriaOrchestrator.sol\\u0027;\\nimport \\u0027./IMateriaFactory.sol\\u0027;\\nimport \\u0027./IMateriaPair.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IERC20WrapperV1.sol\\u0027;\\n\\nimport \\u0027./MateriaLibrary.sol\\u0027;\\nimport \\u0027./TransferHelper.sol\\u0027;\\n\\ncontract MateriaLiquidityAdder is MateriaOperator {\\n    function _addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) private returns (uint256 amountA, uint256 amountB) {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n\\n        // create the pair if it doesn\\u0027t exist yet\\n        if (IMateriaFactory(factory).getPair(tokenA, tokenB) == address(0)) {\\n            IMateriaFactory(factory).createPair(tokenA, tokenB);\\n        }\\n        (uint256 reserveA, uint256 reserveB) = MateriaLibrary.getReserves(address(factory), tokenA, tokenB);\\n        if (reserveA == 0 \\u0026\\u0026 reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else {\\n            uint256 amountBOptimal = MateriaLibrary.quote(amountADesired, reserveA, reserveB);\\n            if (amountBOptimal \\u003c= amountBDesired) {\\n                require(amountBOptimal \\u003e= amountBMin, \\u0027INSUFFICIENT_B_AMOUNT\\u0027);\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint256 amountAOptimal = MateriaLibrary.quote(amountBDesired, reserveB, reserveA);\\n                assert(amountAOptimal \\u003c= amountADesired);\\n                require(amountAOptimal \\u003e= amountAMin, \\u0027INSUFFICIENT_A_AMOUNT\\u0027);\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n\\n    function _doAddLiquidity(\\n        address token,\\n        address bridgeToken,\\n        uint256 tokenAmountDesired,\\n        uint256 bridgeAmountDesired,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to\\n    )\\n        private\\n        returns (\\n            uint256 tokenAmount,\\n            uint256 bridgeAmount,\\n            uint256 liquidity\\n        )\\n    {\\n        (tokenAmount, bridgeAmount) = _addLiquidity(\\n            token,\\n            bridgeToken,\\n            tokenAmountDesired,\\n            bridgeAmountDesired,\\n            tokenAmountMin,\\n            bridgeAmountMin\\n        );\\n\\n        address pair =\\n            MateriaLibrary.pairFor(address(IMateriaOrchestrator(address(this)).factory()), token, bridgeToken);\\n        TransferHelper.safeTransfer(token, pair, tokenAmount);\\n        TransferHelper.safeTransferFrom(bridgeToken, msg.sender, pair, bridgeAmount);\\n        liquidity = IMateriaPair(pair).mint(to);\\n    }\\n\\n    function addLiquidity(\\n        address token,\\n        uint256 tokenAmountDesired,\\n        uint256 bridgeAmountDesired,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) public ensure(deadline) {\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        address interoperable;\\n\\n        tokenAmountMin = _adjustAmount(token, tokenAmountMin);\\n\\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), tokenAmountDesired);\\n        (interoperable, tokenAmountDesired) = _wrapErc20(token, tokenAmountDesired, erc20Wrapper);\\n\\n        (uint256 tokenAmount, , ) =\\n            _doAddLiquidity(\\n                interoperable,\\n                address(IMateriaOrchestrator(address(this)).bridgeToken()),\\n                tokenAmountDesired,\\n                bridgeAmountDesired,\\n                tokenAmountMin,\\n                bridgeAmountMin,\\n                to\\n            );\\n\\n        uint256 dust = tokenAmountDesired - tokenAmount;\\n        if (dust \\u003e 0) _unwrapErc20(IERC20WrapperV1(erc20Wrapper).object(token), token, dust, erc20Wrapper, msg.sender);\\n    }\\n\\n    function addLiquidityETH(\\n        uint256 bridgeAmountDesired,\\n        uint256 ethAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        public\\n        payable\\n        ensure(deadline)\\n        returns (\\n            uint256 ethAmount,\\n            uint256 bridgeAmount,\\n            uint256 liquidity\\n        )\\n    {\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n\\n        address ieth =\\n            address(\\n                IERC20WrapperV1(erc20Wrapper).asInteroperable(\\n                    uint256(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID())\\n                )\\n            );\\n\\n        (ethAmount, bridgeAmount) = _addLiquidity(\\n            ieth,\\n            bridgeToken,\\n            msg.value,\\n            bridgeAmountDesired,\\n            ethAmountMin,\\n            bridgeAmountMin\\n        );\\n\\n        _wrapEth(ethAmount, erc20Wrapper);\\n\\n        address pair =\\n            MateriaLibrary.pairFor(address(IMateriaOrchestrator(address(this)).factory()), ieth, bridgeToken);\\n        TransferHelper.safeTransfer(ieth, pair, ethAmount);\\n        TransferHelper.safeTransferFrom(bridgeToken, msg.sender, pair, bridgeAmount);\\n        liquidity = IMateriaPair(pair).mint(to);\\n\\n        uint256 dust;\\n        if ((dust = msg.value - ethAmount) \\u003e 0) TransferHelper.safeTransferETH(msg.sender, dust);\\n    }\\n\\n    function addLiquidityItem(\\n        uint256 itemId,\\n        uint256 value,\\n        address from,\\n        bytes memory payload\\n    ) private returns (uint256 itemAmount, uint256 bridgeAmount) {\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n\\n        uint256 bridgeAmountDesired;\\n        address to;\\n        uint256 deadline;\\n        address token;\\n\\n        (bridgeAmountDesired, itemAmount, bridgeAmount, to, deadline) = abi.decode(\\n            payload,\\n            (uint256, uint256, uint256, address, uint256)\\n        );\\n\\n        _ensure(deadline);\\n\\n        (itemAmount, bridgeAmount) = _addLiquidity(\\n            (token = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId))),\\n            bridgeToken,\\n            value,\\n            bridgeAmountDesired,\\n            itemAmount,\\n            bridgeAmount\\n        );\\n\\n        address pair =\\n            MateriaLibrary.pairFor(address(IMateriaOrchestrator(address(this)).factory()), token, bridgeToken);\\n        TransferHelper.safeTransfer(token, pair, itemAmount);\\n        TransferHelper.safeTransferFrom(bridgeToken, from, pair, bridgeAmount);\\n        IMateriaPair(pair).mint(to);\\n\\n        // value now is for the possible dust\\n        if ((value = value - itemAmount) \\u003e 0) TransferHelper.safeTransfer(token, from, value);\\n        if ((value = bridgeAmountDesired - bridgeAmount) \\u003e 0) TransferHelper.safeTransfer(bridgeToken, from, value);\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) public override returns (bytes4) {\\n        uint256 operation;\\n        bytes memory payload;\\n\\n        (operation, payload) = abi.decode(data, (uint256, bytes));\\n\\n        if (operation == 1) {\\n            addLiquidityItem(id, value, from, payload);\\n        } else revert();\\n\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) public pure override returns (bytes4) {\\n        revert();\\n    }\\n\\n    function supportsInterface(bytes4) public pure override returns (bool) {\\n        return false;\\n    }\\n}\\n\"},\"MateriaLiquidityMathLibrary.sol\":{\"content\":\"pragma solidity 0.8.0;\\n\\nimport \\u0027./IMateriaPair.sol\\u0027;\\nimport \\u0027./IMateriaFactory.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./Math.sol\\u0027;\\nimport \\u0027./MateriaLibrary.sol\\u0027;\\n\\n// library containing some math for dealing with the liquidity shares of a pair, e.g. computing their exact value\\n// in terms of the underlying tokens\\nlibrary MateriaLiquidityMathLibrary {\\n    using SafeMath for uint256;\\n\\n    // computes the direction and magnitude of the profit-maximizing trade\\n    function computeProfitMaximizingTrade(\\n        uint256 truePriceTokenA,\\n        uint256 truePriceTokenB,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) pure internal returns (bool aToB, uint256 amountIn) {\\n        aToB = SafeMath.mul(reserveA, truePriceTokenB)/reserveB \\u003c truePriceTokenA;\\n\\n        uint256 invariant = reserveA.mul(reserveB);\\n\\n        uint256 leftSide = Math.sqrt(\\n            SafeMath.mul(\\n                invariant.mul(1000),\\n                aToB ? truePriceTokenA : truePriceTokenB)/\\n                (aToB ? truePriceTokenB : truePriceTokenA).mul(997)\\n            \\n        );\\n        uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\\n\\n        if (leftSide \\u003c rightSide) return (false, 0);\\n\\n        // compute the amount that must be sent to move the price to the profit-maximizing price\\n        amountIn = leftSide.sub(rightSide);\\n    }\\n\\n    // gets the reserves after an arbitrage moves the price to the profit-maximizing ratio given an externally observed true price\\n    function getReservesAfterArbitrage(\\n        address factory,\\n        address tokenA,\\n        address tokenB,\\n        uint256 truePriceTokenA,\\n        uint256 truePriceTokenB\\n    ) view internal returns (uint256 reserveA, uint256 reserveB) {\\n        // first get reserves before the swap\\n        (reserveA, reserveB) = MateriaLibrary.getReserves(factory, tokenA, tokenB);\\n\\n        require(reserveA \\u003e 0 \\u0026\\u0026 reserveB \\u003e 0, \\u0027MateriaArbitrageLibrary: ZERO_PAIR_RESERVES\\u0027);\\n\\n        // then compute how much to swap to arb to the true price\\n        (bool aToB, uint256 amountIn) = computeProfitMaximizingTrade(truePriceTokenA, truePriceTokenB, reserveA, reserveB);\\n\\n        if (amountIn == 0) {\\n            return (reserveA, reserveB);\\n        }\\n\\n        // now affect the trade to the reserves\\n        if (aToB) {\\n            uint amountOut = MateriaLibrary.getAmountOut(amountIn, reserveA, reserveB);\\n            reserveA += amountIn;\\n            reserveB -= amountOut;\\n        } else {\\n            uint amountOut = MateriaLibrary.getAmountOut(amountIn, reserveB, reserveA);\\n            reserveB += amountIn;\\n            reserveA -= amountOut;\\n        }\\n    }\\n\\n    // computes liquidity value given all the parameters of the pair\\n    function computeLiquidityValue(\\n        uint256 reservesA,\\n        uint256 reservesB,\\n        uint256 totalSupply,\\n        uint256 liquidityAmount,\\n        bool feeOn,\\n        uint kLast\\n    ) internal pure returns (uint256 tokenAAmount, uint256 tokenBAmount) {\\n        if (feeOn \\u0026\\u0026 kLast \\u003e 0) {\\n            uint rootK = Math.sqrt(reservesA.mul(reservesB));\\n            uint rootKLast = Math.sqrt(kLast);\\n            if (rootK \\u003e rootKLast) {\\n                uint numerator1 = totalSupply;\\n                uint numerator2 = rootK.sub(rootKLast);\\n                uint denominator = rootK.mul(5).add(rootKLast);\\n                uint feeLiquidity = SafeMath.mul(numerator1, numerator2)/ denominator;\\n                totalSupply = totalSupply.add(feeLiquidity);\\n            }\\n        }\\n        return (reservesA.mul(liquidityAmount) / totalSupply, reservesB.mul(liquidityAmount) / totalSupply);\\n    }\\n\\n    // get all current parameters from the pair and compute value of a liquidity amount\\n    // **note this is subject to manipulation, e.g. sandwich attacks**. prefer passing a manipulation resistant price to\\n    // #getLiquidityValueAfterArbitrageToPrice\\n    function getLiquidityValue(\\n        address factory,\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidityAmount\\n    ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\\n        (uint256 reservesA, uint256 reservesB) = MateriaLibrary.getReserves(factory, tokenA, tokenB);\\n        IMateriaPair pair = IMateriaPair(MateriaLibrary.pairFor(factory, tokenA, tokenB));\\n        bool feeOn = IMateriaFactory(factory).feeTo() != address(0);\\n        uint kLast = feeOn ? pair.kLast() : 0;\\n        uint totalSupply = pair.totalSupply();\\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\\n    }\\n\\n    // given two tokens, tokenA and tokenB, and their \\\"true price\\\", i.e. the observed ratio of value of token A to token B,\\n    // and a liquidity amount, returns the value of the liquidity in terms of tokenA and tokenB\\n    function getLiquidityValueAfterArbitrageToPrice(\\n        address factory,\\n        address tokenA,\\n        address tokenB,\\n        uint256 truePriceTokenA,\\n        uint256 truePriceTokenB,\\n        uint256 liquidityAmount\\n    ) internal view returns (\\n        uint256 tokenAAmount,\\n        uint256 tokenBAmount\\n    ) {\\n        bool feeOn = IMateriaFactory(factory).feeTo() != address(0);\\n        IMateriaPair pair = IMateriaPair(MateriaLibrary.pairFor(factory, tokenA, tokenB));\\n        uint kLast = feeOn ? pair.kLast() : 0;\\n        uint totalSupply = pair.totalSupply();\\n\\n        // this also checks that totalSupply \\u003e 0\\n        require(totalSupply \\u003e= liquidityAmount \\u0026\\u0026 liquidityAmount \\u003e 0, \\u0027ComputeLiquidityValue: LIQUIDITY_AMOUNT\\u0027);\\n\\n        (uint reservesA, uint reservesB) = getReservesAfterArbitrage(factory, tokenA, tokenB, truePriceTokenA, truePriceTokenB);\\n\\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\\n    }\\n}\\n\"},\"MateriaLiquidityRemover.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\npragma solidity 0.8.0;\\n\\nimport \\u0027./MateriaOperator.sol\\u0027;\\nimport \\u0027./IMateriaOrchestrator.sol\\u0027;\\nimport \\u0027./IMateriaPair.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IERC20WrapperV1.sol\\u0027;\\n\\nimport \\u0027./MateriaLibrary.sol\\u0027;\\n\\ncontract MateriaLiquidityRemover is MateriaOperator {\\n    function removeLiquidity(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) public ensure(deadline) returns (uint256 amountBridge, uint256 amountToken) {\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n        address pair;\\n\\n        {\\n            (bool ethItem, uint256 itemId) = _isEthItem(token, erc20Wrapper);\\n            token = ethItem ? token : address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\\n            pair = MateriaLibrary.pairFor(address(IMateriaOrchestrator(address(this)).factory()), token, bridgeToken);\\n        }\\n\\n        IMateriaPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (uint256 amount0, uint256 amount1) = IMateriaPair(pair).burn(to);\\n        (address token0, ) = MateriaLibrary.sortTokens(token, bridgeToken);\\n        (amountBridge, amountToken) = token0 == address(bridgeToken) ? (amount0, amount1) : (amount1, amount0);\\n        require(amountBridge \\u003e= bridgeAmountMin, \\u0027INSUFFICIENT_BRIDGE_AMOUNT\\u0027);\\n        require(amountToken \\u003e= tokenAmountMin, \\u0027INSUFFICIENT_TOKEN_AMOUNT\\u0027);\\n    }\\n\\n    function removeLiquidityETH(\\n        uint256 liquidity,\\n        uint256 bridgeAmountMin,\\n        uint256 ethAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) public ensure(deadline) returns (uint256 amountBridge, uint256 amountEth) {\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n        address ieth = _tokenToInteroperable(address(0), erc20Wrapper);\\n\\n        address pair =\\n            MateriaLibrary.pairFor(address(IMateriaOrchestrator(address(this)).factory()), ieth, bridgeToken);\\n\\n        IMateriaPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (uint256 amount0, uint256 amount1) = IMateriaPair(pair).burn(address(this));\\n        (address token0, ) = MateriaLibrary.sortTokens(ieth, address(bridgeToken));\\n        (amountBridge, amountEth) = token0 == address(bridgeToken) ? (amount0, amount1) : (amount1, amount0);\\n        require(amountBridge \\u003e= bridgeAmountMin, \\u0027INSUFFICIENT_BRIDGE_AMOUNT\\u0027);\\n        require(amountEth \\u003e= ethAmountMin, \\u0027INSUFFICIENT_TOKEN_AMOUNT\\u0027);\\n        _unwrapEth(uint256(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID()), amountEth, erc20Wrapper, to);\\n    }\\n\\n    function removeLiquidityWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n\\n        address pair = MateriaLibrary.pairFor(factory, bridgeToken, token);\\n        uint256 value = approveMax ? type(uint256).max : liquidity;\\n        IMateriaPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        removeLiquidity(token, liquidity, tokenAmountMin, bridgeAmountMin, to, deadline);\\n    }\\n\\n    function removeLiquidityETHWithPermit(\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n\\n        address pair = MateriaLibrary.pairFor(factory, bridgeToken, _tokenToInteroperable(address(0), erc20Wrapper));\\n        uint256 value = approveMax ? type(uint256).max : liquidity;\\n        IMateriaPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        removeLiquidityETH(liquidity, bridgeAmountMin, tokenAmountMin, to, deadline);\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) public pure override returns (bytes4) {\\n        revert();\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) public pure override returns (bytes4) {\\n        revert();\\n    }\\n\\n    function supportsInterface(bytes4) public pure override returns (bool) {\\n        return false;\\n    }\\n}\\n\"},\"MateriaOperator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\npragma solidity ^0.8.0;\\n\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IMateriaOrchestrator.sol\\u0027;\\nimport \\u0027./TransferHelper.sol\\u0027;\\nimport \\u0027./IEthItemInteroperableInterface.sol\\u0027;\\nimport \\u0027./IERC20WrapperV1.sol\\u0027;\\n\\nabstract contract MateriaOperator is IERC1155Receiver, IERC165 {\\n    modifier ensure(uint256 deadline) {\\n        require(deadline \\u003e= block.timestamp, \\u0027Materia: Expired\\u0027);\\n        _;\\n    }\\n\\n    function _ensure(uint256 deadline) internal ensure(deadline) {}\\n\\n    function _isEthItem(address token, address wrapper) internal view returns (bool ethItem, uint256 id) {\\n        try IEthItemInteroperableInterface(token).mainInterface() {\\n            ethItem = true;\\n        } catch {\\n            ethItem = false;\\n            id = IERC20WrapperV1(wrapper).object(token);\\n        }\\n    }\\n\\n    function _wrapErc20(\\n        address token,\\n        uint256 amount,\\n        address wrapper\\n    ) internal returns (address interoperable, uint256 newAmount) {\\n        if (IERC20(token).allowance(address(this), wrapper) \\u003c amount) {\\n            IERC20(token).approve(wrapper, type(uint256).max);\\n        }\\n\\n        (uint256 id, ) = IERC20WrapperV1(wrapper).mint(token, amount);\\n\\n        newAmount = IERC20(interoperable = address(IERC20WrapperV1(wrapper).asInteroperable(id))).balanceOf(\\n            address(this)\\n        );\\n    }\\n\\n    function _unwrapErc20(\\n        uint256 id,\\n        address tokenOut,\\n        uint256 amount,\\n        address wrapper,\\n        address to\\n    ) internal {\\n        IERC20WrapperV1(wrapper).burn(id, amount);\\n        TransferHelper.safeTransfer(tokenOut, to, IERC20(tokenOut).balanceOf(address(this)));\\n    }\\n\\n    function _unwrapEth(\\n        uint256 id,\\n        uint256 amount,\\n        address wrapper,\\n        address to\\n    ) internal {\\n        IERC20WrapperV1(wrapper).burn(id, amount);\\n        TransferHelper.safeTransferETH(to, amount);\\n    }\\n\\n    function _wrapEth(uint256 amount, address wrapper) public payable returns (address interoperable) {\\n        (, interoperable) = IERC20WrapperV1(wrapper).mintETH{value: amount}();\\n    }\\n\\n    function _adjustAmount(address token, uint256 amount) internal view returns (uint256 newAmount) {\\n        newAmount = amount * (10**(18 - IERC20Data(token).decimals()));\\n    }\\n\\n    function _tokenToInteroperable(address token, address wrapper) internal view returns (address interoperable) {\\n        if (token == address(0))\\n            interoperable = address(\\n                IERC20WrapperV1(wrapper).asInteroperable(\\n                    uint256(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID())\\n                )\\n            );\\n        else {\\n            (, uint256 itemId) = _isEthItem(token, wrapper);\\n            interoperable = address(IERC20WrapperV1(wrapper).asInteroperable(itemId));\\n        }\\n    }\\n}\\n\"},\"MateriaOrchestrator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity 0.8.0;\\n\\nimport \\u0027./IMVDFunctionalitiesManager.sol\\u0027;\\nimport \\u0027./IDoubleProxy.sol\\u0027;\\nimport \\u0027./IMVDProxy.sol\\u0027;\\n\\nimport \\u0027./IMateriaOrchestrator.sol\\u0027;\\nimport \\u0027./IMateriaFactory.sol\\u0027;\\n\\nimport \\u0027./IEthItemInteroperableInterface.sol\\u0027;\\nimport \\u0027./IERC20WrapperV1.sol\\u0027;\\n\\nimport \\u0027./MateriaLibrary.sol\\u0027;\\nimport \\u0027./TransferHelper.sol\\u0027;\\n\\nabstract contract Proxy {\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n        }\\n    }\\n}\\n\\ncontract MateriaOrchestrator is Proxy, IMateriaOrchestrator {\\n    IDoubleProxy public override doubleProxy;\\n\\n    address public override swapper;\\n    address public override liquidityAdder;\\n    address public override liquidityRemover;\\n\\n    IMateriaFactory public override factory;\\n    IERC20WrapperV1 public override erc20Wrapper;\\n    IERC20 public override bridgeToken;\\n    uint256 public override ETHEREUM_OBJECT_ID;\\n\\n    constructor(\\n        address initialFactory,\\n        address initialBridgeToken,\\n        address initialErc20Wrapper,\\n        address initialDoubleProxy,\\n        address initialLiquidityAdder,\\n        address initialLiquidityRemover,\\n        address initialSwapper\\n    ) {\\n        factory = IMateriaFactory(initialFactory);\\n        bridgeToken = IERC20(initialBridgeToken);\\n        erc20Wrapper = IERC20WrapperV1(initialErc20Wrapper);\\n        ETHEREUM_OBJECT_ID = uint256(keccak256(bytes(\\u0027THE ETHEREUM OBJECT IT\\u0027)));\\n        doubleProxy = IDoubleProxy(initialDoubleProxy);\\n        liquidityAdder = initialLiquidityAdder;\\n        liquidityRemover = initialLiquidityRemover;\\n        swapper = initialSwapper;\\n    }\\n\\n    function setDoubleProxy(address newDoubleProxy) external override onlyDFO {\\n        doubleProxy = IDoubleProxy(newDoubleProxy);\\n    }\\n\\n    function setBridgeToken(address newBridgeToken) external override onlyDFO {\\n        bridgeToken = IERC20(newBridgeToken);\\n    }\\n\\n    function setErc20Wrapper(address newErc20Wrapper) external override onlyDFO {\\n        erc20Wrapper = IERC20WrapperV1(newErc20Wrapper);\\n    }\\n\\n    function setFactory(address newFactory) external override onlyDFO {\\n        factory = IMateriaFactory(newFactory);\\n    }\\n\\n    function setEthereumObjectId(uint256 newEthereumObjectId) external override onlyDFO {\\n        ETHEREUM_OBJECT_ID = newEthereumObjectId;\\n    }\\n\\n    function setSwapper(address _swapper) external override onlyDFO {\\n        swapper = _swapper;\\n    }\\n\\n    function setLiquidityAdder(address _adder) external override onlyDFO {\\n        liquidityAdder = _adder;\\n    }\\n\\n    function setLiquidityRemover(address _remover) external override onlyDFO {\\n        liquidityRemover = _remover;\\n    }\\n\\n    function retire(address newOrchestrator) external override onlyDFO {\\n        factory.transferOwnership(newOrchestrator);\\n    }\\n\\n    function setFees(\\n        address token,\\n        uint256 materiaFee,\\n        uint256 swapFee\\n    ) external override onlyDFO {\\n        factory.setFees(MateriaLibrary.pairFor(address(factory), address(bridgeToken), token), materiaFee, swapFee);\\n    }\\n\\n    function setDefaultFees(uint256 materiaFee, uint256 swapFee) external override onlyDFO {\\n        factory.setDefaultMateriaFee(materiaFee);\\n        factory.setDefaultSwapFee(swapFee);\\n    }\\n\\n    function setFeeTo(address feeTo) external override onlyDFO {\\n        factory.setFeeTo(feeTo);\\n    }\\n\\n    //better be safe than sorry\\n    function getCrumbs(\\n        address token,\\n        uint256 amount,\\n        address receiver\\n    ) external override onlyDFO {\\n        TransferHelper.safeTransfer(token, receiver, amount);\\n    }\\n\\n    modifier onlyDFO() {\\n        require(IMVDFunctionalitiesManager(IMVDProxy(doubleProxy.proxy()).getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(msg.sender), \\\"Unauthorized\\\");\\n        _;\\n    }\\n\\n    receive() external payable {\\n        require(msg.sender == address(erc20Wrapper), \\u0027Only EthItem can send ETH to this contract\\u0027);\\n    }\\n\\n    /**\\n     * As ERC1155 receiver Materia Orchestrator implements onERC1155Received and onERC1155BatchReceived.\\n     * onERC1155Received exposes the delegate call to the Liquidity Adder, Remover Liquidity and to the Swapper contracts.\\n     * Calling with a callback you will be able to specify the operation needed.\\n     * onERC1155BatchReceived will be implemented with batch/lego operation.\\n     */\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata payload\\n    ) external override returns (bytes4) {\\n        (uint256 operation, ) = abi.decode(payload, (uint256, bytes));\\n        if (operation == 1) {\\n            //Adding liquidity\\n            _delegate(liquidityAdder);\\n        } else if (operation == 2 || operation == 3 || operation == 4 || operation == 5) {\\n            //Remove liquidity\\n            _delegate(swapper); //Swapping\\n        } else {\\n            revert();\\n        }\\n\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        revert();\\n    }\\n\\n    /**\\n     * Liquidity adding methods are exposed to call the Liquidity Adder contract via a secure channel such as the Orchestrator.\\n     * Both addLiquidity and addLiquidityETH methods are provided. addLiquidity can be used for ERC20 and ITEMs.\\n     */\\n\\n    function addLiquidity(\\n        address token,\\n        uint256 tokenAmountDesired,\\n        uint256 bridgeAmountDesired,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        override\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        )\\n    {\\n        _delegate(liquidityAdder);\\n    }\\n\\n    function addLiquidityETH(\\n        uint256 bridgeAmountDesired,\\n        uint256 EthAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        )\\n    {\\n        _delegate(liquidityAdder);\\n    }\\n\\n    /**\\n     * Liquidity removing methods are exposed to call the Liquidity Remover contract via a secure channel such as the Orchestrator.\\n     * The following methods are provided:\\n     * removeLiquidity, removeLiquidityETH, removeLiquidityWithPermit and removeLiquidityETHWithPermit\\n     */\\n\\n    function removeLiquidity(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) public override {\\n        _delegate(liquidityRemover);\\n    }\\n\\n    function removeLiquidityETH(\\n        uint256 liquidity,\\n        uint256 bridgeAmountMin,\\n        uint256 EthAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) public override {\\n        _delegate(liquidityRemover);\\n    }\\n\\n    function removeLiquidityWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public override {\\n        _delegate(liquidityRemover);\\n    }\\n\\n    function removeLiquidityETHWithPermit(\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public override {\\n        _delegate(liquidityRemover);\\n    }\\n\\n    /**\\n     * Swapping methods are exposed to call the Swapper Operator contract via a secure channel such as the Orchestrator.\\n     * The following methods are provided:\\n     * swapExactTokensForTokens, swapTokensForExactTokens, swapExactETHForTokens, swapTokensForExactETH, swapExactTokensForETH and swapETHForExactTokens\\n     */\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) public override returns (uint256[] memory amounts) {\\n        _delegate(swapper);\\n    }\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) public override returns (uint256[] memory amounts) {\\n        _delegate(swapper);\\n    }\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) public payable override {\\n        _delegate(swapper);\\n    }\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) public override {\\n        _delegate(swapper);\\n    }\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) public override {\\n        _delegate(swapper);\\n    }\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) public payable override {\\n        _delegate(swapper);\\n    }\\n\\n    /**\\n     * Methods are exposed for the UI to retrive useful information such as quote, getAmountOut, getAmountIn, getAmountsOut, getAmountsIn\\n     */\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) public pure override returns (uint256 amountB) {\\n        return MateriaLibrary.quote(amountA, reserveA, reserveB);\\n    }\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) public pure override returns (uint256 amountOut) {\\n        return MateriaLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\\n    }\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) public pure override returns (uint256 amountIn) {\\n        return MateriaLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\\n    }\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path)\\n        public\\n        view\\n        override\\n        returns (uint256[] memory amounts)\\n    {\\n        return MateriaLibrary.getAmountsOut(address(factory), amountIn, path);\\n    }\\n\\n    function getAmountsIn(uint256 amountOut, address[] memory path)\\n        public\\n        view\\n        override\\n        returns (uint256[] memory amounts)\\n    {\\n        return MateriaLibrary.getAmountsIn(address(factory), amountOut, path);\\n    }\\n\\n    /**\\n     * isEthItem is a custom implementation to check whether a token is an ITEM or a standard ERC20.\\n     */\\n\\n    function isEthItem(address token)\\n        public\\n        view\\n        override\\n        returns (\\n            address collection,\\n            bool ethItem,\\n            uint256 itemId\\n        )\\n    {\\n        if (token == address(0)) {\\n            return (address(0), false, 0);\\n        } else {\\n            try IEthItemInteroperableInterface(token).mainInterface() returns (address mainInterface) {\\n                return (mainInterface, true, IEthItemInteroperableInterface(token).objectId());\\n            } catch {\\n                return (address(0), false, 0);\\n            }\\n        }\\n    }\\n}\\n\"},\"MateriaSwapper.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.0;\\n\\nimport \\u0027./MateriaOperator.sol\\u0027;\\nimport \\u0027./IMateriaOrchestrator.sol\\u0027;\\nimport \\u0027./IMateriaFactory.sol\\u0027;\\nimport \\u0027./IMateriaPair.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IERC20WrapperV1.sol\\u0027;\\nimport \\u0027./IEthItemMainInterface.sol\\u0027;\\nimport \\u0027./MateriaLibrary.sol\\u0027;\\nimport \\u0027./TransferHelper.sol\\u0027;\\n\\n\\ncontract MateriaSwapper is MateriaOperator {\\n\\n    function _swap(address factory, uint[] memory amounts, address[] memory path, address _to) internal virtual {\\n        for (uint i; i \\u003c path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0,) = MateriaLibrary.sortTokens(input, output);\\n            uint amountOut = amounts[i + 1];\\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\n            address to = i \\u003c path.length - 2 ? MateriaLibrary.pairFor(factory, output, path[i + 2]) : _to;\\n            IMateriaPair(MateriaLibrary.pairFor(factory, input, output)).swap(\\n                amount0Out, amount1Out, to, new bytes(0)\\n            );\\n        }\\n    }\\n    \\n \\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) public ensure(deadline) returns (uint[] memory amounts) {\\n        \\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n\\n        TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), amountIn);\\n        \\n        (path[0], amountIn) = _wrapErc20(path[0], amountIn, erc20Wrapper);\\n        \\n        bool ethItemOut;\\n        uint itemId;\\n        address tokenOut;\\n        \\n        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\\n        \\n        if (!ethItemOut \\u0026\\u0026 bridgeToken != path[path.length - 1]) {\\n            tokenOut = path[path.length - 1];\\n            amountOutMin = _adjustAmount(tokenOut, amountOutMin);\\n            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\\n        }\\n        \\n        amounts = MateriaLibrary.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        \\n        TransferHelper.safeTransfer(\\n            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        \\n        if (ethItemOut) {\\n            _swap(factory, amounts, path, to);\\n        } else {\\n            _swap(factory, amounts, path, address(this));\\n            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\\n        }\\n    }\\n\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) public ensure(deadline) returns (uint[] memory amounts) {\\n        \\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        \\n        address tokenIn = path[0];\\n        path[0] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(IERC20WrapperV1(erc20Wrapper).object(path[0])));\\n        \\n        bool ethItemOut;\\n        uint itemId;\\n        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\\n        address tokenOut;\\n        \\n        if (!ethItemOut \\u0026\\u0026 address(IMateriaOrchestrator(address(this)).bridgeToken()) != path[path.length - 1]) {\\n            tokenOut = path[path.length - 1];\\n            amountOut =  _adjustAmount(tokenOut, amountOut);\\n            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\\n        }\\n\\n        amounts = MateriaLibrary.getAmountsIn(factory, amountOut, path);\\n        amounts[0] = amounts[0] / (10**(18 - IERC20Data(tokenIn).decimals())) + 1;\\n\\n        require(amounts[0] \\u003c= amountInMax, \\u0027EXCESSIVE_INPUT_AMOUNT\\u0027);\\n        \\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), amounts[0]);\\n        \\n        (, amounts[0]) = _wrapErc20(tokenIn, amounts[0], erc20Wrapper);\\n        \\n        TransferHelper.safeTransfer(\\n            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        \\n        if (ethItemOut) {\\n            _swap(factory, amounts, path, to);\\n        } else {\\n            _swap(factory, amounts, path, address(this));\\n            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\\n        }\\n    }\\n    \\n     function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) public ensure(deadline) payable returns (uint[] memory amounts) {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n\\n        path[0] = _wrapEth(msg.value, erc20Wrapper);\\n        \\n        bool ethItemOut;\\n        uint itemId;\\n        address tokenOut;\\n        \\n        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\\n        \\n        if (!ethItemOut \\u0026\\u0026 bridgeToken != path[path.length - 1]) {\\n            tokenOut = path[path.length - 1];\\n            amountOutMin = _adjustAmount(tokenOut, amountOutMin);\\n            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\\n        }\\n        \\n        amounts = MateriaLibrary.getAmountsOut(factory, msg.value, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        \\n        TransferHelper.safeTransfer(\\n            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        \\n        if (ethItemOut) {\\n            _swap(factory, amounts, path, to);\\n        } else {\\n            _swap(factory, amounts, path, address(this));\\n            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\\n        }\\n    }\\n   \\n    function swapTokensForExactETH(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) public ensure(deadline) returns (uint[] memory amounts) {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        uint ethId = uint(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID());\\n        \\n        address token = path[0];\\n        path[0] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(IERC20WrapperV1(erc20Wrapper).object(path[0])));\\n        amountOut = amountOut * (10 ** (18 - IERC20Data(path[path.length - 1]).decimals()));\\n\\n        amountInMax = _adjustAmount(token, amountInMax);\\n        amounts = MateriaLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] \\u003c= amountInMax, \\u0027INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n\\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amounts[0]);\\n        \\n        (path[0], amounts[0]) = _wrapErc20(token, amounts[0], erc20Wrapper);\\n        \\n        TransferHelper.safeTransfer(\\n            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        \\n        _swap(factory, amounts, path, address(this));\\n        _unwrapEth(ethId, amounts[amounts.length - 1], erc20Wrapper, to);\\n    }\\n    \\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) public ensure(deadline) returns (uint[] memory amounts) {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        uint ethId = uint(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID());\\n\\n        TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), amountIn);\\n        \\n        (path[0], amountIn) = _wrapErc20(path[0], amountIn, erc20Wrapper);\\n        \\n        amounts = MateriaLibrary.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        \\n        TransferHelper.safeTransfer(\\n            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        \\n        _swap(factory, amounts, path, address(this));\\n        _unwrapEth(ethId, amounts[amounts.length - 1], erc20Wrapper, to);\\n    }\\n    \\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) public payable ensure(deadline) returns (uint[] memory amounts) {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n        \\n        bool ethItemOut;\\n        uint itemId;\\n        address tokenOut;\\n        \\n        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\\n        \\n        if (!ethItemOut \\u0026\\u0026 bridgeToken != path[path.length - 1]) {\\n            tokenOut = path[path.length - 1];\\n            amountOut = _adjustAmount(tokenOut, amountOut);\\n            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\\n        }\\n        \\n        amounts = MateriaLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] \\u003c= msg.value, \\u0027INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n        \\n        path[0] = _wrapEth(amounts[0], erc20Wrapper);\\n        \\n        TransferHelper.safeTransfer(\\n            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        \\n        if (ethItemOut) {\\n            _swap(factory, amounts, path, to);\\n        } else {\\n            _swap(factory, amounts, path, address(this));\\n            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\\n        }\\n        \\n        if (msg.value \\u003e amounts[0])\\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n    }\\n    \\n    function swapExactItemsForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) private ensure(deadline) {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n\\n        bool ethItemOut;\\n        uint itemId;\\n        address tokenOut;\\n        \\n        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\\n        \\n        if (!ethItemOut \\u0026\\u0026 address(IMateriaOrchestrator(address(this)).bridgeToken()) != path[path.length - 1]) {\\n            tokenOut = path[path.length - 1];\\n            amountOutMin = _adjustAmount(tokenOut, amountOutMin);\\n            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\\n        }\\n        \\n        uint[] memory amounts = MateriaLibrary.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        \\n        TransferHelper.safeTransfer(\\n            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        \\n        if (ethItemOut) {\\n            _swap(factory, amounts, path, to);\\n        } else {\\n            _swap(factory, amounts, path, address(this));\\n            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\\n        }\\n    }\\n    \\n    function swapItemsForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] memory path,\\n        address to,\\n        address from,\\n        uint deadline\\n    ) private ensure(deadline) {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n\\n        bool ethItemOut;\\n        uint itemId;\\n        address tokenOut;\\n        \\n        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\\n        \\n        if (!ethItemOut \\u0026\\u0026 address(IMateriaOrchestrator(address(this)).bridgeToken()) != path[path.length - 1]) {\\n            tokenOut = path[path.length - 1];\\n            amountOut = _adjustAmount(tokenOut, amountOut);\\n            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\\n        }\\n        \\n        uint[] memory amounts = MateriaLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] \\u003c= amountInMax, \\u0027INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n        \\n        {\\n        uint amountBack;\\n        if ((amountBack = amountInMax - amounts[0]) \\u003e 0)\\n            TransferHelper.safeTransfer(path[0], from, amountBack);\\n        }\\n        \\n        TransferHelper.safeTransfer(\\n            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        \\n        if (ethItemOut) {\\n            _swap(factory, amounts, path, to);\\n        } else {\\n            _swap(factory, amounts, path, address(this));\\n            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\\n        }\\n    }\\n    \\n    function swapExactItemsForEth(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint deadline\\n    ) private ensure(deadline) {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        uint ethId = uint(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID());\\n\\n        uint[] memory amounts = MateriaLibrary.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        \\n        TransferHelper.safeTransfer(\\n            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        \\n        _swap(factory, amounts, path, address(this));\\n        \\n        IERC20WrapperV1(erc20Wrapper).burn(\\n            ethId,\\n            amounts[amounts.length - 1]\\n        );\\n        \\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n    \\n    function swapItemsForExactEth(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] memory path,\\n        address to,\\n        address from,\\n        uint deadline\\n    ) private ensure(deadline) {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        uint ethId = uint(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID());\\n\\n        uint[] memory amounts = MateriaLibrary.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] \\u003c= amountInMax, \\u0027INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n        \\n        {\\n        uint amountBack;\\n        if ((amountBack = amountInMax - amounts[0]) \\u003e 0)\\n            TransferHelper.safeTransfer(path[0], from, amountBack);\\n        }\\n        \\n        TransferHelper.safeTransfer(\\n            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        \\n        _swap(factory, amounts, path, address(this));\\n        \\n        IERC20WrapperV1(erc20Wrapper).burn(\\n            ethId,\\n            amounts[amounts.length - 1]\\n        );\\n        \\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address from,\\n        uint,\\n        uint value,\\n        bytes calldata data\\n    ) public override returns(bytes4) {\\n        uint operation;\\n        uint amount;\\n        address[] memory path;\\n        address to;\\n        uint deadline;\\n        \\n        { //to avoid \\\"stack too deep\\\"\\n            bytes memory payload;\\n            (operation, payload) = abi.decode(data, (uint, bytes));\\n            (amount, path, to, deadline) = abi.decode(payload, (uint, address[], address, uint));\\n        }\\n        \\n        if (operation == 2) swapExactItemsForTokens(value, amount, path, to, deadline);\\n        else if (operation == 3) swapItemsForExactTokens(amount, value, path, to, from, deadline);\\n        else if (operation == 4) swapExactItemsForEth(value, amount, path, to, deadline);\\n        else if (operation == 5) swapItemsForExactEth(amount, value, path, to, from, deadline);\\n        else revert();\\n        \\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) public override pure returns(bytes4) {\\n        revert();\\n    }\\n    \\n    function supportsInterface(\\n        bytes4\\n    ) public override pure returns (bool) {\\n        return false;\\n    }\\n}\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity =0.8.0;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x \\u003c y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y \\u003e 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x \\u003c z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.0;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) \\u003e= x, \\u0027ds-math-add-overflow\\u0027);\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) \\u003c= x, \\u0027ds-math-sub-underflow\\u0027);\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\u0027ds-math-mul-overflow\\u0027);\\n    }\\n}\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity \\u003e=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: APPROVE_FAILED\\u0027);\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FAILED\\u0027);\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027);\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\u0027TransferHelper: ETH_TRANSFER_FAILED\\u0027);\\n    }\\n}\\n\"},\"UQ112x112.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity =0.8.0;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"}],\"name\":\"_wrapEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"interoperable\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBridge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBridge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountEth\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MateriaLiquidityRemover","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://29008a865a54d2ffb693b520e02e84dd8ea39530469b860dbb25b24b1f4a8fad"}]}