{"status":"1","message":"OK","result":[{"SourceCode":"{\"Container.sol\":{\"content\":\"pragma solidity ^0.5.11;\\n\\ncontract Container{\\n    struct Item{\\n        uint256 itemType;\\n        uint256 status;\\n        address[] addresses;\\n    }\\n    uint256 MaxItemAdressNum = 255;\\n\\n    mapping (bytes32 =\\u003e Item) private container;\\n\\n    function itemAddressExists(bytes32 id, address oneAddress) internal view returns(bool){\\n        for(uint256 i = 0; i \\u003c container[id].addresses.length; i++){\\n            if(container[id].addresses[i] == oneAddress)\\n                return true;\\n        }\\n        return false;\\n    }\\n    function getItemAddresses(bytes32 id) internal view returns(address[] memory){\\n        return container[id].addresses;\\n    }\\n\\n    function getItemInfo(bytes32 id) internal view returns(uint256, uint256, uint256){\\n        return (container[id].itemType, container[id].status, container[id].addresses.length);\\n    }\\n\\n    function getItemAddressCount(bytes32 id) internal view returns(uint256){\\n        return container[id].addresses.length;\\n    }\\n\\n    function setItemInfo(bytes32 id, uint256 itemType, uint256 status) internal{\\n        container[id].itemType = itemType;\\n        container[id].status = status;\\n    }\\n\\n    function addItemAddress(bytes32 id, address oneAddress) internal{\\n        require(!itemAddressExists(id, oneAddress), \\\"dup address added\\\");\\n        require(container[id].addresses.length \\u003c MaxItemAdressNum, \\\"too many addresses\\\");\\n        container[id].addresses.push(oneAddress);\\n    }\\n    function removeItemAddresses(bytes32 id) internal{\\n        container[id].addresses.length = 0;\\n    }\\n\\n    function removeOneItemAddress(bytes32 id, address oneAddress) internal{\\n        for(uint256 i = 0; i \\u003c container[id].addresses.length; i++){\\n            if(container[id].addresses[i] == oneAddress){\\n                container[id].addresses[i] = container[id].addresses[container[id].addresses.length - 1];\\n                container[id].addresses.length--;\\n                return;\\n            }\\n        }\\n        revert(\\\"not exist address\\\");\\n    }\\n\\n    function removeItem(bytes32 id) internal{\\n        delete container[id];\\n    }\\n\\n    function replaceItemAddress(bytes32 id, address oneAddress, address anotherAddress) internal{\\n        require(!itemAddressExists(id,anotherAddress),\\\"dup address added\\\");\\n        for(uint256 i = 0; i \\u003c container[id].addresses.length; i++){\\n            if(container[id].addresses[i] == oneAddress){\\n                container[id].addresses[i] = anotherAddress;\\n                return;\\n            }\\n        }\\n        revert(\\\"not exist address\\\");\\n    }\\n}\"},\"HBETHLogic.sol\":{\"content\":\"pragma solidity ^0.5.11;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./HBETHStorage.sol\\\";\\n\\ncontract HBETHLogic {\\n\\n    using SafeMath for uint256;\\n\\n    string public constant name = \\\"HBETHLogic\\\";\\n\\n    uint256 public constant TASKINIT = 0;\\n    uint256 public constant TASKPROCESSING = 1;\\n    uint256 public constant TASKCANCELLED = 2;\\n    uint256 public constant TASKDONE = 3;\\n    uint256 public constant MINTTASK = 1;\\n    uint256 public constant BURNTASK = 2;\\n\\n    address private caller;\\n    HBETHStorage private store;\\n\\n    constructor(address aCaller) public{\\n        caller = aCaller;\\n    }\\n\\n    modifier onlyCaller(){\\n        require(msg.sender == caller, \\\"only main contract can call\\\");\\n        _;\\n    }\\n\\n    function mintLogic(uint256 value,address to,string calldata proof,\\n        bytes32 taskHash, address supportAddress, uint256 requireNum)\\n        external onlyCaller returns(uint256){\\n        require(to != address(0), \\\"cannot be burned from zero address\\\");\\n        require(value \\u003e 0, \\\"value need \\u003e 0\\\");\\n        require(taskHash == keccak256((abi.encodePacked(to,value,proof))),\\\"taskHash is wrong\\\");\\n        uint256 status = supportTask(MINTTASK, taskHash, supportAddress, requireNum);\\n\\n        if( status == TASKDONE){\\n            uint256 totalSupply = store.getTotalSupply();\\n            uint256 balanceTo = store.balanceOf(to);\\n            balanceTo = balanceTo.safeAdd(value);\\n            totalSupply = totalSupply.safeAdd(value);\\n            store.setBalance(to,balanceTo);\\n            store.setTotalSupply(totalSupply);\\n        }\\n        return status;\\n    }\\n\\n    function burnLogic(address from, uint256 value,string calldata hbethAddress,\\n        string calldata proof,bytes32 taskHash, address supportAddress, uint256 requireNum)\\n        external onlyCaller returns(uint256){\\n\\n        uint256 balance = store.balanceOf(from);\\n        require(balance \\u003e= value,\\\"sender address not have enough HBETH\\\");\\n        require(value \\u003e 0, \\\"value need \\u003e 0\\\");\\n        require(taskHash == keccak256((abi.encodePacked(from,value,hbethAddress,proof))),\\\"taskHash is wrong\\\");\\n        uint256 status = supportTask(BURNTASK, taskHash, supportAddress, requireNum);\\n\\n        if ( status == TASKDONE ){\\n            uint256 totalSupply = store.getTotalSupply();\\n            totalSupply = totalSupply.safeSub(value);\\n            balance = balance.safeSub(value);\\n            store.setBalance(from,balance);\\n            store.setTotalSupply(totalSupply);\\n\\n        }\\n        return status;\\n    }\\n\\n    function transferLogic(address sender,address to,uint256 value) external onlyCaller returns(bool) {\\n        require(to != address(0), \\\"cannot transfer to address zero\\\");\\n        require(sender != to, \\\"sender need != to\\\");\\n        require(value \\u003e 0, \\\"value need \\u003e 0\\\");\\n        require(address(store) != address(0), \\\"dataStore address error\\\");\\n\\n        uint256 balanceFrom = store.balanceOf(sender);\\n        uint256 balanceTo = store.balanceOf(to);\\n        require(value \\u003c= balanceFrom, \\\"insufficient funds\\\");\\n        balanceFrom = balanceFrom.safeSub(value);\\n        balanceTo = balanceTo.safeAdd(value);\\n        store.setBalance(sender,balanceFrom);\\n        store.setBalance(to,balanceTo);\\n        return true;\\n    }\\n\\n    function transferFromLogic(address sender,address from,address to,uint256 value) external onlyCaller returns(bool) {\\n        require(from != address(0), \\\"cannot transfer from address zero\\\");\\n        require(to != address(0), \\\"cannot transfer to address zero\\\");\\n        require(value \\u003e 0, \\\"can not tranfer zero Token\\\");\\n        require(from!=to,\\\"from and to can not be be the same \\\");\\n        require(address(store) != address(0), \\\"dataStore address error\\\");\\n\\n        uint256 balanceFrom = store.balanceOf(from);\\n        uint256 balanceTo = store.balanceOf(to);\\n        uint256 allowedvalue = store.getAllowed(from,sender);\\n\\n        require(value \\u003c= allowedvalue, \\\"insufficient allowance\\\");\\n        require(value \\u003c= balanceFrom, \\\"insufficient funds\\\");\\n\\n        balanceFrom = balanceFrom.safeSub(value);\\n        balanceTo = balanceTo.safeAdd(value);\\n        allowedvalue = allowedvalue.safeSub(value);\\n\\n        store.setBalance(from,balanceFrom);\\n        store.setBalance(to,balanceTo);\\n        store.setAllowed(from,sender,allowedvalue);\\n        return true;\\n    }\\n\\n    function approveLogic(address sender,address spender,uint256 value)  external onlyCaller returns(bool success){\\n        require(spender != address(0), \\\"spender address zero\\\");\\n        require(value \\u003e 0, \\\"value need \\u003e 0\\\");\\n        require(address(store) != address(0), \\\"dataStore address error\\\");\\n\\n        store.setAllowed(sender,spender,value);\\n        return true;\\n    }\\n\\n    function resetStoreLogic(address storeAddress) external onlyCaller {\\n        store = HBETHStorage(storeAddress);\\n    }\\n\\n    function getTotalSupply() public view returns (uint256 supply) {\\n        return store.getTotalSupply();\\n    }\\n\\n    function balanceOf(address owner) public view returns (uint256 balance) {\\n        return store.balanceOf(owner);\\n    }\\n\\n    function getAllowed(address owner, address spender) public view returns (uint256 remaining){\\n        return store.getAllowed(owner,spender);\\n    }\\n\\n    function getStoreAddress() public view returns(address){\\n        return address(store);\\n    }\\n\\n    function supportTask(uint256 taskType, bytes32 taskHash, address oneAddress, uint256 requireNum) private returns(uint256){\\n        require(!store.supporterExists(taskHash, oneAddress), \\\"supporter already exists\\\");\\n        (uint256 theTaskType,uint256 theTaskStatus,uint256 theSupporterNum) = store.getTaskInfo(taskHash);\\n        require(theTaskStatus \\u003c TASKDONE, \\\"wrong status\\\");\\n\\n        if (theTaskStatus != TASKINIT)\\n            require(theTaskType == taskType, \\\"task type not match\\\");\\n        store.addSupporter(taskHash, oneAddress);\\n        theSupporterNum++;\\n        if(theSupporterNum \\u003e= requireNum)\\n            theTaskStatus = TASKDONE;\\n        else\\n            theTaskStatus = TASKPROCESSING;\\n        store.setTaskInfo(taskHash, taskType, theTaskStatus);\\n        return theTaskStatus;\\n    }\\n\\n    function cancelTask(bytes32 taskHash)  external onlyCaller returns(uint256){\\n        (uint256 theTaskType,uint256 theTaskStatus,uint256 theSupporterNum) = store.getTaskInfo(taskHash);\\n        require(theTaskStatus == TASKPROCESSING, \\\"wrong status\\\");\\n        if(theSupporterNum \\u003e 0) store.removeAllSupporter(taskHash);\\n        theTaskStatus = TASKCANCELLED;\\n        store.setTaskInfo(taskHash, theTaskType, theTaskStatus);\\n        return theTaskStatus;\\n    }\\n}\"},\"HBETHStorage.sol\":{\"content\":\"pragma solidity ^0.5.11;\\n\\nimport \\\"./Container.sol\\\";\\n\\ncontract HBETHStorage is Container{\\n\\n    string public constant name = \\\"HBETHStorage\\\";\\n\\n    address private caller;\\n\\n    constructor(address aCaller) public{\\n        totalSupply = 0;\\n        caller = aCaller;\\n    }\\n    uint256 public totalSupply;\\n\\n    mapping (address =\\u003e uint256) private balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private allowed;\\n\\n    function supporterExists(bytes32 taskHash, address user) public view returns(bool){\\n        return itemAddressExists(taskHash, user);\\n    }\\n\\n    function setTaskInfo(bytes32 taskHash, uint256 taskType, uint256 status) external onlyCaller{\\n        setItemInfo(taskHash, taskType, status);\\n    }\\n\\n    function getTaskInfo(bytes32 taskHash) public view returns(uint256, uint256, uint256){\\n        return getItemInfo(taskHash);\\n    }\\n\\n    function addSupporter(bytes32 taskHash, address oneAddress) external onlyCaller{\\n        addItemAddress(taskHash, oneAddress);\\n    }\\n\\n    function removeAllSupporter(bytes32 taskHash) external onlyCaller{\\n        removeItemAddresses(taskHash);\\n    }\\n\\n    modifier onlyCaller() {\\n        require(msg.sender == caller, \\\"only use main main contract to call\\\");\\n        _;\\n    }\\n\\n    function getTotalSupply() external view returns(uint256) {\\n        return totalSupply;\\n    }\\n\\n    function setTotalSupply(uint256 amount) external onlyCaller {\\n        totalSupply = amount;\\n    }\\n\\n    function balanceOf(address account) external view returns(uint256) {\\n        return balances[account];\\n    }\\n\\n    function setBalance(address account,uint256 amount) external onlyCaller {\\n        require(account != address(0),\\\"account address error\\\");\\n        balances[account] = amount;\\n    }\\n\\n    function getAllowed(address owner,address spender) external view returns(uint256) {\\n        return allowed[owner][spender];\\n    }\\n\\n    function setAllowed(address owner,address spender,uint256 amount) external onlyCaller {\\n        require(owner != address(0),\\\"owner address error\\\");\\n        require(spender != address(0),\\\"spender address error\\\");\\n        allowed[owner][spender] = amount;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// solium-disable linebreak-style\\r\\npragma solidity ^0.5.11;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\\r\\n        c = a + b;\\r\\n        require(c \\u003e= a,\\\"\\\");\\r\\n    }\\r\\n    function safeSub(uint a, uint b) public pure returns (uint c) {\\r\\n        require(b \\u003c= a,\\\"\\\");\\r\\n        c = a - b;\\r\\n    }\\r\\n    function safeMul(uint a, uint b) public pure returns (uint c) {\\r\\n        c = a * b;\\r\\n        require(a == 0 || c / a == b,\\\"\\\");\\r\\n    }\\r\\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\\r\\n        require(b \\u003e 0,\\\"\\\");\\r\\n        c = a / b;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aCaller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"BURNTASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINTTASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TASKCANCELLED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TASKDONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TASKINIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TASKPROCESSING\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveLogic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"hbethAddress\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"proof\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"supportAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requireNum\",\"type\":\"uint256\"}],\"name\":\"burnLogic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"}],\"name\":\"cancelTask\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"getAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStoreAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"proof\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"supportAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requireNum\",\"type\":\"uint256\"}],\"name\":\"mintLogic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"storeAddress\",\"type\":\"address\"}],\"name\":\"resetStoreLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFromLogic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferLogic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"HBETHLogic","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008587558fccba43c8a3a7f37184fc4130621c188a","EVMVersion":"Default","Library":"SafeMath:4c5a863a464d96e1488b6d4718c87457cf369da4","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://1b2a71fa6136a9b8200ecb2fcd5b8933460c034696933d6a613e63222b6f11bf"}]}