{"status":"1","message":"OK","result":[{"SourceCode":"{\"SafeMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nlibrary SafeMathLib {\\n  function times(uint a, uint b) public pure returns (uint) {\\n    uint c = a * b;\\n    require(a == 0 || c / a == b, \\u0027Overflow detected\\u0027);\\n    return c;\\n  }\\n\\n  function minus(uint a, uint b) public pure returns (uint) {\\n    require(b \\u003c= a, \\u0027Underflow detected\\u0027);\\n    return a - b;\\n  }\\n\\n  function plus(uint a, uint b) public pure returns (uint) {\\n    uint c = a + b;\\n    require(c\\u003e=a \\u0026\\u0026 c\\u003e=b, \\u0027Overflow detected\\u0027);\\n    return c;\\n  }\\n\\n}\\n\"},\"TrollboxComplete.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nimport \\\"./SafeMathLib.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\\n\\ncontract Trollbox {\\n    using SafeMathLib for uint;\\n\\n    /**\\n        Votes are a mapping from choices to weights, plus a metadataHash, which references an arbitrary bit of metadata\\n        stored on IPFS. The meaning of these choices is not stored on chain, only the index. For example, if  the choices\\n        are [\\\"BTC\\\", \\\"ETH\\\", \\\"DASH\\\"],  and the user  wants to put 3 votes on BTC, 5 votes on ETH and 4 on DASH, then this\\n        will be recorded as weights[1]  = 3; weights[2]  = 5; weights[3] = 4; The choices are indexed starting on 1 to\\n        prevent confusion caused by empty votes.\\n    **/\\n    struct Vote {\\n        mapping(uint =\\u003e uint) weights;\\n        bytes32 metadataHash;\\n    }\\n\\n    /**\\n        Rounds occur with some frequency and represent a complete cycle of prediction-\\u003eresolution. Each round has an id,\\n        which represents it\\u0027s location in a linear sequence of rounds of the same type. It stores a mapping of voter\\n        ids to votes and records the winning option when the round is resolved.\\n    **/\\n    struct Round {\\n        uint roundId;\\n        mapping (uint =\\u003e Vote) votes;\\n        mapping (uint =\\u003e uint) voteTotals;\\n        uint winningOption;\\n    }\\n\\n    /**\\n        A tournament is a linear sequence of rounds of the same type. Tournaments are identified by an integer that\\n        increases sequentially with each tournament. Tournaments also have hash for storing off-chain metadata about the\\n        tournament. A tournament has a set wavelength and phase, called roundLengthSeconds and startDate, respectively. Each\\n        tournament also has it\\u0027s own set of voice credits, which is a mapping from address to balance. The rounds\\n        mapping takes a round id and spits out a Round struct. The tokenRoundBonus attribute describes how much IERC20 to be\\n        distributed to the voters each round. The tokenListENS stores the ENS address of a token list that forms the\\n        choices of the tournament.\\n    **/\\n    struct Tournament {\\n        uint tournamentId;\\n        bytes32 metadataHash;  // ipfs hash of more verbose description, possibly multimedia\\n        uint startTime;\\n        uint roundLengthSeconds;\\n        uint tokenRoundBonus;\\n        uint minimumRank;\\n        uint voiceUBI;   // number of voice credits available to spend each round\\n        bytes32 tokenListENS;\\n        address winnerOracle;  // address that sets the winner for a tournament\\n        mapping (uint =\\u003e uint) voiceCredits;\\n        mapping (uint =\\u003e Round) rounds;\\n    }\\n\\n    /**\\n        An identity is purchased with IERC20 and stores the creation time and a mapping of tournament id to the last round\\n        id that the identity voted in, which is used for deferred reward computation.\\n    **/\\n    struct IdMetadata {\\n        mapping (uint =\\u003e uint) lastRoundVoted;\\n//        uint firstTimeVoted;\\n//        uint timesVoted;\\n        uint cumulativeBonus;\\n        uint rank;\\n    }\\n\\n    address public management; // authoritative key that can make important decisions, can be DAO address later\\n    address public rankManager;\\n    IERC20 public token;\\n    IERC721 public identity;\\n\\n    uint public numTournaments = 0; // a counter to know what index to assign to new tournaments\\n    bytes32 public siteHash;\\n\\n    mapping (uint =\\u003e Tournament) public tournaments; // mapping from tournament id to tournament struct\\n    mapping (uint =\\u003e IdMetadata) public identities; // mapping from address to identity struct\\n    mapping (uint =\\u003e uint) public tokensWon; // tokensWon[voterId] = fvt-wei owed\\n    mapping (uint =\\u003e mapping (uint =\\u003e mapping (uint =\\u003e bool))) public syncMap; // syncMap[voterId][tournamentId][roundId] = true/false\\n\\n    // events for consumption by off chain systems\\n    event VoteOccurred(uint indexed tournamentId, uint indexed roundId, uint indexed voterId, uint[] choices, uint[] weights, bytes32 metadata);\\n    event RoundResolved(uint indexed tournamentId, uint roundId, uint winningChoice);\\n    event TournamentCreated(uint tournamentId, bytes32 metadataHash, uint startTime, uint roundLengthSeconds, uint tokenRoundBonus, uint minimumRank, uint voiceUBI, bytes32 tokenListENS, address winnerOracle);\\n    event ManagementUpdated(address oldManagement, address newManagement);\\n    event SiteHashUpdated(bytes32 oldSiteHash, bytes32 newSiteHash);\\n    event RankUpdated(uint voterId, uint oldRank, uint newRank);\\n    event RankManagerUpdated(address oldManager, address newManager);\\n    event TournamentUpdated(uint tournamentId, bytes32 metadataHash, uint tokenRoundBonus, uint minimumRank, uint voiceUBI, bytes32 tokenListENS, address winnerOracle);\\n    event AccountSynced(uint tournamentId, uint voterId);\\n\\n    modifier managementOnly() {\\n        require (msg.sender == management, \\u0027Only management may call this\\u0027);\\n        _;\\n    }\\n\\n    constructor(address mgmt, address rankMgmt, address id) {\\n        management = mgmt;\\n        rankManager = rankMgmt;\\n        identity = IERC721(id);\\n    }\\n\\n    // this function creates a new tournament type, only management can call it\\n    function createTournament(\\n        bytes32 hash,\\n        uint startTime,\\n        uint roundLengthSeconds,\\n        uint tokenRoundBonus,\\n        bytes32 tokenListENS,\\n        address oracle,\\n        uint minRank,\\n        uint voiceUBI) public managementOnly {\\n        numTournaments = numTournaments.plus(1);\\n        Tournament storage tournament = tournaments[numTournaments];\\n        tournament.metadataHash = hash;\\n        tournament.startTime = startTime == 0 ? block.timestamp : startTime;\\n        tournament.tournamentId = numTournaments;\\n        tournament.roundLengthSeconds = roundLengthSeconds;\\n        tournament.tokenRoundBonus = tokenRoundBonus;\\n        tournament.minimumRank = minRank;\\n        tournament.voiceUBI = voiceUBI;\\n        tournament.tokenListENS = tokenListENS;\\n        tournament.winnerOracle = oracle;\\n        emit TournamentCreated(numTournaments, hash, startTime, roundLengthSeconds, tokenRoundBonus, minRank, voiceUBI, tokenListENS, oracle);\\n    }\\n\\n\\n\\n    // this completes the round, and assigns it a winning choice, which enables deferred updates to voice credits\\n    function resolveRound(uint tournamentId, uint roundId, uint winningOption) public {\\n        Tournament storage tournament = tournaments[tournamentId];\\n        require(msg.sender == tournament.winnerOracle, \\u0027Only winner oracle can call this\\u0027);\\n        uint currentRoundId = getCurrentRoundId(tournamentId);\\n        Round storage round = tournament.rounds[roundId];\\n        require(roundAlreadyResolved(tournamentId, roundId) == false, \\u0027Round already resolved\\u0027);\\n        require(currentRoundId \\u003e roundId + 1, \\u0027Too early to resolve\\u0027);\\n        round.roundId = roundId;\\n        round.winningOption = winningOption;\\n        emit RoundResolved(tournamentId, roundId, winningOption);\\n    }\\n\\n    function voteCheck(uint voterId, uint tournamentId, uint roundId) internal view {\\n        require(roundId \\u003e 0, \\u0027Tournament not started yet\\u0027);\\n        require(identity.ownerOf(voterId) == msg.sender, \\u0027Must own identity to vote with it\\u0027);\\n        require(roundId \\u003e identities[voterId].lastRoundVoted[tournamentId], \\u0027Can only vote one time per round\\u0027);\\n        require(tournaments[tournamentId].minimumRank \\u003c= identities[voterId].rank, \\u0027Insufficient rank to participate in this tournament\\u0027);\\n    }\\n\\n    // this is called by an identity that wishes to vote on a given tournament, with the choices and weights\\n    function vote(\\n        uint voterId,\\n        uint tournamentId,\\n        uint[] memory choices,\\n        uint[] memory weights,\\n        bytes32 hash,\\n        uint updateRoundId\\n    ) public {\\n        uint roundId = getCurrentRoundId(tournamentId);\\n        Round storage currentRound = tournaments[tournamentId].rounds[roundId];\\n\\n        voteCheck(voterId, tournamentId, roundId);\\n        require(choices.length == weights.length, \\u0027Mismatched choices and lengths\\u0027);\\n\\n        updateAccount(voterId, tournamentId, updateRoundId);\\n\\n        identities[voterId].lastRoundVoted[tournamentId] = roundId;\\n\\n        Vote storage currentVote = currentRound.votes[voterId];\\n        currentVote.metadataHash = hash;\\n        uint balance = getVoiceCredits(tournamentId, voterId);\\n        uint sum = 0;\\n\\n        for (uint i = 0; i \\u003c weights.length; i++) {\\n            currentVote.weights[choices[i]] = weights[i];\\n            currentRound.voteTotals[choices[i]] = currentRound.voteTotals[choices[i]].plus(weights[i]);\\n            sum = sum.plus(weights[i].times(weights[i]));\\n        }\\n        require(sum \\u003c= balance, \\u0027Must not spend more than your balance\\u0027);\\n\\n        emit VoteOccurred(tournamentId, roundId, voterId, choices, weights, hash);\\n    }\\n\\n    function withdrawWinnings(uint voterId) public {\\n        uint winnings = tokensWon[voterId];\\n        address owner = identity.ownerOf(voterId);\\n        require(winnings \\u003e 0, \\u0027Nothing to withdraw\\u0027);\\n        // doing it this way out of re-entry avoidance habit, not because it\\u0027s actually possible here\\n        tokensWon[voterId] = 0;\\n        token.transfer(owner, winnings);\\n    }\\n\\n    // this actually updates the voice credit balance to include the reward\\n    function updateAccount(uint voterId, uint tournamentId, uint roundId) public {\\n        IdMetadata storage id = identities[voterId];\\n        Tournament storage tournament = tournaments[tournamentId];\\n        bool roundResolved = roundAlreadyResolved(tournamentId, roundId);\\n        bool shouldSync = isSynced(voterId, tournamentId, roundId) == false;\\n\\n        if (shouldSync \\u0026\\u0026 roundResolved) {\\n            // idempotent condition, call twice, update once, since this function is public\\n            syncMap[voterId][tournamentId][roundId] = true; // idempotence\\n\\n            (uint voiceCreditBonus, uint tokenBonus) = getRoundBonus(voterId, tournamentId, roundId);\\n            tournament.voiceCredits[voterId] = getVoiceCredits(tournamentId, voterId).plus(voiceCreditBonus);\\n            tokensWon[voterId] = tokensWon[voterId].plus(tokenBonus);\\n            id.cumulativeBonus = id.cumulativeBonus.plus(voiceCreditBonus);\\n            emit AccountSynced(tournamentId, voterId);\\n        }\\n    }\\n\\n\\n/**\\n====================================== GETTERS ==========================================================\\n**/\\n    function getRound(uint tournamentId, uint roundId) public view returns (uint[2] memory) {\\n        Round storage round = tournaments[tournamentId].rounds[roundId];\\n        return [round.roundId, round.winningOption];\\n    }\\n\\n    // this computes the id of the current round for a given tournament, starting with round 1 on the startTime\\n    function getCurrentRoundId(uint tournamentId) public view returns (uint) {\\n        Tournament storage tournament = tournaments[tournamentId];\\n        uint startTime = tournament.startTime;\\n        uint roundLengthSeconds = tournament.roundLengthSeconds;\\n        if (block.timestamp \\u003e= startTime) {\\n            return 1 + ((block.timestamp - startTime) / roundLengthSeconds);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function getVoiceCredits(uint tournamentId, uint voterId) public view returns (uint) {\\n        Tournament storage tournament = tournaments[tournamentId];\\n        uint voiceCredits = tournament.voiceCredits[voterId];\\n        if (voiceCredits \\u003e 0) {\\n            return voiceCredits;\\n        } else {\\n            return tournament.voiceUBI;\\n        }\\n    }\\n\\n    function getLastRoundVoted(uint tournamentId, uint voterId) public view returns (uint) {\\n        return identities[voterId].lastRoundVoted[tournamentId];\\n    }\\n\\n    function getVoteTotals(uint tournamentId, uint roundId, uint option) public view returns (uint) {\\n        return tournaments[tournamentId].rounds[roundId].voteTotals[option];\\n    }\\n\\n    function getVoteMetadata(uint tournamentId, uint roundId, uint voterId) public view returns (bytes32) {\\n        return tournaments[tournamentId].rounds[roundId].votes[voterId].metadataHash;\\n    }\\n\\n    function getVoiceUBI(uint tournamentId) public view  returns (uint)  {\\n        return tournaments[tournamentId].voiceUBI;\\n    }\\n\\n    function getRoundResults(uint voterId, uint tournamentId, uint roundId) public view returns (uint, uint) {\\n        Tournament storage tournament = tournaments[tournamentId];\\n        Round storage round = tournament.rounds[roundId];\\n        Vote storage thisVote = round.votes[voterId];\\n        return (thisVote.weights[round.winningOption], round.voteTotals[round.winningOption]);\\n    }\\n\\n    // this actually updates the voice credit balance to include the reward\\n    function getRoundBonus(uint voterId, uint tournamentId, uint roundId) public view returns (uint, uint) {\\n        Tournament storage tournament = tournaments[tournamentId];\\n        (uint voteWeight, uint totalVotes) = getRoundResults(voterId, tournamentId, roundId);\\n        uint tokenBonus = 0;\\n        // if this is the first round voterId has voted in, totalVotes will be 0\\n        if (totalVotes \\u003e 0) {\\n            tokenBonus = tournament.tokenRoundBonus.times(voteWeight) / totalVotes;\\n        }\\n        uint voiceCreditBonus = voteWeight.times(voteWeight);\\n        return (voiceCreditBonus, tokenBonus);\\n    }\\n\\n    function isSynced(uint voterId, uint tournamentId, uint roundId) public view returns (bool) {\\n        return syncMap[voterId][tournamentId][roundId];\\n    }\\n\\n    function roundAlreadyResolved(uint tournamentId, uint roundId) public view returns (bool) {\\n        return tournaments[tournamentId].rounds[roundId].winningOption \\u003e 0;\\n    }\\n\\n/**\\n====================================== SETTERS ==========================================================\\n**/\\n\\n    // change the site hash\\n    function setSiteHash(bytes32 newHash) public managementOnly {\\n        bytes32 oldHash = siteHash;\\n        siteHash = newHash;\\n        emit SiteHashUpdated(oldHash, newHash);\\n    }\\n\\n    function setRank(uint voterId, uint newRank) public {\\n        require(msg.sender == rankManager, \\u0027Only rankManager may call this\\u0027);\\n        IdMetadata storage id = identities[voterId];\\n        uint oldRank = id.rank;\\n        id.rank = newRank;\\n        emit RankUpdated(voterId, oldRank, newRank);\\n    }\\n\\n    function setToken(address tokenAddr) public managementOnly {\\n        token = IERC20(tokenAddr);\\n    }\\n\\n    function updateTournament(uint tournamentId, bytes32 newMetadata, uint newBonus,  uint newMinRank, uint newUBI, bytes32 newTokenList, address newOracle) public managementOnly {\\n        Tournament storage tournament = tournaments[tournamentId];\\n        tournament.metadataHash = newMetadata;\\n        // no changing round length\\n        tournament.tokenRoundBonus = newBonus;\\n        tournament.minimumRank = newMinRank;\\n        tournament.voiceUBI = newUBI;\\n        tournament.tokenListENS = newTokenList;\\n        tournament.winnerOracle = newOracle;\\n        emit TournamentUpdated(tournamentId, newMetadata, newBonus, newMinRank, newUBI, newTokenList, newOracle);\\n    }\\n\\n    function setRankManager(address newManager) public managementOnly {\\n        address oldManager = rankManager;\\n        rankManager = newManager;\\n        emit RankManagerUpdated(oldManager, newManager);\\n    }\\n\\n    // change the management key\\n    function setManagement(address newMgmt) public managementOnly {\\n        address oldMgmt =  management;\\n        management = newMgmt;\\n        emit ManagementUpdated(oldMgmt, newMgmt);\\n    }\\n\\n\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rankMgmt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"}],\"name\":\"AccountSynced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManagement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManagement\",\"type\":\"address\"}],\"name\":\"ManagementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"RankManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRank\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRank\",\"type\":\"uint256\"}],\"name\":\"RankUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningChoice\",\"type\":\"uint256\"}],\"name\":\"RoundResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"oldSiteHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newSiteHash\",\"type\":\"bytes32\"}],\"name\":\"SiteHashUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"metadataHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundLengthSeconds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenRoundBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumRank\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voiceUBI\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tokenListENS\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winnerOracle\",\"type\":\"address\"}],\"name\":\"TournamentCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"metadataHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenRoundBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumRank\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voiceUBI\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tokenListENS\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winnerOracle\",\"type\":\"address\"}],\"name\":\"TournamentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"choices\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"metadata\",\"type\":\"bytes32\"}],\"name\":\"VoteOccurred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundLengthSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenRoundBonus\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"tokenListENS\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voiceUBI\",\"type\":\"uint256\"}],\"name\":\"createTournament\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"}],\"name\":\"getCurrentRoundId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"}],\"name\":\"getLastRoundVoted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRound\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundResults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"}],\"name\":\"getVoiceCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"}],\"name\":\"getVoiceUBI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"}],\"name\":\"getVoteMetadata\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"option\",\"type\":\"uint256\"}],\"name\":\"getVoteTotals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"identities\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rank\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identity\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"isSynced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTournaments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rankManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winningOption\",\"type\":\"uint256\"}],\"name\":\"resolveRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"roundAlreadyResolved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newRank\",\"type\":\"uint256\"}],\"name\":\"setRank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"setRankManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newHash\",\"type\":\"bytes32\"}],\"name\":\"setSiteHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"siteHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"syncMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensWon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tournaments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"metadataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundLengthSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenRoundBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voiceUBI\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"tokenListENS\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"winnerOracle\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"updateAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"newMetadata\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"newBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMinRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newUBI\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"newTokenList\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateTournament\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"choices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"updateRoundId\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voterId\",\"type\":\"uint256\"}],\"name\":\"withdrawWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Trollbox","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b000000000000000000000000f779cae120093807985d5f2e7dbb21d69be6b963","EVMVersion":"Default","Library":"SafeMathLib:82d7630c5eb722557de6d76575c9a7b8de718500","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://42f74405702980323afab94db50beadc8fc4f8208ecf1f53657b1c124acf0156"}]}