{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.8;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IENS {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function setRecord(\r\n        bytes32 node,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external;\r\n\r\n    function setSubnodeRecord(\r\n        bytes32 node,\r\n        bytes32 label,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external;\r\n\r\n    function setSubnodeOwner(\r\n        bytes32 node,\r\n        bytes32 label,\r\n        address owner\r\n    ) external returns (bytes32);\r\n\r\n    function setResolver(bytes32 node, address resolver) external;\r\n\r\n    function setOwner(bytes32 node, address owner) external;\r\n\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function owner(bytes32 node) external view returns (address);\r\n\r\n    function resolver(bytes32 node) external view returns (address);\r\n\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n\r\n    function recordExists(bytes32 node) external view returns (bool);\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\ninterface IENSResolver {\r\n    event AddrChanged(bytes32 indexed _node, address _addr);\r\n    event NameChanged(bytes32 indexed _node, string _name);\r\n\r\n    function addr(bytes32 _node) external view returns (address);\r\n\r\n    function setAddr(bytes32 _node, address _addr) external;\r\n\r\n    function name(bytes32 _node) external view returns (string memory);\r\n\r\n    function setName(bytes32 _node, string calldata _name) external;\r\n}\r\n\r\ninterface IENSReverseRegistrar {\r\n    function claim(address _owner) external returns (bytes32);\r\n\r\n    function claimWithResolver(address _owner, address _resolver)\r\n        external\r\n        returns (bytes32);\r\n\r\n    function setName(string calldata _name) external returns (bytes32);\r\n\r\n    function node(address _addr) external pure returns (bytes32);\r\n}\r\n\r\ninterface IMirrorENSRegistrar {\r\n    function changeRootNodeOwner(address newOwner_) external;\r\n\r\n    function register(string calldata label_, address owner_) external;\r\n\r\n    function updateENSReverseRegistrar() external;\r\n}\r\n\r\ncontract MirrorENSRegistrar is IMirrorENSRegistrar, Ownable {\r\n    // ============ Constants ============\r\n\r\n    /**\r\n     * namehash('addr.reverse')\r\n     */\r\n    bytes32 public constant ADDR_REVERSE_NODE =\r\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n    // ============ Immutable Storage ============\r\n\r\n    /**\r\n     * The name of the ENS root, e.g. \"mirror.xyz\".\r\n     * @dev dependency injectable for testnet.\r\n     */\r\n    string public rootName;\r\n\r\n    /**\r\n     * The node of the root name (e.g. namehash(mirror.xyz))\r\n     */\r\n    bytes32 public immutable rootNode;\r\n\r\n    /**\r\n     * The address of the public ENS registry.\r\n     * @dev Dependency-injectable for testing purposes, but otherwise this is the\r\n     * canonical ENS registry at 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e.\r\n     */\r\n    IENS public immutable ensRegistry;\r\n\r\n    /**\r\n     * The address of the MirrorWriteToken that gates access to this namespace.\r\n     */\r\n    address public immutable writeToken;\r\n\r\n    /**\r\n     * The address of the MirrorENSResolver.\r\n     */\r\n    IENSResolver public immutable ensResolver;\r\n\r\n    // ============ Mutable Storage ============\r\n\r\n    /**\r\n     * Set by anyone to the correct address after configuration,\r\n     * to prevent a lookup on each registration.\r\n     */\r\n    IENSReverseRegistrar public reverseRegistrar;\r\n\r\n    // ============ Events ============\r\n\r\n    event RootNodeOwnerChange(bytes32 indexed node, address indexed owner);\r\n    event RegisteredENS(address indexed _owner, string _ens);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    /**\r\n     * @dev Modifier to check whether the `msg.sender` is the MirrorWriteToken.\r\n     * If it is, it will run the function. Otherwise, it will revert.\r\n     */\r\n    modifier onlyWriteToken() {\r\n        require(\r\n            msg.sender == writeToken,\r\n            \"MirrorENSRegistrar: caller is not the Mirror Write Token\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ============ Constructor ============\r\n\r\n    /**\r\n     * @notice Constructor that sets the ENS root name and root node to manage.\r\n     * @param rootName_ The root name (e.g. mirror.xyz).\r\n     * @param rootNode_ The node of the root name (e.g. namehash(mirror.xyz)).\r\n     * @param ensRegistry_ The address of the ENS registry\r\n     * @param ensResolver_ The address of the ENS resolver\r\n     * @param writeToken_ The address of the Mirror Write Token\r\n     */\r\n    constructor(\r\n        string memory rootName_,\r\n        bytes32 rootNode_,\r\n        address ensRegistry_,\r\n        address ensResolver_,\r\n        address writeToken_\r\n    ) public {\r\n        rootName = rootName_;\r\n        rootNode = rootNode_;\r\n\r\n        writeToken = writeToken_;\r\n\r\n        // Registrations are cheaper if these are instantiated.\r\n        ensRegistry = IENS(ensRegistry_);\r\n        ensResolver = IENSResolver(ensResolver_);\r\n    }\r\n\r\n    // ============ Registration ============\r\n\r\n    /**\r\n     * @notice Assigns an ENS subdomain of the root node to a target address.\r\n     * Registers both the forward and reverse ENS. Can only be called by writeToken.\r\n     * @param label_ The subdomain label.\r\n     * @param owner_ The owner of the subdomain.\r\n     */\r\n    function register(string calldata label_, address owner_)\r\n        external\r\n        override\r\n        onlyWriteToken\r\n    {\r\n        bytes32 labelNode = keccak256(abi.encodePacked(label_));\r\n        bytes32 node = keccak256(abi.encodePacked(rootNode, labelNode));\r\n\r\n        require(\r\n            ensRegistry.owner(node) == address(0),\r\n            \"MirrorENSManager: label is already owned\"\r\n        );\r\n\r\n        // Forward ENS\r\n        ensRegistry.setSubnodeRecord(\r\n            rootNode,\r\n            labelNode,\r\n            owner_,\r\n            address(ensResolver),\r\n            0\r\n        );\r\n        ensResolver.setAddr(node, owner_);\r\n\r\n        // Reverse ENS\r\n        string memory name = string(abi.encodePacked(label_, \".\", rootName));\r\n        bytes32 reverseNode = reverseRegistrar.node(owner_);\r\n        ensResolver.setName(reverseNode, name);\r\n\r\n        emit RegisteredENS(owner_, name);\r\n    }\r\n\r\n    // ============ ENS Management ============\r\n\r\n    /**\r\n     * @notice This function must be called when the ENS Manager contract is replaced\r\n     * and the address of the new Manager should be provided.\r\n     * @param _newOwner The address of the new ENS manager that will manage the root node.\r\n     */\r\n    function changeRootNodeOwner(address _newOwner)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        ensRegistry.setOwner(rootNode, _newOwner);\r\n        emit RootNodeOwnerChange(rootNode, _newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates to the reverse registrar.\r\n     */\r\n    function updateENSReverseRegistrar() external override onlyOwner {\r\n        reverseRegistrar = IENSReverseRegistrar(\r\n            ensRegistry.owner(ADDR_REVERSE_NODE)\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"rootName_\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"rootNode_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"ensRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ensResolver_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"writeToken_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_ens\",\"type\":\"string\"}],\"name\":\"RegisteredENS\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RootNodeOwnerChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADDR_REVERSE_NODE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeRootNodeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensRegistry\",\"outputs\":[{\"internalType\":\"contract IENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensResolver\",\"outputs\":[{\"internalType\":\"contract IENSResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"label_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reverseRegistrar\",\"outputs\":[{\"internalType\":\"contract IENSReverseRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootNode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateENSReverseRegistrar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"writeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MirrorENSRegistrar","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a0a9a87f735d649722c441b5aa3cee9a93786cf4db5f44ef19610909403326b39700000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e0000000000000000000000004184dd6ad5d68cc88dd736b31707df0e1c265e9e000000000000000000000000622236bb180256b6ae1a935dae08dc0356141632000000000000000000000000000000000000000000000000000000000000000b6d6972726f722e74657374000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://959146db9b06917e4cbea1d4b61b3ef49a7d1575abb54fe393ad1ccdb041fa97"}]}