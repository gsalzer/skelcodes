{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\modules\\Ownable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\whiteList.sol\r\n\r\npragma solidity =0.5.16;\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint32.\r\n     */\r\nlibrary whiteListUint32 {\r\n    /**\r\n     * @dev add uint32 into white list.\r\n     * @param whiteList the storage whiteList.\r\n     * @param temp input value\r\n     */\r\n\r\n    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\r\n        if (!isEligibleUint32(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    /**\r\n     * @dev remove uint32 from whitelist.\r\n     */\r\n    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint256.\r\n     */\r\nlibrary whiteListUint256 {\r\n    // add whiteList\r\n    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\r\n        if (!isEligibleUint256(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible address.\r\n     */\r\nlibrary whiteListAddress {\r\n    // add whiteList\r\n    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\r\n        if (!isEligibleAddress(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Operator.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * each operator can be granted exclusive access to specific functions.\r\n *\r\n */\r\ncontract Operator is Ownable {\r\n    using whiteListAddress for address[];\r\n    address[] private _operatorList;\r\n    /**\r\n     * @dev modifier, every operator can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyOperator() {\r\n        require(_operatorList.isEligibleAddress(msg.sender),\"Managerable: caller is not the Operator\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev modifier, Only indexed operator can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyOperatorIndex(uint256 index) {\r\n        require(_operatorList.length>index && _operatorList[index] == msg.sender,\"Operator: caller is not the eligible Operator\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev add a new operator by owner. \r\n     *\r\n     */\r\n    function addOperator(address addAddress)public onlyOwner{\r\n        _operatorList.addWhiteListAddress(addAddress);\r\n    }\r\n    /**\r\n     * @dev modify indexed operator by owner. \r\n     *\r\n     */\r\n    function setOperator(uint256 index,address addAddress)public onlyOwner{\r\n        _operatorList[index] = addAddress;\r\n    }\r\n    /**\r\n     * @dev remove operator by owner. \r\n     *\r\n     */\r\n    function removeOperator(address removeAddress)public onlyOwner returns (bool){\r\n        return _operatorList.removeWhiteListAddress(removeAddress);\r\n    }\r\n    /**\r\n     * @dev get all operators. \r\n     *\r\n     */\r\n    function getOperator()public view returns (address[] memory) {\r\n        return _operatorList;\r\n    }\r\n    /**\r\n     * @dev set all operators by owner. \r\n     *\r\n     */\r\n    function setOperators(address[] memory operators)public onlyOwner {\r\n        _operatorList = operators;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\SmallNumbers.sol\r\n\r\npragma solidity =0.5.16;\r\n    /**\r\n     * @dev Implementation of a Fraction number operation library.\r\n     */\r\nlibrary SmallNumbers {\r\n//    using Fraction for fractionNumber;\r\n    int256 constant private sqrtNum = 1<<120;\r\n    int256 constant private shl = 80;\r\n    uint8 constant private PRECISION   = 32;  // fractional bits\r\n    uint256 constant public FIXED_ONE = uint256(1) << PRECISION; // 0x100000000\r\n    int256 constant public FIXED_64 = 1 << 64; // 0x100000000\r\n    uint256 constant private FIXED_TWO = uint256(2) << PRECISION; // 0x200000000\r\n    int256 constant private FIXED_SIX = int256(6) << PRECISION; // 0x200000000\r\n    uint256 constant private MAX_VAL   = uint256(1) << (256 - PRECISION); // 0x0000000100000000000000000000000000000000000000000000000000000000\r\n\r\n    /**\r\n     * @dev Standard normal cumulative distribution function\r\n     */\r\n    function normsDist(int256 xNum) internal pure returns (int256) {\r\n        bool _isNeg = xNum<0;\r\n        if (_isNeg) {\r\n            xNum = -xNum;\r\n        }\r\n        if (xNum > FIXED_SIX){\r\n            return _isNeg ? 0 : int256(FIXED_ONE);\r\n        } \r\n        // constant int256 b1 = 1371733226;\r\n        // constant int256 b2 = -1531429783;\r\n        // constant int256 b3 = 7651389478;\r\n        // constant int256 b4 = -7822234863;\r\n        // constant int256 b5 = 5713485167;\r\n        //t = 1.0/(1.0 + p*x);\r\n        int256 p = 994894385;\r\n        int256 t = FIXED_64/(((p*xNum)>>PRECISION)+int256(FIXED_ONE));\r\n        //double val = 1 - (1/(Math.sqrt(2*Math.PI))  * Math.exp(-1*Math.pow(a, 2)/2)) * (b1*t + b2 * Math.pow(t,2) + b3*Math.pow(t,3) + b4 * Math.pow(t,4) + b5 * Math.pow(t,5) );\r\n        //1.0 - (-x * x / 2.0).exp()/ (2.0*pi()).sqrt() * t * (a1 + t * (-0.356563782 + t * (1.781477937 + t * (-1.821255978 + t * 1.330274429)))) ;\r\n        xNum=xNum*xNum/int256(FIXED_TWO);\r\n        xNum = int256(7359186145390886912/fixedExp(uint256(xNum)));\r\n        int256 tt = t;\r\n        int256 All = 1371733226*tt;\r\n        tt = (tt*t)>>PRECISION;\r\n        All += -1531429783*tt;\r\n        tt = (tt*t)>>PRECISION;\r\n        All += 7651389478*tt;\r\n        tt = (tt*t)>>PRECISION;\r\n        All += -7822234863*tt;\r\n        tt = (tt*t)>>PRECISION;\r\n        All += 5713485167*tt;\r\n        xNum = (xNum*All)>>64;\r\n        if (!_isNeg) {\r\n            xNum = uint64(FIXED_ONE) - xNum;\r\n        }\r\n        return xNum;\r\n    }\r\n    function pow(uint256 _x,uint256 _y) internal pure returns (uint256){\r\n        _x = (ln(_x)*_y)>>PRECISION;\r\n        return fixedExp(_x);\r\n    }\r\n\r\n    //This is where all your gas goes, sorry\r\n    //Not sorry, you probably only paid 1 gwei\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        x = x << PRECISION;\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n    function ln(uint256 _x)  internal pure returns (uint256) {\r\n        return fixedLoge(_x);\r\n    }\r\n        /**\r\n        input range: \r\n            [0x100000000,uint256_max]\r\n        output range:\r\n            [0, 0x9b43d4f8d6]\r\n\r\n        This method asserts outside of bounds\r\n\r\n    */\r\n    function fixedLoge(uint256 _x) internal pure returns (uint256 logE) {\r\n        /*\r\n        Since `fixedLog2_min` output range is max `0xdfffffffff` \r\n        (40 bits, or 5 bytes), we can use a very large approximation\r\n        for `ln(2)`. This one is used since it’s the max accuracy \r\n        of Python `ln(2)`\r\n\r\n        0xb17217f7d1cf78 = ln(2) * (1 << 56)\r\n        \r\n        */\r\n        //Cannot represent negative numbers (below 1)\r\n        require(_x >= FIXED_ONE,\"loge function input is too small\");\r\n\r\n        uint256 _log2 = fixedLog2(_x);\r\n        logE = (_log2 * 0xb17217f7d1cf78) >> 56;\r\n    }\r\n\r\n    /**\r\n        Returns log2(x >> 32) << 32 [1]\r\n        So x is assumed to be already upshifted 32 bits, and \r\n        the result is also upshifted 32 bits. \r\n        \r\n        [1] The function returns a number which is lower than the \r\n        actual value\r\n\r\n        input-range : \r\n            [0x100000000,uint256_max]\r\n        output-range: \r\n            [0,0xdfffffffff]\r\n\r\n        This method asserts outside of bounds\r\n\r\n    */\r\n    function fixedLog2(uint256 _x) internal pure returns (uint256) {\r\n        // Numbers below 1 are negative. \r\n        require( _x >= FIXED_ONE,\"Log2 input is too small\");\r\n\r\n        uint256 hi = 0;\r\n        while (_x >= FIXED_TWO) {\r\n            _x >>= 1;\r\n            hi += FIXED_ONE;\r\n        }\r\n\r\n        for (uint8 i = 0; i < PRECISION; ++i) {\r\n            _x = (_x * _x) / FIXED_ONE;\r\n            if (_x >= FIXED_TWO) {\r\n                _x >>= 1;\r\n                hi += uint256(1) << (PRECISION - 1 - i);\r\n            }\r\n        }\r\n\r\n        return hi;\r\n    }\r\n    function exp(int256 _x)internal pure returns (uint256){\r\n        bool _isNeg = _x<0;\r\n        if (_isNeg) {\r\n            _x = -_x;\r\n        }\r\n        uint256 value = fixedExp(uint256(_x));\r\n        if (_isNeg){\r\n            return uint256(FIXED_64) / value;\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n        fixedExp is a ‘protected’ version of `fixedExpUnsafe`, which \r\n        asserts instead of overflows\r\n    */\r\n    function fixedExp(uint256 _x) internal pure returns (uint256) {\r\n        require(_x <= 0x386bfdba29,\"exp function input is overflow\");\r\n        return fixedExpUnsafe(_x);\r\n    }\r\n       /**\r\n        fixedExp \r\n        Calculates e^x according to maclauren summation:\r\n\r\n        e^x = 1+x+x^2/2!...+x^n/n!\r\n\r\n        and returns e^(x>>32) << 32, that is, upshifted for accuracy\r\n\r\n        Input range:\r\n            - Function ok at    <= 242329958953 \r\n            - Function fails at >= 242329958954\r\n\r\n        This method is is visible for testcases, but not meant for direct use. \r\n \r\n        The values in this method been generated via the following python snippet: \r\n\r\n        def calculateFactorials():\r\n            “”\"Method to print out the factorials for fixedExp”“”\r\n\r\n            ni = []\r\n            ni.append( 295232799039604140847618609643520000000) # 34!\r\n            ITERATIONS = 34\r\n            for n in range( 1,  ITERATIONS,1 ) :\r\n                ni.append(math.floor(ni[n - 1] / n))\r\n            print( “\\n        “.join([“xi = (xi * _x) >> PRECISION;\\n        res += xi * %s;” % hex(int(x)) for x in ni]))\r\n\r\n    */\r\n    function fixedExpUnsafe(uint256 _x) internal pure returns (uint256) {\r\n    \r\n        uint256 xi = FIXED_ONE;\r\n        uint256 res = 0xde1bc4d19efcac82445da75b00000000 * xi;\r\n\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xde1bc4d19efcb0000000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x6f0de268cf7e58000000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x2504a0cd9a7f72000000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x9412833669fdc800000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x1d9d4d714865f500000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x4ef8ce836bba8c0000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xb481d807d1aa68000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x16903b00fa354d000000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x281cdaac677b3400000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x402e2aad725eb80000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x5d5a6c9f31fe24000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x7c7890d442a83000000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x9931ed540345280000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xaf147cf24ce150000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xbac08546b867d000000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xbac08546b867d00000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xafc441338061b8000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x9c3cabbc0056e000000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x839168328705c80000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x694120286c04a0000;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x50319e98b3d2c400;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x3a52a1e36b82020;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x289286e0fce002;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x1b0c59eb53400;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x114f95b55400;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0xaa7210d200;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x650139600;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x39b78e80;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x1fd8080;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x10fbc0;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x8c40;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x462;\r\n        xi = (xi * _x) >> PRECISION;\r\n        res += xi * 0x22;\r\n\r\n        return res / 0xde1bc4d19efcac82445da75b00000000;\r\n    }  \r\n}\r\n\r\n// File: contracts\\impliedVolatility.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @title Options Implied volatility calculation.\r\n * @dev A Smart-contract to calculate options Implied volatility.\r\n *\r\n */\r\ncontract ImpliedVolatility is Operator {\r\n    //Implied volatility decimal, is same with oracle's price' decimal. \r\n    uint256 constant private _calDecimal = 1e8;\r\n    // A constant day time\r\n    uint256 constant private DaySecond = 1 days;\r\n    // Formulas param, atm Implied volatility, which expiration is one day.\r\n    struct ivParam {\r\n        int48 a;\r\n        int48 b;\r\n        int48 c;\r\n        int48 d;\r\n        int48 e; \r\n    }\r\n    mapping(uint32=>uint256) internal ATMIv0;\r\n    // Formulas param A,B,C,D,E\r\n    mapping(uint32=>ivParam) internal ivParamMap;\r\n    // Formulas param ATM Iv Rate, sort by time\r\n    mapping(uint32=>uint64[]) internal ATMIvRate;\r\n\r\n    constructor () public{\r\n        ATMIv0[1] = 48730000;\r\n        ivParamMap[1] = ivParam(-38611755991,38654705664,-214748365,214748365,4294967296);\r\n        ATMIvRate[1] = [4294967296,4446428991,4537492540,4603231970,4654878626,4697506868,4733852952,4765564595,4793712531,4819032567,\r\n                4842052517,4863164090,4882666130,4900791915,4917727094,4933621868,4948599505,4962762438,4976196728,4988975383,\r\n                5001160887,5012807130,5023960927,5034663202,5044949946,5054852979,5064400575,5073617969,5082527781,5091150366,\r\n                5099504108,5107605667,5115470191,5123111489,5130542192,5137773878,5144817188,5151681926,5158377145,5164911220,\r\n                5171291916,5177526445,5183621518,5189583392,5195417907,5201130526,5206726363,5212210216,5217586590,5222859721,\r\n                5228033600,5233111985,5238098426,5242996276,5247808706,5252538720,5257189164,5261762736,5266262001,5270689395,\r\n                5275047237,5279337732,5283562982,5287724992,5291825675,5295866857,5299850284,5303777626,5307650478,5311470372,\r\n                5315238771,5318957082,5322626652,5326248774,5329824691,5333355597,5336842639,5340286922,5343689509,5347051421,\r\n                5350373645,5353657131,5356902795,5360111520,5363284160,5366421536,5369524445,5372593655,5375629909,5378633924];\r\n        ATMIv0[2] = 48730000;\r\n        ivParamMap[2] = ivParam(-38611755991,38654705664,-214748365,214748365,4294967296);\r\n        ATMIvRate[2] =  ATMIvRate[1];\r\n        //mkr\r\n        ATMIv0[3] = 150000000;\r\n        ivParamMap[3] = ivParam(-38611755991,38654705664,-214748365,214748365,4294967296);\r\n        ATMIvRate[3] =  ATMIvRate[1];\r\n        //snx\r\n        ATMIv0[4] = 200000000;\r\n        ivParamMap[4] = ivParam(-38611755991,38654705664,-214748365,214748365,4294967296);\r\n        ATMIvRate[4] =  ATMIvRate[1];\r\n        //link\r\n        ATMIv0[5] = 180000000;\r\n        ivParamMap[5] = ivParam(-38611755991,38654705664,-214748365,214748365,4294967296);\r\n        ATMIvRate[5] =  ATMIvRate[1];\r\n    }\r\n    /**\r\n     * @dev set underlying's atm implied volatility. Foundation operator will modify it frequently.\r\n     * @param underlying underlying ID.,1 for BTC, 2 for ETH\r\n     * @param _Iv0 underlying's atm implied volatility. \r\n     */ \r\n    function SetAtmIv(uint32 underlying,uint256 _Iv0)public onlyOperatorIndex(0){\r\n        ATMIv0[underlying] = _Iv0;\r\n    }\r\n    function getAtmIv(uint32 underlying)public view returns(uint256){\r\n        return ATMIv0[underlying];\r\n    }\r\n    /**\r\n     * @dev set implied volatility surface Formulas param. \r\n     * @param underlying underlying ID.,1 for BTC, 2 for ETH\r\n     */ \r\n    function SetFormulasParam(uint32 underlying,int48 _paramA,int48 _paramB,int48 _paramC,int48 _paramD,int48 _paramE)\r\n        public onlyOwner{\r\n        ivParamMap[underlying] = ivParam(_paramA,_paramB,_paramC,_paramD,_paramE);\r\n    }\r\n    /**\r\n     * @dev set implied volatility surface Formulas param IvRate. \r\n     * @param underlying underlying ID.,1 for BTC, 2 for ETH\r\n     */ \r\n    function SetATMIvRate(uint32 underlying,uint64[] memory IvRate)public onlyOwner{\r\n        ATMIvRate[underlying] = IvRate;\r\n    }\r\n    /**\r\n     * @dev Interface, calculate option's iv. \r\n     * @param underlying underlying ID.,1 for BTC, 2 for ETH\r\n     * optType option's type.,0 for CALL, 1 for PUT\r\n     * @param expiration Option's expiration, left time to now.\r\n     * @param currentPrice underlying current price\r\n     * @param strikePrice option's strike price\r\n     */ \r\n    function calculateIv(uint32 underlying,uint8 /*optType*/,uint256 expiration,uint256 currentPrice,uint256 strikePrice)public view returns (uint256){\r\n        if (underlying>2){\r\n            return (ATMIv0[underlying]<<32)/_calDecimal;\r\n        }\r\n        uint256 iv = calATMIv(underlying,expiration);\r\n        if (currentPrice == strikePrice){\r\n            return iv;\r\n        }\r\n        return calImpliedVolatility(underlying,iv,currentPrice,strikePrice);\r\n    }\r\n    /**\r\n     * @dev calculate option's atm iv. \r\n     * @param underlying underlying ID.,1 for BTC, 2 for ETH\r\n     * @param expiration Option's expiration, left time to now.\r\n     */ \r\n    function calATMIv(uint32 underlying,uint256 expiration)internal view returns(uint256){\r\n        uint256 index = expiration/DaySecond;\r\n        \r\n        if (index == 0){\r\n            return (ATMIv0[underlying]<<32)/_calDecimal;\r\n        }\r\n        uint256 len = ATMIvRate[underlying].length;\r\n        if (index>=len){\r\n            index = len-1;\r\n        }\r\n        uint256 rate = insertValue(index*DaySecond,(index+1)*DaySecond,ATMIvRate[underlying][index-1],ATMIvRate[underlying][index],expiration);\r\n        return ATMIv0[underlying]*rate/_calDecimal;\r\n    }\r\n    /**\r\n     * @dev calculate option's implied volatility. \r\n     * @param underlying underlying ID.,1 for BTC, 2 for ETH\r\n     * @param _ATMIv atm iv, calculated by calATMIv\r\n     * @param currentPrice underlying current price\r\n     * @param strikePrice option's strike price\r\n     */ \r\n    function calImpliedVolatility(uint32 underlying,uint256 _ATMIv,uint256 currentPrice,uint256 strikePrice)internal view returns(uint256){\r\n        ivParam memory param = ivParamMap[underlying];\r\n        int256 ln = calImpliedVolLn(underlying,currentPrice,strikePrice,param.d);\r\n        //ln*ln+e\r\n        uint256 lnSqrt = uint256(((ln*ln)>>32) + param.e);\r\n        lnSqrt = SmallNumbers.sqrt(lnSqrt);\r\n        //ln*c+sqrt\r\n        ln = ((ln*param.c)>>32) + int256(lnSqrt);\r\n        ln = (ln* param.b + int256(_ATMIv*_ATMIv))>>32;\r\n        return SmallNumbers.sqrt(uint256(ln+param.a));\r\n    }\r\n    /**\r\n     * @dev An auxiliary function, calculate ln price. \r\n     * @param underlying underlying ID.,1 for BTC, 2 for ETH\r\n     * @param currentPrice underlying current price\r\n     * @param strikePrice option's strike price\r\n     */ \r\n    //ln(k) - ln(s) + d\r\n    function calImpliedVolLn(uint32 underlying,uint256 currentPrice,uint256 strikePrice,int48 paramd)internal view returns(int256){\r\n        if (currentPrice == strikePrice){\r\n            return paramd;\r\n        }else if (currentPrice > strikePrice){\r\n            return int256(SmallNumbers.fixedLoge((currentPrice<<32)/strikePrice))+paramd;\r\n        }else{\r\n            return -int256(SmallNumbers.fixedLoge((strikePrice<<32)/currentPrice))+paramd;\r\n        }\r\n    }\r\n    /**\r\n     * @dev An auxiliary function, Linear interpolation. \r\n     */ \r\n    function insertValue(uint256 x0,uint256 x1,uint256 y0, uint256 y1,uint256 x)internal pure returns (uint256){\r\n        require(x1 != x0,\"input values are duplicated!\");\r\n        return y0 + (y1-y0)*(x-x0)/(x1-x0);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"underlying\",\"type\":\"uint32\"},{\"internalType\":\"uint64[]\",\"name\":\"IvRate\",\"type\":\"uint64[]\"}],\"name\":\"SetATMIvRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"underlying\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_Iv0\",\"type\":\"uint256\"}],\"name\":\"SetAtmIv\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"underlying\",\"type\":\"uint32\"},{\"internalType\":\"int48\",\"name\":\"_paramA\",\"type\":\"int48\"},{\"internalType\":\"int48\",\"name\":\"_paramB\",\"type\":\"int48\"},{\"internalType\":\"int48\",\"name\":\"_paramC\",\"type\":\"int48\"},{\"internalType\":\"int48\",\"name\":\"_paramD\",\"type\":\"int48\"},{\"internalType\":\"int48\",\"name\":\"_paramE\",\"type\":\"int48\"}],\"name\":\"SetFormulasParam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"underlying\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"}],\"name\":\"calculateIv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"underlying\",\"type\":\"uint32\"}],\"name\":\"getAtmIv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperator\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeAddress\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setOperators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ImpliedVolatility","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://81b3c07dbb2f9cc0ad81099bc3836679dba068b623dbfef07556390b6bfb4432"}]}