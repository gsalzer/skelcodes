{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\n\r\ncontract ERC20 {\r\n\r\n    function transferFrom (address,address, uint256) external returns (bool);\r\n\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed _to);\r\n\r\n    constructor(address _owner) public {\r\n        owner = _owner;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract Pausable is Owned {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n      require(!paused);\r\n      _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n      require(paused);\r\n      _;\r\n    }\r\n\r\n    function pause() onlyOwner whenNotPaused public {\r\n      paused = true;\r\n      emit Pause();\r\n    }\r\n\r\n    function unpause() onlyOwner whenPaused public {\r\n      paused = false;\r\n      emit Unpause();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract lockingContract is Pausable{\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    address public oldFessToken;  \r\n    address public newFessToken;\r\n\r\n    address public fessOwner;\r\n    \r\n    mapping (address => uint256) public tokens;\r\n    mapping (address => uint256) public claimedTokens;\r\n    mapping (address => uint256 ) public lockedAt;\r\n    mapping (address => uint256) public oldOrNeW;\r\n    mapping (address => uint256) public claimableToken;\r\n\r\n\r\n    constructor(address _oldTokens, address _newToken, address payable _ownerAddress) public Owned(_ownerAddress) {\r\n\r\n\r\n    oldFessToken = _oldTokens;\r\n    newFessToken = _newToken;\r\n\r\n\r\n    }\r\n\r\n\r\n   function setfessOwner (address _fessOwner) external onlyOwner returns (bool) {\r\n       \r\n       fessOwner = _fessOwner;\r\n       \r\n   }\r\n\r\n   function lockTokens (address [] calldata userAddress, uint256  [] calldata value, uint256 oldNew) external \r\n\r\n    {\r\n\r\n          require (oldNew == 1 || oldNew ==2);// 1 for old 2 for new\r\n          require(userAddress.length == value.length,\"Invalid Array\");\r\n\r\n\r\n          for (uint8 i = 0; i < userAddress.length; i++){\r\n\r\n            tokens[userAddress[i]] = value[i].mul(1 ether);\r\n            lockedAt[userAddress[i]] = now;\r\n            oldOrNeW[userAddress[i]] = oldNew; \r\n\r\n              \r\n          }\r\n          \r\n    }\r\n\r\n\r\n    function calculatePayout (address userAddress) public view returns (uint256) {\r\n    \r\n        if (tokens[userAddress] > 0){\r\n            \r\n        uint256 preSaleCycle = getCycle(userAddress);\r\n        uint256 onePercentOfInitialFund = tokens[userAddress].div(730);\r\n        \r\n        if(claimedTokens[userAddress] != onePercentOfInitialFund.mul(preSaleCycle)) {\r\n            \r\n        uint256 tokenToSend = onePercentOfInitialFund.mul(preSaleCycle).sub(claimedTokens[userAddress]);\r\n        return  tokenToSend;\r\n\r\n\r\n        }\r\n            \r\n            \r\n        } \r\n    \r\n    }\r\n\r\n\r\n   function payout() external returns (bool) {\r\n       \r\n        require(tokens[msg.sender] > 0, \"tokens not locked\");\r\n        require(now >= lockedAt[msg.sender].add(86400),\"Time period \"); //1 days\r\n\r\n        uint256 preSaleCycle = getCycle(msg.sender);\r\n        require (preSaleCycle > 0, \"cycle greater then zero\");\r\n        uint256 onePercentOfInitialFund = tokens[msg.sender].div(730);\r\n\r\n        if(claimedTokens[msg.sender] != onePercentOfInitialFund.mul(preSaleCycle)) {\r\n            \r\n        uint256 tokenToSend = onePercentOfInitialFund.mul(preSaleCycle).sub(claimedTokens[msg.sender]);\r\n        claimedTokens[msg.sender] = onePercentOfInitialFund.mul(preSaleCycle);\r\n\r\n        if (oldOrNeW[msg.sender] ==1) {\r\n\r\n        require(ERC20(oldFessToken).transferFrom(fessOwner,msg.sender,tokenToSend), \"token transfer failed\");            \r\n            \r\n        }\r\n        else if (oldOrNeW[msg.sender] ==1) {\r\n            \r\n        require(ERC20(newFessToken).transferFrom(fessOwner,msg.sender,tokenToSend), \"token transfer failed\");\r\n        \r\n        }\r\n        return true;\r\n\r\n        } else {\r\n            \r\n            revert ();\r\n        }       \r\n       \r\n       \r\n   } \r\n\r\n    /**\r\n     * @dev  get cycle for payout \r\n     */\r\n    function getCycle(address userAddress) internal view returns (uint256){\r\n     \r\n\r\n      uint256 cycle = now.sub(lockedAt[userAddress]);\r\n    \r\n     if(cycle <= 1 days) //should be greater then 1 day\r\n     {\r\n         return 0;\r\n     }\r\n     else if (cycle >= 1 days && cycle <= 730 days) //greater then 1 day  \r\n     {     \r\n    \r\n      uint256 secondsToHours = cycle.div(86400);//21600 6 hours\r\n      return secondsToHours;\r\n     \r\n     }\r\n\r\n    }    \r\n\r\n  \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldTokens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"calculatePayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimableToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fessOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"userAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"value\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"oldNew\",\"type\":\"uint256\"}],\"name\":\"lockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newFessToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldFessToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oldOrNeW\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fessOwner\",\"type\":\"address\"}],\"name\":\"setfessOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"lockingContract","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e09394f8ba642430ed448ca20f342ec7aa1ba2e1000000000000000000000000c4caedce7716c8a59ec60afb57e12889dfb74073000000000000000000000000d8e935e50b5684dea63bde8e0994708ab99cc121","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://fb3bc51b923e29edf79bf5f100f60e01f1477d04596148bff3793c2491fab029"}]}