{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IUniswapV2Pair {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function token0() external view returns (address);\r\n\r\n  function token1() external view returns (address);\r\n\r\n  function getReserves()\r\n    external\r\n    view\r\n    returns (\r\n      uint112 reserve0,\r\n      uint112 reserve1,\r\n      uint32 blockTimestampLast\r\n    );\r\n\r\n  function kLast() external view returns (uint256);\r\n\r\n  function factory() external view returns (address);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n  function feeTo() external view returns (address);\r\n}\r\n\r\n/************\r\n@title IPriceOracle interface\r\n@notice Interface for the Aave price oracle.*/\r\ninterface IPriceOracle {\r\n  /***********\r\n    @dev returns the asset price in ETH\r\n     */\r\n  function getAssetPrice(address _asset) external view returns (uint256);\r\n}\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n    require((z = x + y) >= x, 'ds-math-add-overflow');\r\n  }\r\n\r\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n    require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n  }\r\n\r\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n    require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n  }\r\n}\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n  uint256 public constant BONE = 10**18;\r\n  uint256 public constant TWO_BONES = 2 * 10**18;\r\n\r\n  /**\r\n   * @notice Returns the square root of an uint256 x using the Babylonian method\r\n   * @param y The number to calculate the sqrt from\r\n   * @param bone True when y has 18 decimals\r\n   */\r\n  function bsqrt(uint256 y, bool bone) internal pure returns (uint256 z) {\r\n    if (y > 3) {\r\n      z = y;\r\n      uint256 x = y / 2 + 1;\r\n      while (x < z) {\r\n        z = x;\r\n        if (bone) {\r\n          x = (bdiv(y, x) + x) / 2;\r\n        } else {\r\n          x = (y / x + x) / 2;\r\n        }\r\n      }\r\n    } else if (y != 0) {\r\n      z = 1;\r\n    }\r\n  }\r\n\r\n  function bmul(\r\n    uint256 a,\r\n    uint256 b //Bone mul\r\n  ) internal pure returns (uint256) {\r\n    uint256 c0 = a * b;\r\n    require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\r\n    uint256 c1 = c0 + (BONE / 2);\r\n    require(c1 >= c0, 'ERR_MUL_OVERFLOW');\r\n    uint256 c2 = c1 / BONE;\r\n    return c2;\r\n  }\r\n\r\n  function bdiv(\r\n    uint256 a,\r\n    uint256 b //Bone div\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, 'ERR_DIV_ZERO');\r\n    uint256 c0 = a * BONE;\r\n    require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\r\n    uint256 c1 = c0 + (b / 2);\r\n    require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\r\n    uint256 c2 = c1 / b;\r\n    return c2;\r\n  }\r\n}\r\n\r\n/** @title UniswapV2PriceProvider\r\n * @notice Price provider for a Uniswap V2 pair token\r\n * It calculates the price using Chainlink as an external price source and the pair's tokens reserves using the weighted arithmetic mean formula.\r\n * If there is a price deviation, instead of the reserves, it uses a weighted geometric mean with the constant invariant K.\r\n */\r\n\r\ncontract UniswapV2PriceProvider {\r\n  using SafeMath for uint256;\r\n\r\n  IUniswapV2Pair public immutable pair;\r\n  address[] public tokens;\r\n  bool[] public isPeggedToEth;\r\n  uint8[] public decimals;\r\n  IPriceOracle immutable priceOracle;\r\n  uint256 public immutable maxPriceDeviation;\r\n\r\n  /**\r\n   * UniswapV2PriceProvider constructor.\r\n   * @param _pair Uniswap V2 pair address.\r\n   * @param _isPeggedToEth For each token, true if it is pegged to ETH.\r\n   * @param _decimals Number of decimals for each token.\r\n   * @param _priceOracle Aave price oracle.\r\n   * @param _maxPriceDeviation Threshold of spot prices deviation: 10Ë†16 represents a 1% deviation.\r\n   */\r\n  constructor(\r\n    IUniswapV2Pair _pair,\r\n    bool[] memory _isPeggedToEth,\r\n    uint8[] memory _decimals,\r\n    IPriceOracle _priceOracle,\r\n    uint256 _maxPriceDeviation\r\n  ) public {\r\n    require(_isPeggedToEth.length == 2, 'ERR_INVALID_PEGGED_LENGTH');\r\n    require(_decimals.length == 2, 'ERR_INVALID_DECIMALS_LENGTH');\r\n    require(_decimals[0] <= 18 && _decimals[1] <= 18, 'ERR_INVALID_DECIMALS');\r\n    require(address(_priceOracle) != address(0), 'ERR_INVALID_PRICE_PROVIDER');\r\n    require(_maxPriceDeviation < Math.BONE, 'ERR_INVALID_PRICE_DEVIATION');\r\n\r\n    pair = _pair;\r\n    //Get tokens\r\n    tokens.push(_pair.token0());\r\n    tokens.push(_pair.token1());\r\n    isPeggedToEth = _isPeggedToEth;\r\n    decimals = _decimals;\r\n    priceOracle = _priceOracle;\r\n    maxPriceDeviation = _maxPriceDeviation;\r\n  }\r\n\r\n  /**\r\n   * Returns the token balance in ethers by multiplying its reserves with its price in ethers.\r\n   * @param index Token index.\r\n   * @param reserve Token reserves.\r\n   */\r\n  function getEthBalanceByToken(uint256 index, uint112 reserve) internal view returns (uint256) {\r\n    uint256 pi =\r\n      isPeggedToEth[index] ? Math.BONE : uint256(priceOracle.getAssetPrice(tokens[index]));\r\n    require(pi > 0, 'ERR_NO_ORACLE_PRICE');\r\n    uint256 missingDecimals = uint256(18).sub(decimals[index]);\r\n    uint256 bi = uint256(reserve).mul(10**(missingDecimals));\r\n    return Math.bmul(bi, pi);\r\n  }\r\n\r\n  /**\r\n   * Returns true if there is a price deviation.\r\n   * @param ethTotal_0 Total eth for token 0.\r\n   * @param ethTotal_1 Total eth for token 1.\r\n   */\r\n  function hasDeviation(uint256 ethTotal_0, uint256 ethTotal_1) internal view returns (bool) {\r\n    //Check for a price deviation\r\n    uint256 price_deviation = Math.bdiv(ethTotal_0, ethTotal_1);\r\n    if (\r\n      price_deviation > (Math.BONE.add(maxPriceDeviation)) ||\r\n      price_deviation < (Math.BONE.sub(maxPriceDeviation))\r\n    ) {\r\n      return true;\r\n    }\r\n    price_deviation = Math.bdiv(ethTotal_1, ethTotal_0);\r\n    if (\r\n      price_deviation > (Math.BONE.add(maxPriceDeviation)) ||\r\n      price_deviation < (Math.BONE.sub(maxPriceDeviation))\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Calculates the price of the pair token using the formula of arithmetic mean.\r\n   * @param ethTotal_0 Total eth for token 0.\r\n   * @param ethTotal_1 Total eth for token 1.\r\n   */\r\n  function getArithmeticMean(uint256 ethTotal_0, uint256 ethTotal_1)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint256 totalEth = ethTotal_0 + ethTotal_1;\r\n    return Math.bdiv(totalEth, getTotalSupplyAtWithdrawal());\r\n  }\r\n\r\n  /**\r\n   * Calculates the price of the pair token using the formula of weighted geometric mean.\r\n   * @param ethTotal_0 Total eth for token 0.\r\n   * @param ethTotal_1 Total eth for token 1.\r\n   */\r\n  function getWeightedGeometricMean(uint256 ethTotal_0, uint256 ethTotal_1)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint256 square = Math.bsqrt(Math.bmul(ethTotal_0, ethTotal_1), true);\r\n    return Math.bdiv(Math.bmul(Math.TWO_BONES, square), getTotalSupplyAtWithdrawal());\r\n  }\r\n\r\n  /**\r\n   * Returns the pair's token price.\r\n   * It calculates the price using Chainlink as an external price source and the pair's tokens reserves using the arithmetic mean formula.\r\n   * If there is a price deviation, instead of the reserves, it uses a weighted geometric mean with constant invariant K.\r\n   */\r\n  function latestAnswer() external view returns (uint256) {\r\n    //Get token reserves in ethers\r\n    (uint112 reserve_0, uint112 reserve_1, ) = pair.getReserves();\r\n    uint256 ethTotal_0 = getEthBalanceByToken(0, reserve_0);\r\n    uint256 ethTotal_1 = getEthBalanceByToken(1, reserve_1);\r\n\r\n    if (hasDeviation(ethTotal_0, ethTotal_1)) {\r\n      //Calculate the weighted geometric mean\r\n      return getWeightedGeometricMean(ethTotal_0, ethTotal_1);\r\n    } else {\r\n      //Calculate the arithmetic mean\r\n      return getArithmeticMean(ethTotal_0, ethTotal_1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns Uniswap V2 pair total supply at the time of withdrawal.\r\n   */\r\n  function getTotalSupplyAtWithdrawal() private view returns (uint256 totalSupply) {\r\n    totalSupply = pair.totalSupply();\r\n    address feeTo = IUniswapV2Factory(IUniswapV2Pair(pair).factory()).feeTo();\r\n    bool feeOn = feeTo != address(0);\r\n    if (feeOn) {\r\n      uint256 kLast = IUniswapV2Pair(pair).kLast();\r\n      if (kLast != 0) {\r\n        (uint112 reserve_0, uint112 reserve_1, ) = pair.getReserves();\r\n        uint256 rootK = Math.bsqrt(uint256(reserve_0).mul(reserve_1), false);\r\n        uint256 rootKLast = Math.bsqrt(kLast, false);\r\n        if (rootK > rootKLast) {\r\n          uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\r\n          uint256 denominator = rootK.mul(5).add(rootKLast);\r\n          uint256 liquidity = numerator / denominator;\r\n          totalSupply = totalSupply.add(liquidity);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns Uniswap V2 pair address.\r\n   */\r\n  function getPair() external view returns (IUniswapV2Pair) {\r\n    return pair;\r\n  }\r\n\r\n  /**\r\n   * Returns all tokens.\r\n   */\r\n  function getTokens() external view returns (address[] memory) {\r\n    return tokens;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"_isPeggedToEth\",\"type\":\"bool[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_decimals\",\"type\":\"uint8[]\"},{\"internalType\":\"contract IPriceOracle\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxPriceDeviation\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isPeggedToEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPriceDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniswapV2PriceProvider","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a478c2975ab1ea89e8196811f51a7b7ade33eb1100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000a50ba011c48153de246e5192c8f9258a2ba79ca900000000000000000000000000000000000000000000000000b1a2bc2ec50000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000012","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a27fe306bb30943950d1c36534f63c6b4dc6a7708415ed15f926391de2ac450e"}]}