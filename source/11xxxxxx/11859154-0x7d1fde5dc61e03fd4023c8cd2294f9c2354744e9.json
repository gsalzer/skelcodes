{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\modules\\SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Ownable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Halt.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\ncontract Halt is Ownable {\r\n    \r\n    bool private halted = false; \r\n    \r\n    modifier notHalted() {\r\n        require(!halted,\"This contract is halted\");\r\n        _;\r\n    }\r\n\r\n    modifier isHalted() {\r\n        require(halted,\"This contract is not halted\");\r\n        _;\r\n    }\r\n    \r\n    /// @notice function Emergency situation that requires \r\n    /// @notice contribution period to stop or not.\r\n    function setHalt(bool halt) \r\n        public \r\n        onlyOwner\r\n    {\r\n        halted = halt;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\whiteList.sol\r\n\r\npragma solidity >=0.5.16;\r\n/**\r\n * SPDX-License-Identifier: GPL-3.0-or-later\r\n * FinNexus\r\n * Copyright (C) 2020 FinNexus Options Protocol\r\n */\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint32.\r\n     */\r\nlibrary whiteListUint32 {\r\n    /**\r\n     * @dev add uint32 into white list.\r\n     * @param whiteList the storage whiteList.\r\n     * @param temp input value\r\n     */\r\n\r\n    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\r\n        if (!isEligibleUint32(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    /**\r\n     * @dev remove uint32 from whitelist.\r\n     */\r\n    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint256.\r\n     */\r\nlibrary whiteListUint256 {\r\n    // add whiteList\r\n    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\r\n        if (!isEligibleUint256(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible address.\r\n     */\r\nlibrary whiteListAddress {\r\n    // add whiteList\r\n    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\r\n        if (!isEligibleAddress(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Operator.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * each operator can be granted exclusive access to specific functions.\r\n *\r\n */\r\ncontract Operator is Ownable {\r\n    mapping(uint256=>address) private _operators;\r\n    /**\r\n     * @dev modifier, Only indexed operator can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyOperator(uint256 index) {\r\n        require(_operators[index] == msg.sender,\"Operator: caller is not the eligible Operator\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev modify indexed operator by owner. \r\n     *\r\n     */\r\n    function setOperator(uint256 index,address addAddress)public onlyOwner{\r\n        _operators[index] = addAddress;\r\n    }\r\n    function getOperator(uint256 index)public view returns (address) {\r\n        return _operators[index];\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\AddressWhiteList.sol\r\n\r\npragma solidity >=0.5.16;\r\n/**\r\n * SPDX-License-Identifier: GPL-3.0-or-later\r\n * FinNexus\r\n * Copyright (C) 2020 FinNexus Options Protocol\r\n */\r\n\r\n\r\n    /**\r\n     * @dev Implementation of a whitelist filters a eligible address.\r\n     */\r\ncontract AddressWhiteList is Halt {\r\n\r\n    using whiteListAddress for address[];\r\n    // The eligible adress list\r\n    address[] internal whiteList;\r\n    /**\r\n     * @dev Implementation of add an eligible address into the whitelist.\r\n     * @param addAddress new eligible address.\r\n     */\r\n    function addWhiteList(address addAddress)public onlyOwner{\r\n        whiteList.addWhiteListAddress(addAddress);\r\n    }\r\n    /**\r\n     * @dev Implementation of revoke an invalid address from the whitelist.\r\n     * @param removeAddress revoked address.\r\n     */\r\n    function removeWhiteList(address removeAddress)public onlyOwner returns (bool){\r\n        return whiteList.removeWhiteListAddress(removeAddress);\r\n    }\r\n    /**\r\n     * @dev Implementation of getting the eligible whitelist.\r\n     */\r\n    function getWhiteList()public view returns (address[] memory){\r\n        return whiteList;\r\n    }\r\n    /**\r\n     * @dev Implementation of testing whether the input address is eligible.\r\n     * @param tmpAddress input address for testing.\r\n     */    \r\n    function isEligibleAddress(address tmpAddress) public view returns (bool){\r\n        return whiteList.isEligibleAddress(tmpAddress);\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\ReentrancyGuard.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancyLock = false;\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancyLock);\r\n    reentrancyLock = true;\r\n    _;\r\n    reentrancyLock = false;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts\\modules\\initializable.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract initializable {\r\n\r\n    /**\r\n    * @dev Indicates that the contract has been initialized.\r\n    */\r\n    bool private initialized;\r\n\r\n    /**\r\n    * @dev Indicates that the contract is in the process of being initialized.\r\n    */\r\n    bool private initializing;\r\n\r\n    /**\r\n    * @dev Modifier to use in the initializer function of a contract.\r\n    */\r\n    modifier initializer() {\r\n        require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n        bool wasInitializing = initializing;\r\n        initializing = true;\r\n        initialized = true;\r\n\r\n        _;\r\n\r\n        initializing = wasInitializing;\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        uint256 cs;\r\n        assembly { cs := extcodesize(address) }\r\n        return cs == 0;\r\n    }\r\n}\r\n\r\n// File: contracts\\fixedMinePool\\fixedMinePoolData.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * SPDX-License-Identifier: GPL-3.0-or-later\r\n * FinNexus\r\n * Copyright (C) 2020 FinNexus Options Protocol\r\n */\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title new Finnexus Options Pool token mine pool.\r\n * @dev A smart-contract which distribute some mine coins when you stake some FPT-A and FPT-B coins.\r\n *      Users who both stake some FPT-A and FPT-B coins will get more bonus in mine pool.\r\n *      Users who Lock FPT-B coins will get several times than normal miners.\r\n */\r\ncontract fixedMinePoolData is initializable,Operator,Halt,AddressWhiteList,ReentrancyGuard {\r\n    //Special decimals for calculation\r\n    uint256 constant calDecimals = 1e18;\r\n\r\n    //The timestamp when the minepool begin.\r\n    uint256 internal _startTime;\r\n    //Single locked period duration.\r\n    uint256 internal constant _period = 90 days;\r\n    //The lock duration when user stake flexible FPT-B in this pool.\r\n    uint256 internal _flexibleExpired;\r\n\r\n    //The max locked peroid when user stake locked FPT-B coin.\r\n    uint256 constant internal _maxPeriod = 12;\r\n    //The max loop when user does nothing to this pool for long long time .\r\n    uint256 constant internal _maxLoop = 120;\r\n    //the mine distribution's ratio to FPT-A coin \r\n    uint256 constant internal _FPTARatio = 1000;\r\n    //the mine distribution's ratio to FPT-B coin \r\n    uint256 constant internal _FPTBRatio = 1000;\r\n    //the mine distribution's ratio to FPT-A and FPT-B coin repetition\r\n    uint256 constant internal _RepeatRatio = 20000;\r\n    //the accumulated weight each period has.\r\n    uint256 constant internal periodWeight = 1000;\r\n    uint256 constant internal baseWeight = 5000;\r\n\r\n    // FPT-A address\r\n    address internal _FPTA;\r\n    // FPT-B address\r\n    address internal _FPTB;\r\n\r\n    struct userInfo {\r\n        //user's FPT-A staked balance\r\n        uint256 _FPTABalance;\r\n        //user's FPT-B staked balance\r\n        uint256 _FPTBBalance;\r\n        //Period ID start at 1. if a PeriodID equals zero, it means your FPT-B is flexible staked.\r\n        //User's max locked period id;\r\n        uint256 maxPeriodID;\r\n        //User's max locked period timestamp. Flexible FPT-B is locked _flexibleExpired seconds;\r\n        uint256 lockedExpired;\r\n        //User's mine distribution.You can get base mine proportion by your distribution divided by total distribution.\r\n        uint256 distribution;\r\n        //User's settled mine coin balance.\r\n        mapping(address=>uint256) minerBalances;\r\n        //User's latest settled distribution net worth.\r\n        mapping(address=>uint256) minerOrigins;\r\n        //user's latest settlement period for each token.\r\n        mapping(address=>uint256) settlePeriod;\r\n    }\r\n    struct tokenMineInfo {\r\n        //mine distribution amount\r\n        uint256 mineAmount;\r\n        //mine distribution time interval\r\n        uint256 mineInterval;\r\n        //mine distribution first period\r\n        uint256 startPeriod;\r\n        //mine coin latest settlement time\r\n        uint256 latestSettleTime;\r\n        // total mine distribution till latest settlement time.\r\n        uint256 totalMinedCoin;\r\n        //latest distribution net worth;\r\n        uint256 minedNetWorth;\r\n        //period latest distribution net worth;\r\n        mapping(uint256=>uint256) periodMinedNetWorth;\r\n    }\r\n\r\n    //User's staking and mining info.\r\n    mapping(address=>userInfo) internal userInfoMap;\r\n    //each mine coin's mining info.\r\n    mapping(address=>tokenMineInfo) internal mineInfoMap;\r\n    //total weight distribution which is used to calculate total mined amount.\r\n    mapping(uint256=>uint256) internal weightDistributionMap;\r\n    //total Distribution\r\n    uint256 internal totalDistribution;\r\n\r\n    struct premiumDistribution {\r\n        //total premium distribution in each period\r\n        uint256 totalPremiumDistribution;\r\n        //User's premium distribution in each period\r\n        mapping(address=>uint256) userPremiumDistribution;\r\n\r\n    }\r\n    // premium mining info in each period.\r\n    mapping(uint256=>premiumDistribution) internal premiumDistributionMap;\r\n    //user's latest redeemed period index in the distributedPeriod list.\r\n    struct premiumInfo {\r\n        mapping(address=>uint256) lastPremiumIndex;\r\n        mapping(address=>uint256) premiumBalance;\r\n        //period id list which is already distributed by owner.\r\n        uint64[] distributedPeriod;\r\n        //total permium distributed by owner.\r\n        uint256 totalPremium;\r\n        //total premium distributed by owner in each period.\r\n        mapping(uint256=>uint256) periodPremium;\r\n    }\r\n    mapping(address=>premiumInfo) internal premiumMap;\r\n    address[] internal premiumCoinList;\r\n\r\n    /**\r\n     * @dev Emitted when `account` stake `amount` FPT-A coin.\r\n     */\r\n    event StakeFPTA(address indexed account,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `from` airdrop `recieptor` `amount` FPT-B coin.\r\n     */\r\n    event LockAirDrop(address indexed from,address indexed recieptor,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `account` stake `amount` FPT-B coin and locked `lockedPeriod` periods.\r\n     */\r\n    event StakeFPTB(address indexed account,uint256 amount,uint256 lockedPeriod);\r\n    /**\r\n     * @dev Emitted when `account` unstake `amount` FPT-A coin.\r\n     */\r\n    event UnstakeFPTA(address indexed account,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `account` unstake `amount` FPT-B coin.\r\n     */\r\n    event UnstakeFPTB(address indexed account,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `account` change `lockedPeriod` locked periods for FPT-B coin.\r\n     */\r\n    event ChangeLockedPeriod(address indexed account,uint256 lockedPeriod);\r\n    /**\r\n     * @dev Emitted when owner `account` distribute `amount` premium in `periodID` period.\r\n     */\r\n    event DistributePremium(address indexed account,address indexed premiumCoin,uint256 indexed periodID,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `account` redeem `amount` premium.\r\n     */\r\n    event RedeemPremium(address indexed account,address indexed premiumCoin,uint256 amount);\r\n\r\n    /**\r\n     * @dev Emitted when `account` redeem `value` mineCoins.\r\n     */\r\n    event RedeemMineCoin(address indexed account, address indexed mineCoin, uint256 value);\r\n\r\n}\r\n\r\n// File: contracts\\ERC20\\IERC20.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\modules\\Address.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call.value(value )(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\ERC20\\safeErc20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\fixedMinePool\\fixedMinePool.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * SPDX-License-Identifier: GPL-3.0-or-later\r\n * FinNexus\r\n * Copyright (C) 2020 FinNexus Options Protocol\r\n */\r\n\r\n\r\n\r\n\r\n/**\r\n * @title FNX period mine pool.\r\n * @dev A smart-contract which distribute some mine coins when user stake FPT-A and FPT-B coins.\r\n *\r\n */\r\ncontract fixedMinePool is fixedMinePoolData {\r\n    using SafeMath for uint256;\r\n    /**\r\n     * @dev constructor.\r\n     * @param FPTA FPT-A coin's address,staking coin\r\n     * @param FPTB FPT-B coin's address,staking coin\r\n     * @param startTime the start time when this mine pool begin.\r\n     */\r\n    constructor(address FPTA,address FPTB,uint256 startTime)public{\r\n        _FPTA = FPTA;\r\n        _FPTB = FPTB;\r\n        _startTime = startTime;\r\n        initialize();\r\n    }\r\n    /**\r\n     * @dev default function for foundation input miner coins.\r\n     */\r\n    function()external payable{\r\n\r\n    }\r\n    function update()public onlyOwner{\r\n    }\r\n    /**\r\n     * @dev initial function when the proxy contract deployed.\r\n     */\r\n    function initialize() initializer public {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n        _flexibleExpired = 15 days;\r\n    }\r\n    /**\r\n     * @dev setting function.\r\n     * @param FPTA FPT-A coin's address,staking coin\r\n     * @param FPTB FPT-B coin's address,staking coin\r\n     * @param startTime the start time when this mine pool begin.\r\n     */\r\n    function setAddresses(address FPTA,address FPTB,uint256 startTime) public onlyOwner {\r\n        _FPTA = FPTA;\r\n        _FPTB = FPTB;\r\n        _startTime = startTime;\r\n    }\r\n    /**\r\n     * @dev getting function. Retrieve FPT-A coin's address\r\n     */\r\n    function getFPTAAddress()public view returns (address) {\r\n        return _FPTA;\r\n    }\r\n    /**\r\n     * @dev getting function. Retrieve FPT-B coin's address\r\n     */\r\n    function getFPTBAddress()public view returns (address) {\r\n        return _FPTB;\r\n    }\r\n    /**\r\n     * @dev getting function. Retrieve mine pool's start time.\r\n     */\r\n    function getStartTime()public view returns (uint256) {\r\n        return _startTime;\r\n    }\r\n    /**\r\n     * @dev getting current mine period ID.\r\n     */\r\n    function getCurrentPeriodID()public view returns (uint256) {\r\n        return getPeriodIndex(currentTime());\r\n    }\r\n    /**\r\n     * @dev getting user's staking FPT-A balance.\r\n     * @param account user's account\r\n     */\r\n    function getUserFPTABalance(address account)public view returns (uint256) {\r\n        return userInfoMap[account]._FPTABalance;\r\n    }\r\n    /**\r\n     * @dev getting user's staking FPT-B balance.\r\n     * @param account user's account\r\n     */\r\n    function getUserFPTBBalance(address account)public view returns (uint256) {\r\n        return userInfoMap[account]._FPTBBalance;\r\n    }\r\n    /**\r\n     * @dev getting user's maximium locked period ID.\r\n     * @param account user's account\r\n     */\r\n    function getUserMaxPeriodId(address account)public view returns (uint256) {\r\n        return userInfoMap[account].maxPeriodID;\r\n    }\r\n    /**\r\n     * @dev getting user's locked expired time. After this time user can unstake FPTB coins.\r\n     * @param account user's account\r\n     */\r\n    function getUserExpired(address account)public view returns (uint256) {\r\n        return userInfoMap[account].lockedExpired;\r\n    }\r\n    /**\r\n     * @dev getting whole pool's mine production weight ratio.\r\n     *      Real mine production equals base mine production multiply weight ratio.\r\n     */\r\n    function getMineWeightRatio()public view returns (uint256) {\r\n        if(totalDistribution > 0) {\r\n            return getweightDistribution(getPeriodIndex(currentTime()))*1000/totalDistribution;\r\n        }else{\r\n            return 1000;\r\n        }\r\n    }\r\n    /**\r\n     * @dev getting whole pool's mine shared distribution. All these distributions will share base mine production.\r\n     */\r\n    function getTotalDistribution() public view returns (uint256){\r\n        return totalDistribution;\r\n    }\r\n    /**\r\n     * @dev foundation redeem out mine coins.\r\n     * @param mineCoin mineCoin address\r\n     * @param amount redeem amount.\r\n     */\r\n    function redeemOut(address mineCoin,uint256 amount)public onlyOwner{\r\n        _redeem(msg.sender,mineCoin,amount);\r\n    }\r\n    /**\r\n     * @dev An auxiliary foundation which transter amount mine coins to recieptor.\r\n     * @param recieptor recieptor recieptor's account.\r\n     * @param mineCoin mineCoin address\r\n     * @param amount redeem amount.\r\n     */\r\n    function _redeem(address payable recieptor,address mineCoin,uint256 amount) internal{\r\n        if (mineCoin == address(0)){\r\n            recieptor.transfer(amount);\r\n        }else{\r\n            IERC20 token = IERC20(mineCoin);\r\n            uint256 preBalance = token.balanceOf(address(this));\r\n            SafeERC20.safeTransfer(token,recieptor,amount);\r\n//            token.transfer(recieptor,amount);\r\n            uint256 afterBalance = token.balanceOf(address(this));\r\n            require(preBalance - afterBalance == amount,\"settlement token transfer error!\");\r\n        }\r\n    }\r\n    /**\r\n     * @dev retrieve total distributed mine coins.\r\n     * @param mineCoin mineCoin address\r\n     */\r\n    function getTotalMined(address mineCoin)public view returns(uint256){\r\n        return mineInfoMap[mineCoin].totalMinedCoin.add(_getLatestMined(mineCoin));\r\n    }\r\n    /**\r\n     * @dev retrieve minecoin distributed informations.\r\n     * @param mineCoin mineCoin address\r\n     * @return distributed amount and distributed time interval.\r\n     */\r\n    function getMineInfo(address mineCoin)public view returns(uint256,uint256){\r\n        return (mineInfoMap[mineCoin].mineAmount,mineInfoMap[mineCoin].mineInterval);\r\n    }\r\n    /**\r\n     * @dev retrieve user's mine balance.\r\n     * @param account user's account\r\n     * @param mineCoin mineCoin address\r\n     */\r\n    function getMinerBalance(address account,address mineCoin)public view returns(uint256){\r\n        return userInfoMap[account].minerBalances[mineCoin].add(_getUserLatestMined(mineCoin,account));\r\n    }\r\n    /**\r\n     * @dev Set mineCoin mine info, only foundation owner can invoked.\r\n     * @param mineCoin mineCoin address\r\n     * @param _mineAmount mineCoin distributed amount\r\n     * @param _mineInterval mineCoin distributied time interval\r\n     */\r\n    function setMineCoinInfo(address mineCoin,uint256 _mineAmount,uint256 _mineInterval)public onlyOwner {\r\n        require(_mineAmount<1e30,\"input mine amount is too large\");\r\n        require(_mineInterval>0,\"input mine Interval must larger than zero\");\r\n        _mineSettlement(mineCoin);\r\n        mineInfoMap[mineCoin].mineAmount = _mineAmount;\r\n        mineInfoMap[mineCoin].mineInterval = _mineInterval;\r\n        if (mineInfoMap[mineCoin].startPeriod == 0){\r\n            mineInfoMap[mineCoin].startPeriod = getPeriodIndex(currentTime());\r\n        }\r\n        addWhiteList(mineCoin);\r\n    }\r\n\r\n    /**\r\n     * @dev user redeem mine rewards.\r\n     * @param mineCoin mine coin address\r\n     * @param amount redeem amount.\r\n     */\r\n    function redeemMinerCoin(address mineCoin,uint256 amount)public nonReentrant notHalted {\r\n        _mineSettlement(mineCoin);\r\n        _settleUserMine(mineCoin,msg.sender);\r\n        _redeemMineCoin(mineCoin,msg.sender,amount);\r\n    }\r\n    /**\r\n     * @dev subfunction for user redeem mine rewards.\r\n     * @param mineCoin mine coin address\r\n     * @param recieptor recieptor's account\r\n     * @param amount redeem amount.\r\n     */\r\n    function _redeemMineCoin(address mineCoin,address payable recieptor,uint256 amount) internal {\r\n        require (amount > 0,\"input amount must more than zero!\");\r\n        userInfoMap[recieptor].minerBalances[mineCoin] = \r\n            userInfoMap[recieptor].minerBalances[mineCoin].sub(amount);\r\n        _redeem(recieptor,mineCoin,amount);\r\n        emit RedeemMineCoin(recieptor,mineCoin,amount);\r\n    }\r\n\r\n    /**\r\n     * @dev settle all mine coin.\r\n     */    \r\n    function _mineSettlementAll()internal{\r\n        uint256 addrLen = whiteList.length;\r\n        for(uint256 i=0;i<addrLen;i++){\r\n            _mineSettlement(whiteList[i]);\r\n        }\r\n    }\r\n    /**\r\n     * @dev convert timestamp to period ID.\r\n     * @param _time timestamp. \r\n     */ \r\n    function getPeriodIndex(uint256 _time) public view returns (uint256) {\r\n        if (_time<_startTime){\r\n            return 0;\r\n        }\r\n        return _time.sub(_startTime).div(_period)+1;\r\n    }\r\n    /**\r\n     * @dev convert period ID to period's finish timestamp.\r\n     * @param periodID period ID. \r\n     */\r\n    function getPeriodFinishTime(uint256 periodID)public view returns (uint256) {\r\n        return periodID.mul(_period).add(_startTime);\r\n    }\r\n    function getCurrentTotalAPY(address mineCoin)public view returns (uint256) {\r\n        if (totalDistribution == 0 || mineInfoMap[mineCoin].mineInterval == 0){\r\n            return 0;\r\n        }\r\n        uint256 baseMine = mineInfoMap[mineCoin].mineAmount.mul(365 days)/mineInfoMap[mineCoin].mineInterval;\r\n        return baseMine.mul(getweightDistribution(getPeriodIndex(currentTime())))/totalDistribution;\r\n    }\r\n    /**\r\n     * @dev Calculate user's current APY.\r\n     * @param account user's account.\r\n     * @param mineCoin mine coin address\r\n     */\r\n    function getUserCurrentAPY(address account,address mineCoin)public view returns (uint256) {\r\n        if (totalDistribution == 0 || mineInfoMap[mineCoin].mineInterval == 0){\r\n            return 0;\r\n        }\r\n        uint256 baseMine = mineInfoMap[mineCoin].mineAmount.mul(365 days).mul(\r\n                userInfoMap[account].distribution)/totalDistribution/mineInfoMap[mineCoin].mineInterval;\r\n        return baseMine.mul(getPeriodWeight(getPeriodIndex(currentTime()),userInfoMap[account].maxPeriodID))/1000;\r\n    }\r\n    /**\r\n     * @dev Calculate average locked time.\r\n     */\r\n    function getAverageLockedTime()public view returns (uint256) {\r\n        if (totalDistribution == 0){\r\n            return 0;\r\n        }\r\n        uint256 i = _maxPeriod-1;\r\n        uint256 nowIndex = getPeriodIndex(currentTime());\r\n        uint256 allLockedPeriod;\r\n        uint256 periodDistri = weightDistributionMap[nowIndex+i]/4;\r\n        allLockedPeriod = periodDistri.mul(getPeriodFinishTime(nowIndex+i).sub(currentTime()));\r\n        i--;\r\n        for (;;i--){\r\n            //p[i] = (p[i+1]*3+w[i]+w[i+2]-w[i+1]*2)4\r\n            periodDistri = periodDistri.mul(3).add(weightDistributionMap[nowIndex+i]).add(weightDistributionMap[nowIndex+i+2]);\r\n            uint256 subWeight = weightDistributionMap[nowIndex+i+1].mul(2);\r\n            if (periodDistri>subWeight){\r\n                periodDistri = (periodDistri-subWeight)/4;\r\n            }else{\r\n                periodDistri = 0;\r\n            }\r\n            allLockedPeriod = allLockedPeriod.add(periodDistri.mul(getPeriodFinishTime(nowIndex+i).sub(currentTime())));\r\n            if (i == 0){\r\n                break;\r\n            }\r\n        }\r\n        return allLockedPeriod.div(totalDistribution);\r\n    }\r\n\r\n    /**\r\n     * @dev the auxiliary function for _mineSettlementAll.\r\n     * @param mineCoin mine coin address\r\n     */    \r\n    function _mineSettlement(address mineCoin)internal{\r\n        uint256 latestTime = mineInfoMap[mineCoin].latestSettleTime;\r\n        uint256 curIndex = getPeriodIndex(latestTime);\r\n        if (curIndex == 0){\r\n            latestTime = _startTime;\r\n        }\r\n        uint256 nowIndex = getPeriodIndex(currentTime());\r\n        if (nowIndex == 0){\r\n            return;\r\n        }\r\n        for (uint256 i=0;i<_maxLoop;i++){\r\n            // If the fixed distribution is zero, we only need calculate \r\n            uint256 finishTime = getPeriodFinishTime(curIndex);\r\n            if (finishTime < currentTime()){\r\n                _mineSettlementPeriod(mineCoin,curIndex,finishTime.sub(latestTime));\r\n                latestTime = finishTime;\r\n            }else{\r\n                _mineSettlementPeriod(mineCoin,curIndex,currentTime().sub(latestTime));\r\n                latestTime = currentTime();\r\n                break;\r\n            }\r\n            curIndex++;\r\n            if (curIndex > nowIndex){\r\n                break;\r\n            }\r\n        }\r\n        mineInfoMap[mineCoin].periodMinedNetWorth[nowIndex] = mineInfoMap[mineCoin].minedNetWorth;\r\n        uint256 _mineInterval = mineInfoMap[mineCoin].mineInterval;\r\n        if (_mineInterval>0){\r\n            mineInfoMap[mineCoin].latestSettleTime = currentTime()/_mineInterval*_mineInterval;\r\n        }else{\r\n            mineInfoMap[mineCoin].latestSettleTime = currentTime();\r\n        }\r\n    }\r\n    /**\r\n     * @dev the auxiliary function for _mineSettlement. Calculate and record a period mine production. \r\n     * @param mineCoin mine coin address\r\n     * @param periodID period time\r\n     * @param mineTime covered time.\r\n     */  \r\n    function _mineSettlementPeriod(address mineCoin,uint256 periodID,uint256 mineTime)internal{\r\n        uint256 totalDistri = totalDistribution;\r\n        if (totalDistri > 0){\r\n            uint256 latestMined = _getPeriodMined(mineCoin,mineTime);\r\n            if (latestMined>0){\r\n                mineInfoMap[mineCoin].minedNetWorth = mineInfoMap[mineCoin].minedNetWorth.add(latestMined.mul(calDecimals)/totalDistri);\r\n                mineInfoMap[mineCoin].totalMinedCoin = mineInfoMap[mineCoin].totalMinedCoin.add(latestMined.mul(\r\n                    getweightDistribution(periodID))/totalDistri);\r\n            }\r\n        }\r\n        mineInfoMap[mineCoin].periodMinedNetWorth[periodID] = mineInfoMap[mineCoin].minedNetWorth;\r\n    }\r\n    /**\r\n     * @dev Calculate and record user's mine production. \r\n     * @param mineCoin mine coin address\r\n     * @param account user's account\r\n     */  \r\n    function _settleUserMine(address mineCoin,address account) internal {\r\n        uint256 nowIndex = getPeriodIndex(currentTime());\r\n        if (nowIndex == 0){\r\n            return;\r\n        }\r\n        if(userInfoMap[account].distribution>0){\r\n            uint256 userPeriod = userInfoMap[account].settlePeriod[mineCoin];\r\n            if(userPeriod == 0){\r\n                userPeriod = 1;\r\n            }\r\n            if (userPeriod < mineInfoMap[mineCoin].startPeriod){\r\n                userPeriod = mineInfoMap[mineCoin].startPeriod;\r\n            }\r\n            for (uint256 i = 0;i<_maxLoop;i++){\r\n                _settlementPeriod(mineCoin,account,userPeriod);\r\n                if (userPeriod >= nowIndex){\r\n                    break;\r\n                }\r\n                userPeriod++;\r\n            }\r\n        }\r\n        userInfoMap[account].minerOrigins[mineCoin] = _getTokenNetWorth(mineCoin,nowIndex);\r\n        userInfoMap[account].settlePeriod[mineCoin] = nowIndex;\r\n    }\r\n    /**\r\n     * @dev the auxiliary function for _settleUserMine. Calculate and record a period mine production. \r\n     * @param mineCoin mine coin address\r\n     * @param account user's account\r\n     * @param periodID period time\r\n     */ \r\n    function _settlementPeriod(address mineCoin,address account,uint256 periodID) internal {\r\n        uint256 tokenNetWorth = _getTokenNetWorth(mineCoin,periodID);\r\n        if (totalDistribution > 0){\r\n            userInfoMap[account].minerBalances[mineCoin] = userInfoMap[account].minerBalances[mineCoin].add(\r\n                _settlement(mineCoin,account,periodID,tokenNetWorth));\r\n        }\r\n        userInfoMap[account].minerOrigins[mineCoin] = tokenNetWorth;\r\n    }\r\n    /**\r\n     * @dev retrieve each period's networth. \r\n     * @param mineCoin mine coin address\r\n     * @param periodID period time\r\n     */ \r\n    function _getTokenNetWorth(address mineCoin,uint256 periodID)internal view returns(uint256){\r\n        return mineInfoMap[mineCoin].periodMinedNetWorth[periodID];\r\n    }\r\n\r\n    /**\r\n     * @dev the auxiliary function for getMinerBalance. Calculate mine amount during latest time phase.\r\n     * @param mineCoin mine coin address\r\n     * @param account user's account\r\n     */ \r\n    function _getUserLatestMined(address mineCoin,address account)internal view returns(uint256){\r\n        uint256 userDistri = userInfoMap[account].distribution;\r\n        if (userDistri == 0){\r\n            return 0;\r\n        }\r\n        uint256 userperiod = userInfoMap[account].settlePeriod[mineCoin];\r\n        if (userperiod < mineInfoMap[mineCoin].startPeriod){\r\n            userperiod = mineInfoMap[mineCoin].startPeriod;\r\n        }\r\n        uint256 origin = userInfoMap[account].minerOrigins[mineCoin];\r\n        uint256 latestMined = 0;\r\n        uint256 nowIndex = getPeriodIndex(currentTime());\r\n        uint256 userMaxPeriod = userInfoMap[account].maxPeriodID;\r\n        uint256 netWorth = _getTokenNetWorth(mineCoin,userperiod);\r\n\r\n        for (uint256 i=0;i<_maxLoop;i++){\r\n            if(userperiod > nowIndex){\r\n                break;\r\n            }\r\n            if (totalDistribution == 0){\r\n                break;\r\n            }\r\n            netWorth = getPeriodNetWorth(mineCoin,userperiod,netWorth);\r\n            latestMined = latestMined.add(userDistri.mul(netWorth.sub(origin)).mul(getPeriodWeight(userperiod,userMaxPeriod))/1000/calDecimals);\r\n            origin = netWorth;\r\n            userperiod++;\r\n        }\r\n        return latestMined;\r\n    }\r\n    /**\r\n     * @dev the auxiliary function for _getUserLatestMined. Calculate token net worth in each period.\r\n     * @param mineCoin mine coin address\r\n     * @param periodID Period ID\r\n     * @param preNetWorth The previous period's net worth.\r\n     */ \r\n    function getPeriodNetWorth(address mineCoin,uint256 periodID,uint256 preNetWorth) internal view returns(uint256) {\r\n        uint256 latestTime = mineInfoMap[mineCoin].latestSettleTime;\r\n        uint256 curPeriod = getPeriodIndex(latestTime);\r\n        if(periodID < curPeriod){\r\n            return mineInfoMap[mineCoin].periodMinedNetWorth[periodID];\r\n        }else{\r\n            if (preNetWorth<mineInfoMap[mineCoin].periodMinedNetWorth[periodID]){\r\n                preNetWorth = mineInfoMap[mineCoin].periodMinedNetWorth[periodID];\r\n            }\r\n            uint256 finishTime = getPeriodFinishTime(periodID);\r\n            if (finishTime >= currentTime()){\r\n                finishTime = currentTime();\r\n            }\r\n            if(periodID > curPeriod){\r\n                latestTime = getPeriodFinishTime(periodID-1);\r\n            }\r\n            if (totalDistribution == 0){\r\n                return preNetWorth;\r\n            }\r\n            uint256 periodMind = _getPeriodMined(mineCoin,finishTime.sub(latestTime));\r\n            return preNetWorth.add(periodMind.mul(calDecimals)/totalDistribution);\r\n        }\r\n    }\r\n    /**\r\n     * @dev the auxiliary function for getTotalMined. Calculate mine amount during latest time phase .\r\n     * @param mineCoin mine coin address\r\n     */ \r\n    function _getLatestMined(address mineCoin)internal view returns(uint256){\r\n        uint256 latestTime = mineInfoMap[mineCoin].latestSettleTime;\r\n        uint256 curIndex = getPeriodIndex(latestTime);\r\n        uint256 latestMined = 0;\r\n        for (uint256 i=0;i<_maxLoop;i++){\r\n            if (totalDistribution == 0){\r\n                break;\r\n            }\r\n            uint256 finishTime = getPeriodFinishTime(curIndex);\r\n            if (finishTime < currentTime()){\r\n                latestMined = latestMined.add(_getPeriodWeightMined(mineCoin,curIndex,finishTime.sub(latestTime)));\r\n            }else{\r\n                latestMined = latestMined.add(_getPeriodWeightMined(mineCoin,curIndex,currentTime().sub(latestTime)));\r\n                break;\r\n            }\r\n            curIndex++;\r\n            latestTime = finishTime;\r\n        }\r\n        return latestMined;\r\n    }\r\n    /**\r\n     * @dev Calculate mine amount\r\n     * @param mineCoin mine coin address\r\n     * @param mintTime mine duration.\r\n     */ \r\n    function _getPeriodMined(address mineCoin,uint256 mintTime)internal view returns(uint256){\r\n        uint256 _mineInterval = mineInfoMap[mineCoin].mineInterval;\r\n        if (totalDistribution > 0 && _mineInterval>0){\r\n            uint256 _mineAmount = mineInfoMap[mineCoin].mineAmount;\r\n            mintTime = mintTime/_mineInterval;\r\n            uint256 latestMined = _mineAmount.mul(mintTime);\r\n            return latestMined;\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * @dev Calculate mine amount multiply weight ratio in each period.\r\n     * @param mineCoin mine coin address\r\n     * @param mineCoin period ID.\r\n     * @param mintTime mine duration.\r\n     */ \r\n    function _getPeriodWeightMined(address mineCoin,uint256 periodID,uint256 mintTime)internal view returns(uint256){\r\n        if (totalDistribution > 0){\r\n            return _getPeriodMined(mineCoin,mintTime).mul(getweightDistribution(periodID))/totalDistribution;\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * @dev Auxiliary function, calculate user's latest mine amount.\r\n     * @param mineCoin the mine coin address\r\n     * @param account user's account\r\n     * @param tokenNetWorth the latest token net worth\r\n     */\r\n    function _settlement(address mineCoin,address account,uint256 periodID,uint256 tokenNetWorth)internal view returns (uint256) {\r\n        uint256 origin = userInfoMap[account].minerOrigins[mineCoin];\r\n        uint256 userMaxPeriod = userInfoMap[account].maxPeriodID;\r\n        require(tokenNetWorth>=origin,\"error: tokenNetWorth logic error!\");\r\n        return userInfoMap[account].distribution.mul(tokenNetWorth-origin).mul(getPeriodWeight(periodID,userMaxPeriod))/1000/calDecimals;\r\n    }\r\n    /**\r\n     * @dev Stake FPT-A coin and get distribution for mining.\r\n     * @param amount FPT-A amount that transfer into mine pool.\r\n     */\r\n    function stakeFPTA(uint256 amount)public minePoolStarted nonReentrant notHalted{\r\n        amount = getPayableAmount(_FPTA,amount);\r\n        require(amount > 0, 'stake amount is zero');\r\n        removeDistribution(msg.sender);\r\n        userInfoMap[msg.sender]._FPTABalance = userInfoMap[msg.sender]._FPTABalance.add(amount);\r\n        addDistribution(msg.sender);\r\n        emit StakeFPTA(msg.sender,amount);\r\n    }\r\n    /**\r\n     * @dev Air drop to user some FPT-B coin and lock one period and get distribution for mining.\r\n     * @param user air drop's recieptor.\r\n     * @param ftp_b_amount FPT-B amount that transfer into mine pool.\r\n     */\r\n    function lockAirDrop(address user,uint256 ftp_b_amount) minePoolStarted notHalted external{\r\n        if (msg.sender == getOperator(1)){\r\n            lockAirDrop_base(user,ftp_b_amount);\r\n        }else if (msg.sender == getOperator(2)){\r\n            lockAirDrop_stake(user,ftp_b_amount);\r\n        }else{\r\n            require(false ,\"Operator: caller is not the eligible Operator\");\r\n        }\r\n    }\r\n    function lockAirDrop_base(address user,uint256 ftp_b_amount) internal{\r\n        uint256 curPeriod = getPeriodIndex(currentTime());\r\n        uint256 maxId = userInfoMap[user].maxPeriodID;\r\n        uint256 lockedPeriod = curPeriod > maxId ? curPeriod : maxId;\r\n        ftp_b_amount = getPayableAmount(_FPTB,ftp_b_amount);\r\n        require(ftp_b_amount > 0, 'stake amount is zero');\r\n        removeDistribution(user);\r\n        userInfoMap[user]._FPTBBalance = userInfoMap[user]._FPTBBalance.add(ftp_b_amount);\r\n        userInfoMap[user].maxPeriodID = lockedPeriod;\r\n        userInfoMap[user].lockedExpired = getPeriodFinishTime(lockedPeriod);\r\n        addDistribution(user);\r\n        emit LockAirDrop(msg.sender,user,ftp_b_amount);\r\n    } \r\n    function lockAirDrop_stake(address user,uint256 lockedPeriod) internal validPeriod(lockedPeriod) {\r\n        uint256 curPeriod = getPeriodIndex(currentTime());\r\n        uint256 userMaxPeriod = curPeriod+lockedPeriod-1;\r\n\r\n        require(userMaxPeriod>=userInfoMap[user].maxPeriodID, \"lockedPeriod cannot be smaller than current locked period\");\r\n        if(userInfoMap[user].maxPeriodID<curPeriod && lockedPeriod == 1){\r\n            require(getPeriodFinishTime(getCurrentPeriodID()+lockedPeriod)>currentTime() + _flexibleExpired, 'locked time must greater than 15 days');\r\n        }\r\n        uint256 ftp_a_amount = IERC20(_FPTA).balanceOf(msg.sender);\r\n        ftp_a_amount = getPayableAmount(_FPTA,ftp_a_amount);\r\n        uint256 ftp_b_amount = IERC20(_FPTB).balanceOf(msg.sender);\r\n        ftp_b_amount = getPayableAmount(_FPTB,ftp_b_amount);\r\n        require(ftp_a_amount > 0 || ftp_b_amount > 0, 'stake amount is zero');\r\n        removeDistribution(user);\r\n        userInfoMap[user]._FPTABalance = userInfoMap[user]._FPTABalance.add(ftp_a_amount);\r\n        userInfoMap[user]._FPTBBalance = userInfoMap[user]._FPTBBalance.add(ftp_b_amount);\r\n        if (userInfoMap[user]._FPTBBalance > 0)\r\n        {\r\n            if (lockedPeriod == 0){\r\n                userInfoMap[user].maxPeriodID = 0;\r\n                if (ftp_b_amount>0){\r\n                    userInfoMap[user].lockedExpired = currentTime().add(_flexibleExpired);\r\n                }\r\n            }else{\r\n                userInfoMap[user].maxPeriodID = userMaxPeriod;\r\n                userInfoMap[user].lockedExpired = getPeriodFinishTime(userMaxPeriod);\r\n            }\r\n        }\r\n        addDistribution(user);\r\n        emit StakeFPTA(user,ftp_a_amount);\r\n        emit StakeFPTB(user,ftp_b_amount,lockedPeriod);\r\n    } \r\n    /**\r\n     * @dev Stake FPT-B coin and lock locedPreiod and get distribution for mining.\r\n     * @param amount FPT-B amount that transfer into mine pool.\r\n     * @param lockedPeriod locked preiod number.\r\n     */\r\n    function stakeFPTB(uint256 amount,uint256 lockedPeriod)public validPeriod(lockedPeriod) minePoolStarted nonReentrant notHalted{\r\n        uint256 curPeriod = getPeriodIndex(currentTime());\r\n        uint256 userMaxPeriod = curPeriod+lockedPeriod-1;\r\n        require(userMaxPeriod>=userInfoMap[msg.sender].maxPeriodID, \"lockedPeriod cannot be smaller than current locked period\");\r\n        if(userInfoMap[msg.sender].maxPeriodID<curPeriod && lockedPeriod == 1){\r\n            require(getPeriodFinishTime(getCurrentPeriodID()+lockedPeriod)>currentTime() + _flexibleExpired, 'locked time must greater than 15 days');\r\n        }\r\n        amount = getPayableAmount(_FPTB,amount);\r\n        require(amount > 0, 'stake amount is zero');\r\n        removeDistribution(msg.sender);\r\n        userInfoMap[msg.sender]._FPTBBalance = userInfoMap[msg.sender]._FPTBBalance.add(amount);\r\n        if (lockedPeriod == 0){\r\n            userInfoMap[msg.sender].maxPeriodID = 0;\r\n            userInfoMap[msg.sender].lockedExpired = currentTime().add(_flexibleExpired);\r\n        }else{\r\n            userInfoMap[msg.sender].maxPeriodID = userMaxPeriod;\r\n            userInfoMap[msg.sender].lockedExpired = getPeriodFinishTime(userMaxPeriod);\r\n        }\r\n        addDistribution(msg.sender);\r\n        emit StakeFPTB(msg.sender,amount,lockedPeriod);\r\n    }\r\n    /**\r\n     * @dev withdraw FPT-A coin.\r\n     * @param amount FPT-A amount that withdraw from mine pool.\r\n     */\r\n    function unstakeFPTA(uint256 amount)public nonReentrant notHalted{\r\n        require(amount > 0, 'unstake amount is zero');\r\n        require(userInfoMap[msg.sender]._FPTABalance >= amount,\r\n            'unstake amount is greater than total user stakes');\r\n        removeDistribution(msg.sender);\r\n        userInfoMap[msg.sender]._FPTABalance = userInfoMap[msg.sender]._FPTABalance - amount;\r\n        addDistribution(msg.sender);\r\n        _redeem(msg.sender,_FPTA,amount);\r\n        emit UnstakeFPTA(msg.sender,amount);\r\n    }\r\n    /**\r\n     * @dev withdraw FPT-B coin.\r\n     * @param amount FPT-B amount that withdraw from mine pool.\r\n     */\r\n    function unstakeFPTB(uint256 amount)public nonReentrant notHalted minePoolStarted periodExpired(msg.sender){\r\n        require(amount > 0, 'unstake amount is zero');\r\n        require(userInfoMap[msg.sender]._FPTBBalance >= amount,\r\n            'unstake amount is greater than total user stakes');\r\n        removeDistribution(msg.sender);\r\n        userInfoMap[msg.sender]._FPTBBalance = userInfoMap[msg.sender]._FPTBBalance - amount;\r\n        addDistribution(msg.sender);\r\n        _redeem(msg.sender,_FPTB,amount);\r\n        emit UnstakeFPTB(msg.sender,amount);\r\n    }\r\n    /**\r\n     * @dev Add FPT-B locked period.\r\n     * @param lockedPeriod FPT-B locked preiod number.\r\n     */\r\n    function changeFPTBLockedPeriod(uint256 lockedPeriod)public validPeriod(lockedPeriod) minePoolStarted notHalted{\r\n        require(userInfoMap[msg.sender]._FPTBBalance > 0, \"stake FPTB balance is zero\");\r\n        uint256 curPeriod = getPeriodIndex(currentTime());\r\n        require(curPeriod+lockedPeriod-1>=userInfoMap[msg.sender].maxPeriodID, \"lockedPeriod cannot be smaller than current locked period\");\r\n        removeDistribution(msg.sender); \r\n        if (lockedPeriod == 0){\r\n            userInfoMap[msg.sender].maxPeriodID = 0;\r\n            userInfoMap[msg.sender].lockedExpired = currentTime().add(_flexibleExpired);\r\n        }else{\r\n            userInfoMap[msg.sender].maxPeriodID = curPeriod+lockedPeriod-1;\r\n            userInfoMap[msg.sender].lockedExpired = getPeriodFinishTime(curPeriod+lockedPeriod-1);\r\n        }\r\n        addDistribution(msg.sender);\r\n        emit ChangeLockedPeriod(msg.sender,lockedPeriod);\r\n    }\r\n    /**\r\n     * @dev Auxiliary function. getting user's payment\r\n     * @param settlement user's payment coin.\r\n     * @param settlementAmount user's payment amount.\r\n     */\r\n    function getPayableAmount(address settlement,uint256 settlementAmount) internal returns (uint256) {\r\n        if (settlement == address(0)){\r\n            settlementAmount = msg.value;\r\n        }else if (settlementAmount > 0){\r\n            IERC20 oToken = IERC20(settlement);\r\n            uint256 preBalance = oToken.balanceOf(address(this));\r\n            SafeERC20.safeTransferFrom(oToken,msg.sender, address(this), settlementAmount);\r\n            //oToken.transferFrom(msg.sender, address(this), settlementAmount);\r\n            uint256 afterBalance = oToken.balanceOf(address(this));\r\n            require(afterBalance-preBalance==settlementAmount,\"settlement token transfer error!\");\r\n        }\r\n        return settlementAmount;\r\n    }\r\n    /**\r\n     * @dev Auxiliary function. Clear user's distribution amount.\r\n     * @param account user's account.\r\n     */\r\n    function removeDistribution(address account) internal {\r\n        uint256 addrLen = whiteList.length;\r\n        for(uint256 i=0;i<addrLen;i++){\r\n            _mineSettlement(whiteList[i]);\r\n            _settleUserMine(whiteList[i],account);\r\n        }\r\n        uint256 distri = calculateDistribution(account);\r\n        totalDistribution = totalDistribution.sub(distri);\r\n        uint256 nowId = getPeriodIndex(currentTime());\r\n        uint256 endId = userInfoMap[account].maxPeriodID;\r\n        for(;nowId<=endId;nowId++){\r\n            weightDistributionMap[nowId] = weightDistributionMap[nowId].sub(distri.mul(getPeriodWeight(nowId,endId)-1000)/1000);\r\n        }\r\n        userInfoMap[account].distribution =  0;\r\n        removePremiumDistribution(account);\r\n    }\r\n    /**\r\n     * @dev Auxiliary function. Add user's distribution amount.\r\n     * @param account user's account.\r\n     */\r\n    function addDistribution(address account) internal {\r\n        uint256 distri = calculateDistribution(account);\r\n        uint256 nowId = getPeriodIndex(currentTime());\r\n        uint256 endId = userInfoMap[account].maxPeriodID;\r\n        for(;nowId<=endId;nowId++){\r\n            weightDistributionMap[nowId] = weightDistributionMap[nowId].add(distri.mul(getPeriodWeight(nowId,endId)-1000)/1000);\r\n        }\r\n        userInfoMap[account].distribution =  distri;\r\n        totalDistribution = totalDistribution.add(distri);\r\n        addPremiumDistribution(account);\r\n    }\r\n    /**\r\n     * @dev Auxiliary function. calculate user's distribution.\r\n     * @param account user's account.\r\n     */\r\n    function calculateDistribution(address account) internal view returns (uint256){\r\n        uint256 fptAAmount = userInfoMap[account]._FPTABalance;\r\n        uint256 fptBAmount = userInfoMap[account]._FPTBBalance;\r\n        uint256 repeat = (fptAAmount>fptBAmount*10) ? fptBAmount*10 : fptAAmount;\r\n        return _FPTARatio.mul(fptAAmount).add(_FPTBRatio.mul(fptBAmount)).add(\r\n            _RepeatRatio.mul(repeat));\r\n    }\r\n    /**\r\n     * @dev Auxiliary function. get weight distribution in each period.\r\n     * @param periodID period ID.\r\n     */\r\n    function getweightDistribution(uint256 periodID)internal view returns (uint256) {\r\n        return weightDistributionMap[periodID].add(totalDistribution);\r\n    }\r\n    /**\r\n     * @dev Auxiliary function. get mine weight ratio from current period to one's maximium period.\r\n     * @param currentID current period ID.\r\n     * @param maxPeriod user's maximium period ID.\r\n     */\r\n    function getPeriodWeight(uint256 currentID,uint256 maxPeriod) public pure returns (uint256) {\r\n        if (maxPeriod == 0 || currentID > maxPeriod){\r\n            return 1000;\r\n        }\r\n        return maxPeriod.sub(currentID).mul(periodWeight) +baseWeight;\r\n    }\r\n\r\n    /**\r\n     * @dev retrieve total distributed options premium.\r\n     */\r\n    function getTotalPremium(address premiumCoin)public view returns(uint256){\r\n        return premiumMap[premiumCoin].totalPremium;\r\n    }\r\n\r\n    /**\r\n     * @dev user redeem his options premium rewards.\r\n     */\r\n    function redeemPremium()public nonReentrant notHalted {\r\n        for (uint256 i=0;i<premiumCoinList.length;i++){\r\n            address premiumCoin = premiumCoinList[i];\r\n            settlePremium(msg.sender,premiumCoin);\r\n            uint256 amount = premiumMap[premiumCoin].premiumBalance[msg.sender];\r\n            if (amount > 0){\r\n                premiumMap[premiumCoin].premiumBalance[msg.sender] = 0;\r\n                _redeem(msg.sender,premiumCoin,amount);\r\n                emit RedeemPremium(msg.sender,premiumCoin,amount);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @dev user redeem his options premium rewards.\r\n     * @param amount redeem amount.\r\n     */\r\n    function redeemPremiumCoin(address premiumCoin,uint256 amount)public nonReentrant notHalted {\r\n        require(amount > 0,\"redeem amount must be greater than zero\");\r\n        settlePremium(msg.sender,premiumCoin);\r\n        premiumMap[premiumCoin].premiumBalance[msg.sender] = premiumMap[premiumCoin].premiumBalance[msg.sender].sub(amount);\r\n        _redeem(msg.sender,premiumCoin,amount);\r\n        emit RedeemPremium(msg.sender,premiumCoin,amount);\r\n    }\r\n\r\n    /**\r\n     * @dev get user's premium balance.\r\n     * @param account user's account\r\n     */ \r\n    function getUserLatestPremium(address account,address premiumCoin)public view returns(uint256){\r\n        return premiumMap[premiumCoin].premiumBalance[account].add(_getUserPremium(account,premiumCoin));\r\n    }\r\n    /**\r\n     * @dev the auxiliary function for getUserLatestPremium. Calculate latest time phase premium.\r\n     */ \r\n    function _getUserPremium(address account,address premiumCoin)internal view returns(uint256){\r\n        uint256 FPTBBalance = userInfoMap[account]._FPTBBalance;\r\n        if (FPTBBalance > 0){\r\n            uint256 lastIndex = premiumMap[premiumCoin].lastPremiumIndex[account];\r\n            uint256 nowIndex = getPeriodIndex(currentTime());\r\n            uint256 endIndex = lastIndex+_maxLoop < premiumMap[premiumCoin].distributedPeriod.length ? lastIndex+_maxLoop : premiumMap[premiumCoin].distributedPeriod.length;\r\n            uint256 LatestPremium = 0;\r\n            for (; lastIndex< endIndex;lastIndex++){\r\n                uint256 periodID = premiumMap[premiumCoin].distributedPeriod[lastIndex];\r\n                if (periodID == nowIndex || premiumDistributionMap[periodID].totalPremiumDistribution == 0 ||\r\n                    premiumDistributionMap[periodID].userPremiumDistribution[account] == 0){\r\n                    continue;\r\n                }\r\n                LatestPremium = LatestPremium.add(premiumMap[premiumCoin].periodPremium[periodID].mul(premiumDistributionMap[periodID].userPremiumDistribution[account]).div(\r\n                    premiumDistributionMap[periodID].totalPremiumDistribution));\r\n            }        \r\n            return LatestPremium;\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * @dev Distribute premium from foundation.\r\n     * @param premiumCoin premium token address\r\n     * @param periodID period ID\r\n     * @param amount premium amount.\r\n     */ \r\n    function distributePremium(address premiumCoin, uint256 periodID,uint256 amount)public onlyOperator(0) {\r\n        amount = getPayableAmount(premiumCoin,amount);\r\n        require(amount > 0, 'Distribution amount is zero');\r\n        require(premiumMap[premiumCoin].periodPremium[periodID] == 0 , \"This period is already distributed!\");\r\n        uint256 nowIndex = getPeriodIndex(currentTime());\r\n        require(nowIndex > periodID, 'This period is not finished');\r\n        whiteListAddress.addWhiteListAddress(premiumCoinList,premiumCoin);\r\n        premiumMap[premiumCoin].periodPremium[periodID] = amount;\r\n        premiumMap[premiumCoin].totalPremium = premiumMap[premiumCoin].totalPremium.add(amount);\r\n        premiumMap[premiumCoin].distributedPeriod.push(uint64(periodID));\r\n        emit DistributePremium(msg.sender,premiumCoin,periodID,amount);\r\n    }\r\n    /**\r\n     * @dev Auxiliary function. Clear user's premium distribution amount.\r\n     * @param account user's account.\r\n     */ \r\n    function removePremiumDistribution(address account) internal {\r\n        for (uint256 i=0;i<premiumCoinList.length;i++){\r\n            settlePremium(account,premiumCoinList[i]);\r\n        }\r\n        uint256 beginTime = currentTime(); \r\n        uint256 nowId = getPeriodIndex(beginTime);\r\n        uint256 endId = userInfoMap[account].maxPeriodID;\r\n        uint256 FPTBBalance = userInfoMap[account]._FPTBBalance;\r\n        if (FPTBBalance> 0 && nowId<endId){\r\n            for(;nowId<endId;nowId++){\r\n                uint256 finishTime = getPeriodFinishTime(nowId);\r\n                uint256 periodDistribution = finishTime.sub(beginTime).mul(FPTBBalance);\r\n                premiumDistributionMap[nowId].totalPremiumDistribution = premiumDistributionMap[nowId].totalPremiumDistribution.sub(periodDistribution);\r\n                premiumDistributionMap[nowId].userPremiumDistribution[account] = premiumDistributionMap[nowId].userPremiumDistribution[account].sub(periodDistribution);\r\n                beginTime = finishTime;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @dev Auxiliary function. Calculate and record user's premium.\r\n     * @param account user's account.\r\n     */ \r\n    function settlePremium(address account,address premiumCoin)internal{\r\n        premiumMap[premiumCoin].premiumBalance[account] = premiumMap[premiumCoin].premiumBalance[account].add(getUserLatestPremium(account,premiumCoin));\r\n        premiumMap[premiumCoin].lastPremiumIndex[account] = premiumMap[premiumCoin].distributedPeriod.length;\r\n    }\r\n    /**\r\n     * @dev Auxiliary function. Add user's premium distribution amount.\r\n     * @param account user's account.\r\n     */ \r\n    function addPremiumDistribution(address account) internal {\r\n        uint256 beginTime = currentTime(); \r\n        uint256 nowId = getPeriodIndex(beginTime);\r\n        uint256 endId = userInfoMap[account].maxPeriodID;\r\n        uint256 FPTBBalance = userInfoMap[account]._FPTBBalance;\r\n        for(;nowId<endId;nowId++){\r\n            uint256 finishTime = getPeriodFinishTime(nowId);\r\n            uint256 periodDistribution = finishTime.sub(beginTime).mul(FPTBBalance);\r\n            premiumDistributionMap[nowId].totalPremiumDistribution = premiumDistributionMap[nowId].totalPremiumDistribution.add(periodDistribution);\r\n            premiumDistributionMap[nowId].userPremiumDistribution[account] = premiumDistributionMap[nowId].userPremiumDistribution[account].add(periodDistribution);\r\n            beginTime = finishTime;\r\n        }\r\n\r\n    }\r\n    /**\r\n     * @dev Throws if user's locked expired timestamp is less than now.\r\n     */\r\n    modifier periodExpired(address account){\r\n        require(userInfoMap[account].lockedExpired < currentTime(),'locked period is not expired');\r\n\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Throws if input period number is greater than _maxPeriod.\r\n     */\r\n    modifier validPeriod(uint256 period){\r\n        require(period >= 0 && period <= _maxPeriod, 'locked period must be in valid range');\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Throws if minePool is not start.\r\n     */\r\n    modifier minePoolStarted(){\r\n        require(currentTime()>=_startTime, 'mine pool is not start');\r\n        _;\r\n    }\r\n    /**\r\n     * @dev get now timestamp.\r\n     */\r\n    function currentTime() internal view returns (uint256){\r\n        return now;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"FPTA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"FPTB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedPeriod\",\"type\":\"uint256\"}],\"name\":\"ChangeLockedPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"premiumCoin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"periodID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributePremium\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recieptor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockAirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RedeemMineCoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"premiumCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RedeemPremium\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeFPTA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedPeriod\",\"type\":\"uint256\"}],\"name\":\"StakeFPTB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeFPTA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeFPTB\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedPeriod\",\"type\":\"uint256\"}],\"name\":\"changeFPTBLockedPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"premiumCoin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"periodID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distributePremium\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAverageLockedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPeriodID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"}],\"name\":\"getCurrentTotalAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFPTAAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFPTBAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"}],\"name\":\"getMineInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMineWeightRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"}],\"name\":\"getMinerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"periodID\",\"type\":\"uint256\"}],\"name\":\"getPeriodFinishTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getPeriodIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPeriod\",\"type\":\"uint256\"}],\"name\":\"getPeriodWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"}],\"name\":\"getTotalMined\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"premiumCoin\",\"type\":\"address\"}],\"name\":\"getTotalPremium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"}],\"name\":\"getUserCurrentAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserExpired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserFPTABalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserFPTBBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"premiumCoin\",\"type\":\"address\"}],\"name\":\"getUserLatestPremium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserMaxPeriodId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWhiteList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tmpAddress\",\"type\":\"address\"}],\"name\":\"isEligibleAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ftp_b_amount\",\"type\":\"uint256\"}],\"name\":\"lockAirDrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemMinerCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemPremium\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"premiumCoin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemPremiumCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeAddress\",\"type\":\"address\"}],\"name\":\"removeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"FPTA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"FPTB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"setAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"halt\",\"type\":\"bool\"}],\"name\":\"setHalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"mineCoin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_mineAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mineInterval\",\"type\":\"uint256\"}],\"name\":\"setMineCoinInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeFPTA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedPeriod\",\"type\":\"uint256\"}],\"name\":\"stakeFPTB\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstakeFPTA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstakeFPTB\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"fixedMinePool","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000016305b9ec0bdbe32cf8a0b5c142ceb3682db9d2d0000000000000000000000007e605fb638983a448096d82ffd2958ba012f30cd000000000000000000000000000000000000000000000000000000005ff86560","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://813e4f133d7e24ddb9ce8fc4602c32e2bf346cedf20c8e13c225f30338524904"}]}