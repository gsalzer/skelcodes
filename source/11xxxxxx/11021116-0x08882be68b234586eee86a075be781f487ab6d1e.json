{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.16;\r\n\r\ncontract ERC20 {\r\n\r\n    function transferFrom (address,address, uint256) external returns (bool);\r\n    function balanceOf(address) public view returns (uint256);\r\n    function allowance(address, address) external view returns (uint256);\r\n    function transfer (address, uint256) external returns (bool);\r\n    function burn (uint256) external returns (bool);\r\n    function giveRewardsToStakers(address,uint256) external returns(bool); \r\n    function burnLiquidatedTokens() external returns(bool);\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed _to);\r\n\r\n    constructor(address _owner) public {\r\n        owner = _owner;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract Pausable is Owned {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n      require(!paused);\r\n      _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n      require(paused);\r\n      _;\r\n    }\r\n\r\n    function pause() onlyOwner whenNotPaused public {\r\n      paused = true;\r\n      emit Pause();\r\n    }\r\n\r\n    function unpause() onlyOwner whenPaused public {\r\n      paused = false;\r\n      emit Unpause();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract liquidityProviderTokensStaking is Pausable{\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address public uniV2superVsEth;\r\n    address public uniV2MegavsEth;\r\n    address public uniV2UltraVsEth;\r\n    \r\n    address public superContractAddress;\r\n    address public megaContractAddress;\r\n    address public ultraContractAddress;\r\n\r\n    uint256 public stakingRatioSuper;\r\n    uint256 public stakingRatioMega;\r\n    uint256 public stakingRatioUltra;\r\n\r\n    constructor(address _super, address _mega, address _ultra) public Owned(msg.sender) {\r\n\r\n    superContractAddress = _super;\r\n    megaContractAddress = _mega;\r\n    ultraContractAddress = _ultra;\r\n    stakingRatioSuper = 20;\r\n    stakingRatioMega = 20;\r\n    stakingRatioUltra = 4;\r\n    \r\n\r\n    }\r\n\r\n    function setAddress(address _uniV2superVsEth, address _uniV2MegavsEth, address _uniV2UltraVsEth) external onlyOwner returns(bool)  \r\n    {\r\n       \r\n       uniV2superVsEth = _uniV2superVsEth;\r\n       uniV2MegavsEth = _uniV2MegavsEth;\r\n       uniV2UltraVsEth = _uniV2UltraVsEth;\r\n            return true;\r\n    }\r\n\r\n\r\n    function setStakingRatio(uint256 value1, uint256 value2, uint256 value3) external onlyOwner returns(bool)  \r\n    {\r\n       \r\n        stakingRatioSuper = value1;\r\n        stakingRatioMega = value2;\r\n        stakingRatioUltra = value3;\r\n        return true;\r\n    }\r\n\r\n\r\n// stake super mega ultra tokens \r\n\r\n    mapping (address => uint256) public superTokensStaked;\r\n    mapping (address => uint256) public superTokensStakedTime;\r\n\r\n    mapping (address => uint256) public megaTokensStaked;\r\n    mapping (address => uint256) public megaTokensStakedTime;\r\n\r\n    mapping (address => uint256) public ultraTokensStaked;\r\n    mapping (address => uint256) public ultraTokensStakedTime;\r\n\r\n    mapping (address => uint256) public claimedTokens;\r\n    \r\n    mapping (address => uint256) public foundersLocking;\r\n    mapping (address => uint256) public foundersLockingTime;\r\n\r\n    mapping (address => uint256) public foundersLockingMega;\r\n    mapping (address => uint256) public foundersLockingMegaTime;\r\n\r\n    mapping (address => uint256) public foundersLockingUltra;\r\n    mapping (address => uint256) public foundersLockingUltraTime;\r\n\r\n    mapping (address => bool) public foundersAddress; \r\n\r\n   function stakedAllTokens (address userAddress) public view returns (uint256,uint256,uint256) {\r\n       \r\n       uint256 superBalanceStaked = superTokensStaked[userAddress]; \r\n       uint256 megaBalanceStaked =  megaTokensStaked[userAddress];  \r\n       uint256 ultraBalanceStaked = ultraTokensStaked[userAddress];    \r\n       return (superBalanceStaked,megaBalanceStaked,ultraBalanceStaked);\r\n\r\n   }\r\n\r\n\r\n   function superMegaUltraStakingTime (address userAddress) public view returns (uint256,uint256,uint256) {\r\n       \r\n       uint256 superBalance = superTokensStakedTime[userAddress]; \r\n       uint256 megaBalance = megaTokensStakedTime[userAddress];  \r\n       uint256 ultraBalance = ultraTokensStakedTime[userAddress];    \r\n       \r\n       return (superBalance,megaBalance,ultraBalance);\r\n   }\r\n\r\n\r\n   function stakingRatios () public view returns (uint256,uint256,uint256) {\r\n       \r\n       return (stakingRatioSuper,stakingRatioMega,stakingRatioUltra);\r\n   }\r\n\r\n\r\n    function stakeSuperTokens(uint256 amount) public returns (bool) {\r\n       \r\n       require(ERC20(superContractAddress).balanceOf(msg.sender) >= amount,'balance of a user is less then value');\r\n       require(superTokensStaked[msg.sender] == 0, \"Please claim Mega tokens first before new stake\");\r\n       uint256 checkAllowance = ERC20(superContractAddress).allowance(msg.sender, address(this)); \r\n       superTokensStaked[msg.sender] = amount;\r\n       superTokensStakedTime[msg.sender] = now;\r\n       require (checkAllowance >= amount, 'allowance is wrong');\r\n       require(ERC20(superContractAddress).transferFrom(msg.sender,address(this),amount),'transfer From failed');\r\n        \r\n    } \r\n\r\n\r\n    function claimableMegaTokens (address user) public view returns (bool,uint256) {\r\n        \r\n        if (superTokensStaked[user] > 0){\r\n            \r\n            return (true,superTokensStaked[user].div(20));\r\n            \r\n            \r\n        } else {return (false,0);}\r\n        \r\n    }\r\n\r\n    function claimMegaTokens() public returns (bool) {\r\n       \r\n        require(superTokensStaked[msg.sender]>0, \"not staked any super tokens\");\r\n        require(now > superTokensStakedTime[msg.sender].add(14400), \"4 hours not completed yet\"); \r\n\r\n        require(ERC20(superContractAddress).burn(superTokensStaked[msg.sender]), \"Super tokens Burned\");\r\n        require(ERC20(megaContractAddress).giveRewardsToStakers(msg.sender,superTokensStaked[msg.sender].div(stakingRatioSuper)), \"mint failed\");\r\n        superTokensStaked[msg.sender] = 0;\r\n        superTokensStakedTime[msg.sender] = 0;    \r\n        \r\n    } \r\n\r\n\r\n    function stakeMegaTokens(uint256 amount) public returns (bool) {\r\n       \r\n       require(ERC20(megaContractAddress).balanceOf(msg.sender) >= amount,'balance of a user is less then value');\r\n       uint256 checkAllowance = ERC20(megaContractAddress).allowance(msg.sender, address(this)); \r\n       require (checkAllowance >= amount, 'allowance is wrong');\r\n       require(ERC20(megaContractAddress).transferFrom(msg.sender,address(this),amount),'transfer From failed');\r\n\r\n       megaTokensStaked[msg.sender] = amount;\r\n       megaTokensStakedTime[msg.sender] = now;\r\n        \r\n    } \r\n\r\n    function claimableUltraTokens (address user) public view returns (bool,uint256) {\r\n        \r\n        if (megaTokensStaked[user] > 0){\r\n            \r\n            return(true,megaTokensStaked[user].div(20));\r\n            \r\n            \r\n        } else {return (false,0);}\r\n        \r\n    }\r\n\r\n\r\n    function claimUltraTokens() public returns (bool) {\r\n       \r\n        require(megaTokensStaked[msg.sender]>0, \"didnt staked any MEGA\");\r\n        require(now > megaTokensStakedTime[msg.sender].add(14400), \"too early to claim\"); \r\n        require(ERC20(megaContractAddress).burn(megaTokensStaked[msg.sender]), \"Burn is not possible\");\r\n        require(ERC20(ultraContractAddress).giveRewardsToStakers(msg.sender,megaTokensStaked[msg.sender].div(stakingRatioMega)));\r\n        megaTokensStaked[msg.sender] = 0;\r\n        megaTokensStakedTime[msg.sender] = 0;    \r\n        \r\n    } \r\n\r\n    function stakeUltraTokens(uint256 amount) public returns (bool) {\r\n       \r\n       require(ERC20(ultraContractAddress).balanceOf(msg.sender) >= amount,'balance of a user is less then value');\r\n       uint256 checkAllowance = ERC20(ultraContractAddress).allowance(msg.sender, address(this)); \r\n       require (checkAllowance >= amount, 'allowance is wrong');\r\n       require(ERC20(ultraContractAddress).transferFrom(msg.sender,address(this),amount),'transfer From failed');\r\n\r\n       ultraTokensStaked[msg.sender] = amount;\r\n       ultraTokensStakedTime[msg.sender] = now;\r\n        \r\n    } \r\n\r\n    function claimableSuperTokens (address user) public view returns (bool,uint256) {\r\n        \r\n        if (ultraTokensStaked[user] > 0){\r\n            \r\n        uint256 preSaleCycle = getCycle(user);\r\n        uint256 onePercentOfInitialFund = ultraTokensStaked[user].div(4);\r\n        \r\n        if(claimedTokens[user] != onePercentOfInitialFund.mul(preSaleCycle)) {\r\n            \r\n        uint256 tokenToSend = onePercentOfInitialFund.mul(preSaleCycle).sub(claimedTokens[user]);\r\n         return (true, tokenToSend);        \r\n\r\n        }\r\n            \r\n            \r\n        } else {return (false,0);}\r\n        \r\n    }\r\n\r\n    function claimSuperTokens() public returns (bool) {\r\n       \r\n        require(ultraTokensStaked[msg.sender] > 0);\r\n        require(now > ultraTokensStakedTime[msg.sender].add(21600));//21600 6 hours\r\n\r\n        uint256 preSaleCycle = getCycle(msg.sender);\r\n        require (preSaleCycle > 0);\r\n        uint256 onePercentOfInitialFund = ultraTokensStaked[msg.sender].div(stakingRatioUltra);\r\n        if(claimedTokens[msg.sender] != onePercentOfInitialFund.mul(preSaleCycle)) {\r\n            \r\n        uint256 tokenToSend = onePercentOfInitialFund.mul(preSaleCycle).sub(claimedTokens[msg.sender]);\r\n        claimedTokens[msg.sender] = onePercentOfInitialFund.mul(preSaleCycle);\r\n        require(ERC20(superContractAddress).giveRewardsToStakers(msg.sender,tokenToSend));\r\n        return true;\r\n\r\n        } else {\r\n            \r\n            revert ();\r\n        }\r\n        \r\n    } \r\n\r\n\r\n    function unStakeUltraTokens() public returns (bool) {\r\n\r\n        if(foundersAddress[msg.sender]) {\r\n         \r\n         require(now > (ultraTokensStakedTime[msg.sender]).add(15552000));// lock for 6 months    \r\n            \r\n        }\r\n        \r\n        require(ultraTokensStaked[msg.sender]>0, \"didnt staked any Ultra\");\r\n        \r\n        uint256 preSaleCycle = getCycle(msg.sender);\r\n        require (preSaleCycle > 0);\r\n\r\n        uint256 onePercentOfInitialFund = ultraTokensStaked[msg.sender].div(stakingRatioUltra);\r\n        if(claimedTokens[msg.sender] != onePercentOfInitialFund.mul(preSaleCycle)) {\r\n            \r\n        uint256 tokenToSend = onePercentOfInitialFund.mul(preSaleCycle).sub(claimedTokens[msg.sender]);\r\n        claimedTokens[msg.sender] = onePercentOfInitialFund.mul(preSaleCycle);\r\n        require(ERC20(superContractAddress).giveRewardsToStakers(msg.sender,tokenToSend));\r\n\r\n        }        \r\n        require(now > ultraTokensStakedTime[msg.sender].add(21600), \"too early to claim\"); \r\n        require(ERC20(ultraContractAddress).burn(ultraTokensStaked[msg.sender].div(100).mul(5)), \"Burn is not possible\");\r\n        require(ERC20(ultraContractAddress).transfer(msg.sender,ultraTokensStaked[msg.sender].div(100).mul(95)));\r\n                \r\n\r\n        ultraTokensStaked[msg.sender] = 0;\r\n        ultraTokensStakedTime[msg.sender] = 0;   \r\n        claimedTokens[msg.sender] = 0; \r\n        \r\n    } \r\n\r\n    function getCycle(address userAddress) public view returns (uint256){\r\n     \r\n     require(ultraTokensStaked[userAddress] > 0, \"Ultra tokens not staked\");\r\n     uint256 cycle = now.sub(ultraTokensStakedTime[userAddress]);\r\n    \r\n     if(cycle <= 21600)//21600 6 hours\r\n     {\r\n         return 0;\r\n     }\r\n     else if (cycle > 21600)//21600 6 hours\r\n     {     \r\n    \r\n      uint256 secondsToHours = cycle.div(21600);//21600 6 hours\r\n      return secondsToHours;\r\n     \r\n     }\r\n\r\n    }\r\n\r\n   function lockFoundersLP (uint256 value, uint256 stakers) external returns(uint256) {\r\n       \r\n    if (stakers ==1) {\r\n        \r\n       require(ERC20(uniV2superVsEth).balanceOf(msg.sender) >= value,'balance of a user is less then value');\r\n       uint256 checkAllowance = ERC20(uniV2superVsEth).allowance(msg.sender, address(this)); \r\n       require (checkAllowance >= value, 'allowance is wrong');\r\n       require(ERC20(uniV2superVsEth).transferFrom(msg.sender,address(this),value),'transfer From failed');\r\n\r\n       foundersLocking[msg.sender] = value;\r\n       foundersLockingTime[msg.sender] = now;\r\n\r\n\r\n    }else if (stakers ==2) {\r\n        \r\n       require(ERC20(uniV2MegavsEth).balanceOf(msg.sender) >= value,'balance of a user is less then value');\r\n       uint256 checkAllowance = ERC20(uniV2MegavsEth).allowance(msg.sender, address(this)); \r\n       require (checkAllowance >= value, 'allowance is wrong');\r\n       require(ERC20(uniV2MegavsEth).transferFrom(msg.sender,address(this),value),'transfer From failed');\r\n\r\n       foundersLockingMega[msg.sender] = value;\r\n       foundersLockingMegaTime[msg.sender] = now;        \r\n        \r\n        \r\n    } else  if (stakers ==3) {\r\n        \r\n        \r\n       require(ERC20(uniV2UltraVsEth).balanceOf(msg.sender) >= value,'balance of a user is less then value');\r\n       uint256 checkAllowance = ERC20(uniV2UltraVsEth).allowance(msg.sender, address(this)); \r\n       require (checkAllowance >= value, 'allowance is wrong');\r\n       require(ERC20(uniV2UltraVsEth).transferFrom(msg.sender,address(this),value),'transfer From failed');\r\n\r\n       foundersLockingUltra[msg.sender] = foundersLockingUltra[msg.sender].add(value);\r\n       foundersLockingUltraTime[msg.sender] = now;   \r\n        \r\n    } else {revert();}\r\n       \r\n   }\r\n\r\n    function claimLiquidityTokensSixMonths(uint256 token) external returns (bool) {\r\n        \r\n\r\n    if (token ==1) {\r\n    \r\n       require(now > foundersLockingTime[msg.sender].add(15552000));\r\n       require(ERC20(uniV2superVsEth).transfer(msg.sender,foundersLocking[msg.sender]));       \r\n\r\n\r\n    }else if (token ==2) {\r\n        \r\n       require(now > foundersLockingMegaTime[msg.sender].add(15552000));\r\n       require(ERC20(uniV2MegavsEth).transfer(msg.sender,foundersLockingMega[msg.sender]));       \r\n        \r\n        \r\n    } else  if (token ==3) {\r\n        \r\n        \r\n       require(now > foundersLockingUltraTime[msg.sender].add(15552000));\r\n       require(ERC20(uniV2UltraVsEth).transfer(msg.sender,foundersLockingUltra[msg.sender]));          \r\n        \r\n    } else {revert();}\r\n        \r\n    }\r\n\r\n   function burnAndStake (address accounts1,address accounts2,address accounts3) onlyOwner external returns (bool) {\r\n       \r\n       require(ERC20(superContractAddress).burnLiquidatedTokens(), \"burn liquidated failed\");\r\n       require(ERC20(megaContractAddress).giveRewardsToStakers(address(this), 1050 ether), \"Mega mint failed\");\r\n       require(ERC20(megaContractAddress).burn(1050 ether), \"Burn is not possible\");\r\n       require(ERC20(ultraContractAddress).giveRewardsToStakers(msg.sender,52.5 ether), \"Ultra Mint failed\");\r\n       ultraTokensStaked[accounts1] = 17.5 ether; foundersAddress[accounts1] = true; \r\n       ultraTokensStakedTime[accounts1] = now;    foundersAddress[accounts2] = true;\r\n       ultraTokensStaked[accounts1] = 17.5 ether; foundersAddress[accounts3] = true;\r\n       ultraTokensStakedTime[accounts1] = now;      \r\n       ultraTokensStaked[accounts1] = 17.5 ether;\r\n       ultraTokensStakedTime[accounts1] = now;\r\n      \r\n   } \r\n\r\n   function transferAnyERC20Token(address tokenAddress, uint tokens) public whenNotPaused onlyOwner returns (bool success) {\r\n        require(tokenAddress != address(0));\r\n        return ERC20(tokenAddress).transfer(owner, tokens);\r\n    }}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_super\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mega\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ultra\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"accounts1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accounts2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accounts3\",\"type\":\"address\"}],\"name\":\"burnAndStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"}],\"name\":\"claimLiquidityTokensSixMonths\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimMegaTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimSuperTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimUltraTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimableMegaTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimableSuperTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimableUltraTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"foundersAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"foundersLocking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"foundersLockingMega\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"foundersLockingMegaTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"foundersLockingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"foundersLockingUltra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"foundersLockingUltraTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakers\",\"type\":\"uint256\"}],\"name\":\"lockFoundersLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"megaContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"megaTokensStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"megaTokensStakedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniV2superVsEth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniV2MegavsEth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniV2UltraVsEth\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value3\",\"type\":\"uint256\"}],\"name\":\"setStakingRatio\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeMegaTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeSuperTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeUltraTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"stakedAllTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRatioMega\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRatioSuper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRatioUltra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRatios\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"superMegaUltraStakingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"superTokensStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"superTokensStakedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ultraContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ultraTokensStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ultraTokensStakedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unStakeUltraTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniV2MegavsEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniV2UltraVsEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniV2superVsEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"liquidityProviderTokensStaking","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003fe9c744bd6b59511b4b39fa669f9d259252bacd000000000000000000000000b0653b987010cefcac22866ce9abd4a0cbf975820000000000000000000000009ed144daf512f6f334abe4bb466569d114cdce2c","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3400cf17428cafec8038fe56d6e19fc9ab852871f5ad73e2fe5ce4af41ee5bb5"}]}