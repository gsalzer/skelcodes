{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/constants/CMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\naddress constant MCD_MANAGER = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\"\r\n    },\r\n    \"contracts/contracts/resolvers/MakerResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    _getMakerRawVaultDebt,\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\n\\ncontract MakerResolver {\\n    /// @dev Return Debt in wad of the vault associated to the vaultId.\\n    function getMakerVaultDebt(uint256 _vaultId) public view returns (uint256) {\\n        return _getMakerRawVaultDebt(_vaultId);\\n    }\\n\\n    /// @dev Return Collateral in wad of the vault associated to the vaultId.\\n    function getMakerVaultCollateralBalance(uint256 _vaultId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _getMakerVaultCollateralBalance(_vaultId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/functions/dapps/FMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {MCD_MANAGER} from \\\"../../constants/CMaker.sol\\\";\\nimport {IMcdManager} from \\\"../../interfaces/dapps/Maker/IMcdManager.sol\\\";\\nimport {IVat} from \\\"../../interfaces/dapps/Maker/IVat.sol\\\";\\nimport {RAY, sub, mul} from \\\"../../vendor/DSMath.sol\\\";\\n\\nfunction _getMakerVaultDebt(uint256 _vaultId) view returns (uint256 wad) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    IVat vat = IVat(manager.vat());\\n    (, uint256 rate, , , ) = vat.ilks(ilk);\\n    (, uint256 art) = vat.urns(ilk, urn);\\n    uint256 dai = vat.dai(urn);\\n\\n    uint256 rad = sub(mul(art, rate), dai);\\n    wad = rad / RAY;\\n\\n    wad = mul(wad, RAY) < rad ? wad + 1 : wad;\\n}\\n\\nfunction _getMakerRawVaultDebt(uint256 _vaultId) view returns (uint256 tab) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    IVat vat = IVat(manager.vat());\\n    (, uint256 rate, , , ) = vat.ilks(ilk);\\n    (, uint256 art) = vat.urns(ilk, urn);\\n\\n    uint256 rad = mul(art, rate);\\n\\n    tab = rad / RAY;\\n    tab = mul(tab, RAY) < rad ? tab + 1 : tab;\\n}\\n\\nfunction _getMakerVaultCollateralBalance(uint256 _vaultId)\\n    view\\n    returns (uint256)\\n{\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    IVat vat = IVat(manager.vat());\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    (uint256 ink, ) = vat.urns(ilk, urn);\\n\\n    return ink;\\n}\\n\\nfunction _getVaultData(IMcdManager manager, uint256 vault)\\n    view\\n    returns (bytes32 ilk, address urn)\\n{\\n    ilk = manager.ilks(vault);\\n    urn = manager.urns(vault);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/IMcdManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IMcdManager {\\n    function ilks(uint256) external view returns (bytes32);\\n\\n    function urns(uint256) external view returns (address);\\n\\n    function vat() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/IVat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IVat {\\n    function ilks(bytes32)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function dai(address) external view returns (uint256);\\n\\n    function urns(bytes32, address) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/DSMath.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: AGPL-3.0-or-later\\\"\\n/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.4;\\n\\nfunction add(uint x, uint y) pure returns (uint z) {\\n    require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n}\\nfunction sub(uint x, uint y) pure returns (uint z) {\\n    require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n}\\nfunction mul(uint x, uint y) pure returns (uint z) {\\n    require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n}\\n\\nfunction min(uint x, uint y) pure returns (uint z) {\\n    return x <= y ? x : y;\\n}\\nfunction max(uint x, uint y) pure returns (uint z) {\\n    return x >= y ? x : y;\\n}\\nfunction imin(int x, int y) pure returns (int z) {\\n    return x <= y ? x : y;\\n}\\nfunction imax(int x, int y) pure returns (int z) {\\n    return x >= y ? x : y;\\n}\\n\\nuint constant WAD = 10 ** 18;\\nuint constant RAY = 10 ** 27;\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction wmul(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, y), WAD / 2) / WAD;\\n}\\n//rounds to zero if x*y < WAD / 2\\nfunction rmul(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, y), RAY / 2) / RAY;\\n}\\n//rounds to zero if x*y < WAD / 2\\nfunction wdiv(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, WAD), y / 2) / y;\\n}\\n//rounds to zero if x*y < RAY / 2\\nfunction rdiv(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, RAY), y / 2) / y;\\n}\\n\\n// This famous algorithm is called \\\"exponentiation by squaring\\\"\\n// and calculates x^n with x as fixed-point and n as regular unsigned.\\n//\\n// It's O(log n), instead of O(n) for naive repeated multiplication.\\n//\\n// These facts are why it works:\\n//\\n//  If n is even, then x^n = (x^2)^(n/2).\\n//  If n is odd,  then x^n = x * x^(n-1),\\n//   and applying the equation for even x gives\\n//    x^n = x * (x^2)^((n-1) / 2).\\n//\\n//  Also, EVM division is flooring and\\n//    floor[(n-1) / 2] = floor[n / 2].\\n//\\nfunction rpow(uint x, uint n) pure returns (uint z) {\\n    z = n % 2 != 0 ? x : RAY;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n        x = rmul(x, x);\\n\\n        if (n % 2 != 0) {\\n            z = rmul(z, x);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"getMakerVaultCollateralBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"getMakerVaultDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MakerResolver","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":""}]}