{"status":"1","message":"OK","result":[{"SourceCode":"{\"AcceptModifications.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"LibConstants.sol\\\";\\nimport \\\"MAcceptModifications.sol\\\";\\nimport \\\"MTokenQuantization.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\n\\n/*\\n  Interface containing actions a verifier can invoke on the state.\\n  The contract containing the state should implement these and verify correctness.\\n*/\\nabstract contract AcceptModifications is\\n    MainStorage,\\n    LibConstants,\\n    MAcceptModifications,\\n    MTokenQuantization\\n{\\n    event LogWithdrawalAllowed(\\n        uint256 starkKey,\\n        uint256 assetType,\\n        uint256 nonQuantizedAmount,\\n        uint256 quantizedAmount\\n    );\\n\\n    event LogNftWithdrawalAllowed(uint256 starkKey, uint256 assetId);\\n\\n    event LogMintableWithdrawalAllowed(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    );\\n\\n    /*\\n      Transfers funds from the on-chain deposit area to the off-chain area.\\n      Implemented in the Deposits contracts.\\n    */\\n    function acceptDeposit(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    ) internal virtual override {\\n        // Fetch deposit.\\n        require(\\n            pendingDeposits[starkKey][assetId][vaultId] \\u003e= quantizedAmount,\\n            \\\"DEPOSIT_INSUFFICIENT\\\"\\n        );\\n\\n        // Subtract accepted quantized amount.\\n        pendingDeposits[starkKey][assetId][vaultId] -= quantizedAmount;\\n    }\\n\\n    /*\\n      Transfers funds from the off-chain area to the on-chain withdrawal area.\\n    */\\n    function allowWithdrawal(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    )\\n        internal\\n        override\\n    {\\n        // Fetch withdrawal.\\n        uint256 withdrawal = pendingWithdrawals[starkKey][assetId];\\n\\n        // Add accepted quantized amount.\\n        withdrawal += quantizedAmount;\\n        require(withdrawal \\u003e= quantizedAmount, \\\"WITHDRAWAL_OVERFLOW\\\");\\n\\n        // Store withdrawal.\\n        pendingWithdrawals[starkKey][assetId] = withdrawal;\\n\\n        // Log event.\\n        uint256 presumedAssetType = assetId;\\n        if (registeredAssetType[presumedAssetType]) {\\n            emit LogWithdrawalAllowed(\\n                starkKey,\\n                presumedAssetType,\\n                fromQuantized(presumedAssetType, quantizedAmount),\\n                quantizedAmount\\n            );\\n        } else if(assetId == ((assetId \\u0026 MASK_240) | STARKEX_MINTABLE_ASSET_ID_FLAG)) {\\n            emit LogMintableWithdrawalAllowed(\\n                starkKey,\\n                assetId,\\n                quantizedAmount\\n            );\\n        }\\n        else {\\n            // In ERC721 case, assetId is not the assetType.\\n            require(withdrawal \\u003c= 1, \\\"INVALID_NFT_AMOUNT\\\");\\n            emit LogNftWithdrawalAllowed(starkKey, assetId);\\n        }\\n    }\\n\\n    // Verifier authorizes withdrawal.\\n    function acceptWithdrawal(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    ) internal virtual override {\\n        allowWithdrawal(starkKey, assetId, quantizedAmount);\\n    }\\n}\\n\"},\"ActionHash.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"LibConstants.sol\\\";\\n\\n/*\\n  Calculation action hash for the various forced actions in a generic manner.\\n*/\\ncontract ActionHash is MainStorage , LibConstants{\\n\\n    function getActionHash(string memory actionName, bytes memory packedActionParameters)\\n        internal\\n        pure\\n        returns(bytes32 actionHash)\\n    {\\n        actionHash = keccak256(abi.encodePacked(actionName, packedActionParameters));\\n    }\\n\\n    function setActionHash(bytes32 actionHash, bool premiumCost) internal\\n    {\\n        // The rate of forced trade requests is restricted.\\n        // First restriction is by capping the number of requests in a block.\\n        // User can override this cap by requesting with a permium flag set,\\n        // in this case, the gas cost is high (~1M) but no \\\"technical\\\" limit is set.\\n        // However, the high gas cost creates an obvious limitation due to the block gas limit.\\n        if (premiumCost) {\\n            for (uint256 i = 0; i \\u003c 22231; i++) {}\\n        } else {\\n            require(\\n                forcedRequestsInBlock[block.number] \\u003c MAX_FORCED_ACTIONS_REQS_PER_BLOCK,\\n                \\\"MAX_REQUESTS_PER_BLOCK_REACHED\\\");\\n            forcedRequestsInBlock[block.number] += 1;\\n        }\\n        forcedActionRequests[actionHash] = block.timestamp;\\n    }\\n}\\n\"},\"Common.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\n/*\\n  Common Utility librarries.\\n  I. Addresses (extending address).\\n*/\\nlibrary Addresses {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    function performEthTransfer(address recipient, uint256 amount) internal {\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\"); // NOLINT: low-level-calls.\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*\\n      Safe wrapper around ERC20/ERC721 calls.\\n      This is required because many deployed ERC20 contracts don\\u0027t return a value.\\n      See https://github.com/ethereum/solidity/issues/4116.\\n    */\\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\\n        require(isContract(tokenAddress), \\\"BAD_TOKEN_ADDRESS\\\");\\n        // NOLINTNEXTLINE: low-level-calls.\\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\\n        require(success, string(returndata));\\n\\n        if (returndata.length \\u003e 0) {\\n            require(abi.decode(returndata, (bool)), \\\"TOKEN_OPERATION_FAILED\\\");\\n        }\\n    }\\n\\n    /*\\n      Similar to safeTokenContractCall, but always ignores the return value.\\n\\n      Assumes some other method is used to detect the failures\\n      (e.g. balance is checked before and after the call).\\n    */\\n    function uncheckedTokenContractCall(address tokenAddress, bytes memory callData) internal {\\n        // NOLINTNEXTLINE: low-level-calls.\\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\\n        require(success, string(returndata));\\n    }\\n\\n}\\n\\nlibrary UintArray {\\n    function hashSubArray(uint256[] memory array, uint256 subArrayStart, uint256 subArraySize)\\n        internal pure\\n        returns(bytes32 subArrayHash)\\n    {\\n        require(array.length \\u003e= subArrayStart + subArraySize, \\\"ILLEGAL_SUBARRAY_DIMENSIONS\\\");\\n        uint256 startOffsetBytes = 0x20 * (1 + subArrayStart);\\n        uint256 dataSizeBytes = 0x20 * subArraySize;\\n        assembly {\\n            subArrayHash := keccak256(add(array, startOffsetBytes), dataSizeBytes)\\n        }\\n    }\\n\\n    /*\\n      Returns the address of a cell in offset within a uint256[] array.\\n      This allows assigning new variable of dynamic unit256[] pointing to a sub_array\\n      with a layout of serialied uint256[] (i.e. length+content).\\n    */\\n    function extractSerializedUintArray(uint256[] memory programOutput, uint256 offset)\\n        internal pure\\n        returns (uint256[] memory addr)\\n    {\\n        uint256 memOffset = 0x20 * (offset + 1);\\n        assembly {\\n            addr := add(programOutput, memOffset)\\n        }\\n    }\\n\\n}\\n\\n/*\\n  II. StarkExTypes - Common data types.\\n*/\\nlibrary StarkExTypes {\\n\\n    // Structure representing a list of verifiers (validity/availability).\\n    // A statement is valid only if all the verifiers in the list agree on it.\\n    // Adding a verifier to the list is immediate - this is used for fast resolution of\\n    // any soundness issues.\\n    // Removing from the list is time-locked, to ensure that any user of the system\\n    // not content with the announced removal has ample time to leave the system before it is\\n    // removed.\\n    struct ApprovalChainData {\\n        address[] list;\\n        // Represents the time after which the verifier with the given address can be removed.\\n        // Removal of the verifier with address A is allowed only in the case the value\\n        // of unlockedForRemovalTime[A] != 0 and unlockedForRemovalTime[A] \\u003c (current time).\\n        mapping (address =\\u003e uint256) unlockedForRemovalTime;\\n    }\\n}\\n\"},\"Configuration.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MGovernance.sol\\\";\\nimport \\\"LibConstants.sol\\\";\\nimport \\\"PerpetualStorage.sol\\\";\\n\\n/**\\n  Configuration contract facilitates storing system configuration hashes.\\n  A configuration item hash can be stored only once, and cannot be altered or removed.\\n\\n  If there is a need for a configuration change (not addition of new one),\\n  it shall be performed via upgrade using a dedicated External Initializing Contract (EIC).\\n*/\\nabstract contract Configuration is PerpetualStorage, LibConstants, MGovernance {\\n\\n    // This key is used in for the actionsTimeLock.\\n    uint256 constant GLOBAL_CONFIG_KEY = uint256(~0);\\n\\n    event LogGlobalConfigurationRegistered(bytes32 configHash);\\n    event LogGlobalConfigurationApplied(bytes32 configHash);\\n    event LogGlobalConfigurationRemoved(bytes32 configHash);\\n    event LogAssetConfigurationRegistered(uint256 assetId, bytes32 configHash);\\n    event LogAssetConfigurationApplied(uint256 assetId, bytes32 configHash);\\n    event LogAssetConfigurationRemoved(uint256 assetId, bytes32 configHash);\\n\\n    /*\\n      Configuration delay is set during initialization.\\n      It is designed to be changed only through upgrade cycle, by altering the storage variable.\\n    */\\n    function initialize(uint256 delay) internal {\\n        configurationDelay = delay;\\n    }\\n\\n    /*\\n      Register global configuration hash, for applying once configuration delay time-lock expires.\\n    */\\n    function registerGlobalConfigurationChange(bytes32 configHash)\\n        external\\n        onlyGovernance\\n    {\\n        require(uint256(configHash) \\u003c K_MODULUS, \\\"INVALID_CONFIG_HASH\\\");\\n        bytes32 actionKey = keccak256(abi.encodePacked(GLOBAL_CONFIG_KEY, configHash));\\n\\n        actionsTimeLock[actionKey] = block.timestamp + configurationDelay;\\n        emit LogGlobalConfigurationRegistered(configHash);\\n    }\\n\\n    /*\\n      Applies global configuration hash.\\n    */\\n    function applyGlobalConfigurationChange(bytes32 configHash)\\n        external\\n        onlyGovernance\\n    {\\n        bytes32 actionKey = keccak256(abi.encode(GLOBAL_CONFIG_KEY, configHash));\\n        uint256 activationTime = actionsTimeLock[actionKey];\\n        require(activationTime \\u003e 0, \\\"CONFIGURATION_NOT_REGSITERED\\\");\\n        require(activationTime \\u003c= block.timestamp, \\\"CONFIGURATION_NOT_ENABLE_YET\\\");\\n        globalConfigurationHash = configHash;\\n        emit LogGlobalConfigurationApplied(configHash);\\n    }\\n\\n    function removeGlobalConfigurationChange(bytes32 configHash)\\n        external\\n        onlyGovernance\\n    {\\n        bytes32 actionKey = keccak256(abi.encodePacked(GLOBAL_CONFIG_KEY, configHash));\\n        require(actionsTimeLock[actionKey] \\u003e 0, \\\"CONFIGURATION_NOT_REGSITERED\\\");\\n        delete actionsTimeLock[actionKey];\\n        emit LogGlobalConfigurationRemoved(configHash);\\n    }\\n\\n    /*\\n      Register an asset configuration hash, for applying once configuration delay time-lock expires.\\n    */\\n    function registerAssetConfigurationChange(uint256 assetId, bytes32 configHash)\\n        external\\n        onlyGovernance\\n    {\\n        require(assetId \\u003c PERPETUAL_ASSET_ID_UPPER_BOUND, \\\"INVALID_ASSET_ID\\\");\\n        require(uint256(configHash) \\u003c K_MODULUS, \\\"INVALID_CONFIG_HASH\\\");\\n        bytes32 actionKey = keccak256(abi.encode(assetId, configHash));\\n        actionsTimeLock[actionKey] = block.timestamp + configurationDelay;\\n        emit LogAssetConfigurationRegistered(assetId, configHash);\\n    }\\n\\n    /*\\n      Applies asset configuration hash.\\n    */\\n    function applyAssetConfigurationChange(uint256 assetId, bytes32 configHash)\\n        external\\n        onlyGovernance\\n    {\\n        bytes32 actionKey = keccak256(abi.encode(assetId, configHash));\\n        uint256 activationTime = actionsTimeLock[actionKey];\\n        require(activationTime \\u003e 0, \\\"CONFIGURATION_NOT_REGSITERED\\\");\\n        require(activationTime \\u003c= block.timestamp, \\\"CONFIGURATION_NOT_ENABLE_YET\\\");\\n        configurationHash[assetId] = configHash;\\n        emit LogAssetConfigurationApplied(assetId, configHash);\\n    }\\n\\n    function removeAssetConfigurationChange(uint256 assetId, bytes32 configHash)\\n        external\\n        onlyGovernance\\n    {\\n        bytes32 actionKey = keccak256(abi.encode(assetId, configHash));\\n        require(actionsTimeLock[actionKey] \\u003e 0, \\\"CONFIGURATION_NOT_REGSITERED\\\");\\n        delete actionsTimeLock[actionKey];\\n        emit LogAssetConfigurationRemoved(assetId, configHash);\\n    }\\n}\\n\"},\"ForcedTradeActionState.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"ActionHash.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"MForcedTradeActionState.sol\\\";\\n\\n/*\\n  ForcedTrade specific action hashses.\\n*/\\ncontract ForcedTradeActionState is MainStorage, ActionHash, MForcedTradeActionState {\\n    function forcedTradeActionHash(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    ) internal pure override returns (bytes32) {\\n        return\\n            getActionHash(\\n                \\\"FORCED_TRADE\\\",\\n                abi.encodePacked(\\n                    starkKeyA,\\n                    starkKeyB,\\n                    vaultIdA,\\n                    vaultIdB,\\n                    collateralAssetId,\\n                    syntheticAssetId,\\n                    amountCollateral,\\n                    amountSynthetic,\\n                    aIsBuyingSynthetic,\\n                    nonce\\n                )\\n            );\\n    }\\n\\n    function clearForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    ) internal override {\\n        /*\\n          We don\\u0027t clear the entry, but set the time to max so that\\n          it cannot be replayed.\\n        */\\n        bytes32 actionHash = forcedTradeActionHash(\\n            starkKeyA,\\n            starkKeyB,\\n            vaultIdA,\\n            vaultIdB,\\n            collateralAssetId,\\n            syntheticAssetId,\\n            amountCollateral,\\n            amountSynthetic,\\n            aIsBuyingSynthetic,\\n            nonce\\n        );\\n        // A cleared ForcedTrade action is marked with ~0 and not zero, to prevent party A from\\n        // replaying the trade without a new signature from party B.\\n        require(forcedActionRequests[actionHash] != uint256(~0), \\\"ACTION_ALREADY_CLEARED\\\");\\n        require(forcedActionRequests[actionHash] != 0, \\\"NON_EXISTING_ACTION\\\");\\n        forcedActionRequests[actionHash] = uint256(~0);\\n    }\\n\\n    function getForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce\\n    ) public view override returns (uint256) {\\n        return\\n            forcedActionRequests[forcedTradeActionHash(\\n                starkKeyA,\\n                starkKeyB,\\n                vaultIdA,\\n                vaultIdB,\\n                collateralAssetId,\\n                syntheticAssetId,\\n                amountCollateral,\\n                amountSynthetic,\\n                aIsBuyingSynthetic,\\n                nonce\\n            )];\\n    }\\n\\n    function setForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce,\\n        bool premiumCost\\n    ) internal override {\\n        bytes32 actionHash = forcedTradeActionHash(\\n            starkKeyA,\\n            starkKeyB,\\n            vaultIdA,\\n            vaultIdB,\\n            collateralAssetId,\\n            syntheticAssetId,\\n            amountCollateral,\\n            amountSynthetic,\\n            aIsBuyingSynthetic,\\n            nonce\\n        );\\n        // NOLINTNEXTLINE: timestamp.\\n        require(forcedActionRequests[actionHash] == 0, \\\"FORCED_TRADE_REPLAYED\\\");\\n        setActionHash(actionHash, premiumCost);\\n    }\\n}\\n\"},\"ForcedWithdrawalActionState.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"ActionHash.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"MForcedWithdrawalActionState.sol\\\";\\n\\n/*\\n  ForcedWithdrawal specific action hashses.\\n*/\\ncontract ForcedWithdrawalActionState is\\n    MainStorage,\\n    ActionHash,\\n    MForcedWithdrawalActionState\\n{\\n    function forcedWithdrawActionHash(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount)\\n        internal\\n        pure\\n        override\\n        returns (bytes32)\\n    {\\n        return getActionHash(\\\"FORCED_WITHDRAWAL\\\", abi.encode(starkKey, vaultId, quantizedAmount));\\n    }\\n\\n    function clearForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount)\\n        internal\\n        override {\\n        bytes32 actionHash = forcedWithdrawActionHash(starkKey, vaultId, quantizedAmount);\\n        require(forcedActionRequests[actionHash] != 0, \\\"NON_EXISTING_ACTION\\\");\\n        delete forcedActionRequests[actionHash];\\n    }\\n\\n    function getForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        // Return request value. Expect zero if the request doesn\\u0027t exist or has been serviced, and\\n        // a non-zero value otherwise.\\n        return forcedActionRequests[forcedWithdrawActionHash(starkKey, vaultId, quantizedAmount)];\\n    }\\n\\n    function setForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount,\\n        bool premiumCost)\\n        internal\\n        override {\\n        setActionHash(forcedWithdrawActionHash(starkKey, vaultId, quantizedAmount), premiumCost);\\n    }\\n}\\n\"},\"Freezable.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"LibConstants.sol\\\";\\nimport \\\"MFreezable.sol\\\";\\nimport \\\"MGovernance.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\n\\n/*\\n  Implements MFreezable.\\n*/\\nabstract contract Freezable is MainStorage, LibConstants, MGovernance, MFreezable {\\n    event LogFrozen();\\n    event LogUnFrozen();\\n\\n    function isFrozen() public view override returns (bool) {\\n        return stateFrozen;\\n    }\\n\\n    function validateFreezeRequest(uint256 requestTime) internal override {\\n        require(requestTime != 0, \\\"FORCED_ACTION_UNREQUESTED\\\");\\n        // Verify timer on escape request.\\n        uint256 freezeTime = requestTime + FREEZE_GRACE_PERIOD;\\n\\n        // Prevent wraparound.\\n        assert(freezeTime \\u003e= FREEZE_GRACE_PERIOD);\\n        require(block.timestamp \\u003e= freezeTime, \\\"FORCED_ACTION_PENDING\\\"); // NOLINT: timestamp.\\n\\n        // Forced action requests placed before freeze, are no longer valid after the un-freeze.\\n        require(freezeTime \\u003e unFreezeTime, \\\"REFREEZE_ATTEMPT\\\");\\n    }\\n\\n    function freeze()\\n        internal\\n        override\\n        notFrozen()\\n    {\\n        unFreezeTime = block.timestamp + UNFREEZE_DELAY;\\n\\n        // Update state.\\n        stateFrozen = true;\\n\\n        // Log event.\\n        emit LogFrozen();\\n    }\\n\\n    function unFreeze()\\n        external\\n        onlyFrozen()\\n        onlyGovernance()\\n    {\\n        require(block.timestamp \\u003e= unFreezeTime, \\\"UNFREEZE_NOT_ALLOWED_YET\\\");\\n\\n        // Update state.\\n        stateFrozen = false;\\n\\n        // Increment roots to invalidate them, w/o losing information.\\n        vaultRoot += 1;\\n        orderRoot += 1;\\n\\n        // Log event.\\n        emit LogUnFrozen();\\n    }\\n\\n}\\n\"},\"Governance.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"GovernanceStorage.sol\\\";\\nimport \\\"MGovernance.sol\\\";\\n\\n/*\\n  Implements Generic Governance, applicable for both proxy and main contract, and possibly others.\\n  Notes:\\n  1. This class is virtual (getGovernanceTag is not implemented).\\n  2. The use of the same function names by both the Proxy and a delegated implementation\\n     is not possible since calling the implementation functions is done via the default function\\n     of the Proxy. For this reason, for example, the implementation of MainContract (MainGovernance)\\n     exposes mainIsGovernor, which calls the internal isGovernor method.\\n*/\\nabstract contract Governance is GovernanceStorage, MGovernance {\\n    event LogNominatedGovernor(address nominatedGovernor);\\n    event LogNewGovernorAccepted(address acceptedGovernor);\\n    event LogRemovedGovernor(address removedGovernor);\\n    event LogNominationCancelled();\\n\\n    /*\\n      Returns a string which uniquely identifies the type of the governance mechanism.\\n    */\\n    function getGovernanceTag()\\n        virtual\\n        internal\\n        pure\\n        returns (string memory);\\n\\n    /*\\n      Returns the GovernanceInfoStruct associated with the governance tag.\\n    */\\n    function contractGovernanceInfo()\\n        internal\\n        view\\n        returns (GovernanceInfoStruct storage) {\\n        string memory tag = getGovernanceTag();\\n        GovernanceInfoStruct storage gub = governanceInfo[tag];\\n        require(gub.initialized, \\\"NOT_INITIALIZED\\\");\\n        return gub;\\n    }\\n\\n    /*\\n      Current code intentionally prevents governance re-initialization.\\n      This may be a problem in an upgrade situation, in a case that the upgrade-to implementation\\n      performs an initialization (for real) and within that calls initGovernance().\\n\\n      Possible workarounds:\\n      1. Clearing the governance info altogether by changing the MAIN_GOVERNANCE_INFO_TAG.\\n         This will remove existing main governance information.\\n      2. Modify the require part in this function, so that it will exit quietly\\n         when trying to re-initialize (uncomment the lines below).\\n    */\\n    function initGovernance()\\n        internal\\n    {\\n        string memory tag = getGovernanceTag();\\n        GovernanceInfoStruct storage gub = governanceInfo[tag];\\n        require(!gub.initialized, \\\"ALREADY_INITIALIZED\\\");\\n        gub.initialized = true;  // to ensure addGovernor() won\\u0027t fail.\\n        // Add the initial governer.\\n        addGovernor(msg.sender);\\n    }\\n\\n    modifier onlyGovernance () override\\n    {\\n        require(isGovernor(msg.sender), \\\"ONLY_GOVERNANCE\\\");\\n        _;\\n    }\\n\\n    function isGovernor(address testGovernor)\\n        internal view\\n        returns (bool addressIsGovernor){\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        addressIsGovernor = gub.effectiveGovernors[testGovernor];\\n    }\\n\\n    /*\\n      Cancels the nomination of a governor candidate.\\n    */\\n    function cancelNomination() internal onlyGovernance() {\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        gub.candidateGovernor = address(0x0);\\n        emit LogNominationCancelled();\\n    }\\n\\n    function nominateNewGovernor(address newGovernor) internal onlyGovernance() {\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        require(!isGovernor(newGovernor), \\\"ALREADY_GOVERNOR\\\");\\n        gub.candidateGovernor = newGovernor;\\n        emit LogNominatedGovernor(newGovernor);\\n    }\\n\\n    /*\\n      The addGovernor is called in two cases:\\n      1. by acceptGovernance when a new governor accepts its role.\\n      2. by initGovernance to add the initial governor.\\n      The difference is that the init path skips the nominate step\\n      that would fail because of the onlyGovernance modifier.\\n    */\\n    function addGovernor(address newGovernor) private {\\n        require(!isGovernor(newGovernor), \\\"ALREADY_GOVERNOR\\\");\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        gub.effectiveGovernors[newGovernor] = true;\\n    }\\n\\n    function acceptGovernance()\\n        internal\\n    {\\n        // The new governor was proposed as a candidate by the current governor.\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        require(msg.sender == gub.candidateGovernor, \\\"ONLY_CANDIDATE_GOVERNOR\\\");\\n\\n        // Update state.\\n        addGovernor(gub.candidateGovernor);\\n        gub.candidateGovernor = address(0x0);\\n\\n        // Send a notification about the change of governor.\\n        emit LogNewGovernorAccepted(msg.sender);\\n    }\\n\\n    /*\\n      Remove a governor from office.\\n    */\\n    function removeGovernor(address governorForRemoval) internal onlyGovernance() {\\n        require(msg.sender != governorForRemoval, \\\"GOVERNOR_SELF_REMOVE\\\");\\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\\n        require (isGovernor(governorForRemoval), \\\"NOT_GOVERNOR\\\");\\n        gub.effectiveGovernors[governorForRemoval] = false;\\n        emit LogRemovedGovernor(governorForRemoval);\\n    }\\n}\\n\"},\"GovernanceStorage.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\n/*\\n  Holds the governance slots for ALL entities, including proxy and the main contract.\\n*/\\ncontract GovernanceStorage {\\n\\n    struct GovernanceInfoStruct {\\n        mapping (address =\\u003e bool) effectiveGovernors;\\n        address candidateGovernor;\\n        bool initialized;\\n    }\\n\\n    // A map from a Governor tag to its own GovernanceInfoStruct.\\n    mapping (string =\\u003e GovernanceInfoStruct) internal governanceInfo;\\n}\\n\"},\"Identity.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\ninterface Identity {\\n\\n    /*\\n      Allows a caller, typically another contract,\\n      to ensure that the provided address is of the expected type and version.\\n    */\\n    function identify()\\n        external pure\\n        returns(string memory);\\n}\\n\"},\"IFactRegistry.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\n/*\\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\\n  business logic of the contract flow.\\n\\n  A fact registry holds a hash table of verified \\\"facts\\\" which are represented by a hash of claims\\n  that the registry hash check and found valid. This table may be queried by accessing the\\n  isValid() function of the registry with a given hash.\\n\\n  In addition, each fact registry exposes a registry specific function for submitting new claims\\n  together with their proofs. The information submitted varies from one registry to the other\\n  depending of the type of fact requiring verification.\\n\\n  For further reading on the Fact Registry design pattern see this\\n  `StarkWare blog post \\u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\\u003e`_.\\n*/\\ninterface IFactRegistry {\\n    /*\\n      Returns true if the given fact was previously registered in the contract.\\n    */\\n    function isValid(bytes32 fact)\\n        external view\\n        returns(bool);\\n}\\n\"},\"KeyGetters.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"MKeyGetters.sol\\\";\\n\\n/*\\n  Implements MKeyGetters.\\n*/\\ncontract KeyGetters is MainStorage, MKeyGetters {\\n    function getEthKey(uint256 starkKey) public view\\n        override returns (address ethKey) {\\n        // Fetch the user\\u0027s Ethereum key.\\n        ethKey = ethKeys[starkKey];\\n        require(ethKey != address(0x0), \\\"USER_UNREGISTERED\\\");\\n    }\\n\\n    function isMsgSenderStarkKeyOwner(uint256 starkKey) internal view\\n        override returns (bool) {\\n        return msg.sender == getEthKey(starkKey);\\n    }\\n\\n    modifier isSenderStarkKey(uint256 starkKey) override {\\n        // Require the calling user to own the stark key.\\n        require(isMsgSenderStarkKeyOwner(starkKey), \\\"MISMATCHING_STARK_ETH_KEYS\\\");\\n        _;\\n    }\\n}\\n\"},\"LibConstants.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\ncontract LibConstants {\\n    // Durations for time locked mechanisms (in seconds).\\n    // Note that it is known that miners can manipulate block timestamps\\n    // up to a deviation of a few seconds.\\n    // This mechanism should not be used for fine grained timing.\\n\\n    // The time required to cancel a deposit, in the case the operator does not move the funds\\n    // to the off-chain storage.\\n    uint256 public constant DEPOSIT_CANCEL_DELAY = 7 days;\\n\\n    // The time required to freeze the exchange, in the case the operator does not execute a\\n    // requested full withdrawal.\\n    uint256 public constant FREEZE_GRACE_PERIOD = 14 days;\\n\\n    // The time after which the exchange may be unfrozen after it froze. This should be enough time\\n    // for users to perform escape hatches to get back their funds.\\n    uint256 public constant UNFREEZE_DELAY = 365 days;\\n\\n    // Maximal number of verifiers which may co-exist.\\n    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);\\n\\n    // The time required to remove a verifier in case of a verifier upgrade.\\n    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);\\n\\n    address constant ZERO_ADDRESS = address(0x0);\\n\\n    uint256 constant K_MODULUS =\\n    0x800000000000011000000000000000000000000000000000000000000000001;\\n\\n    uint256 constant K_BETA =\\n    0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\\n\\n    uint256 internal constant MASK_250 =\\n    0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant MASK_240 =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    uint256 public constant MAX_FORCED_ACTIONS_REQS_PER_BLOCK = 10;\\n\\n    // ======================================================\\n    //            StarkEx specific constants\\n    // ======================================================\\n    uint256 constant STARKEX_MAX_VAULT_ID = 2**31 - 1;\\n    uint256 constant STARKEX_MAX_QUANTUM = 2**128 - 1;\\n    uint256 constant STARKEX_EXPIRATION_TIMESTAMP_BITS = 22;\\n    uint256 internal constant STARKEX_MINTABLE_ASSET_ID_FLAG = 1\\u003c\\u003c250;\\n\\n    // ======================================================\\n    //            StarkEx specific constants\\n    // ======================================================\\n    uint256 constant PERPETUAL_POSITION_ID_UPPER_BOUND = 2**64;\\n    uint256 constant PERPETUAL_AMOUNT_UPPER_BOUND = 2**64;\\n    uint256 constant PERPETUAL_TIMESTAMP_BITS = 32;\\n    uint256 constant PERPETUAL_ASSET_ID_UPPER_BOUND = 2**120;\\n    uint256 constant PERPETUAL_SYSTEM_TIME_LAG_BOUND = 14 days;\\n    uint256 constant PERPETUAL_SYSTEM_TIME_ADVANCE_BOUND = 4 hours;\\n    uint256 constant PERPETUAL_CONFIGURATION_DELAY = 0;\\n}\\n\"},\"MAcceptModifications.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\n/*\\n  Interface containing actions a verifier can invoke on the state.\\n  The contract containing the state should implement these and verify correctness.\\n*/\\nabstract contract MAcceptModifications {\\n\\n    function acceptDeposit(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    )\\n        internal virtual;\\n\\n    function allowWithdrawal(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    )\\n        internal virtual;\\n\\n    function acceptWithdrawal(\\n        uint256 starkKey,\\n        uint256 assetId,\\n        uint256 quantizedAmount\\n    )\\n    internal virtual;\\n\\n}\\n\"},\"MainGovernance.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"Governance.sol\\\";\\n\\n/**\\n  The StarkEx contract is governed by one or more Governors of which the initial one is the\\n  deployer of the contract.\\n\\n  A governor has the sole authority to perform the following operations:\\n\\n  1. Nominate additional governors (:sol:func:`mainNominateNewGovernor`)\\n  2. Remove other governors (:sol:func:`mainRemoveGovernor`)\\n  3. Add new :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers`\\n  4. Remove :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers` after a timelock allows it\\n  5. Nominate Operators (see :sol:mod:`Operator`) and Token Administrators (see :sol:mod:`Tokens`)\\n\\n  Adding governors is performed in a two step procedure:\\n\\n  1. First, an existing governor nominates a new governor (:sol:func:`mainNominateNewGovernor`)\\n  2. Then, the new governor must accept governance to become a governor (:sol:func:`mainAcceptGovernance`)\\n\\n  This two step procedure ensures that a governor public key cannot be nominated unless there is an\\n  entity that has the corresponding private key. This is intended to prevent errors in the addition\\n  process.\\n\\n  The governor private key should typically be held in a secure cold wallet.\\n*/\\n/*\\n  Implements Governance for the StarkDex main contract.\\n  The wrapper methods (e.g. mainIsGovernor wrapping isGovernor) are needed to give\\n  the method unique names.\\n  Both Proxy and StarkExchange inherit from Governance. Thus, the logical contract method names\\n  must have unique names in order for the proxy to successfully delegate to them.\\n*/\\ncontract MainGovernance is Governance {\\n\\n    // The tag is the sting key that is used in the Governance storage mapping.\\n    string public constant MAIN_GOVERNANCE_INFO_TAG = \\\"StarkEx.Main.2019.GovernorsInformation\\\";\\n\\n    function getGovernanceTag()\\n        internal\\n        pure\\n        override\\n        returns (string memory tag) {\\n        tag = MAIN_GOVERNANCE_INFO_TAG;\\n    }\\n\\n    function mainIsGovernor(address testGovernor) external view returns (bool) {\\n        return isGovernor(testGovernor);\\n    }\\n\\n    function mainNominateNewGovernor(address newGovernor) external {\\n        nominateNewGovernor(newGovernor);\\n    }\\n\\n    function mainRemoveGovernor(address governorForRemoval) external {\\n        removeGovernor(governorForRemoval);\\n    }\\n\\n    function mainAcceptGovernance()\\n        external\\n    {\\n        acceptGovernance();\\n    }\\n\\n    function mainCancelNomination() external {\\n        cancelNomination();\\n    }\\n\\n}\\n\"},\"MainStorage.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"IFactRegistry.sol\\\";\\nimport \\\"ProxyStorage.sol\\\";\\nimport \\\"Common.sol\\\";\\n/*\\n  Holds ALL the main contract state (storage) variables.\\n*/\\ncontract MainStorage is ProxyStorage {\\n\\n    uint256 constant internal LAYOUT_LENGTH = 2**64;\\n\\n    IFactRegistry escapeVerifier_;\\n\\n    // Global dex-frozen flag.\\n    bool stateFrozen;                               // NOLINT: constable-states.\\n\\n    // Time when unFreeze can be successfully called (UNFREEZE_DELAY after freeze).\\n    uint256 unFreezeTime;                           // NOLINT: constable-states.\\n\\n    // Pending deposits.\\n    // A map STARK key =\\u003e asset id =\\u003e vault id =\\u003e quantized amount.\\n    mapping (uint256 =\\u003e mapping (uint256 =\\u003e mapping (uint256 =\\u003e uint256))) pendingDeposits;\\n\\n    // Cancellation requests.\\n    // A map STARK key =\\u003e asset id =\\u003e vault id =\\u003e request timestamp.\\n    mapping (uint256 =\\u003e mapping (uint256 =\\u003e mapping (uint256 =\\u003e uint256))) cancellationRequests;\\n\\n    // Pending withdrawals.\\n    // A map STARK key =\\u003e asset id =\\u003e quantized amount.\\n    mapping (uint256 =\\u003e mapping (uint256 =\\u003e uint256)) pendingWithdrawals;\\n\\n    // vault_id =\\u003e escape used boolean.\\n    mapping (uint256 =\\u003e bool) escapesUsed;\\n\\n    // Number of escapes that were performed when frozen.\\n    uint256 escapesUsedCount;                       // NOLINT: constable-states.\\n\\n    // NOTE: fullWithdrawalRequests is deprecated, and replaced by forcedActionRequests.\\n    // NOLINTNEXTLINE naming-convention.\\n    mapping (uint256 =\\u003e mapping (uint256 =\\u003e uint256)) fullWithdrawalRequests_DEPRECATED;\\n\\n    // State sequence number.\\n    uint256 sequenceNumber;                         // NOLINT: constable-states uninitialized-state.\\n\\n    // Vaults Tree Root \\u0026 Height.\\n    uint256 vaultRoot;                              // NOLINT: constable-states uninitialized-state.\\n    uint256 vaultTreeHeight;                        // NOLINT: constable-states uninitialized-state.\\n\\n    // Order Tree Root \\u0026 Height.\\n    uint256 orderRoot;                              // NOLINT: constable-states uninitialized-state.\\n    uint256 orderTreeHeight;                        // NOLINT: constable-states uninitialized-state.\\n\\n    // True if and only if the address is allowed to add tokens.\\n    mapping (address =\\u003e bool) tokenAdmins;\\n\\n    // True if and only if the address is allowed to register users.\\n    mapping (address =\\u003e bool) userAdmins;\\n\\n    // True if and only if the address is an operator (allowed to update state).\\n    mapping (address =\\u003e bool) operators;\\n\\n    // Mapping of contract ID to asset data.\\n    mapping (uint256 =\\u003e bytes) assetTypeToAssetInfo;    // NOLINT: uninitialized-state.\\n\\n    // Mapping of registered contract IDs.\\n    mapping (uint256 =\\u003e bool) registeredAssetType;      // NOLINT: uninitialized-state.\\n\\n    // Mapping from contract ID to quantum.\\n    mapping (uint256 =\\u003e uint256) assetTypeToQuantum;    // NOLINT: uninitialized-state.\\n\\n    // This mapping is no longer in use, remains for backwards compatibility.\\n    mapping (address =\\u003e uint256) starkKeys_DEPRECATED;  // NOLINT: naming-convention.\\n\\n    // Mapping from STARK public key to the Ethereum public key of its owner.\\n    mapping (uint256 =\\u003e address) ethKeys;               // NOLINT: uninitialized-state.\\n\\n    // Timelocked state transition and availability verification chain.\\n    StarkExTypes.ApprovalChainData verifiersChain;\\n    StarkExTypes.ApprovalChainData availabilityVerifiersChain;\\n\\n    // Batch id of last accepted proof.\\n    uint256 lastBatchId;                            // NOLINT: constable-states uninitialized-state.\\n\\n    // Mapping between sub-contract index to sub-contract address.\\n    mapping(uint256 =\\u003e address) subContracts;       // NOLINT: uninitialized-state.\\n\\n    mapping (uint256 =\\u003e bool) permissiveAssetType_DEPRECATED; // NOLINT: naming-convention.\\n    // ---- END OF MAIN STORAGE AS DEPLOYED IN STARKEX2.0 ----\\n\\n    // Onchain-data version configured for the system.\\n    uint256 onchainDataVersion;                     // NOLINT: constable-states uninitialized-state.\\n\\n    // Counter of forced action request in block. The key is the block number.\\n    mapping(uint256 =\\u003e uint256) forcedRequestsInBlock;\\n\\n    // ForcedAction requests: actionHash =\\u003e requestTime.\\n    mapping(bytes32 =\\u003e uint256) forcedActionRequests;\\n\\n    // Mapping for timelocked actions.\\n    // A actionKey =\\u003e activation time.\\n    mapping (bytes32 =\\u003e uint256) actionsTimeLock;\\n\\n    // Reserved storage space for Extensibility.\\n    // Every added MUST be added above the end gap, and the __endGap size must be reduced\\n    // accordingly.\\n    // NOLINTNEXTLINE: naming-convention.\\n    uint256[LAYOUT_LENGTH - 36] private __endGap;  // __endGap complements layout to LAYOUT_LENGTH.\\n}\\n\"},\"MForcedTradeActionState.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MForcedTradeActionState {\\n    function forcedTradeActionHash(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce)\\n        internal pure virtual returns (bytes32);\\n\\n    function clearForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce)\\n        internal virtual;\\n\\n    // NOLINTNEXTLINE: external-function.\\n    function getForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce)\\n        public view virtual returns (uint256 res);\\n\\n    function setForcedTradeRequest(\\n        uint256 starkKeyA,\\n        uint256 starkKeyB,\\n        uint256 vaultIdA,\\n        uint256 vaultIdB,\\n        uint256 collateralAssetId,\\n        uint256 syntheticAssetId,\\n        uint256 amountCollateral,\\n        uint256 amountSynthetic,\\n        bool aIsBuyingSynthetic,\\n        uint256 nonce,\\n        bool premiumCost)\\n        internal virtual;\\n}\\n\"},\"MForcedWithdrawalActionState.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MForcedWithdrawalActionState {\\n\\n    function forcedWithdrawActionHash(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount)\\n        internal\\n        pure\\n        virtual\\n        returns (bytes32);\\n\\n    function clearForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount)\\n        internal\\n        virtual;\\n\\n    // NOLINTNEXTLINE: external-function.\\n    function getForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount)\\n        public\\n        view\\n        virtual\\n        returns (uint256 res);\\n\\n    function setForcedWithdrawalRequest(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount,\\n        bool premiumCost)\\n        internal\\n        virtual;\\n}\\n\"},\"MFreezable.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MFreezable {\\n    /*\\n      Returns true if the exchange is frozen.\\n    */\\n    function isFrozen() public view virtual returns (bool); // NOLINT: external-function.\\n\\n    /*\\n      Forbids calling the function if the exchange is frozen.\\n    */\\n    modifier notFrozen()\\n    {\\n        require(!isFrozen(), \\\"STATE_IS_FROZEN\\\");\\n        _;\\n    }\\n\\n    function validateFreezeRequest(uint256 requestTime) internal virtual;\\n\\n    /*\\n      Allows calling the function only if the exchange is frozen.\\n    */\\n    modifier onlyFrozen()\\n    {\\n        require(isFrozen(), \\\"STATE_NOT_FROZEN\\\");\\n        _;\\n    }\\n\\n    /*\\n      Freezes the exchange.\\n    */\\n    function freeze() internal virtual;\\n}\\n\"},\"MGovernance.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MGovernance {\\n    /*\\n      Allows calling the function only by a Governor.\\n    */\\n    modifier onlyGovernance () virtual; // NOLINT incorrect-modifier.\\n}\\n\"},\"MKeyGetters.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MKeyGetters {\\n    // NOLINTNEXTLINE: external-function.\\n    function getEthKey(uint256 starkKey) public view virtual returns (address ethKey);\\n\\n    function isMsgSenderStarkKeyOwner(uint256 starkKey) internal view virtual returns (bool);\\n\\n    /*\\n      Allows calling the function only if starkKey is registered to msg.sender.\\n    */\\n    modifier isSenderStarkKey(uint256 starkKey) virtual; // NOLINT incorrect-modifier.\\n}\\n\"},\"MOperator.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MOperator {\\n\\n    modifier onlyOperator() virtual; // NOLINT incorrect-modifier.\\n\\n    function registerOperator(address newOperator)\\n        external\\n        virtual;\\n\\n    function unregisterOperator(address removedOperator)\\n        virtual\\n        external;\\n\\n}\\n\"},\"MStateRoot.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MStateRoot {\\n    function getVaultRoot() // NOLINT: external-function.\\n        public view\\n        virtual\\n        returns (uint256 root);\\n\\n    function getVaultTreeHeight() // NOLINT: external-function.\\n        public view\\n        virtual\\n        returns (uint256 height);\\n}\\n\"},\"MTokenQuantization.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nabstract contract MTokenQuantization {\\n    function fromQuantized(uint256 presumedAssetType, uint256 quantizedAmount)\\n        internal\\n        view\\n        virtual\\n        returns (uint256 amount);\\n\\n    // NOLINTNEXTLINE: external-function.\\n    function getQuantum(uint256 presumedAssetType)\\n        public\\n        view\\n        virtual\\n        returns (uint256 quantum);\\n\\n    function toQuantized(uint256 presumedAssetType, uint256 amount)\\n        internal\\n        view\\n        virtual\\n        returns (uint256 quantizedAmount);\\n}\\n\"},\"OnchainDataFactTreeEncoder.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\ncontract OnchainDataFactTreeEncoder {\\n    // The number of additional words appended to the public input when using the\\n    // OnchainDataFactTreeEncoder format.\\n\\n    uint256 internal constant ONCHAIN_DATA_FACT_ADDITIONAL_WORDS = 2;\\n\\n    /*\\n      Encodes a GPS fact Merkle tree where the root has two children.\\n      The left child contains the data we care about and the right child contains\\n      on-chain data for the fact.\\n\\n      minimalValidLength is the minimal possible length of the data in the left node.\\n    */\\n    function encodeFactWithOnchainData(\\n        uint256[] memory publicInput, uint256 minimalValidLength\\n    )\\n        internal pure\\n        returns (bytes32)\\n    {\\n        // The state transition fact is computed as a Merkle tree, as defined in\\n        // GpsOutputParser.\\n        //\\n        // In our case the fact tree looks as follows:\\n        //   The root has two children.\\n        //   The left child is a leaf that includes the main part - the information regarding\\n        //   the state transition required by this contract.\\n        //   The right child contains the onchain-data which shouldn\\u0027t be accessed by this\\n        //   contract, so we are only given its hash and length\\n        //   (it may be a leaf or an inner node, this has no effect on this contract).\\n\\n        require(\\n            publicInput.length \\u003e= minimalValidLength + ONCHAIN_DATA_FACT_ADDITIONAL_WORDS,\\n            \\\"publicInput does not contain all required fields.\\\");\\n\\n        // Compute the hash without the two additional fields.\\n        uint256 mainPublicInputLen = publicInput.length - ONCHAIN_DATA_FACT_ADDITIONAL_WORDS;\\n        bytes32 mainPublicInputHash;\\n        assembly {\\n            mainPublicInputHash := keccak256(\\n                add(publicInput, 0x20), mul(0x20, mainPublicInputLen))\\n        }\\n\\n        // Compute the hash of the fact Merkle tree.\\n        bytes32 hashResult = keccak256(\\n            abi.encodePacked(\\n                mainPublicInputHash,\\n                mainPublicInputLen,\\n                /*The hash of the onchain-data node*/ publicInput[publicInput.length - 2],\\n                mainPublicInputLen +\\n                /*The size of the onchain-data node*/ publicInput[publicInput.length - 1]\\n            )\\n        );\\n        // Add one to the hash to indicate it represents an inner node, rather than a leaf.\\n        return bytes32(uint256(hashResult) + 1);\\n    }\\n}\\n\"},\"Operator.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MOperator.sol\\\";\\nimport \\\"MGovernance.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\n\\n/**\\n  The Operator of the contract is the entity entitled to submit state update requests\\n  by calling :sol:func:`updateState`.\\n\\n  An Operator may be instantly appointed or removed by the contract Governor\\n  (see :sol:mod:`MainGovernance`). Typically, the Operator is the hot wallet of the StarkEx service\\n  submitting proofs for state updates.\\n*/\\nabstract contract Operator is MainStorage, MGovernance, MOperator {\\n    event LogOperatorAdded(address operator);\\n    event LogOperatorRemoved(address operator);\\n\\n    function initialize()\\n        internal\\n    {\\n        operators[msg.sender] = true;\\n        emit LogOperatorAdded(msg.sender);\\n    }\\n\\n    modifier onlyOperator() override\\n    {\\n        require(operators[msg.sender], \\\"ONLY_OPERATOR\\\");\\n        _;\\n    }\\n\\n    function registerOperator(address newOperator)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        operators[newOperator] = true;\\n        emit LogOperatorAdded(newOperator);\\n    }\\n\\n    function unregisterOperator(address removedOperator)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        operators[removedOperator] = false;\\n        emit LogOperatorRemoved(removedOperator);\\n    }\\n\\n    function isOperator(address testedOperator) external view returns (bool) {\\n        return operators[testedOperator];\\n    }\\n}\\n\"},\"PerpetualEscapes.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"LibConstants.sol\\\";\\nimport \\\"MAcceptModifications.sol\\\";\\nimport \\\"MFreezable.sol\\\";\\nimport \\\"IFactRegistry.sol\\\";\\nimport \\\"PerpetualStorage.sol\\\";\\n\\n/**\\n  Escaping the exchange is the last resort for users that wish to withdraw their funds without\\n  relying on off-chain exchange services. The Escape functionality may only be invoked once the\\n  contract has become frozen. This will be as the result of an unserviced forcedAction request\\n  At that point, any escaper entity may perform an escape operation as follows:\\n\\n  1. Escapers call the :sol:mod:`PerpetualEscapeVerifier` contract with the Merkle proof for the vault to be evicted and the shared state. If the proof is valid, this results in the registration of said proof.\\n  2. Escapers call :sol:func:`escape` function with the starkKey, vaultId and quantizedAmount matching the proof from step 1.\\n  3. The owner of the vault may then withdraw this amount from the pending withdrawals account by calling the normal withdraw function (see :sol:mod:`Withdrawals`) to transfer the funds to the users ERC20 account.\\n\\n  Note that while anyone can perform the initial steps of the escape operation (including the\\n  exchange operator, for example), only the owner of the vault may perform the final step of\\n  transferring the funds.\\n*/\\nabstract contract PerpetualEscapes is\\n    PerpetualStorage,\\n    MAcceptModifications,\\n    MFreezable\\n{\\n    function initialize (\\n        IFactRegistry escapeVerifier\\n    ) internal\\n    {\\n        escapeVerifier_ = escapeVerifier;\\n    }\\n    /*\\n      Escape when the contract is frozen.\\n    */\\n    function escape(\\n        uint256 starkKey,\\n        uint256 vaultId,\\n        uint256 quantizedAmount\\n    )\\n        external\\n        onlyFrozen()\\n    {\\n        require(!escapesUsed[vaultId], \\\"ESCAPE_ALREADY_USED\\\");\\n\\n        // Escape can be used only once.\\n        escapesUsed[vaultId] = true;\\n        escapesUsedCount += 1;\\n\\n        bytes32 claimHash = keccak256(\\n            abi.encode(\\n        starkKey, quantizedAmount, sharedStateHash, vaultId));\\n        require(escapeVerifier_.isValid(claimHash), \\\"ESCAPE_LACKS_PROOF\\\");\\n\\n        allowWithdrawal(starkKey, systemAssetType, quantizedAmount);\\n    }\\n}\\n\"},\"PerpetualState.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"PerpetualEscapes.sol\\\";\\nimport \\\"UpdatePerpetualState.sol\\\";\\nimport \\\"Configuration.sol\\\";\\nimport \\\"Freezable.sol\\\";\\nimport \\\"KeyGetters.sol\\\";\\nimport \\\"MainGovernance.sol\\\";\\nimport \\\"Operator.sol\\\";\\nimport \\\"AcceptModifications.sol\\\";\\nimport \\\"ForcedTradeActionState.sol\\\";\\nimport \\\"ForcedWithdrawalActionState.sol\\\";\\nimport \\\"StateRoot.sol\\\";\\nimport \\\"TokenQuantization.sol\\\";\\nimport \\\"IFactRegistry.sol\\\";\\nimport \\\"SubContractor.sol\\\";\\n\\ncontract PerpetualState is\\n    MainGovernance,\\n    SubContractor,\\n    Configuration,\\n    Operator,\\n    Freezable,\\n    AcceptModifications,\\n    TokenQuantization,\\n    ForcedTradeActionState,\\n    ForcedWithdrawalActionState,\\n    StateRoot,\\n    PerpetualEscapes,\\n    UpdatePerpetualState,\\n    KeyGetters\\n{\\n    // Empty state is 8 words (256 bytes) To pass as uint[] we need also head \\u0026 len fields (64).\\n    uint256 constant INITIALIZER_SIZE = 384; // Padded address(32), uint(32), Empty state(256+64).\\n\\n    /*\\n      Initialization flow:\\n      1. Extract initialization parameters from data.\\n      2. Call internalInitializer with those parameters.\\n    */\\n    function initialize(bytes calldata data) external override {\\n        // This initializer sets roots etc. It must not be applied twice.\\n        // I.e. it can run only when the state is still empty.\\n        require(sharedStateHash == bytes32(0x0), \\\"STATE_ALREADY_INITIALIZED\\\");\\n        require(configurationHash[GLOBAL_CONFIG_KEY] == bytes32(0x0), \\\"STATE_ALREADY_INITIALIZED\\\");\\n\\n        require(data.length == INITIALIZER_SIZE, \\\"INCORRECT_INIT_DATA_SIZE_384\\\");\\n\\n        (\\n            IFactRegistry escapeVerifier,\\n            uint256 initialSequenceNumber,\\n            uint256[] memory initialState\\n        ) = abi.decode(\\n            data,\\n            (IFactRegistry, uint256, uint256[])\\n        );\\n\\n        initGovernance();\\n        Configuration.initialize(PERPETUAL_CONFIGURATION_DELAY);\\n        Operator.initialize();\\n        StateRoot.initialize(\\n            initialSequenceNumber,\\n            initialState[0],\\n            initialState[2],\\n            initialState[1],\\n            initialState[3]\\n        );\\n        sharedStateHash = keccak256(abi.encodePacked(initialState));\\n        PerpetualEscapes.initialize(escapeVerifier);\\n    }\\n\\n    /*\\n      The call to initializerSize is done from MainDispatcherBase using delegatecall,\\n      thus the existing state is already accessible.\\n    */\\n    function initializerSize() external view override returns (uint256) {\\n        return INITIALIZER_SIZE;\\n    }\\n\\n    function identify() external pure override returns (string memory) {\\n        return \\\"StarkWare_PerpetualState_2020_1\\\";\\n    }\\n}\\n\"},\"PerpetualStorage.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MainStorage.sol\\\";\\n\\n/*\\n  Extends MainStorage, holds Perpetual App specific state (storage) variables.\\n\\n  ALL State variables that are common to all applications, reside in MainStorage,\\n  whereas ALL the Perpetual app specific ones reside here.\\n*/\\ncontract PerpetualStorage is MainStorage {\\n    uint256 systemAssetType;                       // NOLINT: constable-states uninitialized-state.\\n\\n    bytes32 public globalConfigurationHash;        // NOLINT: constable-states uninitialized-state.\\n\\n    mapping(uint256 =\\u003e bytes32) public configurationHash; // NOLINT: uninitialized-state.\\n\\n    bytes32 sharedStateHash;                       // NOLINT: constable-states uninitialized-state.\\n\\n    // Configuration apply time-lock.\\n    // The delay is held in storage (and not constant)\\n    // So that it can be modified during upgrade.\\n    uint256 public configurationDelay;             // NOLINT: constable-states.\\n\\n    // Reserved storage space for Extensibility.\\n    // Every added MUST be added above the end gap, and the __endGap size must be reduced\\n    // accordingly.\\n    // NOLINTNEXTLINE: naming-convention shadowing-abstract.\\n    uint256[LAYOUT_LENGTH - 5] private __endGap;  // __endGap complements layout to LAYOUT_LENGTH.\\n}\\n\"},\"ProgramOutputOffsets.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\ncontract ProgramOutputOffsets {\\n    // The following constants are offsets of data expected in the program output.\\n    // The offsets here are of the fixed fields.\\n    uint256 internal constant PROG_OUT_GENERAL_CONFIG_HASH = 0;\\n    uint256 internal constant PROG_OUT_N_ASSET_CONFIGS = 1;\\n    uint256 internal constant PROG_OUT_ASSET_CONFIG_HASHES = 2;\\n\\n    /*\\n      Additional mandatory fields of a single word:\\n      - Previous state size         2\\n      - New state size              3\\n      - Vault tree height           4\\n      - Order tree height           5\\n      - Expiration timestamp        6\\n      - No. of Modifications        7.\\n    */\\n    uint256 internal constant PROG_OUT_N_WORDS_MIN_SIZE = 8;\\n\\n    uint256 internal constant PROG_OUT_N_WORDS_PER_ASSET_CONFIG = 2;\\n    uint256 internal constant PROG_OUT_N_WORDS_PER_MODIFICATION = 3;\\n\\n    uint256 internal constant ASSET_CONFIG_OFFSET_ASSET_ID = 0;\\n    uint256 internal constant ASSET_CONFIG_OFFSET_CONFIG_HASH = 1;\\n\\n    uint256 internal constant MODIFICATIONS_OFFSET_STARKKEY = 0;\\n    uint256 internal constant MODIFICATIONS_OFFSET_POS_ID = 1;\\n    uint256 internal constant MODIFICATIONS_OFFSET_BIASED_DIFF = 2;\\n\\n    uint256 internal constant STATE_OFFSET_VAULTS_ROOT = 0;\\n    uint256 internal constant STATE_OFFSET_VAULTS_HEIGHT = 1;\\n    uint256 internal constant STATE_OFFSET_ORDERS_ROOT = 2;\\n    uint256 internal constant STATE_OFFSET_ORDERS_HEIGHT = 3;\\n    uint256 internal constant STATE_OFFSET_N_FUNDING = 4;\\n    uint256 internal constant STATE_OFFSET_FUNDING = 5;\\n\\n    // The following constants are offsets of data expected in the application data.\\n    uint256 internal constant APP_DATA_BATCH_ID_OFFSET = 0;\\n    uint256 internal constant APP_DATA_PREVIOUS_BATCH_ID_OFFSET = 1;\\n    uint256 internal constant APP_DATA_N_CONDITIONAL_TRANSFER = 2;\\n    uint256 internal constant APP_DATA_CONDITIONAL_TRANSFER_DATA_OFFSET = 3;\\n    uint256 internal constant APP_DATA_N_WORDS_PER_CONDITIONAL_TRANSFER = 2;\\n}\\n\"},\"ProxyStorage.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"GovernanceStorage.sol\\\";\\n\\n/*\\n  Holds the Proxy-specific state variables.\\n  This contract is inherited by the GovernanceStorage (and indirectly by MainStorage)\\n  to prevent collision hazard.\\n*/\\ncontract ProxyStorage is GovernanceStorage {\\n\\n    // Stores the hash of the initialization vector of the added implementation.\\n    // Upon upgradeTo the implementation, the initialization vector is verified\\n    // to be identical to the one submitted when adding the implementation.\\n    mapping (address =\\u003e bytes32) internal initializationHash;\\n\\n    // The time after which we can switch to the implementation.\\n    mapping (address =\\u003e uint256) internal enabledTime;\\n\\n    // A central storage of the flags whether implementation has been initialized.\\n    // Note - it can be used flexibly enough to accommodate multiple levels of initialization\\n    // (i.e. using different key salting schemes for different initialization levels).\\n    mapping (bytes32 =\\u003e bool) internal initialized;\\n}\\n\"},\"StateRoot.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MStateRoot.sol\\\";\\nimport \\\"MainStorage.sol\\\";\\n\\ncontract StateRoot is MainStorage, MStateRoot\\n{\\n\\n    function initialize (\\n        uint256 initialSequenceNumber,\\n        uint256 initialVaultRoot,\\n        uint256 initialOrderRoot,\\n        uint256 initialVaultTreeHeight,\\n        uint256 initialOrderTreeHeight\\n    )\\n        internal\\n    {\\n        sequenceNumber = initialSequenceNumber;\\n        vaultRoot = initialVaultRoot;\\n        orderRoot = initialOrderRoot;\\n        vaultTreeHeight = initialVaultTreeHeight;\\n        orderTreeHeight = initialOrderTreeHeight;\\n    }\\n\\n    function getVaultRoot()\\n        public view\\n        override\\n        returns (uint256 root)\\n    {\\n        root = vaultRoot;\\n    }\\n\\n    function getVaultTreeHeight()\\n        public view\\n        override\\n        returns (uint256 height) {\\n        height = vaultTreeHeight;\\n    }\\n\\n    function getOrderRoot()\\n        external view\\n        returns (uint256 root)\\n    {\\n        root = orderRoot;\\n    }\\n\\n    function getOrderTreeHeight()\\n        external view\\n        returns (uint256 height) {\\n        height = orderTreeHeight;\\n    }\\n\\n    function getSequenceNumber()\\n        external view\\n        returns (uint256 seq)\\n    {\\n        seq = sequenceNumber;\\n    }\\n\\n    function getLastBatchId()\\n        external view\\n        returns (uint256 batchId)\\n    {\\n        batchId = lastBatchId;\\n    }\\n}\\n\"},\"SubContractor.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"Identity.sol\\\";\\n\\ninterface SubContractor is Identity {\\n\\n    function initialize(bytes calldata data)\\n        external;\\n\\n    function initializerSize()\\n        external view\\n        returns(uint256);\\n}\\n\"},\"TokenQuantization.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"MTokenQuantization.sol\\\";\\n\\n\\ncontract TokenQuantization is MainStorage, MTokenQuantization {\\n\\n    function fromQuantized(uint256 presumedAssetType, uint256 quantizedAmount)\\n        internal view override returns (uint256 amount) {\\n        uint256 quantum = getQuantum(presumedAssetType);\\n        amount = quantizedAmount * quantum;\\n        require(amount / quantum == quantizedAmount, \\\"DEQUANTIZATION_OVERFLOW\\\");\\n    }\\n\\n    function getQuantum(uint256 presumedAssetType) public view override returns (uint256 quantum) {\\n        if (!registeredAssetType[presumedAssetType]) {\\n            // Default quantization, for NFTs etc.\\n            quantum = 1;\\n        } else {\\n            // Retrieve registration.\\n            quantum = assetTypeToQuantum[presumedAssetType];\\n        }\\n    }\\n\\n    function toQuantized(uint256 presumedAssetType, uint256 amount)\\n        internal view override returns (uint256 quantizedAmount) {\\n        uint256 quantum = getQuantum(presumedAssetType);\\n        require(amount % quantum == 0, \\\"INVALID_AMOUNT\\\");\\n        quantizedAmount = amount / quantum;\\n    }\\n}\\n\"},\"UpdatePerpetualState.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"PerpetualStorage.sol\\\";\\nimport \\\"ProgramOutputOffsets.sol\\\";\\nimport \\\"OnchainDataFactTreeEncoder.sol\\\";\\nimport \\\"VerifyFactChain.sol\\\";\\nimport \\\"IFactRegistry.sol\\\";\\nimport \\\"MAcceptModifications.sol\\\";\\nimport \\\"MForcedTradeActionState.sol\\\";\\nimport \\\"MForcedWithdrawalActionState.sol\\\";\\nimport \\\"MFreezable.sol\\\";\\nimport \\\"MOperator.sol\\\";\\nimport \\\"Common.sol\\\";\\nimport \\\"LibConstants.sol\\\";\\n\\n/**\\n  TO-DO:DOC.\\n*/\\nabstract contract UpdatePerpetualState is\\n    PerpetualStorage,\\n    LibConstants,\\n    MForcedTradeActionState,\\n    MForcedWithdrawalActionState,\\n    VerifyFactChain,\\n    MAcceptModifications,\\n    MFreezable,\\n    MOperator,\\n    ProgramOutputOffsets,\\n    OnchainDataFactTreeEncoder\\n{\\n    using UintArray for uint256[];\\n\\n    event LogUpdateState(\\n        uint256 sequenceNumber,\\n        uint256 batchId\\n    );\\n\\n    event LogStateTransitionFact(\\n        bytes32 stateTransitionFact\\n    );\\n\\n    enum ForcedAction {\\n        Withdrawal,\\n        Trade\\n    }\\n\\n    struct ProgramOutputMarkers {\\n        uint256 globalConfigurationHash;\\n        uint256 nAssets;\\n        uint256 assetConfigOffset;\\n        uint256 prevSharedStateSize;\\n        uint256 prevSharedStateOffset;\\n        uint256 newSharedStateSize;\\n        uint256 newSharedStateOffset;\\n        uint256 newSystemTime;\\n        uint256 expirationTimestamp;\\n        uint256 nModifications;\\n        uint256 modificationsOffset;\\n        uint256 forcedActionsSize;\\n        uint256 nForcedActions;\\n        uint256 forcedActionsOffset;\\n        uint256 nConditions;\\n        uint256 conditionsOffset;\\n    }\\n\\n    function updateState(uint256[] calldata programOutput, uint256[] calldata applicationData)\\n        external\\n        notFrozen()\\n        onlyOperator()\\n    {\\n        ProgramOutputMarkers memory outputMarkers = parseProgramOutput(programOutput);\\n        require(\\n            outputMarkers.expirationTimestamp \\u003c 2**PERPETUAL_TIMESTAMP_BITS,\\n            \\\"Expiration timestamp is out of range.\\\"\\n        );\\n\\n        require(\\n            outputMarkers.newSystemTime \\u003e (block.timestamp - PERPETUAL_SYSTEM_TIME_LAG_BOUND),\\n            \\\"SYSTEM_TIME_OUTDATED\\\");\\n\\n        require(\\n            outputMarkers.newSystemTime \\u003c (block.timestamp + PERPETUAL_SYSTEM_TIME_ADVANCE_BOUND),\\n            \\\"SYSTEM_TIME_INVALID\\\");\\n\\n        require(\\n            outputMarkers.expirationTimestamp \\u003e block.timestamp / 3600,\\n            \\\"BATCH_TIMESTAMP_EXPIRED\\\"\\n        );\\n\\n        validateConfigHashes(programOutput, outputMarkers);\\n\\n        // Caclulate previous shared state hash, and compare with stored one.\\n        bytes32 prevStateHash = programOutput.hashSubArray(\\n            outputMarkers.prevSharedStateOffset,\\n            outputMarkers.prevSharedStateSize);\\n        require(\\n            prevStateHash == sharedStateHash, \\\"INVALID_PREVIOUS_SHARED_STATE\\\");\\n\\n        require(\\n            applicationData[APP_DATA_PREVIOUS_BATCH_ID_OFFSET] == lastBatchId,\\n            \\\"WRONG_PREVIOUS_BATCH_ID\\\"\\n        );\\n\\n        bytes32 stateTransitionFact = encodeFactWithOnchainData(\\n            programOutput, outputMarkers.forcedActionsOffset);\\n\\n        emit LogStateTransitionFact(stateTransitionFact);\\n\\n        verifyFact(\\n            verifiersChain,\\n            stateTransitionFact,\\n            \\\"NO_STATE_TRANSITION_VERIFIERS\\\",\\n            \\\"NO_STATE_TRANSITION_PROOF\\\"\\n        );\\n\\n        performUpdateState(programOutput, outputMarkers, applicationData);\\n    }\\n\\n    function validateConfigHashes(\\n        uint256[] memory programOutput,\\n        ProgramOutputMarkers memory markers) internal view {\\n        require(globalConfigurationHash != bytes32(0), \\\"GLOBAL_CONFIGURATION_NOT_SET\\\");\\n        require(\\n            globalConfigurationHash == bytes32(markers.globalConfigurationHash),\\n            \\\"GLOBAL_CONFIGURATION_MISMATCH\\\"\\n        );\\n\\n        uint256 offset = markers.assetConfigOffset;\\n        for (uint256 i = 0; i \\u003c markers.nAssets; i++) {\\n            uint256 assetId = programOutput[offset + ASSET_CONFIG_OFFSET_ASSET_ID];\\n            bytes32 assetConfigHash = bytes32(\\n                programOutput[offset + ASSET_CONFIG_OFFSET_CONFIG_HASH]);\\n            require(\\n                configurationHash[assetId] == assetConfigHash,\\n                \\\"ASSET_CONFIGURATION_MISMATCH\\\"\\n            );\\n            offset += PROG_OUT_N_WORDS_PER_ASSET_CONFIG;\\n        }\\n    }\\n\\n    function parseProgramOutput(uint256[] memory programOutput)\\n        internal\\n        pure\\n        returns (ProgramOutputMarkers memory)\\n    {\\n        require(\\n            programOutput.length \\u003e= PROG_OUT_N_WORDS_MIN_SIZE,\\n            \\\"programOutput does not contain all required fields.\\\"\\n        );\\n\\n        ProgramOutputMarkers memory markers; // NOLINT: uninitialized-local.\\n        markers.globalConfigurationHash = programOutput[PROG_OUT_GENERAL_CONFIG_HASH];\\n        markers.nAssets = programOutput[PROG_OUT_N_ASSET_CONFIGS];\\n        require(markers.nAssets \\u003c 2**16, \\\"ILLEGAL_NUMBER_OF_ASSETS\\\");\\n\\n        uint256 offset = PROG_OUT_ASSET_CONFIG_HASHES;\\n        markers.assetConfigOffset = offset;\\n        offset += markers.nAssets * PROG_OUT_N_WORDS_PER_ASSET_CONFIG;\\n        require(\\n            programOutput.length \\u003e= offset + 1, // Adding +1 for the next mandatory field.\\n            \\\"programOutput invalid size (nAssetConfig)\\\"\\n        );\\n\\n        markers.prevSharedStateSize = programOutput[offset++];\\n        markers.prevSharedStateOffset = offset;\\n\\n        offset += markers.prevSharedStateSize;\\n        require(\\n            programOutput.length \\u003e= offset + 1, // Adding +1 for the next mandatory field.\\n            \\\"programOutput invalid size (prevState)\\\");\\n\\n        markers.newSharedStateSize = programOutput[offset++];\\n        markers.newSharedStateOffset = offset;\\n\\n        offset += markers.newSharedStateSize;\\n        require(\\n            programOutput.length \\u003e= offset + 2,  // Adding +2 for the next mandatory fields.\\n            \\\"programOutput invalid size (newState)\\\");\\n\\n        // System time is the last field in the state.\\n        markers.newSystemTime = programOutput[offset-1];\\n\\n        markers.expirationTimestamp = programOutput[offset++];\\n\\n        markers.nModifications = programOutput[offset++];\\n        markers.modificationsOffset = offset;\\n        offset += markers.nModifications * PROG_OUT_N_WORDS_PER_MODIFICATION;\\n\\n        markers.forcedActionsSize = programOutput[offset++];\\n        markers.nForcedActions = programOutput[offset++];\\n        markers.forcedActionsOffset = offset;\\n        offset += markers.forcedActionsSize;\\n\\n        markers.nConditions = programOutput[offset++];\\n        markers.conditionsOffset = offset;\\n        offset += markers.nConditions;\\n\\n        offset += ONCHAIN_DATA_FACT_ADDITIONAL_WORDS;\\n\\n        require(\\n            programOutput.length == offset,\\n            \\\"programOutput invalid size (mods/forced/conditions)\\\"\\n        );\\n        return markers;\\n    }\\n\\n    function performUpdateState(\\n        uint256[] memory programOutput,\\n        ProgramOutputMarkers memory markers,\\n        uint256[] memory applicationData\\n    ) internal {\\n        sharedStateHash = programOutput.hashSubArray(\\n            markers.newSharedStateOffset, markers.newSharedStateSize);\\n\\n        sequenceNumber += 1;\\n        uint256 batchId = applicationData[APP_DATA_BATCH_ID_OFFSET];\\n        lastBatchId = batchId;\\n\\n        sendModifications(programOutput, markers, applicationData);\\n\\n        verifyConditionalTransfers(programOutput, markers, applicationData);\\n\\n        clearForcedActionsFlags(programOutput, markers);\\n\\n        emit LogUpdateState(sequenceNumber, batchId);\\n    }\\n\\n    /*\\n      Goes through the program output forced actions section,\\n      extract each forced action, and if valid and its flag exists, clears it.\\n      If invalid, or not flag not exist - revert.\\n    */\\n    function clearForcedActionsFlags(\\n        uint256[] memory programOutput,\\n        ProgramOutputMarkers memory markers\\n    ) private {\\n        uint256 offset = markers.forcedActionsOffset;\\n        for (uint256 i = 0 ; i \\u003c markers.nForcedActions ; i++) {\\n            ForcedAction forcedActionType = ForcedAction(programOutput[offset++]);\\n            if (forcedActionType == ForcedAction.Withdrawal){\\n                offset = clearForcedWithdrawal(programOutput, offset);\\n            } else if(forcedActionType == ForcedAction.Trade){\\n                offset = clearForcedTrade(programOutput, offset);\\n            }\\n            else {\\n                revert(\\\"UNKNOWN_FORCED_ACTION_TYPE\\\");\\n            }\\n        }\\n        // Ensure all sizes are matching (this is not checked in parsing).\\n        require(markers.forcedActionsOffset + markers.forcedActionsSize == offset, \\\"SIZE_MISMATCH\\\");\\n    }\\n\\n    function clearForcedWithdrawal(\\n        uint256[] memory programOutput,\\n        uint256 offset\\n    ) private returns(uint256){\\n        uint256 starkKey = programOutput[offset++];\\n        uint256 vaultId = programOutput[offset++];\\n        uint256 quantizedAmount = programOutput[offset++];\\n        clearForcedWithdrawalRequest(starkKey, vaultId, quantizedAmount);\\n        return offset;\\n    }\\n\\n    function clearForcedTrade(\\n        uint256[] memory programOutput,\\n        uint256 offset\\n    ) private returns(uint256){\\n        uint256 starkKeyA = programOutput[offset++];\\n        uint256 starkKeyB = programOutput[offset++];\\n        uint256 vaultIdA = programOutput[offset++];\\n        uint256 vaultIdB = programOutput[offset++];\\n        // CollateralAssetId Not taken from progOutput. We use systemAssetType.\\n        uint256 syntheticAssetId = programOutput[offset++];\\n        uint256 amountCollateral = programOutput[offset++];\\n        uint256 amountSynthetic = programOutput[offset++];\\n        bool aIsBuyingSynthetic = (programOutput[offset++] != 0);\\n        uint256 nonce = programOutput[offset++];\\n        clearForcedTradeRequest(\\n            starkKeyA,\\n            starkKeyB,\\n            vaultIdA,\\n            vaultIdB,\\n            systemAssetType,\\n            syntheticAssetId,\\n            amountCollateral,\\n            amountSynthetic,\\n            aIsBuyingSynthetic,\\n            nonce\\n        );\\n        return offset;\\n    }\\n\\n    function verifyConditionalTransfers(\\n        uint256[] memory programOutput,\\n        ProgramOutputMarkers memory markers,\\n        uint256[] memory applicationData\\n    ) private view {\\n        require(\\n            applicationData.length \\u003e= APP_DATA_N_CONDITIONAL_TRANSFER, \\\"APP_DATA_TOO_SHORT\\\");\\n\\n\\n        require(\\n            applicationData[APP_DATA_N_CONDITIONAL_TRANSFER] == markers.nConditions,\\n            \\\"N_CONDITIONS_MISMATCH\\\"\\n        );\\n\\n        require(\\n            applicationData.length \\u003e=\\n            APP_DATA_CONDITIONAL_TRANSFER_DATA_OFFSET +\\n            markers.nConditions * APP_DATA_N_WORDS_PER_CONDITIONAL_TRANSFER,\\n            \\\"BAD_APP_DATA_SIZE\\\");\\n\\n        uint256 conditionsOffset = markers.conditionsOffset;\\n        uint256 preImageOffset = APP_DATA_CONDITIONAL_TRANSFER_DATA_OFFSET;\\n\\n        // Conditional Transfers appear after all other modifications.\\n        for (uint256 i = 0; i \\u003c markers.nConditions; i++) {\\n            address transferRegistry = address(applicationData[preImageOffset]);\\n            bytes32 transferFact = bytes32(applicationData[preImageOffset + 1]);\\n            uint256 condition = programOutput[conditionsOffset];\\n\\n            // The condition is the 250 LS bits of keccak256 of the fact registry \\u0026 fact.\\n            require(\\n                condition ==\\n                    uint256(keccak256(abi.encodePacked(transferRegistry, transferFact))) \\u0026\\n                    MASK_250,\\n                \\\"Condition mismatch.\\\");\\n            // NOLINTNEXTLINE: low-level-calls-loop reentrancy-events.\\n            (bool success, bytes memory returndata) = transferRegistry.staticcall(\\n                abi.encodeWithSignature(\\\"isValid(bytes32)\\\",transferFact));\\n            require(success \\u0026\\u0026 returndata.length == 32, \\\"BAD_FACT_REGISTRY_CONTRACT\\\");\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"Condition for the conditional transfer was not met.\\\");\\n            conditionsOffset += 1;\\n            preImageOffset += APP_DATA_N_WORDS_PER_CONDITIONAL_TRANSFER;\\n        }\\n    }\\n\\n    function sendModifications(\\n        uint256[] memory programOutput,\\n        ProgramOutputMarkers memory markers,\\n        uint256[] memory /*applicationData*/\\n    ) private {\\n        uint256 assetId = systemAssetType;\\n        require(assetId \\u003c K_MODULUS, \\\"Asset id \\u003e= PRIME\\\");\\n\\n        uint256 offset = markers.modificationsOffset;\\n        for (uint256 i = 0; i \\u003c markers.nModifications; i++) {\\n            uint256 starkKey = programOutput[offset + MODIFICATIONS_OFFSET_STARKKEY];\\n            uint256 vaultId = programOutput[offset + MODIFICATIONS_OFFSET_POS_ID];\\n            uint256 biasedDiff = programOutput[offset + MODIFICATIONS_OFFSET_BIASED_DIFF];\\n            // Biased representation.\\n            // biased_delta is in range [0, 2**65), where 2**64 means 0 change.\\n            // The effective difference is biased_delta - 2**64.\\n            require(biasedDiff \\u003c (1 \\u003c\\u003c 65), \\\"Illegal Balance Diff\\\");\\n            int256 balanceDiff = int256(biasedDiff - (1 \\u003c\\u003c 64));\\n\\n            require(starkKey \\u003c K_MODULUS, \\\"Stark key \\u003e= PRIME\\\");\\n\\n            if (balanceDiff \\u003e 0) {\\n                // This is a deposit.\\n                acceptDeposit(starkKey, vaultId, assetId, uint256(balanceDiff));\\n            } else if (balanceDiff \\u003c 0) {\\n                // This is a withdrawal.\\n                acceptWithdrawal(starkKey, assetId, uint256(-balanceDiff));\\n            }\\n            offset += PROG_OUT_N_WORDS_PER_MODIFICATION;\\n        }\\n    }\\n}\\n\"},\"VerifyFactChain.sol\":{\"content\":\"/*\\n  Copyright 2019,2020 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MainStorage.sol\\\";\\nimport \\\"IFactRegistry.sol\\\";\\nimport \\\"Common.sol\\\";\\n\\ncontract VerifyFactChain is MainStorage {\\n\\n    function verifyFact(\\n        StarkExTypes.ApprovalChainData storage chain, bytes32 fact, string memory noVerifiersErrorMessage,\\n        string memory invalidFactErrorMessage)\\n        internal view\\n    {\\n        address[] storage list = chain.list;\\n        uint256 n_entries = list.length;\\n        require(n_entries \\u003e 0, noVerifiersErrorMessage);\\n        for (uint256 i = 0; i \\u003c n_entries; i++) {\\n            // NOLINTNEXTLINE: calls-loop.\\n            require(IFactRegistry(list[i]).isValid(fact), invalidFactErrorMessage);\\n        }\\n    }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"LogAssetConfigurationApplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"LogAssetConfigurationRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"LogAssetConfigurationRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"LogGlobalConfigurationApplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"LogGlobalConfigurationRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"LogGlobalConfigurationRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogMintableWithdrawalAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acceptedGovernor\",\"type\":\"address\"}],\"name\":\"LogNewGovernorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"LogNftWithdrawalAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nominatedGovernor\",\"type\":\"address\"}],\"name\":\"LogNominatedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogNominationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"LogOperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"LogOperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedGovernor\",\"type\":\"address\"}],\"name\":\"LogRemovedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"stateTransitionFact\",\"type\":\"bytes32\"}],\"name\":\"LogStateTransitionFact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogUnFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"LogUpdateState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonQuantizedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawalAllowed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEPOSIT_CANCEL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FREEZE_GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAIN_GOVERNANCE_INFO_TAG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FORCED_ACTIONS_REQS_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VERIFIER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNFREEZE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERIFIER_REMOVAL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"applyAssetConfigurationChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"applyGlobalConfigurationChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"configurationHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"escape\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"}],\"name\":\"getEthKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ethKey\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKeyA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starkKeyB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAssetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"syntheticAssetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSynthetic\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"aIsBuyingSynthetic\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getForcedTradeRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"getForcedWithdrawalRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastBatchId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOrderRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOrderTreeHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"presumedAssetType\",\"type\":\"uint256\"}],\"name\":\"getQuantum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quantum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSequenceNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seq\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultTreeHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalConfigurationHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identify\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializerSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"testedOperator\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainAcceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainCancelNomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"testGovernor\",\"type\":\"address\"}],\"name\":\"mainIsGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"mainNominateNewGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governorForRemoval\",\"type\":\"address\"}],\"name\":\"mainRemoveGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"registerAssetConfigurationChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"registerGlobalConfigurationChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"registerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"removeAssetConfigurationChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"configHash\",\"type\":\"bytes32\"}],\"name\":\"removeGlobalConfigurationChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unFreeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"removedOperator\",\"type\":\"address\"}],\"name\":\"unregisterOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"programOutput\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"applicationData\",\"type\":\"uint256[]\"}],\"name\":\"updateState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PerpetualState","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c7ddd8a0d4fe037bf72b572e4736bda7acf1d3dc04ef08fca3683ba71b29f845"}]}