{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-12-28\r\n*/\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/common/Validating.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ninterface Validating {\r\n  modifier notZero(uint number) { require(number > 0, \"invalid 0 value\"); _; }\r\n  modifier notEmpty(string memory text) { require(bytes(text).length > 0, \"invalid empty string\"); _; }\r\n  modifier validAddress(address value) { require(value != address(0x0), \"invalid address\"); _; }\r\n}\r\n\r\n// File: contracts/external/BytesLib.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *    The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\nlibrary BytesLib {\r\n  function concat(\r\n    bytes memory _preBytes,\r\n    bytes memory _postBytes\r\n  )\r\n    internal\r\n    pure\r\n    returns (bytes memory)\r\n  {\r\n    bytes memory tempBytes;\r\n\r\n    assembly {\r\n      // Get a location of some free memory and store it in tempBytes as\r\n      // Solidity does for memory variables.\r\n      tempBytes := mload(0x40)\r\n\r\n      // Store the length of the first bytes array at the beginning of\r\n      // the memory for tempBytes.\r\n      let length := mload(_preBytes)\r\n      mstore(tempBytes, length)\r\n\r\n      // Maintain a memory counter for the current write location in the\r\n      // temp bytes array by adding the 32 bytes for the array length to\r\n      // the starting location.\r\n      let mc := add(tempBytes, 0x20)\r\n      // Stop copying when the memory counter reaches the length of the\r\n      // first bytes array.\r\n      let end := add(mc, length)\r\n\r\n      for {\r\n        // Initialize a copy counter to the start of the _preBytes data,\r\n        // 32 bytes into its memory.\r\n        let cc := add(_preBytes, 0x20)\r\n      } lt(mc, end) {\r\n        // Increase both counters by 32 bytes each iteration.\r\n        mc := add(mc, 0x20)\r\n        cc := add(cc, 0x20)\r\n      } {\r\n        // Write the _preBytes data into the tempBytes memory 32 bytes\r\n        // at a time.\r\n        mstore(mc, mload(cc))\r\n      }\r\n\r\n      // Add the length of _postBytes to the current length of tempBytes\r\n      // and store it as the new length in the first 32 bytes of the\r\n      // tempBytes memory.\r\n      length := mload(_postBytes)\r\n      mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n      // Move the memory counter back from a multiple of 0x20 to the\r\n      // actual end of the _preBytes data.\r\n      mc := end\r\n      // Stop copying when the memory counter reaches the new combined\r\n      // length of the arrays.\r\n      end := add(mc, length)\r\n\r\n      for {\r\n        let cc := add(_postBytes, 0x20)\r\n      } lt(mc, end) {\r\n        mc := add(mc, 0x20)\r\n        cc := add(cc, 0x20)\r\n      } {\r\n        mstore(mc, mload(cc))\r\n      }\r\n\r\n      // Update the free-memory pointer by padding our last write location\r\n      // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n      // next 32 byte block, then round down to the nearest multiple of\r\n      // 32. If the sum of the length of the two arrays is zero then add\r\n      // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n      mstore(0x40, and(\r\n        add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n        not(31) // Round down to the nearest 32 bytes.\r\n      ))\r\n    }\r\n\r\n    return tempBytes;\r\n  }\r\n\r\n  function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n    assembly {\r\n      // Read the first 32 bytes of _preBytes storage, which is the length\r\n      // of the array. (We don't need to use the offset into the slot\r\n      // because arrays use the entire slot.)\r\n      let fslot := sload(_preBytes.slot)\r\n      // Arrays of 31 bytes or less have an even value in their slot,\r\n      // while longer arrays have an odd value. The actual length is\r\n      // the slot divided by two for odd values, and the lowest order\r\n      // byte divided by two for even values.\r\n      // If the slot is even, bitwise and the slot with 255 and divide by\r\n      // two to get the length. If the slot is odd, bitwise and the slot\r\n      // with -1 and divide by two.\r\n      let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n      let mlength := mload(_postBytes)\r\n      let newlength := add(slength, mlength)\r\n      // slength can contain both the length and contents of the array\r\n      // if length < 32 bytes so let's prepare for that\r\n      // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n      switch add(lt(slength, 32), lt(newlength, 32))\r\n      case 2 {\r\n        // Since the new array still fits in the slot, we just need to\r\n        // update the contents of the slot.\r\n        // uint(bytes_storage) = uint(bytes_storage) + uint(bytes_memory) + new_length\r\n        sstore(\r\n          _preBytes.slot,\r\n          // all the modifications to the slot are inside this\r\n          // next block\r\n          add(\r\n            // we can just add to the slot contents because the\r\n            // bytes we want to change are the LSBs\r\n            fslot,\r\n            add(\r\n              mul(\r\n                div(\r\n                  // load the bytes from memory\r\n                  mload(add(_postBytes, 0x20)),\r\n                  // zero all bytes to the right\r\n                  exp(0x100, sub(32, mlength))\r\n                ),\r\n                // and now shift left the number of bytes to\r\n                // leave space for the length in the slot\r\n                exp(0x100, sub(32, newlength))\r\n              ),\r\n              // increase length by the double of the memory\r\n              // bytes length\r\n              mul(mlength, 2)\r\n            )\r\n          )\r\n        )\r\n      }\r\n      case 1 {\r\n        // The stored value fits in the slot, but the combined value\r\n        // will exceed it.\r\n        // get the keccak hash to get the contents of the array\r\n        mstore(0x0, _preBytes.slot)\r\n        let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n        // save new length\r\n        sstore(_preBytes.slot, add(mul(newlength, 2), 1))\r\n\r\n        // The contents of the _postBytes array start 32 bytes into\r\n        // the structure. Our first read should obtain the `submod`\r\n        // bytes that can fit into the unused space in the last word\r\n        // of the stored array. To get this, we read 32 bytes starting\r\n        // from `submod`, so the data we read overlaps with the array\r\n        // contents by `submod` bytes. Masking the lowest-order\r\n        // `submod` bytes allows us to add that value directly to the\r\n        // stored value.\r\n\r\n        let submod := sub(32, slength)\r\n        let mc := add(_postBytes, submod)\r\n        let end := add(_postBytes, mlength)\r\n        let mask := sub(exp(0x100, submod), 1)\r\n\r\n        sstore(\r\n          sc,\r\n          add(\r\n            and(\r\n              fslot,\r\n              0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n            ),\r\n            and(mload(mc), mask)\r\n          )\r\n        )\r\n\r\n        for {\r\n          mc := add(mc, 0x20)\r\n          sc := add(sc, 1)\r\n        } lt(mc, end) {\r\n          sc := add(sc, 1)\r\n          mc := add(mc, 0x20)\r\n        } {\r\n          sstore(sc, mload(mc))\r\n        }\r\n\r\n        mask := exp(0x100, sub(mc, end))\r\n\r\n        sstore(sc, mul(div(mload(mc), mask), mask))\r\n      }\r\n      default {\r\n        // get the keccak hash to get the contents of the array\r\n        mstore(0x0, _preBytes.slot)\r\n        // Start copying to the last used word of the stored array.\r\n        let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n        // save new length\r\n        sstore(_preBytes.slot, add(mul(newlength, 2), 1))\r\n\r\n        // Copy over the first `submod` bytes of the new data as in\r\n        // case 1 above.\r\n        let slengthmod := mod(slength, 32)\r\n        let mlengthmod := mod(mlength, 32)\r\n        let submod := sub(32, slengthmod)\r\n        let mc := add(_postBytes, submod)\r\n        let end := add(_postBytes, mlength)\r\n        let mask := sub(exp(0x100, submod), 1)\r\n\r\n        sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n        for {\r\n          sc := add(sc, 1)\r\n          mc := add(mc, 0x20)\r\n        } lt(mc, end) {\r\n          sc := add(sc, 1)\r\n          mc := add(mc, 0x20)\r\n        } {\r\n          sstore(sc, mload(mc))\r\n        }\r\n\r\n        mask := exp(0x100, sub(mc, end))\r\n\r\n        sstore(sc, mul(div(mload(mc), mask), mask))\r\n      }\r\n    }\r\n  }\r\n\r\n  function slice(\r\n    bytes memory _bytes,\r\n    uint _start,\r\n    uint _length\r\n  )\r\n    internal\r\n    pure\r\n    returns (bytes memory)\r\n  {\r\n    require(_length + 31 >= _length, \"slice_overflow\");\r\n    require(_start + _length >= _start, \"slice_overflow\");\r\n    require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n    bytes memory tempBytes;\r\n\r\n    assembly {\r\n      switch iszero(_length)\r\n      case 0 {\r\n        // Get a location of some free memory and store it in tempBytes as\r\n        // Solidity does for memory variables.\r\n        tempBytes := mload(0x40)\r\n\r\n        // The first word of the slice result is potentially a partial\r\n        // word read from the original array. To read it, we calculate\r\n        // the length of that partial word and start copying that many\r\n        // bytes into the array. The first word we copy will start with\r\n        // data we don't care about, but the last `lengthmod` bytes will\r\n        // land at the beginning of the contents of the new array. When\r\n        // we're done copying, we overwrite the full first word with\r\n        // the actual length of the slice.\r\n        let lengthmod := and(_length, 31)\r\n\r\n        // The multiplication in the next line is necessary\r\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n        // the following copy loop was copying the origin's length\r\n        // and then ending prematurely not copying everything it should.\r\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n        let end := add(mc, _length)\r\n\r\n        for {\r\n          // The multiplication in the next line has the same exact purpose\r\n          // as the one above.\r\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n        } lt(mc, end) {\r\n          mc := add(mc, 0x20)\r\n          cc := add(cc, 0x20)\r\n        } {\r\n          mstore(mc, mload(cc))\r\n        }\r\n\r\n        mstore(tempBytes, _length)\r\n\r\n        //update free-memory pointer\r\n        //allocating the array padded to 32 bytes like the compiler does now\r\n        mstore(0x40, and(add(mc, 31), not(31)))\r\n      }\r\n      //if we want a zero-length slice let's just return a zero-length array\r\n      default {\r\n        tempBytes := mload(0x40)\r\n\r\n        mstore(0x40, add(tempBytes, 0x20))\r\n      }\r\n    }\r\n\r\n    return tempBytes;\r\n  }\r\n\r\n  function toAddress(bytes memory _bytes, uint _start) internal pure returns (address) {\r\n    require(_start + 20 >= _start, \"toAddress_overflow\");\r\n    require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\r\n    address tempAddress;\r\n\r\n    assembly {\r\n      tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n    }\r\n\r\n    return tempAddress;\r\n  }\r\n\r\n  function toUint8(bytes memory _bytes, uint _start) internal pure returns (uint8) {\r\n    require(_start + 1 >= _start, \"toUint8_overflow\");\r\n    require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\r\n    uint8 tempUint;\r\n\r\n    assembly {\r\n      tempUint := mload(add(add(_bytes, 0x1), _start))\r\n    }\r\n\r\n    return tempUint;\r\n  }\r\n\r\n  function toUint16(bytes memory _bytes, uint _start) internal pure returns (uint16) {\r\n    require(_start + 2 >= _start, \"toUint16_overflow\");\r\n    require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\r\n    uint16 tempUint;\r\n\r\n    assembly {\r\n      tempUint := mload(add(add(_bytes, 0x2), _start))\r\n    }\r\n\r\n    return tempUint;\r\n  }\r\n\r\n  function toUint32(bytes memory _bytes, uint _start) internal pure returns (uint32) {\r\n    require(_start + 4 >= _start, \"toUint32_overflow\");\r\n    require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\r\n    uint32 tempUint;\r\n\r\n    assembly {\r\n      tempUint := mload(add(add(_bytes, 0x4), _start))\r\n    }\r\n\r\n    return tempUint;\r\n  }\r\n\r\n  function toUint64(bytes memory _bytes, uint _start) internal pure returns (uint64) {\r\n    require(_start + 8 >= _start, \"toUint64_overflow\");\r\n    require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\r\n    uint64 tempUint;\r\n\r\n    assembly {\r\n      tempUint := mload(add(add(_bytes, 0x8), _start))\r\n    }\r\n\r\n    return tempUint;\r\n  }\r\n\r\n  function toUint96(bytes memory _bytes, uint _start) internal pure returns (uint96) {\r\n    require(_start + 12 >= _start, \"toUint96_overflow\");\r\n    require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\r\n    uint96 tempUint;\r\n\r\n    assembly {\r\n      tempUint := mload(add(add(_bytes, 0xc), _start))\r\n    }\r\n\r\n    return tempUint;\r\n  }\r\n\r\n  function toUint128(bytes memory _bytes, uint _start) internal pure returns (uint128) {\r\n    require(_start + 16 >= _start, \"toUint128_overflow\");\r\n    require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\r\n    uint128 tempUint;\r\n\r\n    assembly {\r\n      tempUint := mload(add(add(_bytes, 0x10), _start))\r\n    }\r\n\r\n    return tempUint;\r\n  }\r\n\r\n  function toUint256(bytes memory _bytes, uint _start) internal pure returns (uint) {\r\n    require(_start + 32 >= _start, \"toUint256_overflow\");\r\n    require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\r\n    uint tempUint;\r\n\r\n    assembly {\r\n      tempUint := mload(add(add(_bytes, 0x20), _start))\r\n    }\r\n\r\n    return tempUint;\r\n  }\r\n\r\n  function toUint(bytes memory _bytes, uint _start) internal pure returns (uint) {\r\n    return toUint256(_bytes, _start);\r\n  }\r\n\r\n  function toBytes32(bytes memory _bytes, uint _start) internal pure returns (bytes32) {\r\n    require(_start + 32 >= _start, \"toBytes32_overflow\");\r\n    require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\r\n    bytes32 tempBytes32;\r\n\r\n    assembly {\r\n      tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n    }\r\n\r\n    return tempBytes32;\r\n  }\r\n\r\n  function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n    bool success = true;\r\n\r\n    assembly {\r\n      let length := mload(_preBytes)\r\n\r\n      // if lengths don't match the arrays are not equal\r\n      switch eq(length, mload(_postBytes))\r\n      case 1 {\r\n        // cb is a circuit breaker in the for loop since there's\r\n        //  no said feature for inline assembly loops\r\n        // cb = 1 - don't breaker\r\n        // cb = 0 - break\r\n        let cb := 1\r\n\r\n        let mc := add(_preBytes, 0x20)\r\n        let end := add(mc, length)\r\n\r\n        for {\r\n          let cc := add(_postBytes, 0x20)\r\n        // the next line is the loop condition:\r\n        // while(uint(mc < end) + cb == 2)\r\n        } eq(add(lt(mc, end), cb), 2) {\r\n          mc := add(mc, 0x20)\r\n          cc := add(cc, 0x20)\r\n        } {\r\n          // if any of these checks fails then arrays are not equal\r\n          if iszero(eq(mload(mc), mload(cc))) {\r\n            // unsuccess:\r\n            success := 0\r\n            cb := 0\r\n          }\r\n        }\r\n      }\r\n      default {\r\n        // unsuccess:\r\n        success := 0\r\n      }\r\n    }\r\n\r\n    return success;\r\n  }\r\n\r\n  function equalStorage(\r\n    bytes storage _preBytes,\r\n    bytes memory _postBytes\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    bool success = true;\r\n\r\n    assembly {\r\n      // we know _preBytes_offset is 0\r\n      let fslot := sload(_preBytes.slot)\r\n      // Decode the length of the stored array like in concatStorage().\r\n      let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n      let mlength := mload(_postBytes)\r\n\r\n      // if lengths don't match the arrays are not equal\r\n      switch eq(slength, mlength)\r\n      case 1 {\r\n        // slength can contain both the length and contents of the array\r\n        // if length < 32 bytes so let's prepare for that\r\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n        if iszero(iszero(slength)) {\r\n          switch lt(slength, 32)\r\n          case 1 {\r\n            // blank the last byte which is the length\r\n            fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n            if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n              // unsuccess:\r\n              success := 0\r\n            }\r\n          }\r\n          default {\r\n            // cb is a circuit breaker in the for loop since there's\r\n            //  no said feature for inline assembly loops\r\n            // cb = 1 - don't breaker\r\n            // cb = 0 - break\r\n            let cb := 1\r\n\r\n            // get the keccak hash to get the contents of the array\r\n            mstore(0x0, _preBytes.slot)\r\n            let sc := keccak256(0x0, 0x20)\r\n\r\n            let mc := add(_postBytes, 0x20)\r\n            let end := add(mc, mlength)\r\n\r\n            // the next line is the loop condition:\r\n            // while(uint(mc < end) + cb == 2)\r\n            for {} eq(add(lt(mc, end), cb), 2) {\r\n              sc := add(sc, 1)\r\n              mc := add(mc, 0x20)\r\n            } {\r\n              if iszero(eq(sload(sc), mload(mc))) {\r\n                // unsuccess:\r\n                success := 0\r\n                cb := 0\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      default {\r\n        // unsuccess:\r\n        success := 0\r\n      }\r\n    }\r\n\r\n    return success;\r\n  }\r\n}\r\n\r\n// File: contracts/external/MerkleProof.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n/** @dev These functions deal with verification of Merkle trees (hash trees) */\r\ncontract MerkleProof {\r\n\r\n  /**\r\n   * Verifies the inclusion of a leaf in a Merkle tree using a Merkle proof.\r\n   * Based on https://github.com/ameensol/merkle-tree-solidity/src/MerkleProof.sol\r\n   */\r\n  function checkProof(bytes memory proof, bytes32 root, bytes32 leaf) public pure returns (bool) {\r\n    if (proof.length % 32 != 0) return false; // Check if proof is made of bytes32 slices\r\n\r\n    bytes memory elements = proof;\r\n    bytes32 element;\r\n    bytes32 hash = leaf;\r\n    for (uint i = 32; i <= proof.length; i += 32) {\r\n      assembly {\r\n      // Load the current element of the proofOfInclusion (optimal way to get a bytes32 slice)\r\n        element := mload(add(elements, i))\r\n      }\r\n      hash = keccak256(abi.encodePacked(hash < element ? abi.encodePacked(hash, element) : abi.encodePacked(element, hash)));\r\n    }\r\n    return hash == root;\r\n  }\r\n\r\n  // from StorJ -- https://github.com/nginnever/storj-audit-verifier/contracts/MerkleVerifyv3.sol\r\n  function checkProofOrdered(bytes memory proof, bytes32 root, bytes32 leaf, uint index) public pure returns (bool) {\r\n    if (proof.length % 32 != 0) return false; // Check if proof is made of bytes32 slices\r\n\r\n    // use the index to determine the node ordering (index ranges 1 to n)\r\n    bytes32 element;\r\n    bytes32 hash = leaf;\r\n    uint remaining;\r\n    for (uint j = 32; j <= proof.length; j += 32) {\r\n      assembly {\r\n        element := mload(add(proof, j))\r\n      }\r\n\r\n      // calculate remaining elements in proof\r\n      remaining = (proof.length - j + 32) / 32;\r\n\r\n      // we don't assume that the tree is padded to a power of 2\r\n      // if the index is odd then the proof will start with a hash at a higher layer,\r\n      // so we have to adjust the index to be the index at that layer\r\n      while (remaining > 0 && index % 2 == 1 && index > 2 ** remaining) {\r\n        index = uint(index) / 2 + 1;\r\n      }\r\n\r\n      if (index % 2 == 0) {\r\n        hash = keccak256(abi.encodePacked(abi.encodePacked(element, hash)));\r\n        index = index / 2;\r\n      } else {\r\n        hash = keccak256(abi.encodePacked(abi.encodePacked(hash, element)));\r\n        index = uint(index) / 2 + 1;\r\n      }\r\n    }\r\n    return hash == root;\r\n  }\r\n\r\n  /** Verifies the inclusion of a leaf in a Merkle tree using a Merkle proof */\r\n  function verifyIncluded(bytes memory proof, bytes32 root, bytes32 leaf) public pure returns (bool) {\r\n    return checkProof(proof, root, leaf);\r\n  }\r\n\r\n  /** Verifies the inclusion of a leaf is at a specific place in an ordered Merkle tree using a Merkle proof */\r\n  function verifyIncludedAtIndex(bytes memory proof, bytes32 root, bytes32 leaf, uint index) public pure returns (bool) {\r\n    return checkProofOrdered(proof, root, leaf, index);\r\n  }\r\n}\r\n\r\n// File: contracts/gluon/AppGovernance.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ninterface AppGovernance {\r\n  function approve(uint32 id) external;\r\n  function disapprove(uint32 id) external;\r\n  function activate(uint32 id) external;\r\n}\r\n\r\n// File: contracts/gluon/AppLogic.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n/**\r\n  * @notice representing an app's in-and-out transfers of assets\r\n  * @dev an account/asset based app should implement its own bookkeeping\r\n  */\r\ninterface AppLogic {\r\n\r\n  /// @notice when an app proposal has been activated, Gluon will call this method on the previously active app version\r\n  /// @dev each app must implement, providing a future upgrade path, and call retire_() at the very end.\r\n  /// this is the chance for the previously active app version to migrate to the new version\r\n  /// i.e.: migrating data, deprecate prior behavior, releasing resources, etc.\r\n  function upgrade() external;\r\n\r\n  /// @dev once an asset has been deposited into the app's safe within Gluon, the app is given the chance to do\r\n  /// it's own per account/asset bookkeeping\r\n  ///\r\n  /// @param account any Ethereum address\r\n  /// @param asset any ERC20 token or ETH (represented by address 0x0)\r\n  /// @param quantity quantity of asset\r\n  function credit(address account, address asset, uint quantity) external;\r\n\r\n  /// @dev before an asset can be withdrawn from the app's safe within Gluon, the quantity and asset to withdraw must be\r\n  /// derived from `parameters`. if the app is account/asset based, it should take this opportunity to:\r\n  /// - also derive the owning account from `parameters`\r\n  /// - prove that the owning account indeed has the derived quantity of the derived asset\r\n  /// - do it's own per account/asset bookkeeping\r\n  /// notice that the derived account is not necessarily the same as the provided account; a classic usage example is\r\n  /// an account transfers assets across app (in which case the provided account would be the target app)\r\n  ///\r\n  /// @param account any Ethereum address to which `quantity` of `asset` would be transferred to\r\n  /// @param parameters a bytes-marshalled record containing all data needed for the app-specific logic\r\n  /// @return asset any ERC20 token or ETH (represented by address 0x0)\r\n  /// @return quantity quantity of asset\r\n  function debit(address account, bytes calldata parameters) external returns (address asset, uint quantity);\r\n}\r\n\r\n// File: contracts/gluon/AppState.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n/**\r\n  * @title representing an app's life-cycle\r\n  * @notice an app's life-cycle starts in the ON state, then it is either move to the final OFF state,\r\n  * or to the RETIRED state when it upgrades itself to its successor version.\r\n  */\r\ncontract AppState {\r\n\r\n  enum State { OFF, ON, RETIRED }\r\n  State public state = State.ON;\r\n  event Off();\r\n  event Retired();\r\n\r\n  /// @notice app must be active (when current)\r\n  modifier whenOn() { require(state == State.ON, \"must be on\"); _; }\r\n\r\n  /// @notice app must be halted\r\n  modifier whenOff() { require(state == State.OFF, \"must be off\"); _; }\r\n\r\n  /// @notice app must be retired (when no longer current, after being upgraded)\r\n  modifier whenRetired() { require(state == State.RETIRED, \"must be retired\"); _; }\r\n\r\n  /// @dev retire the app. this action is irreversible.\r\n  /// called during a normal upgrade operation. by the end of this call the approved proposal would be active.\r\n  function retire_() internal whenOn {\r\n    state = State.RETIRED;\r\n    emit Retired();\r\n  }\r\n\r\n  /// @notice halt the app. this action is irreversible.\r\n  /// (the only option at this point is have a proposal that will get to approval, then activated.)\r\n  /// should be called by an app-owner when the app has been compromised.\r\n  function switchOff_() internal whenOn {\r\n    state = State.OFF;\r\n    emit Off();\r\n  }\r\n\r\n  /// @notice app state is active, i.e: current & active\r\n  function isOn() external view returns (bool) { return state == State.ON; }\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/common/Versioned.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ncontract Versioned {\r\n\r\n  string public version;\r\n\r\n  constructor(string memory version_) { version = version_; }\r\n\r\n}\r\n\r\n// File: contracts/gluon/GluonWallet.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ninterface GluonWallet {\r\n  function depositEther(uint32 id) external payable;\r\n  function depositToken(uint32 id, address token, uint quantity) external;\r\n  function withdraw(uint32 id, bytes calldata parameters) external;\r\n  function transfer(uint32 from, uint32 to, bytes calldata parameters) external;\r\n}\r\n\r\n// File: contracts/apps/stake/Governing.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ninterface Governing {\r\n  function deleteVoteTally(address proposal) external;\r\n  function activationInterval() external view returns (uint);\r\n}\r\n\r\n// File: contracts/common/HasOwners.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n/// @notice providing an ownership access control mechanism\r\ncontract HasOwners is Validating {\r\n\r\n  address[] public owners;\r\n  mapping(address => bool) public isOwner;\r\n\r\n  event OwnerAdded(address indexed owner);\r\n  event OwnerRemoved(address indexed owner);\r\n\r\n  /// @notice initializing the owners list (with at least one owner)\r\n  constructor(address[] memory owners_) {\r\n    require(owners_.length > 0, \"there must be at least one owner\");\r\n    for (uint i = 0; i < owners_.length; i++) addOwner_(owners_[i]);\r\n  }\r\n\r\n  /// @notice requires the sender to be one of the contract owners\r\n  modifier onlyOwner { require(isOwner[msg.sender], \"invalid sender; must be owner\"); _; }\r\n\r\n  /// @notice list all accounts with an owner access\r\n  function getOwners() public view returns (address[] memory) { return owners; }\r\n\r\n  /// @notice authorize an `account` with owner access\r\n  function addOwner(address owner) external onlyOwner { addOwner_(owner); }\r\n\r\n  function addOwner_(address owner) private validAddress(owner) {\r\n    if (!isOwner[owner]) {\r\n      isOwner[owner] = true;\r\n      owners.push(owner);\r\n      emit OwnerAdded(owner);\r\n    }\r\n  }\r\n\r\n  /// @notice revoke an `account` owner access (while ensuring at least one owner remains)\r\n  function removeOwner(address owner) external onlyOwner {\r\n    require(isOwner[owner], 'only owners can be removed');\r\n    require(owners.length > 1, 'can not remove last owner');\r\n    isOwner[owner] = false;\r\n    for (uint i = 0; i < owners.length; i++) {\r\n      if (owners[i] == owner) {\r\n        owners[i] = owners[owners.length - 1];\r\n        owners.pop();\r\n        emit OwnerRemoved(owner);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/gluon/HasAppOwners.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n/// @notice providing a per-app ownership access control\r\ncontract HasAppOwners is HasOwners {\r\n\r\n  mapping(uint32 => address[]) public appOwners;\r\n\r\n  event AppOwnerAdded (uint32 appId, address appOwner);\r\n  event AppOwnerRemoved (uint32 appId, address appOwner);\r\n\r\n  constructor(address[] memory owners_) HasOwners(owners_) { }\r\n\r\n  /// @notice requires the sender to be one of the app owners (of `appId`)\r\n  ///\r\n  /// @param appId index of the target app\r\n  modifier onlyAppOwner(uint32 appId) { require(isAppOwner(appId, msg.sender), \"invalid sender; must be app owner\"); _; }\r\n\r\n  function isAppOwner(uint32 appId, address appOwner) public view returns (bool) {\r\n    address[] memory currentOwners = appOwners[appId];\r\n    for (uint i = 0; i < currentOwners.length; i++) {\r\n      if (currentOwners[i] == appOwner) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /// @notice list all accounts with an app-owner access for `appId`\r\n  ///\r\n  /// @param appId index of the target app\r\n  function getAppOwners(uint32 appId) public view returns (address[] memory) { return appOwners[appId]; }\r\n\r\n  function addAppOwners(uint32 appId, address[] calldata toBeAdded) external onlyAppOwner(appId) {\r\n    addAppOwners_(appId, toBeAdded);\r\n  }\r\n\r\n  /// @notice authorize each of `toBeAdded` with app-owner access\r\n  ///\r\n  /// @param appId index of the target app\r\n  /// @param toBeAdded accounts to be authorized\r\n  /// (the initial app-owners are established during app registration)\r\n  function addAppOwners_(uint32 appId, address[] memory toBeAdded) internal {\r\n    for (uint i = 0; i < toBeAdded.length; i++) {\r\n      if (!isAppOwner(appId, toBeAdded[i])) {\r\n        appOwners[appId].push(toBeAdded[i]);\r\n        emit AppOwnerAdded(appId, toBeAdded[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /// @notice revokes app-owner access for each of `toBeRemoved` (while ensuring at least one app-owner remains)\r\n  ///\r\n  /// @param appId index of the target app\r\n  /// @param toBeRemoved accounts to have their membership revoked\r\n  function removeAppOwners(uint32 appId, address[] calldata toBeRemoved) external onlyAppOwner(appId) {\r\n    address[] storage currentOwners = appOwners[appId];\r\n    require(currentOwners.length > toBeRemoved.length, \"can not remove last owner\");\r\n    for (uint i = 0; i < toBeRemoved.length; i++) {\r\n      for (uint j = 0; j < currentOwners.length; j++) {\r\n        if (currentOwners[j] == toBeRemoved[i]) {\r\n          currentOwners[j] = currentOwners[currentOwners.length - 1];\r\n          currentOwners.pop();\r\n          emit AppOwnerRemoved(appId, toBeRemoved[i]);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/gluon/Gluon.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @title the Gluon-Plasma contract for upgradable side-chain apps (see: https://leverj.io/GluonPlasma.pdf)\r\n  * @notice once an app has been provisioned with me, I enable:\r\n  * - depositing an asset into an app\r\n  * - withdrawing an asset from an app\r\n  * - transferring an asset across apps\r\n  * - submitting (and discarding) an upgrade proposal for an app\r\n  * - voting for/against app proposals\r\n  * - upgrading an approved app proposal\r\n  */\r\ncontract Gluon is Validating, Versioned, AppGovernance, GluonWallet, HasAppOwners {\r\n  using SafeMath for uint;\r\n\r\n  struct App {\r\n    address[] history;\r\n    address proposal;\r\n    uint activationBlock;\r\n    mapping(address => uint) balances;\r\n  }\r\n\r\n  address private constant ETH = address(0x0);\r\n  uint32 private constant REGISTRY_INDEX = 0;\r\n  uint32 private constant STAKE_INDEX = 1;\r\n\r\n  mapping(uint32 => App) public apps;\r\n  mapping(address => bool) public proposals;\r\n  uint32 public totalAppsCount = 0;\r\n\r\n  event AppRegistered (uint32 appId);\r\n  event AppProvisioned(uint32 indexed appId, uint8 version, address logic);\r\n  event ProposalAdded(uint32 indexed appId, uint8 version, address logic, uint activationBlock);\r\n  event ProposalRemoved(uint32 indexed appId, uint8 version, address logic);\r\n  event Activated(uint32 indexed appId, uint8 version, address logic);\r\n\r\n  constructor(address[] memory owners_, string memory version_) Versioned(version_) HasAppOwners(owners_) {\r\n    registerApp_(REGISTRY_INDEX, owners);\r\n    registerApp_(STAKE_INDEX, owners);\r\n  }\r\n\r\n  /// @notice requires the sender to be the currently active (latest) version of the app contract (identified by appId)\r\n  ///\r\n  /// @param appId index of the provisioned app in question\r\n  modifier onlyCurrentLogic(uint32 appId) { require(msg.sender == current(appId), \"invalid sender; must be latest logic contract\"); _; }\r\n\r\n  modifier provisioned(uint32 appId) { require(apps[appId].history.length > 0, \"App is not yet provisioned\"); _; }\r\n\r\n  function registerApp(uint32 appId, address[] calldata accounts) external onlyOwner { registerApp_(appId, accounts); }\r\n\r\n  function registerApp_(uint32 appId, address[] memory accounts) private {\r\n    require(appOwners[appId].length == 0, \"App already has app owner\");\r\n    require(totalAppsCount == appId, \"app ids are incremented by 1\");\r\n    totalAppsCount++;\r\n    emit AppRegistered(appId);\r\n    addAppOwners_(appId, accounts);\r\n  }\r\n\r\n  /// @notice on-boarding an app\r\n  ///\r\n  /// @param logic address of the app's contract (the first version)\r\n  /// @param appId index of the provisioned app in question\r\n  function provisionApp(uint32 appId, address logic) external onlyAppOwner(appId) validAddress(logic) {\r\n    App storage app = apps[appId];\r\n    require(app.history.length == 0, \"App is already provisioned\");\r\n    app.history.push(logic);\r\n    emit AppProvisioned(appId, uint8(app.history.length - 1), logic);\r\n  }\r\n\r\n  /************************************************* Governance ************************************************/\r\n\r\n  function addProposal(uint32 appId, address logic) external onlyAppOwner(appId) provisioned(appId) validAddress(logic) {\r\n    App storage app = apps[appId];\r\n    require(app.proposal == address(0x0), \"Proposal already exists. remove proposal before adding new one\");\r\n    app.proposal = logic;\r\n    app.activationBlock = block.number + Governing(current(STAKE_INDEX)).activationInterval();\r\n    proposals[logic] = true;\r\n    emit ProposalAdded(appId, uint8(app.history.length - 1), app.proposal, app.activationBlock);\r\n  }\r\n\r\n  function removeProposal(uint32 appId) external onlyAppOwner(appId) provisioned(appId) {\r\n    App storage app = apps[appId];\r\n    emit ProposalRemoved(appId, uint8(app.history.length - 1), app.proposal);\r\n    deleteProposal(app);\r\n  }\r\n\r\n  function deleteProposal(App storage app) private {\r\n    Governing(current(STAKE_INDEX)).deleteVoteTally(app.proposal);\r\n    delete proposals[app.proposal];\r\n    delete app.proposal;\r\n    app.activationBlock = 0;\r\n  }\r\n\r\n  /************************************************* AppGovernance ************************************************/\r\n\r\n  function approve(uint32 appId) external override onlyCurrentLogic(STAKE_INDEX) {\r\n    apps[appId].activationBlock = block.number;\r\n  }\r\n\r\n  function disapprove(uint32 appId) external override onlyCurrentLogic(STAKE_INDEX) {\r\n    App storage app = apps[appId];\r\n    emit ProposalRemoved(appId, uint8(app.history.length - 1), app.proposal);\r\n    deleteProposal(app);\r\n  }\r\n\r\n  function activate(uint32 appId) external override onlyCurrentLogic(appId) provisioned(appId) {\r\n    App storage app = apps[appId];\r\n    require(app.activationBlock > 0, \"nothing to activate\");\r\n    require(app.activationBlock < block.number, \"new app can not be activated before activation block\");\r\n    app.history.push(app.proposal); // now make it the current\r\n    deleteProposal(app);\r\n    emit Activated(appId, uint8(app.history.length - 1), current(appId));\r\n  }\r\n\r\n  /**************************************************** GluonWallet ****************************************************/\r\n\r\n  /// @notice deposit ETH asset on behalf of the sender into an app's safe\r\n  ///\r\n  /// @param appId index of the target app\r\n  function depositEther(uint32 appId) external override payable provisioned(appId) {\r\n    App storage app = apps[appId];\r\n    app.balances[ETH] = app.balances[ETH].add(msg.value);\r\n    AppLogic(current(appId)).credit(msg.sender, ETH, msg.value);\r\n  }\r\n\r\n  /// @notice deposit ERC20 token asset (represented by address 0x0) on behalf of the sender into an app's safe\r\n  /// @dev an account must call token.approve(logic, quantity) beforehand\r\n  ///\r\n  /// @param appId index of the target app\r\n  /// @param token address of ERC20 token contract\r\n  /// @param quantity how much of token\r\n  function depositToken(uint32 appId, address token, uint quantity) external override provisioned(appId) {\r\n    transferTokensToGluonSecurely(appId, IERC20(token), quantity);\r\n    AppLogic(current(appId)).credit(msg.sender, token, quantity);\r\n  }\r\n\r\n  function transferTokensToGluonSecurely(uint32 appId, IERC20 token, uint quantity) private {\r\n    uint balanceBefore = token.balanceOf(address(this));\r\n    require(token.transferFrom(msg.sender, address(this), quantity), \"failure to transfer quantity from token\");\r\n    uint balanceAfter = token.balanceOf(address(this));\r\n    require(balanceAfter.sub(balanceBefore) == quantity, \"bad Token; transferFrom erroneously reported of successful transfer\");\r\n    App storage app = apps[appId];\r\n    app.balances[address(token)] = app.balances[address(token)].add(quantity);\r\n  }\r\n\r\n  /// @notice withdraw a quantity of asset from an app's safe\r\n  /// @dev quantity & asset should be derived by the app\r\n  ///\r\n  /// @param appId index of the target app\r\n  /// @param parameters a bytes-marshalled record containing at the very least quantity & asset\r\n  function withdraw(uint32 appId, bytes calldata parameters) external override provisioned(appId) {\r\n    (address asset, uint quantity) = AppLogic(current(appId)).debit(msg.sender, parameters);\r\n    if (quantity > 0) {\r\n      App storage app = apps[appId];\r\n      require(app.balances[asset] >= quantity, \"not enough funds to transfer\");\r\n      app.balances[asset] = apps[appId].balances[asset].sub(quantity);\r\n      asset == ETH ?\r\n        require(address(uint160(msg.sender)).send(quantity), \"failed to transfer ether\") : // explicit casting to `address payable`\r\n        transferTokensToAccountSecurely(IERC20(asset), quantity, msg.sender);\r\n    }\r\n  }\r\n\r\n  function transferTokensToAccountSecurely(IERC20 token, uint quantity, address to) private {\r\n    uint balanceBefore = token.balanceOf(to);\r\n    require(token.transfer(to, quantity), \"failure to transfer quantity from token\");\r\n    uint balanceAfter = token.balanceOf(to);\r\n    require(balanceAfter.sub(balanceBefore) == quantity, \"bad Token; transferFrom erroneously reported of successful transfer\");\r\n  }\r\n\r\n  /// @notice withdraw a quantity of asset from a source app's safe and transfer it (within Gluon) to a target app's safe\r\n  /// @dev quantity & asset should be derived by the source app\r\n  ///\r\n  /// @param from index of the source app\r\n  /// @param to index of the target app\r\n  /// @param parameters a bytes-marshalled record containing at the very least quantity & asset\r\n  function transfer(uint32 from, uint32 to, bytes calldata parameters) external override provisioned(from) provisioned(to) {\r\n    (address asset, uint quantity) = AppLogic(current(from)).debit(msg.sender, parameters);\r\n    if (quantity > 0) {\r\n      if (from != to) {\r\n        require(apps[from].balances[asset] >= quantity, \"not enough balance in logic to transfer\");\r\n        apps[from].balances[asset] = apps[from].balances[asset].sub(quantity);\r\n        apps[to].balances[asset] = apps[to].balances[asset].add(quantity);\r\n      }\r\n      AppLogic(current(to)).credit(msg.sender, asset, quantity);\r\n    }\r\n  }\r\n\r\n  /**************************************************** GluonView  ****************************************************/\r\n\r\n  /// @notice view of current app data\r\n  ///\r\n  /// @param appId index of the provisioned app in question\r\n  /// @return current address of the app's current contract\r\n  /// @return proposal address of the app's pending proposal contract (if any)\r\n  /// @return activationBlock the block in which the proposal can be activated\r\n  function app(uint32 appId) external view returns (address current, address proposal, uint activationBlock) {\r\n    App storage app_ = apps[appId];\r\n    current = app_.history[app_.history.length - 1];\r\n    proposal = app_.proposal;\r\n    activationBlock = app_.activationBlock;\r\n  }\r\n\r\n  function current(uint32 appId) public view returns (address) { return apps[appId].history[apps[appId].history.length - 1]; }\r\n\r\n  /// @notice view of the full chain of (contract addresses) of the app versions, up to and including the current one\r\n  function history(uint32 appId) external view returns (address[] memory) { return apps[appId].history; }\r\n\r\n  /// @notice is the `logic` contract one of the `appId` app?\r\n  function isAnyLogic(uint32 appId, address logic) public view returns (bool) {\r\n    address[] memory history_ = apps[appId].history;\r\n    for (uint i = history_.length; i > 0; i--) {\r\n      if (history_[i - 1] == logic) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /// @notice what is the current balance of `asset` in the `appId` app's safe?\r\n  function getBalance(uint32 appId, address asset) external view returns (uint) { return apps[appId].balances[asset]; }\r\n\r\n}\r\n\r\n// File: contracts/gluon/GluonCentric.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n/**\r\n  * @title the essentials of a side-chain app participating in Gluon-Plasma\r\n  * @dev both Logic & Data (if exists) contracts should inherit this contract\r\n  */\r\ncontract GluonCentric {\r\n\r\n  uint32 internal constant REGISTRY_INDEX = 0;\r\n  uint32 internal constant STAKE_INDEX = 1;\r\n\r\n  uint32 public id;\r\n  Gluon public gluon;\r\n\r\n  /// @param id_ index of the app within gluon\r\n  /// @param gluon_ address of the Gluon contract\r\n  constructor(uint32 id_, address gluon_) {\r\n    id = id_;\r\n    gluon = Gluon(gluon_);\r\n  }\r\n\r\n  /// @notice requires the sender to be the currently active (latest) version of me (the app contract)\r\n  modifier onlyCurrentLogic { require(currentLogic() == msg.sender, \"invalid sender; must be current logic contract\"); _; }\r\n\r\n  /// @notice requires the sender must be gluon contract\r\n  modifier onlyGluon { require(address(gluon) == msg.sender, \"invalid sender; must be gluon contract\"); _; }\r\n\r\n  /// @notice requires the sender must be my app owner\r\n  modifier onlyOwner { require(gluon.isAppOwner(id, msg.sender), \"invalid sender; must be app owner\"); _; }\r\n\r\n  /// @return address the address of currently active (latest) version of me (the app contract)\r\n  function currentLogic() public view returns (address) { return gluon.current(id); }\r\n\r\n}\r\n\r\n// File: contracts/gluon/GluonLogic.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\nabstract contract GluonLogic is GluonCentric {\r\n  address public upgradeOperator;\r\n\r\n  constructor(uint32 id_, address gluon_) GluonCentric(id_, gluon_) { }\r\n\r\n  modifier onlyUpgradeOperator { require(upgradeOperator == msg.sender, \"invalid sender; must be upgrade operator\"); _; }\r\n\r\n  function setUpgradeOperator(address upgradeOperator_) external onlyOwner { upgradeOperator = upgradeOperator_; }\r\n\r\n  function upgrade_(AppGovernance appGovernance, uint32 id) internal {\r\n    appGovernance.activate(id);\r\n    delete upgradeOperator;\r\n  }\r\n}\r\n\r\n// File: contracts/gluon/GluonExtension.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n/**\r\n  * @title the essentials of a side-chain app participating in Gluon-Plasma\r\n  * @dev both Logic & Data (if exists) contracts should inherit this contract\r\n  */\r\ncontract GluonExtension is Validating, GluonLogic {\r\n  address[] public extensions;\r\n  mapping(address => bool) public isExtension;\r\n\r\n  event ExtensionAdded(address indexed extension);\r\n  event ExtensionRemoved(address indexed extension);\r\n\r\n  /// @param id_ index of the app within gluon\r\n  /// @param gluon_ address of the Gluon contract\r\n  constructor(uint32 id_, address gluon_, address[] memory extensions_) GluonLogic(id_, gluon_) {\r\n    for (uint i = 0; i < extensions_.length; i++) addExtension_(extensions_[i]);\r\n  }\r\n\r\n  /// @notice requires the sender must be gluon or extension\r\n  modifier onlyGluonWallet { require(address(gluon) == msg.sender || isExtension[msg.sender], \"invalid sender; must be gluon contract or one of the extension\"); _; }\r\n\r\n  /// @notice add a extension\r\n  function addExtension(address extension) external onlyOwner {addExtension_(extension);}\r\n\r\n  function addExtension_(address extension) private validAddress(extension) {\r\n    if (!isExtension[extension]) {\r\n      isExtension[extension] = true;\r\n      extensions.push(extension);\r\n      emit ExtensionAdded(extension);\r\n    }\r\n  }\r\n\r\n  function getExtensions() public view returns (address[] memory){return extensions;}\r\n}\r\n\r\n// File: contracts/common/EvmTypes.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ncontract EvmTypes {\r\n  uint constant internal ADDRESS = 20;\r\n  uint constant internal UINT8 = 1;\r\n  uint constant internal UINT32 = 4;\r\n  uint constant internal UINT64 = 8;\r\n  uint constant internal UINT128 = 16;\r\n  uint constant internal UINT256 = 32;\r\n  uint constant internal BYTES32 = 32;\r\n  uint constant internal SIGNATURE_BYTES = 65;\r\n}\r\n\r\n// File: contracts/apps/common/WithDepositCommitmentRecord.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n/// @title unpacking DepositCommitmentRecord from bytes\r\ncontract WithDepositCommitmentRecord is EvmTypes {\r\n  using BytesLib for bytes;\r\n\r\n  struct DepositCommitmentRecord {\r\n    uint32 ledgerId;\r\n    address account;\r\n    address asset;\r\n    uint quantity;\r\n    uint32 nonce;\r\n    uint32 designatedGblock;\r\n    bytes32 hash;\r\n  }\r\n\r\n  uint constant private LEDGER_ID = 0;\r\n  uint constant private ACCOUNT = LEDGER_ID + UINT32;\r\n  uint constant private ASSET = ACCOUNT + ADDRESS;\r\n  uint constant private QUANTITY = ASSET + ADDRESS;\r\n  uint constant private NONCE = QUANTITY + UINT256;\r\n  uint constant private DESIGNATED_GBLOCK = NONCE + UINT32;\r\n\r\n  function parseDepositCommitmentRecord(bytes memory parameters) internal pure returns (DepositCommitmentRecord memory result) {\r\n    result.ledgerId = parameters.toUint32(LEDGER_ID);\r\n    result.account = parameters.toAddress(ACCOUNT);\r\n    result.asset = parameters.toAddress(ASSET);\r\n    result.quantity = parameters.toUint(QUANTITY);\r\n    result.nonce = parameters.toUint32(NONCE);\r\n    result.designatedGblock = parameters.toUint32(DESIGNATED_GBLOCK);\r\n    result.hash = keccak256(encodePackedDeposit(result.ledgerId, result.account, result.asset, result.quantity, result.nonce, result.designatedGblock));\r\n  }\r\n\r\n  function encodePackedDeposit(uint32 ledgerId, address account, address asset, uint quantity, uint32 nonce, uint32 designatedGblock) public pure returns(bytes memory) {\r\n    return abi.encodePacked(ledgerId, account, asset, quantity, nonce, designatedGblock);\r\n  }\r\n}\r\n\r\n// File: contracts/apps_history/registry/OldRegistry.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ninterface OldRegistry {\r\n  function contains(address apiKey) external view returns (bool);\r\n  function register(address apiKey) external;\r\n  function registerWithUserAgreement(address apiKey, bytes32 userAgreement) external;\r\n  function translate(address apiKey) external view returns (address);\r\n}\r\n\r\n// File: contracts/apps/registry/RegistryData.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\ncontract RegistryData is GluonCentric {\r\n\r\n  mapping(address => address) public accounts;\r\n\r\n  constructor(address gluon_) GluonCentric(REGISTRY_INDEX, gluon_) { }\r\n\r\n  function addKey(address apiKey, address account) external onlyCurrentLogic {\r\n    accounts[apiKey] = account;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/apps/registry/RegistryLogic.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @title enabling Zero Knowledge API Keys as described in: https://blog.leverj.io/zero-knowledge-api-keys-43280cc93647\r\n  * @notice the Registry app consists of the RegistryLogic & RegistryData contracts.\r\n  * api-key registrations are held within RegistryData for an easier upgrade path.\r\n  * @dev although Registry enable account-based apps needing log-less logins, no app is required to use it.\r\n  */\r\ncontract RegistryLogic is Validating, AppLogic, AppState, GluonLogic {\r\n\r\n  RegistryData public data;\r\n  OldRegistry public old;\r\n\r\n  event Registered(address apiKey, address indexed account);\r\n\r\n  constructor(address gluon_, address old_, address data_) GluonLogic(REGISTRY_INDEX, gluon_) {\r\n    data = RegistryData(data_);\r\n    old = OldRegistry(old_);\r\n  }\r\n\r\n  modifier isAbsent(address apiKey) { require(translate(apiKey) == address (0x0), \"api key already in use\"); _; }\r\n\r\n  /// @notice register an api-key on behalf of the sender\r\n  /// @dev irreversible operation; the apiKey->sender association cannot be broken or overwritten\r\n  /// (but further apiKey->sender associations can be provided)\r\n  ///\r\n  /// @param apiKey the account to be used to stand-in for the registering sender\r\n  function register(address apiKey) external whenOn validAddress(apiKey) isAbsent(apiKey) {\r\n    data.addKey(apiKey, msg.sender);\r\n    emit Registered(apiKey, msg.sender);\r\n  }\r\n\r\n  /// @notice retrieve the stand-in-for account\r\n  ///\r\n  /// @param apiKey the account to be used to stand-in for the registering sender\r\n  function translate(address apiKey) public view returns (address) {\r\n    address account = data.accounts(apiKey);\r\n    if (account == address(0x0)) account = old.translate(apiKey);\r\n    return account;\r\n  }\r\n\r\n  /**************************************************** AppLogic ****************************************************/\r\n\r\n  /// @notice upgrade the app to a new version; the approved proposal.\r\n  /// by the end of this call the approved proposal would be the current and active version of the app.\r\n  function upgrade() external override onlyUpgradeOperator {\r\n    retire_();\r\n    upgrade_(AppGovernance(gluon), id);\r\n  }\r\n\r\n  function credit(address, address, uint) external override pure { revert(\"not supported\"); }\r\n\r\n  function debit(address, bytes calldata) external override pure returns (address, uint) { revert(\"not supported\"); }\r\n\r\n  /***************************************************** AppState *****************************************************/\r\n\r\n  /// @notice halt the app. this action is irreversible.\r\n  /// (the only option at this point is have a proposal that will get to approval, then activated.)\r\n  /// should be called by an app-owner when the app has been compromised.\r\n  ///\r\n  /// Note the constraint that all apps but Registry & Stake must be halted first!\r\n  function switchOff() external onlyOwner {\r\n    uint32 totalAppsCount = gluon.totalAppsCount();\r\n    for (uint32 i = 2; i < totalAppsCount; i++) {\r\n      AppState appState = AppState(gluon.current(i));\r\n      require(!appState.isOn(), \"One of the apps is still ON\");\r\n    }\r\n    switchOff_();\r\n  }\r\n\r\n  /********************************************************************************************************************/\r\n}\r\n\r\n// File: contracts/apps/spot/SpotData.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\ncontract SpotData is GluonCentric {\r\n\r\n  struct Gblock {\r\n    bytes32 withdrawalsRoot;\r\n    bytes32 depositsRoot;\r\n    bytes32 balancesRoot;\r\n  }\r\n\r\n  uint32 public nonce = 0;\r\n  uint32 public currentGblockNumber;\r\n  uint public submissionBlock = block.number;\r\n  mapping(uint32 => Gblock) public gblocksByNumber;\r\n  mapping(bytes32 => bool) public deposits;\r\n  mapping(bytes32 => bool) public withdrawn;\r\n  mapping(bytes32 => uint) public exitClaims; // exit entry hash => confirmationThreshold\r\n  mapping(address => mapping(address => bool)) public exited; // account => asset => has exited\r\n\r\n  constructor(uint32 id_, address gluon_) GluonCentric(id_, gluon_) { }\r\n\r\n  function deposit(bytes32 hash) external onlyCurrentLogic { deposits[hash] = true; }\r\n\r\n  function deleteDeposit(bytes32 hash) external onlyCurrentLogic {\r\n    require(deposits[hash], \"unknown deposit\");\r\n    delete deposits[hash];\r\n  }\r\n\r\n  function nextNonce() external onlyCurrentLogic returns (uint32) { return ++nonce; }\r\n\r\n  function markExited(address account, address asset) external onlyCurrentLogic { exited[account][asset] = true; }\r\n\r\n  function markWithdrawn(bytes32 hash) external onlyCurrentLogic {withdrawn[hash] = true;}\r\n\r\n  function hasExited(address account, address asset) external view returns (bool) { return exited[account][asset]; }\r\n\r\n  function hasWithdrawn(bytes32 hash) external view returns (bool) { return withdrawn[hash]; }\r\n\r\n  function markExitClaim(bytes32 hash, uint confirmationThreshold) external onlyCurrentLogic { exitClaims[hash] = confirmationThreshold; }\r\n\r\n  function deleteExitClaim(bytes32 hash) external onlyCurrentLogic { delete exitClaims[hash]; }\r\n\r\n  function submit(uint32 gblockNumber, bytes32 withdrawalsRoot, bytes32 depositsRoot, bytes32 balancesRoot, uint submissionInterval) external onlyCurrentLogic {\r\n    Gblock memory gblock = Gblock(withdrawalsRoot, depositsRoot, balancesRoot);\r\n    gblocksByNumber[gblockNumber] = gblock;\r\n    currentGblockNumber = gblockNumber;\r\n    submissionBlock = block.number + submissionInterval;\r\n  }\r\n\r\n  function updateSubmissionBlock(uint submissionBlock_) external onlyCurrentLogic { submissionBlock = submissionBlock_; }\r\n\r\n  function depositsRoot(uint32 gblockNumber) external view returns (bytes32) { return gblocksByNumber[gblockNumber].depositsRoot; }\r\n\r\n  function withdrawalsRoot(uint32 gblockNumber) external view returns (bytes32) { return gblocksByNumber[gblockNumber].withdrawalsRoot; }\r\n\r\n  function balancesRoot(uint32 gblockNumber) external view returns (bytes32) { return gblocksByNumber[gblockNumber].balancesRoot; }\r\n\r\n  function isConfirmedGblock(uint32 gblockNumber) external view returns (bool) { return gblockNumber > 0 && gblockNumber < currentGblockNumber; }\r\n\r\n}\r\n\r\n// File: contracts/external/Cryptography.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ncontract Cryptography {\r\n\r\n  /**\r\n  * @dev Recover signer address from a message by using their signature\r\n  * @param hash message, the hash is the signed message. What is recovered is the signer address.\r\n  * @param signature generated using web3.eth.account.direction().signature\r\n  *\r\n  * Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n  * TODO: Remove this library once solidity supports passing a signature to ecrecover.\r\n  * See https://github.com/ethereum/solidity/issues/864\r\n  */\r\n  function recover(bytes32 hash, bytes memory signature) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    if (signature.length != 65) return (address(0x0));\r\n    // Check the signature length\r\n\r\n    // Divide the signature into r, s and v variables\r\n    assembly {\r\n      r := mload(add(signature, 32))\r\n      s := mload(add(signature, 64))\r\n      v := byte(0, mload(add(signature, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) v += 27;\r\n\r\n    // If the version is correct return the signer address\r\n    return (v != 27 && v != 28) ? (address(0x0)) : ecrecover(hash, v, r, s);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/apps/spot/WithEntry.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n\r\n/// @title unpacking ledger Entry from bytes\r\ncontract WithEntry is EvmTypes, Cryptography {\r\n  using BytesLib for bytes;\r\n\r\n  struct Entry {\r\n    uint32 ledgerId;\r\n    address account;\r\n    address asset;\r\n    EntryType entryType;\r\n    uint8 action;\r\n    uint timestamp;\r\n    uint quantity;\r\n    uint balance;\r\n    uint previous;\r\n    uint32 gblockNumber;\r\n    bytes32 hash;\r\n    bytes32 dataHash;\r\n    bytes signature;\r\n    address signer;\r\n    bytes dataBytes;\r\n  }\r\n\r\n  uint constant private VERSION = 0;\r\n  uint constant private LEDGER_ID = VERSION + UINT8;\r\n  uint constant private ACCOUNT = LEDGER_ID + UINT32;\r\n  uint constant private ASSET = ACCOUNT + ADDRESS;\r\n  uint constant private ENTRY_TYPE = ASSET + ADDRESS;\r\n  uint constant private ACTION = ENTRY_TYPE + UINT8;\r\n  uint constant private TIMESTAMP = ACTION + UINT8;\r\n  uint constant private QUANTITY = TIMESTAMP + UINT64;\r\n  uint constant private BALANCE = QUANTITY + UINT256;\r\n  uint constant private PREVIOUS = BALANCE + UINT256;\r\n  uint constant private GBLOCK_NUMBER = PREVIOUS + UINT128;\r\n  uint constant private DATA_HASH = GBLOCK_NUMBER + UINT32;\r\n  uint constant private ENTRY_LENGTH = DATA_HASH + BYTES32;\r\n\r\n  enum EntryType {Unknown, Origin, Deposit, Withdrawal, Exited, Trade, Fee, ignore1, ignore2, ignore3, ignore4, ignore5, Transfer} /* filling with ignore* just so Transfer will be 12, to match Derivatives */\r\n\r\n  function parseEntry(bytes memory parameters, bytes memory signature) internal pure returns (Entry memory result) {\r\n    result.ledgerId = parameters.toUint32(LEDGER_ID);\r\n    result.account = parameters.toAddress(ACCOUNT);\r\n    result.asset = parameters.toAddress(ASSET);\r\n    result.entryType = EntryType(parameters.toUint8(ENTRY_TYPE));\r\n    result.action = parameters.toUint8(ACTION);\r\n    result.timestamp = parameters.toUint64(TIMESTAMP);\r\n    result.quantity = parameters.toUint(QUANTITY);\r\n    result.balance = parameters.toUint(BALANCE);\r\n    result.previous = parameters.toUint128(PREVIOUS);\r\n    result.gblockNumber = parameters.toUint32(GBLOCK_NUMBER);\r\n    result.dataHash = parameters.toBytes32(DATA_HASH);\r\n    bytes memory entryBytes = parameters;\r\n    if (parameters.length > ENTRY_LENGTH) {\r\n      result.dataBytes = parameters.slice(ENTRY_LENGTH, parameters.length - ENTRY_LENGTH);\r\n      require(result.dataHash == keccak256(result.dataBytes), \"data hash mismatch\");\r\n      entryBytes = parameters.slice(0, ENTRY_LENGTH);\r\n    }\r\n    result.hash = keccak256(entryBytes);\r\n    result.signer = recover(result.hash, signature);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/apps/spot/SpotLogic.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @title enabling the Leverj Spot DEX\r\n  * @notice the Spot app consists of the SpotLogic & SpotData contracts\r\n  * Gblocks related data and withdrawals tracking data are held within SpotData for an easier upgrade path.\r\n  *\r\n  * the Stake app enables:\r\n  * - account/asset based bookkeeping via an side-chain ledger\r\n  * - periodic submission of merkle-tree roots of the side-chain ledger\r\n  * - fraud-proofs based security of account/asset withdrawals\r\n  * - account based AML\r\n  * in-depth details and reasoning are detailed in: https://leverj.io/GluonPlasma.pdf\r\n  */\r\ncontract SpotLogic is Validating, MerkleProof, AppLogic, AppState, GluonExtension, WithDepositCommitmentRecord, WithEntry {\r\n  using SafeMath for uint;\r\n  using BytesLib for bytes;\r\n\r\n  struct ProofOfInclusionAtIndex {\r\n    bytes32 leaf;\r\n    uint index;\r\n    bytes proof;\r\n  }\r\n\r\n  struct ProofOfExclusionOfDeposit {\r\n    ProofOfInclusionAtIndex predecessor;\r\n    ProofOfInclusionAtIndex successor;\r\n  }\r\n\r\n  uint public constant name = uint(keccak256(\"SpotLogic\"));\r\n  uint8 public constant confirmationDelay = 5;\r\n  uint8 public constant visibilityDelay = 1;\r\n\r\n  uint private constant ASSISTED_WITHDRAW = 1;\r\n  uint private constant RECLAIM_DEPOSIT = 2;\r\n  uint private constant CLAIM_EXIT = 3;\r\n  uint private constant EXIT = 4;\r\n  uint private constant EXIT_ON_HALT = 5;\r\n  uint private constant RECLAIM_DEPOSIT_ON_HALT = 6;\r\n\r\n  uint private constant MAX_EXIT_COUNT = 100;\r\n\r\n  SpotData public data;\r\n  address public operator;\r\n  uint public submissionInterval;\r\n  uint public abandonPoint;\r\n  uint32 public exitCounts = 0;\r\n\r\n  event Deposited(address indexed account, address indexed asset, uint quantity, uint32 nonce, uint32 designatedGblock);\r\n  event DepositReclaimed(address indexed account, address indexed asset, uint quantity, uint32 nonce);\r\n  event ExitClaimed(bytes32 hash, address indexed account, address indexed asset, uint confirmationThreshold);\r\n  event Exited(address indexed account, address indexed asset, uint quantity);\r\n  event Withdrawn(bytes32 hash, address indexed account, address indexed asset, uint quantity);\r\n  event Submitted(uint32 gblockNumber, bytes32 withdrawalsRoot, bytes32 depositsRoot, bytes32 balancesRoot);\r\n\r\n  constructor(uint32 id_, address gluon_, address data_, address operator_, uint submissionInterval_, uint abandonPoint_, address[] memory extensions_)\r\n    GluonExtension(id_, gluon_, extensions_)\r\n    validAddress(gluon_)\r\n    validAddress(operator_)\r\n  {\r\n    operator = operator_;\r\n    submissionInterval = submissionInterval_;\r\n    data = SpotData(data_);\r\n    abandonPoint = abandonPoint_;\r\n  }\r\n\r\n  function currentGblockNumber() public view returns (uint32) {\r\n    return data.currentGblockNumber();\r\n  }\r\n\r\n  /**************************************************** AppLogic ****************************************************/\r\n\r\n  function upgrade() external override whenOn onlyUpgradeOperator {\r\n    require(canSubmit(), \"cannot upgrade yet\");\r\n    (, address proposal,) = gluon.app(id);\r\n    address[] memory logics = gluon.history(id);\r\n    require(proposal != address(this), \"can not be the same contract\");\r\n    require(SpotLogic(proposal).id() == id, \"invalid app id\");\r\n    for (uint i = 0; i < logics.length; i++) require(proposal != logics[i], \"can not be old contract\");\r\n    require(SpotLogic(proposal).name() == name, \"proposal name is different\");\r\n    retire_();\r\n    upgrade_(AppGovernance(gluon), id);\r\n  }\r\n\r\n  function credit(address account, address asset, uint quantity) external override whenOn onlyGluonWallet {\r\n    require(!data.hasExited(account, asset), \"previously exited\");\r\n    uint32 nonce = data.nextNonce();\r\n    uint32 designatedGblock = currentGblockNumber() + visibilityDelay;\r\n    bytes32 hash = keccak256(abi.encodePacked(id, account, asset, quantity, nonce, designatedGblock));\r\n    data.deposit(hash);\r\n    emit Deposited(account, asset, quantity, nonce, designatedGblock);\r\n  }\r\n\r\n  function debit(address account, bytes calldata parameters) external override onlyGluonWallet returns (address asset, uint quantity) {\r\n    uint action = parameters.toUint(0);\r\n    if (action == ASSISTED_WITHDRAW) return assistedWithdraw(account, parameters);\r\n    else if (action == RECLAIM_DEPOSIT) return reclaimDeposit(account, parameters);\r\n    else if (action == CLAIM_EXIT) return claimExit(account, parameters);\r\n    else if (action == EXIT) return exit(account, parameters);\r\n    else if (action == EXIT_ON_HALT) return exitOnHalt(account, parameters);\r\n    else if (action == RECLAIM_DEPOSIT_ON_HALT) return reclaimDepositOnHalt(account, parameters);\r\n    else revert(\"invalid action\");\r\n  }\r\n\r\n  /**************************************************** Depositing ****************************************************/\r\n\r\n  /// @notice if a Deposit is not included in the Ledger, reclaim it using a proof-of-exclusion\r\n  /// @dev Deposited events must be listened to, and a corresponding Deposit entry should be created with the event's data as the witness\r\n  ///\r\n  /// @param account the claimant\r\n  /// @param parameters packed proof-of-exclusion of deposit\r\n  function reclaimDeposit(address account, bytes memory parameters) private whenOn returns (address asset, uint quantity) {\r\n    (, bytes memory recordParameters, bytes memory proofBytes1, bytes memory proofBytes2) = abi.decode(parameters, (uint, bytes, bytes, bytes));\r\n    DepositCommitmentRecord memory record = parseAndValidateDepositCommitmentRecord(account, recordParameters);\r\n    require(currentGblockNumber() > record.designatedGblock + 1 && record.designatedGblock != 0, \"designated gblock is unconfirmed or unknown\");\r\n    require(proveIsExcludedFromDeposits(record, data.depositsRoot(record.designatedGblock), proofBytes1), \"failed to proof exclusion of deposit\");\r\n    require(proveIsExcludedFromDeposits(record, data.depositsRoot(record.designatedGblock + 1), proofBytes2), \"failed to proof exclusion of deposit\");\r\n    return reclaimDeposit_(record);\r\n  }\r\n\r\n  function parseAndValidateDepositCommitmentRecord(address account, bytes memory commitmentRecord) private view returns (DepositCommitmentRecord memory record){\r\n    record = parseDepositCommitmentRecord(commitmentRecord);\r\n    require(record.ledgerId == id, \"not from current ledger\");\r\n    require(record.account == account, \"claimant must be the original depositor\");\r\n  }\r\n\r\n  function proveIsExcludedFromDeposits(DepositCommitmentRecord memory record, bytes32 root, bytes memory proofBytes) private pure returns (bool) {\r\n    ProofOfExclusionOfDeposit memory proof = extractProofOfExclusionOfDeposit(proofBytes);\r\n    return proof.successor.index == proof.predecessor.index + 1 && // predecessor & successor must be consecutive\r\n    proof.successor.leaf > record.hash &&\r\n    proof.predecessor.leaf < record.hash &&\r\n    verifyIncludedAtIndex(proof.predecessor.proof, root, proof.predecessor.leaf, proof.predecessor.index) &&\r\n    verifyIncludedAtIndex(proof.successor.proof, root, proof.successor.leaf, proof.successor.index);\r\n  }\r\n\r\n  function reclaimDepositOnHalt(address account, bytes memory parameters) private whenOff returns (address asset, uint quantity) {\r\n    (, bytes memory commitmentRecord, bytes memory proofBytes1, bytes memory proofBytes2) = abi.decode(parameters, (uint, bytes, bytes, bytes));\r\n    DepositCommitmentRecord memory record = parseAndValidateDepositCommitmentRecord(account, commitmentRecord);\r\n    if (currentGblockNumber() > record.designatedGblock) {\r\n      require(proveIsExcludedFromDeposits(record, data.depositsRoot(record.designatedGblock), proofBytes1), \"failed to proof exclusion of deposit\");\r\n    }\r\n    if (currentGblockNumber() > record.designatedGblock + 1) {\r\n      require(proveIsExcludedFromDeposits(record, data.depositsRoot(record.designatedGblock + 1), proofBytes2), \"failed to proof exclusion of deposit\");\r\n    }\r\n    return reclaimDeposit_(record);\r\n  }\r\n\r\n  function encodedDepositOnHaltParameters(address account, address asset, uint quantity, uint32 nonce, uint32 designatedGblock) external view returns (bytes memory) {\r\n    bytes memory encodedPackedDeposit = encodePackedDeposit(id, account, asset, quantity, nonce, designatedGblock);\r\n    return abi.encode(RECLAIM_DEPOSIT_ON_HALT, encodedPackedDeposit);\r\n  }\r\n\r\n  function reclaimDeposit_(DepositCommitmentRecord memory record) private returns (address asset, uint quantity) {\r\n    data.deleteDeposit(record.hash);\r\n    emit DepositReclaimed(record.account, record.asset, record.quantity, record.nonce);\r\n    return (record.asset, record.quantity);\r\n  }\r\n\r\n  function extractProofOfExclusionOfDeposit(bytes memory proofBytes) private pure returns (ProofOfExclusionOfDeposit memory result) {\r\n    (bytes32[] memory leaves, uint[] memory indexes, bytes memory predecessor, bytes memory successor) = abi.decode(proofBytes, (bytes32[], uint[], bytes, bytes));\r\n    result = ProofOfExclusionOfDeposit(ProofOfInclusionAtIndex(leaves[0], indexes[0], predecessor), ProofOfInclusionAtIndex(leaves[1], indexes[1], successor));\r\n  }\r\n\r\n  /**************************************************** Withdrawing ***************************************************/\r\n\r\n  function assistedWithdraw(address account, bytes memory parameters) private returns (address asset, uint quantity) {\r\n    (, bytes memory entryBytes, bytes memory signature, bytes memory proof) = abi.decode(parameters, (uint, bytes, bytes, bytes));\r\n    Entry memory entry = parseAndValidateEntry(entryBytes, signature, account);\r\n    require(entry.entryType == EntryType.Withdrawal, \"entry must be of type Withdrawal\");\r\n    require(proveInConfirmedWithdrawals(proof, entry.gblockNumber, entry.hash), \"invalid entry proof\");\r\n    require(!data.hasWithdrawn(entry.hash), \"entry already withdrawn\");\r\n    data.markWithdrawn(entry.hash);\r\n    emit Withdrawn(entry.hash, entry.account, entry.asset, entry.quantity);\r\n    return (entry.asset, entry.quantity);\r\n  }\r\n\r\n  function claimExit(address account, bytes memory parameters) private whenOn returns (address asset, uint quantity) {\r\n    (, asset) = abi.decode(parameters, (uint, address));\r\n    require(!hasExited(account, asset), \"previously exited\");\r\n    bytes32 hash = keccak256(abi.encodePacked(account, asset));\r\n    require(data.exitClaims(hash) == 0, \"previously claimed exit\");\r\n    require(exitCounts < MAX_EXIT_COUNT, \"exit claim exceeds maximum allowed\");\r\n    exitCounts = exitCounts + 1;\r\n    uint confirmationThreshold = currentGblockNumber() + confirmationDelay;\r\n    data.markExitClaim(hash, confirmationThreshold);\r\n    emit ExitClaimed(hash, account, asset, confirmationThreshold);\r\n    return (asset, 0);\r\n  }\r\n\r\n  function exit(address account, bytes memory parameters) private whenOn returns (address asset, uint quantity) {\r\n    (, bytes memory entry_, bytes memory signature, bytes memory proof, uint32 gblockNumber) = abi.decode(parameters, (uint, bytes, bytes, bytes, uint32));\r\n    Entry memory entry = parseAndValidateEntry(entry_, signature, account);\r\n    require(!hasExited(entry.account, entry.asset), \"previously exited\");\r\n    bytes32 hash = keccak256(abi.encodePacked(entry.account, entry.asset));\r\n    require(canExit(hash, gblockNumber), \"no prior claim found to withdraw OR balances are yet to be confirmed\");\r\n    require(verifyIncluded(proof, data.balancesRoot(gblockNumber), entry.hash), \"invalid balance proof\");\r\n    data.deleteExitClaim(hash);\r\n    data.markExited(entry.account, entry.asset);\r\n    emit Exited(entry.account, entry.asset, entry.balance);\r\n    return (entry.asset, entry.balance);\r\n  }\r\n\r\n  function exitOnHalt(address account, bytes memory parameters) private whenOff returns (address asset, uint quantity) {\r\n    (, bytes memory entry_, bytes memory signature, bytes memory proof) = abi.decode(parameters, (uint, bytes, bytes, bytes));\r\n    Entry memory entry = parseAndValidateEntry(entry_, signature, account);\r\n    require(!hasExited(entry.account, entry.asset), \"previously exited\");\r\n    require(proveInConfirmedBalances(proof, entry.hash), \"invalid balance proof\");\r\n    data.markExited(entry.account, entry.asset);\r\n    emit Exited(entry.account, entry.asset, entry.balance);\r\n    return (entry.asset, entry.balance);\r\n  }\r\n\r\n  /// @notice has the account/asset pair already claimed and exited?\r\n  ///\r\n  /// @param account the account in question\r\n  /// @param asset the asset in question\r\n  function hasExited(address account, address asset) public view returns (bool) {return data.hasExited(account, asset);}\r\n\r\n  /// @notice can the entry represented by hash be used to exit?\r\n  ///\r\n  /// @param hash the hash of the entry to be used to exit?\r\n  /// (account/asset pair is implicitly represented within hash)\r\n  function canExit(bytes32 hash, uint32 gblock) public view returns (bool) {\r\n    uint confirmationThreshold = data.exitClaims(hash);\r\n    uint unconfirmedGblock = currentGblockNumber();\r\n    return confirmationThreshold != 0 &&\r\n      unconfirmedGblock > confirmationThreshold &&\r\n      gblock >= confirmationThreshold &&\r\n      gblock < unconfirmedGblock;\r\n  }\r\n\r\n  /**************************************************** FraudProof ****************************************************/\r\n\r\n  /// @notice can we submit a new gblock?\r\n  function canSubmit() public view returns (bool) {return block.number > data.submissionBlock();}\r\n\r\n  /// @notice submit a new gblock\r\n  ///\r\n  /// @param gblockNumber index of new gblockNumber\r\n  /// @param withdrawalsRoot the gblock's withdrawals root\r\n  /// @param depositsRoot the gblock's deposits root\r\n  /// @param balancesRoot the gblock's balances root\r\n  function submit(uint32 gblockNumber, bytes32 withdrawalsRoot, bytes32 depositsRoot, bytes32 balancesRoot) public whenOn {\r\n    require(canSubmit(), \"cannot submit yet\");\r\n    exitCounts = 0;\r\n    require(msg.sender == operator, \"submitter must be the operator\");\r\n    require(gblockNumber == currentGblockNumber() + 1, \"gblock must be the next in sequence\");\r\n    data.submit(gblockNumber, withdrawalsRoot, depositsRoot, balancesRoot, submissionInterval);\r\n    emit Submitted(gblockNumber, withdrawalsRoot, depositsRoot, balancesRoot);\r\n  }\r\n\r\n  /// @notice prove a withdrawal entry is included in a confirmed withdrawals root\r\n  ///\r\n  /// @param proof proof-of-inclusion for entryHash\r\n  /// @param gblockNumber index of including gblock\r\n  /// @param entryHash hash of entry asserted to be included\r\n  function proveInConfirmedWithdrawals(bytes memory proof, uint32 gblockNumber, bytes32 entryHash) public view returns (bool) {\r\n    return data.isConfirmedGblock(gblockNumber) && verifyIncluded(proof, data.withdrawalsRoot(gblockNumber), entryHash);\r\n  }\r\n\r\n  /// @notice prove an entry is included in the latest confirmed balances root\r\n  ///\r\n  /// @param proof proof-of-inclusion for entryHash\r\n  /// @param entryHash hash of entry asserted to be included\r\n  function proveInConfirmedBalances(bytes memory proof, bytes32 entryHash) public view returns (bool) {\r\n    uint32 gblockNumber = currentGblockNumber() - 1;\r\n    return verifyIncluded(proof, data.balancesRoot(gblockNumber), entryHash);\r\n  }\r\n\r\n  function parseAndValidateEntry(bytes memory entryBytes, bytes memory signature, address account) private view returns (Entry memory entry) {\r\n    entry = parseEntry(entryBytes, signature);\r\n    require(entry.ledgerId == id, \"entry is not from current ledger\");\r\n    require(entry.signer == operator, \"failed to verify signature\");\r\n    require(entry.account == account, \"entry account mismatch\");\r\n  }\r\n\r\n  /****************************************************** halting ******************************************************/\r\n\r\n  /// @notice if the operator stops creating blocks for a very long time, the app is said to be abandoned\r\n  function hasBeenAbandoned() public view returns (bool) {\r\n    return block.number > data.submissionBlock() + abandonPoint;\r\n  }\r\n\r\n  /// @notice if the app is abandoned, anyone can halt the app, thus allowing everyone to transfer funds back to the main chain.\r\n  function abandon() external {\r\n    require(hasBeenAbandoned(), \"chain has not yet abandoned\");\r\n    switchOff_();\r\n  }\r\n\r\n  function switchOff() external onlyOwner {\r\n    switchOff_();\r\n  }\r\n\r\n  /********************************************************************************************************************/\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"id_\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"gluon_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"data_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"submissionInterval_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"abandonPoint_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"extensions_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"}],\"name\":\"DepositReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"designatedGblock\",\"type\":\"uint32\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"confirmationThreshold\",\"type\":\"uint256\"}],\"name\":\"ExitClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"Exited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"}],\"name\":\"ExtensionAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"}],\"name\":\"ExtensionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Off\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Retired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"gblockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"withdrawalsRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositsRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"balancesRoot\",\"type\":\"bytes32\"}],\"name\":\"Submitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"abandon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"abandonPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"}],\"name\":\"addExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"gblock\",\"type\":\"uint32\"}],\"name\":\"canExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canSubmit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"checkProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"checkProofOrdered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmationDelay\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"credit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentGblockNumber\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLogic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"data\",\"outputs\":[{\"internalType\":\"contract SpotData\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"debit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"ledgerId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"designatedGblock\",\"type\":\"uint32\"}],\"name\":\"encodePackedDeposit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"designatedGblock\",\"type\":\"uint32\"}],\"name\":\"encodedDepositOnHaltParameters\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitCounts\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"extensions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExtensions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gluon\",\"outputs\":[{\"internalType\":\"contract Gluon\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasBeenAbandoned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"hasExited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExtension\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"entryHash\",\"type\":\"bytes32\"}],\"name\":\"proveInConfirmedBalances\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"gblockNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"entryHash\",\"type\":\"bytes32\"}],\"name\":\"proveInConfirmedWithdrawals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"upgradeOperator_\",\"type\":\"address\"}],\"name\":\"setUpgradeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum AppState.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"submissionInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"gblockNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"withdrawalsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"depositsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"balancesRoot\",\"type\":\"bytes32\"}],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"switchOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"verifyIncluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"verifyIncludedAtIndex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"visibilityDelay\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SpotLogic","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000200000000000000000000000075ace7a086ea0fb1a79e43cc6331ad053d8c67cb0000000000000000000000000d283d685f0a741c463846176e4c8eff90d3f9ec0000000000000000000000005ccaaae7bea14e8e04fb0fc7ed16df49d5678eb800000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000009d8000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000da88efa53c85afa30564bb651a2e76b99a232082","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8805d3c7f039d46621501d41e9441809102bdc605da19570aa0325198a8ee9cf"}]}