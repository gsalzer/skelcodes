{"status":"1","message":"OK","result":[{"SourceCode":"{\"AbqErc20.sol\":{\"content\":\"// SPDX-Lincense-identifier:MIT\\npragma solidity ^0.7.0;\\nimport \\\"./SafeMathTyped.sol\\\";\\n\\n// The MIT License\\n//\\n// Copyright (c) 2017-2018 0xcert, d.o.o. https://0xcert.org\\n// \\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n// \\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n/**\\n * @title ERC20 standard token implementation.\\n * @dev Standard ERC20 token. This contract follows the implementation at https://goo.gl/mLbAPJ.\\n */\\ncontract Token\\n{\\n  string internal tokenName;\\n\\n  string internal tokenSymbol;\\n\\n  uint8 internal tokenDecimals;\\n\\n  uint256 internal tokenTotalSupply;\\n\\n  mapping (address =\\u003e uint256) internal balances;\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\n\\n  /**\\n   * @dev Trigger when tokens are transferred, including zero value transfers.\\n   */\\n  event Transfer(\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 _value\\n  );\\n\\n  /**\\n   * @dev Trigger on any successful call to approve(address _spender, uint256 _value).\\n   */\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _spender,\\n    uint256 _value\\n  );\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name()\\n    external\\n    view\\n    returns (string memory _name)\\n  {\\n    _name = tokenName;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol()\\n    external\\n    view\\n    returns (string memory _symbol)\\n  {\\n    _symbol = tokenSymbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals the token uses.\\n   */\\n  function decimals()\\n    external\\n    view\\n    returns (uint8 _decimals)\\n  {\\n    _decimals = tokenDecimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total token supply.\\n   */\\n  function totalSupply()\\n    external\\n    view\\n    returns (uint256 _totalSupply)\\n  {\\n    _totalSupply = tokenTotalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the account balance of another account with address _owner.\\n   * @param _owner The address from which the balance will be retrieved.\\n   */\\n  function balanceOf(\\n    address _owner\\n  )\\n    external\\n    view\\n    returns (uint256 _balance)\\n  {\\n    _balance = balances[_owner];\\n  }\\n\\n  /**\\n   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\\n   * @param _to The address of the recipient.\\n   * @param _value The amount of token to be transferred.\\n   */\\n  function transfer(\\n    address _to,\\n    uint256 _value\\n  )\\n    public\\n    returns (bool _success)\\n  {\\n    require(_value \\u003c= balances[msg.sender]);\\n\\n    balances[msg.sender] = SafeMathTyped.sub256(balances[msg.sender], _value);\\n    balances[_to] = SafeMathTyped.add256(balances[_to], _value);\\n\\n    emit Transfer(msg.sender, _to, _value);\\n    _success = true;\\n  }\\n\\n  /**\\n   * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. If\\n   * this function is called again it overwrites the current allowance with _value.\\n   * @param _spender The address of the account able to transfer the tokens.\\n   * @param _value The amount of tokens to be approved for transfer.\\n   */\\n  function approve(\\n    address _spender,\\n    uint256 _value\\n  )\\n    public\\n    returns (bool _success)\\n  {\\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\\n\\n    allowed[msg.sender][_spender] = _value;\\n\\n    emit Approval(msg.sender, _spender, _value);\\n    _success = true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\\n   * @param _owner The address of the account owning tokens.\\n   * @param _spender The address of the account able to transfer the tokens.\\n   */\\n  function allowance(\\n    address _owner,\\n    address _spender\\n  )\\n    external\\n    view\\n    returns (uint256 _remaining)\\n  {\\n    _remaining = allowed[_owner][_spender];\\n  }\\n\\n  /**\\n   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\\n   * Transfer event.\\n   * @param _from The address of the sender.\\n   * @param _to The address of the recipient.\\n   * @param _value The amount of token to be transferred.\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  )\\n    public\\n    returns (bool _success)\\n  {\\n    require(_value \\u003c= balances[_from]);\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n    balances[_from] = SafeMathTyped.sub256(balances[_from], _value);\\n    balances[_to] = SafeMathTyped.add256(balances[_to], _value);\\n    allowed[_from][msg.sender] = SafeMathTyped.sub256(allowed[_from][msg.sender], _value);\\n\\n    emit Transfer(_from, _to, _value);\\n    _success = true;\\n  }\\n\\n}\\n\\n/// @notice This is the ABQ token. It allows the owner (the Aardbanq DAO) to mint new tokens. It also allow the \\n/// owner to change owners. The ABQ token has 18 decimals.\\ncontract AbqErc20 is Token\\n{\\n    address public owner;\\n    constructor(address _owner, uint256 _abqAmount)\\n    {\\n        tokenName = \\\"Aardbanq DAO\\\";\\n        tokenSymbol = \\\"ABQ\\\";\\n        tokenDecimals = 18;\\n        tokenTotalSupply = _abqAmount;\\n        owner = _owner;\\n        balances[_owner] = _abqAmount;\\n        emit Transfer(address(0), _owner, _abqAmount);\\n    }\\n\\n    modifier onlyOwner()\\n    {\\n        require(msg.sender == owner, \\\"ABQ/only-owner\\\");\\n        _;\\n    }\\n\\n    /// @notice Allows the owner to change the ownership to another address.\\n    /// @param _newOwner The address that should be the new owner.\\n    function changeOwner(address _newOwner)\\n        external\\n        onlyOwner()\\n    {\\n        owner = _newOwner;\\n    }\\n\\n    /// @notice Allows the owner to mint tokens.\\n    /// @param _target The address to mint the tokens to.\\n    /// @param _abqAmount The amount of ABQ to mint.\\n    function mint(address _target, uint256 _abqAmount)\\n        external\\n        onlyOwner()\\n    {\\n        tokenTotalSupply = SafeMathTyped.add256(tokenTotalSupply, _abqAmount);\\n        balances[_target] = SafeMathTyped.add256(balances[_target], _abqAmount);\\n        emit Transfer(address(0), _target, _abqAmount);\\n    }\\n}\"},\"SafeMathTyped.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMathTyped {\\n    /**\\n    * @dev Multiplies two unsigned integers, reverts on overflow.\\n    */\\n    function mul256(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"uint256 overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n    */\\n    function div256(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"Can\\u0027t divide by 0\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"uint256 underflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two unsigned integers, reverts on overflow.\\n    */\\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"uint256 overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod256(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"Can\\u0027t mod by 0\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n    * @dev returns the greater of two numbers\\n    */\\n    function max256(uint256 a, uint256 b) internal pure returns (uint) {\\n        return a \\u003e b ? a : b;\\n    }\\n\\n    /**\\n    * @dev returns the lesser of two numbers\\n    */\\n    function min256(uint256 a, uint256 b) internal pure returns (uint) {\\n        return a \\u003c b ? a : b;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_abqAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_abqAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AbqErc20","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000829c094f5034099e91ab1d553828f8a765a3daa1000000000000000000000000000000000000000000084595161401484a000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://68560489cfcf9b594c7508fda0ad226c647b27517069b53a87a2c4ce7ba471aa"}]}