{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n  ____    __             __                                                                  __                   \r\n/\\  _`\\ /\\ \\__         /\\ \\      __                      /'\\_/`\\  __                       /\\ \\__                \r\n\\ \\,\\L\\_\\ \\ ,_\\    __  \\ \\ \\/'\\ /\\_\\    ___      __     /\\      \\/\\_\\     __   _ __    __  \\ \\ ,_\\   ___   _ __  \r\n \\/_\\__ \\\\ \\ \\/  /'__`\\ \\ \\ , < \\/\\ \\ /' _ `\\  /'_ `\\   \\ \\ \\__\\ \\/\\ \\  /'_ `\\/\\`'__\\/'__`\\ \\ \\ \\/  / __`\\/\\`'__\\\r\n   /\\ \\L\\ \\ \\ \\_/\\ \\L\\.\\_\\ \\ \\\\`\\\\ \\ \\/\\ \\/\\ \\/\\ \\L\\ \\   \\ \\ \\_/\\ \\ \\ \\/\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/\\ \\L\\ \\ \\ \\/ \r\n   \\ `\\____\\ \\__\\ \\__/.\\_\\\\ \\_\\ \\_\\ \\_\\ \\_\\ \\_\\ \\____ \\   \\ \\_\\\\ \\_\\ \\_\\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\__\\ \\____/\\ \\_\\ \r\n    \\/_____/\\/__/\\/__/\\/_/ \\/_/\\/_/\\/_/\\/_/\\/_/\\/___L\\ \\   \\/_/ \\/_/\\/_/\\/___L\\ \\/_/ \\/__/\\/_/ \\/__/\\/___/  \\/_/ \r\n                                                 /\\____/                  /\\____/                                \r\n                                                 \\_/__/                   \\_/__/                                  \r\n*/\r\npragma solidity 0.5.12;\r\n\r\ninterface IERC20{\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n}\r\n\r\ninterface IBPool{\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)external;\r\n    function getSwapFee()external view returns (uint);\r\n    function getCurrentTokens()external view returns (address[] memory tokens);\r\n    function getDenormalizedWeight(address token)external view returns (uint);\r\n    function setController(address manager)external;\r\n}\r\n\r\ninterface IMAction {\r\n    function create(address MFactory, address[] calldata tokens, uint[] calldata balances, uint[] calldata denorms,uint swapFee, uint initLpSupply, bool finalize) external returns (IBPool pool);\r\n}\r\n\r\ncontract Migrator {\r\n   \r\n    address public lpStaking;   /* staking address */\r\n    address public controller;  /* controller address */\r\n    address public MFactory;    /* factory address */\r\n    \r\n    uint256 public notBeforeBlock; /* blockLimted */\r\n    uint256 private UNI_SWAPFEE = 0.003 * 10 ** 18; /* uni swapFee 3/1000 */\r\n    uint256 private UNI_DENORM = 10 ** 18;  /* uni denorm 3/1000 */\r\n    bool private FINALIZE = true;\r\n\r\n    IMAction public action;\r\n    mapping(address => bool) public isBpool;\r\n\r\n    constructor(\r\n        address _lpStaking,\r\n        address _controller,\r\n        address _MFactory,\r\n        IMAction  _action,\r\n        uint256 _notBeforeBlock\r\n    ) public {\r\n        lpStaking = _lpStaking;\r\n        controller = _controller;\r\n        MFactory = _MFactory;\r\n        notBeforeBlock = _notBeforeBlock;\r\n        action = _action;\r\n    }\r\n\r\n    function migrate(IERC20 lp) public returns (IERC20 pool){\r\n   \r\n        require(msg.sender == lpStaking, \"not from lpStaking\");/* only staking call */\r\n        require(block.number >= notBeforeBlock, \"too early to migrate\");\r\n        require(lp.balanceOf(msg.sender) > 0,\"have no balance for migrate\");\r\n        \r\n        address lpAddress = address(lp);\r\n\r\n        if(!isBpool[lpAddress]){\r\n           \r\n           uint256 swapFee = UNI_SWAPFEE;\r\n           (address[] memory tokens, uint[] memory balances, uint[] memory denorms,uint initLpSupply) = _migrateUniLp(lpAddress); \r\n\r\n            IBPool bPool = action.create(MFactory, tokens, balances, denorms, swapFee, initLpSupply,FINALIZE);\r\n\r\n            bPool.setController(controller);\r\n\r\n            pool = IERC20(address(bPool));\r\n        \r\n            require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n\r\n        }else{    \r\n            uint256 swapFee = IBPool(lpAddress).getSwapFee();\r\n            \r\n           (address[] memory tokens, uint[] memory balances, uint[] memory denorms, uint initLpSupply) = _migrateBLp(lpAddress);\r\n           \r\n           IBPool bPool =  action.create(MFactory, tokens, balances, denorms, swapFee, initLpSupply,FINALIZE);\r\n\r\n           bPool.setController(controller);\r\n\r\n           pool = IERC20(address(bPool)); \r\n\r\n           require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n        }\r\n\r\n    }\r\n    \r\n    function _migrateUniLp(address _uniLpAddress) internal returns(address[] memory,uint256[] memory,uint256[] memory, uint256) {\r\n        IUniswapV2Pair uniLp = IUniswapV2Pair(_uniLpAddress);\r\n    \r\n        address[] memory tokens = new address[](2);/* uniswap tokens length is  2 */\r\n        uint256[] memory balances = new uint256[](2);\r\n        uint256[] memory denorms = new uint256[](2);\r\n\r\n        tokens[0] = uniLp.token0();\r\n        tokens[1] = uniLp.token1();\r\n\r\n        uint256 lpAmount = uniLp.balanceOf(msg.sender);\r\n        uniLp.transferFrom(msg.sender, address(uniLp), lpAmount);\r\n        uniLp.burn(address(this));\r\n\r\n        for(uint256 i = 0; i < tokens.length; i++){\r\n             uint256 value = IERC20(tokens[i]).balanceOf(address(this)); \r\n             IERC20(tokens[i]).approve(address(action),value);\r\n             balances[i] = value;\r\n             denorms[i] = UNI_DENORM;      \r\n        }\r\n        \r\n        return(tokens,balances,denorms,lpAmount); \r\n    }\r\n\r\n    function _migrateBLp(address _bLpAddress) internal returns(address[] memory,uint256[] memory,uint256[] memory, uint256){\r\n        \r\n        IBPool bLp = IBPool(_bLpAddress);\r\n\r\n        address[] memory tokens = bLp.getCurrentTokens();\r\n\r\n        uint256 len = tokens.length;\r\n\r\n        uint256[] memory balances = new uint256[](len);\r\n\r\n        uint256[] memory denorms = new uint256[](len);\r\n        \r\n        uint256[] memory minAmountOut = new uint256[](len);\r\n\r\n        uint256 lpAmount = bLp.balanceOf(msg.sender);\r\n\r\n        bLp.transferFrom(msg.sender,address(this),lpAmount);\r\n        \r\n        bLp.exitPool(lpAmount,minAmountOut);\r\n\r\n        for(uint256 i = 0; i < len; i++){\r\n             uint256 value = IERC20(tokens[i]).balanceOf(address(this));\r\n            \r\n             IERC20(tokens[i]).approve(address(action),value);/* token approve address(this) => address(action) value*/\r\n             balances[i] = value;\r\n             denorms[i] =  bLp.getDenormalizedWeight(tokens[i]);      \r\n        }\r\n\r\n        return(tokens,balances,denorms,lpAmount);      \r\n    }\r\n\r\n    function setBPool(address bLp, bool isBLp) public {\r\n        require(msg.sender == controller,\"not controller call\");\r\n        isBpool[bLp] = isBLp;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_MFactory\",\"type\":\"address\"},{\"internalType\":\"contract IMAction\",\"name\":\"_action\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_notBeforeBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"MFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"action\",\"outputs\":[{\"internalType\":\"contract IMAction\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBpool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lpStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"pool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"notBeforeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"bLp\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBLp\",\"type\":\"bool\"}],\"name\":\"setBPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Migrator","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000beac580727ae61f08fd1ef75115a0c73f301e93b0000000000000000000000004cdce4077626ca9bbba21d094ea31c1dac8d78f6000000000000000000000000f2ed5a6b412227c5e71fc6900f2cc774a18563c9000000000000000000000000e7faadebf9c7b723fb48fb29e31e87581145d9130000000000000000000000000000000000000000000000000000000000ab88ea","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://69565fd3fdc03bf18810608d8f1227118c93938b98c0afbd66ebffd87fc02d2b"}]}