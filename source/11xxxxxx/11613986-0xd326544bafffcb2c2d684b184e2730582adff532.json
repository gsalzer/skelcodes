{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\ncontract NFTRegistryLike {\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n    function data(uint tokenID) public view returns (address, uint, bytes32, uint64);\r\n}\r\n\r\ncontract NFTUpdateLike {\r\n    function update(bytes32 nftID, uint value, uint risk) public;\r\n    function file(bytes32 name, bytes32 nftID, uint maturityDate) public;\r\n}\r\n\r\ncontract NFTOracle {\r\n    bytes32 public fingerprint;\r\n\r\n    // mapping (owners => uint);\r\n    mapping (address => uint) public wards;\r\n\r\n    // mapping (token holders)\r\n    mapping (address => uint) public tokenHolders;\r\n\r\n    // mapping (nftID => loanData);\r\n    mapping (uint => NFTData) public nftData;\r\n\r\n    // nft registry that holds the metadata for each nft\r\n    NFTRegistryLike public registry;\r\n\r\n    // nft update that holds the value of NFT's risk and value\r\n    NFTUpdateLike public nftUpdate;\r\n\r\n    struct NFTData {\r\n        uint80 riskScore;\r\n        uint128 value;\r\n        uint64 maturityDate;\r\n        uint48 timestamp;\r\n    }\r\n\r\n    event NFTValueUpdated(uint indexed tokenID);\r\n\r\n    constructor (\r\n        address _nftUpdate,\r\n        address _registry,\r\n        bytes32 _fingerprint,\r\n        address _ward,\r\n        address[] memory _tokenHolders) public {\r\n\r\n        fingerprint = _fingerprint;\r\n        registry = NFTRegistryLike(_registry);\r\n        nftUpdate = NFTUpdateLike(_nftUpdate);\r\n\r\n        // update nft token holders\r\n        uint i;\r\n        for (i=0; i<_tokenHolders.length; i++) {\r\n            tokenHolders[_tokenHolders[i]] = 1;\r\n        }\r\n\r\n        // add the creator to auth\r\n        wards[_ward] = 1;\r\n        wards[msg.sender] = 1;\r\n    }\r\n\r\n    function rely(address usr) public auth { wards[usr] = 1; }\r\n    function deny(address usr) public auth { wards[usr] = 0; }\r\n    function relyTokenHolder(address usr) public auth { tokenHolders[usr] = 1; }\r\n    function denyTokenHolder(address usr) public auth { tokenHolders[usr] = 0; }\r\n    modifier auth { require(wards[msg.sender] == 1); _; }\r\n    modifier authToken(uint token) {\r\n        require(tokenHolders[registry.ownerOf(token)] == 1, \"oracle/token owner not allowed\");\r\n        _;\r\n    }\r\n\r\n    function depend(address _nftUpdate) public auth {\r\n        nftUpdate = NFTUpdateLike(_nftUpdate);\r\n    }\r\n\r\n    function update(uint tokenID, bytes32 _fingerprint, bytes32 _result) public authToken(tokenID) {\r\n        require(fingerprint == _fingerprint, \"oracle/fingerprint mismatch\");\r\n        (uint80 risk, uint128 value) = getRiskAndValue(_result);\r\n        (, , , uint64 maturityDate) = registry.data(tokenID);\r\n        nftData[tokenID] = NFTData(risk, value, maturityDate, uint48(block.timestamp));\r\n\r\n        // pass value to NFT update\r\n        bytes32 nftID = keccak256(abi.encodePacked(address(registry), tokenID));\r\n        nftUpdate.update(nftID, uint(value), uint(risk));\r\n        nftUpdate.file(\"maturityDate\",nftID,uint(maturityDate));\r\n        emit NFTValueUpdated(tokenID);\r\n    }\r\n\r\n    function getRiskAndValue(bytes32 _result) public pure returns (uint80, uint128) {\r\n        bytes memory riskb = sliceFromBytes32(_result, 0, 16);\r\n        bytes memory valueb = sliceFromBytes32(_result, 16, 32);\r\n        return (uint80(toUint128(riskb)), toUint128(valueb));\r\n    }\r\n\r\n    function sliceFromBytes32(bytes32 data, uint start, uint end) internal pure returns (bytes memory) {\r\n        bytes memory res = new bytes(end -start);\r\n        for (uint i=0; i< end -start; i++){\r\n            res[i] = data[i+start];\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes) internal pure returns (uint128) {\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), 0))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"relyTokenHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftUpdate\",\"type\":\"address\"}],\"name\":\"depend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fingerprint\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_result\",\"type\":\"bytes32\"}],\"name\":\"getRiskAndValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint80\"},{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nftUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftData\",\"outputs\":[{\"name\":\"riskScore\",\"type\":\"uint80\"},{\"name\":\"value\",\"type\":\"uint128\"},{\"name\":\"maturityDate\",\"type\":\"uint64\"},{\"name\":\"timestamp\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"denyTokenHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenID\",\"type\":\"uint256\"},{\"name\":\"_fingerprint\",\"type\":\"bytes32\"},{\"name\":\"_result\",\"type\":\"bytes32\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_nftUpdate\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_fingerprint\",\"type\":\"bytes32\"},{\"name\":\"_ward\",\"type\":\"address\"},{\"name\":\"_tokenHolders\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"NFTValueUpdated\",\"type\":\"event\"}]","ContractName":"NFTOracle","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a78c17921e7e060c246ac9575b01ff0fb29bceae77dbe23f77846a63b209fe2db9cd2c61e559f327ad326723baa6137d9c657e0a000000000000000000000000f3bcea7494d8f3ac21585ca4b0e52aa175c24c2500000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d0d9c8b56498fe4c9a35770b358fa100168f70bb0be0645ff4727e6379184cd7"}]}