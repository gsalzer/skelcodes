{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NestMiningV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./libminingv1/MiningV1Data.sol\\\";\\nimport \\\"./libminingv1/MiningV1Calc.sol\\\";\\nimport \\\"./libminingv1/MiningV1Op.sol\\\";\\n\\nimport \\\"./lib/SafeMath.sol\\\";\\nimport \\\"./lib/SafeERC20.sol\\\";\\nimport './lib/TransferHelper.sol';\\nimport \\\"./lib/ABDKMath64x64.sol\\\";\\n\\nimport \\\"./iface/INestPool.sol\\\";\\nimport \\\"./iface/INestStaking.sol\\\";\\nimport \\\"./iface/INTokenLegacy.sol\\\";\\nimport \\\"./iface/INestMining.sol\\\";\\nimport \\\"./iface/INestDAO.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\n/// @title  NestMiningV1\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author Paradox  - <paradox@nestprotocol.org>\\ncontract NestMiningV1 {\\n\\n    using SafeMath for uint256;\\n\\n    using MiningV1Calc for MiningV1Data.State;\\n    using MiningV1Op for MiningV1Data.State;\\n\\n    /* ========== STATE VARIABLES ============== */\\n\\n    uint8       public  flag;  // 0:  | 1:  | 2:  | 3:\\n    uint64      public  version; \\n    uint8       private _entrant_state; \\n    uint176     private _reserved;\\n\\n    MiningV1Data.State state;\\n    \\n    // NOTE: _NOT_ENTERED is set to ZERO such that it needn't constructor\\n    uint8 private constant _NOT_ENTERED = 0;\\n    uint8 private constant _ENTERED = 1;\\n\\n    uint8 constant MINING_FLAG_UNINITIALIZED    = 0;\\n    uint8 constant MINING_FLAG_SETUP_NEEDED     = 1;\\n    uint8 constant MINING_FLAG_UPGRADE_NEEDED   = 2;\\n    uint8 constant MINING_FLAG_ACTIVE           = 3;\\n\\n    /* ========== ADDRESSES ============== */\\n\\n    address public  governance;\\n    address private C_NestPool;\\n\\n    /* ========== STRUCTURES ============== */\\n\\n    struct Params {\\n        uint8    miningEthUnit;     \\n        uint32   nestStakedNum1k;   \\n        uint8    biteFeeRate;     \\n        uint8    miningFeeRate;     \\n        uint8    priceDurationBlock; \\n        uint8    maxBiteNestedLevel; \\n        uint8    biteInflateFactor;\\n        uint8    biteNestInflateFactor;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor() public { }\\n\\n    function initialize(address NestPool) external \\n    {\\n        // check flag\\n        require(flag == MINING_FLAG_UNINITIALIZED, \\\"Nest:Mine:!flag\\\");\\n\\n        uint256 amount = MiningV1Data.MINING_NEST_YIELD_PER_BLOCK_BASE;\\n        for (uint i =0; i < 10; i++) {\\n            state._mining_nest_yield_per_block_amount[i] = amount;\\n            amount = amount.mul(MiningV1Data.MINING_NEST_YIELD_CUTBACK_RATE).div(100);\\n        }\\n\\n        amount = MiningV1Data.MINING_NTOKEN_YIELD_PER_BLOCK_BASE;\\n        for (uint i =0; i < 10; i++) {\\n            state._mining_ntoken_yield_per_block_amount[i] = amount;\\n            amount = amount.mul(MiningV1Data.MINING_NTOKEN_YIELD_CUTBACK_RATE).div(100);\\n        }\\n        \\n        // set a temporary governance\\n        governance = msg.sender;\\n\\n        // increase version number\\n        version = uint64(block.number);\\n\\n        // set the address of NestPool \\n        C_NestPool = NestPool;\\n\\n        // set flag\\n        flag = MINING_FLAG_SETUP_NEEDED;\\n    }\\n\\n    /// @dev This function can only be called once immediately right after deployment\\n    function setup(\\n            uint32   genesisBlockNumber, \\n            uint128  latestMiningHeight,\\n            uint128  minedNestTotalAmount,\\n            Params calldata initParams\\n        ) external onlyGovernance\\n    {\\n        // check flag\\n        require(flag == MINING_FLAG_SETUP_NEEDED, \\\"Nest:Mine:!flag\\\");\\n        \\n        // set system-wide parameters\\n        state.miningEthUnit = initParams.miningEthUnit;\\n        state.nestStakedNum1k = initParams.nestStakedNum1k;\\n        state.biteFeeRate = initParams.biteFeeRate;    // 0.1%\\n        state.miningFeeRate = initParams.miningFeeRate;  // 0.1% on testnet\\n        state.priceDurationBlock = initParams.priceDurationBlock;  // 5 on testnet\\n        state.maxBiteNestedLevel = initParams.maxBiteNestedLevel;  \\n        state.biteInflateFactor = initParams.biteInflateFactor;   // 1 on testnet\\n        state.biteNestInflateFactor = initParams.biteNestInflateFactor; // 1 on testnet\\n        state.latestMiningHeight = latestMiningHeight;\\n        state.minedNestAmount = minedNestTotalAmount;\\n        \\n        // genesisBlock = 6236588 on mainnet\\n        state.genesisBlock = genesisBlockNumber;\\n\\n        // increase version number\\n        version = uint64(block.number);\\n        \\n        // set flag\\n        flag = MINING_FLAG_UPGRADE_NEEDED;\\n    }\\n\\n    /// @dev The function will be kicking off Nest Protocol v3.5.\\n    ///    After upgrading, `post/post2()` are ready to be invoked.\\n    ///    Before that, `post2Only4Upgrade()` is used to do posting.\\n    ///    The purpose is to limit post2Only4Upgrade() to run \\n    function upgrade() external onlyGovernance\\n    {\\n        require(flag == MINING_FLAG_UPGRADE_NEEDED, \\\"Nest:Mine:!flag\\\");\\n\\n        flag = MINING_FLAG_ACTIVE;\\n    }\\n\\n    /// @notice Write the block number as a version number\\n    /// @dev It shall be invoked *manually* whenever the contract is upgraded(behind proxy)\\n    function incVersion() external onlyGovernance\\n    {\\n        version = uint64(block.number);\\n    }\\n\\n    receive() external payable { }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    function _onlyGovernance() private view \\n    {\\n        require(msg.sender == governance, \\\"Nest:Mine:!GOV\\\");\\n    }\\n\\n    modifier onlyGovernance() \\n    {\\n        _onlyGovernance();\\n        _;\\n    }\\n\\n    function _noContract() private view {\\n        require(address(msg.sender) == address(tx.origin), \\\"Nest:Mine:contract!\\\");\\n    }\\n\\n    modifier noContract() \\n    {\\n        _noContract();\\n        _;\\n    }\\n\\n    modifier noContractExcept(address _contract) \\n    {\\n        require(address(msg.sender) == address(tx.origin) || address(msg.sender) == _contract, \\\"Nest:Mine:contract!\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovOrBy(address _contract) \\n    {\\n        require(msg.sender == governance || msg.sender == _contract, \\\"Nest:Mine:!sender\\\");\\n        _;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_entrant_state != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _entrant_state = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _entrant_state = _NOT_ENTERED;\\n    }\\n\\n    modifier onlyByNestOrNoContract()\\n    {\\n        require(address(msg.sender) == address(tx.origin)\\n            || msg.sender == state.C_NestDAO \\n            || msg.sender == state.C_NestStaking \\n            || msg.sender == state.C_NNRewardPool \\n            || msg.sender == state.C_NestQuery, \\\"Nest:Mine:!Auth\\\");\\n        _;\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    /// @dev Load real governance from NestPool, invalidate the temporary \\n    function loadGovernance() external\\n    {\\n        governance = INestPool(C_NestPool).governance();\\n    }\\n\\n    function loadContracts() external onlyGovOrBy(C_NestPool)\\n    {\\n        state.C_NestPool = C_NestPool;\\n        state.C_NestToken = INestPool(state.C_NestPool).addrOfNestToken();\\n        state.C_NestStaking = INestPool(state.C_NestPool).addrOfNestStaking();\\n        state.C_NestQuery = INestPool(state.C_NestPool).addrOfNestQuery();\\n        state.C_NNRewardPool = INestPool(state.C_NestPool).addrOfNNRewardPool();\\n        state.C_NestDAO = INestPool(state.C_NestPool).addrOfNestDAO();\\n    }\\n\\n    function setParams(Params calldata newParams) external \\n        onlyGovernance\\n    {\\n        state.miningEthUnit = newParams.miningEthUnit;\\n        state.nestStakedNum1k = newParams.nestStakedNum1k;\\n        state.biteFeeRate = newParams.biteFeeRate;\\n        state.miningFeeRate = newParams.miningFeeRate;\\n\\n        state.priceDurationBlock = newParams.priceDurationBlock;\\n        state.maxBiteNestedLevel = newParams.maxBiteNestedLevel;\\n        state.biteInflateFactor = newParams.biteInflateFactor;\\n        state.biteNestInflateFactor = newParams.biteNestInflateFactor;\\n\\n        emit MiningV1Data.SetParams(state.miningEthUnit, state.nestStakedNum1k, state.biteFeeRate,\\n                                    state.miningFeeRate, state.priceDurationBlock, state.maxBiteNestedLevel,\\n                                    state.biteInflateFactor, state.biteNestInflateFactor);\\n    }\\n\\n    /// @dev only be used when upgrading 3.0 to 3.5\\n    /// @dev when the upgrade is complete, this function is disabled\\n    function setParams1(\\n            uint128  latestMiningHeight,\\n            uint128  minedNestTotalAmount\\n        ) external onlyGovernance\\n    {\\n        require(flag == MINING_FLAG_UPGRADE_NEEDED, \\\"Nest:Mine:!flag\\\");\\n        state.latestMiningHeight = latestMiningHeight;\\n        state.minedNestAmount = minedNestTotalAmount;\\n    }\\n\\n    /* ========== HELPERS ========== */\\n\\n    function addrOfGovernance() view external\\n        returns (address) \\n    {   \\n        return governance;\\n    }\\n\\n    function parameters() view external \\n        returns (Params memory params)\\n    {\\n        params.miningEthUnit = state.miningEthUnit;\\n        params.nestStakedNum1k = state.nestStakedNum1k;\\n        params.biteFeeRate = state.biteFeeRate;\\n        params.miningFeeRate = state.miningFeeRate;\\n        params.priceDurationBlock = state.priceDurationBlock;\\n        params.maxBiteNestedLevel = state.maxBiteNestedLevel;\\n        params.biteInflateFactor = state.biteInflateFactor;\\n        params.biteNestInflateFactor = state.biteNestInflateFactor;\\n    }\\n\\n    /* ========== POST/CLOSE Price Sheets ========== */\\n\\n    /// @notice Post a price sheet for TOKEN\\n    /// @dev  It is for TOKEN (except USDT and NTOKENs) whose NTOKEN has a total supply below a threshold (e.g. 5,000,000 * 1e18)\\n    /// @param token The address of TOKEN contract\\n    /// @param ethNum The numbers of ethers to post sheets\\n    /// @param tokenAmountPerEth The price of TOKEN\\n    function post(\\n            address token, \\n            uint256 ethNum, \\n            uint256 tokenAmountPerEth\\n        )\\n        external \\n        payable \\n        noContract\\n    {\\n        // check parameters\\n        require(ethNum == state.miningEthUnit, \\\"Nest:Mine:!(ethNum)\\\");\\n        require(tokenAmountPerEth > 0, \\\"Nest:Mine:!(price)\\\");\\n\\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n        address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n        require(_ntoken != address(0) &&  _ntoken != address(state.C_NestToken) && token != _ntoken, \\\"Nest:Mine:!(ntoken)\\\");\\n\\n        // check if the totalsupply of ntoken is less than MINING_NTOKEN_NON_DUAL_POST_THRESHOLD, otherwise use post2()\\n        require(INToken(_ntoken).totalSupply() < MiningV1Data.MINING_NTOKEN_NON_DUAL_POST_THRESHOLD, \\\"Nest:Mine:!ntoken\\\");\\n\\n        // calculate eth fee\\n        // NOTE: fee = ethAmount * (feeRate * 1/10k)\\n        uint256 _ethFee = ethNum.mul(state.miningFeeRate).mul(1e18).div(10_000);\\n\\n        { // settle ethers and tokens\\n\\n            // save the changes into miner's virtual account\\n            if (msg.value.sub(_ethFee) > 0) {\\n                _C_NestPool.depositEth{value:msg.value.sub(_ethFee)}(address(msg.sender));\\n            }\\n\\n            // load addresses\\n            INestStaking _C_NestStaking = INestStaking(state.C_NestStaking);\\n            INestDAO _C_NestDAO = INestDAO(state.C_NestDAO);\\n\\n            // 60% fee => NestStaking\\n            _C_NestStaking.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_DIVIDEND_RATE).div(100)}(_ntoken);       \\n            // 20% fee => NestDAO[NTOKEN]\\n            _C_NestDAO.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_DAO_RATE).div(100)}(_ntoken);       \\n            // 20% fee => NestDAO[NEST]\\n            _C_NestDAO.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_NEST_DAO_RATE).div(100)}(address(state.C_NestToken));  \\n\\n            // freeze eths and tokens inside NestPool\\n            _C_NestPool.freezeEthAndToken(msg.sender, ethNum.mul(1 ether), \\n                token, tokenAmountPerEth.mul(ethNum));\\n            _C_NestPool.freezeNest(msg.sender, uint256(state.nestStakedNum1k).mul(1000 * 1e18));\\n        }\\n\\n        {\\n            MiningV1Data.PriceSheet[] storage _sheetToken = state.priceSheetList[token];\\n            // append a new price sheet\\n            _sheetToken.push(MiningV1Data.PriceSheet(\\n                uint160(msg.sender),            // miner \\n                uint32(block.number),           // atHeight\\n                uint32(ethNum),                 // ethNum\\n                uint32(ethNum),                 // remainNum\\n                uint8(0),                       // level\\n                uint8(MiningV1Data.PRICESHEET_TYPE_TOKEN),   // typ\\n                uint8(MiningV1Data.PRICESHEET_STATE_POSTED), // state \\n                uint8(0),                       // _reserved\\n                uint32(ethNum),                 // ethNumBal\\n                uint32(ethNum),                 // tokenNumBal\\n                uint32(state.nestStakedNum1k),    // nestNum1k\\n                uint128(tokenAmountPerEth)      // tokenAmountPerEth\\n            ));\\n            emit MiningV1Data.PricePosted(msg.sender, token, (_sheetToken.length - 1), ethNum.mul(1 ether), tokenAmountPerEth.mul(ethNum)); \\n\\n        }\\n\\n        { // mining; NTOKEN branch only\\n            // load mining record from `minedAtHeight`\\n            uint256 _minedH = state.minedAtHeight[token][block.number];\\n            // decode `_ntokenH` & `_ethH`\\n            uint256 _ntokenH = uint256(_minedH >> 128);\\n            uint256 _ethH = uint256(_minedH % (1 << 128));\\n            if (_ntokenH == 0) {  // the sheet is the first in the block\\n                // calculate the amount the NTOKEN to be mined\\n                uint256 _ntokenAmount = mineNToken(_ntoken);  \\n                // load `Bidder` from NTOKEN contract\\n                address _bidder = INToken(_ntoken).checkBidder();\\n                if (_bidder == state.C_NestPool) { // for new NTokens, 100% to miners\\n                    _ntokenH = _ntokenAmount;\\n                    INToken(_ntoken).mint(_ntokenAmount, address(state.C_NestPool));\\n                } else { // for old NTokens, 95% to miners, 5% to the bidder\\n                    _ntokenH = _ntokenAmount.mul(MiningV1Data.MINING_LEGACY_NTOKEN_MINER_REWARD_PERCENTAGE).div(100);\\n                    INTokenLegacy(_ntoken).increaseTotal(_ntokenAmount);\\n                    INTokenLegacy(_ntoken).transfer(state.C_NestPool, _ntokenAmount);\\n                    INestPool(state.C_NestPool).addNToken(_bidder, _ntoken, _ntokenAmount.sub(_ntokenH));\\n                }\\n            }\\n            \\n            // add up `_ethH`\\n            _ethH = _ethH.add(ethNum);\\n            // store `_ntokenH` & `_ethH` into `minedAtHeight`\\n            state.minedAtHeight[token][block.number] = (_ntokenH * (1<< 128) + _ethH);\\n        }\\n\\n        // calculate averge and volatility\\n        state._stat(token);\\n        return; \\n    }\\n\\n    /// @notice Post two price sheets for a token and its ntoken simultaneously \\n    /// @dev  Support dual-posts for TOKEN/NTOKEN, (ETH, TOKEN) + (ETH, NTOKEN)\\n    /// @param token The address of TOKEN contract\\n    /// @param ethNum The numbers of ethers to post sheets\\n    /// @param tokenAmountPerEth The price of TOKEN\\n    /// @param ntokenAmountPerEth The price of NTOKEN\\n    function post2(\\n            address token, \\n            uint256 ethNum, \\n            uint256 tokenAmountPerEth, \\n            uint256 ntokenAmountPerEth\\n        )\\n        external \\n        payable \\n        noContract\\n    {\\n        // check parameters \\n        require(ethNum == state.miningEthUnit, \\\"Nest:Mine:!(ethNum)\\\");\\n        require(tokenAmountPerEth > 0 && ntokenAmountPerEth > 0, \\\"Nest:Mine:!(price)\\\");\\n        address _ntoken = INestPool(state.C_NestPool).getNTokenFromToken(token);\\n\\n        require(_ntoken != token && _ntoken != address(0), \\\"Nest:Mine:!(ntoken)\\\");\\n\\n        // calculate eth fee\\n        uint256 _ethFee = ethNum.mul(state.miningFeeRate).mul(1e18).div(10_000);\\n\\n        { // settle ethers and tokens\\n            INestPool _C_NestPool = INestPool(state.C_NestPool);\\n\\n            // save the changes into miner's virtual account\\n            if (msg.value.sub(_ethFee) > 0) {\\n                _C_NestPool.depositEth{value:msg.value.sub(_ethFee)}(address(msg.sender));\\n            }\\n\\n            // load addresses\\n            INestStaking _C_NestStaking = INestStaking(state.C_NestStaking);\\n            INestDAO _C_NestDAO = INestDAO(state.C_NestDAO);\\n\\n            if (_ntoken == address(state.C_NestToken)) {\\n                // %80 => NestStaking\\n                _C_NestStaking.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NEST_FEE_DIVIDEND_RATE).div(100)}(_ntoken);       \\n                // %20 => NestDAO\\n                _C_NestDAO.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NEST_FEE_DAO_RATE).div(100)}(_ntoken);       \\n            } else {\\n                // 60% => NestStaking\\n                _C_NestStaking.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_DIVIDEND_RATE).div(100)}(_ntoken);       \\n                // 20% => NestDAO[NTOKEN]\\n                _C_NestDAO.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_DAO_RATE).div(100)}(_ntoken);       \\n                // 20% => NestDAO[NEST]\\n                _C_NestDAO.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_NEST_DAO_RATE).div(100)}(address(state.C_NestToken));  \\n            }\\n\\n            // freeze assets inside NestPool\\n            _C_NestPool.freezeEthAndToken(msg.sender, ethNum.mul(1 ether), \\n                token, tokenAmountPerEth.mul(ethNum));\\n            _C_NestPool.freezeEthAndToken(msg.sender, ethNum.mul(1 ether), \\n                _ntoken, ntokenAmountPerEth.mul(ethNum));\\n            _C_NestPool.freezeNest(msg.sender, uint256(state.nestStakedNum1k).mul(2).mul(1000 * 1e18));\\n        }\\n\\n        {\\n            uint8 typ1;\\n            uint8 typ2; \\n            if (_ntoken == address(state.C_NestToken)) {\\n                typ1 = MiningV1Data.PRICESHEET_TYPE_USD;\\n                typ2 = MiningV1Data.PRICESHEET_TYPE_NEST;\\n            } else {\\n                typ1 = MiningV1Data.PRICESHEET_TYPE_TOKEN;\\n                typ2 = MiningV1Data.PRICESHEET_TYPE_NTOKEN;\\n            }\\n            MiningV1Data.PriceSheet[] storage _sheetToken = state.priceSheetList[token];\\n            // append a new price sheet\\n            _sheetToken.push(MiningV1Data.PriceSheet(\\n                uint160(msg.sender),            // miner \\n                uint32(block.number),           // atHeight\\n                uint32(ethNum),                 // ethNum\\n                uint32(ethNum),                 // remainNum\\n                uint8(0),                       // level\\n                uint8(typ1),                    // typ\\n                uint8(MiningV1Data.PRICESHEET_STATE_POSTED), // state \\n                uint8(0),                       // _reserved\\n                uint32(ethNum),                 // ethNumBal\\n                uint32(ethNum),                 // tokenNumBal\\n                uint32(state.nestStakedNum1k),        // nestNum1k\\n                uint128(tokenAmountPerEth)      // tokenAmountPerEth\\n            ));\\n\\n            MiningV1Data.PriceSheet[] storage _sheetNToken = state.priceSheetList[_ntoken];\\n            // append a new price sheet for ntoken\\n            _sheetNToken.push(MiningV1Data.PriceSheet(\\n                uint160(msg.sender),            // miner \\n                uint32(block.number),           // atHeight\\n                uint32(ethNum),                 // ethNum\\n                uint32(ethNum),                 // remainNum\\n                uint8(0),                       // level\\n                uint8(typ2),                    // typ\\n                uint8(MiningV1Data.PRICESHEET_STATE_POSTED), // state \\n                uint8(0),                       // _reserved\\n                uint32(ethNum),                 // ethNumBal\\n                uint32(ethNum),                 // tokenNumBal\\n                uint32(state.nestStakedNum1k),  // nestNum1k\\n                uint128(ntokenAmountPerEth)     // tokenAmountPerEth\\n            ));\\n            emit MiningV1Data.PricePosted(msg.sender, token, (_sheetToken.length - 1), ethNum.mul(1 ether), tokenAmountPerEth.mul(ethNum)); \\n            emit MiningV1Data.PricePosted(msg.sender, _ntoken, (_sheetNToken.length - 1), ethNum.mul(1 ether), ntokenAmountPerEth.mul(ethNum)); \\n        }\\n\\n        { // mining; NEST branch & NTOKEN branch\\n            if (_ntoken == address(state.C_NestToken)) {\\n                // load mining records `minedAtHeight` in the same block \\n                uint256 _minedH = state.minedAtHeight[token][block.number];\\n                // decode `_nestH` and `_ethH` from `minedAtHeight`\\n                uint256 _nestH = uint256(_minedH >> 128);\\n                uint256 _ethH = uint256(_minedH % (1 << 128));\\n\\n                if (_nestH == 0) { // the sheet is the first in the block\\n\\n                    // calculate the amount of NEST to be mined\\n                    uint256 _nestAmount = mineNest(); \\n\\n                    // update `latestMiningHeight`, the lastest NEST-mining block \\n                    state.latestMiningHeight = uint32(block.number); \\n\\n                    // accumulate the amount of NEST\\n                    state.minedNestAmount += uint128(_nestAmount);\\n\\n                    // \\n                    _nestH = _nestAmount.mul(MiningV1Data.MINER_NEST_REWARD_PERCENTAGE).div(100); \\n\\n                    // 15% of NEST to NNRewardPool\\n                    INestPool(state.C_NestPool).addNest(state.C_NNRewardPool, _nestAmount.mul(MiningV1Data.NN_NEST_REWARD_PERCENTAGE).div(100));\\n                    INNRewardPool(state.C_NNRewardPool).addNNReward(_nestAmount.mul(MiningV1Data.NN_NEST_REWARD_PERCENTAGE).div(100));\\n\\n                    // 5% of NEST to NestDAO\\n                    INestPool(state.C_NestPool).addNest(state.C_NestDAO, _nestAmount.mul(MiningV1Data.DAO_NEST_REWARD_PERCENTAGE).div(100));\\n                    INestDAO(state.C_NestDAO).addNestReward(_nestAmount.mul(MiningV1Data.DAO_NEST_REWARD_PERCENTAGE).div(100));\\n                }\\n\\n                // add up `ethNum` into `minedAtHeight`\\n                _ethH = _ethH.add(ethNum);\\n                // encode `_nestH` and `_ethH` into `minedAtHeight`\\n                state.minedAtHeight[token][block.number] = (_nestH * (1<< 128) + _ethH);\\n            } else {\\n                // load mining records `minedAtHeight` in the same block \\n                uint256 _minedH = state.minedAtHeight[token][block.number];\\n                // decode `_ntokenH` and `_ethH` from `minedAtHeight`\\n                uint256 _ntokenH = uint256(_minedH >> 128);\\n                uint256 _ethH = uint256(_minedH % (1 << 128));\\n\\n                if (_ntokenH == 0) { // the sheet is the first in the block\\n\\n                    // calculate the amount of NEST to be mined\\n                    uint256 _ntokenAmount = mineNToken(_ntoken);\\n\\n                    // load `Bidder` from NTOKEN contract\\n                    address _bidder = INToken(_ntoken).checkBidder();\\n\\n                    if (_bidder == state.C_NestPool) { // for new NTokens, 100% to miners\\n                        \\n                        // save the amount of NTOKEN to be mined\\n                        _ntokenH = _ntokenAmount;\\n                        // mint NTOKEN(new, v3.5) to NestPool\\n                        INToken(_ntoken).mint(_ntokenAmount, address(state.C_NestPool));\\n\\n                    } else {                           // for old NTokens, 95% to miners, 5% to the bidder\\n                        \\n                        // mint NTOKEN(old, v3.0)\\n                        INTokenLegacy(_ntoken).increaseTotal(_ntokenAmount);\\n                        // transfer NTOKEN(old) to NestPool\\n                        INTokenLegacy(_ntoken).transfer(state.C_NestPool, _ntokenAmount);\\n                        // calculate the amount of NTOKEN, 95% => miner\\n                        _ntokenH = _ntokenAmount.mul(MiningV1Data.MINING_LEGACY_NTOKEN_MINER_REWARD_PERCENTAGE).div(100);\\n                        // 5% NTOKEN =>  `Bidder`\\n                        INestPool(state.C_NestPool).addNToken(_bidder, _ntoken, _ntokenAmount.sub(_ntokenH));\\n                    }\\n                }\\n                // add up `ethNum` into `minedAtHeight`\\n                _ethH = _ethH.add(ethNum);\\n                // encode `_nestH` and `_ethH` into `minedAtHeight`\\n                state.minedAtHeight[token][block.number] = (_ntokenH * (1<< 128) + _ethH);\\n            }\\n        }\\n\\n        // calculate the average-prices and volatilities for (TOKEN. NTOKEN)\\n\\n        state._stat(token);\\n        state._stat(_ntoken);\\n        return; \\n    }\\n\\n    /// @notice Close a price sheet of (ETH, USDx) | (ETH, NEST) | (ETH, TOKEN) | (ETH, NTOKEN)\\n    /// @dev Here we allow an empty price sheet (still in VERIFICATION-PERIOD) to be closed \\n    /// @param token The address of TOKEN contract\\n    /// @param index The index of the price sheet w.r.t. `token`\\n    function close(address token, uint256 index) \\n        public \\n        noContract \\n    {\\n        // call library\\n        state._close(token, index);\\n\\n        // calculate average-price and volatility (forward)\\n        state._stat(token);\\n\\n    }\\n\\n \\n    /// @notice Close a price sheet and withdraw assets for WEB users.  \\n    /// @dev Contracts aren't allowed to call it.\\n    /// @param token The address of TOKEN contract\\n    /// @param index The index of the price sheet w.r.t. `token`\\n    function closeAndWithdraw(address token, uint256 index) \\n        external \\n        noContract\\n    {\\n        // call library\\n        state._closeAndWithdraw(token, index);\\n        // calculate average-price and volatility (forward)\\n        state._stat(token);\\n    }\\n\\n    /// @notice Close a batch of price sheets passed VERIFICATION-PHASE\\n    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\\n    /// @param token The address of TOKEN contract\\n    /// @param indices A list of indices of sheets w.r.t. `token`\\n    function closeList(address token, uint32[] memory indices) \\n        external \\n        noContract\\n    {\\n        // call library\\n        state._closeList(token, indices);\\n\\n        // calculate average-price and volatility (forward)\\n        state._stat(token);\\n\\n    }\\n\\n\\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\\n    /// @param token The address of token(ntoken)\\n    /// @param index The position of the sheet in priceSheetList[token]\\n    /// @param biteNum The amount of bitting (in the unit of ETH), realAmount = biteNum * newTokenAmountPerEth\\n    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\\n    function biteToken(address token, uint256 index, uint256 biteNum, uint256 newTokenAmountPerEth) \\n        external \\n        payable \\n        noContract\\n    {\\n        // call library\\n        state._biteToken(token, index, biteNum, newTokenAmountPerEth);\\n\\n        // calculate average-price and volatility (forward)\\n        state._stat(token);\\n    }\\n\\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\\n    /// @param token The address of token(ntoken)\\n    /// @param index The position of the sheet in priceSheetList[token]\\n    /// @param biteNum The amount of bitting (in the unit of ETH), realAmount = biteNum * newTokenAmountPerEth\\n    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\\n    function biteEth(address token, uint256 index, uint256 biteNum, uint256 newTokenAmountPerEth)\\n        external\\n        payable\\n        noContract\\n    {\\n        // call library\\n        state._biteEth(token, index, biteNum, newTokenAmountPerEth);\\n\\n        // calculate average-price and volatility (forward)\\n        state._stat(token);\\n    }\\n\\n\\n    /* ========== CALCULATION ========== */\\n\\n    function stat(address _token) public \\n    {\\n        // call library\\n        return state._stat(_token);\\n    }\\n    \\n    /* ========== PRICE QUERIES ========== */\\n\\n    /// @notice Get the latest effective price for a token\\n    /// @dev It shouldn't be read from any contracts other than NestQuery\\n    function latestPriceOf(address token) \\n        public\\n        view\\n        onlyByNestOrNoContract\\n        returns(uint256 ethAmount, uint256 tokenAmount, uint256 blockNum) \\n    {\\n        MiningV1Data.PriceSheet[] storage _plist = state.priceSheetList[token];\\n        uint256 len = _plist.length;\\n        uint256 _ethNum;\\n        MiningV1Data.PriceSheet memory _sheet;\\n\\n        if (len == 0) {\\n            revert(\\\"Nest:Mine:no(price)\\\");\\n        }\\n\\n        uint256 _first = 0;\\n        for (uint i = 1; i <= len; i++) {\\n            _sheet = _plist[len-i];\\n            if (_first == 0 && uint256(_sheet.height) + state.priceDurationBlock < block.number) {\\n                _ethNum = uint256(_sheet.remainNum);\\n                if (_ethNum == 0) {\\n                    continue;  // jump over a bitten sheet\\n                }\\n                _first = uint256(_sheet.height);\\n                tokenAmount = _ethNum.mul(uint256(_sheet.tokenAmountPerEth));\\n                ethAmount = _ethNum.mul(1 ether);\\n                blockNum = _first;\\n            } else if (_first == uint256(_sheet.height)) {\\n                _ethNum = uint256(_sheet.remainNum);\\n                tokenAmount = tokenAmount.add(_ethNum.mul(uint256(_sheet.tokenAmountPerEth)));\\n                ethAmount = ethAmount.add(_ethNum.mul(1 ether));\\n            } else if (_first > uint256(_sheet.height)) {\\n                break;\\n            }\\n        }\\n        blockNum = blockNum + uint256(state.priceDurationBlock); // safe math\\n        require(ethAmount > 0 && tokenAmount > 0, \\\"Nest:Mine:no(price)\\\");\\n    }\\n\\n    /// @dev It shouldn't be read from any contracts other than NestQuery\\n    function priceOf(address token)\\n        public\\n        view\\n        noContractExcept(state.C_NestQuery)\\n        returns(uint256 ethAmount, uint256 tokenAmount, uint256 blockNum) \\n    {\\n        MiningV1Data.PriceInfo memory pi = state.priceInfo[token];\\n        require(pi.height > 0, \\\"Nest:Mine:NO(price)\\\");\\n        ethAmount = uint256(pi.ethNum).mul(1 ether);\\n        tokenAmount = uint256(pi.tokenAmount);\\n        blockNum = uint256(pi.height + state.priceDurationBlock);\\n        require(ethAmount > 0 && tokenAmount > 0, \\\"Nest:Mine:no(price)\\\");\\n    }\\n\\n    /// @dev It shouldn't be read from any contracts other than NestQuery\\n    function priceAvgAndSigmaOf(address token) \\n        public \\n        view \\n        onlyByNestOrNoContract\\n        returns (uint128 price, uint128 avgPrice, int128 vola, uint32 bn) \\n    {\\n        MiningV1Data.PriceInfo memory pi = state.priceInfo[token];\\n        require(pi.height > 0, \\\"Nest:Mine:NO(price)\\\");\\n        vola = ABDKMath64x64.sqrt(ABDKMath64x64.abs(pi.volatility_sigma_sq));\\n        price = uint128(uint256(pi.tokenAmount).div(uint256(pi.ethNum)));\\n        avgPrice = pi.avgTokenAmount;\\n        bn = pi.height + uint32(state.priceDurationBlock);\\n        require(price > 0 && avgPrice > 0, \\\"Nest:Mine:no(price)\\\");\\n    }\\n\\n    function priceOfTokenAtHeight(address token, uint64 atHeight)\\n        public \\n        view \\n        noContractExcept(state.C_NestQuery)\\n        returns(uint256 ethAmount, uint256 tokenAmount, uint256 bn) \\n    {\\n        (ethAmount, tokenAmount, bn) = state._priceOfTokenAtHeight(token, atHeight);\\n        require(ethAmount > 0 && tokenAmount > 0, \\\"Nest:Mine:no(price)\\\");\\n    }\\n\\n    /// @notice Return a consecutive price list for a token \\n    /// @dev \\n    /// @param token The address of token contract\\n    /// @param num   The length of price list\\n    function priceListOfToken(address token, uint8 num) \\n        external view \\n        noContractExcept(state.C_NestQuery)\\n        returns (uint128[] memory data, uint256 bn) \\n    {\\n        return state._priceListOfToken(token, num);\\n    }\\n\\n    /* ========== MINING ========== */\\n    \\n    function mineNest() public view returns (uint256) \\n    {\\n        uint256 _period = block.number.sub(state.genesisBlock).div(MiningV1Data.MINING_NEST_YIELD_CUTBACK_PERIOD);\\n        uint256 _nestPerBlock;\\n        if (_period > 9) {\\n            _nestPerBlock = MiningV1Data.MINING_NEST_YIELD_OFF_PERIOD_AMOUNT;\\n            if (block.number > MiningV1Data.MINING_FINAL_BLOCK_NUMBER) {\\n                return 0;  // NEST is empty\\n            }\\n        } else {\\n            _nestPerBlock = state._mining_nest_yield_per_block_amount[_period];\\n        }\\n        \\n        return _nestPerBlock.mul(block.number.sub(state.latestMiningHeight));\\n    }\\n\\n    function minedNestAmount() external view returns (uint256) \\n    {\\n       return uint256(state.minedNestAmount);\\n    }\\n\\n    function latestMinedHeight() external view returns (uint64) \\n    {\\n       return uint64(state.latestMiningHeight);\\n    }\\n\\n    function mineNToken(address ntoken) public view returns (uint256) \\n    {\\n        (uint256 _genesis, uint256 _last) = INToken(ntoken).checkBlockInfo();\\n\\n        uint256 _period = block.number.sub(_genesis).div(MiningV1Data.MINING_NEST_YIELD_CUTBACK_PERIOD);\\n        uint256 _ntokenPerBlock;\\n        if (_period > 9) {\\n            _ntokenPerBlock = MiningV1Data.MINING_NTOKEN_YIELD_OFF_PERIOD_AMOUNT;\\n        } else {\\n            _ntokenPerBlock = state._mining_ntoken_yield_per_block_amount[_period];\\n        }\\n        uint256 _interval = block.number.sub(_last);\\n        if (_interval > MiningV1Data.MINING_NTOKEN_YIELD_BLOCK_LIMIT) {\\n            _interval = MiningV1Data.MINING_NTOKEN_YIELD_BLOCK_LIMIT;\\n        }\\n\\n        // NOTE: no NTOKEN rewards if the mining interval is greater than a pre-defined number\\n        uint256 yieldAmount = _ntokenPerBlock.mul(_interval);\\n        return yieldAmount;\\n    }\\n\\n    /* ========== WITHDRAW ========== */\\n\\n    function withdrawEth(uint256 ethAmount) \\n        external nonReentrant\\n    {\\n        INestPool(state.C_NestPool).withdrawEth(address(msg.sender), ethAmount); \\n    }\\n\\n    function withdrawEthAndToken(uint256 ethAmount, address token, uint256 tokenAmount) \\n        external nonReentrant\\n    {\\n        INestPool(state.C_NestPool).withdrawEthAndToken(address(msg.sender), ethAmount, token, tokenAmount); \\n    }\\n\\n    function withdrawNest(uint256 nestAmount) \\n        external nonReentrant\\n    {\\n        INestPool(state.C_NestPool).withdrawNest(address(msg.sender), nestAmount); \\n    }\\n\\n    function withdrawEthAndTokenAndNest(uint256 ethAmount, address token, uint256 tokenAmount, uint256 nestAmount) \\n        external nonReentrant\\n    {\\n        INestPool(state.C_NestPool).withdrawEthAndToken(address(msg.sender), ethAmount, token, tokenAmount); \\n        INestPool(state.C_NestPool).withdrawNest(address(msg.sender), nestAmount);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function lengthOfPriceSheets(address token) \\n        view \\n        external \\n        returns (uint256)\\n    {\\n        return state.priceSheetList[token].length;\\n    }\\n\\n    function priceSheet(address token, uint256 index) \\n        view external \\n        returns (MiningV1Data.PriceSheetPub memory sheet) \\n    {\\n        return state._priceSheet(token, index); \\n    }\\n\\n    function fullPriceSheet(address token, uint256 index) \\n        view \\n        public\\n        noContract\\n        returns (MiningV1Data.PriceSheet memory sheet) \\n    {\\n        uint256 len = state.priceSheetList[token].length;\\n        require (index < len, \\\"Nest:Mine:>(len)\\\");\\n        return state.priceSheetList[token][index];\\n    }\\n\\n    function unVerifiedSheetList(address token)\\n        view \\n        public\\n        noContract\\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \\n    {\\n        return state.unVerifiedSheetList(token);\\n    }\\n\\n    function unClosedSheetListOf(address miner, address token, uint256 fromIndex, uint256 num) \\n        view \\n        public\\n        noContract\\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \\n    {\\n        return state.unClosedSheetListOf(miner, token, fromIndex, num);\\n    }\\n\\n    function sheetListOf(address miner, address token, uint256 fromIndex, uint256 num) \\n        view \\n        public\\n        noContract\\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \\n    {\\n        return state.sheetListOf(miner, token, fromIndex, num);\\n    }\\n\\n    /*\\n     /// @dev The function will be disabled when the upgrading is completed\\n    /// TODO: (TBD) auth needed? \\n    function post2Only4Upgrade(\\n            address token,\\n            uint256 ethNum,\\n            uint256 tokenAmountPerEth,\\n            uint256 ntokenAmountPerEth\\n        )\\n        external \\n        noContract\\n    {\\n       // only avialble in upgrade phase\\n        require (flag == MINING_FLAG_UPGRADE_NEEDED, \\\"Nest:Mine:!flag\\\");\\n        state._post2Only4Upgrade(token, ethNum, tokenAmountPerEth, ntokenAmountPerEth);\\n        address _ntoken = INestPool(state.C_NestPool).getNTokenFromToken(token);\\n\\n        // calculate average price and volatility\\n        state._stat(token);\\n        state._stat(_ntoken);\\n    }\\n    */\\n}\"\r\n    },\r\n    \"contracts/libminingv1/MiningV1Data.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n\\nimport \\\"../iface/INestPool.sol\\\";\\nimport \\\"../iface/INestStaking.sol\\\";\\nimport \\\"../iface/INToken.sol\\\";\\nimport \\\"../iface/INNRewardPool.sol\\\";\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\n\\n\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author 0x00  - <0x00@nestprotocol.org>\\nlibrary MiningV1Data {\\n\\n    /* ========== CONSTANTS ========== */\\n\\n    uint256 constant MINING_NEST_YIELD_CUTBACK_PERIOD = 2400000; // ~ 1 years \\n    uint256 constant MINING_NEST_YIELD_CUTBACK_RATE = 80;     // percentage = 80%\\n\\n    // yield amount (per block) after the first ten years\\n    uint256 constant MINING_NEST_YIELD_OFF_PERIOD_AMOUNT = 40 ether;\\n    // yield amount (per block) in the first year, it drops to 80% in the following nine years\\n    uint256 constant MINING_NEST_YIELD_PER_BLOCK_BASE = 400 ether;\\n\\n    uint256 constant MINING_NTOKEN_YIELD_CUTBACK_RATE = 80;\\n    uint256 constant MINING_NTOKEN_YIELD_OFF_PERIOD_AMOUNT = 0.4 ether;\\n    uint256 constant MINING_NTOKEN_YIELD_PER_BLOCK_BASE = 4 ether;\\n\\n    uint256 constant MINING_FINAL_BLOCK_NUMBER = 173121488;\\n\\n\\n    uint256 constant MINING_NEST_FEE_DIVIDEND_RATE = 80;    // percentage = 80%\\n    uint256 constant MINING_NEST_FEE_DAO_RATE = 20;         // percentage = 20%\\n\\n    uint256 constant MINING_NTOKEN_FEE_DIVIDEND_RATE        = 60;     // percentage = 60%\\n    uint256 constant MINING_NTOKEN_FEE_DAO_RATE             = 20;     // percentage = 20%\\n    uint256 constant MINING_NTOKEN_FEE_NEST_DAO_RATE        = 20;     // percentage = 20%\\n\\n    uint256 constant MINING_NTOKEN_YIELD_BLOCK_LIMIT = 100;\\n\\n    uint256 constant NN_NEST_REWARD_PERCENTAGE = 15;\\n    uint256 constant DAO_NEST_REWARD_PERCENTAGE = 5;\\n    uint256 constant MINER_NEST_REWARD_PERCENTAGE = 80;\\n\\n    uint256 constant MINING_LEGACY_NTOKEN_MINER_REWARD_PERCENTAGE = 95;\\n    uint256 constant MINING_LEGACY_NTOKEN_BIDDER_REWARD_PERCENTAGE = 5;\\n\\n    uint8 constant PRICESHEET_STATE_CLOSED = 0;\\n    uint8 constant PRICESHEET_STATE_POSTED = 1;\\n    uint8 constant PRICESHEET_STATE_BITTEN = 2;\\n\\n    uint8 constant PRICESHEET_TYPE_USD     = 1;\\n    uint8 constant PRICESHEET_TYPE_NEST    = 2;\\n    uint8 constant PRICESHEET_TYPE_TOKEN   = 3;\\n    uint8 constant PRICESHEET_TYPE_NTOKEN  = 4;\\n    uint8 constant PRICESHEET_TYPE_BITTING = 8;\\n\\n\\n    uint8 constant STATE_FLAG_UNINITIALIZED    = 0;\\n    uint8 constant STATE_FLAG_SETUP_NEEDED     = 1;\\n    uint8 constant STATE_FLAG_ACTIVE           = 3;\\n    uint8 constant STATE_FLAG_MINING_STOPPED   = 4;\\n    uint8 constant STATE_FLAG_CLOSING_STOPPED  = 5;\\n    uint8 constant STATE_FLAG_WITHDRAW_STOPPED = 6;\\n    uint8 constant STATE_FLAG_PRICE_STOPPED    = 7;\\n    uint8 constant STATE_FLAG_SHUTDOWN         = 127;\\n\\n    uint256 constant MINING_NTOKEN_NON_DUAL_POST_THRESHOLD = 5_000_000 ether;\\n\\n\\n    /// @dev size: (2 x 256 bit)\\n    struct PriceSheet {    \\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\\n        uint32  height;      //\\n        uint32  ethNum;   \\n        uint32  remainNum;    \\n\\n        uint8   level;           // the level of bitting, 1-4: eth-doubling | 5 - 127: nest-doubling\\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN\\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\\n        uint8   _reserved;       // for padding\\n        uint32  ethNumBal;\\n        uint32  tokenNumBal;\\n        uint32  nestNum1k;\\n        uint128 tokenAmountPerEth;\\n    }\\n    \\n    /// @dev size: (3 x 256 bit)\\n    struct PriceInfo {\\n        uint32  index;\\n        uint32  height;         // NOTE: the height of being posted\\n        uint32  ethNum;         //  the balance of eth\\n        uint32  _reserved;\\n        uint128 tokenAmount;    //  the balance of token \\n        int128  volatility_sigma_sq;\\n        int128  volatility_ut_sq;\\n        uint128  avgTokenAmount;  // avg = (tokenAmount : perEth)\\n        uint128 _reserved2;     \\n    }\\n\\n\\n    /// @dev The struct is for public data in a price sheet, so as to protect prices from being read\\n    struct PriceSheetPub {\\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\\n        uint32  height;\\n        uint32  ethNum;   \\n\\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN(Not Available)\\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\\n        uint32  ethNumBal;\\n        uint32  tokenNumBal;\\n    }\\n\\n\\n    struct PriceSheetPub2 {\\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\\n        uint32  height;\\n        uint32  ethNum;   \\n        uint32  remainNum; \\n\\n        uint8   level;           // the level of bitting, 1-4: eth-doubling | 5 - 127: nest-doubling\\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN(Not Available)\\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\\n        uint256 index;           // return to the quotation of index\\n        uint32  nestNum1k;\\n        uint128 tokenAmountPerEth;   \\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event PricePosted(address miner, address token, uint256 index, uint256 ethAmount, uint256 tokenAmount);\\n    event PriceClosed(address miner, address token, uint256 index);\\n    event Deposit(address miner, address token, uint256 amount);\\n    event Withdraw(address miner, address token, uint256 amount);\\n    event TokenBought(address miner, address token, uint256 index, uint256 biteEthAmount, uint256 biteTokenAmount);\\n    event TokenSold(address miner, address token, uint256 index, uint256 biteEthAmount, uint256 biteTokenAmount);\\n\\n    event VolaComputed(uint32 h, uint32 pos, uint32 ethA, uint128 tokenA, int128 sigma_sq, int128 ut_sq);\\n\\n    event SetParams(uint8 miningEthUnit, uint32 nestStakedNum1k, uint8 biteFeeRate,\\n                    uint8 miningFeeRate, uint8 priceDurationBlock, uint8 maxBiteNestedLevel,\\n                    uint8 biteInflateFactor, uint8 biteNestInflateFactor);\\n\\n    // event GovSet(address oldGov, address newGov);\\n\\n    /* ========== GIANT STATE VARIABLE ========== */\\n\\n    struct State {\\n        // TODO: more comments\\n\\n        uint8   miningEthUnit;      // = 30 on mainnet;\\n        uint32  nestStakedNum1k;    // = 100;\\n        uint8   biteFeeRate;        // \\n        uint8   miningFeeRate;      // = 10;  \\n        uint8   priceDurationBlock; // = 25;\\n        uint8   maxBiteNestedLevel; // = 3;\\n        uint8   biteInflateFactor;  // = 2;\\n        uint8   biteNestInflateFactor; // = 2;\\n\\n        uint32  genesisBlock;       // = 6236588;\\n\\n        uint128  latestMiningHeight;  // latest block number of NEST mining\\n        uint128  minedNestAmount;     // the total amount of mined NEST\\n        \\n        address  _developer_address;  // WARNING: DO NOT delete this unused variable\\n        address  _NN_address;         // WARNING: DO NOT delete this unused variable\\n\\n        address  C_NestPool;\\n        address  C_NestToken;\\n        address  C_NestStaking;\\n        address  C_NNRewardPool;\\n        address  C_NestQuery;\\n        address  C_NestDAO;\\n\\n        uint256[10] _mining_nest_yield_per_block_amount;\\n        uint256[10] _mining_ntoken_yield_per_block_amount;\\n\\n        // A mapping (from token(address) to an array of PriceSheet)\\n        mapping(address => PriceSheet[]) priceSheetList;\\n\\n        // from token(address) to Price\\n        mapping(address => PriceInfo) priceInfo;\\n\\n        // (token-address, block-number) => (ethFee-total, nest/ntoken-mined-total)\\n        mapping(address => mapping(uint256 => uint256)) minedAtHeight;\\n\\n        // WARNING: DO NOT delete these variables, reserved for future use\\n        uint256  _reserved1;\\n        uint256  _reserved2;\\n        uint256  _reserved3;\\n        uint256  _reserved4;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/libminingv1/MiningV1Calc.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/SafeMath.sol\\\";\\nimport \\\"../lib/SafeERC20.sol\\\";\\nimport '../lib/TransferHelper.sol';\\nimport \\\"../lib/ABDKMath64x64.sol\\\";\\n\\nimport \\\"../iface/INestPool.sol\\\";\\nimport \\\"../iface/INestStaking.sol\\\";\\nimport \\\"../iface/INToken.sol\\\";\\nimport \\\"../iface/INNRewardPool.sol\\\";\\nimport \\\"../libminingv1/MiningV1Data.sol\\\";\\n//import \\\"hardhat/console.sol\\\";\\n\\n\\n/// @title  NestMiningV1/MiningV1Calc\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author Paradox  - <paradox@nestprotocol.org>\\nlibrary MiningV1Calc {\\n\\n    using SafeMath for uint256;\\n    \\n    /// @dev Average block mining interval, ~ 14s\\n    uint256 constant ETHEREUM_BLOCK_TIMESPAN = 14;\\n\\n    function _calcVola(\\n            // uint256 ethA0, \\n            uint256 tokenA0, \\n            // uint256 ethA1, \\n            uint256 tokenA1, \\n            int128 _sigma_sq, \\n            int128 _ut_sq,\\n            uint256 _interval\\n        )\\n        private\\n        pure\\n        // pure \\n        returns (int128, int128)\\n    {\\n        int128 _ut_sq_2 = ABDKMath64x64.div(_ut_sq, \\n            ABDKMath64x64.fromUInt(_interval.mul(ETHEREUM_BLOCK_TIMESPAN)));\\n\\n        int128 _new_sigma_sq = ABDKMath64x64.add(\\n            ABDKMath64x64.mul(ABDKMath64x64.divu(95, 100), _sigma_sq),\\n            ABDKMath64x64.mul(ABDKMath64x64.divu(5,100), _ut_sq_2));\\n\\n        int128 _new_ut_sq;\\n        _new_ut_sq = ABDKMath64x64.pow(ABDKMath64x64.sub(\\n                    ABDKMath64x64.divu(tokenA1, tokenA0), \\n                    ABDKMath64x64.fromUInt(1)), \\n                2);\\n        \\n        return (_new_sigma_sq, _new_ut_sq);\\n    }\\n\\n    function _calcAvg(uint256 ethA, uint256 tokenA, uint256 _avg)\\n        private \\n        pure\\n        returns(uint256)\\n    {\\n        uint256 _newP = tokenA.div(ethA);\\n        uint256 _newAvg;\\n\\n        if (_avg == 0) {\\n            _newAvg = _newP;\\n        } else {\\n            _newAvg = (_avg.mul(95).div(100)).add(_newP.mul(5).div(100));\\n            // _newAvg = ABDKMath64x64.add(\\n            //     ABDKMath64x64.mul(ABDKMath64x64.divu(95, 100), _avg),\\n            //     ABDKMath64x64.mul(ABDKMath64x64.divu(5,100), _newP));\\n        }\\n\\n        return _newAvg;\\n    }\\n\\n    function _moveAndCalc(\\n            MiningV1Data.PriceInfo memory p0,\\n            MiningV1Data.PriceSheet[] storage pL,\\n            uint256 priceDurationBlock\\n        )\\n        private\\n        view\\n        returns (MiningV1Data.PriceInfo memory)\\n    {\\n        uint256 i = p0.index + 1;\\n        if (i >= pL.length) {\\n            return (MiningV1Data.PriceInfo(0,0,0,0,0,int128(0),int128(0), uint128(0), 0));\\n        }\\n\\n        uint256 h = uint256(pL[i].height);\\n        if (h + priceDurationBlock >= block.number) {\\n            return (MiningV1Data.PriceInfo(0,0,0,0,0,int128(0),int128(0), uint128(0), 0));\\n        }\\n\\n        uint256 ethA1 = 0;\\n        uint256 tokenA1 = 0;\\n        while (i < pL.length && pL[i].height == h) {\\n            uint256 _remain = uint256(pL[i].remainNum);\\n            if (_remain == 0) {\\n                i = i + 1;\\n                continue;  // jump over a bitten sheet\\n            }\\n            ethA1 = ethA1 + _remain;\\n            tokenA1 = tokenA1 + _remain.mul(pL[i].tokenAmountPerEth);\\n            i = i + 1;\\n        }\\n        i = i - 1;\\n\\n        if (ethA1 == 0 || tokenA1 == 0) {\\n            return (MiningV1Data.PriceInfo(\\n                    uint32(i),  // index\\n                    uint32(0),  // height\\n                    uint32(0),  // ethNum\\n                    uint32(0),  // _reserved\\n                    uint32(0),  // tokenAmount\\n                    int128(0),  // volatility_sigma_sq\\n                    int128(0),  // volatility_ut_sq\\n                    uint128(0),  // avgTokenAmount\\n                    0           // _reserved2\\n            ));\\n        }\\n        int128 new_sigma_sq;\\n        int128 new_ut_sq;\\n        {\\n            if (uint256(p0.ethNum) != 0) {\\n                (new_sigma_sq, new_ut_sq) = _calcVola(\\n                    uint256(p0.tokenAmount).div(uint256(p0.ethNum)), \\n                    uint256(tokenA1).div(uint256(ethA1)),\\n                p0.volatility_sigma_sq, p0.volatility_ut_sq,\\n                h - p0.height);\\n            }\\n        }\\n        uint256 _newAvg = _calcAvg(ethA1, tokenA1, p0.avgTokenAmount); \\n\\n        return(MiningV1Data.PriceInfo(\\n                uint32(i),          // index\\n                uint32(h),          // height\\n                uint32(ethA1),      // ethNum\\n                uint32(0),          // _reserved\\n                uint128(tokenA1),   // tokenAmount\\n                new_sigma_sq,       // volatility_sigma_sq\\n                new_ut_sq,          // volatility_ut_sq\\n                uint128(_newAvg),   // avgTokenAmount\\n                uint128(0)          // _reserved2\\n        ));\\n    }\\n\\n    /// @dev The function updates the statistics of price sheets\\n    ///     It calculates from priceInfo to the newest that is effective.\\n    ///     Different from `_statOneBlock()`, it may cross multiple blocks.\\n    function _stat(MiningV1Data.State storage state, address token)\\n        external \\n    {\\n        MiningV1Data.PriceInfo memory p0 = state.priceInfo[token];\\n        MiningV1Data.PriceSheet[] storage pL = state.priceSheetList[token];\\n\\n        if (pL.length < 2) {\\n            return;\\n        }\\n\\n        if (p0.height == 0) {\\n\\n            MiningV1Data.PriceSheet memory _sheet = pL[0];\\n            p0.ethNum = _sheet.ethNum;\\n            p0.tokenAmount = uint128(uint256(_sheet.tokenAmountPerEth).mul(_sheet.ethNum));\\n            p0.height = _sheet.height;\\n            p0.volatility_sigma_sq = 0;\\n            p0.volatility_ut_sq = 0;\\n            p0.avgTokenAmount = uint128(_sheet.tokenAmountPerEth);\\n            // write back\\n            state.priceInfo[token] = p0;\\n        }\\n\\n        MiningV1Data.PriceInfo memory p1;\\n\\n        // record the gas usage\\n        uint256 startGas = gasleft();\\n        uint256 gasUsed;\\n\\n        while (uint256(p0.index) < pL.length && uint256(p0.height) + state.priceDurationBlock < block.number){\\n            gasUsed = startGas - gasleft();\\n            // NOTE: check gas usage to prevent DOS attacks\\n            if (gasUsed > 1_000_000) {\\n                break; \\n            }\\n            p1 = _moveAndCalc(p0, pL, state.priceDurationBlock);\\n            if (p1.index <= p0.index) {    // bootstraping\\n                break;\\n            } else if (p1.ethNum == 0) {   // jump cross a block with bitten prices\\n                p0.index = p1.index;\\n                continue;\\n            } else {                       // calculate one more block\\n                p0 = p1;\\n            }\\n        }\\n\\n        if (p0.index > state.priceInfo[token].index) {\\n            state.priceInfo[token] = p0;\\n        }\\n\\n        return;\\n    }\\n\\n    /// @dev The function updates the statistics of price sheets across only one block.\\n    function _statOneBlock(MiningV1Data.State storage state, address token) \\n        external \\n    {\\n        MiningV1Data.PriceInfo memory p0 = state.priceInfo[token];\\n        MiningV1Data.PriceSheet[] storage pL = state.priceSheetList[token];\\n        if (pL.length < 2) {\\n            return;\\n        }\\n        (MiningV1Data.PriceInfo memory p1) = _moveAndCalc(p0, state.priceSheetList[token], state.priceDurationBlock);\\n        if (p1.index > p0.index && p1.ethNum != 0) {\\n            state.priceInfo[token] = p1;\\n        } else if (p1.index > p0.index && p1.ethNum == 0) {\\n            p0.index = p1.index;\\n            state.priceInfo[token] = p1;\\n        }\\n        return;\\n    }\\n\\n    /// @notice Return a consecutive price list for a token \\n    /// @dev \\n    /// @param token The address of token contract\\n    /// @param num   The length of price list\\n    function _priceListOfToken(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint8 num\\n        )\\n        external \\n        view\\n        returns (uint128[] memory data, uint256 bn) \\n    {\\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token];\\n        uint256 len = _list.length;\\n        uint256 _index = 0;\\n        data = new uint128[](num * 3);\\n        MiningV1Data.PriceSheet memory _sheet;\\n        uint256 _ethNum;\\n\\n        // loop\\n        uint256 _curr = 0;\\n        uint256 _prev = 0;\\n        for (uint i = 1; i <= len; i++) {\\n            _sheet = _list[len - i];\\n            _curr = uint256(_sheet.height);\\n            if (_prev == 0) {\\n                if (_curr + state.priceDurationBlock < block.number) {\\n                    _ethNum = uint256(_sheet.remainNum);\\n                    if(_ethNum > 0) {\\n                        data[_index] = uint128(_curr + state.priceDurationBlock); // safe math\\n                        data[_index + 1] = uint128(_ethNum.mul(1 ether));\\n                        data[_index + 2] = uint128(_ethNum.mul(_sheet.tokenAmountPerEth));\\n                        bn = _curr + state.priceDurationBlock;  // safe math\\n                        _prev = _curr;\\n                    }\\n                }\\n            } else if (_prev == _curr) {\\n                _ethNum = uint256(_sheet.remainNum);\\n                data[_index + 1] += uint128(_ethNum.mul(1 ether));\\n                data[_index + 2] += uint128(_ethNum.mul(_sheet.tokenAmountPerEth));\\n            } else if (_prev > _curr) {\\n                _ethNum = uint256(_sheet.remainNum);\\n                if(_ethNum > 0){\\n                    _index += 3;\\n                    if (_index >= uint256(num * 3)) {\\n                        break;\\n                    }\\n                    data[_index] = uint128(_curr + state.priceDurationBlock); // safe math\\n                    data[_index + 1] = uint128(_ethNum.mul(1 ether));\\n                    data[_index + 2] = uint128(_ethNum.mul(_sheet.tokenAmountPerEth));\\n                    _prev = _curr;\\n                }\\n            }\\n        } \\n        // require (data.length == uint256(num * 3), \\\"Incorrect price list length\\\");\\n    }\\n\\n    function _priceOfTokenAtHeight(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint64 atHeight\\n        )\\n        external \\n        view \\n        returns(uint256 ethAmount, uint256 tokenAmount, uint256 blockNum) \\n    {\\n        require(atHeight <= block.number, \\\"Nest:Mine:!height\\\");\\n\\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token];\\n        uint256 len = state.priceSheetList[token].length;\\n        MiningV1Data.PriceSheet memory _sheet;\\n        uint256 _ethNum;\\n\\n        if (len == 0) {\\n            return (0, 0, 0);\\n        }\\n\\n        uint256 _first = 0;\\n        uint256 _prev = 0;\\n        for (uint i = 1; i <= len; i++) {\\n            _sheet = _list[len - i];\\n            _first = uint256(_sheet.height);\\n            if (_prev == 0) {\\n                if (_first + state.priceDurationBlock < uint256(atHeight)) {\\n                    _ethNum = uint256(_sheet.remainNum);\\n                    if (_ethNum == 0) {\\n                        continue; // jump over a bitten sheet\\n                    }\\n                    ethAmount = _ethNum.mul(1 ether);\\n                    tokenAmount = _ethNum.mul(_sheet.tokenAmountPerEth);\\n                    blockNum = _first + state.priceDurationBlock;\\n                    _prev = _first;\\n                }\\n            } else if (_first == _prev) {\\n                _ethNum = uint256(_sheet.remainNum);\\n                ethAmount = ethAmount.add(_ethNum.mul(1 ether));\\n                tokenAmount = tokenAmount.add(_ethNum.mul(_sheet.tokenAmountPerEth));\\n            } else if (_prev > _first) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _priceSheet(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint256 index\\n        ) \\n        view external \\n        returns (MiningV1Data.PriceSheetPub memory sheet) \\n    {\\n        uint256 len = state.priceSheetList[token].length;\\n        require (index < len, \\\"Nest:Mine:!index\\\");\\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index];\\n        sheet.miner = _sheet.miner;\\n        sheet.height = _sheet.height;\\n        sheet.ethNum = _sheet.ethNum;\\n        sheet.typ = _sheet.typ;\\n        sheet.state = _sheet.state;\\n        sheet.ethNumBal = _sheet.ethNumBal;\\n        sheet.tokenNumBal = _sheet.tokenNumBal;\\n    }\\n\\n    \\n    function unVerifiedSheetList(\\n            MiningV1Data.State storage state, \\n            address token\\n        ) \\n        view \\n        public\\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \\n    {\\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token]; \\n        uint256 len = _list.length;\\n        uint256 num;\\n        for (uint i = 0; i < len; i++) {\\n            if (_list[len - 1 - i].height + state.priceDurationBlock < block.number) {\\n                break;\\n            }\\n            num += 1;\\n        }\\n\\n        sheets = new MiningV1Data.PriceSheetPub2[](num);\\n        for (uint i = 0; i < num; i++) {\\n            MiningV1Data.PriceSheet memory _sheet = _list[len - 1 - i];\\n            if (uint256(_sheet.height) + state.priceDurationBlock < block.number) {\\n                break;\\n            }\\n            //sheets[i] = _sheet;\\n            sheets[i].miner = _sheet.miner;\\n            sheets[i].height = _sheet.height;\\n            sheets[i].ethNum = _sheet.ethNum;\\n            sheets[i].remainNum = _sheet.remainNum;\\n            sheets[i].level = _sheet.level;\\n            sheets[i].typ = _sheet.typ;\\n            sheets[i].state = _sheet.state;\\n\\n            sheets[i].index = len - 1 - i;\\n\\n            sheets[i].nestNum1k = _sheet.nestNum1k;\\n            sheets[i].tokenAmountPerEth = _sheet.tokenAmountPerEth;\\n        }\\n    }\\n\\n    function unClosedSheetListOf(\\n            MiningV1Data.State storage state, \\n            address miner, \\n            address token, \\n            uint256 fromIndex, \\n            uint256 num) \\n        view \\n        external\\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \\n    {\\n        sheets = new MiningV1Data.PriceSheetPub2[](num);\\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token]; \\n        uint256 len = _list.length;\\n        require(fromIndex < len, \\\"Nest:Mine:!from\\\");\\n\\n        for (uint i = 0; i < num; i++) {\\n            if (fromIndex < i) {\\n                break;\\n            }\\n\\n            MiningV1Data.PriceSheet memory _sheet = _list[fromIndex - i];\\n            if (uint256(_sheet.miner) == uint256(miner)\\n                && (_sheet.state == MiningV1Data.PRICESHEET_STATE_POSTED \\n                    || _sheet.state == MiningV1Data.PRICESHEET_STATE_BITTEN)) {\\n            \\n                sheets[i].miner = _sheet.miner;\\n                sheets[i].height = _sheet.height;\\n                sheets[i].ethNum = _sheet.ethNum;\\n                sheets[i].remainNum = _sheet.remainNum;\\n                sheets[i].level = _sheet.level;\\n                sheets[i].typ = _sheet.typ;\\n                sheets[i].state = _sheet.state;\\n\\n                sheets[i].index = fromIndex - i;\\n\\n                sheets[i].nestNum1k = _sheet.nestNum1k;\\n                sheets[i].tokenAmountPerEth = _sheet.tokenAmountPerEth;\\n\\n            }\\n        }\\n    }\\n\\n    function sheetListOf(\\n           MiningV1Data.State storage state, \\n           address miner, \\n           address token, \\n           uint256 fromIndex, \\n           uint256 num\\n        ) \\n        view \\n        external\\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \\n    {\\n        sheets = new MiningV1Data.PriceSheetPub2[](num);\\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token]; \\n        uint256 len = _list.length;\\n        require(fromIndex < len, \\\"Nest:Mine:!from\\\");\\n\\n        for (uint i = 0; i < num; i++) {\\n            if (fromIndex < i) {\\n                break;\\n            }\\n            MiningV1Data.PriceSheet memory _sheet = _list[fromIndex - i];\\n            if (uint256(_sheet.miner) == uint256(miner)) {\\n            \\n                sheets[i].miner = _sheet.miner;\\n                sheets[i].height = _sheet.height;\\n                sheets[i].ethNum = _sheet.ethNum;\\n                sheets[i].remainNum = _sheet.remainNum;\\n                sheets[i].level = _sheet.level;\\n                sheets[i].typ = _sheet.typ;\\n                sheets[i].state = _sheet.state;\\n\\n                sheets[i].index = fromIndex - i;\\n                sheets[i].nestNum1k = _sheet.nestNum1k;\\n                sheets[i].tokenAmountPerEth = _sheet.tokenAmountPerEth;\\n\\n            }\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/libminingv1/MiningV1Op.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/SafeMath.sol\\\";\\nimport \\\"../lib/SafeERC20.sol\\\";\\nimport '../lib/TransferHelper.sol';\\nimport \\\"../lib/ABDKMath64x64.sol\\\";\\n\\nimport \\\"../iface/INestPool.sol\\\";\\nimport \\\"../iface/INestStaking.sol\\\";\\nimport \\\"../iface/INToken.sol\\\";\\nimport \\\"../iface/INNRewardPool.sol\\\";\\nimport \\\"../libminingv1/MiningV1Data.sol\\\";\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\n/// @title  NestMiningV1/MiningV1Calc\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author Paradox  - <paradox@nestprotocol.org>\\nlibrary MiningV1Op {\\n\\n    using SafeMath for uint256;\\n\\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\\n    /// @param token The address of token(ntoken)\\n    /// @param index The position of the sheet in priceSheetList[token]\\n    /// @param biteNum The amount of bitting (in the unit of ETH), realAmount = biteNum * newTokenAmountPerEth\\n    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\\n    function _biteToken(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint256 index, \\n            uint256 biteNum, \\n            uint256 newTokenAmountPerEth\\n        )\\n        external\\n    {\\n        // check parameters\\n        require(token != address(0x0), \\\"Nest:Mine:(token)=0\\\"); \\n        require(newTokenAmountPerEth > 0, \\\"Nest:Mine:(price)=0\\\");\\n        require(biteNum >= state.miningEthUnit && biteNum % state.miningEthUnit == 0, \\\"Nest:Mine:!(bite)\\\");\\n\\n        // check sheet\\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index]; \\n        require(uint256(_sheet.height) + state.priceDurationBlock >= block.number, \\\"Nest:Mine:!EFF(sheet)\\\");\\n        require(uint256(_sheet.remainNum) >= biteNum, \\\"Nest:Mine:!(remain)\\\");\\n\\n        // load address of NestPool \\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n\\n        // check sheet sate\\n        uint256 _state = uint256(_sheet.state);\\n        require(_state == MiningV1Data.PRICESHEET_STATE_POSTED \\n             || _state == MiningV1Data.PRICESHEET_STATE_BITTEN,  \\\"Nest:Mine:!(state)\\\");\\n\\n        {\\n            // load NTOKEN\\n            address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n            // calculate fee\\n            uint256 _ethFee = biteNum.mul(1 ether).mul(state.biteFeeRate).div(1000);\\n\\n            // save the changes into miner's virtual account\\n            if (msg.value.sub(_ethFee) > 0) {\\n                _C_NestPool.depositEth{value:msg.value.sub(_ethFee)}(address(msg.sender));\\n            }\\n\\n            // pump fee into staking pool\\n            if (_ethFee > 0) {\\n                INestStaking(state.C_NestStaking).addETHReward{value:_ethFee}(_ntoken);\\n            }\\n        }\\n \\n        // post a new price sheet\\n        { \\n            // check bitting conditions\\n            uint256 _newEthNum;\\n            uint256 _newNestNum1k = uint256(_sheet.nestNum1k);\\n            {\\n                uint256 _level = uint256(_sheet.level);\\n                uint256 _newLevel;\\n                \\n                // calculate `(_newEthNum, _newNestNum1k, _newLevel)`\\n                if (_level > state.maxBiteNestedLevel && _level < 127) { // bitten sheet, nest doubling\\n                    _newEthNum = biteNum;\\n                    _newNestNum1k = _newNestNum1k.mul(biteNum.mul(state.biteNestInflateFactor)).div(_sheet.ethNum);\\n                    _newLevel = _level + 1;\\n                } else if (_level <= state.maxBiteNestedLevel) {  // bitten sheet, eth doubling \\n                    _newEthNum = biteNum.mul(state.biteInflateFactor);\\n                    _newNestNum1k = _newNestNum1k.mul(biteNum.mul(state.biteNestInflateFactor)).div(_sheet.ethNum);\\n                    _newLevel = _level + 1;\\n                }\\n\\n                // freeze NEST \\n                _C_NestPool.freezeNest(address(msg.sender), _newNestNum1k.mul(1000 * 1e18));\\n\\n                // freeze(TOKEN, ETH); or freeeze(ETH) but unfreeze(TOKEN)\\n                if (_newEthNum.mul(newTokenAmountPerEth) < biteNum * _sheet.tokenAmountPerEth) {\\n                    uint256 _unfreezetokenAmount;\\n                    _unfreezetokenAmount = uint256(_sheet.tokenAmountPerEth).mul(biteNum).sub((uint256(newTokenAmountPerEth)).mul(_newEthNum));               \\n                    _C_NestPool.unfreezeToken(msg.sender, token, _unfreezetokenAmount);\\n                    _C_NestPool.freezeEth(msg.sender, _newEthNum.add(biteNum).mul(1 ether));\\n                } else {\\n                    _C_NestPool.freezeEthAndToken(msg.sender, _newEthNum.add(biteNum).mul(1 ether), \\n                        token, _newEthNum.mul(newTokenAmountPerEth)\\n                                         .sub(biteNum * _sheet.tokenAmountPerEth));\\n                }\\n\\n                MiningV1Data.PriceSheet[] storage _sheetOfToken = state.priceSheetList[token];\\n                // append a new price sheet\\n                _sheetOfToken.push(MiningV1Data.PriceSheet(\\n                    uint160(msg.sender),                // miner \\n                    uint32(block.number),               // atHeight\\n                    uint32(_newEthNum),                 // ethNum\\n                    uint32(_newEthNum),                 // remainNum\\n                    uint8(_newLevel),                   // level\\n                    uint8(_sheet.typ),                  // typ\\n                    uint8(MiningV1Data.PRICESHEET_STATE_POSTED),  // state \\n                    uint8(0),                           // _reserved\\n                    uint32(_newEthNum),                 // ethNumBal\\n                    uint32(_newEthNum),                 // tokenNumBal\\n                    uint32(_newNestNum1k),              // nestNum1k\\n                    uint128(newTokenAmountPerEth)     // tokenAmountPerEth\\n                ));\\n              \\n            }\\n\\n            // update the bitten sheet\\n            _sheet.state = MiningV1Data.PRICESHEET_STATE_BITTEN;\\n            _sheet.ethNumBal = uint32(uint256(_sheet.ethNumBal).add(biteNum));\\n            _sheet.tokenNumBal = uint32(uint256(_sheet.tokenNumBal).sub(biteNum));\\n            _sheet.remainNum = uint32(uint256(_sheet.remainNum).sub(biteNum));\\n            state.priceSheetList[token][index] = _sheet;\\n            \\n        }\\n\\n        emit MiningV1Data.TokenBought(address(msg.sender), address(token), index, biteNum.mul(1 ether), biteNum.mul(_sheet.tokenAmountPerEth));\\n        return; \\n\\n    }\\n\\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\\n    /// @param token The address of token(ntoken)\\n    /// @param index The position of the sheet in priceSheetList[token]\\n    /// @param biteNum The amount of bitting (in the unit of ETH), realAmount = biteNum * newTokenAmountPerEth\\n    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\\n    function _biteEth(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint256 index, \\n            uint256 biteNum, \\n            uint256 newTokenAmountPerEth\\n        )\\n        external\\n    {\\n        // check parameters\\n        require(token != address(0x0), \\\"Nest:Mine:(token)=0\\\"); \\n        require(newTokenAmountPerEth > 0, \\\"Nest:Mine:(price)=0\\\");\\n        require(biteNum >= state.miningEthUnit && biteNum % state.miningEthUnit == 0, \\\"Nest:Mine:!(bite)\\\");\\n\\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index]; \\n        require(uint256(_sheet.height) + state.priceDurationBlock >= block.number, \\\"Nest:Mine:!EFF(sheet)\\\");\\n        require(uint256(_sheet.remainNum) >= biteNum, \\\"Nest:Mine:!(remain)\\\");\\n\\n        // load NestPool\\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n\\n        // check state\\n        uint256 _state = uint256(_sheet.state);\\n        require(_state == MiningV1Data.PRICESHEET_STATE_POSTED \\n            || _state == MiningV1Data.PRICESHEET_STATE_BITTEN,  \\\"Nest:Mine:!(state)\\\");\\n\\n        {\\n            // load NTOKEN\\n            address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n\\n            // calculate fee\\n            uint256 _ethFee = biteNum.mul(1 ether).mul(state.biteFeeRate).div(1000);\\n\\n            // save the changes into miner's virtual account\\n            if (msg.value.sub(_ethFee) > 0) {\\n                _C_NestPool.depositEth{value:msg.value.sub(_ethFee)}(address(msg.sender));\\n            }\\n\\n            // pump fee into NestStaking\\n            INestStaking(state.C_NestStaking).addETHReward{value:_ethFee}(_ntoken);\\n        }\\n        \\n        // post a new price sheet\\n        { \\n            // check bitting conditions\\n            uint256 _newEthNum;\\n            uint256 _newNestNum1k = uint256(_sheet.nestNum1k);\\n            {\\n                uint256 _level = uint256(_sheet.level);\\n                uint256 _newLevel;\\n\\n                if (_level > state.maxBiteNestedLevel && _level < 127) { // bitten sheet, nest doubling\\n                    _newEthNum = biteNum;\\n                    _newNestNum1k = _newNestNum1k.mul(biteNum.mul(state.biteNestInflateFactor)).div(_sheet.ethNum);\\n                    _newLevel = _level + 1;\\n                } else if (_level <= state.maxBiteNestedLevel) {  // bitten sheet, eth doubling \\n                    _newEthNum = biteNum.mul(state.biteInflateFactor);\\n                    _newNestNum1k = _newNestNum1k.mul(biteNum.mul(state.biteNestInflateFactor)).div(_sheet.ethNum);\\n                    _newLevel = _level + 1;\\n                }\\n\\n                MiningV1Data.PriceSheet[] storage _sheetOfToken = state.priceSheetList[token];\\n                // append a new price sheet\\n                _sheetOfToken.push(MiningV1Data.PriceSheet(\\n                    uint160(msg.sender),             // miner \\n                    uint32(block.number),            // atHeight\\n                    uint32(_newEthNum),                 // ethNum\\n                    uint32(_newEthNum),                 // remainNum\\n                    uint8(_newLevel),                // level\\n                    uint8(_sheet.typ),               // typ\\n                    uint8(MiningV1Data.PRICESHEET_STATE_POSTED),  // state \\n                    uint8(0),                        // _reserved\\n                    uint32(_newEthNum),                 // ethNumBal\\n                    uint32(_newEthNum),                 // tokenNumBal\\n                    uint32(_newNestNum1k),           // nestNum1k\\n                    uint128(newTokenAmountPerEth)    // tokenAmountPerEth\\n                ));\\n            }\\n\\n            // freeze NEST \\n            _C_NestPool.freezeNest(address(msg.sender), _newNestNum1k.mul(1000 * 1e18));\\n\\n            // freeze(TOKEN, ETH)\\n            _C_NestPool.freezeEthAndToken(msg.sender, _newEthNum.sub(biteNum).mul(1 ether), \\n                token, _newEthNum.mul(newTokenAmountPerEth)\\n                                    .add(biteNum.mul(_sheet.tokenAmountPerEth)));\\n\\n            // update the bitten sheet\\n            _sheet.state = MiningV1Data.PRICESHEET_STATE_BITTEN;\\n            _sheet.ethNumBal = uint32(uint256(_sheet.ethNumBal).sub(biteNum));\\n            _sheet.tokenNumBal = uint32(uint256(_sheet.tokenNumBal).add(biteNum));\\n            _sheet.remainNum = uint32(uint256(_sheet.remainNum).sub(biteNum));\\n            state.priceSheetList[token][index] = _sheet;\\n        }\\n\\n        emit MiningV1Data.TokenSold(address(msg.sender), address(token), index, biteNum.mul(1 ether), biteNum.mul(_sheet.tokenAmountPerEth));\\n        return; \\n    }\\n\\n    /// @notice Close a price sheet of (ETH, USDx) | (ETH, NEST) | (ETH, TOKEN) | (ETH, NTOKEN)\\n    /// @dev Here we allow an empty price sheet (still in VERIFICATION-PERIOD) to be closed \\n    /// @param token The address of TOKEN contract\\n    /// @param index The index of the price sheet w.r.t. `token`\\n    function _close(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint256 index\\n        )\\n        external\\n    {\\n        // load sheet\\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index];\\n        // check if the sheet is closable\\n        require(uint256(_sheet.height) + state.priceDurationBlock < block.number // safe_math\\n            || _sheet.remainNum == 0, \\\"Nest:Mine:!(height)\\\");\\n\\n        // check owner\\n        require(address(_sheet.miner) == address(msg.sender), \\\"Nest:Mine:!(miner)\\\");\\n        // check state flag\\n        require(uint256(_sheet.state) != MiningV1Data.PRICESHEET_STATE_CLOSED, \\\"Nest:Mine:!unclosed\\\");\\n\\n        // load ntoken\\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n        address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n\\n        // distribute rewards (NEST or NTOKEN)\\n        {\\n            uint256 h = _sheet.height;\\n            if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_USD && _sheet.level == 0) {   // for (USDT, NEST)\\n                uint256 _nestH = uint256(state.minedAtHeight[token][h] / (1 << 128));\\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\\n                uint256 _reward = uint256(_sheet.ethNum).mul(_nestH).div(_ethH);\\n                _C_NestPool.addNest(address(msg.sender), _reward);\\n            } else if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_TOKEN && _sheet.level == 0) { // for (ERC20, NTOKEN)\\n                uint256 _ntokenH = uint256(state.minedAtHeight[token][h] / (1 << 128));\\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\\n                uint256 _reward = uint256(_sheet.ethNum).mul(_ntokenH).div(_ethH);\\n                _C_NestPool.addNToken(address(msg.sender), _ntoken, _reward);\\n            }\\n        }\\n\\n        // unfreeze the assets withheld by the sheet\\n        {\\n            uint256 _ethAmount = uint256(_sheet.ethNumBal).mul(1 ether);\\n            uint256 _tokenAmount = uint256(_sheet.tokenNumBal).mul(_sheet.tokenAmountPerEth);\\n            uint256 _nestAmount = uint256(_sheet.nestNum1k).mul(1000 * 1e18);\\n            _sheet.ethNumBal = 0;\\n            _sheet.tokenNumBal = 0;\\n            _sheet.nestNum1k = 0;\\n\\n            _C_NestPool.unfreezeEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\\n            _C_NestPool.unfreezeNest(address(msg.sender), _nestAmount); \\n        }\\n\\n        // update the state flag\\n        _sheet.state = MiningV1Data.PRICESHEET_STATE_CLOSED;\\n\\n        // write back\\n        state.priceSheetList[token][index] = _sheet;\\n\\n        // emit an event\\n        emit MiningV1Data.PriceClosed(address(msg.sender), token, index);\\n    }\\n\\n    /// @notice Close a price sheet and withdraw assets for WEB users.  \\n    /// @dev Contracts aren't allowed to call it.\\n    /// @param token The address of TOKEN contract\\n    /// @param index The index of the price sheet w.r.t. `token`\\n    function _closeAndWithdraw(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint256 index\\n        ) \\n        external \\n    {\\n        // check sheet if passing verification\\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index];\\n        require(uint256(_sheet.height) + state.priceDurationBlock < block.number // safe_math\\n            || _sheet.remainNum == 0, \\\"Nest:Mine:!(height)\\\");\\n\\n        // check ownership and state\\n        require(address(_sheet.miner) == address(msg.sender), \\\"Nest:Mine:!(miner)\\\");\\n        require(uint256(_sheet.state) != MiningV1Data.PRICESHEET_STATE_CLOSED, \\\"Nest:Mine:!unclosed\\\");\\n\\n        // get ntoken\\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n        address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n\\n        {\\n            uint256 h = uint256(_sheet.height);\\n            if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_USD && _sheet.level == 0) {\\n                uint256 _nestH = uint256(state.minedAtHeight[token][h] / (1 << 128));\\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\\n                uint256 _reward = uint256(_sheet.ethNum).mul(_nestH).div(_ethH);\\n                _C_NestPool.addNest(address(msg.sender), _reward);\\n            } else if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_TOKEN && _sheet.level == 0) {\\n                uint256 _ntokenH = uint256(state.minedAtHeight[token][h] / (1 << 128));\\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\\n                uint256 _reward = uint256(_sheet.ethNum).mul(_ntokenH).div(_ethH);\\n                _C_NestPool.addNToken(address(msg.sender), _ntoken, _reward);\\n            }\\n        }\\n\\n        {\\n            uint256 _ethAmount = uint256(_sheet.ethNumBal).mul(1 ether);\\n            uint256 _tokenAmount = uint256(_sheet.tokenNumBal).mul(_sheet.tokenAmountPerEth);\\n            uint256 _nestAmount = uint256(_sheet.nestNum1k).mul(1000 * 1e18);\\n            _sheet.ethNumBal = 0;\\n            _sheet.tokenNumBal = 0;\\n            _sheet.nestNum1k = 0;\\n\\n            _C_NestPool.unfreezeEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\\n            _C_NestPool.unfreezeNest(address(msg.sender), _nestAmount); \\n            _C_NestPool.withdrawEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\\n            _C_NestPool.withdrawNest(address(msg.sender), _nestAmount);\\n        }\\n\\n        /*  \\n        - Issue #23: \\n            Uncomment the following code to support withdrawing ethers cached \\n        {\\n            uint256 _ethAmount = _C_NestPool.balanceOfEthInPool(address(msg.sender));\\n            if (_ethAmount > 0) {\\n                _C_NestPool.withdrawEth(address(msg.sender), _ethAmount);\\n            }\\n        }\\n        */\\n\\n        _sheet.state = MiningV1Data.PRICESHEET_STATE_CLOSED;\\n\\n        state.priceSheetList[token][index] = _sheet;\\n\\n        emit MiningV1Data.PriceClosed(address(msg.sender), token, index);    \\n    }\\n\\n    /// @notice Close a batch of price sheets passed VERIFICATION-PHASE\\n    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\\n    /// @param token The address of TOKEN contract\\n    /// @param indices A list of indices of sheets w.r.t. `token`\\n    function _closeList(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint32[] memory indices) \\n        external \\n    {\\n        uint256 _ethAmount;\\n        uint256 _tokenAmount;\\n        uint256 _nestAmount;\\n        uint256 _reward;\\n\\n        // load storage point to the list of price sheets\\n        MiningV1Data.PriceSheet[] storage prices = state.priceSheetList[token];\\n        \\n        // loop\\n        for (uint i=0; i<indices.length; i++) {\\n            // load one sheet\\n            MiningV1Data.PriceSheet memory _sheet = prices[indices[i]];\\n\\n            // check owner\\n            if (uint256(_sheet.miner) != uint256(msg.sender)) {\\n                continue;\\n            }\\n\\n            // check state\\n            if(_sheet.state == MiningV1Data.PRICESHEET_STATE_CLOSED) {\\n                continue;\\n            }\\n\\n            uint256 h = uint256(_sheet.height);\\n            // check if the sheet closable\\n            if (h + state.priceDurationBlock < block.number || _sheet.remainNum == 0) { // safe_math: untainted values\\n\\n                // count up assets in the sheet\\n                _ethAmount = _ethAmount.add(uint256(_sheet.ethNumBal).mul(1 ether));\\n                _tokenAmount = _tokenAmount.add(uint256(_sheet.tokenNumBal).mul(_sheet.tokenAmountPerEth));\\n                _nestAmount = _nestAmount.add(uint256(_sheet.nestNum1k).mul(1000 * 1e18));\\n\\n                // clear bits in the sheet\\n                _sheet.ethNumBal = 0;\\n                _sheet.tokenNumBal = 0;\\n                _sheet.nestNum1k = 0;\\n                \\n                // update state flag\\n                _sheet.state = MiningV1Data.PRICESHEET_STATE_CLOSED;\\n                \\n                // write back\\n                prices[indices[i]] = _sheet;\\n\\n                // count up the reward\\n                if(_sheet.level == 0 && (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_USD || _sheet.typ == MiningV1Data.PRICESHEET_TYPE_TOKEN)) {\\n                    uint256 _ntokenH = uint256(state.minedAtHeight[token][h] >> 128);\\n                    uint256 _ethH = uint256(state.minedAtHeight[token][h] << 128 >> 128);\\n                    _reward = _reward.add(uint256(_sheet.ethNum).mul(_ntokenH).div(_ethH));\\n                }\\n                emit MiningV1Data.PriceClosed(address(msg.sender), token, indices[i]);\\n            }\\n        }\\n        \\n        // load address of NestPool (for gas saving)\\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\\n\\n        // unfreeze assets\\n        if (_ethAmount > 0 || _tokenAmount > 0) {\\n            _C_NestPool.unfreezeEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\\n        }\\n        _C_NestPool.unfreezeNest(address(msg.sender), _nestAmount); \\n\\n        // distribute the rewards\\n        {\\n            uint256 _typ = prices[indices[0]].typ;\\n            if  (_typ == MiningV1Data.PRICESHEET_TYPE_USD) {\\n                _C_NestPool.addNest(address(msg.sender), _reward);\\n            } else if (_typ == MiningV1Data.PRICESHEET_TYPE_TOKEN) {\\n                address _ntoken = _C_NestPool.getNTokenFromToken(token);\\n                _C_NestPool.addNToken(address(msg.sender), _ntoken, _reward);\\n            }\\n        }\\n    }\\n\\n    /*\\n    /// @dev This function is only for post dual-price-sheet before upgrading without assets\\n    function _post2Only4Upgrade(\\n            MiningV1Data.State storage state,\\n            address token,\\n            uint256 ethNum,\\n            uint256 tokenAmountPerEth,\\n            uint256 ntokenAmountPerEth\\n        )\\n        external \\n    {\\n        // check parameters \\n        require(ethNum == state.miningEthUnit, \\\"Nest:Mine:!(ethNum)\\\");\\n        require(tokenAmountPerEth > 0 && ntokenAmountPerEth > 0, \\\"Nest:Mine:!(price)\\\");\\n        address _ntoken = INestPool(state.C_NestPool).getNTokenFromToken(token);\\n\\n        // no eth fee, no freezing\\n\\n        // push sheets\\n        {\\n            uint8 typ1;\\n            uint8 typ2; \\n            if (_ntoken == address(state.C_NestToken)) {\\n                typ1 = MiningV1Data.PRICESHEET_TYPE_USD;\\n                typ2 = MiningV1Data.PRICESHEET_TYPE_NEST;\\n            } else {\\n                typ1 = MiningV1Data.PRICESHEET_TYPE_TOKEN;\\n                typ2 = MiningV1Data.PRICESHEET_TYPE_NTOKEN;\\n            }\\n            MiningV1Data.PriceSheet[] storage _sheetToken = state.priceSheetList[token];\\n            // append a new price sheet\\n            _sheetToken.push(MiningV1Data.PriceSheet(\\n                uint160(msg.sender),            // miner \\n                uint32(block.number),           // atHeight\\n                uint32(ethNum),                 // ethNum\\n                uint32(ethNum),                 // remainNum\\n                uint8(0),                       // level\\n                uint8(typ1),     // typ\\n                uint8(MiningV1Data.PRICESHEET_STATE_CLOSED), // state \\n                uint8(0),                       // _reserved\\n                uint32(ethNum),                 // ethNumBal\\n                uint32(ethNum),                 // tokenNumBal\\n                uint32(state.nestStakedNum1k),        // nestNum1k\\n                uint128(tokenAmountPerEth)      // tokenAmountPerEth\\n            ));\\n\\n            MiningV1Data.PriceSheet[] storage _sheetNToken = state.priceSheetList[_ntoken];\\n            // append a new price sheet for ntoken\\n            _sheetNToken.push(MiningV1Data.PriceSheet(\\n                uint160(msg.sender),            // miner \\n                uint32(block.number),           // atHeight\\n                uint32(ethNum),                 // ethNum\\n                uint32(ethNum),                 // remainNum\\n                uint8(0),                       // level\\n                uint8(typ2),     // typ\\n                uint8(MiningV1Data.PRICESHEET_STATE_CLOSED), // state \\n                uint8(0),                       // _reserved\\n                uint32(ethNum),                 // ethNumBal\\n                uint32(ethNum),                 // tokenNumBal\\n                uint32(state.nestStakedNum1k),        // nestNum1k\\n                uint128(ntokenAmountPerEth)      // tokenAmountPerEth\\n            ));\\n            emit MiningV1Data.PricePosted(msg.sender, token, (_sheetToken.length - 1), ethNum.mul(1 ether), tokenAmountPerEth.mul(ethNum)); \\n            emit MiningV1Data.PricePosted(msg.sender, _ntoken, (_sheetNToken.length - 1), ethNum.mul(1 ether), ntokenAmountPerEth.mul(ethNum)); \\n        }\\n\\n        // no mining\\n\\n        return; \\n    }\\n    */\\n\\n}\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n\\n    function div(uint x, uint y) internal pure returns (uint z) {\\n        require(y > 0, \\\"ds-math-div-zero\\\");\\n        z = x / y;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\ninterface ERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/lib/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Copyright © 2019 by ABDK Consulting\\n\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity 0.6.12;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /**\\n   * @dev Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /**\\n   * @dev Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    return int64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    require (x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    require (x >= 0);\\n    return uint64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    int256 result = x >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    return int256 (x) << 64;\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) + y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) - y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) * y >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    if (x == MIN_64x64) {\\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n        y <= 0x1000000000000000000000000000000000000000000000000);\\n      return -y << 63;\\n    } else {\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x;\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint256 absoluteResult = mulu (x, uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <=\\n          0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <=\\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (absoluteResult);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    if (y == 0) return 0;\\n\\n    require (x >= 0);\\n\\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n    uint256 hi = uint256 (x) * (y >> 128);\\n\\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    hi <<= 64;\\n\\n    require (hi <=\\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n    return hi + lo;\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    require (y != 0);\\n    int256 result = (int256 (x) << 64) / y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    require (y != 0);\\n\\n    bool negativeResult = false;\\n    if (x < 0) {\\n      x = -x; // We rely on overflow behavior here\\n      negativeResult = true;\\n    }\\n    if (y < 0) {\\n      y = -y; // We rely on overflow behavior here\\n      negativeResult = !negativeResult;\\n    }\\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n    if (negativeResult) {\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\n    } else {\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    require (y != 0);\\n    uint128 result = divuu (x, y);\\n    require (result <= uint128 (MAX_64x64));\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return -x;\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return x < 0 ? -x : x;\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    require (x != 0);\\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    return int128 ((int256 (x) + int256 (y)) >> 1);\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    int256 m = int256 (x) * int256 (y);\\n    require (m >= 0);\\n    require (m <\\n        0x4000000000000000000000000000000000000000000000000000000000000000);\\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    uint256 absoluteResult;\\n    bool negativeResult = false;\\n    if (x >= 0) {\\n      absoluteResult = powu (uint256 (x) << 63, y);\\n    } else {\\n      // We rely on overflow behavior here\\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\\n      negativeResult = y & 1 > 0;\\n    }\\n\\n    absoluteResult >>= 63;\\n\\n    if (negativeResult) {\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\n    } else {\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    require (x >= 0);\\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    int256 msb = 0;\\n    int256 xc = x;\\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n    int256 result = msb - 64 << 64;\\n    uint256 ux = uint256 (x) << 127 - msb;\\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n      ux *= ux;\\n      uint256 b = ux >> 255;\\n      ux >>= 127 + b;\\n      result += bit * int256 (b);\\n    }\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    return int128 (\\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    uint256 result = 0x80000000000000000000000000000000;\\n\\n    if (x & 0x8000000000000000 > 0)\\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n    if (x & 0x4000000000000000 > 0)\\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n    if (x & 0x2000000000000000 > 0)\\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n    if (x & 0x1000000000000000 > 0)\\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n    if (x & 0x800000000000000 > 0)\\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n    if (x & 0x400000000000000 > 0)\\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n    if (x & 0x200000000000000 > 0)\\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n    if (x & 0x100000000000000 > 0)\\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n    if (x & 0x80000000000000 > 0)\\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n    if (x & 0x40000000000000 > 0)\\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n    if (x & 0x20000000000000 > 0)\\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n    if (x & 0x10000000000000 > 0)\\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n    if (x & 0x8000000000000 > 0)\\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n    if (x & 0x4000000000000 > 0)\\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n    if (x & 0x2000000000000 > 0)\\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n    if (x & 0x1000000000000 > 0)\\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n    if (x & 0x800000000000 > 0)\\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n    if (x & 0x400000000000 > 0)\\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n    if (x & 0x200000000000 > 0)\\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n    if (x & 0x100000000000 > 0)\\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n    if (x & 0x80000000000 > 0)\\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n    if (x & 0x40000000000 > 0)\\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n    if (x & 0x20000000000 > 0)\\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n    if (x & 0x10000000000 > 0)\\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n    if (x & 0x8000000000 > 0)\\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n    if (x & 0x4000000000 > 0)\\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n    if (x & 0x2000000000 > 0)\\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n    if (x & 0x1000000000 > 0)\\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n    if (x & 0x800000000 > 0)\\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n    if (x & 0x400000000 > 0)\\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n    if (x & 0x200000000 > 0)\\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n    if (x & 0x100000000 > 0)\\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n    if (x & 0x80000000 > 0)\\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n    if (x & 0x40000000 > 0)\\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n    if (x & 0x20000000 > 0)\\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n    if (x & 0x10000000 > 0)\\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n    if (x & 0x8000000 > 0)\\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n    if (x & 0x4000000 > 0)\\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n    if (x & 0x2000000 > 0)\\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n    if (x & 0x1000000 > 0)\\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n    if (x & 0x800000 > 0)\\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n    if (x & 0x400000 > 0)\\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n    if (x & 0x200000 > 0)\\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n    if (x & 0x100000 > 0)\\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n    if (x & 0x80000 > 0)\\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n    if (x & 0x40000 > 0)\\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n    if (x & 0x20000 > 0)\\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n    if (x & 0x10000 > 0)\\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n    if (x & 0x8000 > 0)\\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n    if (x & 0x4000 > 0)\\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n    if (x & 0x2000 > 0)\\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n    if (x & 0x1000 > 0)\\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n    if (x & 0x800 > 0)\\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n    if (x & 0x400 > 0)\\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n    if (x & 0x200 > 0)\\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n    if (x & 0x100 > 0)\\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n    if (x & 0x80 > 0)\\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n    if (x & 0x40 > 0)\\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n    if (x & 0x20 > 0)\\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n    if (x & 0x10 > 0)\\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n    if (x & 0x8 > 0)\\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n    if (x & 0x4 > 0)\\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n    if (x & 0x2 > 0)\\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n    if (x & 0x1 > 0)\\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n    result >>= 63 - (x >> 64);\\n    require (result <= uint256 (MAX_64x64));\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    return exp_2 (\\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    require (y != 0);\\n\\n    uint256 result;\\n\\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      result = (x << 64) / y;\\n    else {\\n      uint256 msb = 192;\\n      uint256 xc = x >> 192;\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 hi = result * (y >> 128);\\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 xh = x >> 192;\\n      uint256 xl = x << 64;\\n\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n      lo = hi << 128;\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n\\n      assert (xh == hi >> 128);\\n\\n      result += xl / y;\\n    }\\n\\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    return uint128 (result);\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x unsigned 129.127-bit fixed point number\\n   * @param y uint256 value\\n   * @return unsigned 129.127-bit fixed point number\\n   */\\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\\n    if (y == 0) return 0x80000000000000000000000000000000;\\n    else if (x == 0) return 0;\\n    else {\\n      int256 msb = 0;\\n      uint256 xc = x;\\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      int256 xe = msb - 127;\\n      if (xe > 0) x >>= xe;\\n      else x <<= -xe;\\n\\n      uint256 result = 0x80000000000000000000000000000000;\\n      int256 re = 0;\\n\\n      while (y > 0) {\\n        if (y & 1 > 0) {\\n          result = result * x;\\n          y -= 1;\\n          re += xe;\\n          if (result >=\\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\\n            result >>= 128;\\n            re += 1;\\n          } else result >>= 127;\\n          if (re < -127) return 0; // Underflow\\n          require (re < 128); // Overflow\\n        } else {\\n          x = x * x;\\n          y >>= 1;\\n          xe <<= 1;\\n          if (x >=\\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\\n            x >>= 128;\\n            xe += 1;\\n          } else x >>= 127;\\n          if (xe < -127) return 0; // Underflow\\n          require (xe < 128); // Overflow\\n        }\\n      }\\n\\n      if (re > 0) result <<= re;\\n      else if (re < 0) result >>= -re;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\\n    if (x == 0) return 0;\\n    else {\\n      require (r > 0);\\n      while (true) {\\n        uint256 rr = x / r;\\n        if (r == rr || r + 1 == rr) return uint128 (r);\\n        else if (r == rr + 1) return uint128 (rr);\\n        r = r + rr + 1 >> 1;\\n      }\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/iface/INestPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\n\\ninterface INestPool {\\n\\n    // function getNTokenFromToken(address token) view external returns (address);\\n    // function setNTokenToToken(address token, address ntoken) external; \\n\\n    function addNest(address miner, uint256 amount) external;\\n    function addNToken(address contributor, address ntoken, uint256 amount) external;\\n\\n    function depositEth(address miner) external payable;\\n    function depositNToken(address miner,  address from, address ntoken, uint256 amount) external;\\n\\n    function freezeEth(address miner, uint256 ethAmount) external; \\n    function unfreezeEth(address miner, uint256 ethAmount) external;\\n\\n    function freezeNest(address miner, uint256 nestAmount) external;\\n    function unfreezeNest(address miner, uint256 nestAmount) external;\\n\\n    function freezeToken(address miner, address token, uint256 tokenAmount) external; \\n    function unfreezeToken(address miner, address token, uint256 tokenAmount) external;\\n\\n    function freezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n    function unfreezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n\\n    function getNTokenFromToken(address token) external view returns (address); \\n    function setNTokenToToken(address token, address ntoken) external; \\n\\n    function withdrawEth(address miner, uint256 ethAmount) external;\\n    function withdrawToken(address miner, address token, uint256 tokenAmount) external;\\n\\n    function withdrawNest(address miner, uint256 amount) external;\\n    function withdrawEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n    // function withdrawNToken(address miner, address ntoken, uint256 amount) external;\\n    function withdrawNTokenAndTransfer(address miner, address ntoken, uint256 amount, address to) external;\\n\\n\\n    function balanceOfNestInPool(address miner) external view returns (uint256);\\n    function balanceOfEthInPool(address miner) external view returns (uint256);\\n    function balanceOfTokenInPool(address miner, address token)  external view returns (uint256);\\n\\n    function addrOfNestToken() external view returns (address);\\n    function addrOfNestMining() external view returns (address);\\n    function addrOfNTokenController() external view returns (address);\\n    function addrOfNNRewardPool() external view returns (address);\\n    function addrOfNNToken() external view returns (address);\\n    function addrOfNestStaking() external view returns (address);\\n    function addrOfNestQuery() external view returns (address);\\n    function addrOfNestDAO() external view returns (address);\\n\\n    function addressOfBurnedNest() external view returns (address);\\n\\n    function setGovernance(address _gov) external; \\n    function governance() external view returns(address);\\n    function initNestLedger(uint256 amount) external;\\n    function drainNest(address to, uint256 amount, address gov) external;\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INestStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n\\ninterface INestStaking {\\n    // Views\\n\\n    /// @dev How many stakingToken (XToken) deposited into to this reward pool (staking pool)\\n    /// @param  ntoken The address of NToken\\n    /// @return The total amount of XTokens deposited in this staking pool\\n    function totalStaked(address ntoken) external view returns (uint256);\\n\\n    /// @dev How many stakingToken (XToken) deposited by the target account\\n    /// @param  ntoken The address of NToken\\n    /// @param  account The target account\\n    /// @return The total amount of XToken deposited in this staking pool\\n    function stakedBalanceOf(address ntoken, address account) external view returns (uint256);\\n\\n\\n    // Mutative\\n    /// @dev Stake/Deposit into the reward pool (staking pool)\\n    /// @param  ntoken The address of NToken\\n    /// @param  amount The target amount\\n    function stake(address ntoken, uint256 amount) external;\\n\\n    function stakeFromNestPool(address ntoken, uint256 amount) external;\\n\\n    /// @dev Withdraw from the reward pool (staking pool), get the original tokens back\\n    /// @param  ntoken The address of NToken\\n    /// @param  amount The target amount\\n    function unstake(address ntoken, uint256 amount) external;\\n\\n    /// @dev Claim the reward the user earned\\n    /// @param ntoken The address of NToken\\n    /// @return The amount of ethers as rewards\\n    function claim(address ntoken) external returns (uint256);\\n\\n    /// @dev Add ETH reward to the staking pool\\n    /// @param ntoken The address of NToken\\n    function addETHReward(address ntoken) external payable;\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external; \\n\\n    function pause() external;\\n\\n    function resume() external;\\n\\n    //function setParams(uint8 dividendShareRate) external;\\n\\n    /* ========== EVENTS ========== */\\n\\n    // Events\\n    event RewardAdded(address ntoken, address sender, uint256 reward);\\n    event NTokenStaked(address ntoken, address indexed user, uint256 amount);\\n    event NTokenUnstaked(address ntoken, address indexed user, uint256 amount);\\n    event SavingWithdrawn(address ntoken, address indexed to, uint256 amount);\\n    event RewardClaimed(address ntoken, address indexed user, uint256 reward);\\n\\n    event FlagSet(address gov, uint256 flag);\\n}\"\r\n    },\r\n    \"contracts/iface/INTokenLegacy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\ninterface INTokenLegacy {\\n    function increaseTotal(uint256 value) external;\\n\\n    // the block height where the ntoken was created\\n    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\\n    // the owner (auction winner) of the ntoken\\n    function checkBidder() external view returns(address);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/iface/INestMining.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\n\\n\\ninterface INestMining {\\n    \\n    struct Params {\\n        uint8    miningEthUnit;     // = 10;\\n        uint32   nestStakedNum1k;   // = 1;\\n        uint8    biteFeeRate;       // = 1; \\n        uint8    miningFeeRate;     // = 10;\\n        uint8    priceDurationBlock; \\n        uint8    maxBiteNestedLevel; // = 3;\\n        uint8    biteInflateFactor;\\n        uint8    biteNestInflateFactor;\\n    }\\n\\n    function priceOf(address token) external view returns(uint256 ethAmount, uint256 tokenAmount, uint256 bn);\\n    \\n    function priceListOfToken(address token, uint8 num) external view returns(uint128[] memory data, uint256 bn);\\n\\n    // function priceOfTokenAtHeight(address token, uint64 atHeight) external view returns(uint256 ethAmount, uint256 tokenAmount, uint64 bn);\\n\\n    function latestPriceOf(address token) external view returns (uint256 ethAmount, uint256 tokenAmount, uint256 bn);\\n\\n    function priceAvgAndSigmaOf(address token) \\n        external view returns (uint128, uint128, int128, uint32);\\n\\n    function minedNestAmount() external view returns (uint256);\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n    \\n    function loadGovernance() external;\\n\\n    function upgrade() external;\\n\\n    function setup(uint32   genesisBlockNumber, uint128  latestMiningHeight, uint128  minedNestTotalAmount, Params calldata initParams) external;\\n\\n    function setParams1(uint128  latestMiningHeight, uint128  minedNestTotalAmount) external;\\n}\"\r\n    },\r\n    \"contracts/iface/INestDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\ninterface INestDAO {\\n\\n    function addETHReward(address ntoken) external payable; \\n\\n    function addNestReward(uint256 amount) external;\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external;\\n    \\n    /// @dev Only for governance\\n    function start() external; \\n\\n    function initEthLedger(address ntoken, uint256 amount) external;\\n\\n    event NTokenRedeemed(address ntoken, address user, uint256 amount);\\n\\n    event AssetsCollected(address user, uint256 ethAmount, uint256 nestAmount);\\n\\n    event ParamsSetup(address gov, uint256 oldParam, uint256 newParam);\\n\\n    event FlagSet(address gov, uint256 flag);\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\ninterface INToken {\\n    // mint ntoken for value\\n    function mint(uint256 amount, address account) external;\\n\\n    // the block height where the ntoken was created\\n    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\\n    // the owner (auction winner) of the ntoken\\n    function checkBidder() external view returns(address);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INNRewardPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n/// @title NNRewardPool\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author Paradox  - <paradox@nestprotocol.org>\\n\\ninterface INNRewardPool {\\n    \\n    /* [DEPRECATED]\\n        uint256 constant DEV_REWARD_PERCENTAGE   = 5;\\n        uint256 constant NN_REWARD_PERCENTAGE    = 15;\\n        uint256 constant MINER_REWARD_PERCENTAGE = 80;\\n    */\\n\\n    /// @notice Add rewards for Nest-Nodes, only governance or NestMining (contract) are allowed\\n    /// @dev  The rewards need to pull from NestPool\\n    /// @param _amount The amount of Nest token as the rewards to each nest-node\\n    function addNNReward(uint256 _amount) external;\\n\\n    /// @notice Claim rewards by Nest-Nodes\\n    /// @dev The rewards need to pull from NestPool\\n    function claimNNReward() external ;  \\n\\n    /// @dev The callback function called by NNToken.transfer()\\n    /// @param fromAdd The address of 'from' to transfer\\n    /// @param toAdd The address of 'to' to transfer\\n    function nodeCount(address fromAdd, address toAdd) external;\\n\\n    /// @notice Show the amount of rewards unclaimed\\n    /// @return reward The reward of a NN holder\\n    function unclaimedNNReward() external view returns (uint256 reward);\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external; \\n\\n    /* ========== EVENTS ============== */\\n\\n    /// @notice When rewards are added to the pool\\n    /// @param reward The amount of Nest Token\\n    /// @param allRewards The snapshot of all rewards accumulated\\n    event NNRewardAdded(uint256 reward, uint256 allRewards);\\n\\n    /// @notice When rewards are claimed by nodes \\n    /// @param nnode The address of the nest node\\n    /// @param share The amount of Nest Token claimed by the nest node\\n    event NNRewardClaimed(address nnode, uint256 share);\\n\\n    /// @notice When flag of state is set by governance \\n    /// @param gov The address of the governance\\n    /// @param flag The value of the new flag\\n    event FlagSet(address gov, uint256 flag);\\n}\"\r\n    },\r\n    \"contracts/lib/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n        (bool success, ) = recipient.call{value:amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libminingv1/MiningV1Calc.sol\": {\r\n        \"MiningV1Calc\": \"0x265b6c10c606cd1c79545799ebe36bca9ce124a5\"\r\n      },\r\n      \"contracts/libminingv1/MiningV1Op.sol\": {\r\n        \"MiningV1Op\": \"0xfe543efe9bb91b51a046157b73fdf0838833b841\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"addrOfGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"biteNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newTokenAmountPerEth\",\"type\":\"uint256\"}],\"name\":\"biteEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"biteNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newTokenAmountPerEth\",\"type\":\"uint256\"}],\"name\":\"biteToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"closeAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"indices\",\"type\":\"uint32[]\"}],\"name\":\"closeList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"fullPriceSheet\",\"outputs\":[{\"components\":[{\"internalType\":\"uint160\",\"name\":\"miner\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"height\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ethNum\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"remainNum\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"typ\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_reserved\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"ethNumBal\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"tokenNumBal\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"nestNum1k\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"tokenAmountPerEth\",\"type\":\"uint128\"}],\"internalType\":\"struct MiningV1Data.PriceSheet\",\"name\":\"sheet\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"NestPool\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestMinedHeight\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"latestPriceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"lengthOfPriceSheets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loadContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loadGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"mineNToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mineNest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minedNestAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parameters\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"miningEthUnit\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"nestStakedNum1k\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"biteFeeRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"miningFeeRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"priceDurationBlock\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxBiteNestedLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"biteInflateFactor\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"biteNestInflateFactor\",\"type\":\"uint8\"}],\"internalType\":\"struct NestMiningV1.Params\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountPerEth\",\"type\":\"uint256\"}],\"name\":\"post\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountPerEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ntokenAmountPerEth\",\"type\":\"uint256\"}],\"name\":\"post2\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"priceAvgAndSigmaOf\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"avgPrice\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"vola\",\"type\":\"int128\"},{\"internalType\":\"uint32\",\"name\":\"bn\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"num\",\"type\":\"uint8\"}],\"name\":\"priceListOfToken\",\"outputs\":[{\"internalType\":\"uint128[]\",\"name\":\"data\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256\",\"name\":\"bn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"priceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"atHeight\",\"type\":\"uint64\"}],\"name\":\"priceOfTokenAtHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"priceSheet\",\"outputs\":[{\"components\":[{\"internalType\":\"uint160\",\"name\":\"miner\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"height\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ethNum\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"typ\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"ethNumBal\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"tokenNumBal\",\"type\":\"uint32\"}],\"internalType\":\"struct MiningV1Data.PriceSheetPub\",\"name\":\"sheet\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"miningEthUnit\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"nestStakedNum1k\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"biteFeeRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"miningFeeRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"priceDurationBlock\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxBiteNestedLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"biteInflateFactor\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"biteNestInflateFactor\",\"type\":\"uint8\"}],\"internalType\":\"struct NestMiningV1.Params\",\"name\":\"newParams\",\"type\":\"tuple\"}],\"name\":\"setParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"latestMiningHeight\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minedNestTotalAmount\",\"type\":\"uint128\"}],\"name\":\"setParams1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"genesisBlockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"latestMiningHeight\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minedNestTotalAmount\",\"type\":\"uint128\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"miningEthUnit\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"nestStakedNum1k\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"biteFeeRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"miningFeeRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"priceDurationBlock\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maxBiteNestedLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"biteInflateFactor\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"biteNestInflateFactor\",\"type\":\"uint8\"}],\"internalType\":\"struct NestMiningV1.Params\",\"name\":\"initParams\",\"type\":\"tuple\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"sheetListOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint160\",\"name\":\"miner\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"height\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ethNum\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"remainNum\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"typ\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nestNum1k\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"tokenAmountPerEth\",\"type\":\"uint128\"}],\"internalType\":\"struct MiningV1Data.PriceSheetPub2[]\",\"name\":\"sheets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"stat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"unClosedSheetListOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint160\",\"name\":\"miner\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"height\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ethNum\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"remainNum\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"typ\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nestNum1k\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"tokenAmountPerEth\",\"type\":\"uint128\"}],\"internalType\":\"struct MiningV1Data.PriceSheetPub2[]\",\"name\":\"sheets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unVerifiedSheetList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint160\",\"name\":\"miner\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"height\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ethNum\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"remainNum\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"typ\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nestNum1k\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"tokenAmountPerEth\",\"type\":\"uint128\"}],\"internalType\":\"struct MiningV1Data.PriceSheetPub2[]\",\"name\":\"sheets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawEthAndToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nestAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawEthAndTokenAndNest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nestAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawNest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"NestMiningV1","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}