{"status":"1","message":"OK","result":[{"SourceCode":"# Created by interfinex.io\r\n# - The Greeks\r\n\r\ninterface ERC20:\r\n    def approve(_spender : address, _value : uint256) -> bool: nonpayable\r\n    def transferFrom(_from : address, _to : address, _value : uint256) -> bool: nonpayable\r\n\r\ninterface Exchange:\r\n    def initialize_exchange(\r\n        _base_token: address, \r\n        _asset_token: address, \r\n        _fee_rate: uint256, \r\n        _erc20_dividend_template: address, \r\n        _factory_contract: address,\r\n        _ifex_token_contract: address\r\n    ): nonpayable\r\n    def mint_liquidity(\r\n        base_token_amount: uint256, \r\n        min_asset_token_amount: uint256, \r\n        max_asset_token_amount: uint256, \r\n        recipient: address, \r\n        deadline: uint256\r\n    ): nonpayable\r\n\r\nevent NewExchange:\r\n    creator: address\r\n    exchange_contract: indexed(address)\r\n    base_token: indexed(address)\r\n    asset_token: indexed(address)\r\n\r\nexchange_template: public(address)\r\nerc20_dividend_template: public(address)\r\n\r\nifex_token_contract: public(address)\r\n\r\npair_to_exchange: public(HashMap[address, HashMap[address, address]])\r\nexchange_to_pair: public(HashMap[address, address[2]])\r\nexchange_count: public(uint256)\r\nid_to_exchange: public(HashMap[uint256, address])\r\n\r\nfee_rate: public(uint256)\r\n\r\n@external\r\ndef initialize_factory(_fee_rate: uint256, _exchange_template: address, _erc20_dividend_template: address, _ifex_token_contract: address,):\r\n    assert self.exchange_template == ZERO_ADDRESS and self.erc20_dividend_template == ZERO_ADDRESS\r\n    assert _exchange_template != ZERO_ADDRESS and _erc20_dividend_template != ZERO_ADDRESS\r\n\r\n    self.exchange_template = _exchange_template\r\n    self.ifex_token_contract = _ifex_token_contract\r\n    self.erc20_dividend_template = _erc20_dividend_template\r\n    self.fee_rate = _fee_rate\r\n\r\n@internal\r\ndef _create_exchange(_token0: address, _token1: address, _token0_amount: uint256, _token1_amount: uint256, creator: address) -> address:\r\n    assert _token0 != ZERO_ADDRESS and _token1 != ZERO_ADDRESS, \"asset_token and base_token must be valid addresses\"\r\n    assert self.exchange_template != ZERO_ADDRESS, \"exchange_template must have been initialized\"\r\n    assert self.pair_to_exchange[_token0][_token1] == ZERO_ADDRESS and self.pair_to_exchange[_token1][_token0] == ZERO_ADDRESS, \"Exchange contract cannot already exist for pair\"\r\n    assert _token0_amount > 0 and _token1_amount > 0, \"Must deposit at least some liquidity\"\r\n\r\n    uint256_token0: uint256 = convert(_token0, uint256)\r\n    uint256_token1: uint256 = convert(_token1, uint256)\r\n    token0: address = _token0\r\n    token1: address = _token1\r\n    token0_amount: uint256 = _token0_amount\r\n    token1_amount: uint256 = _token1_amount\r\n    if (uint256_token0 > uint256_token1):\r\n        token0 = _token1\r\n        token1 = _token0\r\n        token0_amount = _token1_amount\r\n        token1_amount = _token0_amount\r\n\r\n    exchange: address = create_forwarder_to(self.exchange_template)\r\n    \r\n    ERC20(token0).approve(exchange, MAX_UINT256)\r\n    ERC20(token1).approve(exchange, MAX_UINT256)\r\n\r\n    Exchange(exchange).initialize_exchange(\r\n        token0, \r\n        token1, \r\n        self.fee_rate, \r\n        self.erc20_dividend_template,\r\n        self,\r\n        self.ifex_token_contract\r\n    )\r\n\r\n    Exchange(exchange).mint_liquidity(\r\n        token0_amount, \r\n        token1_amount, \r\n        token1_amount, \r\n        creator,\r\n        0,\r\n    )\r\n\r\n    self.pair_to_exchange[token0][token1] = exchange\r\n    self.pair_to_exchange[token1][token0] = exchange\r\n    self.exchange_to_pair[exchange] = [token0, token1]\r\n\r\n    self.id_to_exchange[self.exchange_count] = exchange\r\n    self.exchange_count += 1\r\n\r\n    log NewExchange(creator, exchange, token0, token1)\r\n    return exchange\r\n    \r\n@external\r\ndef create_exchange(base_token: address, asset_token: address, base_token_amount: uint256, asset_token_amount: uint256, ifex_token_amount: uint256):\r\n    ERC20(base_token).transferFrom(msg.sender, self, base_token_amount)\r\n    ERC20(asset_token).transferFrom(msg.sender, self, asset_token_amount)\r\n    ERC20(self.ifex_token_contract).transferFrom(msg.sender, self, ifex_token_amount)\r\n\r\n    # Create the ifex exchange so that ifex tokens can be bought and paid out in dividends\r\n    if base_token != self.ifex_token_contract and asset_token != self.ifex_token_contract:\r\n        if self.pair_to_exchange[base_token][self.ifex_token_contract] == ZERO_ADDRESS:\r\n            self._create_exchange(base_token, self.ifex_token_contract, base_token_amount * 10 / 100, ifex_token_amount * 50 / 100, msg.sender)\r\n        \r\n        if self.pair_to_exchange[asset_token][self.ifex_token_contract] == ZERO_ADDRESS:\r\n            self._create_exchange(asset_token, self.ifex_token_contract, asset_token_amount * 10 / 100, ifex_token_amount * 50 / 100, msg.sender) \r\n\r\n    deposit_percentage: uint256 = 90\r\n    if base_token == self.ifex_token_contract or asset_token == self.ifex_token_contract: \r\n        deposit_percentage = 100\r\n\r\n    self._create_exchange(base_token, asset_token, base_token_amount * deposit_percentage / 100, asset_token_amount * deposit_percentage / 100, msg.sender)","ABI":"[{\"name\":\"NewExchange\",\"inputs\":[{\"type\":\"address\",\"name\":\"creator\",\"indexed\":false},{\"type\":\"address\",\"name\":\"exchange_contract\",\"indexed\":true},{\"type\":\"address\",\"name\":\"base_token\",\"indexed\":true},{\"type\":\"address\",\"name\":\"asset_token\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"initialize_factory\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_fee_rate\"},{\"type\":\"address\",\"name\":\"_exchange_template\"},{\"type\":\"address\",\"name\":\"_erc20_dividend_template\"},{\"type\":\"address\",\"name\":\"_ifex_token_contract\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":142278},{\"name\":\"create_exchange\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"base_token\"},{\"type\":\"address\",\"name\":\"asset_token\"},{\"type\":\"uint256\",\"name\":\"base_token_amount\"},{\"type\":\"uint256\",\"name\":\"asset_token_amount\"},{\"type\":\"uint256\",\"name\":\"ifex_token_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":830891},{\"name\":\"exchange_template\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1241},{\"name\":\"erc20_dividend_template\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1271},{\"name\":\"ifex_token_contract\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1301},{\"name\":\"pair_to_exchange\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"},{\"type\":\"address\",\"name\":\"arg1\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1639},{\"name\":\"exchange_to_pair\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"},{\"type\":\"uint256\",\"name\":\"arg1\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1624},{\"name\":\"exchange_count\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1391},{\"name\":\"id_to_exchange\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1536},{\"name\":\"fee_rate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1451}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.4","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}