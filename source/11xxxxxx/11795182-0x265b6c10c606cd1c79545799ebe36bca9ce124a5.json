{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libminingv1/MiningV1Calc.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/SafeMath.sol\\\";\\nimport \\\"../lib/SafeERC20.sol\\\";\\nimport '../lib/TransferHelper.sol';\\nimport \\\"../lib/ABDKMath64x64.sol\\\";\\n\\nimport \\\"../iface/INestPool.sol\\\";\\nimport \\\"../iface/INestStaking.sol\\\";\\nimport \\\"../iface/INToken.sol\\\";\\nimport \\\"../iface/INNRewardPool.sol\\\";\\nimport \\\"../libminingv1/MiningV1Data.sol\\\";\\n//import \\\"hardhat/console.sol\\\";\\n\\n\\n/// @title  NestMiningV1/MiningV1Calc\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author Paradox  - <paradox@nestprotocol.org>\\nlibrary MiningV1Calc {\\n\\n    using SafeMath for uint256;\\n    \\n    /// @dev Average block mining interval, ~ 14s\\n    uint256 constant ETHEREUM_BLOCK_TIMESPAN = 14;\\n\\n    function _calcVola(\\n            // uint256 ethA0, \\n            uint256 tokenA0, \\n            // uint256 ethA1, \\n            uint256 tokenA1, \\n            int128 _sigma_sq, \\n            int128 _ut_sq,\\n            uint256 _interval\\n        )\\n        private\\n        pure\\n        // pure \\n        returns (int128, int128)\\n    {\\n        int128 _ut_sq_2 = ABDKMath64x64.div(_ut_sq, \\n            ABDKMath64x64.fromUInt(_interval.mul(ETHEREUM_BLOCK_TIMESPAN)));\\n\\n        int128 _new_sigma_sq = ABDKMath64x64.add(\\n            ABDKMath64x64.mul(ABDKMath64x64.divu(95, 100), _sigma_sq),\\n            ABDKMath64x64.mul(ABDKMath64x64.divu(5,100), _ut_sq_2));\\n\\n        int128 _new_ut_sq;\\n        _new_ut_sq = ABDKMath64x64.pow(ABDKMath64x64.sub(\\n                    ABDKMath64x64.divu(tokenA1, tokenA0), \\n                    ABDKMath64x64.fromUInt(1)), \\n                2);\\n        \\n        return (_new_sigma_sq, _new_ut_sq);\\n    }\\n\\n    function _calcAvg(uint256 ethA, uint256 tokenA, uint256 _avg)\\n        private \\n        pure\\n        returns(uint256)\\n    {\\n        uint256 _newP = tokenA.div(ethA);\\n        uint256 _newAvg;\\n\\n        if (_avg == 0) {\\n            _newAvg = _newP;\\n        } else {\\n            _newAvg = (_avg.mul(95).div(100)).add(_newP.mul(5).div(100));\\n            // _newAvg = ABDKMath64x64.add(\\n            //     ABDKMath64x64.mul(ABDKMath64x64.divu(95, 100), _avg),\\n            //     ABDKMath64x64.mul(ABDKMath64x64.divu(5,100), _newP));\\n        }\\n\\n        return _newAvg;\\n    }\\n\\n    function _moveAndCalc(\\n            MiningV1Data.PriceInfo memory p0,\\n            MiningV1Data.PriceSheet[] storage pL,\\n            uint256 priceDurationBlock\\n        )\\n        private\\n        view\\n        returns (MiningV1Data.PriceInfo memory)\\n    {\\n        uint256 i = p0.index + 1;\\n        if (i >= pL.length) {\\n            return (MiningV1Data.PriceInfo(0,0,0,0,0,int128(0),int128(0), uint128(0), 0));\\n        }\\n\\n        uint256 h = uint256(pL[i].height);\\n        if (h + priceDurationBlock >= block.number) {\\n            return (MiningV1Data.PriceInfo(0,0,0,0,0,int128(0),int128(0), uint128(0), 0));\\n        }\\n\\n        uint256 ethA1 = 0;\\n        uint256 tokenA1 = 0;\\n        while (i < pL.length && pL[i].height == h) {\\n            uint256 _remain = uint256(pL[i].remainNum);\\n            if (_remain == 0) {\\n                i = i + 1;\\n                continue;  // jump over a bitten sheet\\n            }\\n            ethA1 = ethA1 + _remain;\\n            tokenA1 = tokenA1 + _remain.mul(pL[i].tokenAmountPerEth);\\n            i = i + 1;\\n        }\\n        i = i - 1;\\n\\n        if (ethA1 == 0 || tokenA1 == 0) {\\n            return (MiningV1Data.PriceInfo(\\n                    uint32(i),  // index\\n                    uint32(0),  // height\\n                    uint32(0),  // ethNum\\n                    uint32(0),  // _reserved\\n                    uint32(0),  // tokenAmount\\n                    int128(0),  // volatility_sigma_sq\\n                    int128(0),  // volatility_ut_sq\\n                    uint128(0),  // avgTokenAmount\\n                    0           // _reserved2\\n            ));\\n        }\\n        int128 new_sigma_sq;\\n        int128 new_ut_sq;\\n        {\\n            if (uint256(p0.ethNum) != 0) {\\n                (new_sigma_sq, new_ut_sq) = _calcVola(\\n                    uint256(p0.tokenAmount).div(uint256(p0.ethNum)), \\n                    uint256(tokenA1).div(uint256(ethA1)),\\n                p0.volatility_sigma_sq, p0.volatility_ut_sq,\\n                h - p0.height);\\n            }\\n        }\\n        uint256 _newAvg = _calcAvg(ethA1, tokenA1, p0.avgTokenAmount); \\n\\n        return(MiningV1Data.PriceInfo(\\n                uint32(i),          // index\\n                uint32(h),          // height\\n                uint32(ethA1),      // ethNum\\n                uint32(0),          // _reserved\\n                uint128(tokenA1),   // tokenAmount\\n                new_sigma_sq,       // volatility_sigma_sq\\n                new_ut_sq,          // volatility_ut_sq\\n                uint128(_newAvg),   // avgTokenAmount\\n                uint128(0)          // _reserved2\\n        ));\\n    }\\n\\n    /// @dev The function updates the statistics of price sheets\\n    ///     It calculates from priceInfo to the newest that is effective.\\n    ///     Different from `_statOneBlock()`, it may cross multiple blocks.\\n    function _stat(MiningV1Data.State storage state, address token)\\n        external \\n    {\\n        MiningV1Data.PriceInfo memory p0 = state.priceInfo[token];\\n        MiningV1Data.PriceSheet[] storage pL = state.priceSheetList[token];\\n\\n        if (pL.length < 2) {\\n            return;\\n        }\\n\\n        if (p0.height == 0) {\\n\\n            MiningV1Data.PriceSheet memory _sheet = pL[0];\\n            p0.ethNum = _sheet.ethNum;\\n            p0.tokenAmount = uint128(uint256(_sheet.tokenAmountPerEth).mul(_sheet.ethNum));\\n            p0.height = _sheet.height;\\n            p0.volatility_sigma_sq = 0;\\n            p0.volatility_ut_sq = 0;\\n            p0.avgTokenAmount = uint128(_sheet.tokenAmountPerEth);\\n            // write back\\n            state.priceInfo[token] = p0;\\n        }\\n\\n        MiningV1Data.PriceInfo memory p1;\\n\\n        // record the gas usage\\n        uint256 startGas = gasleft();\\n        uint256 gasUsed;\\n\\n        while (uint256(p0.index) < pL.length && uint256(p0.height) + state.priceDurationBlock < block.number){\\n            gasUsed = startGas - gasleft();\\n            // NOTE: check gas usage to prevent DOS attacks\\n            if (gasUsed > 1_000_000) {\\n                break; \\n            }\\n            p1 = _moveAndCalc(p0, pL, state.priceDurationBlock);\\n            if (p1.index <= p0.index) {    // bootstraping\\n                break;\\n            } else if (p1.ethNum == 0) {   // jump cross a block with bitten prices\\n                p0.index = p1.index;\\n                continue;\\n            } else {                       // calculate one more block\\n                p0 = p1;\\n            }\\n        }\\n\\n        if (p0.index > state.priceInfo[token].index) {\\n            state.priceInfo[token] = p0;\\n        }\\n\\n        return;\\n    }\\n\\n    /// @dev The function updates the statistics of price sheets across only one block.\\n    function _statOneBlock(MiningV1Data.State storage state, address token) \\n        external \\n    {\\n        MiningV1Data.PriceInfo memory p0 = state.priceInfo[token];\\n        MiningV1Data.PriceSheet[] storage pL = state.priceSheetList[token];\\n        if (pL.length < 2) {\\n            return;\\n        }\\n        (MiningV1Data.PriceInfo memory p1) = _moveAndCalc(p0, state.priceSheetList[token], state.priceDurationBlock);\\n        if (p1.index > p0.index && p1.ethNum != 0) {\\n            state.priceInfo[token] = p1;\\n        } else if (p1.index > p0.index && p1.ethNum == 0) {\\n            p0.index = p1.index;\\n            state.priceInfo[token] = p1;\\n        }\\n        return;\\n    }\\n\\n    /// @notice Return a consecutive price list for a token \\n    /// @dev \\n    /// @param token The address of token contract\\n    /// @param num   The length of price list\\n    function _priceListOfToken(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint8 num\\n        )\\n        external \\n        view\\n        returns (uint128[] memory data, uint256 bn) \\n    {\\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token];\\n        uint256 len = _list.length;\\n        uint256 _index = 0;\\n        data = new uint128[](num * 3);\\n        MiningV1Data.PriceSheet memory _sheet;\\n        uint256 _ethNum;\\n\\n        // loop\\n        uint256 _curr = 0;\\n        uint256 _prev = 0;\\n        for (uint i = 1; i <= len; i++) {\\n            _sheet = _list[len - i];\\n            _curr = uint256(_sheet.height);\\n            if (_prev == 0) {\\n                if (_curr + state.priceDurationBlock < block.number) {\\n                    _ethNum = uint256(_sheet.remainNum);\\n                    if(_ethNum > 0) {\\n                        data[_index] = uint128(_curr + state.priceDurationBlock); // safe math\\n                        data[_index + 1] = uint128(_ethNum.mul(1 ether));\\n                        data[_index + 2] = uint128(_ethNum.mul(_sheet.tokenAmountPerEth));\\n                        bn = _curr + state.priceDurationBlock;  // safe math\\n                        _prev = _curr;\\n                    }\\n                }\\n            } else if (_prev == _curr) {\\n                _ethNum = uint256(_sheet.remainNum);\\n                data[_index + 1] += uint128(_ethNum.mul(1 ether));\\n                data[_index + 2] += uint128(_ethNum.mul(_sheet.tokenAmountPerEth));\\n            } else if (_prev > _curr) {\\n                _ethNum = uint256(_sheet.remainNum);\\n                if(_ethNum > 0){\\n                    _index += 3;\\n                    if (_index >= uint256(num * 3)) {\\n                        break;\\n                    }\\n                    data[_index] = uint128(_curr + state.priceDurationBlock); // safe math\\n                    data[_index + 1] = uint128(_ethNum.mul(1 ether));\\n                    data[_index + 2] = uint128(_ethNum.mul(_sheet.tokenAmountPerEth));\\n                    _prev = _curr;\\n                }\\n            }\\n        } \\n        // require (data.length == uint256(num * 3), \\\"Incorrect price list length\\\");\\n    }\\n\\n    function _priceOfTokenAtHeight(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint64 atHeight\\n        )\\n        external \\n        view \\n        returns(uint256 ethAmount, uint256 tokenAmount, uint256 blockNum) \\n    {\\n        require(atHeight <= block.number, \\\"Nest:Mine:!height\\\");\\n\\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token];\\n        uint256 len = state.priceSheetList[token].length;\\n        MiningV1Data.PriceSheet memory _sheet;\\n        uint256 _ethNum;\\n\\n        if (len == 0) {\\n            return (0, 0, 0);\\n        }\\n\\n        uint256 _first = 0;\\n        uint256 _prev = 0;\\n        for (uint i = 1; i <= len; i++) {\\n            _sheet = _list[len - i];\\n            _first = uint256(_sheet.height);\\n            if (_prev == 0) {\\n                if (_first + state.priceDurationBlock < uint256(atHeight)) {\\n                    _ethNum = uint256(_sheet.remainNum);\\n                    if (_ethNum == 0) {\\n                        continue; // jump over a bitten sheet\\n                    }\\n                    ethAmount = _ethNum.mul(1 ether);\\n                    tokenAmount = _ethNum.mul(_sheet.tokenAmountPerEth);\\n                    blockNum = _first + state.priceDurationBlock;\\n                    _prev = _first;\\n                }\\n            } else if (_first == _prev) {\\n                _ethNum = uint256(_sheet.remainNum);\\n                ethAmount = ethAmount.add(_ethNum.mul(1 ether));\\n                tokenAmount = tokenAmount.add(_ethNum.mul(_sheet.tokenAmountPerEth));\\n            } else if (_prev > _first) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _priceSheet(\\n            MiningV1Data.State storage state, \\n            address token, \\n            uint256 index\\n        ) \\n        view external \\n        returns (MiningV1Data.PriceSheetPub memory sheet) \\n    {\\n        uint256 len = state.priceSheetList[token].length;\\n        require (index < len, \\\"Nest:Mine:!index\\\");\\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index];\\n        sheet.miner = _sheet.miner;\\n        sheet.height = _sheet.height;\\n        sheet.ethNum = _sheet.ethNum;\\n        sheet.typ = _sheet.typ;\\n        sheet.state = _sheet.state;\\n        sheet.ethNumBal = _sheet.ethNumBal;\\n        sheet.tokenNumBal = _sheet.tokenNumBal;\\n    }\\n\\n    \\n    function unVerifiedSheetList(\\n            MiningV1Data.State storage state, \\n            address token\\n        ) \\n        view \\n        public\\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \\n    {\\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token]; \\n        uint256 len = _list.length;\\n        uint256 num;\\n        for (uint i = 0; i < len; i++) {\\n            if (_list[len - 1 - i].height + state.priceDurationBlock < block.number) {\\n                break;\\n            }\\n            num += 1;\\n        }\\n\\n        sheets = new MiningV1Data.PriceSheetPub2[](num);\\n        for (uint i = 0; i < num; i++) {\\n            MiningV1Data.PriceSheet memory _sheet = _list[len - 1 - i];\\n            if (uint256(_sheet.height) + state.priceDurationBlock < block.number) {\\n                break;\\n            }\\n            //sheets[i] = _sheet;\\n            sheets[i].miner = _sheet.miner;\\n            sheets[i].height = _sheet.height;\\n            sheets[i].ethNum = _sheet.ethNum;\\n            sheets[i].remainNum = _sheet.remainNum;\\n            sheets[i].level = _sheet.level;\\n            sheets[i].typ = _sheet.typ;\\n            sheets[i].state = _sheet.state;\\n\\n            sheets[i].index = len - 1 - i;\\n\\n            sheets[i].nestNum1k = _sheet.nestNum1k;\\n            sheets[i].tokenAmountPerEth = _sheet.tokenAmountPerEth;\\n        }\\n    }\\n\\n    function unClosedSheetListOf(\\n            MiningV1Data.State storage state, \\n            address miner, \\n            address token, \\n            uint256 fromIndex, \\n            uint256 num) \\n        view \\n        external\\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \\n    {\\n        sheets = new MiningV1Data.PriceSheetPub2[](num);\\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token]; \\n        uint256 len = _list.length;\\n        require(fromIndex < len, \\\"Nest:Mine:!from\\\");\\n\\n        for (uint i = 0; i < num; i++) {\\n            if (fromIndex < i) {\\n                break;\\n            }\\n\\n            MiningV1Data.PriceSheet memory _sheet = _list[fromIndex - i];\\n            if (uint256(_sheet.miner) == uint256(miner)\\n                && (_sheet.state == MiningV1Data.PRICESHEET_STATE_POSTED \\n                    || _sheet.state == MiningV1Data.PRICESHEET_STATE_BITTEN)) {\\n            \\n                sheets[i].miner = _sheet.miner;\\n                sheets[i].height = _sheet.height;\\n                sheets[i].ethNum = _sheet.ethNum;\\n                sheets[i].remainNum = _sheet.remainNum;\\n                sheets[i].level = _sheet.level;\\n                sheets[i].typ = _sheet.typ;\\n                sheets[i].state = _sheet.state;\\n\\n                sheets[i].index = fromIndex - i;\\n\\n                sheets[i].nestNum1k = _sheet.nestNum1k;\\n                sheets[i].tokenAmountPerEth = _sheet.tokenAmountPerEth;\\n\\n            }\\n        }\\n    }\\n\\n    function sheetListOf(\\n           MiningV1Data.State storage state, \\n           address miner, \\n           address token, \\n           uint256 fromIndex, \\n           uint256 num\\n        ) \\n        view \\n        external\\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \\n    {\\n        sheets = new MiningV1Data.PriceSheetPub2[](num);\\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token]; \\n        uint256 len = _list.length;\\n        require(fromIndex < len, \\\"Nest:Mine:!from\\\");\\n\\n        for (uint i = 0; i < num; i++) {\\n            if (fromIndex < i) {\\n                break;\\n            }\\n            MiningV1Data.PriceSheet memory _sheet = _list[fromIndex - i];\\n            if (uint256(_sheet.miner) == uint256(miner)) {\\n            \\n                sheets[i].miner = _sheet.miner;\\n                sheets[i].height = _sheet.height;\\n                sheets[i].ethNum = _sheet.ethNum;\\n                sheets[i].remainNum = _sheet.remainNum;\\n                sheets[i].level = _sheet.level;\\n                sheets[i].typ = _sheet.typ;\\n                sheets[i].state = _sheet.state;\\n\\n                sheets[i].index = fromIndex - i;\\n                sheets[i].nestNum1k = _sheet.nestNum1k;\\n                sheets[i].tokenAmountPerEth = _sheet.tokenAmountPerEth;\\n\\n            }\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n\\n    function div(uint x, uint y) internal pure returns (uint z) {\\n        require(y > 0, \\\"ds-math-div-zero\\\");\\n        z = x / y;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\ninterface ERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/lib/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Copyright © 2019 by ABDK Consulting\\n\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity 0.6.12;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /**\\n   * @dev Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /**\\n   * @dev Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    return int64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    require (x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    require (x >= 0);\\n    return uint64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    int256 result = x >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    return int256 (x) << 64;\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) + y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) - y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) * y >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    if (x == MIN_64x64) {\\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n        y <= 0x1000000000000000000000000000000000000000000000000);\\n      return -y << 63;\\n    } else {\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x;\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint256 absoluteResult = mulu (x, uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <=\\n          0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <=\\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (absoluteResult);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    if (y == 0) return 0;\\n\\n    require (x >= 0);\\n\\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n    uint256 hi = uint256 (x) * (y >> 128);\\n\\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    hi <<= 64;\\n\\n    require (hi <=\\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n    return hi + lo;\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    require (y != 0);\\n    int256 result = (int256 (x) << 64) / y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    require (y != 0);\\n\\n    bool negativeResult = false;\\n    if (x < 0) {\\n      x = -x; // We rely on overflow behavior here\\n      negativeResult = true;\\n    }\\n    if (y < 0) {\\n      y = -y; // We rely on overflow behavior here\\n      negativeResult = !negativeResult;\\n    }\\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n    if (negativeResult) {\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\n    } else {\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    require (y != 0);\\n    uint128 result = divuu (x, y);\\n    require (result <= uint128 (MAX_64x64));\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return -x;\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return x < 0 ? -x : x;\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    require (x != 0);\\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    return int128 ((int256 (x) + int256 (y)) >> 1);\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    int256 m = int256 (x) * int256 (y);\\n    require (m >= 0);\\n    require (m <\\n        0x4000000000000000000000000000000000000000000000000000000000000000);\\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    uint256 absoluteResult;\\n    bool negativeResult = false;\\n    if (x >= 0) {\\n      absoluteResult = powu (uint256 (x) << 63, y);\\n    } else {\\n      // We rely on overflow behavior here\\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\\n      negativeResult = y & 1 > 0;\\n    }\\n\\n    absoluteResult >>= 63;\\n\\n    if (negativeResult) {\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\n    } else {\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    require (x >= 0);\\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    int256 msb = 0;\\n    int256 xc = x;\\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n    int256 result = msb - 64 << 64;\\n    uint256 ux = uint256 (x) << 127 - msb;\\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n      ux *= ux;\\n      uint256 b = ux >> 255;\\n      ux >>= 127 + b;\\n      result += bit * int256 (b);\\n    }\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    return int128 (\\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    uint256 result = 0x80000000000000000000000000000000;\\n\\n    if (x & 0x8000000000000000 > 0)\\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n    if (x & 0x4000000000000000 > 0)\\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n    if (x & 0x2000000000000000 > 0)\\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n    if (x & 0x1000000000000000 > 0)\\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n    if (x & 0x800000000000000 > 0)\\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n    if (x & 0x400000000000000 > 0)\\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n    if (x & 0x200000000000000 > 0)\\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n    if (x & 0x100000000000000 > 0)\\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n    if (x & 0x80000000000000 > 0)\\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n    if (x & 0x40000000000000 > 0)\\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n    if (x & 0x20000000000000 > 0)\\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n    if (x & 0x10000000000000 > 0)\\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n    if (x & 0x8000000000000 > 0)\\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n    if (x & 0x4000000000000 > 0)\\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n    if (x & 0x2000000000000 > 0)\\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n    if (x & 0x1000000000000 > 0)\\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n    if (x & 0x800000000000 > 0)\\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n    if (x & 0x400000000000 > 0)\\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n    if (x & 0x200000000000 > 0)\\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n    if (x & 0x100000000000 > 0)\\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n    if (x & 0x80000000000 > 0)\\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n    if (x & 0x40000000000 > 0)\\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n    if (x & 0x20000000000 > 0)\\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n    if (x & 0x10000000000 > 0)\\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n    if (x & 0x8000000000 > 0)\\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n    if (x & 0x4000000000 > 0)\\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n    if (x & 0x2000000000 > 0)\\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n    if (x & 0x1000000000 > 0)\\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n    if (x & 0x800000000 > 0)\\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n    if (x & 0x400000000 > 0)\\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n    if (x & 0x200000000 > 0)\\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n    if (x & 0x100000000 > 0)\\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n    if (x & 0x80000000 > 0)\\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n    if (x & 0x40000000 > 0)\\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n    if (x & 0x20000000 > 0)\\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n    if (x & 0x10000000 > 0)\\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n    if (x & 0x8000000 > 0)\\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n    if (x & 0x4000000 > 0)\\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n    if (x & 0x2000000 > 0)\\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n    if (x & 0x1000000 > 0)\\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n    if (x & 0x800000 > 0)\\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n    if (x & 0x400000 > 0)\\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n    if (x & 0x200000 > 0)\\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n    if (x & 0x100000 > 0)\\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n    if (x & 0x80000 > 0)\\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n    if (x & 0x40000 > 0)\\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n    if (x & 0x20000 > 0)\\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n    if (x & 0x10000 > 0)\\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n    if (x & 0x8000 > 0)\\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n    if (x & 0x4000 > 0)\\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n    if (x & 0x2000 > 0)\\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n    if (x & 0x1000 > 0)\\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n    if (x & 0x800 > 0)\\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n    if (x & 0x400 > 0)\\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n    if (x & 0x200 > 0)\\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n    if (x & 0x100 > 0)\\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n    if (x & 0x80 > 0)\\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n    if (x & 0x40 > 0)\\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n    if (x & 0x20 > 0)\\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n    if (x & 0x10 > 0)\\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n    if (x & 0x8 > 0)\\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n    if (x & 0x4 > 0)\\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n    if (x & 0x2 > 0)\\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n    if (x & 0x1 > 0)\\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n    result >>= 63 - (x >> 64);\\n    require (result <= uint256 (MAX_64x64));\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    return exp_2 (\\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    require (y != 0);\\n\\n    uint256 result;\\n\\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      result = (x << 64) / y;\\n    else {\\n      uint256 msb = 192;\\n      uint256 xc = x >> 192;\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 hi = result * (y >> 128);\\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 xh = x >> 192;\\n      uint256 xl = x << 64;\\n\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n      lo = hi << 128;\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n\\n      assert (xh == hi >> 128);\\n\\n      result += xl / y;\\n    }\\n\\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    return uint128 (result);\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x unsigned 129.127-bit fixed point number\\n   * @param y uint256 value\\n   * @return unsigned 129.127-bit fixed point number\\n   */\\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\\n    if (y == 0) return 0x80000000000000000000000000000000;\\n    else if (x == 0) return 0;\\n    else {\\n      int256 msb = 0;\\n      uint256 xc = x;\\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      int256 xe = msb - 127;\\n      if (xe > 0) x >>= xe;\\n      else x <<= -xe;\\n\\n      uint256 result = 0x80000000000000000000000000000000;\\n      int256 re = 0;\\n\\n      while (y > 0) {\\n        if (y & 1 > 0) {\\n          result = result * x;\\n          y -= 1;\\n          re += xe;\\n          if (result >=\\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\\n            result >>= 128;\\n            re += 1;\\n          } else result >>= 127;\\n          if (re < -127) return 0; // Underflow\\n          require (re < 128); // Overflow\\n        } else {\\n          x = x * x;\\n          y >>= 1;\\n          xe <<= 1;\\n          if (x >=\\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\\n            x >>= 128;\\n            xe += 1;\\n          } else x >>= 127;\\n          if (xe < -127) return 0; // Underflow\\n          require (xe < 128); // Overflow\\n        }\\n      }\\n\\n      if (re > 0) result <<= re;\\n      else if (re < 0) result >>= -re;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\\n    if (x == 0) return 0;\\n    else {\\n      require (r > 0);\\n      while (true) {\\n        uint256 rr = x / r;\\n        if (r == rr || r + 1 == rr) return uint128 (r);\\n        else if (r == rr + 1) return uint128 (rr);\\n        r = r + rr + 1 >> 1;\\n      }\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/iface/INestPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\n\\ninterface INestPool {\\n\\n    // function getNTokenFromToken(address token) view external returns (address);\\n    // function setNTokenToToken(address token, address ntoken) external; \\n\\n    function addNest(address miner, uint256 amount) external;\\n    function addNToken(address contributor, address ntoken, uint256 amount) external;\\n\\n    function depositEth(address miner) external payable;\\n    function depositNToken(address miner,  address from, address ntoken, uint256 amount) external;\\n\\n    function freezeEth(address miner, uint256 ethAmount) external; \\n    function unfreezeEth(address miner, uint256 ethAmount) external;\\n\\n    function freezeNest(address miner, uint256 nestAmount) external;\\n    function unfreezeNest(address miner, uint256 nestAmount) external;\\n\\n    function freezeToken(address miner, address token, uint256 tokenAmount) external; \\n    function unfreezeToken(address miner, address token, uint256 tokenAmount) external;\\n\\n    function freezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n    function unfreezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n\\n    function getNTokenFromToken(address token) external view returns (address); \\n    function setNTokenToToken(address token, address ntoken) external; \\n\\n    function withdrawEth(address miner, uint256 ethAmount) external;\\n    function withdrawToken(address miner, address token, uint256 tokenAmount) external;\\n\\n    function withdrawNest(address miner, uint256 amount) external;\\n    function withdrawEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n    // function withdrawNToken(address miner, address ntoken, uint256 amount) external;\\n    function withdrawNTokenAndTransfer(address miner, address ntoken, uint256 amount, address to) external;\\n\\n\\n    function balanceOfNestInPool(address miner) external view returns (uint256);\\n    function balanceOfEthInPool(address miner) external view returns (uint256);\\n    function balanceOfTokenInPool(address miner, address token)  external view returns (uint256);\\n\\n    function addrOfNestToken() external view returns (address);\\n    function addrOfNestMining() external view returns (address);\\n    function addrOfNTokenController() external view returns (address);\\n    function addrOfNNRewardPool() external view returns (address);\\n    function addrOfNNToken() external view returns (address);\\n    function addrOfNestStaking() external view returns (address);\\n    function addrOfNestQuery() external view returns (address);\\n    function addrOfNestDAO() external view returns (address);\\n\\n    function addressOfBurnedNest() external view returns (address);\\n\\n    function setGovernance(address _gov) external; \\n    function governance() external view returns(address);\\n    function initNestLedger(uint256 amount) external;\\n    function drainNest(address to, uint256 amount, address gov) external;\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INestStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n\\ninterface INestStaking {\\n    // Views\\n\\n    /// @dev How many stakingToken (XToken) deposited into to this reward pool (staking pool)\\n    /// @param  ntoken The address of NToken\\n    /// @return The total amount of XTokens deposited in this staking pool\\n    function totalStaked(address ntoken) external view returns (uint256);\\n\\n    /// @dev How many stakingToken (XToken) deposited by the target account\\n    /// @param  ntoken The address of NToken\\n    /// @param  account The target account\\n    /// @return The total amount of XToken deposited in this staking pool\\n    function stakedBalanceOf(address ntoken, address account) external view returns (uint256);\\n\\n\\n    // Mutative\\n    /// @dev Stake/Deposit into the reward pool (staking pool)\\n    /// @param  ntoken The address of NToken\\n    /// @param  amount The target amount\\n    function stake(address ntoken, uint256 amount) external;\\n\\n    function stakeFromNestPool(address ntoken, uint256 amount) external;\\n\\n    /// @dev Withdraw from the reward pool (staking pool), get the original tokens back\\n    /// @param  ntoken The address of NToken\\n    /// @param  amount The target amount\\n    function unstake(address ntoken, uint256 amount) external;\\n\\n    /// @dev Claim the reward the user earned\\n    /// @param ntoken The address of NToken\\n    /// @return The amount of ethers as rewards\\n    function claim(address ntoken) external returns (uint256);\\n\\n    /// @dev Add ETH reward to the staking pool\\n    /// @param ntoken The address of NToken\\n    function addETHReward(address ntoken) external payable;\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external; \\n\\n    function pause() external;\\n\\n    function resume() external;\\n\\n    //function setParams(uint8 dividendShareRate) external;\\n\\n    /* ========== EVENTS ========== */\\n\\n    // Events\\n    event RewardAdded(address ntoken, address sender, uint256 reward);\\n    event NTokenStaked(address ntoken, address indexed user, uint256 amount);\\n    event NTokenUnstaked(address ntoken, address indexed user, uint256 amount);\\n    event SavingWithdrawn(address ntoken, address indexed to, uint256 amount);\\n    event RewardClaimed(address ntoken, address indexed user, uint256 reward);\\n\\n    event FlagSet(address gov, uint256 flag);\\n}\"\r\n    },\r\n    \"contracts/iface/INToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\ninterface INToken {\\n    // mint ntoken for value\\n    function mint(uint256 amount, address account) external;\\n\\n    // the block height where the ntoken was created\\n    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\\n    // the owner (auction winner) of the ntoken\\n    function checkBidder() external view returns(address);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INNRewardPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n/// @title NNRewardPool\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author Paradox  - <paradox@nestprotocol.org>\\n\\ninterface INNRewardPool {\\n    \\n    /* [DEPRECATED]\\n        uint256 constant DEV_REWARD_PERCENTAGE   = 5;\\n        uint256 constant NN_REWARD_PERCENTAGE    = 15;\\n        uint256 constant MINER_REWARD_PERCENTAGE = 80;\\n    */\\n\\n    /// @notice Add rewards for Nest-Nodes, only governance or NestMining (contract) are allowed\\n    /// @dev  The rewards need to pull from NestPool\\n    /// @param _amount The amount of Nest token as the rewards to each nest-node\\n    function addNNReward(uint256 _amount) external;\\n\\n    /// @notice Claim rewards by Nest-Nodes\\n    /// @dev The rewards need to pull from NestPool\\n    function claimNNReward() external ;  \\n\\n    /// @dev The callback function called by NNToken.transfer()\\n    /// @param fromAdd The address of 'from' to transfer\\n    /// @param toAdd The address of 'to' to transfer\\n    function nodeCount(address fromAdd, address toAdd) external;\\n\\n    /// @notice Show the amount of rewards unclaimed\\n    /// @return reward The reward of a NN holder\\n    function unclaimedNNReward() external view returns (uint256 reward);\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external; \\n\\n    /* ========== EVENTS ============== */\\n\\n    /// @notice When rewards are added to the pool\\n    /// @param reward The amount of Nest Token\\n    /// @param allRewards The snapshot of all rewards accumulated\\n    event NNRewardAdded(uint256 reward, uint256 allRewards);\\n\\n    /// @notice When rewards are claimed by nodes \\n    /// @param nnode The address of the nest node\\n    /// @param share The amount of Nest Token claimed by the nest node\\n    event NNRewardClaimed(address nnode, uint256 share);\\n\\n    /// @notice When flag of state is set by governance \\n    /// @param gov The address of the governance\\n    /// @param flag The value of the new flag\\n    event FlagSet(address gov, uint256 flag);\\n}\"\r\n    },\r\n    \"contracts/libminingv1/MiningV1Data.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n\\nimport \\\"../iface/INestPool.sol\\\";\\nimport \\\"../iface/INestStaking.sol\\\";\\nimport \\\"../iface/INToken.sol\\\";\\nimport \\\"../iface/INNRewardPool.sol\\\";\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\n\\n\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author 0x00  - <0x00@nestprotocol.org>\\nlibrary MiningV1Data {\\n\\n    /* ========== CONSTANTS ========== */\\n\\n    uint256 constant MINING_NEST_YIELD_CUTBACK_PERIOD = 2400000; // ~ 1 years \\n    uint256 constant MINING_NEST_YIELD_CUTBACK_RATE = 80;     // percentage = 80%\\n\\n    // yield amount (per block) after the first ten years\\n    uint256 constant MINING_NEST_YIELD_OFF_PERIOD_AMOUNT = 40 ether;\\n    // yield amount (per block) in the first year, it drops to 80% in the following nine years\\n    uint256 constant MINING_NEST_YIELD_PER_BLOCK_BASE = 400 ether;\\n\\n    uint256 constant MINING_NTOKEN_YIELD_CUTBACK_RATE = 80;\\n    uint256 constant MINING_NTOKEN_YIELD_OFF_PERIOD_AMOUNT = 0.4 ether;\\n    uint256 constant MINING_NTOKEN_YIELD_PER_BLOCK_BASE = 4 ether;\\n\\n    uint256 constant MINING_FINAL_BLOCK_NUMBER = 173121488;\\n\\n\\n    uint256 constant MINING_NEST_FEE_DIVIDEND_RATE = 80;    // percentage = 80%\\n    uint256 constant MINING_NEST_FEE_DAO_RATE = 20;         // percentage = 20%\\n\\n    uint256 constant MINING_NTOKEN_FEE_DIVIDEND_RATE        = 60;     // percentage = 60%\\n    uint256 constant MINING_NTOKEN_FEE_DAO_RATE             = 20;     // percentage = 20%\\n    uint256 constant MINING_NTOKEN_FEE_NEST_DAO_RATE        = 20;     // percentage = 20%\\n\\n    uint256 constant MINING_NTOKEN_YIELD_BLOCK_LIMIT = 100;\\n\\n    uint256 constant NN_NEST_REWARD_PERCENTAGE = 15;\\n    uint256 constant DAO_NEST_REWARD_PERCENTAGE = 5;\\n    uint256 constant MINER_NEST_REWARD_PERCENTAGE = 80;\\n\\n    uint256 constant MINING_LEGACY_NTOKEN_MINER_REWARD_PERCENTAGE = 95;\\n    uint256 constant MINING_LEGACY_NTOKEN_BIDDER_REWARD_PERCENTAGE = 5;\\n\\n    uint8 constant PRICESHEET_STATE_CLOSED = 0;\\n    uint8 constant PRICESHEET_STATE_POSTED = 1;\\n    uint8 constant PRICESHEET_STATE_BITTEN = 2;\\n\\n    uint8 constant PRICESHEET_TYPE_USD     = 1;\\n    uint8 constant PRICESHEET_TYPE_NEST    = 2;\\n    uint8 constant PRICESHEET_TYPE_TOKEN   = 3;\\n    uint8 constant PRICESHEET_TYPE_NTOKEN  = 4;\\n    uint8 constant PRICESHEET_TYPE_BITTING = 8;\\n\\n\\n    uint8 constant STATE_FLAG_UNINITIALIZED    = 0;\\n    uint8 constant STATE_FLAG_SETUP_NEEDED     = 1;\\n    uint8 constant STATE_FLAG_ACTIVE           = 3;\\n    uint8 constant STATE_FLAG_MINING_STOPPED   = 4;\\n    uint8 constant STATE_FLAG_CLOSING_STOPPED  = 5;\\n    uint8 constant STATE_FLAG_WITHDRAW_STOPPED = 6;\\n    uint8 constant STATE_FLAG_PRICE_STOPPED    = 7;\\n    uint8 constant STATE_FLAG_SHUTDOWN         = 127;\\n\\n    uint256 constant MINING_NTOKEN_NON_DUAL_POST_THRESHOLD = 5_000_000 ether;\\n\\n\\n    /// @dev size: (2 x 256 bit)\\n    struct PriceSheet {    \\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\\n        uint32  height;      //\\n        uint32  ethNum;   \\n        uint32  remainNum;    \\n\\n        uint8   level;           // the level of bitting, 1-4: eth-doubling | 5 - 127: nest-doubling\\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN\\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\\n        uint8   _reserved;       // for padding\\n        uint32  ethNumBal;\\n        uint32  tokenNumBal;\\n        uint32  nestNum1k;\\n        uint128 tokenAmountPerEth;\\n    }\\n    \\n    /// @dev size: (3 x 256 bit)\\n    struct PriceInfo {\\n        uint32  index;\\n        uint32  height;         // NOTE: the height of being posted\\n        uint32  ethNum;         //  the balance of eth\\n        uint32  _reserved;\\n        uint128 tokenAmount;    //  the balance of token \\n        int128  volatility_sigma_sq;\\n        int128  volatility_ut_sq;\\n        uint128  avgTokenAmount;  // avg = (tokenAmount : perEth)\\n        uint128 _reserved2;     \\n    }\\n\\n\\n    /// @dev The struct is for public data in a price sheet, so as to protect prices from being read\\n    struct PriceSheetPub {\\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\\n        uint32  height;\\n        uint32  ethNum;   \\n\\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN(Not Available)\\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\\n        uint32  ethNumBal;\\n        uint32  tokenNumBal;\\n    }\\n\\n\\n    struct PriceSheetPub2 {\\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\\n        uint32  height;\\n        uint32  ethNum;   \\n        uint32  remainNum; \\n\\n        uint8   level;           // the level of bitting, 1-4: eth-doubling | 5 - 127: nest-doubling\\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN(Not Available)\\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\\n        uint256 index;           // return to the quotation of index\\n        uint32  nestNum1k;\\n        uint128 tokenAmountPerEth;   \\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event PricePosted(address miner, address token, uint256 index, uint256 ethAmount, uint256 tokenAmount);\\n    event PriceClosed(address miner, address token, uint256 index);\\n    event Deposit(address miner, address token, uint256 amount);\\n    event Withdraw(address miner, address token, uint256 amount);\\n    event TokenBought(address miner, address token, uint256 index, uint256 biteEthAmount, uint256 biteTokenAmount);\\n    event TokenSold(address miner, address token, uint256 index, uint256 biteEthAmount, uint256 biteTokenAmount);\\n\\n    event VolaComputed(uint32 h, uint32 pos, uint32 ethA, uint128 tokenA, int128 sigma_sq, int128 ut_sq);\\n\\n    event SetParams(uint8 miningEthUnit, uint32 nestStakedNum1k, uint8 biteFeeRate,\\n                    uint8 miningFeeRate, uint8 priceDurationBlock, uint8 maxBiteNestedLevel,\\n                    uint8 biteInflateFactor, uint8 biteNestInflateFactor);\\n\\n    // event GovSet(address oldGov, address newGov);\\n\\n    /* ========== GIANT STATE VARIABLE ========== */\\n\\n    struct State {\\n        // TODO: more comments\\n\\n        uint8   miningEthUnit;      // = 30 on mainnet;\\n        uint32  nestStakedNum1k;    // = 100;\\n        uint8   biteFeeRate;        // \\n        uint8   miningFeeRate;      // = 10;  \\n        uint8   priceDurationBlock; // = 25;\\n        uint8   maxBiteNestedLevel; // = 3;\\n        uint8   biteInflateFactor;  // = 2;\\n        uint8   biteNestInflateFactor; // = 2;\\n\\n        uint32  genesisBlock;       // = 6236588;\\n\\n        uint128  latestMiningHeight;  // latest block number of NEST mining\\n        uint128  minedNestAmount;     // the total amount of mined NEST\\n        \\n        address  _developer_address;  // WARNING: DO NOT delete this unused variable\\n        address  _NN_address;         // WARNING: DO NOT delete this unused variable\\n\\n        address  C_NestPool;\\n        address  C_NestToken;\\n        address  C_NestStaking;\\n        address  C_NNRewardPool;\\n        address  C_NestQuery;\\n        address  C_NestDAO;\\n\\n        uint256[10] _mining_nest_yield_per_block_amount;\\n        uint256[10] _mining_ntoken_yield_per_block_amount;\\n\\n        // A mapping (from token(address) to an array of PriceSheet)\\n        mapping(address => PriceSheet[]) priceSheetList;\\n\\n        // from token(address) to Price\\n        mapping(address => PriceInfo) priceInfo;\\n\\n        // (token-address, block-number) => (ethFee-total, nest/ntoken-mined-total)\\n        mapping(address => mapping(uint256 => uint256)) minedAtHeight;\\n\\n        // WARNING: DO NOT delete these variables, reserved for future use\\n        uint256  _reserved1;\\n        uint256  _reserved2;\\n        uint256  _reserved3;\\n        uint256  _reserved4;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/lib/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n        (bool success, ) = recipient.call{value:amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[]","ContractName":"MiningV1Calc","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}