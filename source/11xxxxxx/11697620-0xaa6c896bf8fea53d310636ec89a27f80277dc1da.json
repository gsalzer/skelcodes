{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/utils/Ownable.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract Ownable {\r\n    address private _contract_owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = msg.sender;\r\n        _contract_owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _contract_owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_contract_owner, newOwner);\r\n        _contract_owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SafeMath.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"add\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"sub\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"mul\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"div\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/Address.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: contracts/erc20/IERC20.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/erc20/SafeERC20.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).safeAdd(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).safeSub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/core/HPeriod.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\ncontract HPeriod{\r\n  using SafeMath for uint;\r\n\r\n  uint256 period_start_block;\r\n  uint256 period_block_num;\r\n  uint256 period_gap_block;\r\n\r\n  struct period_info{\r\n    uint256 period;\r\n    uint256 start_block;\r\n    uint256 end_block;    // [start_block, end_block)\r\n  }\r\n\r\n  mapping (uint256 => period_info) all_periods;\r\n  uint256 current_period;\r\n\r\n  bool is_gapping;\r\n\r\n  constructor(uint256 _start_block, uint256 _period_block_num, uint256 _gap_block_num) public{\r\n    period_start_block = _start_block;\r\n    period_block_num = _period_block_num;\r\n\r\n    period_gap_block = _gap_block_num;\r\n    current_period = 0;\r\n    is_gapping = true;\r\n  }\r\n\r\n  function _end_current_and_start_new_period() internal returns(bool){\r\n    require(block.number >= period_start_block, \"1st period not start yet\");\r\n\r\n    if(is_gapping){\r\n      if(current_period == 0 || block.number.safeSub(all_periods[current_period].end_block) >= period_gap_block){\r\n        current_period = current_period + 1;\r\n        all_periods[current_period].period = current_period;\r\n        all_periods[current_period].start_block = block.number;\r\n        is_gapping = false;\r\n        return true;\r\n      }\r\n    }else{\r\n      if(block.number.safeSub(all_periods[current_period].start_block) >= period_block_num){\r\n        all_periods[current_period].end_block = block.number;\r\n        is_gapping = true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  event HPeriodChanged(uint256 old, uint256 new_period);\r\n  function _change_period(uint256 _period) internal{\r\n    uint256 old = period_block_num;\r\n    period_block_num = _period;\r\n    emit HPeriodChanged(old, period_block_num);\r\n  }\r\n\r\n  function getCurrentPeriodStartBlock() public view returns(uint256){\r\n    (, uint256 s, ) = getPeriodInfo(current_period);\r\n    return s;\r\n  }\r\n\r\n  function getPeriodInfo(uint256 period) public view returns(uint256 p, uint256 s, uint256 e){\r\n    p = all_periods[period].period;\r\n    s = all_periods[period].start_block;\r\n    e = all_periods[period].end_block;\r\n  }\r\n\r\n  function getParamPeriodStartBlock() public view returns(uint256){\r\n    return period_start_block;\r\n  }\r\n\r\n  function getParamPeriodBlockNum() public view returns(uint256){\r\n    return period_block_num;\r\n  }\r\n\r\n  function getParamPeriodGapNum() public view returns(uint256){\r\n    return period_gap_block;\r\n  }\r\n\r\n  function getCurrentPeriod() public view returns(uint256){\r\n    return current_period;\r\n  }\r\n\r\n  function isPeriodEnd(uint256 _period) public view returns(bool){\r\n    return all_periods[_period].end_block != 0;\r\n  }\r\n\r\n  function isPeriodStart(uint256 _period) public view returns(bool){\r\n    return all_periods[_period].start_block != 0;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/core/HPeriodToken.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract HTokenFactoryInterface{\r\n  function createFixedRatioToken(address _token_addr, uint256 _period, uint256 _ratio, string memory _postfix) public returns(address);\r\n  function createFloatingToken(address _token_addr, uint256 _period, string memory _postfix) public returns(address);\r\n}\r\n\r\ncontract HTokenInterface{\r\n  function mint(address addr, uint256 amount)public;\r\n  function burnFrom(address addr, uint256 amount) public;\r\n  uint256 public period_number;\r\n  uint256 public ratio; // 0 is for floating\r\n  uint256 public underlying_balance;\r\n  function setUnderlyingBalance(uint256 _balance) public;\r\n  function setTargetToken(address _target) public;\r\n}\r\n\r\ncontract HPeriodToken is HPeriod, Ownable{\r\n\r\n  struct period_token_info{\r\n    address[] period_tokens;\r\n\r\n    mapping(bytes32 => address) hash_to_tokens;\r\n  }\r\n\r\n  mapping (uint256 => period_token_info) all_period_tokens;\r\n\r\n  HTokenFactoryInterface public token_factory;\r\n  address public target_token;\r\n\r\n\r\n  constructor(address _target_token, uint256 _start_block, uint256 _period, uint256 _gap, address _factory)\r\n    HPeriod(_start_block, _period, _gap) public{\r\n    target_token = _target_token;\r\n    token_factory = HTokenFactoryInterface(_factory);\r\n  }\r\n\r\n  function uint2str(uint256 i) internal pure returns (string memory c) {\r\n    if (i == 0) return \"0\";\r\n    uint256 j = i;\r\n    uint256 length;\r\n    while (j != 0){\r\n        length++;\r\n        j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(length);\r\n    uint256 k = length - 1;\r\n    while (i != 0){\r\n      bstr[k--] = byte(48 + uint8(i % 10));\r\n      i /= 10;\r\n    }\r\n    c = string(bstr);\r\n  }\r\n\r\n  function getOrCreateToken(uint ratio) public onlyOwner returns(address, bool){\r\n\r\n    _end_current_and_start_new_period();\r\n\r\n    uint256 p = getCurrentPeriod();\r\n    bytes32 h = keccak256(abi.encodePacked(target_token, getParamPeriodBlockNum(), ratio, p + 1));\r\n    address c = address(0x0);\r\n\r\n    period_token_info storage pi = all_period_tokens[p + 1];\r\n\r\n    bool s  = false;\r\n    if(pi.hash_to_tokens[h] == address(0x0)){\r\n      if(ratio == 0){\r\n        c = token_factory.createFloatingToken(target_token, p + 1, uint2str(getParamPeriodBlockNum()));\r\n      }\r\n      else{\r\n        c = token_factory.createFixedRatioToken(target_token, p + 1, ratio, uint2str(getParamPeriodBlockNum()));\r\n      }\r\n      HTokenInterface(c).setTargetToken(target_token);\r\n      Ownable ow = Ownable(c);\r\n      ow.transferOwnership(owner());\r\n      pi.period_tokens.push(c);\r\n      pi.hash_to_tokens[h] = c;\r\n      s = true;\r\n    }\r\n    c = pi.hash_to_tokens[h];\r\n\r\n    return(c, s);\r\n  }\r\n\r\n  function updatePeriodStatus() public onlyOwner returns(bool){\r\n    return _end_current_and_start_new_period();\r\n  }\r\n\r\n  function isPeriodTokenValid(address _token_addr) public view returns(bool){\r\n    HTokenInterface hti = HTokenInterface(_token_addr);\r\n    bytes32 h = keccak256(abi.encodePacked(target_token, getParamPeriodBlockNum(), hti.ratio(), hti.period_number()));\r\n    period_token_info storage pi = all_period_tokens[hti.period_number()];\r\n    if(pi.hash_to_tokens[h] == _token_addr){\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function totalAtPeriodWithRatio(uint256 _period, uint256 _ratio) public view returns(uint256) {\r\n    bytes32 h = keccak256(abi.encodePacked(target_token, getParamPeriodBlockNum(), _ratio, _period));\r\n    period_token_info storage pi = all_period_tokens[_period];\r\n    address c = pi.hash_to_tokens[h];\r\n    if(c == address(0x0)) return 0;\r\n\r\n    IERC20 e = IERC20(c);\r\n    return e.totalSupply();\r\n  }\r\n\r\n  function htokenAtPeriodWithRatio(uint256 _period, uint256 _ratio) public view returns(address){\r\n    bytes32 h = keccak256(abi.encodePacked(target_token, getParamPeriodBlockNum(), _ratio, _period));\r\n    period_token_info storage pi = all_period_tokens[_period];\r\n    address c = pi.hash_to_tokens[h];\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract HPeriodTokenFactory{\r\n\r\n  event NewPeriodToken(address addr);\r\n  function createPeriodToken(address _target_token, uint256 _start_block, uint256 _period, uint256 _gap, address _token_factory) public returns(address){\r\n    HPeriodToken pt = new HPeriodToken(_target_token, _start_block, _period, _gap, _token_factory);\r\n\r\n    pt.transferOwnership(msg.sender);\r\n    emit NewPeriodToken(address(pt));\r\n    return address(pt);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getParamPeriodBlockNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"getOrCreateToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token_addr\",\"type\":\"address\"}],\"name\":\"isPeriodTokenValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"getPeriodInfo\",\"outputs\":[{\"name\":\"p\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"},{\"name\":\"e\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updatePeriodStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_period\",\"type\":\"uint256\"},{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"totalAtPeriodWithRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParamPeriodGapNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"isPeriodStart\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_period\",\"type\":\"uint256\"},{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"htokenAtPeriodWithRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"isPeriodEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPeriodStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"target_token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParamPeriodStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_target_token\",\"type\":\"address\"},{\"name\":\"_start_block\",\"type\":\"uint256\"},{\"name\":\"_period\",\"type\":\"uint256\"},{\"name\":\"_gap\",\"type\":\"uint256\"},{\"name\":\"_factory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"old\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"new_period\",\"type\":\"uint256\"}],\"name\":\"HPeriodChanged\",\"type\":\"event\"}]","ContractName":"HPeriodToken","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008798249c2e607446efb7ad49ec89dd1865ff42720000000000000000000000000000000000000000000000000000000000b26010000000000000000000000000000000000000000000000000000000000000a2ee0000000000000000000000000000000000000000000000000000000000001748000000000000000000000000dd7236a2fe55827311452a9ebdd2338190ad0820","EVMVersion":"Default","Library":"SafeMath:0836e32f1f91db939d58a0763cbd38a28a8688fa","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e91ab2f290f7be79f7cdc84d2846c0237924feaa466dc9a07c85b95ec87b691e"}]}