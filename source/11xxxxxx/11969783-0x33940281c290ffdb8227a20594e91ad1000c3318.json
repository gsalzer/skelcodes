{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"LPReward: Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address transferOwner) public onlyOwner {\r\n        require(transferOwner != newOwner);\r\n        newOwner = transferOwner;\r\n    }\r\n\r\n    function acceptOwnership() virtual public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ninterface INimbusRouter {\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external  view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface INimbusFactory {\r\n    function getPair(address tokenA, address tokenB) external  view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'LPReward: ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'LPReward: ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'LPReward: ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\ncontract LPReward is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    uint public lpRewardMaxAmount = 100_000_000e18;\r\n    uint public lpRewardUsed;\r\n    uint public immutable startReward;\r\n    uint public constant rewardPeriod = 365 days;\r\n\r\n    address public NBU;\r\n    address public swapRouter;\r\n    INimbusFactory public swapFactory;\r\n\r\n    mapping (address => mapping (address => uint)) public lpTokenAmounts;\r\n    mapping (address => mapping (address => uint)) public weightedRatio;\r\n    mapping (address => mapping (address => uint)) public ratioUpdateLast;\r\n    mapping (address => mapping (address => uint[])) public unclaimedAmounts;\r\n    mapping (address => bool) public allowedPairs;\r\n    mapping (address => address[]) public pairTokens;\r\n\r\n    event RecordAddLiquidity(uint ratio, uint weightedRatio, uint oldWeighted, uint liquidity);\r\n    event RecordRemoveLiquidityUnclaimed(address recipient, address pair, uint amountA, uint amountB, uint liquidity);\r\n    event RecordRemoveLiquidityGiveNbu(address recipient, address pair, uint nbu, uint amountA, uint amountB, uint liquidity);\r\n    event ClaimLiquidityNbu(address recipient, uint nbu, uint amountA, uint amountB);\r\n    event Rescue(address to, uint amount);\r\n    event RescueToken(address token, address to, uint amount); \r\n\r\n    constructor(address nbu, address factory) {\r\n        swapFactory = INimbusFactory(factory);\r\n        NBU = nbu;\r\n        startReward = block.timestamp;\r\n    }\r\n    \r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, \"LPReward: LOCKED\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    modifier onlyRouter() {\r\n        require(msg.sender == swapRouter, \"Caller is not the allowed router\");\r\n        _;\r\n    }\r\n    \r\n    function recordAddLiquidity(address recipient, address pair, uint amountA, uint amountB, uint liquidity) external onlyRouter {\r\n        if (!allowedPairs[pair]) return;\r\n        uint ratio = Math.sqrt(amountA.mul(amountB)).mul(1e18) / liquidity;   \r\n        uint previousRatio = weightedRatio[recipient][pair];\r\n        if (ratio < previousRatio) {\r\n            return;\r\n        }\r\n        uint previousAmount = lpTokenAmounts[recipient][pair];\r\n        uint newAmount = previousAmount.add(liquidity);\r\n        uint weighted =  (previousRatio.mul(previousAmount) / newAmount).add(ratio.mul(liquidity) / newAmount); \r\n        weightedRatio[recipient][pair] = weighted;\r\n        lpTokenAmounts[recipient][pair] = newAmount;\r\n        ratioUpdateLast[recipient][pair] = block.timestamp;\r\n        emit RecordAddLiquidity(ratio, weighted, previousRatio, liquidity);\r\n    }\r\n\r\n    function recordRemoveLiquidity(address recipient, address tokenA, address tokenB, uint amountA, uint amountB, uint liquidity) external lock onlyRouter { \r\n        address pair = swapFactory.getPair(tokenA, tokenB);\r\n        if (!allowedPairs[pair]) return;\r\n        uint amount0;\r\n        uint amount1;\r\n        {\r\n        uint previousAmount = lpTokenAmounts[recipient][pair];\r\n        if (previousAmount == 0) return;\r\n        uint ratio = Math.sqrt(amountA.mul(amountB)).mul(1e18) / liquidity;   \r\n        uint previousRatio = weightedRatio[recipient][pair];\r\n        if (previousRatio == 0 || (previousRatio != 0 && ratio < previousRatio)) return;\r\n        uint difference = ratio.sub(previousRatio);\r\n        if (previousAmount < liquidity) liquidity = previousAmount;\r\n        weightedRatio[recipient][pair] = (previousRatio.mul(previousAmount.sub(liquidity)) / previousAmount).add(ratio.mul(liquidity) / previousAmount);    \r\n        lpTokenAmounts[recipient][pair] = previousAmount.sub(liquidity);\r\n        amount0 = amountA.mul(difference) / 1e18;\r\n        amount1 = amountB.mul(difference) / 1e18; \r\n        }\r\n\r\n        uint amountNbu;\r\n        if (tokenA != NBU && tokenB != NBU) {\r\n            address tokenToNbuPair = swapFactory.getPair(tokenA, NBU);\r\n            if (tokenToNbuPair != address(0)) {\r\n                amountNbu = INimbusRouter(swapRouter).getAmountsOut(amount0, getPathForToken(tokenA))[1];\r\n            }\r\n\r\n            tokenToNbuPair = swapFactory.getPair(tokenB, NBU);\r\n            if (tokenToNbuPair != address(0)) {\r\n                if (amountNbu != 0) {\r\n                    amountNbu = amountNbu.add(INimbusRouter(swapRouter).getAmountsOut(amount1, getPathForToken(tokenB))[1]);\r\n                } else  {\r\n                    amountNbu = INimbusRouter(swapRouter).getAmountsOut(amount1, getPathForToken(tokenB))[1].mul(2);\r\n                }\r\n            } else {\r\n                amountNbu = amountNbu.mul(2);\r\n            }\r\n        } else if (tokenA == NBU) { \r\n            amountNbu = amount0.mul(2);\r\n        } else {\r\n            amountNbu = amount1.mul(2);\r\n        }\r\n        \r\n        if (amountNbu != 0 && amountNbu <= availableReward() && IERC20(NBU).balanceOf(address(this)) >= amountNbu) {\r\n            IERC20(NBU).transfer(recipient, amountNbu);\r\n            lpRewardUsed = lpRewardUsed.add(amountNbu);\r\n            emit RecordRemoveLiquidityGiveNbu(recipient, pair, amountNbu, amountA, amountB, liquidity);            \r\n        } else {\r\n            uint amountS0;\r\n            uint amountS1;\r\n            {\r\n            (address token0,) = sortTokens(tokenA, tokenB);\r\n            (amountS0, amountS1) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n            }\r\n            if (unclaimedAmounts[recipient][pair].length == 0) { \r\n                unclaimedAmounts[recipient][pair].push(amountS0);\r\n                unclaimedAmounts[recipient][pair].push(amountS1);\r\n            } else {\r\n                unclaimedAmounts[recipient][pair][0] = unclaimedAmounts[recipient][pair][0].add(amountS0);\r\n                unclaimedAmounts[recipient][pair][1] = unclaimedAmounts[recipient][pair][1].add(amountS1);\r\n            }\r\n            \r\n            emit RecordRemoveLiquidityUnclaimed(recipient, pair, amount0, amount1, liquidity);\r\n        }\r\n        ratioUpdateLast[recipient][pair] = block.timestamp;\r\n    }\r\n    \r\n    function claimBonusBatch(address[] memory pairs, address recipient) external {\r\n        for (uint i; i < pairs.length; i++) {\r\n            claimBonus(pairs[i],recipient);\r\n        }\r\n    }\r\n    \r\n    function claimBonus(address pair, address recipient) public lock {\r\n        require (allowedPairs[pair], \"LPReward: Not allowed pair\");\r\n        require (unclaimedAmounts[recipient][pair].length > 0 && (unclaimedAmounts[recipient][pair][0] > 0 || unclaimedAmounts[recipient][pair][1] > 0), \"LPReward: No undistributed fee bonuses\");\r\n        uint amountA;\r\n        uint amountB;\r\n        amountA = unclaimedAmounts[recipient][pair][0];\r\n        amountB = unclaimedAmounts[recipient][pair][1];\r\n        unclaimedAmounts[recipient][pair][0] = 0;\r\n        unclaimedAmounts[recipient][pair][1] = 0;\r\n\r\n        uint amountNbu = nbuAmountForPair(pair, amountA, amountB);\r\n        require (amountNbu > 0, \"LPReward: No NBU pairs to token A and token B\");\r\n        require (amountNbu <= availableReward(), \"LPReward: Available reward for the period is used\");\r\n        \r\n        IERC20(NBU).transfer(recipient, amountNbu);\r\n        lpRewardUsed = lpRewardUsed.add(amountNbu);\r\n        emit ClaimLiquidityNbu(recipient, amountNbu, amountA, amountB);            \r\n    }\r\n\r\n    function unclaimedAmountNbu(address recipient, address pair) external view returns (uint) {\r\n        uint amountA;\r\n        uint amountB;\r\n        if (unclaimedAmounts[recipient][pair].length != 0) {\r\n            amountA = unclaimedAmounts[recipient][pair][0];\r\n            amountB = unclaimedAmounts[recipient][pair][1];\r\n        } else  {\r\n            return 0;\r\n        }\r\n\r\n        return nbuAmountForPair(pair, amountA, amountB);\r\n    }\r\n\r\n    function unclaimedAmount(address recipient, address pair) external view returns (uint amountA, uint amountB) {\r\n        if (unclaimedAmounts[recipient][pair].length != 0) {\r\n            amountA = unclaimedAmounts[recipient][pair][0];\r\n            amountB = unclaimedAmounts[recipient][pair][1];\r\n        }\r\n    }\r\n\r\n    function availableReward() public view returns (uint) {\r\n        uint rewardForPeriod = lpRewardMaxAmount.mul(block.timestamp - startReward) / rewardPeriod;\r\n        if (rewardForPeriod > lpRewardUsed) return rewardForPeriod.sub(lpRewardUsed);\r\n        else return 0;\r\n    }\r\n\r\n    function nbuAmountForPair(address pair, uint amountA, uint amountB) private view returns (uint amountNbu) {\r\n        address tokenA = pairTokens[pair][0];\r\n        address tokenB = pairTokens[pair][1];\r\n        if (tokenA != NBU && tokenB != NBU) {\r\n            address tokenToNbuPair = swapFactory.getPair(tokenA, NBU);\r\n            if (tokenToNbuPair != address(0)) {\r\n                amountNbu = INimbusRouter(swapRouter).getAmountsOut(amountA, getPathForToken(tokenA))[1];\r\n            }\r\n\r\n            tokenToNbuPair = swapFactory.getPair(tokenB, NBU);\r\n            if (tokenToNbuPair != address(0)) {\r\n                if (amountNbu != 0) {\r\n                    amountNbu = amountNbu.add(INimbusRouter(swapRouter).getAmountsOut(amountB, getPathForToken(tokenB))[1]);\r\n                } else  {\r\n                    amountNbu = INimbusRouter(swapRouter).getAmountsOut(amountB, getPathForToken(tokenB))[1].mul(2);\r\n                }\r\n            } else {\r\n                amountNbu = amountNbu.mul(2);\r\n            }\r\n        } else if (tokenA == NBU) {\r\n            amountNbu = amountA.mul(2);\r\n        } else {\r\n            amountNbu = amountB.mul(2);\r\n        }\r\n    }\r\n\r\n    function getPathForToken(address token) private view returns (address[] memory) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = NBU;\r\n        return path;\r\n    }\r\n\r\n    function sortTokens(address tokenA, address tokenB) private pure returns (address token0, address token1) {\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n    }\r\n\r\n\r\n\r\n    function rescue(address payable to, uint256 amount) external onlyOwner {\r\n        require(to != address(0), \"LPReward: Address is zero\");\r\n        require(amount > 0, \"LPReward: Should be greater than 0\");\r\n        TransferHelper.safeTransferETH(to, amount);\r\n        emit Rescue(to, amount);\r\n    }\r\n\r\n    function rescue(address to, address token, uint256 amount) external onlyOwner {\r\n        require(to != address(0), \"LPReward: Address is zero\");\r\n        require(amount > 0, \"LPReward: Should be greater than 0\");\r\n        TransferHelper.safeTransfer(token, to, amount);\r\n        emit RescueToken(token, to, amount);\r\n    }\r\n\r\n    function updateSwapRouter(address newRouter) external onlyOwner {\r\n        require (newRouter != address(0), \"LPReward: Zero address\");\r\n        swapRouter = newRouter;\r\n    }\r\n\r\n    function updateAllowedPair(address tokenA, address tokenB, bool isAllowed) external onlyOwner {\r\n        require (tokenA != address(0) && tokenB != address(0) && tokenA != tokenB, \"LPReward: Wrong addresses\");\r\n        address pair = swapFactory.getPair(tokenA, tokenB);\r\n        require (pair != address(0), \"LPReward: Pair not exists\");\r\n        if (!allowedPairs[pair]) {\r\n            (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n            pairTokens[pair].push(token0);\r\n            pairTokens[pair].push(token1);\r\n        }\r\n        allowedPairs[pair] = isAllowed;\r\n    }\r\n\r\n    function updateRewardMaxAmount(uint newAmount) external onlyOwner {\r\n        lpRewardMaxAmount = newAmount;\r\n    }\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nbu\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nbu\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"ClaimLiquidityNbu\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weightedRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldWeighted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"RecordAddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nbu\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"RecordRemoveLiquidityGiveNbu\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"RecordRemoveLiquidityUnclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Rescue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RescueToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NBU\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"claimBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"claimBonusBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpRewardMaxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpRewardUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpTokenAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ratioUpdateLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"recordAddLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"recordRemoveLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFactory\",\"outputs\":[{\"internalType\":\"contract INimbusFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"unclaimedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"unclaimedAmountNbu\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unclaimedAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"updateAllowedPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateRewardMaxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"updateSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"weightedRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LPReward","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000eb58343b36c7528f23caae63a150240241310049000000000000000000000000c80a014b034756a9c97e3c1b6a3139d9fc42ecc0","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://19a26f5caf44c447163bfbc9ead29d26cd574a721996b2db1756ea61ee853354"}]}