{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.7.0;\r\n\r\ncontract SponsorPool {\r\n    using SafeMathLT for uint256;\r\n\r\n    address public owner;\r\n\r\n    IERC20Token public tokenA;\r\n    IERC20Token public tokenB;\r\n\r\n    uint256 public maxTriggerTotal = 20 ether;\r\n    uint256 public timeout = block.timestamp.add(2 hours);\r\n\r\n    UniswapRouterV2 public constant UNISWAP_ROUTER = UniswapRouterV2(\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D // mainnet\r\n    );\r\n    \r\n    event ReceiveETH(address account, uint256 amount);\r\n    event SwapExactETHForTokens(uint256 balance, uint256 tokens);\r\n    event AddLiquidity(uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    modifier onlyOwner() {\r\n       require(msg.sender == owner, 'wrong sender');\r\n        _;\r\n    }\r\n\r\n    constructor(IERC20Token _tokenA,IERC20Token _tokenB) {\r\n        owner = msg.sender;\r\n        tokenA = _tokenA;\r\n        tokenB = _tokenB;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit ReceiveETH(msg.sender, msg.value);\r\n    }\r\n\r\n    function getTokensBalance()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 _aBalance = tokenA.balanceOf(address(this));\r\n        uint256 _bBalance = tokenB.balanceOf(address(this));\r\n\r\n        return (_aBalance, _bBalance);\r\n    }\r\n\r\n    function forwardLiquidity(/*ðŸ¦„*/) public\r\n    {\r\n        if (address(this).balance > 0) {\r\n            uint256[] memory amounts = UNISWAP_ROUTER.swapExactETHForTokens{value: address(this).balance}(0, getPath(), address(this), timeout);\r\n            emit SwapExactETHForTokens(address(this).balance, amounts[1]);\r\n        }\r\n        \r\n        uint256 _aBalance;\r\n        uint256 _bBalance;\r\n\r\n        (_aBalance, _bBalance) = getTokensBalance();\r\n\r\n        if (_aBalance == 0 || _bBalance == 0) {\r\n            return;\r\n        }\r\n\r\n        tokenA.approve(address(UNISWAP_ROUTER), _aBalance);\r\n        tokenB.approve(address(UNISWAP_ROUTER), _bBalance);\r\n\r\n        (uint256 amountA, uint256 amountB, uint256 liquidity) = UNISWAP_ROUTER\r\n            .addLiquidity(\r\n            address(tokenA),\r\n            address(tokenB),\r\n            _aBalance,\r\n            _bBalance,\r\n            0,\r\n            0,\r\n            address(0x0),\r\n            timeout\r\n        );\r\n        \r\n        emit AddLiquidity(amountA, amountB, liquidity);\r\n    }\r\n    \r\n\r\n    function getPath() internal view returns (address[] memory) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = UNISWAP_ROUTER.WETH();\r\n        path[1] = address(tokenB);\r\n\r\n        return path;\r\n    }\r\n\r\n    function setMaxTriggerTotal(uint256 _v) external onlyOwner {\r\n        maxTriggerTotal = _v;\r\n    }\r\n\r\n    function setOwner(address _v) external onlyOwner {\r\n        owner = _v;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (\r\n        address pair\r\n    );\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n\r\n    function getReserves() external view returns (\r\n        uint112 reserve0,\r\n        uint112 reserve1,\r\n        uint32 blockTimestampLast\r\n    );\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function balanceOf(\r\n        address owner\r\n    ) external view returns (uint256);\r\n\r\n    function token1() external view returns (address);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface UniswapRouterV2 {\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenMax,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n        ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadlin\r\n    ) external payable returns (\r\n        uint[] memory amounts\r\n    );\r\n}\r\n\r\ninterface IERC20Token {\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n}\r\n\r\nlibrary SafeMathLT {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"modulo by zero\");\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Token\",\"name\":\"_tokenB\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceiveETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"SwapExactETHForTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER\",\"outputs\":[{\"internalType\":\"contract UniswapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwardLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTriggerTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_v\",\"type\":\"uint256\"}],\"name\":\"setMaxTriggerTotal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_v\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenA\",\"outputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenB\",\"outputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SponsorPool","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000e7d2914136e63f209f0e9de3100ed60ce18a3e8e000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9ecc424317544a08d10da1f72ecc5fd3eae7d68ccd86eac55c879f0f84dddf61"}]}