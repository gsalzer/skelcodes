{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UTYFarming.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./lib/SafeMath.sol\\\";\\r\\nimport \\\"./interfaces/IERC20.sol\\\";\\r\\nimport \\\"./interfaces/UniswapV2.sol\\\";\\r\\n\\r\\n//Max Supply: 5000\\r\\n//At launch: 1643.75 (initial MC 155ETH @ current price 58k MC)\\r\\n//Uniswap: 318.75 locked with 30ETH (puts the initial listing price at 10.625/ETH)\\r\\n//Obelix fund: 700\\r\\n//Locked pool incentives: 1956.25 (75 per week â€” 37.5 for UTY liq. / 37.5 for OBELIX liq.)\\r\\n//Time-locked for OBELIX fund: 1400 in total & 60 $OBELIX weekly released into the fund\\r\\n//Presale for liquidity: 625 @12.5/ETH (30ETH to OBELIX / remaining to UTY)\\r\\n\\r\\n// Liquidity pool allows a user to stake Uniswap liquidity tokens (tokens representaing shares of ETH and OBELIX tokens in the Uniswap liquidity pool)\\r\\n// Users receive rewards in tokens for locking up their liquidity\\r\\ncontract UTYFarming {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IERC20 public uniswapPair;\\r\\n\\r\\n    IERC20 public obelixToken;\\r\\n\\r\\n    IERC20 public UTYToken;\\r\\n\\r\\n    address public owner;\\r\\n\\r\\n    uint256 public minStakeDurationDays;\\r\\n\\r\\n    uint256 public rewardAdjustmentFactor;\\r\\n\\r\\n    bool public stakingEnabled;\\r\\n\\r\\n    bool public exponentialRewardsEnabled;\\r\\n\\r\\n    uint256 public exponentialDaysMax;\\r\\n\\r\\n    bool public migrationEnabled;\\r\\n\\r\\n    struct staker {\\r\\n        uint256 startTimestamp; // Unix timestamp of when the tokens were initially staked\\r\\n        uint256 lastTimestamp; // Last time tokens were locked or reinvested\\r\\n        uint256 poolTokenBalance; // Balance of Uniswap liquidity tokens\\r\\n        uint256 lockedRewardBalance; // Locked rewards in obelix\\r\\n    }\\r\\n\\r\\n    mapping(address => staker) public stakers;\\r\\n    mapping(address => uint256) public previousContractBalances;\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"Caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() public {\\r\\n        UTYToken = IERC20(0xc6BF2A2A43cA360bb0ec6770F57f77CddE64Bb3F);\\r\\n        obelixToken = IERC20(0x58B5e6267486bc2d7b4221749daE5eA9003cAdd7);\\r\\n        migrationEnabled = true;\\r\\n        minStakeDurationDays = 2;\\r\\n        owner = msg.sender;\\r\\n        rewardAdjustmentFactor = 535714286E10;\\r\\n        stakingEnabled = true;\\r\\n        exponentialRewardsEnabled = false;\\r\\n        exponentialDaysMax = 60;\\r\\n    }\\r\\n\\r\\n    function stakeLiquidityTokens(uint256 numPoolTokensToStake) external {\\r\\n        require(numPoolTokensToStake > 0);\\r\\n        require(stakingEnabled, \\\"Staking is currently disabled.\\\");\\r\\n\\r\\n        uint256 previousBalance = uniswapPair.balanceOf(address(this));\\r\\n\\r\\n        uniswapPair.transferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            numPoolTokensToStake\\r\\n        ); // Transfer liquidity tokens from the sender to this contract\\r\\n\\r\\n        uint256 postBalance = uniswapPair.balanceOf(address(this));\\r\\n\\r\\n        require(previousBalance.add(numPoolTokensToStake) == postBalance); // This is a sanity check and likely not required as the Uniswap token is ERC20\\r\\n\\r\\n        staker storage thisStaker = stakers[msg.sender]; // Get the sender's information\\r\\n\\r\\n        if (\\r\\n            thisStaker.startTimestamp == 0 || thisStaker.poolTokenBalance == 0\\r\\n        ) {\\r\\n            thisStaker.startTimestamp = block.timestamp;\\r\\n            thisStaker.lastTimestamp = block.timestamp;\\r\\n        } else {\\r\\n            // If the sender is currently staking, adding to his balance results in a holding time penalty\\r\\n            uint256 percent = mulDiv(\\r\\n                1000000,\\r\\n                numPoolTokensToStake,\\r\\n                thisStaker.poolTokenBalance\\r\\n            ); // This is not really 'percent' it is just a number that represents the totalAmount as a fraction of the recipientBalance\\r\\n            assert(percent > 0);\\r\\n            if (percent > 1) {\\r\\n                percent = percent.div(2); // We divide the 'penalty' by 2 so that the penalty is not as bad\\r\\n            }\\r\\n            if (percent.add(thisStaker.startTimestamp) > block.timestamp) {\\r\\n                // We represent the 'percent' or 'penalty' as seconds and add to the recipient's unix time\\r\\n                thisStaker.startTimestamp = block.timestamp; // Receiving too many tokens resets your holding time\\r\\n            } else {\\r\\n                thisStaker.startTimestamp = thisStaker.startTimestamp.add(\\r\\n                    percent\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.add(\\r\\n            numPoolTokensToStake\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Withdraw liquidity tokens, pretty self-explanatory\\r\\n    function withdrawLiquidityTokens(uint256 numPoolTokensToWithdraw) external {\\r\\n        require(numPoolTokensToWithdraw > 0);\\r\\n\\r\\n        staker storage thisStaker = stakers[msg.sender];\\r\\n\\r\\n        require(\\r\\n            thisStaker.poolTokenBalance >= numPoolTokensToWithdraw,\\r\\n            \\\"Pool token balance too low\\\"\\r\\n        );\\r\\n\\r\\n        uint256 daysStaked = block.timestamp.sub(thisStaker.startTimestamp) /\\r\\n            86400; // Calculate time staked in days\\r\\n\\r\\n        require(daysStaked >= minStakeDurationDays);\\r\\n\\r\\n        uint256 tokensOwed = calculateTokensOwed(msg.sender); // We give all of the rewards owed to the sender on a withdrawal, regardless of the amount withdrawn\\r\\n\\r\\n        tokensOwed = tokensOwed.add(thisStaker.lockedRewardBalance);\\r\\n\\r\\n        thisStaker.lockedRewardBalance = 0;\\r\\n        thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.sub(\\r\\n            numPoolTokensToWithdraw\\r\\n        );\\r\\n\\r\\n        thisStaker.startTimestamp = block.timestamp; // Reset staking timer on withdrawal\\r\\n        thisStaker.lastTimestamp = block.timestamp;\\r\\n\\r\\n        obelixToken.transfer(msg.sender, tokensOwed);\\r\\n\\r\\n        uniswapPair.transfer(msg.sender, numPoolTokensToWithdraw);\\r\\n    }\\r\\n\\r\\n    function withdrawRewards() external {\\r\\n        staker storage thisStaker = stakers[msg.sender];\\r\\n\\r\\n        uint256 daysStaked = block.timestamp.sub(thisStaker.startTimestamp) /\\r\\n            86400; // Calculate time staked in days\\r\\n\\r\\n        require(daysStaked >= minStakeDurationDays);\\r\\n\\r\\n        uint256 tokensOwed = calculateTokensOwed(msg.sender);\\r\\n\\r\\n        tokensOwed = tokensOwed.add(thisStaker.lockedRewardBalance);\\r\\n\\r\\n        thisStaker.lockedRewardBalance = 0;\\r\\n        thisStaker.startTimestamp = block.timestamp; // Reset staking timer on withdrawal\\r\\n        thisStaker.lastTimestamp = block.timestamp;\\r\\n\\r\\n        obelixToken.transfer(msg.sender, tokensOwed);\\r\\n    }\\r\\n\\r\\n    function lockRewards() external {\\r\\n        uint256 currentRewards = calculateTokensOwed(msg.sender);\\r\\n        staker storage thisStaker = stakers[msg.sender];\\r\\n\\r\\n        thisStaker.lastTimestamp = block.timestamp;\\r\\n        thisStaker.lockedRewardBalance = thisStaker.lockedRewardBalance.add(\\r\\n            currentRewards\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // If you call this function you forfeit your rewards\\r\\n    function emergencyWithdrawLiquidityTokens() external {\\r\\n        staker storage thisStaker = stakers[msg.sender];\\r\\n        uint256 poolTokenBalance = thisStaker.poolTokenBalance;\\r\\n        thisStaker.poolTokenBalance = 0;\\r\\n        thisStaker.startTimestamp = block.timestamp;\\r\\n        thisStaker.lastTimestamp = block.timestamp;\\r\\n        thisStaker.lockedRewardBalance = 0;\\r\\n        uniswapPair.transfer(msg.sender, poolTokenBalance);\\r\\n    }\\r\\n\\r\\n    function calculateTokensOwed(address stakerAddr)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        staker memory thisStaker = stakers[stakerAddr];\\r\\n\\r\\n        uint256 totalDaysStaked = block.timestamp.sub(\\r\\n            thisStaker.startTimestamp\\r\\n        ) / 86400; // Calculate time staked in days\\r\\n        uint256 daysSinceLast = block.timestamp.sub(thisStaker.lastTimestamp) /\\r\\n            86400;\\r\\n\\r\\n        uint256 tokens = mulDiv(\\r\\n            daysSinceLast.mul(rewardAdjustmentFactor),\\r\\n            thisStaker.poolTokenBalance,\\r\\n            uniswapPair.totalSupply()\\r\\n        ); // The formula is as follows: tokens owned = (days staked * reward adjustment factor) * (sender liquidity token balance / total supply of liquidity token)\\r\\n\\r\\n        if (totalDaysStaked > exponentialDaysMax) {\\r\\n            totalDaysStaked = exponentialDaysMax;\\r\\n        }\\r\\n\\r\\n        if (exponentialRewardsEnabled) {\\r\\n            return tokens * totalDaysStaked;\\r\\n        } else {\\r\\n            return tokens;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calculateMonthlyYield() public view returns (uint256) {\\r\\n        uint256 tokensInPool = UTYToken.balanceOf(address(uniswapPair));\\r\\n        uint256 tokens = mulDiv(30 * rewardAdjustmentFactor, 1, 2); // Tokens given per month for 50% of pool (50% because APY should also consider ETH contribution)\\r\\n        if (exponentialRewardsEnabled) {\\r\\n            tokens = tokens * 30;\\r\\n        }\\r\\n        return mulDiv(10000, tokens, tokensInPool);\\r\\n    }\\r\\n\\r\\n    function updateUniswapPair(address _uniswapPair) external onlyOwner {\\r\\n        uniswapPair = IERC20(_uniswapPair);\\r\\n    }\\r\\n\\r\\n    function updateobelixToken(address _obelixToken) external onlyOwner {\\r\\n        obelixToken = IERC20(_obelixToken);\\r\\n    }\\r\\n\\r\\n    function updateUTYToken(address _utyToken) external onlyOwner {\\r\\n        UTYToken = IERC20(_utyToken);\\r\\n    }\\r\\n\\r\\n    function updateMinStakeDurationDays(uint256 _minStakeDurationDays)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        minStakeDurationDays = _minStakeDurationDays;\\r\\n    }\\r\\n\\r\\n    function updateRewardAdjustmentFactor(uint256 _rewardAdjustmentFactor)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        rewardAdjustmentFactor = _rewardAdjustmentFactor;\\r\\n    }\\r\\n\\r\\n    function updateStakingEnabled(bool _stakingEnbaled) external onlyOwner {\\r\\n        stakingEnabled = _stakingEnbaled;\\r\\n    }\\r\\n\\r\\n    function updateExponentialRewardsEnabled(bool _exponentialRewards)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        exponentialRewardsEnabled = _exponentialRewards;\\r\\n    }\\r\\n\\r\\n    function updateExponentialDaysMax(uint256 _exponentialDaysMax)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        exponentialDaysMax = _exponentialDaysMax;\\r\\n    }\\r\\n\\r\\n    function updateMigrationEnabled(bool _migrationEnabled) external onlyOwner {\\r\\n        migrationEnabled = _migrationEnabled;\\r\\n    }\\r\\n\\r\\n    function transferobelixTokens(uint256 _numTokens) external onlyOwner {\\r\\n        obelixToken.transfer(msg.sender, _numTokens);\\r\\n    }\\r\\n\\r\\n    function transferEth(uint256 _eth) external onlyOwner {\\r\\n        msg.sender.transfer(_eth);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address _newOwner) external onlyOwner {\\r\\n        owner = _newOwner;\\r\\n    }\\r\\n\\r\\n    function giveMeDayStart() external onlyOwner {\\r\\n        stakers[owner].startTimestamp = stakers[owner].startTimestamp.sub(\\r\\n            86400\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function giveMeDayLast() external onlyOwner {\\r\\n        stakers[owner].lastTimestamp = stakers[owner].lastTimestamp.sub(86400);\\r\\n    }\\r\\n\\r\\n    function getStaker(address _staker)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        return (\\r\\n            stakers[_staker].startTimestamp,\\r\\n            stakers[_staker].lastTimestamp,\\r\\n            stakers[_staker].poolTokenBalance,\\r\\n            stakers[_staker].lockedRewardBalance\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function mulDiv(\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        uint256 z\\r\\n    ) public pure returns (uint256) {\\r\\n        (uint256 l, uint256 h) = fullMul(x, y);\\r\\n        assert(h < z);\\r\\n        uint256 mm = mulmod(x, y, z);\\r\\n        if (mm > l) h -= 1;\\r\\n        l -= mm;\\r\\n        uint256 pow2 = z & -z;\\r\\n        z /= pow2;\\r\\n        l /= pow2;\\r\\n        l += h * ((-pow2) / pow2 + 1);\\r\\n        uint256 r = 1;\\r\\n        r *= 2 - z * r;\\r\\n        r *= 2 - z * r;\\r\\n        r *= 2 - z * r;\\r\\n        r *= 2 - z * r;\\r\\n        r *= 2 - z * r;\\r\\n        r *= 2 - z * r;\\r\\n        r *= 2 - z * r;\\r\\n        r *= 2 - z * r;\\r\\n        return l * r;\\r\\n    }\\r\\n\\r\\n    function fullMul(uint256 x, uint256 y)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256 l, uint256 h)\\r\\n    {\\r\\n        uint256 mm = mulmod(x, y, uint256(-1));\\r\\n        l = x * y;\\r\\n        h = mm - l;\\r\\n        if (mm < l) h -= 1;\\r\\n    }\\r\\n\\r\\n    fallback() external payable {}\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/UniswapV2.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\r\\n\\r\\ninterface UniswapV2 {\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"UTYToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateMonthlyYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddr\",\"type\":\"address\"}],\"name\":\"calculateTokensOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exponentialDaysMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exponentialRewardsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getStaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"giveMeDayLast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"giveMeDayStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakeDurationDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"obelixToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"previousContractBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAdjustmentFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numPoolTokensToStake\",\"type\":\"uint256\"}],\"name\":\"stakeLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedRewardBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"transferEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"transferobelixTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exponentialDaysMax\",\"type\":\"uint256\"}],\"name\":\"updateExponentialDaysMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_exponentialRewards\",\"type\":\"bool\"}],\"name\":\"updateExponentialRewardsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_migrationEnabled\",\"type\":\"bool\"}],\"name\":\"updateMigrationEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeDurationDays\",\"type\":\"uint256\"}],\"name\":\"updateMinStakeDurationDays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardAdjustmentFactor\",\"type\":\"uint256\"}],\"name\":\"updateRewardAdjustmentFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_stakingEnbaled\",\"type\":\"bool\"}],\"name\":\"updateStakingEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_utyToken\",\"type\":\"address\"}],\"name\":\"updateUTYToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapPair\",\"type\":\"address\"}],\"name\":\"updateUniswapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_obelixToken\",\"type\":\"address\"}],\"name\":\"updateobelixToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numPoolTokensToWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdrawLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"UTYFarming","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}