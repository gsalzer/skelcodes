{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/constants/CDebtBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nfunction GAS_COSTS_FOR_FULL_REFINANCE() pure returns(uint256[4] memory) {\\n    return [uint256(2519000), 3140500, 3971000, 4345000];\\n}\"\r\n    },\r\n    \"contracts/constants/CGelato.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IGelatoGasPriceOracle\\n} from \\\"../interfaces/gelato/IGelatoGasPriceOracle.sol\\\";\\n\\nIGelatoGasPriceOracle constant GELATO_GAS_PRICE_ORACLE = IGelatoGasPriceOracle(\\n    0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C\\n);\\n\"\r\n    },\r\n    \"contracts/constants/CInstaDapp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\n// InstaDapp\\naddress constant INSTA_MEMORY = 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F;\\n\\n// Connectors\\naddress constant CONNECT_MAKER = 0xac02030d8a8F49eD04b2f52C394D3F901A10F8A9;\\naddress constant CONNECT_COMPOUND = 0x07F81230d73a78f63F0c2A3403AD281b067d28F8;\\naddress constant INSTA_POOL_V2 = 0x3150e5A805577366816A1ddc7330c6Ea17070c05;\\n\\n// Tokens\\naddress constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n// Insta Pool\\naddress constant INSTA_POOL_RESOLVER = 0xa004a5afBa04b74037E9E52bA1f7eb02b5E61509;\\nuint256 constant ROUTE_1_TOLERANCE = 1005e15;\"\r\n    },\r\n    \"contracts/constants/CMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\naddress constant MCD_MANAGER = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\"\r\n    },\r\n    \"contracts/contracts/connectors/ConnectGelatoDataFullRefinanceMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\nimport {sub} from \\\"../../vendor/DSMath.sol\\\";\\nimport {\\n    AccountInterface,\\n    ConnectorInterface\\n} from \\\"../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {\\n    DAI,\\n    CONNECT_MAKER,\\n    CONNECT_COMPOUND,\\n    INSTA_POOL_V2\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault,\\n    _encodeOpenMakerVault,\\n    _encodedDepositMakerVault,\\n    _encodeBorrowMakerVault\\n} from \\\"../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodePayGelatoProvider\\n} from \\\"../../functions/InstaDapp/connectors/FConnectGelatoProviderPayment.sol\\\";\\nimport {\\n    _encodeDepositCompound,\\n    _encodeBorrowCompound\\n} from \\\"../../functions/InstaDapp/connectors/FConnectCompound.sol\\\";\\nimport {_getGelatoProviderFees} from \\\"../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToMaker,\\n    _getGasCostMakerToCompound,\\n    _getRealisedDebt\\n} from \\\"../../functions/gelato/FGelatoDebtBridge.sol\\\";\\n\\ncontract ConnectGelatoDataFullRefinanceMaker is ConnectorInterface {\\n    using GelatoBytes for bytes;\\n\\n    // solhint-disable const-name-snakecase\\n    string\\n        public constant\\n        override name = \\\"ConnectGelatoDataFullRefinanceMaker-v1.0\\\";\\n    uint256 internal immutable _id;\\n    address internal immutable _connectGelatoProviderPayment;\\n\\n    constructor(uint256 id, address connectGelatoProviderPayment) {\\n        _id = id;\\n        _connectGelatoProviderPayment = connectGelatoProviderPayment;\\n    }\\n\\n    /// @dev Connector Details\\n    function connectorID()\\n        external\\n        view\\n        override\\n        returns (uint256 _type, uint256 id)\\n    {\\n        (_type, id) = (1, _id); // Should put specific value.\\n    }\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _vaultAId Id of the unsafe vault of the client of Vault A Collateral.\\n    /// @param _vaultBId Id of the vault B Collateral of the client.\\n    /// @param _colToken  vault's col token address .\\n    /// @param _colType colType of the new vault. example : ETH-B, ETH-A.\\n    function getDataAndCastMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        address _colToken,\\n        string calldata _colType\\n    ) external payable {\\n        (address[] memory targets, bytes[] memory datas) = _dataMakerToMaker(\\n            _vaultAId,\\n            _vaultBId,\\n            _colToken,\\n            _colType\\n        );\\n\\n        _cast(targets, datas);\\n    }\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from Maker to Compound\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _vaultId Id of the unsafe vault of the client.\\n    /// @param _colToken  vault's col token address .\\n    function getDataAndCastMakerToCompound(uint256 _vaultId, address _colToken)\\n        external\\n        payable\\n    {\\n        (address[] memory targets, bytes[] memory datas) = _dataMakerToCompound(\\n            _vaultId,\\n            _colToken\\n        );\\n\\n        _cast(targets, datas);\\n    }\\n\\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\\n        // Instapool V2 / FlashLoan call\\n        bytes memory castData = abi.encodeWithSelector(\\n            AccountInterface.cast.selector,\\n            targets,\\n            datas,\\n            msg.sender // msg.sender == GelatoCore\\n        );\\n\\n        (bool success, bytes memory returndata) = address(this).delegatecall(\\n            castData\\n        );\\n        if (!success) {\\n            returndata.revertWithError(\\n                \\\"ConnectGelatoDataFullRefinanceMaker._cast:\\\"\\n            );\\n        }\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        address _colToken,\\n        string calldata _colType\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultAId));\\n        uint256 wColToWithdrawFromMaker = _getMakerVaultCollateralBalance(\\n            _vaultAId\\n        );\\n        uint256 route = _getFlashLoanRoute(DAI, wDaiToBorrow);\\n        uint256 gasCost = _getGasCostMakerToMaker(_vaultBId == 0, route);\\n        uint256 gasFeesPaidFromCol = _getGelatoProviderFees(gasCost);\\n\\n        (address[] memory _targets, bytes[] memory _datas) = _vaultBId == 0\\n            ? _spellsMakerToNewMakerVault(\\n                _vaultAId,\\n                _colToken,\\n                _colType,\\n                wDaiToBorrow,\\n                wColToWithdrawFromMaker,\\n                gasFeesPaidFromCol\\n            )\\n            : _spellsMakerToMaker(\\n                _vaultAId,\\n                _vaultBId,\\n                _colToken,\\n                wDaiToBorrow,\\n                wColToWithdrawFromMaker,\\n                gasFeesPaidFromCol\\n            );\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            wDaiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    function _spellsMakerToNewMakerVault(\\n        uint256 _vaultAId,\\n        address _colToken,\\n        string calldata _colType,\\n        uint256 _wDaiToBorrow,\\n        uint256 _wColToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromCol\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](7);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = CONNECT_MAKER; // open new B vault\\n        targets[3] = CONNECT_MAKER; // deposit\\n        targets[4] = CONNECT_MAKER; // borrow\\n        targets[5] = _connectGelatoProviderPayment; // payProvider\\n        targets[6] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](7);\\n        datas[0] = _encodePaybackMakerVault(_vaultAId, uint256(-1), 0, 600);\\n        datas[1] = _encodedWithdrawMakerVault(_vaultAId, uint256(-1), 0, 0);\\n        datas[2] = _encodeOpenMakerVault(_colType);\\n        datas[3] = _encodedDepositMakerVault(\\n            0,\\n            sub(_wColToWithdrawFromMaker, _gasFeesPaidFromCol),\\n            0,\\n            0\\n        );\\n        datas[4] = _encodeBorrowMakerVault(0, 0, 600, 0);\\n        datas[5] = _encodePayGelatoProvider(\\n            _colToken,\\n            _gasFeesPaidFromCol,\\n            0,\\n            0\\n        );\\n        datas[6] = _encodeFlashPayback(DAI, _wDaiToBorrow, 0, 0);\\n    }\\n\\n    function _spellsMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        address _colToken,\\n        uint256 _wDaiToBorrow,\\n        uint256 _wColToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromCol\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](6);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = CONNECT_MAKER; // deposit\\n        targets[3] = CONNECT_MAKER; // borrow\\n        targets[4] = _connectGelatoProviderPayment; // payProvider\\n        targets[5] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](6);\\n        datas[0] = _encodePaybackMakerVault(_vaultAId, uint256(-1), 0, 600);\\n        datas[1] = _encodedWithdrawMakerVault(_vaultAId, uint256(-1), 0, 0);\\n        datas[2] = _encodedDepositMakerVault(\\n            _vaultBId,\\n            sub(_wColToWithdrawFromMaker, _gasFeesPaidFromCol),\\n            0,\\n            0\\n        );\\n        datas[3] = _encodeBorrowMakerVault(_vaultBId, 0, 600, 0);\\n        datas[4] = _encodePayGelatoProvider(\\n            _colToken,\\n            _gasFeesPaidFromCol,\\n            0,\\n            0\\n        );\\n        datas[5] = _encodeFlashPayback(DAI, _wDaiToBorrow, 0, 0);\\n    }\\n\\n    function _dataMakerToCompound(uint256 _vaultId, address _colToken)\\n        internal\\n        view\\n        returns (address[] memory targets, bytes[] memory datas)\\n    {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\\n        uint256 wColToWithdrawFromMaker = _getMakerVaultCollateralBalance(\\n            _vaultId\\n        );\\n        uint256 route = _getFlashLoanRoute(DAI, wDaiToBorrow);\\n        uint256 gasCost = _getGasCostMakerToCompound(route);\\n        uint256 gasFeesPaidFromCol = _getGelatoProviderFees(gasCost);\\n\\n        address[] memory _targets = new address[](6);\\n        _targets[0] = CONNECT_MAKER; // payback\\n        _targets[1] = CONNECT_MAKER; // withdraw\\n        _targets[2] = CONNECT_COMPOUND; // deposit\\n        _targets[3] = CONNECT_COMPOUND; // borrow\\n        _targets[4] = _connectGelatoProviderPayment; // payProvider\\n        _targets[5] = INSTA_POOL_V2; // flashPayback\\n\\n        bytes[] memory _datas = new bytes[](6);\\n        _datas[0] = _encodePaybackMakerVault(_vaultId, uint256(-1), 0, 600);\\n        _datas[1] = _encodedWithdrawMakerVault(_vaultId, uint256(-1), 0, 0);\\n        _datas[2] = _encodeDepositCompound(\\n            _colToken,\\n            sub(wColToWithdrawFromMaker, gasFeesPaidFromCol),\\n            0,\\n            0\\n        );\\n        _datas[3] = _encodeBorrowCompound(DAI, 0, 600, 0);\\n        _datas[4] = _encodePayGelatoProvider(\\n            _colToken,\\n            gasFeesPaidFromCol,\\n            0,\\n            0\\n        );\\n        _datas[5] = _encodeFlashPayback(DAI, wDaiToBorrow, 0, 0);\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            wDaiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IConnectCompound\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectCompound.sol\\\";\\n\\nfunction _encodeDepositCompound(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectCompound.deposit.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodeBorrowCompound(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectCompound.borrow.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectGelatoProviderPayment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IConnectGelatoProviderPayment\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectGelatoProviderPayment.sol\\\";\\n\\nfunction _encodePayGelatoProvider(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectGelatoProviderPayment.payProvider.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IConnectMaker\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectMaker.sol\\\";\\n\\nfunction _encodeOpenMakerVault(string memory _colType)\\n    pure\\n    returns (bytes memory)\\n{\\n    return abi.encodeWithSelector(IConnectMaker.open.selector, _colType);\\n}\\n\\nfunction _encodeBorrowMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.borrow.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodedDepositMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.deposit.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodePaybackMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.payback.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodedWithdrawMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.withdraw.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FInstaPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\n\\nfunction _encodeFlashPayback(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashPayback.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/dapps/FMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {MCD_MANAGER} from \\\"../../constants/CMaker.sol\\\";\\nimport {IMcdManager} from \\\"../../interfaces/dapps/Maker/IMcdManager.sol\\\";\\nimport {IVat} from \\\"../../interfaces/dapps/Maker/IVat.sol\\\";\\nimport {RAY, sub, mul} from \\\"../../vendor/DSMath.sol\\\";\\n\\nfunction _getMakerVaultDebt(uint256 _vaultId) view returns (uint256 wad) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    IVat vat = IVat(manager.vat());\\n    (, uint256 rate, , , ) = vat.ilks(ilk);\\n    (, uint256 art) = vat.urns(ilk, urn);\\n    uint256 dai = vat.dai(urn);\\n\\n    uint256 rad = sub(mul(art, rate), dai);\\n    wad = rad / RAY;\\n\\n    wad = mul(wad, RAY) < rad ? wad + 1 : wad;\\n}\\n\\nfunction _getMakerRawVaultDebt(uint256 _vaultId) view returns (uint256 tab) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    IVat vat = IVat(manager.vat());\\n    (, uint256 rate, , , ) = vat.ilks(ilk);\\n    (, uint256 art) = vat.urns(ilk, urn);\\n\\n    uint256 rad = mul(art, rate);\\n\\n    tab = rad / RAY;\\n    tab = mul(tab, RAY) < rad ? tab + 1 : tab;\\n}\\n\\nfunction _getMakerVaultCollateralBalance(uint256 _vaultId)\\n    view\\n    returns (uint256)\\n{\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    IVat vat = IVat(manager.vat());\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    (uint256 ink, ) = vat.urns(ilk, urn);\\n\\n    return ink;\\n}\\n\\nfunction _getVaultData(IMcdManager manager, uint256 vault)\\n    view\\n    returns (bytes32 ilk, address urn)\\n{\\n    ilk = manager.ilks(vault);\\n    urn = manager.urns(vault);\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/FGelato.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {GELATO_GAS_PRICE_ORACLE} from \\\"../../constants/CGelato.sol\\\";\\nimport {mul} from \\\"../../vendor/DSMath.sol\\\";\\n\\nfunction _getGelatoGasPrice() view returns (uint256) {\\n    return uint256(GELATO_GAS_PRICE_ORACLE.latestAnswer());\\n}\\n\\nfunction _getGelatoProviderFees(uint256 _gas) view returns (uint256) {\\n    return mul(_gas, _getGelatoGasPrice());\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/FGelatoDebtBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {add, sub, wmul, wdiv} from \\\"../../vendor/DSMath.sol\\\";\\nimport {\\n    INSTA_POOL_RESOLVER,\\n    ROUTE_1_TOLERANCE\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {GAS_COSTS_FOR_FULL_REFINANCE} from \\\"../../constants/CDebtBridge.sol\\\";\\nimport {\\n    IInstaPoolResolver\\n} from \\\"../../interfaces/InstaDapp/resolvers/IInstaPoolResolver.sol\\\";\\n\\nfunction _wCalcCollateralToWithdraw(\\n    uint256 _wMinColRatioA,\\n    uint256 _wMinColRatioB,\\n    uint256 _wColPrice,\\n    uint256 _wPricedCol,\\n    uint256 _wDebtOnA\\n) pure returns (uint256) {\\n    return\\n        wdiv(\\n            sub(\\n                _wPricedCol,\\n                wdiv(\\n                    sub(\\n                        wmul(_wMinColRatioA, _wPricedCol),\\n                        wmul(_wMinColRatioA, wmul(_wMinColRatioB, _wDebtOnA))\\n                    ),\\n                    sub(_wMinColRatioA, _wMinColRatioB)\\n                )\\n            ),\\n            _wColPrice\\n        );\\n}\\n\\nfunction _wCalcDebtToRepay(\\n    uint256 _wMinColRatioA,\\n    uint256 _wMinColRatioB,\\n    uint256 _wPricedCol,\\n    uint256 _wDebtOnA\\n) pure returns (uint256) {\\n    return\\n        sub(\\n            _wDebtOnA,\\n            wmul(\\n                wdiv(1e18, _wMinColRatioA),\\n                wdiv(\\n                    sub(\\n                        wmul(_wMinColRatioA, _wPricedCol),\\n                        wmul(_wMinColRatioA, wmul(_wMinColRatioB, _wDebtOnA))\\n                    ),\\n                    sub(_wMinColRatioA, _wMinColRatioB)\\n                )\\n            )\\n        );\\n}\\n\\nfunction _getFlashLoanRoute(address _tokenA, uint256 _wTokenADebtToMove)\\n    view\\n    returns (uint256)\\n{\\n    IInstaPoolResolver.RouteData memory rData = IInstaPoolResolver(\\n        INSTA_POOL_RESOLVER\\n    )\\n        .getTokenLimit(_tokenA);\\n\\n    if (rData.dydx > _wTokenADebtToMove) return 0;\\n    if (rData.maker > _wTokenADebtToMove) return 1;\\n    if (rData.compound > _wTokenADebtToMove) return 2;\\n    if (rData.aave > _wTokenADebtToMove) return 3;\\n    revert(\\\"FGelatoDebtBridge._getFlashLoanRoute: illiquid\\\");\\n}\\n\\nfunction _getGasCostMakerToMaker(bool _newVault, uint256 _route)\\n    pure\\n    returns (uint256)\\n{\\n    _checkRouteIndex(_route);\\n    return\\n        _newVault\\n            ? add(GAS_COSTS_FOR_FULL_REFINANCE()[_route], 0)\\n            : GAS_COSTS_FOR_FULL_REFINANCE()[_route];\\n}\\n\\nfunction _getGasCostMakerToCompound(uint256 _route) pure returns (uint256) {\\n    _checkRouteIndex(_route);\\n    return GAS_COSTS_FOR_FULL_REFINANCE()[_route];\\n}\\n\\nfunction _getRealisedDebt(uint256 _debtToMove) pure returns (uint256) {\\n    return wmul(_debtToMove, ROUTE_1_TOLERANCE);\\n}\\n\\nfunction _checkRouteIndex(uint256 _route) pure {\\n    require(\\n        _route <= 4,\\n        \\\"FGelatoDebtBridge._getGasCostMakerToMaker: invalid route index\\\"\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/IInstaDapp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\n/// @notice Interface InstaDapp Index\\ninterface IndexInterface {\\n    function connectors(uint256 version) external view returns (address);\\n\\n    function list() external view returns (address);\\n}\\n\\n/// @notice Interface InstaDapp List\\ninterface ListInterface {\\n    function accountID(address _account) external view returns (uint64);\\n}\\n\\n/// @notice Interface InstaDapp InstaMemory\\ninterface MemoryInterface {\\n    function setUint(uint256 _id, uint256 _val) external;\\n\\n    function getUint(uint256 _id) external returns (uint256);\\n}\\n\\n/// @notice Interface InstaDapp Defi Smart Account wallet\\ninterface AccountInterface {\\n    function cast(\\n        address[] calldata _targets,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) external payable returns (bytes32[] memory responses);\\n\\n    function version() external view returns (uint256);\\n\\n    function isAuth(address user) external view returns (bool);\\n\\n    function shield() external view returns (bool);\\n}\\n\\ninterface ConnectorInterface {\\n    function connectorID() external view returns (uint256 _type, uint256 _id);\\n\\n    function name() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IConnectCompound {\\n    function borrow(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function deposit(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectGelatoProviderPayment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport {ConnectorInterface} from \\\"../IInstaDapp.sol\\\";\\n\\ninterface IConnectGelatoProviderPayment is ConnectorInterface {\\n    function setProvider(address _provider) external;\\n\\n    function payProvider(\\n        address _token,\\n        uint256 _amt,\\n        uint256 _getId,\\n        uint256 _setId\\n    ) external payable;\\n\\n    function gelatoProvider() external view returns (address);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function GELATO_CORE() external pure returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IConnectInstaPoolV2 {\\n    function flashBorrowAndCast(\\n        address token,\\n        uint256 amt,\\n        uint256 route,\\n        bytes memory data\\n    ) external payable;\\n\\n    function flashPayback(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IConnectMaker {\\n    function payback(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function borrow(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function open(string calldata colType)\\n        external\\n        payable\\n        returns (uint256 vault);\\n\\n    function withdraw(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function deposit(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/resolvers/IInstaPoolResolver.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface IInstaPoolResolver {\\n    struct RouteData {\\n        uint256 dydx;\\n        uint256 maker;\\n        uint256 compound;\\n        uint256 aave;\\n    }\\n\\n    function getTokenLimit(address token)\\n        external\\n        view\\n        returns (RouteData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/IMcdManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IMcdManager {\\n    function ilks(uint256) external view returns (bytes32);\\n\\n    function urns(uint256) external view returns (address);\\n\\n    function vat() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/IVat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IVat {\\n    function ilks(bytes32)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function dai(address) external view returns (uint256);\\n\\n    function urns(bytes32, address) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/gelato/IGelatoGasPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\ninterface IGelatoGasPriceOracle {\\n    function latestAnswer() external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GelatoBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nlibrary GelatoBytes {\\n    function calldataSliceSelector(bytes calldata _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function memorySliceSelector(bytes memory _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\\n            } else {\\n                revert(\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"))\\n                );\\n            }\\n        } else {\\n            revert(\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"))\\n            );\\n        }\\n    }\\n\\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\\n            } else {\\n                return\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"));\\n            }\\n        } else {\\n            return\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/DSMath.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: AGPL-3.0-or-later\\\"\\n/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.4;\\n\\nfunction add(uint x, uint y) pure returns (uint z) {\\n    require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n}\\nfunction sub(uint x, uint y) pure returns (uint z) {\\n    require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n}\\nfunction mul(uint x, uint y) pure returns (uint z) {\\n    require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n}\\n\\nfunction min(uint x, uint y) pure returns (uint z) {\\n    return x <= y ? x : y;\\n}\\nfunction max(uint x, uint y) pure returns (uint z) {\\n    return x >= y ? x : y;\\n}\\nfunction imin(int x, int y) pure returns (int z) {\\n    return x <= y ? x : y;\\n}\\nfunction imax(int x, int y) pure returns (int z) {\\n    return x >= y ? x : y;\\n}\\n\\nuint constant WAD = 10 ** 18;\\nuint constant RAY = 10 ** 27;\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction wmul(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, y), WAD / 2) / WAD;\\n}\\n//rounds to zero if x*y < WAD / 2\\nfunction rmul(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, y), RAY / 2) / RAY;\\n}\\n//rounds to zero if x*y < WAD / 2\\nfunction wdiv(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, WAD), y / 2) / y;\\n}\\n//rounds to zero if x*y < RAY / 2\\nfunction rdiv(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, RAY), y / 2) / y;\\n}\\n\\n// This famous algorithm is called \\\"exponentiation by squaring\\\"\\n// and calculates x^n with x as fixed-point and n as regular unsigned.\\n//\\n// It's O(log n), instead of O(n) for naive repeated multiplication.\\n//\\n// These facts are why it works:\\n//\\n//  If n is even, then x^n = (x^2)^(n/2).\\n//  If n is odd,  then x^n = x * x^(n-1),\\n//   and applying the equation for even x gives\\n//    x^n = x * (x^2)^((n-1) / 2).\\n//\\n//  Also, EVM division is flooring and\\n//    floor[(n-1) / 2] = floor[n / 2].\\n//\\nfunction rpow(uint x, uint n) pure returns (uint z) {\\n    z = n % 2 != 0 ? x : RAY;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n        x = rmul(x, x);\\n\\n        if (n % 2 != 0) {\\n            z = rmul(z, x);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"connectGelatoProviderPayment\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"connectorID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_colToken\",\"type\":\"address\"}],\"name\":\"getDataAndCastMakerToCompound\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultAId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vaultBId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_colToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_colType\",\"type\":\"string\"}],\"name\":\"getDataAndCastMakerToMaker\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConnectGelatoDataFullRefinanceMaker","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000034000000000000000000000000d6d097ebeb8ffab4c5e27e1d5306c2023752a7dc","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":""}]}