{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\n\ninterface AggregatorV3Interface {\n\n    function decimals() external view returns (uint8);\n    function description() external view returns (string memory);\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    );\n\n    function latestRoundData()\n    external\n    view\n    returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    );\n}\n\ncontract IERC20 {\n    function balanceOf(\n        address whom\n    )\n    external\n    view\n    returns (uint);\n\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n    public\n    returns (bool);\n\n\n\n    function decimals()\n    external\n    view\n    returns (uint);\n\n\n    function symbol()\n    external\n    view\n    returns (string);\n\n\n    function name()\n    external\n    view\n    returns (string);\n\n\n    function freezeTransfers()\n    external;\n\n\n    function unfreezeTransfers()\n    external;\n}\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITwoKeyEventSourceEvents {\n    // This 2 functions will be always in the interface since we need them very often\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n\n    function created(\n        address _campaign,\n        address _owner,\n        address _moderator\n    )\n    external;\n\n    function rewarded(\n        address _campaign,\n        address _to,\n        uint256 _amount\n    )\n    external;\n\n    function acquisitionCampaignCreated(\n        address proxyLogicHandler,\n        address proxyConversionHandler,\n        address proxyAcquisitionCampaign,\n        address proxyPurchasesHandler,\n        address contractor\n    )\n    external;\n\n    function donationCampaignCreated(\n        address proxyDonationCampaign,\n        address proxyDonationConversionHandler,\n        address proxyDonationLogicHandler,\n        address contractor\n    )\n    external;\n\n    function priceUpdated(\n        bytes32 _currency,\n        uint newRate,\n        uint _timestamp,\n        address _updater\n    )\n    external;\n\n    function userRegistered(\n        string _name,\n        address _address,\n        string _fullName,\n        string _email,\n        string _username_walletName\n    )\n    external;\n\n    function cpcCampaignCreated(\n        address proxyCPC,\n        address contractor\n    )\n    external;\n\n\n    function emitHandleChangedEvent(\n        address _userPlasmaAddress,\n        string _newHandle\n    )\n    public;\n\n\n}\n\ncontract ITwoKeyMaintainersRegistry {\n    function checkIsAddressMaintainer(address _sender) public view returns (bool);\n    function checkIsAddressCoreDev(address _sender) public view returns (bool);\n\n    function addMaintainers(address [] _maintainers) public;\n    function addCoreDevs(address [] _coreDevs) public;\n    function removeMaintainers(address [] _maintainers) public;\n    function removeCoreDevs(address [] _coreDevs) public;\n}\n\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestCampaignApprovedVersion(string campaignType) public view returns (string);\n}\n\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    * @param contractName is the name of the contract we added new version\n    */\n    event VersionAdded(string version, address implementation, string contractName);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(uint amountOut, address[] path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n    function getAmountsOut(uint amountIn, address[] path) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, address[] path) external view returns (uint[] memory amounts);\n}\n\ncontract IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract ITwoKeyExchangeRateContractStorage is IStructuredStorage {\n\n}\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\ncontract ITwoKeySingletonUtils {\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    // Modifier to restrict method calls only to maintainers\n    modifier onlyMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressMaintainer(msg.sender));\n        _;\n    }\n\n    /**\n     * @notice Function to get any singleton contract proxy address from TwoKeySingletonRegistry contract\n     * @param contractName is the name of the contract we're looking for\n     */\n    function getAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getContractProxyAddress(contractName);\n    }\n\n    function getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getNonUpgradableContractAddress(contractName);\n    }\n}\n\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\n\ncontract TwoKeyExchangeRateContract is Upgradeable, ITwoKeySingletonUtils {\n\n    /**\n     * Storage keys are stored on the top. Here they are in order to avoid any typos\n     */\n    string constant _currencyName2rate = \"currencyName2rate\";\n    string constant _pairToOracleAddress = \"pairToOracleAddress\";\n    string constant _twoKeyEventSource = \"TwoKeyEventSource\";\n\n    using SafeMath for uint;\n    bool initialized;\n\n    ITwoKeyExchangeRateContractStorage public PROXY_STORAGE_CONTRACT;\n\n    /**\n     * @notice Function which will be called immediately after contract deployment\n     * @param _twoKeySingletonesRegistry is the address of TWO_KEY_SINGLETON_REGISTRY contract\n     * @param _proxyStorage is the address of proxy storage contract\n     */\n    function setInitialParams(\n        address _twoKeySingletonesRegistry,\n        address _proxyStorage\n    )\n    external\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonesRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyExchangeRateContractStorage(_proxyStorage);\n\n        initialized = true;\n    }\n\n\n    /**\n     * @notice Backend calls to update rates\n     * @dev only twoKeyMaintainer address will be eligible to update it\n     * @param _currency is the bytes32 (hex) representation of currency shortcut string\n     * @param _baseToTargetRate is the rate between base and target currency\n     */\n    function setFiatCurrencyDetails(\n        bytes32 _currency,\n        uint _baseToTargetRate\n    )\n    public\n    onlyMaintainer\n    {\n        storeFiatCurrencyDetails(_currency, _baseToTargetRate);\n        address twoKeyEventSource = getAddressFromTwoKeySingletonRegistry(_twoKeyEventSource);\n        ITwoKeyEventSourceEvents(twoKeyEventSource).priceUpdated(_currency, _baseToTargetRate, block.timestamp, msg.sender);\n    }\n\n    /**\n     * @notice Function to update multiple rates at once\n     * @param _currencies is the array of currencies\n     * @dev Only maintainer can call this\n     */\n    function setMultipleFiatCurrencyDetails(\n        bytes32[] _currencies,\n        uint[] _baseToTargetRates\n    )\n    public\n    onlyMaintainer\n    {\n        uint numberOfFiats = _currencies.length; //either _isETHGreaterThanCurrencies.length\n        //There's no need for validation of input, because only we can call this and that costs gas\n        for(uint i=0; i<numberOfFiats; i++) {\n            storeFiatCurrencyDetails(_currencies[i], _baseToTargetRates[i]);\n            address twoKeyEventSource = getAddressFromTwoKeySingletonRegistry(_twoKeyEventSource);\n            ITwoKeyEventSourceEvents(twoKeyEventSource).priceUpdated(_currencies[i], _baseToTargetRates[i], block.timestamp, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Function to store details about currency\n     * @param _currency is the bytes32 (hex) representation of currency shortcut string\n     * @param _baseToTargetRate is the rate between base and target currency\n     */\n    function storeFiatCurrencyDetails(\n        bytes32 _currency,\n        uint _baseToTargetRate\n    )\n    internal\n    {\n        bytes32 hashKey = keccak256(_currencyName2rate, _currency);\n        PROXY_STORAGE_CONTRACT.setUint(hashKey, _baseToTargetRate);\n    }\n\n\n    /**\n     * @notice Function to set ChainLink oracle addresses\n     * @param  priceFeeds is the array of price feeds ChainLink contract addresses\n     * @param  hexedPairs is the array of pairs hexed\n     */\n    function storeChainLinkOracleAddresses(\n        bytes32 [] hexedPairs,\n        address [] priceFeeds\n    )\n    public\n    onlyMaintainer\n    {\n        uint i;\n\n        for(i = 0; i < priceFeeds.length; i++) {\n            PROXY_STORAGE_CONTRACT.setAddress(\n                keccak256(_pairToOracleAddress, hexedPairs[i]),\n                priceFeeds[i]\n            );\n        }\n    }\n\n\n    /**\n     * @notice Function getter for base to target rate\n     * @param base_target is the name of the currency\n     */\n    function getBaseToTargetRate(\n        string base_target\n    )\n    public\n    view\n    returns (uint)\n    {\n        bytes32 hexedBaseTarget = stringToBytes32(base_target);\n        return getBaseToTargetRateInternal(hexedBaseTarget);\n    }\n\n\n    function getBaseToTargetRateInternal(\n        bytes32 baseTarget\n    )\n    internal\n    view\n    returns (uint)\n    {\n        address oracleAddress = PROXY_STORAGE_CONTRACT.getAddress(keccak256(_pairToOracleAddress, baseTarget));\n        int latestPrice = getLatestPrice(oracleAddress);\n        uint8 decimalsPrecision = getDecimalsReturnPrecision(oracleAddress);\n        uint maxDecimals = 18;\n        return uint(latestPrice) * (10**(maxDecimals.sub(decimalsPrecision))); //do sub instead of -\n    }\n\n\n    /**\n     * @notice Helper calculation function\n     */\n    function exchangeCurrencies(\n        string base_target,\n        uint base_amount\n    )\n    public\n    view\n    returns (uint)\n    {\n        return getBaseToTargetRate(base_target).mul(base_amount);\n    }\n\n\n\n    function getFiatToStableQuotes(\n        uint amountInFiatWei,\n        string fiatCurrency,\n        bytes32 [] stableCoinPairs //Pairs stable coin - ETh\n    )\n    public\n    view\n    returns (uint[])\n    {\n        uint len = stableCoinPairs.length;\n\n        uint [] memory pairs = new uint[](len);\n\n        uint i;\n\n        // We have rate 1 DAI = X USD => 1 USD = 1/X DAI\n        // We need to compute N dai = Y usd\n        for(i = 0; i < len; i++) {\n            // This represents us how much USD is 1 stable coin unit worth\n            // Example: 1 DAI = rate = 0.99 $\n            // 1 * DAI = 0.99 * USD\n            // 1 USD = 1 * DAI / 0.99\n            // 15 USD = 15 / 0.99\n\n            // get rate against ETH (1 STABLE  = rate ETH)\n            uint stableEthRate = getBaseToTargetRateInternal(stableCoinPairs[i]);\n\n            // This is the ETH/USD rate\n            uint eth_usd = getBaseToTargetRateInternal(stringToBytes32(\"USD\"));\n\n            uint rate =  stableEthRate.mul(eth_usd).div(10**18);\n\n            pairs[i] = amountInFiatWei.mul(10**18).div(rate);\n        }\n\n        return pairs;\n    }\n\n    /**\n     * @notice          Function to fetch 2KEY against DAI rate from uniswap\n     */\n    function get2KeyDaiRate()\n    public\n    view\n    returns (uint)\n    {\n        address uniswapRouter = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"UniswapV2Router02\");\n\n        address [] memory path = new address[](2);\n\n        path[0] = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"TwoKeyEconomy\");\n        path[1] = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\"DAI\");\n\n        uint[] memory amountsOut = new uint[](2);\n\n        amountsOut = IUniswapV2Router02(uniswapRouter).getAmountsOut(\n            10**18,\n            path\n        );\n\n        return amountsOut[1];\n    }\n\n    function getStableCoinToUSDQuota(\n        address stableCoinAddress\n    )\n    public\n    view\n    returns (uint)\n    {\n        // Take the symbol of the token\n        string memory tokenSymbol = IERC20(stableCoinAddress).symbol();\n        // Check that this symbol is matching address stored in our codebase so we are sure that it's real asset\n        if(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(tokenSymbol) == stableCoinAddress) {\n            // Chainlink provides us with the rates from StableCoin -> ETH, and along with that we have ETH -> USD quota\n\n            // Generate pair against ETH (Example: Symbol = DAI ==> result = 'DAI-ETH'\n            string memory tokenSymbolToCurrency = concatenateStrings(tokenSymbol, \"-ETH\");\n\n            // get rate against ETH (1 STABLE  = rate ETH)\n            uint stableEthRate = getBaseToTargetRateInternal(stringToBytes32(tokenSymbolToCurrency));\n\n            // This is the ETH/USD rate\n            uint eth_usd = getBaseToTargetRateInternal(stringToBytes32(\"USD\"));\n\n            return stableEthRate.mul(eth_usd).div(10**18);\n        }\n        // If stable coin is not matched, return 0 as quota\n        return 0;\n    }\n\n    /**\n     * @notice          Function to fetch the latest token price from ChainLink oracle\n     * @param           oracleAddress is the address of oracle we fetch price from\n     */\n    function getLatestPrice(\n        address oracleAddress\n    ) public view returns (int) {\n        (\n            uint80 roundID,\n            int price,\n            uint startedAt,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(oracleAddress).latestRoundData();\n        return price;\n    }\n\n\n    /**\n     * @notice          Function to fetch on how many decimals is the response\n     * @param           oracleAddress is the address of the oracle from which we take price\n     */\n    function getDecimalsReturnPrecision(\n        address oracleAddress\n    )\n    public\n    view\n    returns (uint8)\n    {\n        return AggregatorV3Interface(oracleAddress).decimals();\n    }\n\n    /**\n     * @notice          Function to fetch address of the oracle for the specific pair\n     * @param           pair is the name of the pair for which we store oracles\n     */\n    function getChainLinkOracleAddress(\n        string memory pair\n    )\n    public\n    view\n    returns (address)\n    {\n        bytes32 hexedPair = stringToBytes32(pair);\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(_pairToOracleAddress, hexedPair));\n    }\n\n\n\n\n    /**\n     * @notice Helper method to convert string to bytes32\n     * @dev If string.length > 32 then the rest after 32nd char will be deleted\n     * @return result\n     */\n    function stringToBytes32(\n        string memory source\n    )\n    internal\n    returns (bytes32 result)\n    {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n\n\n    function concatenateStrings(\n        string a,\n        string b\n    )\n    internal\n    pure\n    returns (string)\n    {\n        return string(abi.encodePacked(a,b));\n    }\n}\n\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_twoKeySingletonesRegistry\",\"type\":\"address\"},{\"name\":\"_proxyStorage\",\"type\":\"address\"}],\"name\":\"setInitialParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROXY_STORAGE_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"}],\"name\":\"getLatestPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hexedPairs\",\"type\":\"bytes32[]\"},{\"name\":\"priceFeeds\",\"type\":\"address[]\"}],\"name\":\"storeChainLinkOracleAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amountInFiatWei\",\"type\":\"uint256\"},{\"name\":\"fiatCurrency\",\"type\":\"string\"},{\"name\":\"stableCoinPairs\",\"type\":\"bytes32[]\"}],\"name\":\"getFiatToStableQuotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"}],\"name\":\"getDecimalsReturnPrecision\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"base_target\",\"type\":\"string\"},{\"name\":\"base_amount\",\"type\":\"uint256\"}],\"name\":\"exchangeCurrencies\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"base_target\",\"type\":\"string\"}],\"name\":\"getBaseToTargetRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pair\",\"type\":\"string\"}],\"name\":\"getChainLinkOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"stableCoinAddress\",\"type\":\"address\"}],\"name\":\"getStableCoinToUSDQuota\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get2KeyDaiRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_KEY_SINGLETON_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currencies\",\"type\":\"bytes32[]\"},{\"name\":\"_baseToTargetRates\",\"type\":\"uint256[]\"}],\"name\":\"setMultipleFiatCurrencyDetails\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currency\",\"type\":\"bytes32\"},{\"name\":\"_baseToTargetRate\",\"type\":\"uint256\"}],\"name\":\"setFiatCurrencyDetails\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TwoKeyExchangeRateContract","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}