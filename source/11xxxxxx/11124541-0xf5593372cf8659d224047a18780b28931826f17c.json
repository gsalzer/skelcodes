{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n \r\n// -----------------------------------------------------------------------\r\n//\r\n// Name : JACS Token Sale\r\n//  \r\n// -----------------------------------------------------------------------\r\nlibrary SafeMath {\r\nfunction add(uint a, uint b) internal pure returns (uint c) {\r\nc = a + b;\r\nrequire(c >= a);\r\n}\r\nfunction sub(uint a, uint b) internal pure returns (uint c) {\r\nrequire(b <= a);\r\nc = a - b;\r\n}\r\nfunction mul(uint a, uint b) internal pure returns (uint c) {\r\nc = a * b;\r\nrequire(a == 0 || c / a == b);\r\n}\r\nfunction div(uint a, uint b) internal pure returns (uint c) {\r\nrequire(b > 0);\r\nc = a / b;\r\n}\r\n}\r\n\r\ncontract ERC20Interface {\r\nfunction totalSupply() public view returns (uint);\r\nfunction balanceOf(address tokenOwner) public view returns (uint balance);\r\nfunction allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\nfunction transfer(address to, uint tokens) public returns (bool success);\r\nfunction approve(address spender, uint tokens) public returns (bool success);\r\nfunction transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n  \r\nevent Transfer(address indexed from, address indexed to, uint tokens);\r\nevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\nfunction receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\ncontract Owned {\r\naddress public owner;\r\naddress public newOwner;\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n    constructor() public {\r\nowner = msg.sender;\r\n}\r\n    modifier onlyOwner {\r\nrequire(msg.sender == owner);\r\n_;\r\n}\r\nfunction transferOwnership(address _newOwner) public onlyOwner {\r\nnewOwner = _newOwner;\r\n}\r\nfunction acceptOwnership() public {\r\nrequire(msg.sender == newOwner);\r\n emit OwnershipTransferred(owner, newOwner);\r\nowner = newOwner;\r\nnewOwner = address(0);\r\n   }\r\n    \r\n  }\r\n\r\ncontract Lock {\r\n    \r\n     /**lock\r\n     * @dev Reasons why a user's tokens have been locked\r\n     */\r\n    mapping(address => bytes32[]) public lockReason;\r\n    mapping(address => uint256) public balances;\r\n\r\n    /**\r\n     * @dev locked token structure\r\n     */\r\n    struct LockToken {\r\n        uint256 amount;\r\n        uint256 validity;\r\n        bool claimed;\r\n    }\r\n\r\n    /**\r\n     * @dev Holds number & validity of tokens locked for a given reason for\r\n     *      a specified address\r\n     */\r\n    mapping(address => mapping(bytes32 => LockToken)) public locked;\r\n\r\n    /**\r\n     * @dev Records data of all the tokens Locked\r\n     */\r\n    event Locked(\r\n        address indexed _of,\r\n        bytes32 indexed _reason,\r\n        uint256 _amount,\r\n        uint256 _validity\r\n    );\r\n    /**\r\n     * @dev Records data of all the tokens unlocked\r\n     */\r\n    event Unlocked(\r\n        address indexed _of,\r\n        bytes32 indexed _reason,\r\n        uint256 _amount\r\n    );\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason\r\n     *\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     */\r\n    function tokensLocked(address _of, bytes32 _reason)\r\n    public view returns(uint256 amount);\r\n\r\n    /**\r\n     * @dev Returns unlockable tokens for a specified address for a specified reason\r\n     * @param _of The address to query the the unlockable token count of\r\n     * @param _reason The reason to query the unlockable tokens for\r\n     */\r\n    function tokensUnlockable(address _of, bytes32 _reason)\r\n    public view returns(uint256 amount);\r\n\r\n    /**\r\n     * @dev Unlocks the unlockable tokens of a specified address\r\n     * @param _of Address of user, claiming back unlockable tokens\r\n     */\r\n    function unlock(address _of)\r\n    public returns(uint256 unlockableTokens);\r\n}\r\n\r\ncontract JACSToken is ERC20Interface, Owned, Lock {\r\n    using SafeMath for uint;\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint256 public tokensForTokenSale; \r\n    address public tokenSaleAddress;                    // address of TokenSale contract\r\n    uint256 public totalAllocatedTokens;                // variable to regulate the funds allocation\r\n    uint256 public ownerHold; \r\n    uint internal _totalSupply;\r\n    mapping(address => uint) public balances;\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n    \r\n        /**\r\n     * @dev Error messages for require statements\r\n     */\r\n    string internal constant AMOUNT_ZERO = \"Amount can not be 0\";\r\n    string internal constant ONLY_OWNER = \"Only owner has the right to perform this action\";\r\n    address public owner = msg.sender;\r\n    \r\n    constructor( address _tokensaleContract) public {\r\n           symbol = \"JACS\";\r\n           name = \"JACS Token\";\r\n           decimals = 18;\r\n           tokenSaleAddress = _tokensaleContract;\r\n           _totalSupply = 536870912 * 10**uint(decimals);\r\n           \r\n           tokensForTokenSale = 268435456 * 10**uint(decimals);\r\n           ownerHold = 268435456 * 10**uint(decimals);\r\n           \r\n            balances[tokenSaleAddress] = tokensForTokenSale;\r\n            balances[owner] = ownerHold;\r\n            \r\n            emit Transfer(address(0), tokenSaleAddress, tokensForTokenSale);\r\n            emit Transfer(address(0), owner, ownerHold);\r\n         }\r\n         // ------------------------------------------------------------------\r\n        // Total supply\r\n        // -------------------------------------------------------------------\r\n        function totalSupply() public constant returns (uint) {\r\n             return _totalSupply.sub(balances[address(0)]);\r\n        }\r\n     // ------------------------------------------------------------------\r\n    // modifier\r\n    // ------------------------------------------------------------------\r\n      modifier onlyTokenSale() {\r\n        require(msg.sender == tokenSaleAddress);\r\n    _;\r\n  }\r\n  \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, ONLY_OWNER);\r\n        _;\r\n    }\r\n    \r\n       /**lock\r\n     * @dev Transfers and Locks a specified amount of tokens,\r\n     *      for a specified reason and time\r\n     * @param _to adress to which tokens are to be transfered\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be transfered and locked\r\n     * @param _days Number of days for locked token\r\n     */\r\n    function transferWithLock(address _to, bytes32 _reason, uint256 _amount, uint256 _days)\r\n    public\r\n    onlyOwner \r\n    returns(bool) {\r\n        uint256 validUntil = now.add(_days.mul(86400)); //solhint-disable-line\r\n        require(_amount != 0, AMOUNT_ZERO);\r\n\r\n        if (locked[_to][_reason].amount == 0)\r\n            lockReason[_to].push(_reason);\r\n\r\n        transfer(address(this), _amount);\r\n\r\n        locked[_to][_reason] = LockToken(_amount, validUntil, false);\r\n\r\n        emit Locked(_to, _reason, _amount, validUntil);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     */\r\n    function tokensLocked(address _of, bytes32 _reason)\r\n    public\r\n    view\r\n    returns(uint256 amount) {\r\n        if (!locked[_of][_reason].claimed)\r\n            amount = locked[_of][_reason].amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns unlockable tokens for a specified address for a specified reason\r\n     * @param _of The address to query the the unlockable token count of\r\n     * @param _reason The reason to query the unlockable tokens for\r\n     */\r\n    function tokensUnlockable(address _of, bytes32 _reason)\r\n    public\r\n    view\r\n    returns(uint256 amount) {\r\n        if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) //solhint-disable-line\r\n            amount = locked[_of][_reason].amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Unlocks the unlockable tokens of a specified address\r\n     * @param _of Address of user, claiming back unlockable tokens \r\n     */\r\n    function unlock(address _of)\r\n    public\r\n    returns(uint256 unlockableTokens) {\r\n        uint256 lockedTokens;\r\n\r\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n            lockedTokens = tokensUnlockable(_of, lockReason[_of][i]);\r\n            if (lockedTokens > 0) {\r\n                unlockableTokens = unlockableTokens.add(lockedTokens);\r\n                locked[_of][lockReason[_of][i]].claimed = true;\r\n                emit Unlocked(_of, lockReason[_of][i], lockedTokens); \r\n                \r\n                if (unlockableTokens > 0){\r\n                    this.transfer(_of, unlockableTokens);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Internal function that burns an amount of the token\r\n     * @param tokens The amount that will be burnt.\r\n     */\r\n\r\n    function burn(uint256 tokens) public onlyOwner  returns(bool) {\r\n        _burn(owner, tokens);\r\n        return true;\r\n    }\r\n    \r\n   /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param amount The amount that will be burnt.\r\n   */\r\n  function _burn(address account, uint256 amount) internal {\r\n    require(account != 0);\r\n    require(amount <= balances[account]);\r\n\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    balances[account] = balances[account].sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n  \r\n /**\r\n      @dev function used to change the supply of total Allocated tokens in the market , it only called by TokenSale\r\n      @param _amount amount is the token quantity added in token supply\r\n  \r\n   */\r\n  function totalAllocatedTokens(uint256 _amount) public onlyTokenSale {\r\n    totalAllocatedTokens += _amount;\r\n  }\r\n  \r\n     // ------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // -------------------------------------------------------------------\r\n     function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n         return balances[tokenOwner];\r\n    }\r\n     // ------------------------------------------------------------------\r\n     // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n     // - 0 value transfers are allowed\r\n     // ------------------------------------------------------------------\r\n     function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n         return true;\r\n     }\r\n     // ------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n     // from the token owner's account\r\n  // recommends that there are no checks for the approval double-spend\r\n // attack\r\n // as this should be implemented in user interfaces\r\n     // ------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n         return true;\r\n     }\r\n  // -------------------------------------------------------------------\r\n  // Transfer `tokens` from the `from` account to the `to` account\r\n  //\r\n  // The calling account must already have sufficient tokens\r\n // approve(...)-d\r\n // for spending from the `from` account and\r\n  // - From account must have sufficient balance to transfer\r\n  // - Spender must have sufficient allowance to transfer\r\n   // - 0 value transfers are allowed\r\n  // -------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = balances[from].sub(tokens);\r\n         allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n         balances[to] = balances[to].add(tokens);\r\n         emit Transfer(from, to, tokens);\r\n         return true;\r\n     }\r\n    // -------------------------------------------------------------------\r\n     // transferred to the spender's account\r\n     // ------------------------------------------------------------------\r\n     function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n         return allowed[tokenOwner][spender];\r\n    }\r\n     // ------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account. The `spender` contract function\r\n     // `receiveApproval(...)` is then executed\r\n     // ------------------------------------------------------------------\r\n     function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\r\n         allowed[msg.sender][spender] = tokens;\r\n         emit Approval(msg.sender, spender, tokens);\r\n         ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n         return true;\r\n     }\r\n    // -------------------------------------------------------------------\r\n     // Don't accept ETH\r\n    // -------------------------------------------------------------------\r\n     function () external payable {\r\n         revert();\r\n     }\r\n// -------------------------------------------------------------------\r\n     // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // -------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}\r\n\r\ncontract JACSTokenSale {\r\n\r\n    using SafeMath for uint256;\r\n    \r\n//////////////////////////////////////////// VARIABLES ///////////////////////////////////////////////// \r\n\r\n    JACSToken public token;                         // Token variable\r\n    uint256 public tokeSaleStartTime;               // It should be XXXXXXXXXXX starting time of tokeSale\r\n    uint256 public tokenSaleEndTime;                // It should be xxxxxxxxxxx token Sale End Time\r\n    uint256 public totalWeiRaised;                  // Flag to track the amount raised\r\n\r\n    // Price as per week in token sale\r\n\r\n    uint256 internal firstWeekPrice =2;\r\n    uint256 internal secondWeekPrice=3;\r\n    uint256 internal thirdWeekPrice =4;                              \r\n    uint256 internal fourthWeekPrice=5; \r\n    \r\n    bool internal isTokenDeployed = false;               // Flag to track the token deployment\r\n    bool public isTokenSaleActive = false;               // Flag to track the TokenSale active or not\r\n    // Addresses\r\n    address public founderMultiSigAddress;          // Founders multi sign address\r\n    address public remainingTokenHolder;            // Address to hold the remaining tokens after TokenSale end\r\n    \r\n    enum State { TokenSale }\r\n\r\n   \r\n    //Events\r\n    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); \r\n    event TokenSaleClosed(uint256 _blockTimeStamp);\r\n    event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress);\r\n\r\n    //Modifiers\r\n    modifier tokenIsDeployed() {\r\n        require(isTokenDeployed == true);\r\n        _;\r\n    }\r\n\r\n    modifier nonZeroAddress(address _to) {\r\n        require(_to != 0x0);\r\n        _;\r\n    }\r\n    \r\n    modifier nonZeroEth() {\r\n        require(msg.value > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyFounders() {\r\n        require(msg.sender == founderMultiSigAddress);\r\n        _;\r\n    }\r\n     \r\n    modifier onlyremainingTokenHolder() {\r\n        require(msg.sender == remainingTokenHolder);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPublic() {\r\n        require(msg.sender != founderMultiSigAddress);\r\n        _;\r\n    }\r\n//////////////////////////////////////////// CONSTRUCTOR //////////////////////////////////////////\r\n   \r\n    constructor(address _founderWalletAddress , address _remainingTokenHolder) public {\r\n        founderMultiSigAddress = _founderWalletAddress;\r\n        remainingTokenHolder = _remainingTokenHolder;\r\n      \r\n    }\r\n\r\n    /**\r\n        @dev function to change the founder multisig wallet address\r\n        @param _newFounderAddress new address of founder\r\n     */\r\n\r\n     function setFounderMultiSigAddress(address _newFounderAddress) public\r\n     onlyFounders \r\n     {\r\n        founderMultiSigAddress = _newFounderAddress;\r\n        emit ChangeFoundersWalletAddress(now, founderMultiSigAddress);\r\n     }\r\n    \r\n\r\n    /**\r\n        @dev attach the token address with the TokenSale conract \r\n        @param _tokenAddress address of the respective token contract \r\n    \r\n     */\r\n         \r\n    function setTokenAddress(address _tokenAddress) \r\n    external \r\n    onlyFounders \r\n    nonZeroAddress(_tokenAddress) \r\n    {\r\n        require(isTokenDeployed == false);\r\n        token = JACSToken(_tokenAddress);\r\n        isTokenDeployed = true;\r\n    }\r\n\r\n    /**\r\n        @dev startTokenSale function use to start the TokenSale at the calling function time\r\n        @dev _days No. of days to which TokenSale get active\r\n        @return bool\r\n     */\r\n    \r\n    function startTokenSale(uint8 _days) public\r\n    onlyFounders \r\n    tokenIsDeployed \r\n    returns (bool)\r\n    {\r\n            tokeSaleStartTime = now;                            \r\n            tokenSaleEndTime = tokeSaleStartTime + _days * 1 days; \r\n            isTokenSaleActive = !isTokenSaleActive;\r\n            return true;\r\n    }\r\n\r\n\r\n    /**\r\n        @dev function call after tokenSaleEndTime \r\n        it transfers the remaining tokens to remainingTokenHolder address\r\n        @return bool\r\n    */\r\n\r\n    function endTokenSale() public onlyremainingTokenHolder returns (bool) {\r\n        require(now > tokenSaleEndTime);\r\n        uint256 remainingToken = token.balanceOf(this);  // remaining tokens\r\n\r\n        if (remainingToken != 0) {\r\n          token.transfer(remainingTokenHolder, remainingToken); \r\n          isTokenSaleActive = false;\r\n          tokenSaleEndTime = now; \r\n          emit TokenSaleClosed(now);\r\n          return true; \r\n        } \r\n        return false;\r\n    }\r\n\r\n    // function to get the current state of the token sale\r\n    function getState() internal constant returns(State) {\r\n        if(isTokenSaleActive) {\r\n            return State.TokenSale;\r\n        }\r\n    }\r\n\r\n   // get the amount of tokens a user would receive for a specific amount of ether\r\n   function getTotalTokens(uint256 _amountOfEth) public view returns(uint256) {\r\n       if (getState() == State.TokenSale) {\r\n           return calcToken(_amountOfEth);\r\n       }else {\r\n           revert();\r\n       }\r\n      \r\n   } \r\n   \r\n    // function provide the current price \r\n    function getCurrentPrice() internal view returns (uint256) {\r\n        \r\n        if (now > tokeSaleStartTime + 21 days) {\r\n            return fourthWeekPrice;\r\n        }\r\n        if (now > tokeSaleStartTime + 14 days) {\r\n            return thirdWeekPrice;\r\n        }\r\n        if (now > tokeSaleStartTime + 7 days) {\r\n            return secondWeekPrice;\r\n        }\r\n        if (now > tokeSaleStartTime) {\r\n            return firstWeekPrice;\r\n        }\r\n    }\r\n\r\n    // calculate the amount of tokens\r\n    function calcToken(uint256 value)\r\n        internal\r\n        view\r\n        returns(uint256 amount){\r\n             amount =  value.mul(10000).div(getCurrentPrice());\r\n             return amount;\r\n        }\r\n        \r\n    // Buy token function call only in duration of TokenSale active \r\n    function buyTokens(address beneficiary) public nonZeroEth tokenIsDeployed onlyPublic nonZeroAddress(beneficiary) payable returns(bool) {\r\n        if(getState() == State.TokenSale) {\r\n            require(now < tokenSaleEndTime);\r\n            fundTransfer(msg.value);\r\n            totalWeiRaised = totalWeiRaised.add(msg.value);\r\n             uint256 amount = calcToken(msg.value);\r\n        \r\n         if (token.transfer(beneficiary, amount)) {\r\n                token.totalAllocatedTokens(amount); \r\n                emit TokenPurchase(beneficiary, msg.value, amount);\r\n            }\r\n            return true;         \r\n        }\r\n        else {\r\n            revert();\r\n        }\r\n        \r\n    }\r\n    \r\n    // function to transfer the funds to founders account\r\n    function fundTransfer(uint256 weiAmount) internal {\r\n        founderMultiSigAddress.transfer(weiAmount);\r\n    }\r\n    \r\n    // send ether to the contract address\r\n    function() public payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokeSaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFounderAddress\",\"type\":\"address\"}],\"name\":\"setFounderMultiSigAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"founderMultiSigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endTokenSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokenHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_days\",\"type\":\"uint8\"}],\"name\":\"startTokenSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTokenSaleActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSaleEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amountOfEth\",\"type\":\"uint256\"}],\"name\":\"getTotalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_founderWalletAddress\",\"type\":\"address\"},{\"name\":\"_remainingTokenHolder\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockTimeStamp\",\"type\":\"uint256\"}],\"name\":\"TokenSaleClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockTimeStamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_foundersWalletAddress\",\"type\":\"address\"}],\"name\":\"ChangeFoundersWalletAddress\",\"type\":\"event\"}]","ContractName":"JACSTokenSale","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006b306026eebc53e9fa9ec84221fe344c39f17b7a0000000000000000000000009852884370b5d817287285112b0a569695a9f16a","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://29999ac774d7f74ddc8bfde614bef9041bd9832aa9884ce82be15d57beeba3b6"}]}