{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"pragma solidity \\u003e= 0.6.4;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n  function mint(address account, uint256 amount) external;\\n  function burn(uint256 amount) external;\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"ownable.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\ncontract Owned is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"priceAggregatorInterface.sol\":{\"content\":\"pragma solidity \\u003e= 0.6.6;\\n\\ninterface priceAggregatorInterface {\\n  function registerVaultAggregator(address oracle) external;\\n  function priceRequest(\\n    address vault,\\n    uint256 lastUpdated\\n  )\\n  external\\n  view\\n  returns(int256[] memory, uint256);\\n  function roundIdCheck(address vault) external view returns(bool);\\n}\\n\"},\"priceCalculatorInterface.sol\":{\"content\":\"pragma solidity \\u003e= 0.6.6;\\n\\ninterface priceCalculatorInterface {\\n  function getUpdatedPrice(\\n    address vault,\\n    uint256 latestRoundId\\n  )\\n    external\\n    view\\n    returns(\\n      uint256[6] memory latestPrice,\\n      uint256 rRoundId,\\n      bool updated\\n  );\\n  function getKFactor(\\n    uint256 targetEquity,\\n    uint256 bullEquity,\\n    uint256 bearEquity,\\n    uint256 totalEquity\\n  )\\n  external\\n  view\\n  returns(uint256 kFactor);\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"vault.sol\":{\"content\":\"//////////////////////////////////////////////////\\n//SYNLEV VAULT CONTRACT V 1.0.0\\n//////////////////////////\\n\\npragma solidity \\u003e= 0.6.6;\\n\\nimport \\u0027./ownable.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./priceCalculatorInterface.sol\\u0027;\\nimport \\u0027./vaultHelperInterface.sol\\u0027;\\nimport \\u0027./priceAggregatorInterface.sol\\u0027;\\n\\n/*\\n * @title SynLev vault contract.\\n * @author Icarus\\n */\\ncontract vault is Owned {\\n  using SafeMath for uint256;\\n\\n  constructor() public {\\n    priceAggregatorInterface(0x7196545d854D03D9c87B7588F6D9e1e42D876E95).registerVaultAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\\n    priceAggregator = priceAggregatorInterface(0x73f27200093b74B3d21ff4df63E14a9E3fB85cd8);\\n    priceCalculator = priceCalculatorInterface(0xf4c56485A09388DbdcB01056E76A7B5bf7f5F574);\\n    vaultHelper = vaultHelperInterface(0xE0d6b68403D32Dd659E452DB880393Df15fA00F2);\\n    synStakingProxy = 0x0070F3e1147c03a1Bb0caF80035B7c362D312119;\\n    buyFee = 4 * 10**6;\\n    sellFee = 4 * 10**6;\\n  }\\n\\n  /////////////////////\\n  //EVENTS/////////////\\n  /////////////////////\\n  event PriceUpdate(\\n    uint256 bullPrice,\\n    uint256 bearPrice,\\n    uint256 bullLiqEquity,\\n    uint256 bearLiqEquity,\\n    uint256 bullEquity,\\n    uint256 bearEquity,\\n    uint256 roundId,\\n    bool updated\\n  );\\n  event TokenBuy(\\n    address account,\\n    address token,\\n    uint256 tokensMinted,\\n    uint256 ethin,\\n    uint256 fees,\\n    uint256 bonus\\n  );\\n  event TokenSell(\\n    address account,\\n    address token,\\n    uint256 tokensBurned,\\n    uint256 ethout,\\n    uint256 fees,\\n    uint256 penalty\\n  );\\n  event LiquidityAdd(\\n    address account,\\n    uint256 eth,\\n    uint256 shares,\\n    uint256 shareprice\\n  );\\n  event LiquidityRemove(\\n    address account,\\n    uint256 eth,\\n    uint256 shares,\\n    uint256 shareprice\\n  );\\n\\n  modifier isActive() {\\n    require(active == true);\\n    if(active == true \\u0026\\u0026 !priceAggregator.roundIdCheck(address(this))) {\\n      updatePrice();\\n    }\\n    _;\\n  }\\n\\n  modifier updateIfActive() {\\n    if(active == true \\u0026\\u0026 !priceAggregator.roundIdCheck(address(this))) {\\n      updatePrice();\\n    }\\n    _;\\n  }\\n\\n  /////////////////////\\n  //GLOBAL VARIBLES\\n  /////////////////////\\n\\n  bool private active;\\n  uint256 constant private multiplier = 3;\\n  address private bull;\\n  address private bear;\\n  uint256 private latestRoundId;\\n  mapping(address =\\u003e uint256) private price;\\n  mapping(address =\\u003e uint256) private equity;\\n  uint256 private buyFee;\\n  uint256 private sellFee;\\n  uint256 private totalLiqShares;\\n  uint256 private liqFees;\\n  uint256 private balanceEquity;\\n  mapping(address =\\u003e uint256) private liqTokens;\\n  mapping(address =\\u003e uint256) private liqEquity;\\n  mapping(address =\\u003e uint256) private userShares;\\n\\n  priceAggregatorInterface  public priceAggregator;\\n  priceCalculatorInterface public priceCalculator;\\n  vaultHelperInterface public vaultHelper;\\n  address payable public synStakingProxy;\\n\\n  //Fallback function\\n  receive() external payable {}\\n\\n  ////////////////////////////////////\\n  //LOW LEVEL BUY AND SELL FUNCTIONS//\\n  //        NO SAFETY CHECK         //\\n  //SHOULD ONLY BE CALLED BY OTHER  //\\n  //          CONTRACTS             //\\n  ////////////////////////////////////\\n\\n  /*\\n   * @notice Buys bull or bear token and updates price before token buy.\\n   * @param token bull or bear token address\\n   * @param account Recipient of newly minted tokens\\n   * @dev Should only be called by a router contract. Checks the excess ETH in\\n   * contract by calling getDepositEquity(). Can\\u0027t 0 ETH buy. Calculates\\n   * resulting tokens and fees. Sends fees and mints tokens.\\n   *\\n   */\\n  function tokenBuy(address token, address account)\\n  public\\n  virtual\\n  isActive()\\n  {\\n    uint256 ethin = getDepositEquity();\\n    require(ethin \\u003e 0);\\n    require(token == bull || token == bear);\\n    IERC20 itkn = IERC20(token);\\n    uint256 fees = ethin.mul(buyFee).div(10**9);\\n    uint256 buyeth = ethin.sub(fees);\\n    uint256 bonus = vaultHelper.getBonus(address(this), token, buyeth);\\n    uint256 tokensToMint = buyeth.add(bonus).mul(10**18).div(price[token]);\\n    equity[token] = equity[token].add(buyeth).add(bonus);\\n    if(bonus != 0) balanceEquity = balanceEquity.sub(bonus);\\n    payFees(fees);\\n    itkn.mint(account, tokensToMint);\\n\\n    emit TokenBuy(account, token, tokensToMint, ethin, fees, bonus);\\n  }\\n\\n  /*\\n   * @notice Sells bull or bear token and updates price before token sell.\\n   * @param token bull or bear token address\\n   * @param account Recipient of resulting eth from burned tokens\\n   * @dev Should only be called by a router contract that simultaneously sends\\n   * tokens using transferFrom() and calls this function. Looks at the current\\n   * balance of the contract of the selected token. Can\\u0027t 0 token sell.\\n   * Calculates resulting ETH from burned tokens. Pays fees, burns tokens, and\\n   * sends ETH.\\n   */\\n  function tokenSell(address token, address payable account)\\n  public\\n  virtual\\n  isActive()\\n  {\\n    IERC20 itkn = IERC20(token);\\n    uint256 tokensToBurn = itkn.balanceOf(address(this));\\n    require(tokensToBurn \\u003e 0);\\n    require(token == bull || token == bear);\\n    uint256 selleth = tokensToBurn.mul(price[token]).div(10**18);\\n    uint256 penalty = vaultHelper.getPenalty(address(this), token, selleth);\\n    uint256 fees = sellFee.mul(selleth.sub(penalty)).div(10**9);\\n    uint256 ethout = selleth.sub(penalty).sub(fees);\\n    equity[token] = equity[token].sub(selleth);\\n    if(penalty != 0) balanceEquity = balanceEquity.add(penalty);\\n    payFees(fees);\\n    itkn.burn(tokensToBurn);\\n    account.transfer(ethout);\\n\\n    emit TokenSell(account, token, tokensToBurn, ethout, fees, penalty);\\n  }\\n\\n  /*\\n   * @notice Adds liquidty to the contract and gives LP shares. Minimum LP add\\n   * is 1 wei. Virtually mints bear/bull tokens to be held in the vault.\\n   * @param account Recipient of LP shares\\n   * @dev Can be called by router but there is benefit to doing so. All\\n   * calculations are done with respect to equity and supply. Doing by price\\n   * creates rounding error. Calls updatePrice() then calls getLiqAddTokens()\\n   * to determine how many bull/bear to create.\\n   */\\n  function addLiquidity(address account)\\n  public\\n  payable\\n  virtual\\n  updateIfActive()\\n  {\\n    uint256 ethin = getDepositEquity();\\n    (\\n      uint256 bullEquity,\\n      uint256 bearEquity,\\n      uint256 bullTokens,\\n      uint256 bearTokens\\n    ) = vaultHelper.getLiqAddTokens(address(this), ethin);\\n    uint256 sharePrice = vaultHelper.getSharePrice(address(this));\\n    uint256 resultingShares = ethin.mul(10**18).div(sharePrice);\\n    liqEquity[bull] = liqEquity[bull].add(bullEquity);\\n    liqEquity[bear] = liqEquity[bear].add(bearEquity);\\n    liqTokens[bull] = liqTokens[bull].add(bullTokens);\\n    liqTokens[bear] = liqTokens[bear].add(bearTokens);\\n    userShares[account] = userShares[account].add(resultingShares);\\n    totalLiqShares = totalLiqShares.add(resultingShares);\\n\\n    emit LiquidityAdd(account, ethin, resultingShares, sharePrice);\\n  }\\n\\n  /*\\n   * @notice Removes liquidty to the contract and gives LP shares. Virtually\\n   * burns bear/bull tokens to be held in the vault. Cannot be called if user\\n   * has 0 shares\\n   * @param _shares How many shares to burn\\n   * @dev Cannot be called by a router as LP shares are not currently tokenized.\\n   * Calls updatePrice() then calls getLiqRemoveTokens() to determine how many\\n   * bull/bear tokens to remove.\\n   */\\n  function removeLiquidity(uint256 shares)\\n  public\\n  virtual\\n  updateIfActive()\\n  {\\n    require(shares \\u003c= userShares[msg.sender]);\\n    (\\n      uint256 bullEquity,\\n      uint256 bearEquity,\\n      uint256 bullTokens,\\n      uint256 bearTokens,\\n      uint256 feesPaid\\n    ) = vaultHelper.getLiqRemoveTokens(address(this), shares);\\n    uint256 sharePrice = vaultHelper.getSharePrice(address(this));\\n    uint256 resultingEth = bullEquity.add(bearEquity).add(feesPaid);\\n    liqEquity[bull] = liqEquity[bull].sub(bullEquity);\\n    liqEquity[bear] = liqEquity[bear].sub(bearEquity);\\n    liqTokens[bull] = liqTokens[bull].sub(bullTokens);\\n    liqTokens[bear] = liqTokens[bear].sub(bearTokens);\\n    userShares[msg.sender] = userShares[msg.sender].sub(shares);\\n    totalLiqShares = totalLiqShares.sub(shares);\\n    liqFees = liqFees.sub(feesPaid);\\n    msg.sender.transfer(resultingEth);\\n\\n    emit LiquidityRemove(msg.sender, resultingEth, shares, sharePrice);\\n  }\\n\\n  /*\\n   * @notice Updates price from chainlink oracles.\\n   * @param _shares How many shares to burn\\n   * @dev Calls getUpdatedPrice() function and sets new price, equity, liquidity\\n   * equity, and latestRoundId; only if there is new price data\\n   * @return bool if price was updated\\n   */\\n  function updatePrice()\\n  public\\n  {\\n    require(active == true);\\n    (\\n      uint256[6] memory priceArray,\\n      uint256 roundId,\\n      bool updated\\n    ) = priceCalculator.getUpdatedPrice(address(this), latestRoundId);\\n    if(updated == true) {\\n      (\\n        price[bull],\\n        price[bear],\\n        liqEquity[bull],\\n        liqEquity[bear],\\n        equity[bull],\\n        equity[bear],\\n        latestRoundId\\n      ) =\\n      (\\n        priceArray[0],\\n        priceArray[1],\\n        priceArray[2],\\n        priceArray[3],\\n        priceArray[4],\\n        priceArray[5],\\n        roundId\\n      );\\n    }\\n    emit PriceUpdate(\\n      price[bull],\\n      price[bear],\\n      liqEquity[bull],\\n      liqEquity[bear],\\n      equity[bull],\\n      equity[bear],\\n      latestRoundId,\\n      updated\\n    );\\n  }\\n\\n  ///////////////////////\\n  //INTERNAL FUNCTIONS///\\n  ///////////////////////\\n\\n  /*\\n   * @notice Pays half fees to SYN stakers and half to LP\\n   * @param _amount Fees to be paid in ETH\\n   * @dev Only called by tokenBuy() and tokenSell()\\n   */\\n  function payFees(uint256 amount) internal {\\n    synStakingProxy.transfer(amount.div(2));\\n    liqFees += amount.sub(amount.div(2));\\n  }\\n\\n  ///////////////////\\n  ///VIEW FUNCTIONS//\\n  ///////////////////\\n  function getActive() public view returns(bool) {return(active);}\\n  function getMultiplier() public pure returns(uint256) {return(multiplier);}\\n  function getBullToken() public view returns(address) {return(bull);}\\n  function getBearToken() public view returns(address) {return(bear);}\\n  function getLatestRoundId() public view returns(uint256) {return(latestRoundId);}\\n  function getPrice(address token) public view returns(uint256) {return(price[token]);}\\n  function getEquity(address token) public view returns(uint256) {return(equity[token]);}\\n  function getBuyFee() public view returns(uint256) {return(buyFee);}\\n  function getSellFee() public view returns(uint256) {return(sellFee);}\\n  function getTotalLiqShares() public view returns(uint256) {return(totalLiqShares);}\\n  function getLiqFees() public view returns(uint256) {return(liqFees);}\\n  function getBalanceEquity() public view returns(uint256) {return(balanceEquity);}\\n  function getLiqTokens(address token) public view returns(uint256) {return(liqTokens[token]);}\\n  function getLiqEquity(address token) public view returns(uint256) {return(liqEquity[token]);}\\n  function getUserShares(address account) public view returns(uint256) {return(userShares[account]);}\\n\\n  function getTotalEquity() public view returns(uint256) {\\n    return(getTokenEquity(bear).add(getTokenEquity(bull)));\\n  }\\n\\n  function getTokenEquity(address token) public view returns(uint256) {\\n    return(equity[token].add(liqEquity[token]));\\n  }\\n  function getTokenLiqEquity(address token) public view returns(uint256) {\\n    return(liqTokens[token].mul(price[token]).div(10**18));\\n  }\\n  function getDepositEquity() public view returns(uint256) {\\n    return(address(this).balance.sub(liqFees.add(balanceEquity).add(getTotalEquity())));\\n  }\\n  ///////////////////\\n  //ADMIN FUNCTIONS//\\n  ///////////////////\\n\\n  //One time use function to set token addresses. this can never be changed once set.\\n  //Cannot be included in constructor as vault must be deployed before tokens.\\n  function setTokens(address bearAddress, address bullAddress) public onlyOwner() {\\n    require(bear == address(0) || bull == address(0));\\n    (bull, bear) = (bullAddress, bearAddress);\\n    //Set initial price to .01 eth\\n    (price[bull], price[bear]) = (10**16, 10**16);\\n  }\\n  function setActive(bool state, uint256 roundId) public onlyOwner() {\\n    active = state;\\n    if(roundId == 0) {\\n      ( , latestRoundId) = priceAggregator.priceRequest(address(this), latestRoundId);\\n    }\\n    else {\\n      latestRoundId == roundId;\\n    }\\n  }\\n  //Fees in the form of 1 / 10^8\\n  function setBuyFee(uint256 amount) public onlyOwner() {\\n    require(amount \\u003c= 10**9);\\n    buyFee = amount;\\n  }\\n  //Sell fees limited to a maximum of 1%\\n  function setSellFee(uint256 amount) public onlyOwner() {\\n    require(amount \\u003c= 10**7);\\n    sellFee = amount;\\n  }\\n\\n}\\n\"},\"vaultHelperInterface.sol\":{\"content\":\"pragma solidity \\u003e= 0.6.6;\\n\\ninterface vaultHelperInterface {\\n  function getBonus(address vault, address token, uint256 eth)\\n  external\\n  view\\n  returns(uint256 bonus);\\n\\n  function getPenalty(address vault, address token, uint256 eth)\\n  external\\n  view\\n  returns(uint256 penalty);\\n\\n  function getSharePrice(address vault)\\n  external\\n  view\\n  returns(uint256 sharePrice);\\n\\n  function getLiqAddTokens(address vault, uint256 eth)\\n  external\\n  view\\n  returns(\\n    uint256 bullEquity,\\n    uint256 bearEquity,\\n    uint256 bullTokens,\\n    uint256 bearTokens\\n  );\\n\\n  function getLiqRemoveTokens(address vault, uint256 eth)\\n  external\\n  view\\n  returns(\\n    uint256 bullEquity,\\n    uint256 bearEquity,\\n    uint256 bullTokens,\\n    uint256 bearTokens,\\n    uint256 feesPaid\\n  );\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareprice\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareprice\",\"type\":\"uint256\"}],\"name\":\"LiquidityRemove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bullPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bearPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bullLiqEquity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bearLiqEquity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bullEquity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bearEquity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"updated\",\"type\":\"bool\"}],\"name\":\"PriceUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"name\":\"TokenBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"}],\"name\":\"TokenSell\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalanceEquity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBearToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBullToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositEquity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getEquity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestRoundId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getLiqEquity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiqFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getLiqTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenEquity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenLiqEquity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalEquity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalLiqShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceAggregator\",\"outputs\":[{\"internalType\":\"contract priceAggregatorInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceCalculator\",\"outputs\":[{\"internalType\":\"contract priceCalculatorInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"setActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bearAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bullAddress\",\"type\":\"address\"}],\"name\":\"setTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synStakingProxy\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"tokenBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"tokenSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultHelper\",\"outputs\":[{\"internalType\":\"contract vaultHelperInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"vault","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fb60cc37e50db57b971c82f504c47f2b825744041c647692b8ff7f2e5b92b05b"}]}