{"status":"1","message":"OK","result":[{"SourceCode":"/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: ExchangerWithVirtualSynth.sol\n*\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/ExchangerWithVirtualSynth.sol\n* Docs: https://docs.synthetix.io/contracts/ExchangerWithVirtualSynth\n*\n* Contract Dependencies: \n*\t- ERC20\n*\t- Exchanger\n*\t- IAddressResolver\n*\t- IERC20\n*\t- IExchanger\n*\t- IVirtualSynth\n*\t- MixinResolver\n*\t- MixinSystemSettings\n*\t- Owned\n* Libraries: \n*\t- SafeDecimalMath\n*\t- SafeMath\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity ^0.5.16;\n\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function canBurnSynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeEtherCollateral) external view returns (uint);\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to Synthetix\n    function issueSynths(address from, uint amount) external;\n\n    function issueSynthsOnBehalf(\n        address issueFor,\n        address from,\n        uint amount\n    ) external;\n\n    function issueMaxSynths(address from) external;\n\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\n\n    function burnSynths(address from, uint amount) external;\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external;\n\n    function burnSynthsToTarget(address from) external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint susdAmount,\n        address liquidator\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            repository[names[i]] = destinations[i];\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\ncontract MixinResolver is Owned {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    bytes32[] public resolverAddressesRequired;\n\n    uint public constant MAX_ADDRESSES_FROM_RESOLVER = 24;\n\n    constructor(address _resolver, bytes32[MAX_ADDRESSES_FROM_RESOLVER] memory _addressesToCache) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        for (uint i = 0; i < _addressesToCache.length; i++) {\n            if (_addressesToCache[i] != bytes32(0)) {\n                resolverAddressesRequired.push(_addressesToCache[i]);\n            } else {\n                // End early once an empty item is found - assumes there are no empty slots in\n                // _addressesToCache\n                break;\n            }\n        }\n        resolver = AddressResolver(_resolver);\n        // Do not sync the cache as addresses may not be in the resolver yet\n    }\n\n    /* ========== SETTERS ========== */\n    function setResolverAndSyncCache(AddressResolver _resolver) external onlyOwner {\n        resolver = _resolver;\n\n        for (uint i = 0; i < resolverAddressesRequired.length; i++) {\n            bytes32 name = resolverAddressesRequired[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            addressCache[name] = resolver.requireAndGetAddress(name, \"Resolver missing target\");\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function requireAndGetAddress(bytes32 name, string memory reason) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    // Note: this could be made external in a utility contract if addressCache was made public\n    // (used for deployment)\n    function isResolverCached(AddressResolver _resolver) external view returns (bool) {\n        if (resolver != _resolver) {\n            return false;\n        }\n\n        // otherwise, check everything\n        for (uint i = 0; i < resolverAddressesRequired.length; i++) {\n            bytes32 name = resolverAddressesRequired[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Note: can be made external into a utility contract (used for deployment)\n    function getResolverAddressesRequired()\n        external\n        view\n        returns (bytes32[MAX_ADDRESSES_FROM_RESOLVER] memory addressesRequired)\n    {\n        for (uint i = 0; i < resolverAddressesRequired.length; i++) {\n            addressesRequired[i] = resolverAddressesRequired[i];\n        }\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n    function appendToAddressCache(bytes32 name) internal {\n        resolverAddressesRequired.push(name);\n        require(resolverAddressesRequired.length < MAX_ADDRESSES_FROM_RESOLVER, \"Max resolver cache size met\");\n        // Because this is designed to be called internally in constructors, we don't\n        // check the address exists already in the resolver\n        addressCache[name] = resolver.getAddress(name);\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\ninterface IFlexibleStorage {\n    // Views\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\n\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\n\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\n\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\n\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\n\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\n\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\n\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\n\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\n\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\n\n    // Mutative functions\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\n\n    function setUIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        uint value\n    ) external;\n\n    function setUIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        uint[] calldata values\n    ) external;\n\n    function setIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        int value\n    ) external;\n\n    function setIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        int[] calldata values\n    ) external;\n\n    function setAddressValue(\n        bytes32 contractName,\n        bytes32 record,\n        address value\n    ) external;\n\n    function setAddressValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        address[] calldata values\n    ) external;\n\n    function setBoolValue(\n        bytes32 contractName,\n        bytes32 record,\n        bool value\n    ) external;\n\n    function setBoolValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bool[] calldata values\n    ) external;\n\n    function setBytes32Value(\n        bytes32 contractName,\n        bytes32 record,\n        bytes32 value\n    ) external;\n\n    function setBytes32Values(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bytes32[] calldata values\n    ) external;\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\ncontract MixinSystemSettings is MixinResolver {\n    bytes32 internal constant SETTING_CONTRACT_NAME = \"SystemSettings\";\n\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \"waitingPeriodSecs\";\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \"priceDeviationThresholdFactor\";\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \"issuanceRatio\";\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \"feePeriodDuration\";\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \"targetThreshold\";\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \"liquidationDelay\";\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \"liquidationRatio\";\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \"liquidationPenalty\";\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \"rateStalePeriod\";\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \"exchangeFeeRate\";\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \"minimumStakeTime\";\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \"aggregatorWarningFlags\";\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \"tradingRewardsEnabled\";\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \"debtSnapshotStaleTime\";\n\n    bytes32 private constant CONTRACT_FLEXIBLESTORAGE = \"FlexibleStorage\";\n\n    constructor() internal {\n        appendToAddressCache(CONTRACT_FLEXIBLESTORAGE);\n    }\n\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE, \"Missing FlexibleStorage address\"));\n    }\n\n    function getTradingRewardsEnabled() internal view returns (bool) {\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\n    }\n\n    function getWaitingPeriodSecs() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\n    }\n\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\n    }\n\n    function getIssuanceRatio() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\n    }\n\n    function getFeePeriodDuration() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\n    }\n\n    function getTargetThreshold() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\n    }\n\n    function getLiquidationDelay() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\n    }\n\n    function getLiquidationRatio() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\n    }\n\n    function getLiquidationPenalty() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\n    }\n\n    function getRateStalePeriod() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\n    }\n\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    function getMinimumStakeTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\n    }\n\n    function getAggregatorWarningFlags() internal view returns (address) {\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\n    }\n\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\n    }\n}\n\n\ninterface IVirtualSynth {\n    // Views\n    function balanceOfUnderlying(address account) external view returns (uint);\n\n    function rate() external view returns (uint);\n\n    function readyToSettle() external view returns (bool);\n\n    function secsLeftInWaitingPeriod() external view returns (uint);\n\n    function settled() external view returns (bool);\n\n    function synth() external view returns (ISynth);\n\n    // Mutative functions\n    function settle(address account) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\ninterface IExchanger {\n    // Views\n    function calculateAmountAfterSettlement(\n        address from,\n        bytes32 currencyKey,\n        uint amount,\n        uint refunded\n    ) external view returns (uint amountAfterSettlement);\n\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\n\n    function settlementOwing(address account, bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries\n        );\n\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\n\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint exchangeFeeRate);\n\n    function getAmountsForExchange(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate\n        );\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function waitingPeriodSecs() external view returns (uint);\n\n    // Mutative functions\n    function exchange(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTracking(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        address originator,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalfWithTracking(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address originator,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithVirtual(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    function setLastExchangeRateForSynth(bytes32 currencyKey, uint rate) external;\n\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireSynthActive(bytes32 currencyKey) external view;\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    // Restricted functions\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangestate\ninterface IExchangeState {\n    // Views\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint);\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        );\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint);\n\n    // Mutative functions\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external;\n\n    function removeEntries(address account, bytes32 currencyKey) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    struct InversePricing {\n        uint entryPoint;\n        uint upperLimit;\n        uint lowerLimit;\n        bool frozenAtUpperLimit;\n        bool frozenAtLowerLimit;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function canFreezeRate(bytes32 currencyKey) external view returns (bool);\n\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external view returns (uint value);\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function inversePricing(bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint entryPoint,\n            uint upperLimit,\n            uint lowerLimit,\n            bool frozenAtUpperLimit,\n            bool frozenAtLowerLimit\n        );\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\n        external\n        view\n        returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    // Mutative functions\n    function freezeRate(bytes32 currencyKey) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\ninterface ISynthetix {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\n\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\n\n    function totalIssuedSynthsExcludeEtherCollateral(bytes32 currencyKey) external view returns (uint);\n\n    function transferableSynthetix(address account) external view returns (uint transferable);\n\n    // Mutative Functions\n    function burnSynths(uint amount) external;\n\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\n\n    function burnSynthsToTarget() external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTracking(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address originator,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalfWithTracking(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address originator,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithVirtual(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function issueMaxSynths() external;\n\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\n\n    function issueSynths(uint amount) external;\n\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\n\n    function mint() external returns (bool);\n\n    function settle(bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\n\n    // Restricted Functions\n\n    function mintSecondary(address account, uint amount) external;\n\n    function mintSecondaryRewards(uint amount) external;\n\n    function burnSecondary(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\ninterface IFeePool {\n    // Views\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function targetThreshold() external view returns (uint);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    // Restricted: used internally to Synthetix\n    function appendAccountIssuanceRecord(\n        address account,\n        uint lockedAmount,\n        uint debtEntryIndex\n    ) external;\n\n    function recordFeePaid(uint sUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/idelegateapprovals\ninterface IDelegateApprovals {\n    // Views\n    function canBurnFor(address authoriser, address delegate) external view returns (bool);\n\n    function canIssueFor(address authoriser, address delegate) external view returns (bool);\n\n    function canClaimFor(address authoriser, address delegate) external view returns (bool);\n\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool);\n\n    // Mutative\n    function approveAllDelegatePowers(address delegate) external;\n\n    function removeAllDelegatePowers(address delegate) external;\n\n    function approveBurnOnBehalf(address delegate) external;\n\n    function removeBurnOnBehalf(address delegate) external;\n\n    function approveIssueOnBehalf(address delegate) external;\n\n    function removeIssueOnBehalf(address delegate) external;\n\n    function approveClaimOnBehalf(address delegate) external;\n\n    function removeClaimOnBehalf(address delegate) external;\n\n    function approveExchangeOnBehalf(address delegate) external;\n\n    function removeExchangeOnBehalf(address delegate) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/itradingrewards\ninterface ITradingRewards {\n    /* ========== VIEWS ========== */\n\n    function getAvailableRewards() external view returns (uint);\n\n    function getUnassignedRewards() external view returns (uint);\n\n    function getRewardsToken() external view returns (address);\n\n    function getPeriodController() external view returns (address);\n\n    function getCurrentPeriod() external view returns (uint);\n\n    function getPeriodIsClaimable(uint periodID) external view returns (bool);\n\n    function getPeriodIsFinalized(uint periodID) external view returns (bool);\n\n    function getPeriodRecordedFees(uint periodID) external view returns (uint);\n\n    function getPeriodTotalRewards(uint periodID) external view returns (uint);\n\n    function getPeriodAvailableRewards(uint periodID) external view returns (uint);\n\n    function getUnaccountedFeesForAccountForPeriod(address account, uint periodID) external view returns (uint);\n\n    function getAvailableRewardsForAccountForPeriod(address account, uint periodID) external view returns (uint);\n\n    function getAvailableRewardsForAccountForPeriods(address account, uint[] calldata periodIDs)\n        external\n        view\n        returns (uint totalRewards);\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function claimRewardsForPeriod(uint periodID) external;\n\n    function claimRewardsForPeriods(uint[] calldata periodIDs) external;\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function recordExchangeFeeForAccount(uint usdFeeAmount, address account) external;\n\n    function closeCurrentPeriodWithRewards(uint rewards) external;\n\n    function recoverEther(address payable recoverAddress) external;\n\n    function recoverTokens(address tokenAddress, address recoverAddress) external;\n\n    function recoverUnassignedRewardTokens(address recoverAddress) external;\n\n    function recoverAssignedRewardTokensAndDestroyPeriod(address recoverAddress, uint periodID) external;\n\n    function setPeriodController(address newPeriodController) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/idebtcache\ninterface IDebtCache {\n    // Views\n\n    function cachedDebt() external view returns (uint);\n\n    function cachedSynthDebt(bytes32 currencyKey) external view returns (uint);\n\n    function cacheTimestamp() external view returns (uint);\n\n    function cacheInvalid() external view returns (bool);\n\n    function cacheStale() external view returns (bool);\n\n    function currentSynthDebts(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory debtValues, bool anyRateIsInvalid);\n\n    function cachedSynthDebts(bytes32[] calldata currencyKeys) external view returns (uint[] memory debtValues);\n\n    function currentDebt() external view returns (uint debt, bool anyRateIsInvalid);\n\n    function cacheInfo()\n        external\n        view\n        returns (\n            uint debt,\n            uint timestamp,\n            bool isInvalid,\n            bool isStale\n        );\n\n    // Mutative functions\n\n    function takeDebtSnapshot() external;\n\n    function updateCachedSynthDebts(bytes32[] calldata currencyKeys) external;\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxy\ncontract Proxy is Owned {\n    Proxyable public target;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    function setTarget(Proxyable _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    function _emit(\n        bytes calldata callData,\n        uint numTopics,\n        bytes32 topic1,\n        bytes32 topic2,\n        bytes32 topic3,\n        bytes32 topic4\n    ) external onlyTarget {\n        uint size = callData.length;\n        bytes memory _callData = callData;\n\n        assembly {\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n             * This means moving call_data across 32 bytes guarantees we correctly access\n             * the data itself. */\n            switch numTopics\n                case 0 {\n                    log0(add(_callData, 32), size)\n                }\n                case 1 {\n                    log1(add(_callData, 32), size, topic1)\n                }\n                case 2 {\n                    log2(add(_callData, 32), size, topic1, topic2)\n                }\n                case 3 {\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\n                }\n                case 4 {\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n                }\n        }\n    }\n\n    // solhint-disable no-complex-fallback\n    function() external payable {\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\n        target.setMessageSender(msg.sender);\n\n        assembly {\n            let free_ptr := mload(0x40)\n            calldatacopy(free_ptr, 0, calldatasize)\n\n            /* We must explicitly forward ether to the underlying contract as well. */\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n            returndatacopy(free_ptr, 0, returndatasize)\n\n            if iszero(result) {\n                revert(free_ptr, returndatasize)\n            }\n            return(free_ptr, returndatasize)\n        }\n    }\n\n    modifier onlyTarget {\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\n        _;\n    }\n\n    event TargetUpdated(Proxyable newTarget);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\ncontract Proxyable is Owned {\n    // This contract should be treated like an abstract contract\n\n    /* The proxy this contract exists behind. */\n    Proxy public proxy;\n    Proxy public integrationProxy;\n\n    /* The caller of the proxy, passed through to this contract.\n     * Note that every function using this member must apply the onlyProxy or\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\n    address public messageSender;\n\n    constructor(address payable _proxy) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setProxy(address payable _proxy) external onlyOwner {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setIntegrationProxy(address payable _integrationProxy) external onlyOwner {\n        integrationProxy = Proxy(_integrationProxy);\n    }\n\n    function setMessageSender(address sender) external onlyProxy {\n        messageSender = sender;\n    }\n\n    modifier onlyProxy {\n        _onlyProxy();\n        _;\n    }\n\n    function _onlyProxy() private view {\n        require(Proxy(msg.sender) == proxy || Proxy(msg.sender) == integrationProxy, \"Only the proxy can call\");\n    }\n\n    modifier optionalProxy {\n        _optionalProxy();\n        _;\n    }\n\n    function _optionalProxy() private {\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n    }\n\n    modifier optionalProxy_onlyOwner {\n        _optionalProxy_onlyOwner();\n        _;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function _optionalProxy_onlyOwner() private {\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner, \"Owner only function\");\n    }\n\n    event ProxyUpdated(address proxyAddress);\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// Note: use OZ's IERC20 here as using ours will complain about conflicting names\n// during the build (VirtualSynth has IERC20 from the OZ ERC20 implementation)\n\n\n// Used to have strongly-typed access to internal mutative functions in Synthetix\ninterface ISynthetixInternal {\n    function emitExchangeTracking(\n        bytes32 trackingCode,\n        bytes32 toCurrencyKey,\n        uint256 toAmount\n    ) external;\n\n    function emitSynthExchange(\n        address account,\n        bytes32 fromCurrencyKey,\n        uint fromAmount,\n        bytes32 toCurrencyKey,\n        uint toAmount,\n        address toAddress\n    ) external;\n\n    function emitExchangeReclaim(\n        address account,\n        bytes32 currencyKey,\n        uint amount\n    ) external;\n\n    function emitExchangeRebate(\n        address account,\n        bytes32 currencyKey,\n        uint amount\n    ) external;\n}\n\n\ninterface IExchangerInternalDebtCache {\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates) external;\n\n    function updateCachedSynthDebts(bytes32[] calldata currencyKeys) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchanger\ncontract Exchanger is Owned, MixinResolver, MixinSystemSettings, IExchanger {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    struct ExchangeEntrySettlement {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint reclaim;\n        uint rebate;\n        uint srcRoundIdAtPeriodEnd;\n        uint destRoundIdAtPeriodEnd;\n        uint timestamp;\n    }\n\n    bytes32 private constant sUSD = \"sUSD\";\n\n    // SIP-65: Decentralized circuit breaker\n    uint public constant CIRCUIT_BREAKER_SUSPENSION_REASON = 65;\n\n    mapping(bytes32 => uint) public lastExchangeRate;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_EXCHANGESTATE = \"ExchangeState\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n    bytes32 private constant CONTRACT_SYNTHETIX = \"Synthetix\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n    bytes32 private constant CONTRACT_TRADING_REWARDS = \"TradingRewards\";\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \"DelegateApprovals\";\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\n    bytes32 private constant CONTRACT_DEBTCACHE = \"DebtCache\";\n\n    bytes32[24] private addressesToCache = [\n        CONTRACT_SYSTEMSTATUS,\n        CONTRACT_EXCHANGESTATE,\n        CONTRACT_EXRATES,\n        CONTRACT_SYNTHETIX,\n        CONTRACT_FEEPOOL,\n        CONTRACT_TRADING_REWARDS,\n        CONTRACT_DELEGATEAPPROVALS,\n        CONTRACT_ISSUER,\n        CONTRACT_DEBTCACHE\n    ];\n\n    constructor(address _owner, address _resolver)\n        public\n        Owned(_owner)\n        MixinResolver(_resolver, addressesToCache)\n        MixinSystemSettings()\n    {}\n\n    /* ========== VIEWS ========== */\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS, \"Missing SystemStatus address\"));\n    }\n\n    function exchangeState() internal view returns (IExchangeState) {\n        return IExchangeState(requireAndGetAddress(CONTRACT_EXCHANGESTATE, \"Missing ExchangeState address\"));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES, \"Missing ExchangeRates address\"));\n    }\n\n    function synthetix() internal view returns (ISynthetix) {\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX, \"Missing Synthetix address\"));\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL, \"Missing FeePool address\"));\n    }\n\n    function tradingRewards() internal view returns (ITradingRewards) {\n        return ITradingRewards(requireAndGetAddress(CONTRACT_TRADING_REWARDS, \"Missing TradingRewards address\"));\n    }\n\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS, \"Missing DelegateApprovals address\"));\n    }\n\n    function issuer() internal view returns (IIssuer) {\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER, \"Missing Issuer address\"));\n    }\n\n    function debtCache() internal view returns (IExchangerInternalDebtCache) {\n        return IExchangerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE, \"Missing DebtCache address\"));\n    }\n\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) public view returns (uint) {\n        return secsLeftInWaitingPeriodForExchange(exchangeState().getMaxTimestamp(account, currencyKey));\n    }\n\n    function waitingPeriodSecs() external view returns (uint) {\n        return getWaitingPeriodSecs();\n    }\n\n    function tradingRewardsEnabled() external view returns (bool) {\n        return getTradingRewardsEnabled();\n    }\n\n    function priceDeviationThresholdFactor() external view returns (uint) {\n        return getPriceDeviationThresholdFactor();\n    }\n\n    function settlementOwing(address account, bytes32 currencyKey)\n        public\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries\n        )\n    {\n        (reclaimAmount, rebateAmount, numEntries, ) = _settlementOwing(account, currencyKey);\n    }\n\n    // Internal function to emit events for each individual rebate and reclaim entry\n    function _settlementOwing(address account, bytes32 currencyKey)\n        internal\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries,\n            ExchangeEntrySettlement[] memory\n        )\n    {\n        // Need to sum up all reclaim and rebate amounts for the user and the currency key\n        numEntries = exchangeState().getLengthOfEntries(account, currencyKey);\n\n        // For each unsettled exchange\n        ExchangeEntrySettlement[] memory settlements = new ExchangeEntrySettlement[](numEntries);\n        for (uint i = 0; i < numEntries; i++) {\n            uint reclaim;\n            uint rebate;\n            // fetch the entry from storage\n            IExchangeState.ExchangeEntry memory exchangeEntry = _getExchangeEntry(account, currencyKey, i);\n\n            // determine the last round ids for src and dest pairs when period ended or latest if not over\n            (uint srcRoundIdAtPeriodEnd, uint destRoundIdAtPeriodEnd) = getRoundIdsAtPeriodEnd(exchangeEntry);\n\n            // given these round ids, determine what effective value they should have received\n            uint destinationAmount = exchangeRates().effectiveValueAtRound(\n                exchangeEntry.src,\n                exchangeEntry.amount,\n                exchangeEntry.dest,\n                srcRoundIdAtPeriodEnd,\n                destRoundIdAtPeriodEnd\n            );\n\n            // and deduct the fee from this amount using the exchangeFeeRate from storage\n            uint amountShouldHaveReceived = _getAmountReceivedForExchange(destinationAmount, exchangeEntry.exchangeFeeRate);\n\n            // SIP-65 settlements where the amount at end of waiting period is beyond the threshold, then\n            // settle with no reclaim or rebate\n            if (!_isDeviationAboveThreshold(exchangeEntry.amountReceived, amountShouldHaveReceived)) {\n                if (exchangeEntry.amountReceived > amountShouldHaveReceived) {\n                    // if they received more than they should have, add to the reclaim tally\n                    reclaim = exchangeEntry.amountReceived.sub(amountShouldHaveReceived);\n                    reclaimAmount = reclaimAmount.add(reclaim);\n                } else if (amountShouldHaveReceived > exchangeEntry.amountReceived) {\n                    // if less, add to the rebate tally\n                    rebate = amountShouldHaveReceived.sub(exchangeEntry.amountReceived);\n                    rebateAmount = rebateAmount.add(rebate);\n                }\n            }\n\n            settlements[i] = ExchangeEntrySettlement({\n                src: exchangeEntry.src,\n                amount: exchangeEntry.amount,\n                dest: exchangeEntry.dest,\n                reclaim: reclaim,\n                rebate: rebate,\n                srcRoundIdAtPeriodEnd: srcRoundIdAtPeriodEnd,\n                destRoundIdAtPeriodEnd: destRoundIdAtPeriodEnd,\n                timestamp: exchangeEntry.timestamp\n            });\n        }\n\n        return (reclaimAmount, rebateAmount, numEntries, settlements);\n    }\n\n    function _getExchangeEntry(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    ) internal view returns (IExchangeState.ExchangeEntry memory) {\n        (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        ) = exchangeState().getEntryAt(account, currencyKey, index);\n\n        return\n            IExchangeState.ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            });\n    }\n\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool) {\n        if (maxSecsLeftInWaitingPeriod(account, currencyKey) != 0) {\n            return true;\n        }\n\n        (uint reclaimAmount, , , ) = _settlementOwing(account, currencyKey);\n\n        return reclaimAmount > 0;\n    }\n\n    /* ========== SETTERS ========== */\n\n    function calculateAmountAfterSettlement(\n        address from,\n        bytes32 currencyKey,\n        uint amount,\n        uint refunded\n    ) public view returns (uint amountAfterSettlement) {\n        amountAfterSettlement = amount;\n\n        // balance of a synth will show an amount after settlement\n        uint balanceOfSourceAfterSettlement = IERC20(address(issuer().synths(currencyKey))).balanceOf(from);\n\n        // when there isn't enough supply (either due to reclamation settlement or because the number is too high)\n        if (amountAfterSettlement > balanceOfSourceAfterSettlement) {\n            // then the amount to exchange is reduced to their remaining supply\n            amountAfterSettlement = balanceOfSourceAfterSettlement;\n        }\n\n        if (refunded > 0) {\n            amountAfterSettlement = amountAfterSettlement.add(refunded);\n        }\n    }\n\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool) {\n        return _isSynthRateInvalid(currencyKey, exchangeRates().rateForCurrency(currencyKey));\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function exchange(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress\n    ) external onlySynthetixorSynth returns (uint amountReceived) {\n        uint fee;\n        (amountReceived, fee, ) = _exchange(\n            from,\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey,\n            destinationAddress,\n            false\n        );\n\n        _processTradingRewards(fee, destinationAddress);\n    }\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external onlySynthetixorSynth returns (uint amountReceived) {\n        require(delegateApprovals().canExchangeFor(exchangeForAddress, from), \"Not approved to act on behalf\");\n\n        uint fee;\n        (amountReceived, fee, ) = _exchange(\n            exchangeForAddress,\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey,\n            exchangeForAddress,\n            false\n        );\n\n        _processTradingRewards(fee, exchangeForAddress);\n    }\n\n    function exchangeWithTracking(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        address originator,\n        bytes32 trackingCode\n    ) external onlySynthetixorSynth returns (uint amountReceived) {\n        uint fee;\n        (amountReceived, fee, ) = _exchange(\n            from,\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey,\n            destinationAddress,\n            false\n        );\n\n        _processTradingRewards(fee, originator);\n\n        _emitTrackingEvent(trackingCode, destinationCurrencyKey, amountReceived);\n    }\n\n    function exchangeOnBehalfWithTracking(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address originator,\n        bytes32 trackingCode\n    ) external onlySynthetixorSynth returns (uint amountReceived) {\n        require(delegateApprovals().canExchangeFor(exchangeForAddress, from), \"Not approved to act on behalf\");\n\n        uint fee;\n        (amountReceived, fee, ) = _exchange(\n            exchangeForAddress,\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey,\n            exchangeForAddress,\n            false\n        );\n\n        _processTradingRewards(fee, originator);\n\n        _emitTrackingEvent(trackingCode, destinationCurrencyKey, amountReceived);\n    }\n\n    function exchangeWithVirtual(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bytes32 trackingCode\n    ) external onlySynthetixorSynth returns (uint amountReceived, IVirtualSynth vSynth) {\n        uint fee;\n        (amountReceived, fee, vSynth) = _exchange(\n            from,\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey,\n            destinationAddress,\n            true\n        );\n\n        _processTradingRewards(fee, destinationAddress);\n\n        if (trackingCode != bytes32(0)) {\n            _emitTrackingEvent(trackingCode, destinationCurrencyKey, amountReceived);\n        }\n    }\n\n    function _emitTrackingEvent(\n        bytes32 trackingCode,\n        bytes32 toCurrencyKey,\n        uint256 toAmount\n    ) internal {\n        ISynthetixInternal(address(synthetix())).emitExchangeTracking(trackingCode, toCurrencyKey, toAmount);\n    }\n\n    function _processTradingRewards(uint fee, address originator) internal {\n        if (fee > 0 && originator != address(0) && getTradingRewardsEnabled()) {\n            tradingRewards().recordExchangeFeeForAccount(fee, originator);\n        }\n    }\n\n    function _suspendIfRateInvalid(bytes32 currencyKey, uint rate) internal returns (bool circuitBroken) {\n        if (_isSynthRateInvalid(currencyKey, rate)) {\n            systemStatus().suspendSynth(currencyKey, CIRCUIT_BREAKER_SUSPENSION_REASON);\n            circuitBroken = true;\n        } else {\n            lastExchangeRate[currencyKey] = rate;\n        }\n    }\n\n    function _updateSNXIssuedDebtOnExchange(bytes32[2] memory currencyKeys, uint[2] memory currencyRates) internal {\n        bool includesSUSD = currencyKeys[0] == sUSD || currencyKeys[1] == sUSD;\n        uint numKeys = includesSUSD ? 2 : 3;\n\n        bytes32[] memory keys = new bytes32[](numKeys);\n        keys[0] = currencyKeys[0];\n        keys[1] = currencyKeys[1];\n\n        uint[] memory rates = new uint[](numKeys);\n        rates[0] = currencyRates[0];\n        rates[1] = currencyRates[1];\n\n        if (!includesSUSD) {\n            keys[2] = sUSD; // And we'll also update sUSD to account for any fees if it wasn't one of the exchanged currencies\n            rates[2] = SafeDecimalMath.unit();\n        }\n\n        // Note that exchanges can't invalidate the debt cache, since if a rate is invalid,\n        // the exchange will have failed already.\n        debtCache().updateCachedSynthDebtsWithRates(keys, rates);\n    }\n\n    function _settleAndCalcSourceAmountRemaining(\n        uint sourceAmount,\n        address from,\n        bytes32 sourceCurrencyKey\n    ) internal returns (uint sourceAmountAfterSettlement) {\n        (, uint refunded, uint numEntriesSettled) = _internalSettle(from, sourceCurrencyKey, false);\n\n        sourceAmountAfterSettlement = sourceAmount;\n\n        // when settlement was required\n        if (numEntriesSettled > 0) {\n            // ensure the sourceAmount takes this into account\n            sourceAmountAfterSettlement = calculateAmountAfterSettlement(from, sourceCurrencyKey, sourceAmount, refunded);\n        }\n    }\n\n    function _exchange(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bool virtualSynth\n    )\n        internal\n        returns (\n            uint amountReceived,\n            uint fee,\n            IVirtualSynth vSynth\n        )\n    {\n        _ensureCanExchange(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n\n        uint sourceAmountAfterSettlement = _settleAndCalcSourceAmountRemaining(sourceAmount, from, sourceCurrencyKey);\n\n        // If, after settlement the user has no balance left (highly unlikely), then return to prevent\n        // emitting events of 0 and don't revert so as to ensure the settlement queue is emptied\n        if (sourceAmountAfterSettlement == 0) {\n            return (0, 0, IVirtualSynth(0));\n        }\n\n        uint exchangeFeeRate;\n        uint sourceRate;\n        uint destinationRate;\n\n        // Note: `fee` is denominated in the destinationCurrencyKey.\n        (amountReceived, fee, exchangeFeeRate, sourceRate, destinationRate) = _getAmountsForExchangeMinusFees(\n            sourceAmountAfterSettlement,\n            sourceCurrencyKey,\n            destinationCurrencyKey\n        );\n\n        // SIP-65: Decentralized Circuit Breaker\n        if (\n            _suspendIfRateInvalid(sourceCurrencyKey, sourceRate) ||\n            _suspendIfRateInvalid(destinationCurrencyKey, destinationRate)\n        ) {\n            return (0, 0, IVirtualSynth(0));\n        }\n\n        // Note: We don't need to check their balance as the burn() below will do a safe subtraction which requires\n        // the subtraction to not overflow, which would happen if their balance is not sufficient.\n\n        vSynth = _convert(\n            sourceCurrencyKey,\n            from,\n            sourceAmountAfterSettlement,\n            destinationCurrencyKey,\n            amountReceived,\n            destinationAddress,\n            virtualSynth\n        );\n\n        // When using a virtual synth, it becomes the destinationAddress for event and settlement tracking\n        if (vSynth != IVirtualSynth(0)) {\n            destinationAddress = address(vSynth);\n        }\n\n        // Remit the fee if required\n        if (fee > 0) {\n            // Normalize fee to sUSD\n            // Note: `fee` is being reused to avoid stack too deep errors.\n            fee = exchangeRates().effectiveValue(destinationCurrencyKey, fee, sUSD);\n\n            // Remit the fee in sUSDs\n            issuer().synths(sUSD).issue(feePool().FEE_ADDRESS(), fee);\n\n            // Tell the fee pool about this\n            feePool().recordFeePaid(fee);\n        }\n\n        // Note: As of this point, `fee` is denominated in sUSD.\n\n        // Nothing changes as far as issuance data goes because the total value in the system hasn't changed.\n        // But we will update the debt snapshot in case exchange rates have fluctuated since the last exchange\n        // in these currencies\n        _updateSNXIssuedDebtOnExchange([sourceCurrencyKey, destinationCurrencyKey], [sourceRate, destinationRate]);\n\n        // Let the DApps know there was a Synth exchange\n        ISynthetixInternal(address(synthetix())).emitSynthExchange(\n            from,\n            sourceCurrencyKey,\n            sourceAmountAfterSettlement,\n            destinationCurrencyKey,\n            amountReceived,\n            destinationAddress\n        );\n\n        // persist the exchange information for the dest key\n        appendExchange(\n            destinationAddress,\n            sourceCurrencyKey,\n            sourceAmountAfterSettlement,\n            destinationCurrencyKey,\n            amountReceived,\n            exchangeFeeRate\n        );\n    }\n\n    function _convert(\n        bytes32 sourceCurrencyKey,\n        address from,\n        uint sourceAmountAfterSettlement,\n        bytes32 destinationCurrencyKey,\n        uint amountReceived,\n        address recipient,\n        bool virtualSynth\n    ) internal returns (IVirtualSynth vSynth) {\n        // Burn the source amount\n        issuer().synths(sourceCurrencyKey).burn(from, sourceAmountAfterSettlement);\n\n        // Issue their new synths\n        ISynth dest = issuer().synths(destinationCurrencyKey);\n\n        if (virtualSynth) {\n            Proxyable synth = Proxyable(address(dest));\n            vSynth = _createVirtualSynth(IERC20(address(synth.proxy())), recipient, amountReceived, destinationCurrencyKey);\n            dest.issue(address(vSynth), amountReceived);\n        } else {\n            dest.issue(recipient, amountReceived);\n        }\n    }\n\n    function _createVirtualSynth(\n        IERC20,\n        address,\n        uint,\n        bytes32\n    ) internal returns (IVirtualSynth) {\n        revert(\"Not supported in this layer\");\n    }\n\n    // Note: this function can intentionally be called by anyone on behalf of anyone else (the caller just pays the gas)\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntriesSettled\n        )\n    {\n        systemStatus().requireSynthActive(currencyKey);\n        return _internalSettle(from, currencyKey, true);\n    }\n\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external {\n        systemStatus().requireSystemActive();\n        require(issuer().synths(currencyKey) != ISynth(0), \"No such synth\");\n        require(_isSynthRateInvalid(currencyKey, exchangeRates().rateForCurrency(currencyKey)), \"Synth price is valid\");\n        systemStatus().suspendSynth(currencyKey, CIRCUIT_BREAKER_SUSPENSION_REASON);\n    }\n\n    // SIP-78\n    function setLastExchangeRateForSynth(bytes32 currencyKey, uint rate) external onlyExchangeRates {\n        require(rate > 0, \"Rate must be above 0\");\n        lastExchangeRate[currencyKey] = rate;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _ensureCanExchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) internal view {\n        require(sourceCurrencyKey != destinationCurrencyKey, \"Can't be same synth\");\n        require(sourceAmount > 0, \"Zero amount\");\n\n        bytes32[] memory synthKeys = new bytes32[](2);\n        synthKeys[0] = sourceCurrencyKey;\n        synthKeys[1] = destinationCurrencyKey;\n        require(!exchangeRates().anyRateIsInvalid(synthKeys), \"Src/dest rate invalid or not found\");\n    }\n\n    function _isSynthRateInvalid(bytes32 currencyKey, uint currentRate) internal view returns (bool) {\n        if (currentRate == 0) {\n            return true;\n        }\n\n        uint lastRateFromExchange = lastExchangeRate[currencyKey];\n\n        if (lastRateFromExchange > 0) {\n            return _isDeviationAboveThreshold(lastRateFromExchange, currentRate);\n        }\n\n        // if no last exchange for this synth, then we need to look up last 3 rates (+1 for current rate)\n        (uint[] memory rates, ) = exchangeRates().ratesAndUpdatedTimeForCurrencyLastNRounds(currencyKey, 4);\n\n        // start at index 1 to ignore current rate\n        for (uint i = 1; i < rates.length; i++) {\n            // ignore any empty rates in the past (otherwise we will never be able to get validity)\n            if (rates[i] > 0 && _isDeviationAboveThreshold(rates[i], currentRate)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _isDeviationAboveThreshold(uint base, uint comparison) internal view returns (bool) {\n        if (base == 0 || comparison == 0) {\n            return true;\n        }\n\n        uint factor;\n        if (comparison > base) {\n            factor = comparison.divideDecimal(base);\n        } else {\n            factor = base.divideDecimal(comparison);\n        }\n\n        return factor >= getPriceDeviationThresholdFactor();\n    }\n\n    function _internalSettle(\n        address from,\n        bytes32 currencyKey,\n        bool updateCache\n    )\n        internal\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntriesSettled\n        )\n    {\n        require(maxSecsLeftInWaitingPeriod(from, currencyKey) == 0, \"Cannot settle during waiting period\");\n\n        (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint entries,\n            ExchangeEntrySettlement[] memory settlements\n        ) = _settlementOwing(from, currencyKey);\n\n        if (reclaimAmount > rebateAmount) {\n            reclaimed = reclaimAmount.sub(rebateAmount);\n            reclaim(from, currencyKey, reclaimed);\n        } else if (rebateAmount > reclaimAmount) {\n            refunded = rebateAmount.sub(reclaimAmount);\n            refund(from, currencyKey, refunded);\n        }\n\n        if (updateCache) {\n            bytes32[] memory key = new bytes32[](1);\n            key[0] = currencyKey;\n            debtCache().updateCachedSynthDebts(key);\n        }\n\n        // emit settlement event for each settled exchange entry\n        for (uint i = 0; i < settlements.length; i++) {\n            emit ExchangeEntrySettled(\n                from,\n                settlements[i].src,\n                settlements[i].amount,\n                settlements[i].dest,\n                settlements[i].reclaim,\n                settlements[i].rebate,\n                settlements[i].srcRoundIdAtPeriodEnd,\n                settlements[i].destRoundIdAtPeriodEnd,\n                settlements[i].timestamp\n            );\n        }\n\n        numEntriesSettled = entries;\n\n        // Now remove all entries, even if no reclaim and no rebate\n        exchangeState().removeEntries(from, currencyKey);\n    }\n\n    function reclaim(\n        address from,\n        bytes32 currencyKey,\n        uint amount\n    ) internal {\n        // burn amount from user\n        issuer().synths(currencyKey).burn(from, amount);\n        ISynthetixInternal(address(synthetix())).emitExchangeReclaim(from, currencyKey, amount);\n    }\n\n    function refund(\n        address from,\n        bytes32 currencyKey,\n        uint amount\n    ) internal {\n        // issue amount to user\n        issuer().synths(currencyKey).issue(from, amount);\n        ISynthetixInternal(address(synthetix())).emitExchangeRebate(from, currencyKey, amount);\n    }\n\n    function secsLeftInWaitingPeriodForExchange(uint timestamp) internal view returns (uint) {\n        uint _waitingPeriodSecs = getWaitingPeriodSecs();\n        if (timestamp == 0 || now >= timestamp.add(_waitingPeriodSecs)) {\n            return 0;\n        }\n\n        return timestamp.add(_waitingPeriodSecs).sub(now);\n    }\n\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint exchangeFeeRate)\n    {\n        exchangeFeeRate = _feeRateForExchange(sourceCurrencyKey, destinationCurrencyKey);\n    }\n\n    function _feeRateForExchange(\n        bytes32, // API for source in case pricing model evolves to include source rate /* sourceCurrencyKey */\n        bytes32 destinationCurrencyKey\n    ) internal view returns (uint exchangeFeeRate) {\n        return getExchangeFeeRate(destinationCurrencyKey);\n    }\n\n    function getAmountsForExchange(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate\n        )\n    {\n        (amountReceived, fee, exchangeFeeRate, , ) = _getAmountsForExchangeMinusFees(\n            sourceAmount,\n            sourceCurrencyKey,\n            destinationCurrencyKey\n        );\n    }\n\n    function _getAmountsForExchangeMinusFees(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        internal\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        uint destinationAmount;\n        (destinationAmount, sourceRate, destinationRate) = exchangeRates().effectiveValueAndRates(\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey\n        );\n        exchangeFeeRate = _feeRateForExchange(sourceCurrencyKey, destinationCurrencyKey);\n        amountReceived = _getAmountReceivedForExchange(destinationAmount, exchangeFeeRate);\n        fee = destinationAmount.sub(amountReceived);\n    }\n\n    function _getAmountReceivedForExchange(uint destinationAmount, uint exchangeFeeRate)\n        internal\n        pure\n        returns (uint amountReceived)\n    {\n        amountReceived = destinationAmount.multiplyDecimal(SafeDecimalMath.unit().sub(exchangeFeeRate));\n    }\n\n    function appendExchange(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate\n    ) internal {\n        IExchangeRates exRates = exchangeRates();\n        uint roundIdForSrc = exRates.getCurrentRoundId(src);\n        uint roundIdForDest = exRates.getCurrentRoundId(dest);\n        exchangeState().appendExchangeEntry(\n            account,\n            src,\n            amount,\n            dest,\n            amountReceived,\n            exchangeFeeRate,\n            now,\n            roundIdForSrc,\n            roundIdForDest\n        );\n\n        emit ExchangeEntryAppended(\n            account,\n            src,\n            amount,\n            dest,\n            amountReceived,\n            exchangeFeeRate,\n            roundIdForSrc,\n            roundIdForDest\n        );\n    }\n\n    function getRoundIdsAtPeriodEnd(IExchangeState.ExchangeEntry memory exchangeEntry)\n        internal\n        view\n        returns (uint srcRoundIdAtPeriodEnd, uint destRoundIdAtPeriodEnd)\n    {\n        IExchangeRates exRates = exchangeRates();\n        uint _waitingPeriodSecs = getWaitingPeriodSecs();\n\n        srcRoundIdAtPeriodEnd = exRates.getLastRoundIdBeforeElapsedSecs(\n            exchangeEntry.src,\n            exchangeEntry.roundIdForSrc,\n            exchangeEntry.timestamp,\n            _waitingPeriodSecs\n        );\n        destRoundIdAtPeriodEnd = exRates.getLastRoundIdBeforeElapsedSecs(\n            exchangeEntry.dest,\n            exchangeEntry.roundIdForDest,\n            exchangeEntry.timestamp,\n            _waitingPeriodSecs\n        );\n    }\n\n    // ========== MODIFIERS ==========\n\n    modifier onlySynthetixorSynth() {\n        ISynthetix _synthetix = synthetix();\n        require(\n            msg.sender == address(_synthetix) || _synthetix.synthsByAddress(msg.sender) != bytes32(0),\n            \"Exchanger: Only synthetix or a synth contract can perform this action\"\n        );\n        _;\n    }\n\n    modifier onlyExchangeRates() {\n        IExchangeRates _exchangeRates = exchangeRates();\n        require(msg.sender == address(_exchangeRates), \"Restricted to ExchangeRates\");\n        _;\n    }\n\n    // ========== EVENTS ==========\n    event ExchangeEntryAppended(\n        address indexed account,\n        bytes32 src,\n        uint256 amount,\n        bytes32 dest,\n        uint256 amountReceived,\n        uint256 exchangeFeeRate,\n        uint256 roundIdForSrc,\n        uint256 roundIdForDest\n    );\n\n    event ExchangeEntrySettled(\n        address indexed from,\n        bytes32 src,\n        uint256 amount,\n        bytes32 dest,\n        uint256 reclaim,\n        uint256 rebate,\n        uint256 srcRoundIdAtPeriodEnd,\n        uint256 destRoundIdAtPeriodEnd,\n        uint256 exchangeTimestamp\n    );\n}\n\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// Note: use OZ's IERC20 here as using ours will complain about conflicting names\n// during the build\n\n\n// https://docs.synthetix.io/contracts/source/contracts/virtualsynth\ncontract VirtualSynth is ERC20, IVirtualSynth {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    IERC20 public synth;\n    IAddressResolver public resolver;\n\n    bool public settled = false;\n\n    uint8 public constant decimals = 18;\n\n    // track initial supply so we can calculate the rate even after all supply is burned\n    uint public initialSupply;\n\n    // track final settled amount of the synth so we can calculate the rate after settlement\n    uint public settledAmount;\n\n    bytes32 public currencyKey;\n\n    constructor(\n        IERC20 _synth,\n        IAddressResolver _resolver,\n        address _recipient,\n        uint _amount,\n        bytes32 _currencyKey\n    ) public ERC20() {\n        synth = _synth;\n        resolver = _resolver;\n        currencyKey = _currencyKey;\n\n        // Assumption: the synth will be issued to us within the same transaction,\n        // and this supply matches that\n        _mint(_recipient, _amount);\n\n        initialSupply = _amount;\n    }\n\n    // INTERNALS\n\n    function exchanger() internal view returns (IExchanger) {\n        return IExchanger(resolver.requireAndGetAddress(\"Exchanger\", \"Exchanger contract not found\"));\n    }\n\n    function secsLeft() internal view returns (uint) {\n        return exchanger().maxSecsLeftInWaitingPeriod(address(this), currencyKey);\n    }\n\n    function calcRate() internal view returns (uint) {\n        if (initialSupply == 0) {\n            return 0;\n        }\n\n        uint synthBalance;\n\n        if (!settled) {\n            synthBalance = IERC20(address(synth)).balanceOf(address(this));\n            (uint reclaim, uint rebate, ) = exchanger().settlementOwing(address(this), currencyKey);\n\n            if (reclaim > 0) {\n                synthBalance = synthBalance.sub(reclaim);\n            } else if (rebate > 0) {\n                synthBalance = synthBalance.add(rebate);\n            }\n        } else {\n            synthBalance = settledAmount;\n        }\n\n        return synthBalance.divideDecimalRound(initialSupply);\n    }\n\n    function balanceUnderlying(address account) internal view returns (uint) {\n        uint vBalanceOfAccount = balanceOf(account);\n\n        return vBalanceOfAccount.multiplyDecimalRound(calcRate());\n    }\n\n    function settleSynth() internal {\n        if (settled) {\n            return;\n        }\n        settled = true;\n\n        exchanger().settle(address(this), currencyKey);\n\n        settledAmount = IERC20(address(synth)).balanceOf(address(this));\n\n        emit Settled(totalSupply(), settledAmount);\n    }\n\n    // VIEWS\n\n    function name() external view returns (string memory) {\n        return string(abi.encodePacked(\"Virtual Synth \", currencyKey));\n    }\n\n    function symbol() external view returns (string memory) {\n        return string(abi.encodePacked(\"v\", currencyKey));\n    }\n\n    // get the rate of the vSynth to the synth.\n    function rate() external view returns (uint) {\n        return calcRate();\n    }\n\n    // show the balance of the underlying synth that the given address has, given\n    // their proportion of totalSupply\n    function balanceOfUnderlying(address account) external view returns (uint) {\n        return balanceUnderlying(account);\n    }\n\n    function secsLeftInWaitingPeriod() external view returns (uint) {\n        return secsLeft();\n    }\n\n    function readyToSettle() external view returns (bool) {\n        return secsLeft() == 0;\n    }\n\n    // PUBLIC FUNCTIONS\n\n    // Perform settlement of the underlying exchange if required,\n    // then burn the accounts vSynths and transfer them their owed balanceOfUnderlying\n    function settle(address account) external {\n        settleSynth();\n\n        IERC20(address(synth)).transfer(account, balanceUnderlying(account));\n\n        _burn(account, balanceOf(account));\n    }\n\n    event Settled(uint totalSupply, uint amountAfterSettled);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangerwithvirtualsynth\ncontract ExchangerWithVirtualSynth is Exchanger {\n    constructor(address _owner, address _resolver) public Exchanger(_owner, _resolver) {}\n\n    function _createVirtualSynth(\n        IERC20 synth,\n        address recipient,\n        uint amount,\n        bytes32 currencyKey\n    ) internal returns (IVirtualSynth vSynth) {\n        // prevent inverse synths from being allowed due to purgeability\n        require(currencyKey[0] != 0x69, \"Cannot virtualize this synth\");\n\n        vSynth = new VirtualSynth(synth, resolver, recipient, amount, currencyKey);\n        emit VirtualSynthCreated(address(synth), recipient, address(vSynth), currencyKey, amount);\n    }\n\n    event VirtualSynthCreated(\n        address indexed synth,\n        address indexed recipient,\n        address vSynth,\n        bytes32 currencyKey,\n        uint amount\n    );\n}\n\n    ","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"src\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dest\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exchangeFeeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundIdForSrc\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundIdForDest\",\"type\":\"uint256\"}],\"name\":\"ExchangeEntryAppended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"src\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dest\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reclaim\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rebate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcRoundIdAtPeriodEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destRoundIdAtPeriodEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exchangeTimestamp\",\"type\":\"uint256\"}],\"name\":\"ExchangeEntrySettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"synth\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vSynth\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VirtualSynthCreated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"CIRCUIT_BREAKER_SUSPENSION_REASON\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ADDRESSES_FROM_RESOLVER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refunded\",\"type\":\"uint256\"}],\"name\":\"calculateAmountAfterSettlement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountAfterSettlement\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"destinationAddress\",\"type\":\"address\"}],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangeForAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"exchangeOnBehalf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangeForAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"originator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"trackingCode\",\"type\":\"bytes32\"}],\"name\":\"exchangeOnBehalfWithTracking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"destinationAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"trackingCode\",\"type\":\"bytes32\"}],\"name\":\"exchangeWithTracking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"destinationAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"trackingCode\",\"type\":\"bytes32\"}],\"name\":\"exchangeWithVirtual\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"internalType\":\"contract IVirtualSynth\",\"name\":\"vSynth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"feeRateForExchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"exchangeFeeRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"getAmountsForExchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeFeeRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getResolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32[24]\",\"name\":\"addressesRequired\",\"type\":\"bytes32[24]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"hasWaitingPeriodOrSettlementOwing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"isSynthRateInvalid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lastExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"maxSecsLeftInWaitingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceDeviationThresholdFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setLastExchangeRateForSynth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"setResolverAndSyncCache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"settle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reclaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refunded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numEntriesSettled\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"settlementOwing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reclaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebateAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numEntries\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"suspendSynthWithInvalidRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingRewardsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitingPeriodSecs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ExchangerWithVirtualSynth","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000de910777c787903f78c89e7a0bf7f4c435cbb1fe0000000000000000000000004e3b31eb0e5cb73641ee1e65e7dcefe520ba3ef2","EVMVersion":"Default","Library":"SafeDecimalMath:84d626b2bb4d0f064067e4bf80fce7055d8f3e7b","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}