{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.12;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n\r\n            bytes32 accountHash\r\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nlibrary DataTypes {\r\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n    struct ReserveData {\r\n        //stores the reserve configuration\r\n        ReserveConfigurationMap configuration;\r\n        //the liquidity index. Expressed in ray\r\n        uint128 liquidityIndex;\r\n        //variable borrow index. Expressed in ray\r\n        uint128 variableBorrowIndex;\r\n        //the current supply rate. Expressed in ray\r\n        uint128 currentLiquidityRate;\r\n        //the current variable borrow rate. Expressed in ray\r\n        uint128 currentVariableBorrowRate;\r\n        //the current stable borrow rate. Expressed in ray\r\n        uint128 currentStableBorrowRate;\r\n        uint40 lastUpdateTimestamp;\r\n        //tokens addresses\r\n        address aTokenAddress;\r\n        address stableDebtTokenAddress;\r\n        address variableDebtTokenAddress;\r\n        //address of the interest rate strategy\r\n        address interestRateStrategyAddress;\r\n        //the id of the reserve. Represents the position in the list of the active reserves\r\n        uint8 id;\r\n    }\r\n\r\n    struct ReserveConfigurationMap {\r\n        //bit 0-15: LTV\r\n        //bit 16-31: Liq. threshold\r\n        //bit 32-47: Liq. bonus\r\n        //bit 48-55: Decimals\r\n        //bit 56: Reserve is active\r\n        //bit 57: reserve is frozen\r\n        //bit 58: borrowing is enabled\r\n        //bit 59: stable rate borrowing enabled\r\n        //bit 60-63: reserved\r\n        //bit 64-79: reserve factor\r\n        uint256 data;\r\n    }\r\n\r\n    struct UserConfigurationMap {\r\n        uint256 data;\r\n    }\r\n\r\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IFlashLoanReceiver {\r\n    function executeOperation(\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata premiums,\r\n        address initiator,\r\n        bytes calldata params\r\n    ) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProvider {\r\n    event LendingPoolUpdated(address indexed newAddress);\r\n    event ConfigurationAdminUpdated(address indexed newAddress);\r\n    event EmergencyAdminUpdated(address indexed newAddress);\r\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n    event PriceOracleUpdated(address indexed newAddress);\r\n    event LendingRateOracleUpdated(address indexed newAddress);\r\n    event ProxyCreated(bytes32 id, address indexed newAddress);\r\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n    function setAddress(bytes32 id, address newAddress) external;\r\n\r\n    function setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n    function getAddress(bytes32 id) external view returns (address);\r\n\r\n    function getLendingPool() external view returns (address);\r\n\r\n    function setLendingPoolImpl(address pool) external;\r\n\r\n    function getLendingPoolConfigurator() external view returns (address);\r\n\r\n    function setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n    function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n    function setLendingPoolCollateralManager(address manager) external;\r\n\r\n    function getPoolAdmin() external view returns (address);\r\n\r\n    function setPoolAdmin(address admin) external;\r\n\r\n    function getEmergencyAdmin() external view returns (address);\r\n\r\n    function setEmergencyAdmin(address admin) external;\r\n\r\n    function getPriceOracle() external view returns (address);\r\n\r\n    function setPriceOracle(address priceOracle) external;\r\n\r\n    function getLendingRateOracle() external view returns (address);\r\n\r\n    function setLendingRateOracle(address lendingRateOracle) external;\r\n}\r\n\r\ninterface ILendingPool {\r\n    /**\r\n     * @dev Emitted on deposit()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address initiating the deposit\r\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\r\n     * @param amount The amount deposited\r\n     * @param referral The referral code used\r\n     **/\r\n    event Deposit(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint16 indexed referral\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on withdraw()\r\n     * @param reserve The address of the underlyng asset being withdrawn\r\n     * @param user The address initiating the withdrawal, owner of aTokens\r\n     * @param to Address that will receive the underlying\r\n     * @param amount The amount to be withdrawn\r\n     **/\r\n    event Withdraw(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n     * @param reserve The address of the underlying asset being borrowed\r\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n     * initiator of the transaction on flashLoan()\r\n     * @param onBehalfOf The address that will be getting the debt\r\n     * @param amount The amount borrowed out\r\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\r\n     * @param borrowRate The numeric rate at which the user has borrowed\r\n     * @param referral The referral code used\r\n     **/\r\n    event Borrow(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint256 borrowRateMode,\r\n        uint256 borrowRate,\r\n        uint16 indexed referral\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on repay()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The beneficiary of the repayment, getting his debt reduced\r\n     * @param repayer The address of the user initiating the repay(), providing the funds\r\n     * @param amount The amount repaid\r\n     **/\r\n    event Repay(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed repayer,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on swapBorrowRateMode()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user swapping his rate mode\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralEnabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralDisabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on rebalanceStableBorrowRate()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user for which the rebalance has been executed\r\n     **/\r\n    event RebalanceStableBorrowRate(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on flashLoan()\r\n     * @param target The address of the flash loan receiver contract\r\n     * @param initiator The address initiating the flash loan\r\n     * @param asset The address of the asset being flash borrowed\r\n     * @param amount The amount flash borrowed\r\n     * @param premium The fee flash borrowed\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event FlashLoan(\r\n        address indexed target,\r\n        address indexed initiator,\r\n        address indexed asset,\r\n        uint256 amount,\r\n        uint256 premium,\r\n        uint16 referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered.\r\n     */\r\n    event Paused();\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted.\r\n     */\r\n    event Unpaused();\r\n\r\n    /**\r\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\r\n     * LendingPoolCollateral manager using a DELEGATECALL\r\n     * This allows to have the events in the generated ABI for LendingPool.\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\r\n     * @param liquidator The address of the liquidator\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    event LiquidationCall(\r\n        address indexed collateralAsset,\r\n        address indexed debtAsset,\r\n        address indexed user,\r\n        uint256 debtToCover,\r\n        uint256 liquidatedCollateralAmount,\r\n        address liquidator,\r\n        bool receiveAToken\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\r\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\r\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\r\n     * gets added to the LendingPool ABI\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param liquidityRate The new liquidity rate\r\n     * @param stableBorrowRate The new stable borrow rate\r\n     * @param variableBorrowRate The new variable borrow rate\r\n     * @param liquidityIndex The new liquidity index\r\n     * @param variableBorrowIndex The new variable borrow index\r\n     **/\r\n    event ReserveDataUpdated(\r\n        address indexed reserve,\r\n        uint256 liquidityRate,\r\n        uint256 stableBorrowRate,\r\n        uint256 variableBorrowRate,\r\n        uint256 liquidityIndex,\r\n        uint256 variableBorrowIndex\r\n    );\r\n\r\n    /**\r\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n     * @param asset The address of the underlying asset to deposit\r\n     * @param amount The amount to be deposited\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function deposit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n     * @param asset The address of the underlying asset to withdraw\r\n     * @param amount The underlying amount to be withdrawn\r\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n     * @param to Address that will receive the underlying, same as msg.sender if the user\r\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n     *   different wallet\r\n     **/\r\n    function withdraw(\r\n        address asset,\r\n        uint256 amount,\r\n        address to\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n     * @param asset The address of the underlying asset to borrow\r\n     * @param amount The amount to be borrowed\r\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n     * if he has been given credit delegation allowance\r\n     **/\r\n    function borrow(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        uint16 referralCode,\r\n        address onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n     * other borrower whose debt should be removed\r\n     **/\r\n    function repay(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 rateMode,\r\n        address onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\r\n\r\n    /**\r\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n     * - Users can be rebalanced if the following conditions are satisfied:\r\n     *     1. Usage ratio is above 95%\r\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n     *        borrowed at a stable rate and depositors are not earning enough\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param user The address of the user to be rebalanced\r\n     **/\r\n    function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n    /**\r\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n     * @param asset The address of the underlying asset deposited\r\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n     **/\r\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n        external;\r\n\r\n    /**\r\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    function liquidationCall(\r\n        address collateralAsset,\r\n        address debtAsset,\r\n        address user,\r\n        uint256 debtToCover,\r\n        bool receiveAToken\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n     * as long as the amount taken plus a fee is returned.\r\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n     * For further details please visit https://developers.aave.com\r\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n     * @param assets The addresses of the assets being flash-borrowed\r\n     * @param amounts The amounts amounts being flash-borrowed\r\n     * @param modes Types of the debt to open if the flash loan is not returned:\r\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n     * @param params Variadic packed params to pass to the receiver as extra information\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function flashLoan(\r\n        address receiverAddress,\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata modes,\r\n        address onBehalfOf,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the user account data across all the reserves\r\n     * @param user The address of the user\r\n     * @return totalCollateralETH the total collateral in ETH of the user\r\n     * @return totalDebtETH the total debt in ETH of the user\r\n     * @return availableBorrowsETH the borrowing power left of the user\r\n     * @return currentLiquidationThreshold the liquidation threshold of the user\r\n     * @return ltv the loan to value of the user\r\n     * @return healthFactor the current health factor of the user\r\n     **/\r\n    function getUserAccountData(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalCollateralETH,\r\n            uint256 totalDebtETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        );\r\n\r\n    function initReserve(\r\n        address reserve,\r\n        address aTokenAddress,\r\n        address stableDebtAddress,\r\n        address variableDebtAddress,\r\n        address interestRateStrategyAddress\r\n    ) external;\r\n\r\n    function setReserveInterestRateStrategyAddress(\r\n        address reserve,\r\n        address rateStrategyAddress\r\n    ) external;\r\n\r\n    function setConfiguration(address reserve, uint256 configuration) external;\r\n\r\n    /**\r\n     * @dev Returns the configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The configuration of the reserve\r\n     **/\r\n    function getConfiguration(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n    /**\r\n     * @dev Returns the configuration of the user across all the reserves\r\n     * @param user The user address\r\n     * @return The configuration of the user\r\n     **/\r\n    function getUserConfiguration(address user)\r\n        external\r\n        view\r\n        returns (DataTypes.UserConfigurationMap memory);\r\n\r\n    /**\r\n     * @dev Returns the normalized income normalized income of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve's normalized income\r\n     */\r\n    function getReserveNormalizedIncome(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the normalized variable debt per unit of asset\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve normalized variable debt\r\n     */\r\n    function getReserveNormalizedVariableDebt(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the state and configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The state of the reserve\r\n     **/\r\n    function getReserveData(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveData memory);\r\n\r\n    function finalizeTransfer(\r\n        address asset,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 balanceFromAfter,\r\n        uint256 balanceToBefore\r\n    ) external;\r\n\r\n    function getReservesList() external view returns (address[] memory);\r\n\r\n    function getAddressesProvider()\r\n        external\r\n        view\r\n        returns (ILendingPoolAddressesProvider);\r\n\r\n    function setPause(bool val) external;\r\n\r\n    function paused() external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    ILendingPoolAddressesProvider internal _addressesProvider;\r\n    ILendingPool internal _lendingPool;\r\n\r\n    constructor(ILendingPoolAddressesProvider provider) public {\r\n        _addressesProvider = provider;\r\n        _lendingPool = ILendingPool(\r\n            ILendingPoolAddressesProvider(provider).getLendingPool()\r\n        );\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n\r\n\r\n\r\ninterface IBank {\r\n    function liquidateBorrow(\r\n        address borrower,\r\n        address underlyingBorrow,\r\n        address underlyingCollateral,\r\n        uint256 repayAmount\r\n    ) external payable;\r\n\r\n    function tokenOut(address token, uint256 amountOut) external;\r\n}\r\n\r\n\r\n\r\ninterface IBankController {\r\n    function getAccountLiquidity(address account)\r\n        external\r\n        view\r\n        returns (uint256 liquidity, uint256 shortfall);\r\n}\r\n\r\n\r\n\r\ninterface IUniswapRouter {\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n}\r\n\r\n\r\ninterface IWeth {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\n\r\ninterface IChiToken {\r\n    function free(uint256 value) external returns (uint256);\r\n\r\n    function freeUpTo(uint256 value) external returns (uint256);\r\n\r\n    function freeFrom(address from, uint256 value) external returns (uint256);\r\n\r\n    function freeFromUpTo(address from, uint256 value)\r\n        external\r\n        returns (uint256);\r\n}\r\n\r\n\r\ncontract MyAaveFlashLoan is FlashLoanReceiverBase {\r\n    using SafeMath for uint256;\r\n\r\n    IBank public bank;\r\n\r\n    IBankController public bankController;\r\n\r\n    IUniswapRouter public router;\r\n\r\n    IWeth public weth;\r\n\r\n    IChiToken chi;\r\n\r\n    address public borrower;\r\n\r\n    address public underlyingBorrow;\r\n\r\n    address public underlyingCollateral;\r\n\r\n    uint256 public repayAmount;\r\n\r\n    address public admin;\r\n\r\n    address[] public path;\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin, \"Admin required\");\r\n        _;\r\n    }\r\n\r\n    modifier discountCHI(uint256 amount) {\r\n        if (amount == 0) {\r\n            _;\r\n        } else {\r\n            uint256 gasStart = gasleft();\r\n            _;\r\n            uint256 gasSpent = 21000 +\r\n                gasStart -\r\n                gasleft() +\r\n                16 *\r\n                msg.data.length;\r\n            chi.freeFromUpTo(\r\n                msg.sender,\r\n                (gasSpent + 14154) / 41947\r\n            );\r\n        }\r\n    }\r\n\r\n    constructor(ILendingPoolAddressesProvider _addressProvider)\r\n        public\r\n        FlashLoanReceiverBase(_addressProvider)\r\n    {\r\n        admin = msg.sender;\r\n        bank = IBank(0xdE7B3b2Fe0E7b4925107615A5b199a4EB40D9ca9);\r\n        bankController = IBankController(\r\n            0x936E6490eD786FD0e0f0C1b1e4E1540b9D41F9eF\r\n        );\r\n        router = IUniswapRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        weth = IWeth(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n        chi = IChiToken(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n    }\r\n\r\n    struct ExecuteVars {\r\n        bool isCollateralETH;\r\n        uint256 collateralBefore;\r\n        uint256 collateralAfter;\r\n        uint256 delta;\r\n    }\r\n\r\n    /**\r\n        This function is called after your contract has received the flash loaned amount\r\n     */\r\n    function executeOperation(\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata premiums,\r\n        address initiator,\r\n        bytes calldata params\r\n    ) external override returns (bool) {\r\n        //\r\n        // This contract now has the funds requested.\r\n        // Your logic goes here.\r\n        //\r\n\r\n        initiator;\r\n        params;\r\n        ExecuteVars memory vars;\r\n\r\n        bool isBorrowETH = underlyingBorrow ==\r\n            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n        if (isBorrowETH) {\r\n            weth.withdraw(repayAmount);\r\n        } else {\r\n            approveInternal(\r\n                underlyingBorrow,\r\n                address(bankController),\r\n                uint256(-1)\r\n            );\r\n        }\r\n\r\n        bank.liquidateBorrow{value: repayAmount}(\r\n            borrower,\r\n            underlyingBorrow,\r\n            underlyingCollateral,\r\n            repayAmount\r\n        );\r\n\r\n        vars.isCollateralETH =\r\n            underlyingCollateral == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n        vars.collateralBefore = vars.isCollateralETH\r\n            ? address(this).balance\r\n            : IERC20(underlyingCollateral).balanceOf(address(this));\r\n        // token out fToken\r\n        bank.tokenOut(underlyingCollateral, uint256(-1));\r\n\r\n        vars.collateralAfter = vars.isCollateralETH\r\n            ? address(this).balance\r\n            : IERC20(underlyingCollateral).balanceOf(address(this));\r\n        vars.delta = vars.collateralAfter - vars.collateralBefore;\r\n\r\n        if (vars.isCollateralETH) {\r\n            // eth\r\n            // path : eth => token, collaterral => borrow\r\n            router.swapExactETHForTokens{value: vars.delta}(\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp + 300\r\n            );\r\n        } else {\r\n            // erc 20\r\n            approveInternal(underlyingCollateral, address(router), uint256(-1));\r\n            if (isBorrowETH) {\r\n                // path : erc20 => eth, collateral => borrow\r\n                router.swapExactTokensForETH(\r\n                    vars.delta,\r\n                    0,\r\n                    path,\r\n                    address(this),\r\n                    block.timestamp + 300\r\n                );\r\n            } else {\r\n                // path : erc20 => erc20, collateral => borrow\r\n                router.swapExactTokensForTokens(\r\n                    vars.delta,\r\n                    0,\r\n                    path,\r\n                    address(this),\r\n                    block.timestamp + 300\r\n                );\r\n            }\r\n        }\r\n\r\n        uint256 repayToAaveAmount = amounts[0].add(premiums[0]);\r\n        if (isBorrowETH) {\r\n            weth.deposit{value: repayToAaveAmount}();\r\n        }\r\n\r\n        // At the end of your logic above, this contract owes\r\n        // the flashloaned amounts + premiums.\r\n        // Therefore ensure your contract has enough to repay\r\n        // these amounts.\r\n\r\n        // Approve the LendingPool contract allowance to *pull* the owed amount\r\n        // for (uint256 i = 0; i < assets.length; i++) {\r\n        // uint256 amountOwing = amounts[0].add(premiums[0]);\r\n        // IERC20(assets[i]).approve(address(_lendingPool), amountOwing);\r\n        approveInternal(assets[0], address(_lendingPool), repayToAaveAmount);\r\n        // }\r\n\r\n        // if (address(this).balance > 0) {\r\n        //     msg.sender.transfer(address(this).balance.sub(repayToAaveAmount));\r\n        // } else {\r\n        //     IERC20(underlyingBorrow).transfer(\r\n        //         msg.sender,\r\n        //         IERC20(underlyingBorrow).balanceOf(address(this))\r\n        //     );\r\n        // }\r\n\r\n        return true;\r\n    }\r\n\r\n    // if we borrow eth from aave, it's weth, not eth\r\n    // _path is from collateral to borrow\r\n    function myFlashLoanCall(\r\n        address _borrower,\r\n        address _underlyingBorrow,\r\n        address _underlyingCollateral,\r\n        uint256 _repayAmount,\r\n        address[] memory _path,\r\n        uint256 chiAmount\r\n    ) public payable onlyAdmin discountCHI(chiAmount) {\r\n        borrower = _borrower;\r\n        underlyingBorrow = _underlyingBorrow;\r\n        underlyingCollateral = _underlyingCollateral;\r\n        repayAmount = _repayAmount;\r\n        path = _path;\r\n\r\n        (, uint256 shortfall) = bankController.getAccountLiquidity(_borrower);\r\n        require(shortfall != 0, \"Insufficient shortfall\");\r\n\r\n        address receiverAddress = address(this);\r\n\r\n        bool isBorrowETH = underlyingBorrow ==\r\n            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n        address[] memory assets = new address[](1);\r\n        assets[0] = isBorrowETH ? address(weth) : _underlyingBorrow;\r\n\r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = _repayAmount;\r\n\r\n        // 0 = no debt, 1 = stable, 2 = variable\r\n        uint256[] memory modes = new uint256[](1);\r\n        modes[0] = 0;\r\n\r\n        address onBehalfOf = address(this);\r\n        bytes memory params = \"\";\r\n        uint16 referralCode = 0;\r\n\r\n        _lendingPool.flashLoan(\r\n            receiverAddress,\r\n            assets,\r\n            amounts,\r\n            modes,\r\n            onBehalfOf,\r\n            params,\r\n            referralCode\r\n        );\r\n    }\r\n\r\n    function approveInternal(\r\n        address token,\r\n        address target,\r\n        uint256 amount\r\n    ) internal {\r\n        IERC20(token).approve(target, 0);\r\n        IERC20(token).approve(target, amount);\r\n    }\r\n\r\n    function approve(\r\n        address token,\r\n        address target,\r\n        uint256 amount\r\n    ) public onlyAdmin {\r\n        approveInternal(token, target, amount);\r\n    }\r\n\r\n    function withdrawERC20(address token) public onlyAdmin {\r\n        IERC20(token).transfer(admin, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function withdrawETH() public onlyAdmin {\r\n        payable(admin).transfer(address(this).balance);\r\n    }\r\n\r\n    function setRouter(address _router) public onlyAdmin {\r\n        router = IUniswapRouter(_router);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"_addressProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"internalType\":\"contract IBank\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bankController\",\"outputs\":[{\"internalType\":\"contract IBankController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrower\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"premiums\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlyingBorrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlyingCollateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"chiAmount\",\"type\":\"uint256\"}],\"name\":\"myFlashLoanCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"path\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repayAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingBorrow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingCollateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWeth\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MyAaveFlashLoan","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b53c1a33016b2dc2ff3653530bff1848a515c8c5","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7ba307837556512242e53b5f23295c4bac1c40e3d9feac4b79ec4b5864f527af"}]}