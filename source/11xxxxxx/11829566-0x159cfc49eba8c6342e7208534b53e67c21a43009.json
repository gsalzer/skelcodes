{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/deposits/DfFinanceDeposits.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"../access/FundsManager.sol\\\";\\nimport \\\"../access/Adminable.sol\\\";\\n\\nimport \\\"../constants/ConstantAddressesMainnet.sol\\\";\\n\\nimport \\\"../utils/DSMath.sol\\\";\\nimport \\\"../utils/SafeMath.sol\\\";\\n\\nimport \\\"../flashloan/base/FlashLoanReceiverBase.sol\\\";\\nimport \\\"../dydxFlashloan/FlashloanDyDx.sol\\\";\\n\\n// **INTERFACES**\\nimport \\\"../compound/interfaces/ICToken.sol\\\";\\nimport \\\"../flashloan/interfaces/ILendingPool.sol\\\";\\nimport \\\"../interfaces/IDfWalletFactory.sol\\\";\\nimport \\\"../interfaces/IDfWallet.sol\\\";\\nimport \\\"../interfaces/IToken.sol\\\";\\nimport \\\"../interfaces/IComptrollerLensInterface.sol\\\";\\nimport \\\"../interfaces/IComptroller.sol\\\";\\nimport \\\"../interfaces/IWeth.sol\\\";\\nimport \\\"../interfaces/IDfProxy.sol\\\";\\n\\n\\ncontract DfFinanceDeposits is\\n    Initializable,\\n    DSMath,\\n    ConstantAddresses,\\n    FundsManager,\\n    Adminable,\\n    FlashLoanReceiverBase,\\n    FlashloanDyDx\\n{\\n    using UniversalERC20 for IToken;\\n    using SafeMath for uint256;\\n\\n\\n    // ** STRUCTS **\\n\\n    struct FeeScheme {\\n        address[] partners;\\n        uint32[] percents;\\n        uint32 fee;\\n        bool isEnabled;\\n    }\\n\\n    struct UserData {\\n        address owner;\\n        uint256 deposit; // in dai\\n        uint64 compClaimed;\\n        uint64 compClaimedinUSD; // 6 decimals\\n        uint64 activeFeeScheme; // 0 - fee scheme is disabled\\n        uint64 depositUSDC;\\n        // next pack\\n        uint96 depositETH;\\n        uint64 depositWBTC;\\n        uint96 gap;\\n    }\\n\\n    struct FlashloanData {\\n        address dfWallet;\\n        address token;\\n        address cToken;\\n        uint256 deposit;\\n        uint256 amountFlashLoan;\\n    }\\n\\n    struct FlashloanDataDyDxEth {\\n        address dfWallet;\\n        address token;\\n        address cToken;\\n        uint256 deposit;\\n        uint256 debt;\\n        uint256 ethAmountFlashLoan;\\n    }\\n\\n    // ** ENUMS **\\n\\n    enum OP {\\n        UNKNOWN,\\n        DEPOSIT,\\n        WITHDRAW,\\n        DEPOSIT_USING_DYDX_ETH,\\n        WITHDRAW_USING_DYDX_ETH\\n    }\\n\\n    enum FlashloanProvider {\\n        DYDX,\\n        AAVE,\\n        ADDRESS\\n    }\\n\\n\\n    // ** PUBLIC STATES **\\n\\n    IDfWalletFactory public dfWalletFactory;\\n\\n    uint256 private DELETED_fee; // DELETED state\\n\\n    mapping(address => UserData) public wallets;\\n\\n\\n    // ** PRIVATE STATES **\\n\\n    // partner => token => balance\\n    mapping(address => mapping(address => uint256)) private DELETED_partnerBalances;    // DELETED state\\n\\n    FeeScheme[] private DELETED_feeSchemes; // DELETED state\\n\\n    OP private state;\\n\\n\\n    // ** ADDED STATES **\\n\\n    // withdraw min ratio from cToken to Token conversion\\n    uint256 public withdrawMinRatio;\\n\\n\\n    // ** EVENTS **\\n\\n    event DfOpenDeposit(address indexed dfWallet, uint256 amount);\\n    event DfAddDeposit(address indexed dfWallet, uint256 amount);\\n    event DfCloseDeposit(address indexed dfWallet, uint256 amount, address token);\\n    event DfPartiallyCloseDeposit(\\n        address indexed dfWallet, address indexed tokenReceiver, uint256 amountDAI, uint256 tokensSent,  uint256 deposit\\n    );\\n\\n\\n    // ** INITIALIZER – Constructor for Upgradable contracts **\\n\\n    function initialize() public initializer {\\n        Adminable.initialize();  // Initialize Parent Contract\\n        // FundsManager.initialize();  // Init in Adminable\\n\\n        withdrawMinRatio = 0.995 * 1e18;\\n\\n        // dfWalletFactory = IDfWalletFactory(0);\\n    }\\n\\n\\n    // ** ONLY_OWNER functions **\\n\\n    function setDfWalletFactory(address _dfWalletFactory) public onlyOwner {\\n        require(_dfWalletFactory != address(0));\\n        dfWalletFactory = IDfWalletFactory(_dfWalletFactory);\\n    }\\n\\n    function setWithdrawMinRatio(uint256 _withdrawMinRatio) public onlyOwner {\\n        require(_withdrawMinRatio >= 0.9 * 1e18 && _withdrawMinRatio <= 1e18);\\n        withdrawMinRatio = _withdrawMinRatio;\\n    }\\n\\n\\n    // ** PUBLIC functions **\\n\\n    function getCompBalanceMetadataExt(address account) external returns (uint256 balance, uint256 allocated) {\\n        IComptrollerLensInterface comptroller = IComptrollerLensInterface(COMPTROLLER);\\n        balance = IToken(COMP_ADDRESS).balanceOf(account);\\n        comptroller.claimComp(account);\\n        uint256 newBalance = IToken(COMP_ADDRESS).balanceOf(account);\\n        uint256 accrued = comptroller.compAccrued(account);\\n        uint256 total = add(accrued, newBalance);\\n        allocated = sub(total, balance);\\n    }\\n\\n\\n    // DEPOSIT function\\n\\n    function deposit(\\n        address dfWallet,\\n        uint256 amountDAI,\\n        uint256 amountUSDC,\\n        uint256 amountWBTC,\\n        uint256 flashloanDAI,\\n        uint256 flashloanUSDC,\\n        FlashloanProvider flashloanType,\\n        address flashloanFromAddress\\n    ) public payable onlyOwnerOrAdmin returns (address) {\\n        if (dfWallet == address(0)) {\\n            dfWallet = dfWalletFactory.createDfWallet();\\n            wallets[dfWallet] = UserData(msg.sender, 0, 0, 0, 0, 0, 0, 0, 0);\\n        }\\n\\n        require(wallets[dfWallet].owner == msg.sender);\\n\\n        uint amountETH = msg.value;\\n\\n        // Update states\\n        wallets[dfWallet].deposit = add(wallets[dfWallet].deposit, amountDAI);\\n        wallets[dfWallet].depositUSDC = uint64(add(wallets[dfWallet].depositUSDC, amountUSDC));\\n        wallets[dfWallet].depositETH = uint96(add(wallets[dfWallet].depositETH, amountETH));\\n        wallets[dfWallet].depositWBTC = uint64(add(wallets[dfWallet].depositWBTC, amountWBTC));\\n\\n        // Deposit ETH without boosting\\n        if (amountETH > 0) {\\n            IDfWallet(dfWallet).deposit.value(amountETH)(ETH_ADDRESS, CETH_ADDRESS, amountETH, address(0), address(0), 0);\\n        }\\n\\n        // Deposit WBTC without boosting\\n        if (amountWBTC > 0) {\\n            IDfWallet(dfWallet).deposit(WBTC_ADDRESS, CWBTC_ADDRESS, amountWBTC, address(0), address(0), 0);\\n        }\\n\\n        // Boost USDC deposit\\n        if (amountUSDC > 0 || flashloanUSDC > 0) {\\n            if (flashloanType == FlashloanProvider.DYDX\\n                && flashloanUSDC > IToken(USDC_ADDRESS).balanceOf(SOLO_MARGIN_ADDRESS)\\n            ) {\\n                // if dYdX lacks liquidity in USDC use ETH\\n                _depositBoostUsingDyDxEth(\\n                    dfWallet, USDC_ADDRESS, CUSDC_ADDRESS, amountUSDC, flashloanUSDC\\n                );\\n            } else {\\n                _depositBoost(\\n                    dfWallet, USDC_ADDRESS, CUSDC_ADDRESS, amountUSDC, flashloanUSDC, flashloanType, flashloanFromAddress\\n                );\\n            }\\n        }\\n\\n        // Boost DAI deposit\\n        if (amountDAI > 0 || flashloanDAI > 0) {\\n            if (flashloanType == FlashloanProvider.DYDX\\n                && flashloanDAI > IToken(DAI_ADDRESS).balanceOf(SOLO_MARGIN_ADDRESS)\\n            ) {\\n                // if dYdX lacks liquidity in DAI use ETH\\n                _depositBoostUsingDyDxEth(\\n                    dfWallet, DAI_ADDRESS, CDAI_ADDRESS, amountDAI, flashloanDAI\\n                );\\n            } else {\\n                _depositBoost(\\n                    dfWallet, DAI_ADDRESS, CDAI_ADDRESS, amountDAI, flashloanDAI, flashloanType, flashloanFromAddress\\n                );\\n            }\\n        }\\n\\n        return dfWallet;\\n    }\\n\\n\\n    // CLAIM function\\n\\n    function claimComps(address dfWallet, address[] memory cTokens) public returns(uint256) {\\n        require(wallets[dfWallet].owner == msg.sender);\\n\\n        IDfWallet(dfWallet).claimComp(cTokens);\\n\\n        uint compTokenBalance = IToken(COMP_ADDRESS).balanceOf(address(this));\\n        IToken(COMP_ADDRESS).transfer(msg.sender, compTokenBalance);\\n\\n        wallets[dfWallet].compClaimed += uint64(compTokenBalance / 1e12); // 6 decemals\\n        return compTokenBalance;\\n    }\\n\\n\\n    // WITHDRAW function\\n\\n    function withdraw(\\n        address dfWallet,\\n        uint256 amountDAI,\\n        uint256 amountUSDC,\\n        uint256 amountETH,\\n        uint256 amountWBTC,\\n        address receiver,\\n        uint256 flashloanDAI,\\n        uint256 flashloanUSDC,\\n        FlashloanProvider flashloanType,\\n        address flashloanFromAddress\\n    ) public onlyOwnerOrAdmin {\\n        require(wallets[dfWallet].owner == msg.sender);\\n        require(receiver != address(0));\\n\\n        // Update states\\n        wallets[dfWallet].deposit     = (amountDAI < wallets[dfWallet].deposit) ? sub(wallets[dfWallet].deposit, amountDAI) : 0;\\n        wallets[dfWallet].depositUSDC = (amountUSDC < wallets[dfWallet].depositUSDC) ? uint64(sub(wallets[dfWallet].depositUSDC, amountUSDC)) : 0;\\n        wallets[dfWallet].depositETH  = (amountETH < wallets[dfWallet].depositETH) ? uint96(sub(wallets[dfWallet].depositETH, amountETH)) : 0;\\n        wallets[dfWallet].depositWBTC = (amountWBTC < wallets[dfWallet].depositWBTC) ? uint64(sub(wallets[dfWallet].depositWBTC, amountWBTC)) : 0;\\n\\n        // Withdraw assets\\n        _withdrawBoostedAsset(\\n            dfWallet, USDC_ADDRESS, CUSDC_ADDRESS, amountUSDC, receiver, flashloanUSDC, flashloanType, flashloanFromAddress\\n        );\\n\\n        _withdrawBoostedAsset(\\n            dfWallet, DAI_ADDRESS, CDAI_ADDRESS, amountDAI, receiver, flashloanDAI, flashloanType, flashloanFromAddress\\n        );\\n\\n        _withdrawAsset(\\n            dfWallet, ETH_ADDRESS, CETH_ADDRESS, amountETH, receiver\\n        );\\n\\n        _withdrawAsset(\\n            dfWallet, WBTC_ADDRESS, CWBTC_ADDRESS, amountWBTC, receiver\\n        );\\n    }\\n\\n\\n    // ** FLASHLOAN CALLBACK functions **\\n\\n    // Aave flashloan callback\\n    function executeOperation(\\n        address _reserve,\\n        uint256 _amountFlashLoan,\\n        uint256 _fee,\\n        bytes memory _data\\n    ) public {\\n        _flashloanHandler(_data, _fee);\\n\\n        // Time to transfer the funds back\\n        transferFundsBackToPoolInternal(_reserve, add(_amountFlashLoan, _fee));\\n    }\\n\\n    // dYdX flashloan callback\\n    function callFunction(\\n        address sender,\\n        Account.Info memory account,\\n        bytes memory data\\n    ) public {\\n        _flashloanHandler(data, 0);\\n    }\\n\\n\\n    // ** PRIVATE & INTERNAL functions **\\n\\n    function _bytesToAddress(bytes memory bys) private pure returns (address addr) {\\n        assembly {\\n            addr := mload(add(bys,20))\\n        }\\n    }\\n\\n    function _depositBoost(\\n        address dfWallet,\\n        address token,\\n        address cToken,\\n        uint256 deposit,\\n        uint256 flashloanAmount,\\n        FlashloanProvider flashloanType,\\n        address flashloanFromAddress\\n    ) internal {\\n        // FLASHLOAN LOGIC\\n        state = OP.DEPOSIT;\\n\\n        if (flashloanType == FlashloanProvider.DYDX) {\\n            _initFlashloanDyDx(\\n                token,\\n                flashloanAmount,\\n                // Encode FlashloanData for callFunction\\n                abi.encode(FlashloanData({dfWallet: dfWallet, token: token, cToken: cToken, deposit: deposit, amountFlashLoan: flashloanAmount}))\\n            );\\n        } else if (flashloanType == FlashloanProvider.AAVE) {\\n            ILendingPool lendingPool = ILendingPool(ILendingPoolAddressesProvider(AAVE_ADDRESSES_PROVIDER).getLendingPool());\\n            lendingPool.flashLoan(\\n                address(this),\\n                token,\\n                flashloanAmount,\\n                // Encode FlashloanData for executeOperation\\n                abi.encode(FlashloanData({dfWallet: dfWallet, token: token, cToken: cToken, deposit: deposit, amountFlashLoan: flashloanAmount}))\\n            );\\n        } else if (flashloanType == FlashloanProvider.ADDRESS) {\\n            IToken(token).universalTransferFrom(flashloanFromAddress, dfWallet, flashloanAmount);\\n\\n            IDfWallet(dfWallet).deposit(token, cToken, add(deposit, flashloanAmount), token, cToken, flashloanAmount);\\n            IDfWallet(dfWallet).withdrawToken(token, flashloanFromAddress, flashloanAmount);\\n        }\\n\\n        state = OP.UNKNOWN;\\n        // END FLASHLOAN LOGIC\\n    }\\n\\n    function _depositBoostUsingDyDxEth(\\n        address dfWallet,\\n        address token,\\n        address cToken,\\n        uint256 deposit,\\n        uint256 flashloanInTokens\\n    ) internal {\\n        // FLASHLOAN LOGIC\\n        state = OP.DEPOSIT_USING_DYDX_ETH;\\n\\n        IPriceOracle compOracle = IComptroller(COMPTROLLER).oracle();\\n        uint256 ethPrice = compOracle.price(\\\"ETH\\\").mul(1e12); // with 1e18 (1e6 * 1e12)\\n\\n        uint256 ethDecimals = 18;\\n        uint256 decimalsMultiplier = 10 ** ethDecimals.sub(IToken(token).decimals());\\n\\n        // IMPORTANT: token price is equal to 1 USD\\n        uint256 flashloanEthAmount = wdiv(flashloanInTokens * decimalsMultiplier, ethPrice).mul(2); // use x2 coef for eth as collateral\\n\\n        _initFlashloanDyDx(\\n            WETH_ADDRESS,\\n            flashloanEthAmount,\\n            // Encode FlashloanDataDyDxEth for callFunction\\n            abi.encode(FlashloanDataDyDxEth({\\n                dfWallet: dfWallet, token: token, cToken: cToken, deposit: deposit, debt: flashloanInTokens, ethAmountFlashLoan: flashloanEthAmount\\n            }))\\n        );\\n\\n        state = OP.UNKNOWN;\\n        // END FLASHLOAN LOGIC\\n    }\\n\\n    function _withdrawBoostedAsset(\\n        address dfWallet,\\n        address token,\\n        address cToken,\\n        uint256 amountToken,\\n        address receiver,\\n        uint256 flashloanAmount,\\n        FlashloanProvider flashloanType,\\n        address flashloanFromAddress\\n    ) internal {\\n        if (amountToken == 0 && flashloanAmount == 0) {\\n            return;\\n        }\\n\\n        if (IToken(token).allowance(address(this), dfWallet) != uint(-1)) {\\n            IToken(token).approve(dfWallet, uint(-1));\\n        }\\n\\n        uint startBalance = IToken(token).universalBalanceOf(address(this));\\n\\n        if (flashloanType == FlashloanProvider.DYDX\\n            && flashloanAmount > IToken(token).balanceOf(SOLO_MARGIN_ADDRESS)\\n        ) {\\n            // if dYdX lacks liquidity in token (DAI or USDC) use ETH\\n            _withdrawBoostUsingDyDxEth(\\n                dfWallet, token, cToken, amountToken, flashloanAmount\\n            );\\n        } else {\\n            _withdrawBoost(\\n                dfWallet, token, cToken, amountToken, flashloanAmount, flashloanType, flashloanFromAddress\\n            );\\n        }\\n\\n        uint curBalance = IToken(token).universalBalanceOf(address(this));\\n\\n        // rounding in token to cToken conversion\\n        if (curBalance <= startBalance) {\\n            require(wdiv(curBalance, startBalance) >= withdrawMinRatio);\\n            return;\\n        }\\n\\n        uint tokensToUser = sub(curBalance, startBalance);\\n        if (token == ETH_ADDRESS) {\\n            _transferEth(receiver, tokensToUser);\\n        } else {\\n            IToken(token).universalTransfer(receiver, tokensToUser);\\n        }\\n    }\\n\\n    function _withdrawAsset(\\n        address dfWallet,\\n        address token,\\n        address cToken,\\n        uint256 amountToken,\\n        address receiver\\n    ) internal {\\n        if (amountToken == 0) {\\n            return;\\n        }\\n\\n        uint startBalance = IToken(token).universalBalanceOf(address(this));\\n\\n        // Compound Quick Maths – redeemAmountIn * 1e18 * 1e18 / exchangeRateCurrent / 1e18\\n        uint cTokenToExtract =  (amountToken != uint(-1)) ? amountToken.mul(1e36).div(ICToken(cToken).exchangeRateCurrent()).div(1e18) : uint(-1);\\n        IDfWallet(dfWallet).withdraw(token, cToken, cTokenToExtract, ETH_ADDRESS, CETH_ADDRESS, 0);\\n\\n        uint tokensToUser = sub(IToken(token).universalBalanceOf(address(this)), startBalance);\\n        if (token == ETH_ADDRESS) {\\n            _transferEth(receiver, tokensToUser);\\n        } else {\\n            IToken(token).universalTransfer(receiver, tokensToUser);\\n        }\\n    }\\n\\n    function _withdrawBoost(\\n        address dfWallet,\\n        address token,\\n        address cToken,\\n        uint256 deposit,\\n        uint256 flashloanAmount,\\n        FlashloanProvider flashloanType,\\n        address flashloanFromAddress\\n    ) internal {\\n        // FLASHLOAN LOGIC\\n        state = OP.WITHDRAW;\\n\\n        if (flashloanType == FlashloanProvider.DYDX) {\\n            _initFlashloanDyDx(\\n                token,\\n                flashloanAmount,\\n                // Encode FlashloanData for callFunction\\n                abi.encode(FlashloanData({dfWallet: dfWallet, token: token, cToken: cToken, deposit: deposit, amountFlashLoan: flashloanAmount}))\\n            );\\n        } else if (flashloanType == FlashloanProvider.AAVE) {\\n            ILendingPool lendingPool = ILendingPool(ILendingPoolAddressesProvider(AAVE_ADDRESSES_PROVIDER).getLendingPool());\\n            lendingPool.flashLoan(\\n                address(this),\\n                token,\\n                flashloanAmount,\\n                // Encode FlashloanData for executeOperation\\n                abi.encode(FlashloanData({dfWallet: dfWallet, token: token, cToken: cToken, deposit: deposit, amountFlashLoan: flashloanAmount}))\\n            );\\n        } else if (flashloanType == FlashloanProvider.ADDRESS) {\\n            IToken(token).universalTransferFrom(flashloanFromAddress, dfWallet, flashloanAmount);\\n\\n            // Compound Quick Maths – redeemAmountIn * 1e18 * 1e18 / exchangeRateCurrent / 1e18\\n            uint cTokenToExtract = (deposit != uint(-1)) ? deposit.add(flashloanAmount).mul(1e36).div(ICToken(cToken).exchangeRateCurrent()).div(1e18) : uint(-1);\\n            IDfWallet(dfWallet).withdraw(token, cToken, cTokenToExtract, token, cToken, flashloanAmount);\\n\\n            IToken(token).universalTransfer(flashloanFromAddress, flashloanAmount);\\n        }\\n\\n        state = OP.UNKNOWN;\\n        // END FLASHLOAN LOGIC\\n    }\\n\\n    function _withdrawBoostUsingDyDxEth(\\n        address dfWallet,\\n        address token,\\n        address cToken,\\n        uint256 deposit,\\n        uint256 flashloanInTokens\\n    ) internal {\\n        // FLASHLOAN LOGIC\\n        state = OP.WITHDRAW_USING_DYDX_ETH;\\n\\n        IPriceOracle compOracle = IComptroller(COMPTROLLER).oracle();\\n        uint256 ethPrice = compOracle.price(\\\"ETH\\\").mul(1e12); // with 1e18 (1e6 * 1e12)\\n\\n        uint256 ethDecimals = 18;\\n        uint256 decimalsMultiplier = 10 ** ethDecimals.sub(IToken(token).decimals());\\n\\n        // IMPORTANT: token price is equal to 1 USD\\n        uint256 flashloanEthAmount = wdiv(flashloanInTokens * decimalsMultiplier, ethPrice).mul(2); // use x2 coef for eth as collateral\\n\\n        _initFlashloanDyDx(\\n            WETH_ADDRESS,\\n            flashloanEthAmount,\\n            // Encode FlashloanDataDyDxEth for callFunction\\n            abi.encode(FlashloanDataDyDxEth({\\n                dfWallet: dfWallet, token: token, cToken: cToken, deposit: deposit, debt: flashloanInTokens, ethAmountFlashLoan: flashloanEthAmount\\n            }))\\n        );\\n\\n        state = OP.UNKNOWN;\\n        // END FLASHLOAN LOGIC\\n    }\\n\\n    function _flashloanHandler(\\n        bytes memory data,\\n        uint fee\\n    ) internal {\\n        require(state != OP.UNKNOWN);\\n\\n        if (state == OP.DEPOSIT) {\\n            FlashloanData memory flashloanData = abi.decode(data, (FlashloanData));\\n\\n            // Calculate repay amount\\n            uint totalDebt = add(flashloanData.amountFlashLoan, fee);\\n\\n            IToken(flashloanData.token).transfer(flashloanData.dfWallet, flashloanData.amountFlashLoan);\\n\\n            IDfWallet(flashloanData.dfWallet).deposit(\\n                flashloanData.token, flashloanData.cToken, add(flashloanData.deposit, flashloanData.amountFlashLoan), flashloanData.token, flashloanData.cToken, totalDebt\\n            );\\n\\n            IDfWallet(flashloanData.dfWallet).withdrawToken(flashloanData.token, address(this), totalDebt);\\n        } else if (state == OP.WITHDRAW) {\\n            FlashloanData memory flashloanData = abi.decode(data, (FlashloanData));\\n\\n            // _withdrawBoost() subtracts flashloan fee\\n            // Compound Quick Maths – redeemAmountIn * 1e18 * 1e18 / exchangeRateCurrent / 1e18\\n            uint cTokenToExtract = (flashloanData.deposit != uint(-1)) ? flashloanData.deposit.add(flashloanData.amountFlashLoan).mul(1e36).div(ICToken(flashloanData.cToken).exchangeRateCurrent()).div(1e18) : uint(-1);\\n\\n            IDfWallet(flashloanData.dfWallet).withdraw(flashloanData.token, flashloanData.cToken, cTokenToExtract, flashloanData.token, flashloanData.cToken, flashloanData.amountFlashLoan);\\n            // require(flashloanData.amountFlashLoan.div(3) >= sub(receivedAmount, _fee), \\\"Fee greater then user amount\\\"); // user pay fee for flash loan\\n        } else if (state == OP.DEPOSIT_USING_DYDX_ETH) {\\n            // use dYdX flashloans without fee\\n            FlashloanDataDyDxEth memory flashloanData = abi.decode(data, (FlashloanDataDyDxEth));\\n            uint256 loanEth = flashloanData.ethAmountFlashLoan;\\n\\n            // WETH to ETH for loan using proxy (eth transfer gas limit)\\n            IDfProxy dfProxy = IDfProxy(DF_PROXY_ADDRESS);\\n            IERC20(WETH_ADDRESS).transfer(address(dfProxy), loanEth);\\n            dfProxy.cast(address(uint160(WETH_ADDRESS)), abi.encodeWithSelector(IWeth(WETH_ADDRESS).withdraw.selector, loanEth));\\n            dfProxy.withdrawEth(address(this));\\n\\n            // deposit eth loan and borrow debt tokens\\n            IDfWallet(flashloanData.dfWallet).deposit.value(loanEth)(\\n                ETH_ADDRESS, CETH_ADDRESS, loanEth, flashloanData.token, flashloanData.cToken, flashloanData.debt\\n            );\\n\\n            // deposit user deposit + debt tokens (are already on the dfWallet)\\n            IDfWallet(flashloanData.dfWallet).deposit(\\n                flashloanData.token, flashloanData.cToken, add(flashloanData.deposit, flashloanData.debt), address(0), address(0), 0\\n            );\\n\\n            // redeem eth loan (using withdraw function)\\n            // Compound Quick Maths – redeemAmountIn * 1e18 * 1e18 / exchangeRateCurrent / 1e18\\n            uint cEthToExtract = loanEth.mul(1e36).div(ICToken(CETH_ADDRESS).exchangeRateCurrent()).div(1e18);\\n            IDfWallet(flashloanData.dfWallet).withdraw(\\n                ETH_ADDRESS, CETH_ADDRESS, cEthToExtract, ETH_ADDRESS, CETH_ADDRESS, 0\\n            );\\n\\n            // ETH to WETH for loan\\n            IWeth(WETH_ADDRESS).deposit.value(loanEth)();\\n        } else if (state == OP.WITHDRAW_USING_DYDX_ETH) {\\n            // use dYdX flashloans without fee\\n            FlashloanDataDyDxEth memory flashloanData = abi.decode(data, (FlashloanDataDyDxEth));\\n            uint256 loanEth = flashloanData.ethAmountFlashLoan;\\n\\n            // WETH to ETH for loan using proxy (eth transfer gas limit)\\n            IDfProxy dfProxy = IDfProxy(DF_PROXY_ADDRESS);\\n            IERC20(WETH_ADDRESS).transfer(address(dfProxy), loanEth);\\n            dfProxy.cast(address(uint160(WETH_ADDRESS)), abi.encodeWithSelector(IWeth(WETH_ADDRESS).withdraw.selector, loanEth));\\n            dfProxy.withdrawEth(address(this));\\n\\n            // deposit eth loan and borrow debt tokens\\n            IDfWallet(flashloanData.dfWallet).deposit.value(loanEth)(\\n                ETH_ADDRESS, CETH_ADDRESS, loanEth, flashloanData.token, flashloanData.cToken, flashloanData.debt\\n            );\\n            IDfWallet(flashloanData.dfWallet).withdrawToken(flashloanData.token, address(this), flashloanData.debt);\\n\\n            // repay debt tokens and redeem deposit + debt tokens\\n            // Compound Quick Maths – redeemAmountIn * 1e18 * 1e18 / exchangeRateCurrent / 1e18\\n            uint cTokenToExtract = (flashloanData.deposit != uint(-1)) ? flashloanData.deposit.add(flashloanData.debt).mul(1e36).div(ICToken(flashloanData.cToken).exchangeRateCurrent()).div(1e18) : uint(-1);\\n            IDfWallet(flashloanData.dfWallet).withdraw(\\n                flashloanData.token, flashloanData.cToken, cTokenToExtract, flashloanData.token, flashloanData.cToken, flashloanData.debt\\n            );\\n\\n            // repay debt tokens and redeem eth loan\\n            // Compound Quick Maths – redeemAmountIn * 1e18 * 1e18 / exchangeRateCurrent / 1e18\\n            uint cEthToExtract = loanEth.mul(1e36).div(ICToken(CETH_ADDRESS).exchangeRateCurrent()).div(1e18);\\n            IDfWallet(flashloanData.dfWallet).withdraw(\\n                ETH_ADDRESS, CETH_ADDRESS, cEthToExtract, flashloanData.token, flashloanData.cToken, flashloanData.debt\\n            );\\n\\n            // ETH to WETH for loan\\n            IWeth(WETH_ADDRESS).deposit.value(loanEth)();\\n        }\\n    }\\n\\n    function _transferEth(address _receiver, uint _amount) internal {\\n        address payable receiverPayable = address(uint160(_receiver));\\n        (bool result, ) = receiverPayable.call.value(_amount)(\\\"\\\");\\n        require(result, \\\"Transfer of ETH failed\\\");\\n    }\\n\\n\\n    // **FALLBACK functions**\\n    function() external payable {}\\n\\n}\"\r\n    },\r\n    \"./contracts/access/FundsManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n// import \\\"../openzeppelin/upgrades/contracts/Initializable.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"../utils/UniversalERC20.sol\\\";\\n\\n\\ncontract FundsManager is Initializable, Ownable {\\n    using UniversalERC20 for IToken;\\n\\n    // Initializer – Constructor for Upgradable contracts\\n    function initialize() public initializer {\\n        Ownable.initialize();  // Initialize Parent Contract\\n    }\\n\\n    function initialize(address payable newOwner) public initializer {\\n        Ownable.initialize(newOwner);  // Initialize Parent Contract\\n    }\\n\\n\\n    function withdraw(address token, uint256 amount) public onlyOwner {\\n        if (token == address(0x0)) {\\n            owner.transfer(amount);\\n        } else {\\n            IToken(token).universalTransfer(owner, amount);\\n        }\\n    }\\n\\n    function withdrawAll(address[] memory tokens) public onlyOwner {\\n        for(uint256 i = 0; i < tokens.length;i++) {\\n            withdraw(tokens[i], IToken(tokens[i]).universalBalanceOf(address(this)));\\n        }\\n    }\\n\\n    uint256[50] private ______gap;\\n}\"\r\n    },\r\n    \"./contracts/access/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n// import \\\"../openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\n\\ncontract Ownable is Initializable {\\n    address payable public owner;\\n    address payable internal newOwnerCandidate;\\n\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Permission denied\\\");\\n        _;\\n    }\\n\\n\\n    // ** INITIALIZERS – Constructors for Upgradable contracts **\\n\\n    function initialize() public initializer {\\n        owner = msg.sender;\\n    }\\n\\n    function initialize(address payable newOwner) public initializer {\\n        owner = newOwner;\\n    }\\n\\n\\n    function changeOwner(address payable newOwner) public onlyOwner {\\n        newOwnerCandidate = newOwner;\\n    }\\n\\n    function acceptOwner() public {\\n        require(msg.sender == newOwnerCandidate, \\\"Permission denied\\\");\\n        owner = newOwnerCandidate;\\n    }\\n\\n\\n    uint256[50] private ______gap;\\n}\"\r\n    },\r\n    \"./contracts/utils/UniversalERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// import \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n// import \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\nimport \\\"../interfaces/IToken.sol\\\";\\n\\nlibrary UniversalERC20 {\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IToken;\\n\\n    IToken private constant ZERO_ADDRESS = IToken(0x0000000000000000000000000000000000000000);\\n    IToken private constant ETH_ADDRESS = IToken(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    function universalTransfer(IToken token, address to, uint256 amount) internal {\\n        universalTransfer(token, to, amount, false);\\n    }\\n\\n    function universalTransfer(IToken token, address to, uint256 amount, bool mayFail) internal returns(bool) {\\n        if (amount == 0) {\\n            return true;\\n        }\\n\\n        if (token == ZERO_ADDRESS || token == ETH_ADDRESS) {\\n            if (mayFail) {\\n                return address(uint160(to)).send(amount);\\n            } else {\\n                address(uint160(to)).transfer(amount);\\n                return true;\\n            }\\n        } else {\\n            token.safeTransfer(to, amount);\\n            return true;\\n        }\\n    }\\n\\n    function universalApprove(IToken token, address to, uint256 amount) internal {\\n        if (token != ZERO_ADDRESS && token != ETH_ADDRESS) {\\n            token.safeApprove(to, amount);\\n        }\\n    }\\n\\n    function universalTransferFrom(IToken token, address from, address to, uint256 amount) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        if (token == ZERO_ADDRESS || token == ETH_ADDRESS) {\\n            require(from == msg.sender && msg.value >= amount, \\\"msg.value is zero\\\");\\n            if (to != address(this)) {\\n                address(uint160(to)).transfer(amount);\\n            }\\n            if (msg.value > amount) {\\n                msg.sender.transfer(uint256(msg.value).sub(amount));\\n            }\\n        } else {\\n            token.safeTransferFrom(from, to, amount);\\n        }\\n    }\\n\\n    function universalBalanceOf(IToken token, address who) internal view returns (uint256) {\\n        if (token == ZERO_ADDRESS || token == ETH_ADDRESS) {\\n            return who.balance;\\n        } else {\\n            return token.balanceOf(who);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"./contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// import \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n// import \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\nimport \\\"../interfaces/IToken.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IToken token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IToken token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IToken token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IToken token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IToken token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IToken token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"./contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract's constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\n     * function returns false is an externally-owned account (EOA) and not a\\n     * contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/interfaces/IToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface IToken {\\n    function decimals() external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function balanceOf(address account) external view returns (uint);\\n    function approve(address spender, uint value) external;\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n    function deposit() external payable;\\n    function mint(address, uint256) external;\\n    function withdraw(uint amount) external;\\n    function totalSupply() view external returns (uint256);\\n    function burnFrom(address account, uint256 amount) external;\\n}\"\r\n    },\r\n    \"./contracts/access/Adminable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n// import \\\"../openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n\\ncontract Adminable is Initializable, Ownable {\\n    mapping(address => bool) public admins;\\n\\n\\n    modifier onlyOwnerOrAdmin {\\n        require(msg.sender == owner ||\\n                admins[msg.sender], \\\"Permission denied\\\");\\n        _;\\n    }\\n\\n\\n    // Initializer – Constructor for Upgradable contracts\\n    function initialize() public initializer {\\n        Ownable.initialize();  // Initialize Parent Contract\\n    }\\n\\n    function initialize(address payable newOwner) public initializer {\\n        Ownable.initialize(newOwner);  // Initialize Parent Contract\\n    }\\n\\n\\n    function setAdminPermission(address _admin, bool _status) public onlyOwner {\\n        admins[_admin] = _status;\\n    }\\n\\n//    function setAdminPermission(address[] memory _admins, bool _status) public onlyOwner {\\n//        for (uint i = 0; i < _admins.length; i++) {\\n//            admins[_admins[i]] = _status;\\n//        }\\n//    }\\n\\n\\n    uint256[50] private ______gap;\\n}\"\r\n    },\r\n    \"./contracts/constants/ConstantAddressesMainnet.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n\\ncontract ConstantAddresses {\\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\n//    address public constant COMPOUND_ORACLE = 0x1D8aEdc9E924730DD3f9641CDb4D1B92B848b4bd;\\n\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\\n\\n    address public constant USDC_ADDRESS = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address public constant CUSDC_ADDRESS = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\\n\\n    address public constant WBTC_ADDRESS = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n    address public constant CWBTC_ADDRESS = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;\\n\\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address public constant CDAI_ADDRESS = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\\n\\n    address public constant COMP_ADDRESS = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\\n\\n    address public constant USDT_ADDRESS = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n\\n    // proxy for eth transfer (gas limit)\\n    address public constant DF_PROXY_ADDRESS = 0x7a925f91a4583E87b355f6CE15B2C3BF26E3449F;\\n}\"\r\n    },\r\n    \"./contracts/utils/DSMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\ncontract DSMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x);\\n    }\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x);\\n    }\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x);\\n    }\\n\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        return x <= y ? x : y;\\n    }\\n    function max(uint x, uint y) internal pure returns (uint z) {\\n        return x >= y ? x : y;\\n    }\\n//    function imin(int x, int y) internal pure returns (int z) {\\n//        return x <= y ? x : y;\\n//    }\\n//    function imax(int x, int y) internal pure returns (int z) {\\n//        return x >= y ? x : y;\\n//    }\\n\\n    uint constant WAD = 10 ** 18;\\n//    uint constant RAY = 10 ** 27;\\n\\n    function wmul(uint x, uint y, uint base) internal pure returns (uint z) {\\n        z = add(mul(x, y), base / 2) / base;\\n    }\\n\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n//    function rmul(uint x, uint y) internal pure returns (uint z) {\\n//        z = add(mul(x, y), RAY / 2) / RAY;\\n//    }\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n//    function rdiv(uint x, uint y) internal pure returns (uint z) {\\n//        z = add(mul(x, RAY), y / 2) / y;\\n//    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    /*function rpow(uint x, uint n) internal pure returns (uint z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }*/\\n}\"\r\n    },\r\n    \"./contracts/flashloan/base/FlashLoanReceiverBase.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n// import \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../../interfaces/IToken.sol\\\";\\n\\nimport \\\"../interfaces/IFlashLoanReceiver.sol\\\";\\nimport \\\"../interfaces/ILendingPoolAddressesProvider.sol\\\";\\n\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"../../utils/EthAddressLib.sol\\\";\\n\\n\\ncontract FlashLoanReceiverBase is IFlashLoanReceiver {\\n\\n    using SafeERC20 for IToken;\\n\\n\\n    // Mainnet Aave LendingPoolAddressesProvider address\\n     address public constant AAVE_ADDRESSES_PROVIDER = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\\n\\n    // Kovan Aave LendingPoolAddressesProvider addres\\n    // address public constant AAVE_ADDRESSES_PROVIDER = 0x506B0B2CF20FAA8f38a4E2B524EE43e1f4458Cc5;\\n\\n\\n    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount) internal {\\n        address payable core = ILendingPoolAddressesProvider(AAVE_ADDRESSES_PROVIDER).getLendingPoolCore();\\n        transferInternal(core, _reserve, _amount);\\n    }\\n\\n    function transferInternal(address _destination, address _reserve, uint256  _amount) internal {\\n\\n        if(_reserve == EthAddressLib.ethAddress()) {\\n            address payable receiverPayable = address(uint160(_destination));\\n\\n            //solium-disable-next-line\\n            (bool result, ) = receiverPayable.call.value(_amount)(\\\"\\\");\\n\\n            require(result, \\\"Transfer of ETH failed\\\");\\n            return;\\n        }\\n\\n        IToken(_reserve).safeTransfer(_destination, _amount);\\n    }\\n\\n    function getBalanceInternal(address _target, address _reserve) internal view returns(uint256) {\\n        if(_reserve == EthAddressLib.ethAddress()) {\\n            return _target.balance;\\n        }\\n\\n        return IToken(_reserve).balanceOf(_target);\\n    }\\n\\n}\"\r\n    },\r\n    \"./contracts/flashloan/interfaces/IFlashLoanReceiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n/**\\n* @title IFlashLoanReceiver interface\\n* @notice Interface for the Aave fee IFlashLoanReceiver.\\n* @author Aave\\n* @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\\n**/\\ninterface IFlashLoanReceiver {\\n\\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\\n}\\n\"\r\n    },\r\n    \"./contracts/flashloan/interfaces/ILendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n@title ILendingPoolAddressesProvider interface\\n@notice provides the interface to fetch the LendingPoolCore address\\n */\\ninterface ILendingPoolAddressesProvider {\\n\\n    function getLendingPool() external view returns (address);\\n    function setLendingPoolImpl(address _pool) external;\\n\\n    function getLendingPoolCore() external view returns (address payable);\\n    function setLendingPoolCoreImpl(address _lendingPoolCore) external;\\n\\n    function getLendingPoolConfigurator() external view returns (address);\\n    function setLendingPoolConfiguratorImpl(address _configurator) external;\\n\\n    function getLendingPoolDataProvider() external view returns (address);\\n    function setLendingPoolDataProviderImpl(address _provider) external;\\n\\n    function getLendingPoolParametersProvider() external view returns (address);\\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) external;\\n\\n    function getTokenDistributor() external view returns (address);\\n    function setTokenDistributor(address _tokenDistributor) external;\\n\\n\\n    function getFeeProvider() external view returns (address);\\n    function setFeeProviderImpl(address _feeProvider) external;\\n\\n    function getLendingPoolLiquidationManager() external view returns (address);\\n    function setLendingPoolLiquidationManager(address _manager) external;\\n\\n    function getLendingPoolManager() external view returns (address);\\n    function setLendingPoolManager(address _lendingPoolManager) external;\\n\\n    function getPriceOracle() external view returns (address);\\n    function setPriceOracle(address _priceOracle) external;\\n\\n    function getLendingRateOracle() external view returns (address);\\n    function setLendingRateOracle(address _lendingRateOracle) external;\\n\\n}\"\r\n    },\r\n    \"./contracts/utils/EthAddressLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\nlibrary EthAddressLib {\\n\\n    /**\\n    * @dev returns the address used within the protocol to identify ETH\\n    * @return the address assigned to ETH\\n     */\\n    function ethAddress() internal pure returns(address) {\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    }\\n}\"\r\n    },\r\n    \"./contracts/dydxFlashloan/FlashloanDyDx.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./helpers/DydxFlashloanBase.sol\\\";\\nimport \\\"./helpers/ICallee.sol\\\";\\n\\n\\ncontract FlashloanDyDx is\\n    ICallee,\\n    DydxFlashloanBase\\n{\\n\\n    address public constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\\n\\n    function _initFlashloanDyDx(\\n        address _token,\\n        uint256 _amount,\\n        bytes memory _data  // data to callFunction()\\n    ) internal {\\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\\n\\n        // Get marketId from token address\\n        uint256 marketId = _getMarketIdFromTokenAddress(address(solo), _token);\\n\\n        // Calculate repay amount (_amount + (2 wei))\\n        // Approve transfer from\\n        uint256 repayAmount = _getRepaymentAmountInternal(_amount);\\n        IERC20(_token).approve(address(solo), repayAmount);\\n\\n        // 1. Withdraw tokens\\n        // 2. Call callFunction()\\n        // 3. Deposit back tokens\\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\\n\\n        operations[0] = _getWithdrawAction(marketId, _amount);\\n        operations[1] = _getCallAction(_data);\\n        operations[2] = _getDepositAction(marketId, repayAmount);\\n\\n        Account.Info[] memory accountInfos = new Account.Info[](1);\\n        accountInfos[0] = _getAccountInfo();\\n\\n        solo.operate(accountInfos, operations);\\n    }\\n}\"\r\n    },\r\n    \"./contracts/dydxFlashloan/helpers/DydxFlashloanBase.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../utils/SafeMath.sol\\\";\\nimport \\\"../../interfaces/IERC20.sol\\\";\\n\\nimport \\\"./ISoloMargin.sol\\\";\\n\\n\\ncontract DydxFlashloanBase {\\n    using SafeMath for uint256;\\n\\n    // -- Internal Helper functions -- //\\n\\n    function _getMarketIdFromTokenAddress(address _solo, address token)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        ISoloMargin solo = ISoloMargin(_solo);\\n\\n        uint256 numMarkets = solo.getNumMarkets();\\n\\n        address curToken;\\n        for (uint256 i = 0; i < numMarkets; i++) {\\n            curToken = solo.getMarketTokenAddress(i);\\n\\n            if (curToken == token) {\\n                return i;\\n            }\\n        }\\n\\n        revert(\\\"No marketId found for provided token\\\");\\n    }\\n\\n    function _getRepaymentAmountInternal(uint256 amount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // Needs to be overcollateralize\\n        // Needs to provide +2 wei to be safe\\n        return amount.add(2);\\n    }\\n\\n    function _getAccountInfo() internal view returns (Account.Info memory) {\\n        return Account.Info({owner: address(this), number: 1});\\n    }\\n\\n    function _getWithdrawAction(uint marketId, uint256 amount)\\n        internal\\n        view\\n        returns (Actions.ActionArgs memory)\\n    {\\n        return\\n            Actions.ActionArgs({\\n                actionType: Actions.ActionType.Withdraw,\\n                accountId: 0,\\n                amount: Types.AssetAmount({\\n                    sign: false,\\n                    denomination: Types.AssetDenomination.Wei,\\n                    ref: Types.AssetReference.Delta,\\n                    value: amount\\n                }),\\n                primaryMarketId: marketId,\\n                secondaryMarketId: 0,\\n                otherAddress: address(this),\\n                otherAccountId: 0,\\n                data: \\\"\\\"\\n            });\\n    }\\n\\n    function _getCallAction(bytes memory data)\\n        internal\\n        view\\n        returns (Actions.ActionArgs memory)\\n    {\\n        return\\n            Actions.ActionArgs({\\n                actionType: Actions.ActionType.Call,\\n                accountId: 0,\\n                amount: Types.AssetAmount({\\n                    sign: false,\\n                    denomination: Types.AssetDenomination.Wei,\\n                    ref: Types.AssetReference.Delta,\\n                    value: 0\\n                }),\\n                primaryMarketId: 0,\\n                secondaryMarketId: 0,\\n                otherAddress: address(this),\\n                otherAccountId: 0,\\n                data: data\\n            });\\n    }\\n\\n    function _getDepositAction(uint marketId, uint256 amount)\\n        internal\\n        view\\n        returns (Actions.ActionArgs memory)\\n    {\\n        return\\n            Actions.ActionArgs({\\n                actionType: Actions.ActionType.Deposit,\\n                accountId: 0,\\n                amount: Types.AssetAmount({\\n                    sign: true,\\n                    denomination: Types.AssetDenomination.Wei,\\n                    ref: Types.AssetReference.Delta,\\n                    value: amount\\n                }),\\n                primaryMarketId: marketId,\\n                secondaryMarketId: 0,\\n                otherAddress: address(this),\\n                otherAccountId: 0,\\n                data: \\\"\\\"\\n            });\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"./contracts/dydxFlashloan/helpers/ISoloMargin.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\npragma experimental ABIEncoderV2;\\n\\n\\nlibrary Account {\\n    enum Status {Normal, Liquid, Vapor}\\n    struct Info {\\n        address owner; // The address that owns the account\\n        uint256 number; // A nonce that allows a single address to control many accounts\\n    }\\n    struct Storage {\\n        mapping(uint256 => Types.Par) balances; // Mapping from marketId to principal\\n        Status status;\\n    }\\n}\\n\\n\\nlibrary Actions {\\n    enum ActionType {\\n        Deposit, // supply tokens\\n        Withdraw, // borrow tokens\\n        Transfer, // transfer balance between accounts\\n        Buy, // buy an amount of some token (publicly)\\n        Sell, // sell an amount of some token (publicly)\\n        Trade, // trade tokens against another account\\n        Liquidate, // liquidate an undercollateralized or expiring account\\n        Vaporize, // use excess tokens to zero-out a completely negative account\\n        Call // send arbitrary data to an address\\n    }\\n\\n    enum AccountLayout {OnePrimary, TwoPrimary, PrimaryAndSecondary}\\n\\n    enum MarketLayout {ZeroMarkets, OneMarket, TwoMarkets}\\n\\n    struct ActionArgs {\\n        ActionType actionType;\\n        uint256 accountId;\\n        Types.AssetAmount amount;\\n        uint256 primaryMarketId;\\n        uint256 secondaryMarketId;\\n        address otherAddress;\\n        uint256 otherAccountId;\\n        bytes data;\\n    }\\n\\n    struct DepositArgs {\\n        Types.AssetAmount amount;\\n        Account.Info account;\\n        uint256 market;\\n        address from;\\n    }\\n\\n    struct WithdrawArgs {\\n        Types.AssetAmount amount;\\n        Account.Info account;\\n        uint256 market;\\n        address to;\\n    }\\n\\n    struct TransferArgs {\\n        Types.AssetAmount amount;\\n        Account.Info accountOne;\\n        Account.Info accountTwo;\\n        uint256 market;\\n    }\\n\\n    struct BuyArgs {\\n        Types.AssetAmount amount;\\n        Account.Info account;\\n        uint256 makerMarket;\\n        uint256 takerMarket;\\n        address exchangeWrapper;\\n        bytes orderData;\\n    }\\n\\n    struct SellArgs {\\n        Types.AssetAmount amount;\\n        Account.Info account;\\n        uint256 takerMarket;\\n        uint256 makerMarket;\\n        address exchangeWrapper;\\n        bytes orderData;\\n    }\\n\\n    struct TradeArgs {\\n        Types.AssetAmount amount;\\n        Account.Info takerAccount;\\n        Account.Info makerAccount;\\n        uint256 inputMarket;\\n        uint256 outputMarket;\\n        address autoTrader;\\n        bytes tradeData;\\n    }\\n\\n    struct LiquidateArgs {\\n        Types.AssetAmount amount;\\n        Account.Info solidAccount;\\n        Account.Info liquidAccount;\\n        uint256 owedMarket;\\n        uint256 heldMarket;\\n    }\\n\\n    struct VaporizeArgs {\\n        Types.AssetAmount amount;\\n        Account.Info solidAccount;\\n        Account.Info vaporAccount;\\n        uint256 owedMarket;\\n        uint256 heldMarket;\\n    }\\n\\n    struct CallArgs {\\n        Account.Info account;\\n        address callee;\\n        bytes data;\\n    }\\n}\\n\\n\\nlibrary Decimal {\\n    struct D256 {\\n        uint256 value;\\n    }\\n}\\n\\n\\nlibrary Interest {\\n    struct Rate {\\n        uint256 value;\\n    }\\n\\n    struct Index {\\n        uint96 borrow;\\n        uint96 supply;\\n        uint32 lastUpdate;\\n    }\\n}\\n\\n\\nlibrary Monetary {\\n    struct Price {\\n        uint256 value;\\n    }\\n    struct Value {\\n        uint256 value;\\n    }\\n}\\n\\n\\nlibrary Storage {\\n    // All information necessary for tracking a market\\n    struct Market {\\n        // Contract address of the associated ERC20 token\\n        address token;\\n        // Total aggregated supply and borrow amount of the entire market\\n        Types.TotalPar totalPar;\\n        // Interest index of the market\\n        Interest.Index index;\\n        // Contract address of the price oracle for this market\\n        address priceOracle;\\n        // Contract address of the interest setter for this market\\n        address interestSetter;\\n        // Multiplier on the marginRatio for this market\\n        Decimal.D256 marginPremium;\\n        // Multiplier on the liquidationSpread for this market\\n        Decimal.D256 spreadPremium;\\n        // Whether additional borrows are allowed for this market\\n        bool isClosing;\\n    }\\n\\n    // The global risk parameters that govern the health and security of the system\\n    struct RiskParams {\\n        // Required ratio of over-collateralization\\n        Decimal.D256 marginRatio;\\n        // Percentage penalty incurred by liquidated accounts\\n        Decimal.D256 liquidationSpread;\\n        // Percentage of the borrower's interest fee that gets passed to the suppliers\\n        Decimal.D256 earningsRate;\\n        // The minimum absolute borrow value of an account\\n        // There must be sufficient incentivize to liquidate undercollateralized accounts\\n        Monetary.Value minBorrowedValue;\\n    }\\n\\n    // The maximum RiskParam values that can be set\\n    struct RiskLimits {\\n        uint64 marginRatioMax;\\n        uint64 liquidationSpreadMax;\\n        uint64 earningsRateMax;\\n        uint64 marginPremiumMax;\\n        uint64 spreadPremiumMax;\\n        uint128 minBorrowedValueMax;\\n    }\\n\\n    // The entire storage state of Solo\\n    struct State {\\n        // number of markets\\n        uint256 numMarkets;\\n        // marketId => Market\\n        mapping(uint256 => Market) markets;\\n        // owner => account number => Account\\n        mapping(address => mapping(uint256 => Account.Storage)) accounts;\\n        // Addresses that can control other users accounts\\n        mapping(address => mapping(address => bool)) operators;\\n        // Addresses that can control all users accounts\\n        mapping(address => bool) globalOperators;\\n        // mutable risk parameters of the system\\n        RiskParams riskParams;\\n        // immutable risk limits of the system\\n        RiskLimits riskLimits;\\n    }\\n}\\n\\n\\nlibrary Types {\\n    enum AssetDenomination {\\n        Wei, // the amount is denominated in wei\\n        Par // the amount is denominated in par\\n    }\\n\\n    enum AssetReference {\\n        Delta, // the amount is given as a delta from the current value\\n        Target // the amount is given as an exact number to end up at\\n    }\\n\\n    struct AssetAmount {\\n        bool sign; // true if positive\\n        AssetDenomination denomination;\\n        AssetReference ref;\\n        uint256 value;\\n    }\\n\\n    struct TotalPar {\\n        uint128 borrow;\\n        uint128 supply;\\n    }\\n\\n    struct Par {\\n        bool sign; // true if positive\\n        uint128 value;\\n    }\\n\\n    struct Wei {\\n        bool sign; // true if positive\\n        uint256 value;\\n    }\\n}\\n\\n\\ncontract ISoloMargin {\\n    struct OperatorArg {\\n        address operator;\\n        bool trusted;\\n    }\\n\\n    function ownerSetSpreadPremium(\\n        uint256 marketId,\\n        Decimal.D256 memory spreadPremium\\n    ) public;\\n\\n    function getIsGlobalOperator(address operator) public view returns (bool);\\n\\n    function getMarketTokenAddress(uint256 marketId)\\n        public\\n        view\\n        returns (address);\\n\\n    function ownerSetInterestSetter(uint256 marketId, address interestSetter)\\n        public;\\n\\n    function getAccountValues(Account.Info memory account)\\n        public\\n        view\\n        returns (Monetary.Value memory, Monetary.Value memory);\\n\\n    function getMarketPriceOracle(uint256 marketId)\\n        public\\n        view\\n        returns (address);\\n\\n    function getMarketInterestSetter(uint256 marketId)\\n        public\\n        view\\n        returns (address);\\n\\n    function getMarketSpreadPremium(uint256 marketId)\\n        public\\n        view\\n        returns (Decimal.D256 memory);\\n\\n    function getNumMarkets() public view returns (uint256);\\n\\n    function ownerWithdrawUnsupportedTokens(address token, address recipient)\\n        public\\n        returns (uint256);\\n\\n    function ownerSetMinBorrowedValue(Monetary.Value memory minBorrowedValue)\\n        public;\\n\\n    function ownerSetLiquidationSpread(Decimal.D256 memory spread) public;\\n\\n    function ownerSetEarningsRate(Decimal.D256 memory earningsRate) public;\\n\\n    function getIsLocalOperator(address owner, address operator)\\n        public\\n        view\\n        returns (bool);\\n\\n    function getAccountPar(Account.Info memory account, uint256 marketId)\\n        public\\n        view\\n        returns (Types.Par memory);\\n\\n    function ownerSetMarginPremium(\\n        uint256 marketId,\\n        Decimal.D256 memory marginPremium\\n    ) public;\\n\\n    function getMarginRatio() public view returns (Decimal.D256 memory);\\n\\n    function getMarketCurrentIndex(uint256 marketId)\\n        public\\n        view\\n        returns (Interest.Index memory);\\n\\n    function getMarketIsClosing(uint256 marketId) public view returns (bool);\\n\\n    function getRiskParams() public view returns (Storage.RiskParams memory);\\n\\n    function getAccountBalances(Account.Info memory account)\\n        public\\n        view\\n        returns (address[] memory, Types.Par[] memory, Types.Wei[] memory);\\n\\n    function renounceOwnership() public;\\n\\n    function getMinBorrowedValue() public view returns (Monetary.Value memory);\\n\\n    function setOperators(OperatorArg[] memory args) public;\\n\\n    function getMarketPrice(uint256 marketId) public view returns (address);\\n\\n    function owner() public view returns (address);\\n\\n    function isOwner() public view returns (bool);\\n\\n    function ownerWithdrawExcessTokens(uint256 marketId, address recipient)\\n        public\\n        returns (uint256);\\n\\n    function ownerAddMarket(\\n        address token,\\n        address priceOracle,\\n        address interestSetter,\\n        Decimal.D256 memory marginPremium,\\n        Decimal.D256 memory spreadPremium\\n    ) public;\\n\\n    function operate(\\n        Account.Info[] memory accounts,\\n        Actions.ActionArgs[] memory actions\\n    ) public;\\n\\n    function getMarketWithInfo(uint256 marketId)\\n        public\\n        view\\n        returns (\\n            Storage.Market memory,\\n            Interest.Index memory,\\n            Monetary.Price memory,\\n            Interest.Rate memory\\n        );\\n\\n    function ownerSetMarginRatio(Decimal.D256 memory ratio) public;\\n\\n    function getLiquidationSpread() public view returns (Decimal.D256 memory);\\n\\n    function getAccountWei(Account.Info memory account, uint256 marketId)\\n        public\\n        view\\n        returns (Types.Wei memory);\\n\\n    function getMarketTotalPar(uint256 marketId)\\n        public\\n        view\\n        returns (Types.TotalPar memory);\\n\\n    function getLiquidationSpreadForPair(\\n        uint256 heldMarketId,\\n        uint256 owedMarketId\\n    ) public view returns (Decimal.D256 memory);\\n\\n    function getNumExcessTokens(uint256 marketId)\\n        public\\n        view\\n        returns (Types.Wei memory);\\n\\n    function getMarketCachedIndex(uint256 marketId)\\n        public\\n        view\\n        returns (Interest.Index memory);\\n\\n    function getAccountStatus(Account.Info memory account)\\n        public\\n        view\\n        returns (uint8);\\n\\n    function getEarningsRate() public view returns (Decimal.D256 memory);\\n\\n    function ownerSetPriceOracle(uint256 marketId, address priceOracle) public;\\n\\n    function getRiskLimits() public view returns (Storage.RiskLimits memory);\\n\\n    function getMarket(uint256 marketId)\\n        public\\n        view\\n        returns (Storage.Market memory);\\n\\n    function ownerSetIsClosing(uint256 marketId, bool isClosing) public;\\n\\n    function ownerSetGlobalOperator(address operator, bool approved) public;\\n\\n    function transferOwnership(address newOwner) public;\\n\\n    function getAdjustedAccountValues(Account.Info memory account)\\n        public\\n        view\\n        returns (Monetary.Value memory, Monetary.Value memory);\\n\\n    function getMarketMarginPremium(uint256 marketId)\\n        public\\n        view\\n        returns (Decimal.D256 memory);\\n\\n    function getMarketInterestRate(uint256 marketId)\\n        public\\n        view\\n        returns (Interest.Rate memory);\\n}\\n\"\r\n    },\r\n    \"./contracts/dydxFlashloan/helpers/ICallee.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.7;\\npragma experimental ABIEncoderV2;\\n\\nimport { Account } from \\\"./ISoloMargin.sol\\\";\\n\\n\\n/**\\n * @title ICallee\\n * @author dYdX\\n *\\n * Interface that Callees for Solo must implement in order to ingest data.\\n */\\ncontract ICallee {\\n\\n    // ============ Public Functions ============\\n\\n    /**\\n     * Allows users to send this contract arbitrary data.\\n     *\\n     * @param  sender       The msg.sender to Solo\\n     * @param  accountInfo  The account from which the data is being sent\\n     * @param  data         Arbitrary data given by the sender\\n     */\\n    function callFunction(\\n        address sender,\\n        Account.Info memory accountInfo,\\n        bytes memory data\\n    )\\n        public;\\n}\"\r\n    },\r\n    \"./contracts/compound/interfaces/ICToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface ICToken {\\n    function borrowIndex() view external returns (uint256);\\n\\n    function mint(uint256 mintAmount) external returns (uint256);\\n\\n    function mint() external payable;\\n\\n    function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\\n\\n    function repayBorrow() external payable;\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\\n\\n    function repayBorrowBehalf(address borrower) external payable;\\n\\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)\\n        external\\n        returns (uint256);\\n\\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\\n\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    function supplyRatePerBlock() external returns (uint256);\\n\\n    function borrowRatePerBlock() external returns (uint256);\\n\\n    function totalReserves() external returns (uint256);\\n\\n    function reserveFactorMantissa() external returns (uint256);\\n\\n    function borrowBalanceCurrent(address account) external returns (uint256);\\n\\n    function borrowBalanceStored(address account) external view returns (uint256);\\n\\n    function totalBorrowsCurrent() external returns (uint256);\\n\\n    function getCash() external returns (uint256);\\n\\n    function balanceOfUnderlying(address owner) external returns (uint256);\\n\\n    function balanceOf(address owner) view external returns (uint256);\\n\\n    function underlying() external returns (address);\\n}\\n\"\r\n    },\r\n    \"./contracts/flashloan/interfaces/ILendingPool.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface ILendingPool {\\n    function addressesProvider () external view returns ( address );\\n    function deposit ( address _reserve, uint256 _amount, uint16 _referralCode ) external payable;\\n    function redeemUnderlying ( address _reserve, address _user, uint256 _amount ) external;\\n    function borrow ( address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode ) external;\\n    function repay ( address _reserve, uint256 _amount, address _onBehalfOf ) external payable;\\n    function swapBorrowRateMode ( address _reserve ) external;\\n    function rebalanceFixedBorrowRate ( address _reserve, address _user ) external;\\n    function setUserUseReserveAsCollateral ( address _reserve, bool _useAsCollateral ) external;\\n    function liquidationCall ( address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveAToken ) external payable;\\n    function flashLoan ( address _receiver, address _reserve, uint256 _amount, bytes calldata _params ) external;\\n    function getReserveConfigurationData ( address _reserve ) external view returns ( uint256 ltv, uint256 liquidationThreshold, uint256 liquidationDiscount, address interestRateStrategyAddress, bool usageAsCollateralEnabled, bool borrowingEnabled, bool fixedBorrowRateEnabled, bool isActive );\\n    function getReserveData ( address _reserve ) external view returns ( uint256 totalLiquidity, uint256 availableLiquidity, uint256 totalBorrowsFixed, uint256 totalBorrowsVariable, uint256 liquidityRate, uint256 variableBorrowRate, uint256 fixedBorrowRate, uint256 averageFixedBorrowRate, uint256 utilizationRate, uint256 liquidityIndex, uint256 variableBorrowIndex, address aTokenAddress, uint40 lastUpdateTimestamp );\\n    function getUserAccountData ( address _user ) external view returns ( uint256 totalLiquidityETH, uint256 totalCollateralETH, uint256 totalBorrowsETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor );\\n    function getUserReserveData ( address _reserve, address _user ) external view returns ( uint256 currentATokenBalance, uint256 currentUnderlyingBalance, uint256 currentBorrowBalance, uint256 principalBorrowBalance, uint256 borrowRateMode, uint256 borrowRate, uint256 liquidityRate, uint256 originationFee, uint256 variableBorrowIndex, uint256 lastUpdateTimestamp, bool usageAsCollateralEnabled );\\n    function getReserves () external view;\\n}\"\r\n    },\r\n    \"./contracts/interfaces/IDfWalletFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface IDfWalletFactory {\\n    function createDfWallet() external returns (address dfWallet);\\n}\"\r\n    },\r\n    \"./contracts/interfaces/IDfWallet.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface IDfWallet {\\n\\n    function claimComp(address[] calldata cTokens) external;\\n\\n    function borrow(address _cTokenAddr, uint _amount) external;\\n\\n    function setDfFinanceClose(address _dfFinanceClose) external;\\n\\n    function deposit(\\n        address _tokenIn, address _cTokenIn, uint _amountIn, address _tokenOut, address _cTokenOut, uint _amountOut\\n    ) external payable;\\n\\n    function withdraw(\\n        address _tokenIn, address _cTokenIn, address _tokenOut, address _cTokenOut\\n    ) external payable;\\n\\n    function withdraw(\\n        address _tokenIn, address _cTokenIn, uint256 amountRedeem, address _tokenOut, address _cTokenOut, uint256 amountPayback\\n    ) external payable returns(uint256);\\n\\n    function withdrawToken(address _tokenAddr, address to, uint256 amount) external;\\n\\n    function redeem(address _tokenAddr, address _cTokenAddr, uint256 amount) external; \\n\\n}\\n\"\r\n    },\r\n    \"./contracts/interfaces/IComptrollerLensInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface IComptrollerLensInterface {\\n    function markets(address) external view returns (bool, uint);\\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\\n    function claimComp(address) external;\\n    function compAccrued(address) external view returns (uint);\\n}\"\r\n    },\r\n    \"./contracts/interfaces/IComptroller.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"./IPriceOracle.sol\\\";\\n\\ninterface IComptroller {\\n    function oracle() external view returns (IPriceOracle);\\n\\n    function getAccountLiquidity(address)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n}\"\r\n    },\r\n    \"./contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface IPriceOracle {\\n    function price(string calldata symbol) external view returns (uint);\\n}\"\r\n    },\r\n    \"./contracts/interfaces/IWeth.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface IWeth {\\n    function deposit() external payable;\\n    function withdraw(uint wad) external;\\n}\"\r\n    },\r\n    \"./contracts/interfaces/IDfProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ninterface IDfProxy {\\n    function cast(address payable _to, bytes calldata _data) external payable;\\n    function withdrawEth(address payable _to) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/upgrades/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dfWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DfAddDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dfWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"DfCloseDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dfWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DfOpenDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dfWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"DfPartiallyCloseDeposit\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"AAVE_ADDRESSES_PROVIDER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CDAI_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMPTROLLER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMP_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CUSDC_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CWBTC_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DF_PROXY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SOLO_MARGIN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USDC_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USDT_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WBTC_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct Account.Info\",\"name\":\"account\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dfWallet\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"}],\"name\":\"claimComps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dfWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUSDC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountWBTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flashloanDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flashloanUSDC\",\"type\":\"uint256\"},{\"internalType\":\"enum DfFinanceDeposits.FlashloanProvider\",\"name\":\"flashloanType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"flashloanFromAddress\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dfWalletFactory\",\"outputs\":[{\"internalType\":\"contract IDfWalletFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountFlashLoan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCompBalanceMetadataExt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocated\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdminPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dfWalletFactory\",\"type\":\"address\"}],\"name\":\"setDfWalletFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawMinRatio\",\"type\":\"uint256\"}],\"name\":\"setWithdrawMinRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"compClaimed\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"compClaimedinUSD\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"activeFeeScheme\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"depositUSDC\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"depositETH\",\"type\":\"uint96\"},{\"internalType\":\"uint64\",\"name\":\"depositWBTC\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"gap\",\"type\":\"uint96\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dfWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUSDC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountWBTC\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flashloanDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flashloanUSDC\",\"type\":\"uint256\"},{\"internalType\":\"enum DfFinanceDeposits.FlashloanProvider\",\"name\":\"flashloanType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"flashloanFromAddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawMinRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DfFinanceDeposits","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://1664c0b5f762a11397fd8d254db3047ba585d99e0b3f1a592e493daea10b1b74"}]}