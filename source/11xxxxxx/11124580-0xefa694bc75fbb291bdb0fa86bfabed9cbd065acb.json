{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n \r\n// -----------------------------------------------------------------------\r\n//\r\n// Symbol      : JACS\r\n// Name        : JACS Token\r\n// Total supply: 536,870,912.000000000000000000\r\n// Decimals    : 18\r\n//  \r\n// -----------------------------------------------------------------------\r\nlibrary SafeMath {\r\nfunction add(uint a, uint b) internal pure returns (uint c) {\r\nc = a + b;\r\nrequire(c >= a);\r\n}\r\nfunction sub(uint a, uint b) internal pure returns (uint c) {\r\nrequire(b <= a);\r\nc = a - b;\r\n}\r\nfunction mul(uint a, uint b) internal pure returns (uint c) {\r\nc = a * b;\r\nrequire(a == 0 || c / a == b);\r\n}\r\nfunction div(uint a, uint b) internal pure returns (uint c) {\r\nrequire(b > 0);\r\nc = a / b;\r\n}\r\n}\r\n\r\ncontract ERC20Interface {\r\nfunction totalSupply() public view returns (uint);\r\nfunction balanceOf(address tokenOwner) public view returns (uint balance);\r\nfunction allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\nfunction transfer(address to, uint tokens) public returns (bool success);\r\nfunction approve(address spender, uint tokens) public returns (bool success);\r\nfunction transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n  \r\nevent Transfer(address indexed from, address indexed to, uint tokens);\r\nevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\nfunction receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\ncontract Owned {\r\naddress public owner;\r\naddress public newOwner;\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n    constructor() public {\r\nowner = msg.sender;\r\n}\r\n    modifier onlyOwner {\r\nrequire(msg.sender == owner);\r\n_;\r\n}\r\nfunction transferOwnership(address _newOwner) public onlyOwner {\r\nnewOwner = _newOwner;\r\n}\r\nfunction acceptOwnership() public {\r\nrequire(msg.sender == newOwner);\r\n emit OwnershipTransferred(owner, newOwner);\r\nowner = newOwner;\r\nnewOwner = address(0);\r\n   }\r\n    \r\n  }\r\n\r\ncontract Lock {\r\n    \r\n     /**lock\r\n     * @dev Reasons why a user's tokens have been locked\r\n     */\r\n    mapping(address => bytes32[]) public lockReason;\r\n    mapping(address => uint256) public balances;\r\n\r\n    /**\r\n     * @dev locked token structure\r\n     */\r\n    struct LockToken {\r\n        uint256 amount;\r\n        uint256 validity;\r\n        bool claimed;\r\n    }\r\n\r\n    /**\r\n     * @dev Holds number & validity of tokens locked for a given reason for\r\n     *      a specified address\r\n     */\r\n    mapping(address => mapping(bytes32 => LockToken)) public locked;\r\n\r\n    /**\r\n     * @dev Records data of all the tokens Locked\r\n     */\r\n    event Locked(\r\n        address indexed _of,\r\n        bytes32 indexed _reason,\r\n        uint256 _amount,\r\n        uint256 _validity\r\n    );\r\n    /**\r\n     * @dev Records data of all the tokens unlocked\r\n     */\r\n    event Unlocked(\r\n        address indexed _of,\r\n        bytes32 indexed _reason,\r\n        uint256 _amount\r\n    );\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason\r\n     *\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     */\r\n    function tokensLocked(address _of, bytes32 _reason)\r\n    public view returns(uint256 amount);\r\n\r\n    /**\r\n     * @dev Returns unlockable tokens for a specified address for a specified reason\r\n     * @param _of The address to query the the unlockable token count of\r\n     * @param _reason The reason to query the unlockable tokens for\r\n     */\r\n    function tokensUnlockable(address _of, bytes32 _reason)\r\n    public view returns(uint256 amount);\r\n\r\n    /**\r\n     * @dev Unlocks the unlockable tokens of a specified address\r\n     * @param _of Address of user, claiming back unlockable tokens\r\n     */\r\n    function unlock(address _of)\r\n    public returns(uint256 unlockableTokens);\r\n}\r\n\r\ncontract JACSToken is ERC20Interface, Owned, Lock {\r\n    using SafeMath for uint;\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint256 public tokensForTokenSale; \r\n    address public tokenSaleAddress;                    // address of TokenSale contract\r\n    uint256 public totalAllocatedTokens;                // variable to regulate the funds allocation\r\n    uint256 public ownerHold; \r\n    uint internal _totalSupply;\r\n    mapping(address => uint) public balances;\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n    \r\n        /**\r\n     * @dev Error messages for require statements\r\n     */\r\n    string internal constant AMOUNT_ZERO = \"Amount can not be 0\";\r\n    string internal constant ONLY_OWNER = \"Only owner has the right to perform this action\";\r\n    address public owner = msg.sender;\r\n    \r\n    constructor( address _tokensaleContract) public {\r\n           symbol = \"JACS\";\r\n           name = \"JACS Token\";\r\n           decimals = 18;\r\n           tokenSaleAddress = _tokensaleContract;\r\n           _totalSupply = 536870912 * 10**uint(decimals);\r\n           \r\n           tokensForTokenSale = 268435456 * 10**uint(decimals);\r\n           ownerHold = 268435456 * 10**uint(decimals);\r\n           \r\n            balances[tokenSaleAddress] = tokensForTokenSale;\r\n            balances[owner] = ownerHold;\r\n            \r\n            emit Transfer(address(0), tokenSaleAddress, tokensForTokenSale);\r\n            emit Transfer(address(0), owner, ownerHold);\r\n         }\r\n         // ------------------------------------------------------------------\r\n        // Total supply\r\n        // -------------------------------------------------------------------\r\n        function totalSupply() public constant returns (uint) {\r\n             return _totalSupply.sub(balances[address(0)]);\r\n        }\r\n     // ------------------------------------------------------------------\r\n    // modifier\r\n    // ------------------------------------------------------------------\r\n      modifier onlyTokenSale() {\r\n        require(msg.sender == tokenSaleAddress);\r\n    _;\r\n  }\r\n  \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, ONLY_OWNER);\r\n        _;\r\n    }\r\n    \r\n       /**lock\r\n     * @dev Transfers and Locks a specified amount of tokens,\r\n     *      for a specified reason and time\r\n     * @param _to adress to which tokens are to be transfered\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be transfered and locked\r\n     * @param _days Number of days for locked token\r\n     */\r\n    function transferWithLock(address _to, bytes32 _reason, uint256 _amount, uint256 _days)\r\n    public\r\n    onlyOwner \r\n    returns(bool) {\r\n        uint256 validUntil = now.add(_days.mul(86400)); //solhint-disable-line\r\n        require(_amount != 0, AMOUNT_ZERO);\r\n\r\n        if (locked[_to][_reason].amount == 0)\r\n            lockReason[_to].push(_reason);\r\n\r\n        transfer(address(this), _amount);\r\n\r\n        locked[_to][_reason] = LockToken(_amount, validUntil, false);\r\n\r\n        emit Locked(_to, _reason, _amount, validUntil);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     */\r\n    function tokensLocked(address _of, bytes32 _reason)\r\n    public\r\n    view\r\n    returns(uint256 amount) {\r\n        if (!locked[_of][_reason].claimed)\r\n            amount = locked[_of][_reason].amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns unlockable tokens for a specified address for a specified reason\r\n     * @param _of The address to query the the unlockable token count of\r\n     * @param _reason The reason to query the unlockable tokens for\r\n     */\r\n    function tokensUnlockable(address _of, bytes32 _reason)\r\n    public\r\n    view\r\n    returns(uint256 amount) {\r\n        if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) //solhint-disable-line\r\n            amount = locked[_of][_reason].amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Unlocks the unlockable tokens of a specified address\r\n     * @param _of Address of user, claiming back unlockable tokens \r\n     */\r\n    function unlock(address _of)\r\n    public\r\n    returns(uint256 unlockableTokens) {\r\n        uint256 lockedTokens;\r\n\r\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n            lockedTokens = tokensUnlockable(_of, lockReason[_of][i]);\r\n            if (lockedTokens > 0) {\r\n                unlockableTokens = unlockableTokens.add(lockedTokens);\r\n                locked[_of][lockReason[_of][i]].claimed = true;\r\n                emit Unlocked(_of, lockReason[_of][i], lockedTokens); \r\n                \r\n                if (unlockableTokens > 0){\r\n                    this.transfer(_of, unlockableTokens);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Internal function that burns an amount of the token\r\n     * @param tokens The amount that will be burnt.\r\n     */\r\n\r\n    function burn(uint256 tokens) public onlyOwner  returns(bool) {\r\n        _burn(owner, tokens);\r\n        return true;\r\n    }\r\n    \r\n   /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param amount The amount that will be burnt.\r\n   */\r\n  function _burn(address account, uint256 amount) internal {\r\n    require(account != 0);\r\n    require(amount <= balances[account]);\r\n\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    balances[account] = balances[account].sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n  \r\n /**\r\n      @dev function used to change the supply of total Allocated tokens in the market , it only called by TokenSale\r\n      @param _amount amount is the token quantity added in token supply\r\n  \r\n   */\r\n  function totalAllocatedTokens(uint256 _amount) public onlyTokenSale {\r\n    totalAllocatedTokens += _amount;\r\n  }\r\n  \r\n     // ------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // -------------------------------------------------------------------\r\n     function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n         return balances[tokenOwner];\r\n    }\r\n     // ------------------------------------------------------------------\r\n     // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n     // - 0 value transfers are allowed\r\n     // ------------------------------------------------------------------\r\n     function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n         return true;\r\n     }\r\n     // ------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n     // from the token owner's account\r\n  // recommends that there are no checks for the approval double-spend\r\n // attack\r\n // as this should be implemented in user interfaces\r\n     // ------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n         return true;\r\n     }\r\n  // -------------------------------------------------------------------\r\n  // Transfer `tokens` from the `from` account to the `to` account\r\n  //\r\n  // The calling account must already have sufficient tokens\r\n // approve(...)-d\r\n // for spending from the `from` account and\r\n  // - From account must have sufficient balance to transfer\r\n  // - Spender must have sufficient allowance to transfer\r\n   // - 0 value transfers are allowed\r\n  // -------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = balances[from].sub(tokens);\r\n         allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n         balances[to] = balances[to].add(tokens);\r\n         emit Transfer(from, to, tokens);\r\n         return true;\r\n     }\r\n    // -------------------------------------------------------------------\r\n     // transferred to the spender's account\r\n     // ------------------------------------------------------------------\r\n     function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n         return allowed[tokenOwner][spender];\r\n    }\r\n     // ------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account. The `spender` contract function\r\n     // `receiveApproval(...)` is then executed\r\n     // ------------------------------------------------------------------\r\n     function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\r\n         allowed[msg.sender][spender] = tokens;\r\n         emit Approval(msg.sender, spender, tokens);\r\n         ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n         return true;\r\n     }\r\n    // -------------------------------------------------------------------\r\n     // Don't accept ETH\r\n    // -------------------------------------------------------------------\r\n     function () external payable {\r\n         revert();\r\n     }\r\n// -------------------------------------------------------------------\r\n     // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // -------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAllocatedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerHold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensForTokenSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"totalAllocatedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"unlock\",\"outputs\":[{\"name\":\"unlockableTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"transferWithLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"bytes32\"}],\"name\":\"tokensUnlockable\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"bytes32\"}],\"name\":\"tokensLocked\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockReason\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"locked\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"validity\",\"type\":\"uint256\"},{\"name\":\"claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokensaleContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_of\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_reason\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_validity\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_of\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_reason\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"JACSToken","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f5593372cf8659d224047a18780b28931826f17c","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7d70cbe3f6f81824bdddd0918f797a0a01d9aa2c2869943bd8c8da5be9b9bf3e"}]}