{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\n\r\npragma solidity >=0.7.6;\r\npragma abicoder v2;\r\n\r\ninterface IValueLiquidFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint256);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function formula() external view returns (address);\r\n\r\n    function protocolFee() external view returns (uint256);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint32 tokenWeightA,\r\n        uint32 swapFee\r\n    ) external view returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function isPair(address) external view returns (bool);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint32 tokenWeightA,\r\n        uint32 swapFee\r\n    ) external returns (address pair);\r\n\r\n    function getWeightsAndSwapFee(address pair)\r\n        external\r\n        view\r\n        returns (\r\n            uint32 tokenWeight0,\r\n            uint32 tokenWeight1,\r\n            uint32 swapFee\r\n        );\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n\r\n    function setProtocolFee(uint256) external;\r\n}\r\n\r\n/*\r\n    Bancor Formula interface\r\n*/\r\ninterface IValueLiquidFormula {\r\n    function getReserveAndWeights(address pair, address tokenA)\r\n        external\r\n        view\r\n        returns (\r\n            address tokenB,\r\n            uint256 reserveA,\r\n            uint256 reserveB,\r\n            uint32 tokenWeightA,\r\n            uint32 tokenWeightB,\r\n            uint32 swapFee\r\n        );\r\n\r\n    function getFactoryReserveAndWeights(\r\n        address factory,\r\n        address pair,\r\n        address tokenA\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address tokenB,\r\n            uint256 reserveA,\r\n            uint256 reserveB,\r\n            uint32 tokenWeightA,\r\n            uint32 tokenWeightB,\r\n            uint32 swapFee\r\n        );\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut,\r\n        uint32 tokenWeightIn,\r\n        uint32 tokenWeightOut,\r\n        uint32 swapFee\r\n    ) external view returns (uint256 amountIn);\r\n\r\n    function getPairAmountIn(\r\n        address pair,\r\n        address tokenIn,\r\n        uint256 amountOut\r\n    ) external view returns (uint256 amountIn);\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut,\r\n        uint32 tokenWeightIn,\r\n        uint32 tokenWeightOut,\r\n        uint32 swapFee\r\n    ) external view returns (uint256 amountOut);\r\n\r\n    function getPairAmountOut(\r\n        address pair,\r\n        address tokenIn,\r\n        uint256 amountIn\r\n    ) external view returns (uint256 amountOut);\r\n\r\n    function getAmountsIn(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n\r\n    function getFactoryAmountsIn(\r\n        address factory,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsOut(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n\r\n    function getFactoryAmountsOut(\r\n        address factory,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n\r\n    function ensureConstantValue(\r\n        uint256 reserve0,\r\n        uint256 reserve1,\r\n        uint256 balance0Adjusted,\r\n        uint256 balance1Adjusted,\r\n        uint32 tokenWeight0\r\n    ) external view returns (bool);\r\n\r\n    function getReserves(\r\n        address pair,\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (uint256 reserveA, uint256 reserveB);\r\n\r\n    function getOtherToken(address pair, address tokenA) external view returns (address tokenB);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\r\n\r\n    function mintLiquidityFee(\r\n        uint256 totalLiquidity,\r\n        uint112 reserve0,\r\n        uint112 reserve1,\r\n        uint32 tokenWeight0,\r\n        uint32 tokenWeight1,\r\n        uint112 collectedFee0,\r\n        uint112 collectedFee1\r\n    ) external view returns (uint256 amount);\r\n}\r\n\r\ninterface IValueLiquidPair {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\r\n\r\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\r\n\r\n    function getSwapFee() external view returns (uint32);\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(\r\n        address,\r\n        address,\r\n        uint32,\r\n        uint32\r\n    ) external;\r\n}\r\n\r\ninterface IStakePool {\r\n    event Deposit(address indexed account, uint256 amount);\r\n    event AddRewardPool(uint256 indexed poolId);\r\n    event UpdateRewardPool(uint256 indexed poolId, uint256 endRewardBlock, uint256 rewardPerBlock);\r\n    event PayRewardPool(\r\n        uint256 indexed poolId,\r\n        address indexed rewardToken,\r\n        address indexed account,\r\n        uint256 pendingReward,\r\n        uint256 rebaseAmount,\r\n        uint256 paidReward\r\n    );\r\n    event UpdateRewardRebaser(uint256 indexed poolId, address rewardRebaser);\r\n    event UpdateRewardMultiplier(uint256 indexed poolId, address rewardMultiplier);\r\n    event Withdraw(address indexed account, uint256 amount);\r\n\r\n    function version() external returns (uint256);\r\n\r\n    function pair() external returns (address);\r\n\r\n    function initialize(\r\n        address _pair,\r\n        uint256 _unstakingFrozenTime,\r\n        address _rewardFund,\r\n        address _timelock\r\n    ) external;\r\n\r\n    function stake(uint256) external;\r\n\r\n    function stakeFor(address _account) external;\r\n\r\n    function withdraw(uint256) external;\r\n\r\n    function getReward(uint8 _pid, address _account) external;\r\n\r\n    function getAllRewards(address _account) external;\r\n\r\n    function pendingReward(uint8 _pid, address _account) external view returns (uint256);\r\n\r\n    function getEndRewardBlock(uint8 _pid) external view returns (address, uint256);\r\n\r\n    function getRewardPerBlock(uint8 pid) external view returns (uint256);\r\n\r\n    function rewardPoolInfoLength() external view returns (uint256);\r\n\r\n    function unfrozenStakeTime(address _account) external view returns (uint256);\r\n\r\n    function emergencyWithdraw() external;\r\n\r\n    function updateReward() external;\r\n\r\n    function updateReward(uint8 _pid) external;\r\n\r\n    function updateRewardPool(\r\n        uint8 _pid,\r\n        uint256 _endRewardBlock,\r\n        uint256 _rewardPerBlock\r\n    ) external;\r\n\r\n    function getRewardMultiplier(\r\n        uint8 _pid,\r\n        uint256 _from,\r\n        uint256 _to,\r\n        uint256 _rewardPerBlock\r\n    ) external view returns (uint256);\r\n\r\n    function getRewardRebase(\r\n        uint8 _pid,\r\n        address _rewardToken,\r\n        uint256 _pendingReward\r\n    ) external view returns (uint256);\r\n\r\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external;\r\n\r\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external;\r\n\r\n    function getUserInfo(uint8 _pid, address _account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 amount,\r\n            uint256 rewardDebt,\r\n            uint256 accumulatedEarned,\r\n            uint256 lockReward,\r\n            uint256 lockRewardReleased\r\n        );\r\n\r\n    function addRewardPool(\r\n        address _rewardToken,\r\n        address _rewardRebaser,\r\n        address _rewardMultiplier,\r\n        uint256 _startBlock,\r\n        uint256 _endRewardBlock,\r\n        uint256 _rewardPerBlock,\r\n        uint256 _lockRewardPercent,\r\n        uint256 _startVestingBlock,\r\n        uint256 _endVestingBlock\r\n    ) external;\r\n\r\n    function removeLiquidity(\r\n        address provider,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address provider,\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address provider,\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountETH);\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n\r\ninterface IValueLiquidRouter {\r\n    struct Swap {\r\n        address pool;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 swapAmount; // tokenInAmount / tokenOutAmount\r\n        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\r\n        uint256 maxPrice;\r\n        bool isBPool;\r\n    }\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function controller() external view returns (address);\r\n\r\n    function formula() external view returns (address);\r\n\r\n    function WETH() external view returns (address);\r\n\r\n    function addLiquidity(\r\n        address pair,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address pair,\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForTokens(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        address tokenOut,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        address tokenIn,\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        address tokenOut,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external;\r\n\r\n    function addStakeLiquidity(\r\n        address stakePool,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addStakeLiquidityETH(\r\n        address stakePool,\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function multihopBatchSwapExactIn(\r\n        Swap[][] memory swapSequences,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 totalAmountIn,\r\n        uint256 minTotalAmountOut,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable returns (uint256 totalAmountOut);\r\n\r\n    function multihopBatchSwapExactOut(\r\n        Swap[][] memory swapSequences,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 maxTotalAmountIn,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable returns (uint256 totalAmountIn);\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint32 tokenWeightA,\r\n        uint32 swapFee,\r\n        address to,\r\n        uint8 flag\r\n    ) external returns (uint256 liquidity);\r\n\r\n    function createPairETH(\r\n        address token,\r\n        uint256 amountToken,\r\n        uint32 tokenWeight,\r\n        uint32 swapFee,\r\n        address to,\r\n        uint8 flag\r\n    ) external payable returns (uint256 liquidity);\r\n}\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b > 0, \"ds-math-division-by-zero\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function withdraw(uint256) external;\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IBPool is IERC20 {\r\n    function version() external view returns (uint256);\r\n\r\n    function swapExactAmountIn(\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256, uint256);\r\n\r\n    function swapExactAmountOut(\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256, uint256);\r\n\r\n    function calcInGivenOut(\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256\r\n    ) external pure returns (uint256);\r\n\r\n    function calcOutGivenIn(\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256\r\n    ) external pure returns (uint256);\r\n\r\n    function getDenormalizedWeight(address) external view returns (uint256);\r\n\r\n    function swapFee() external view returns (uint256);\r\n\r\n    function setSwapFee(uint256 _swapFee) external;\r\n\r\n    function bind(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denorm\r\n    ) external;\r\n\r\n    function rebind(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denorm\r\n    ) external;\r\n\r\n    function finalize(\r\n        uint256 _swapFee,\r\n        uint256 _initPoolSupply,\r\n        address[] calldata _bindTokens,\r\n        uint256[] calldata _bindDenorms\r\n    ) external;\r\n\r\n    function setPublicSwap(bool _publicSwap) external;\r\n\r\n    function setController(address _controller) external;\r\n\r\n    function setExchangeProxy(address _exchangeProxy) external;\r\n\r\n    function getFinalTokens() external view returns (address[] memory tokens);\r\n\r\n    function getTotalDenormalizedWeight() external view returns (uint256);\r\n\r\n    function getBalance(address token) external view returns (uint256);\r\n\r\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\r\n\r\n    function joinPoolFor(\r\n        address account,\r\n        uint256 rewardAmountOut,\r\n        uint256[] calldata maxAmountsIn\r\n    ) external;\r\n\r\n    function joinswapPoolAmountOut(\r\n        address tokenIn,\r\n        uint256 poolAmountOut,\r\n        uint256 maxAmountIn\r\n    ) external returns (uint256 tokenAmountIn);\r\n\r\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\r\n\r\n    function exitswapPoolAmountIn(\r\n        address tokenOut,\r\n        uint256 poolAmountIn,\r\n        uint256 minAmountOut\r\n    ) external returns (uint256 tokenAmountOut);\r\n\r\n    function exitswapExternAmountOut(\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPoolAmountIn\r\n    ) external returns (uint256 poolAmountIn);\r\n\r\n    function joinswapExternAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 minPoolAmountOut\r\n    ) external returns (uint256 poolAmountOut);\r\n\r\n    function finalizeRewardFundInfo(address _rewardFund, uint256 _unstakingFrozenTime) external;\r\n\r\n    function addRewardPool(\r\n        IERC20 _rewardToken,\r\n        uint256 _startBlock,\r\n        uint256 _endRewardBlock,\r\n        uint256 _rewardPerBlock,\r\n        uint256 _lockRewardPercent,\r\n        uint256 _startVestingBlock,\r\n        uint256 _endVestingBlock\r\n    ) external;\r\n\r\n    function isBound(address t) external view returns (bool);\r\n\r\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\r\n}\r\n\r\ninterface IFreeFromUpTo {\r\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\r\n}\r\n\r\ninterface IStakePoolController {\r\n    event MasterCreated(address indexed farm, address indexed pair, uint256 version, address timelock, address stakePoolRewardFund, uint256 totalStakePool);\r\n    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\r\n    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\r\n    event SetStakePoolCreator(address indexed contractAddress, uint256 verion);\r\n    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\r\n    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\r\n    event SetStakePoolVerifier(address indexed contractAddress, bool value);\r\n    event ChangeGovernance(address indexed governance);\r\n    event SetFeeCollector(address indexed feeCollector);\r\n    event SetFeeToken(address indexed token);\r\n    event SetFeeAmount(uint256 indexed amount);\r\n\r\n    struct PoolRewardInfo {\r\n        address rewardToken;\r\n        address rewardRebaser;\r\n        address rewardMultiplier;\r\n        uint256 startBlock;\r\n        uint256 endRewardBlock;\r\n        uint256 rewardPerBlock;\r\n        uint256 lockRewardPercent;\r\n        uint256 startVestingBlock;\r\n        uint256 endVestingBlock;\r\n        uint256 unstakingFrozenTime;\r\n        uint256 rewardFundAmount;\r\n    }\r\n\r\n    function allStakePools(uint256) external view returns (address stakePool);\r\n\r\n    function isStakePool(address contractAddress) external view returns (bool);\r\n\r\n    function isStakePoolVerifier(address contractAddress) external view returns (bool);\r\n\r\n    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\r\n\r\n    function isWhitelistStakePool(address contractAddress) external view returns (int8);\r\n\r\n    function setStakePoolVerifier(address contractAddress, bool state) external;\r\n\r\n    function setWhitelistStakingFor(address contractAddress, bool state) external;\r\n\r\n    function setWhitelistStakePool(address contractAddress, int8 state) external;\r\n\r\n    function addStakePoolCreator(address contractAddress) external;\r\n\r\n    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\r\n\r\n    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\r\n\r\n    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\r\n\r\n    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\r\n\r\n    function allStakePoolsLength() external view returns (uint256);\r\n\r\n    function create(\r\n        uint256 version,\r\n        address pair,\r\n        uint256 delayTimeLock,\r\n        PoolRewardInfo calldata poolRewardInfo,\r\n        uint8 flag\r\n    ) external returns (address);\r\n\r\n    function createPair(\r\n        uint256 version,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint32 tokenWeightA,\r\n        uint32 swapFee,\r\n        uint256 delayTimeLock,\r\n        PoolRewardInfo calldata poolRewardInfo,\r\n        uint8 flag\r\n    ) external returns (address);\r\n\r\n    function setGovernance(address) external;\r\n\r\n    function setFeeCollector(address _address) external;\r\n\r\n    function setFeeToken(address _token) external;\r\n\r\n    function setFeeAmount(uint256 _token) external;\r\n}\r\n\r\ncontract ValueLiquidRouter is IValueLiquidRouter {\r\n    using SafeMath for uint256;\r\n    address public immutable override factory;\r\n    address public immutable override controller;\r\n    address public immutable override formula;\r\n    address public immutable override WETH;\r\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n    modifier ensure(uint256 deadline) {\r\n        require(deadline >= block.timestamp, \"Router: EXPIRED\");\r\n        _;\r\n    }\r\n    modifier discountCHI(uint8 flag) {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        if ((flag & 0x1) == 1) {\r\n            uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\r\n            chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41130);\r\n        }\r\n    }\r\n\r\n    constructor(\r\n        address _factory,\r\n        address _controller,\r\n        address _WETH\r\n    ) {\r\n        factory = _factory;\r\n        controller = _controller;\r\n        formula = IValueLiquidFactory(_factory).formula();\r\n        WETH = _WETH;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH);\r\n        // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address pair,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin\r\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\r\n        require(IValueLiquidFactory(factory).isPair(pair), \"Router: Invalid pair\");\r\n        (uint256 reserveA, uint256 reserveB) = IValueLiquidFormula(formula).getReserves(pair, tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint256 amountBOptimal = IValueLiquidFormula(formula).quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, \"Router: INSUFFICIENT_B_AMOUNT\");\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint256 amountAOptimal = IValueLiquidFormula(formula).quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, \"Router: INSUFFICIENT_A_AMOUNT\");\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _addLiquidityToken(\r\n        address pair,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin\r\n    ) internal returns (uint256 amountA, uint256 amountB) {\r\n        (amountA, amountB) = _addLiquidity(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n    }\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint32 tokenWeightA,\r\n        uint32 swapFee,\r\n        address to,\r\n        uint8 flag\r\n    ) public virtual override discountCHI(flag) returns (uint256 liquidity) {\r\n        address pair = IValueLiquidFactory(factory).createPair(tokenA, tokenB, tokenWeightA, swapFee);\r\n        _addLiquidityToken(pair, tokenA, tokenB, amountA, amountB, 0, 0);\r\n        liquidity = IValueLiquidPair(pair).mint(to);\r\n    }\r\n\r\n    function addLiquidity(\r\n        address pair,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        (amountA, amountB) = _addLiquidityToken(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        liquidity = IValueLiquidPair(pair).mint(to);\r\n    }\r\n\r\n    function addStakeLiquidity(\r\n        address stakePool,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        require(IStakePoolController(controller).isStakePool(stakePool), \"Router: Invalid stakePool\");\r\n        address pair = IStakePool(stakePool).pair();\r\n        (amountA, amountB) = _addLiquidityToken(pair, tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        liquidity = IValueLiquidPair(pair).mint(stakePool);\r\n        IStakePool(stakePool).stakeFor(msg.sender);\r\n    }\r\n\r\n    function addStakeLiquidityETH(\r\n        address stakePool,\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        require(IStakePoolController(controller).isStakePool(stakePool), \"Router: Invalid stakePool\");\r\n        (amountToken, amountETH, liquidity) = _addLiquidityETH(\r\n            IStakePool(stakePool).pair(),\r\n            token,\r\n            amountTokenDesired,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            stakePool\r\n        );\r\n        IStakePool(stakePool).stakeFor(msg.sender);\r\n    }\r\n\r\n    function _addLiquidityETH(\r\n        address pair,\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        (amountToken, amountETH) = _addLiquidity(pair, token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        transferETHTo(amountETH, pair);\r\n        liquidity = IValueLiquidPair(pair).mint(to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    function createPairETH(\r\n        address token,\r\n        uint256 amountToken,\r\n        uint32 tokenWeight,\r\n        uint32 swapFee,\r\n        address to,\r\n        uint8 flag\r\n    ) public payable virtual override discountCHI(flag) returns (uint256 liquidity) {\r\n        address pair = IValueLiquidFactory(factory).createPair(token, WETH, tokenWeight, swapFee);\r\n        (, , liquidity) = _addLiquidityETH(pair, token, amountToken, 0, 0, to);\r\n    }\r\n\r\n    function addLiquidityETH(\r\n        address pair,\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        public\r\n        payable\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        (amountToken, amountETH, liquidity) = _addLiquidityETH(pair, token, amountTokenDesired, amountTokenMin, amountETHMin, to);\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(\r\n        address tokenIn,\r\n        uint256[] memory amounts,\r\n        address[] memory path,\r\n        address _to\r\n    ) internal virtual {\r\n        address input = tokenIn;\r\n        for (uint256 i = 0; i < path.length; i++) {\r\n            IValueLiquidPair pairV2 = IValueLiquidPair(path[i]);\r\n            address token0 = pairV2.token0();\r\n            uint256 amountOut = amounts[i + 1];\r\n            (uint256 amount0Out, uint256 amount1Out, address output) =\r\n                input == token0 ? (uint256(0), amountOut, pairV2.token1()) : (amountOut, uint256(0), token0);\r\n            address to = i < path.length - 1 ? path[i + 1] : _to;\r\n            pairV2.swap(amount0Out, amount1Out, to, new bytes(0));\r\n            input = output;\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) public virtual override discountCHI(flag) ensure(deadline) returns (uint256[] memory amounts) {\r\n        amounts = _validateAmountOut(tokenIn, tokenOut, amountIn, amountOutMin, path);\r\n\r\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\r\n        _swap(tokenIn, amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external virtual override discountCHI(flag) ensure(deadline) returns (uint256[] memory amounts) {\r\n        amounts = _validateAmountIn(tokenIn, tokenOut, amountOut, amountInMax, path);\r\n\r\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\r\n        _swap(tokenIn, amounts, path, to);\r\n    }\r\n\r\n    function swapExactETHForTokens(\r\n        address tokenOut,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable virtual override discountCHI(flag) ensure(deadline) returns (uint256[] memory amounts) {\r\n        amounts = _validateAmountOut(WETH, tokenOut, msg.value, amountOutMin, path);\r\n\r\n        transferETHTo(amounts[0], path[0]);\r\n        _swap(WETH, amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactETH(\r\n        address tokenIn,\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external virtual override discountCHI(flag) ensure(deadline) returns (uint256[] memory amounts) {\r\n        amounts = _validateAmountIn(tokenIn, WETH, amountOut, amountInMax, path);\r\n\r\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\r\n        _swap(tokenIn, amounts, path, address(this));\r\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapExactTokensForETH(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external virtual override discountCHI(flag) ensure(deadline) returns (uint256[] memory amounts) {\r\n        amounts = _validateAmountOut(tokenIn, WETH, amountIn, amountOutMin, path);\r\n\r\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amounts[0]);\r\n        _swap(tokenIn, amounts, path, address(this));\r\n        transferAll(ETH_ADDRESS, to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapETHForExactTokens(\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable virtual override discountCHI(flag) ensure(deadline) returns (uint256[] memory amounts) {\r\n        amounts = _validateAmountIn(WETH, tokenOut, amountOut, msg.value, path);\r\n\r\n        transferETHTo(amounts[0], path[0]);\r\n        _swap(WETH, amounts, path, to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(\r\n        address tokenIn,\r\n        address[] memory path,\r\n        address _to\r\n    ) internal virtual {\r\n        address input = tokenIn;\r\n        for (uint256 i; i < path.length; i++) {\r\n            IValueLiquidPair pair = IValueLiquidPair(path[i]);\r\n\r\n            uint256 amountInput;\r\n            uint256 amountOutput;\r\n            address currentOutput;\r\n            {\r\n                (address output, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) =\r\n                    IValueLiquidFormula(formula).getFactoryReserveAndWeights(factory, address(pair), input);\r\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n                amountOutput = IValueLiquidFormula(formula).getAmountOut(\r\n                    amountInput,\r\n                    reserveInput,\r\n                    reserveOutput,\r\n                    tokenWeightInput,\r\n                    tokenWeightOutput,\r\n                    swapFee\r\n                );\r\n                currentOutput = output;\r\n            }\r\n            (uint256 amount0Out, uint256 amount1Out) = input == pair.token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\r\n            address to = i < path.length - 1 ? path[i + 1] : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n            input = currentOutput;\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external virtual override discountCHI(flag) ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\r\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, to);\r\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    }\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        address tokenOut,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external payable virtual override discountCHI(flag) ensure(deadline) {\r\n        //            require(path[0] == WETH, 'Router: INVALID_PATH');\r\n        uint256 amountIn = msg.value;\r\n        transferETHTo(amountIn, path[0]);\r\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(WETH, path, to);\r\n        require(IERC20(tokenOut).balanceOf(to).sub(balanceBefore) >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    }\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) external virtual override discountCHI(flag) ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, path[0], amountIn);\r\n        _swapSupportingFeeOnTransferTokens(tokenIn, path, address(this));\r\n        uint256 amountOut = IERC20(WETH).balanceOf(address(this));\r\n        require(amountOut >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        transferAll(ETH_ADDRESS, to, amountOut);\r\n    }\r\n\r\n    function multihopBatchSwapExactIn(\r\n        Swap[][] memory swapSequences,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 totalAmountIn,\r\n        uint256 minTotalAmountOut,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) public payable virtual override discountCHI(flag) ensure(deadline) returns (uint256 totalAmountOut) {\r\n        transferFromAll(tokenIn, totalAmountIn);\r\n        uint256 balanceBefore;\r\n        if (!isETH(tokenOut)) {\r\n            balanceBefore = IERC20(tokenOut).balanceOf(msg.sender);\r\n        }\r\n\r\n        for (uint256 i = 0; i < swapSequences.length; i++) {\r\n            uint256 tokenAmountOut;\r\n            for (uint256 k = 0; k < swapSequences[i].length; k++) {\r\n                Swap memory swap = swapSequences[i][k];\r\n                if (k == 1) {\r\n                    // Makes sure that on the second swap the output of the first was used\r\n                    // so there is not intermediate token leftover\r\n                    swap.swapAmount = tokenAmountOut;\r\n                }\r\n\r\n                if (swap.isBPool) {\r\n                    TransferHelper.safeApprove(swap.tokenIn, swap.pool, swap.swapAmount);\r\n\r\n                    (tokenAmountOut, ) = IBPool(swap.pool).swapExactAmountIn(\r\n                        swap.tokenIn,\r\n                        swap.swapAmount,\r\n                        swap.tokenOut,\r\n                        swap.limitReturnAmount,\r\n                        swap.maxPrice\r\n                    );\r\n                } else {\r\n                    tokenAmountOut = _swapSingleSupportFeeOnTransferTokens(swap.tokenIn, swap.tokenOut, swap.pool, swap.swapAmount, swap.limitReturnAmount);\r\n                }\r\n            }\r\n\r\n            // This takes the amountOut of the last swap\r\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\r\n        }\r\n\r\n        transferAll(tokenOut, msg.sender, totalAmountOut);\r\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\r\n\r\n        if (isETH(tokenOut)) {\r\n            require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\r\n        } else {\r\n            require(IERC20(tokenOut).balanceOf(msg.sender).sub(balanceBefore) >= minTotalAmountOut, \"<minTotalAmountOut\");\r\n        }\r\n    }\r\n\r\n    function multihopBatchSwapExactOut(\r\n        Swap[][] memory swapSequences,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 maxTotalAmountIn,\r\n        uint256 deadline,\r\n        uint8 flag\r\n    ) public payable virtual override discountCHI(flag) ensure(deadline) returns (uint256 totalAmountIn) {\r\n        transferFromAll(tokenIn, maxTotalAmountIn);\r\n\r\n        for (uint256 i = 0; i < swapSequences.length; i++) {\r\n            uint256 tokenAmountInFirstSwap;\r\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\r\n            if (swapSequences[i].length == 1) {\r\n                Swap memory swap = swapSequences[i][0];\r\n                tokenAmountInFirstSwap = _swapSingleMixOut(\r\n                    swap.tokenIn,\r\n                    swap.tokenOut,\r\n                    swap.pool,\r\n                    swap.swapAmount,\r\n                    swap.limitReturnAmount,\r\n                    swap.maxPrice,\r\n                    swap.isBPool\r\n                );\r\n            } else {\r\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\r\n                // of token C. But first we need to buy B with A so we can then buy C with B\r\n                // To get the exact amount of C we then first need to calculate how much B we'll need:\r\n                uint256 intermediateTokenAmount;\r\n                // This would be token B as described above\r\n                Swap memory secondSwap = swapSequences[i][1];\r\n                if (secondSwap.isBPool) {\r\n                    IBPool poolSecondSwap = IBPool(secondSwap.pool);\r\n                    intermediateTokenAmount = poolSecondSwap.calcInGivenOut(\r\n                        poolSecondSwap.getBalance(secondSwap.tokenIn),\r\n                        poolSecondSwap.getDenormalizedWeight(secondSwap.tokenIn),\r\n                        poolSecondSwap.getBalance(secondSwap.tokenOut),\r\n                        poolSecondSwap.getDenormalizedWeight(secondSwap.tokenOut),\r\n                        secondSwap.swapAmount,\r\n                        poolSecondSwap.swapFee()\r\n                    );\r\n                } else {\r\n                    address[] memory paths = new address[](1);\r\n                    paths[0] = secondSwap.pool;\r\n                    uint256[] memory amounts =\r\n                        IValueLiquidFormula(formula).getFactoryAmountsIn(factory, secondSwap.tokenIn, secondSwap.tokenOut, secondSwap.swapAmount, paths);\r\n                    intermediateTokenAmount = amounts[0];\r\n                    require(intermediateTokenAmount <= secondSwap.limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\r\n                }\r\n\r\n                //// Buy intermediateTokenAmount of token B with A in the first pool\r\n                Swap memory firstSwap = swapSequences[i][0];\r\n                tokenAmountInFirstSwap = _swapSingleMixOut(\r\n                    firstSwap.tokenIn,\r\n                    firstSwap.tokenOut,\r\n                    firstSwap.pool,\r\n                    intermediateTokenAmount,\r\n                    firstSwap.limitReturnAmount,\r\n                    firstSwap.maxPrice,\r\n                    firstSwap.isBPool\r\n                );\r\n\r\n                //// Buy the final amount of token C desired\r\n                if (secondSwap.isBPool) {\r\n                    _swapPBoolOut(\r\n                        secondSwap.tokenIn,\r\n                        secondSwap.tokenOut,\r\n                        secondSwap.pool,\r\n                        secondSwap.swapAmount,\r\n                        secondSwap.limitReturnAmount,\r\n                        secondSwap.maxPrice\r\n                    );\r\n                } else {\r\n                    _swapSingle(secondSwap.tokenIn, secondSwap.pool, intermediateTokenAmount, secondSwap.swapAmount);\r\n                }\r\n            }\r\n\r\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\r\n        }\r\n\r\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        transferAll(tokenOut, msg.sender, getBalance(tokenOut));\r\n        transferAll(tokenIn, msg.sender, getBalance(tokenIn));\r\n    }\r\n\r\n    function transferFromAll(address token, uint256 amount) internal returns (bool) {\r\n        if (isETH(token)) {\r\n            IWETH(WETH).deposit{value: msg.value}();\r\n        } else {\r\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getBalance(address token) internal view returns (uint256) {\r\n        if (isETH(token)) {\r\n            return IWETH(WETH).balanceOf(address(this));\r\n        } else {\r\n            return IERC20(token).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function _swapSingleMixOut(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        address pool,\r\n        uint256 swapAmount,\r\n        uint256 limitReturnAmount,\r\n        uint256 maxPrice,\r\n        bool isBPool\r\n    ) internal returns (uint256 tokenAmountIn) {\r\n        if (isBPool) {\r\n            return _swapPBoolOut(tokenIn, tokenOut, pool, swapAmount, limitReturnAmount, maxPrice);\r\n        } else {\r\n            address[] memory paths = new address[](1);\r\n            paths[0] = pool;\r\n            uint256[] memory amounts = IValueLiquidFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, swapAmount, paths);\r\n            tokenAmountIn = amounts[0];\r\n            require(tokenAmountIn <= limitReturnAmount, \"Router: EXCESSIVE_INPUT_AMOUNT\");\r\n\r\n            _swapSingle(tokenIn, pool, tokenAmountIn, amounts[1]);\r\n        }\r\n    }\r\n\r\n    function _swapPBoolOut(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        address pool,\r\n        uint256 swapAmount,\r\n        uint256 limitReturnAmount,\r\n        uint256 maxPrice\r\n    ) internal returns (uint256 tokenAmountIn) {\r\n        TransferHelper.safeApprove(tokenIn, pool, limitReturnAmount);\r\n\r\n        (tokenAmountIn, ) = IBPool(pool).swapExactAmountOut(tokenIn, limitReturnAmount, tokenOut, swapAmount, maxPrice);\r\n    }\r\n\r\n    function _swapSingle(\r\n        address tokenIn,\r\n        address pair,\r\n        uint256 targetSwapAmount,\r\n        uint256 targetOutAmount\r\n    ) internal {\r\n        TransferHelper.safeTransfer(tokenIn, pair, targetSwapAmount);\r\n        (uint256 amount0Out, uint256 amount1Out) = tokenIn == IValueLiquidPair(pair).token0() ? (uint256(0), targetOutAmount) : (targetOutAmount, uint256(0));\r\n\r\n        IValueLiquidPair(pair).swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n    }\r\n\r\n    function _swapSingleSupportFeeOnTransferTokens(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        address pool,\r\n        uint256 swapAmount,\r\n        uint256 limitReturnAmount\r\n    ) internal returns (uint256 tokenAmountOut) {\r\n        TransferHelper.safeTransfer(tokenIn, pool, swapAmount);\r\n\r\n        uint256 amountOutput;\r\n        {\r\n            (, uint256 reserveInput, uint256 reserveOutput, uint32 tokenWeightInput, uint32 tokenWeightOutput, uint32 swapFee) =\r\n                IValueLiquidFormula(formula).getFactoryReserveAndWeights(factory, pool, tokenIn);\r\n            uint256 amountInput = IERC20(tokenIn).balanceOf(pool).sub(reserveInput);\r\n            amountOutput = IValueLiquidFormula(formula).getAmountOut(amountInput, reserveInput, reserveOutput, tokenWeightInput, tokenWeightOutput, swapFee);\r\n        }\r\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\r\n        (uint256 amount0Out, uint256 amount1Out) = tokenIn == IValueLiquidPair(pool).token0() ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\r\n        IValueLiquidPair(pool).swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n\r\n        tokenAmountOut = IERC20(tokenOut).balanceOf(address(this)).sub(balanceBefore);\r\n        require(tokenAmountOut >= limitReturnAmount, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    }\r\n\r\n    function _validateAmountOut(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory path\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        amounts = IValueLiquidFormula(formula).getFactoryAmountsOut(factory, tokenIn, tokenOut, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Router: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    }\r\n\r\n    function _validateAmountIn(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        amounts = IValueLiquidFormula(formula).getFactoryAmountsIn(factory, tokenIn, tokenOut, amountOut, path);\r\n        require(amounts[0] <= amountInMax, \"Router: EXCESSIVE_INPUT_AMOUNT\");\r\n    }\r\n\r\n    function transferETHTo(uint256 amount, address to) internal {\r\n        IWETH(WETH).deposit{value: amount}();\r\n        assert(IWETH(WETH).transfer(to, amount));\r\n    }\r\n\r\n    function transferAll(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n\r\n        if (isETH(token)) {\r\n            IWETH(WETH).withdraw(amount);\r\n            TransferHelper.safeTransferETH(to, amount);\r\n        } else {\r\n            TransferHelper.safeTransfer(token, to, amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function isETH(address token) internal pure returns (bool) {\r\n        return (token == ETH_ADDRESS);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addStakeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addStakeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chi\",\"outputs\":[{\"internalType\":\"contract IFreeFromUpTo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"tokenWeightA\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"swapFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"tokenWeight\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"swapFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"createPairETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"formula\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBPool\",\"type\":\"bool\"}],\"internalType\":\"struct IValueLiquidRouter.Swap[][]\",\"name\":\"swapSequences\",\"type\":\"tuple[][]\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTotalAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"multihopBatchSwapExactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBPool\",\"type\":\"bool\"}],\"internalType\":\"struct IValueLiquidRouter.Swap[][]\",\"name\":\"swapSequences\",\"type\":\"tuple[][]\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"multihopBatchSwapExactOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"flag\",\"type\":\"uint8\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ValueLiquidRouter","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000005021470fc598373fba4fe3384745940eab3e653d000000000000000000000000f0159d041db29029ccf285a1043dcaac7088030b000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://53ea4c22bb71659cb70ad3da9b80aab3e4cf63d22e9db30df5b52ac14966ffd5"}]}