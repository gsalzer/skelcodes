{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PremiaOptionBatch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./interface/IPremiaOption.sol\\\";\\r\\n\\r\\n/// @author Premia\\r\\n/// @title Batch functions to interact with PremiaOption\\r\\ncontract PremiaOptionBatch {\\r\\n    /// @notice Write multiple options at once\\r\\n    /// @param _premiaOption A PremiaOption contract\\r\\n    /// @param _options Options to write\\r\\n    /// @param _referrer Referrer\\r\\n    function batchWriteOption(IPremiaOption _premiaOption, IPremiaOption.OptionWriteArgs[] memory _options, address _referrer) external {\\r\\n        for (uint256 i = 0; i < _options.length; ++i) {\\r\\n            _premiaOption.writeOptionFrom(msg.sender, _options[i], _referrer);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Cancel multiple options at once\\r\\n    /// @param _premiaOption A PremiaOption contract\\r\\n    /// @param _optionId List of ids of options to cancel\\r\\n    /// @param _amounts Amount to cancel for each option\\r\\n    function batchCancelOption(IPremiaOption _premiaOption, uint256[] memory _optionId, uint256[] memory _amounts) external {\\r\\n        require(_optionId.length == _amounts.length, \\\"Arrays diff len\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < _optionId.length; ++i) {\\r\\n            _premiaOption.cancelOptionFrom(msg.sender, _optionId[i], _amounts[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw funds from multiple options at once\\r\\n    /// @param _premiaOption A PremiaOption contract\\r\\n    /// @param _optionId List of ids of options to withdraw funds from\\r\\n    function batchWithdraw(IPremiaOption _premiaOption, uint256[] memory _optionId) external {\\r\\n        for (uint256 i = 0; i < _optionId.length; ++i) {\\r\\n            _premiaOption.withdrawFrom(msg.sender, _optionId[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Exercise multiple options at once\\r\\n    /// @param _premiaOption A PremiaOption contract\\r\\n    /// @param _optionId List of ids of options to exercise\\r\\n    /// @param _amounts Amount to exercise for each option\\r\\n    /// @param _referrer Referrer\\r\\n    function batchExerciseOption(IPremiaOption _premiaOption, uint256[] memory _optionId, uint256[] memory _amounts, address _referrer) external {\\r\\n        require(_optionId.length == _amounts.length, \\\"Arrays diff len\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < _optionId.length; ++i) {\\r\\n            _premiaOption.exerciseOptionFrom(msg.sender, _optionId[i], _amounts[i], _referrer);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw funds pre expiration from multiple options at once\\r\\n    /// @param _premiaOption A PremiaOption contract\\r\\n    /// @param _optionId List of ids of options to withdraw funds from\\r\\n    /// @param _amounts Amount to withdraw pre expiration for each option\\r\\n    function batchWithdrawPreExpiration(IPremiaOption _premiaOption, uint256[] memory _optionId, uint256[] memory _amounts) external {\\r\\n        require(_optionId.length == _amounts.length, \\\"Arrays diff len\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < _optionId.length; ++i) {\\r\\n            _premiaOption.withdrawPreExpirationFrom(msg.sender, _optionId[i], _amounts[i]);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IPremiaOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\\r\\nimport \\\"../interface/IFlashLoanReceiver.sol\\\";\\r\\nimport \\\"../uniswapV2/interfaces/IUniswapV2Router02.sol\\\";\\r\\n\\r\\ninterface IPremiaOption is IERC1155 {\\r\\n    struct OptionWriteArgs {\\r\\n        address token;                  // Token address\\r\\n        uint256 amount;                 // Amount of tokens to write option for\\r\\n        uint256 strikePrice;            // Strike price (Must follow strikePriceIncrement of token)\\r\\n        uint256 expiration;             // Expiration timestamp of the option (Must follow expirationIncrement)\\r\\n        bool isCall;                    // If true : Call option | If false : Put option\\r\\n    }\\r\\n\\r\\n    struct OptionData {\\r\\n        address token;                  // Token address\\r\\n        uint256 strikePrice;            // Strike price (Must follow strikePriceIncrement of token)\\r\\n        uint256 expiration;             // Expiration timestamp of the option (Must follow expirationIncrement)\\r\\n        bool isCall;                    // If true : Call option | If false : Put option\\r\\n        uint256 claimsPreExp;           // Amount of options from which the funds have been withdrawn pre expiration\\r\\n        uint256 claimsPostExp;          // Amount of options from which the funds have been withdrawn post expiration\\r\\n        uint256 exercised;              // Amount of options which have been exercised\\r\\n        uint256 supply;                 // Total circulating supply\\r\\n        uint8 decimals;                 // Token decimals\\r\\n    }\\r\\n\\r\\n    // Total write cost = collateral + fee + feeReferrer\\r\\n    struct QuoteWrite {\\r\\n        address collateralToken;        // The token to deposit as collateral\\r\\n        uint256 collateral;             // The amount of collateral to deposit\\r\\n        uint8 collateralDecimals;       // Decimals of collateral token\\r\\n        uint256 fee;                    // The amount of collateralToken needed to be paid as protocol fee\\r\\n        uint256 feeReferrer;            // The amount of collateralToken which will be paid the referrer\\r\\n    }\\r\\n\\r\\n    // Total exercise cost = input + fee + feeReferrer\\r\\n    struct QuoteExercise {\\r\\n        address inputToken;             // Input token for exercise\\r\\n        uint256 input;                  // Amount of input token to pay to exercise\\r\\n        uint8 inputDecimals;            // Decimals of input token\\r\\n        address outputToken;            // Output token from the exercise\\r\\n        uint256 output;                 // Amount of output tokens which will be received on exercise\\r\\n        uint8 outputDecimals;           // Decimals of output token\\r\\n        uint256 fee;                    // The amount of inputToken needed to be paid as protocol fee\\r\\n        uint256 feeReferrer;            // The amount of inputToken which will be paid to the referrer\\r\\n    }\\r\\n\\r\\n    struct Pool {\\r\\n        uint256 tokenAmount;\\r\\n        uint256 denominatorAmount;\\r\\n    }\\r\\n\\r\\n    function denominatorDecimals() external view returns(uint8);\\r\\n\\r\\n    function maxExpiration() external view returns(uint256);\\r\\n    function optionData(uint256 _optionId) external view returns (OptionData memory);\\r\\n    function tokenStrikeIncrement(address _token) external view returns (uint256);\\r\\n    function nbWritten(address _writer, uint256 _optionId) external view returns (uint256);\\r\\n\\r\\n    function getOptionId(address _token, uint256 _expiration, uint256 _strikePrice, bool _isCall) external view returns(uint256);\\r\\n    function getOptionIdOrCreate(address _token, uint256 _expiration, uint256 _strikePrice, bool _isCall) external returns(uint256);\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    function getWriteQuote(address _from, OptionWriteArgs memory _option, address _referrer, uint8 _decimals) external view returns(QuoteWrite memory);\\r\\n    function getExerciseQuote(address _from, OptionData memory _option, uint256 _amount, address _referrer, uint8 _decimals) external view returns(QuoteExercise memory);\\r\\n\\r\\n    function writeOptionWithIdFrom(address _from, uint256 _optionId, uint256 _amount, address _referrer) external returns(uint256);\\r\\n    function writeOption(address _token, OptionWriteArgs memory _option, address _referrer) external returns(uint256);\\r\\n    function writeOptionFrom(address _from, OptionWriteArgs memory _option, address _referrer) external returns(uint256);\\r\\n    function cancelOption(uint256 _optionId, uint256 _amount) external;\\r\\n    function cancelOptionFrom(address _from, uint256 _optionId, uint256 _amount) external;\\r\\n    function exerciseOption(uint256 _optionId, uint256 _amount) external;\\r\\n    function exerciseOptionFrom(address _from, uint256 _optionId, uint256 _amount, address _referrer) external;\\r\\n    function withdraw(uint256 _optionId) external;\\r\\n    function withdrawFrom(address _from, uint256 _optionId) external;\\r\\n    function withdrawPreExpiration(uint256 _optionId, uint256 _amount) external;\\r\\n    function withdrawPreExpirationFrom(address _from, uint256 _optionId, uint256 _amount) external;\\r\\n    function flashExerciseOption(uint256 _optionId, uint256 _amount, address _referrer, IUniswapV2Router02 _router, uint256 _amountInMax) external;\\r\\n    function flashExerciseOptionFrom(address _from, uint256 _optionId, uint256 _amount, address _referrer, IUniswapV2Router02 _router, uint256 _amountInMax) external;\\r\\n    function flashLoan(address _tokenAddress, uint256 _amount, IFlashLoanReceiver _receiver) external;\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IFlashLoanReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IFlashLoanReceiver {\\r\\n    function execute(address _tokenAddress, uint256 _amount, uint256 _amountWithFee) external;\\r\\n}\"\r\n    },\r\n    \"contracts/uniswapV2/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\r\\n\\r\\nimport './IUniswapV2Router01.sol';\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapV2/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IPremiaOption\",\"name\":\"_premiaOption\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_optionId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchCancelOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPremiaOption\",\"name\":\"_premiaOption\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_optionId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"batchExerciseOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPremiaOption\",\"name\":\"_premiaOption\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_optionId\",\"type\":\"uint256[]\"}],\"name\":\"batchWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPremiaOption\",\"name\":\"_premiaOption\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_optionId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchWithdrawPreExpiration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPremiaOption\",\"name\":\"_premiaOption\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"}],\"internalType\":\"struct IPremiaOption.OptionWriteArgs[]\",\"name\":\"_options\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"batchWriteOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PremiaOptionBatch","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}