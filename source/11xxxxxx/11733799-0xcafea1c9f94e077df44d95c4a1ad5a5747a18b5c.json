{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/oracles/TwapOracle.sol\": {\r\n      \"content\": \"/* Copyright (C) 2020 NexusMutual.io\\n\\n  This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n  This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n  You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@uniswap/lib/contracts/libraries/FixedPoint.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\\\";\\n\\ncontract TwapOracle {\\n  using FixedPoint for *;\\n\\n  struct Bucket {\\n    uint timestamp;\\n    uint price0Cumulative;\\n    uint price1Cumulative;\\n  }\\n\\n  event Updated(address indexed pair, uint timestamp, uint price0Cumulative, uint price1Cumulative);\\n\\n  uint constant public periodSize = 1800;\\n  uint constant public periodsPerWindow = 8;\\n  uint constant public windowSize = periodSize * periodsPerWindow;\\n\\n  address public factory;\\n\\n  // token pair => Bucket[8]\\n  mapping(address => Bucket[8]) public buckets;\\n\\n  constructor (address _factory) public {\\n    factory = _factory;\\n  }\\n\\n  /* utils */\\n\\n  // https://uniswap.org/docs/v2/smart-contract-integration/getting-pair-addresses/\\n  function _pairFor(address _factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n\\n    // sort tokens\\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n\\n    require(token0 != token1, \\\"TWAP: identical addresses\\\");\\n    require(token0 != address(0), \\\"TWAP: zero address\\\");\\n\\n    pair = address(uint(keccak256(abi.encodePacked(\\n        hex'ff',\\n        _factory,\\n        keccak256(abi.encodePacked(token0, token1)),\\n        hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\\n      ))));\\n  }\\n\\n  function timestampToIndex(uint timestamp) internal pure returns (uint index) {\\n    uint epochPeriod = timestamp / periodSize;\\n    return epochPeriod % periodsPerWindow;\\n  }\\n\\n  function pairFor(address tokenA, address tokenB) external view returns (address pair) {\\n    return _pairFor(factory, tokenA, tokenB);\\n  }\\n\\n  function currentBucketIndex() external view returns (uint index) {\\n    return timestampToIndex(block.timestamp);\\n  }\\n\\n  /* update */\\n\\n  function update(address[] calldata pairs) external {\\n\\n    for (uint i = 0; i < pairs.length; i++) {\\n\\n      // note: not reusing canUpdate() because we need the bucket variable\\n      address pair = pairs[i];\\n      uint index = timestampToIndex(block.timestamp);\\n      Bucket storage bucket = buckets[pair][index];\\n\\n      if (block.timestamp - bucket.timestamp < periodSize) {\\n        continue;\\n      }\\n\\n      (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\\n      bucket.timestamp = block.timestamp;\\n      bucket.price0Cumulative = price0Cumulative;\\n      bucket.price1Cumulative = price1Cumulative;\\n\\n      emit Updated(pair, block.timestamp, price0Cumulative, price1Cumulative);\\n    }\\n  }\\n\\n  function canUpdate(address pair) external view returns (bool) {\\n\\n    uint index = timestampToIndex(block.timestamp);\\n    Bucket storage bucket = buckets[pair][index];\\n    uint timeElapsed = block.timestamp - bucket.timestamp;\\n\\n    return timeElapsed > periodSize;\\n  }\\n\\n  /* consult */\\n\\n  function _getCumulativePrices(\\n    address tokenIn,\\n    address tokenOut\\n  ) internal view returns (uint priceCumulativeStart, uint priceCumulativeEnd, uint timeElapsed) {\\n\\n    uint currentIndex = timestampToIndex(block.timestamp);\\n    uint firstBucketIndex = (currentIndex + 1) % periodsPerWindow;\\n\\n    address pair = _pairFor(factory, tokenIn, tokenOut);\\n    Bucket storage firstBucket = buckets[pair][firstBucketIndex];\\n\\n    timeElapsed = block.timestamp - firstBucket.timestamp;\\n    require(timeElapsed <= windowSize, \\\"TWAP: missing historical reading\\\");\\n    require(timeElapsed >= windowSize - periodSize * 2, \\\"TWAP: unexpected time elapsed\\\");\\n\\n    (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\\n\\n    if (tokenIn < tokenOut) {\\n      return (firstBucket.price0Cumulative, price0Cumulative, timeElapsed);\\n    }\\n\\n    return (firstBucket.price1Cumulative, price1Cumulative, timeElapsed);\\n  }\\n\\n  function _computeAmountOut(\\n    uint priceCumulativeStart,\\n    uint priceCumulativeEnd,\\n    uint timeElapsed,\\n    uint amountIn\\n  ) internal pure returns (uint amountOut) {\\n\\n    // overflow is desired.\\n    FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\\n      uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\\n    );\\n\\n    return priceAverage.mul(amountIn).decode144();\\n  }\\n\\n  /**\\n   *  @dev Returns the amount out corresponding to the amount in for a given token using the\\n   *  @dev   moving average over the time range [now - [windowSize, windowSize - periodSize * 2], now]\\n   *  @dev   update must have been called for the bucket corresponding to timestamp `now - windowSize`\\n   */\\n  function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\\n\\n    uint pastPriceCumulative;\\n    uint currentPriceCumulative;\\n    uint timeElapsed;\\n\\n    (pastPriceCumulative, currentPriceCumulative, timeElapsed) = _getCumulativePrices(tokenIn, tokenOut);\\n\\n    return _computeAmountOut(\\n      pastPriceCumulative,\\n      currentPriceCumulative,\\n      timeElapsed,\\n      amountIn\\n    );\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.0;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price0Cumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price1Cumulative\",\"type\":\"uint256\"}],\"name\":\"Updated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buckets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1Cumulative\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"canUpdate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"consult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBucketIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"pairFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodsPerWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"windowSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TwapOracle","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}