{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/contracts/oracle/chainlink/ChainlinkPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {ISynthereumFinder} from '../../versioning/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumPoolRegistry\\n} from '../../versioning/interfaces/IPoolRegistry.sol';\\nimport {\\n  ISynthereumPoolDeployment\\n} from '../../synthereum-pool/common/interfaces/IPoolDeployment.sol';\\nimport {SynthereumInterfaces} from '../../versioning/Constants.sol';\\nimport {\\n  ISynthereumChainlinkPriceFeed\\n} from './interfaces/IChainlinkPriceFeed.sol';\\nimport {\\n  AggregatorV3Interface\\n} from '../../../@chainlink/contracts/v0.6/interfaces/AggregatorV3Interface.sol';\\nimport {SafeMath} from '../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport {\\n  AccessControl\\n} from '../../../@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract SynthereumChainlinkPriceFeed is\\n  ISynthereumChainlinkPriceFeed,\\n  AccessControl\\n{\\n  using SafeMath for uint256;\\n\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  //Describe role structure\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n  }\\n\\n  //----------------------------------------\\n  // State variables\\n  //----------------------------------------\\n\\n  ISynthereumFinder public synthereumFinder;\\n  mapping(bytes32 => AggregatorV3Interface) private aggregators;\\n\\n  //----------------------------------------\\n  // Events\\n  //----------------------------------------\\n\\n  event SetAggregator(bytes32 indexed priceIdentifier, address aggregator);\\n\\n  event RemoveAggregator(bytes32 indexed priceIdentifier);\\n\\n  //----------------------------------------\\n  // Constructor\\n  //----------------------------------------\\n  /**\\n   * @notice Constructs the SynthereumChainlinkPriceFeed contract\\n   * @param _synthereumFinder Synthereum finder contract\\n   * @param _roles Admin and Mainteiner roles\\n   */\\n  constructor(ISynthereumFinder _synthereumFinder, Roles memory _roles) public {\\n    synthereumFinder = _synthereumFinder;\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, _roles.admin);\\n    _setupRole(MAINTAINER_ROLE, _roles.maintainer);\\n  }\\n\\n  //----------------------------------------\\n  // Modifiers\\n  //----------------------------------------\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyPools() {\\n    if (msg.sender != tx.origin) {\\n      ISynthereumPoolRegistry poolRegister =\\n        ISynthereumPoolRegistry(\\n          synthereumFinder.getImplementationAddress(\\n            SynthereumInterfaces.PoolRegistry\\n          )\\n        );\\n      ISynthereumPoolDeployment pool = ISynthereumPoolDeployment(msg.sender);\\n      require(\\n        poolRegister.isPoolDeployed(\\n          pool.syntheticTokenSymbol(),\\n          pool.collateralToken(),\\n          pool.version(),\\n          msg.sender\\n        ),\\n        'Pool not registred'\\n      );\\n    }\\n    _;\\n  }\\n\\n  //----------------------------------------\\n  // External functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Set the address of aggregator associated to a pricee identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @param aggregator Address of chainlink proxy aggregator\\n   */\\n  function setAggregator(\\n    bytes32 priceIdentifier,\\n    AggregatorV3Interface aggregator\\n  ) external override onlyMaintainer {\\n    require(\\n      address(aggregators[priceIdentifier]) != address(aggregator),\\n      'Aggregator address is the same'\\n    );\\n    aggregators[priceIdentifier] = aggregator;\\n    emit SetAggregator(priceIdentifier, address(aggregator));\\n  }\\n\\n  /**\\n   * @notice Remove the address of aggregator associated to a price identifier\\n   * @param priceIdentifier Price feed identifier\\n   */\\n  function removeAggregator(bytes32 priceIdentifier)\\n    external\\n    override\\n    onlyMaintainer\\n  {\\n    require(\\n      address(aggregators[priceIdentifier]) != address(0),\\n      'Price identifier does not exist'\\n    );\\n    delete aggregators[priceIdentifier];\\n    emit RemoveAggregator(priceIdentifier);\\n  }\\n\\n  /**\\n   * @notice Get last chainlink oracle price for a given price identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @return price Oracle price\\n   */\\n  function getLatestPrice(bytes32 priceIdentifier)\\n    external\\n    view\\n    override\\n    onlyPools()\\n    returns (uint256 price)\\n  {\\n    OracleData memory oracleData = _getOracleLatestRoundData(priceIdentifier);\\n    price = getScaledValue(oracleData.answer, oracleData.decimals);\\n  }\\n\\n  /**\\n   * @notice Get last chainlink oracle data for a given price identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @return oracleData Oracle data\\n   */\\n  function getOracleLatestData(bytes32 priceIdentifier)\\n    external\\n    view\\n    override\\n    onlyPools()\\n    returns (OracleData memory oracleData)\\n  {\\n    oracleData = _getOracleLatestRoundData(priceIdentifier);\\n  }\\n\\n  /**\\n   * @notice Get chainlink oracle price in a given round for a given price identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @param _roundId Round Id\\n   * @return price Oracle price\\n   */\\n  function getRoundPrice(bytes32 priceIdentifier, uint80 _roundId)\\n    external\\n    view\\n    override\\n    onlyPools()\\n    returns (uint256 price)\\n  {\\n    OracleData memory oracleData =\\n      _getOracleRoundData(priceIdentifier, _roundId);\\n    price = getScaledValue(oracleData.answer, oracleData.decimals);\\n  }\\n\\n  /**\\n   * @notice Get chainlink oracle data in a given round for a given price identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @param _roundId Round Id\\n   * @return oracleData Oracle data\\n   */\\n  function getOracleRoundData(bytes32 priceIdentifier, uint80 _roundId)\\n    external\\n    view\\n    override\\n    onlyPools()\\n    returns (OracleData memory oracleData)\\n  {\\n    oracleData = _getOracleRoundData(priceIdentifier, _roundId);\\n  }\\n\\n  //----------------------------------------\\n  // Public view functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Returns the address of aggregator if exists, otherwise it reverts\\n   * @param priceIdentifier Price feed identifier\\n   * @return aggregator Aggregator associated with price identifier\\n   */\\n  function getAggregator(bytes32 priceIdentifier)\\n    public\\n    view\\n    override\\n    returns (AggregatorV3Interface aggregator)\\n  {\\n    aggregator = aggregators[priceIdentifier];\\n    require(\\n      address(aggregator) != address(0),\\n      'Price identifier does not exist'\\n    );\\n  }\\n\\n  //----------------------------------------\\n  // Internal view functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Get last chainlink oracle data for a given price identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @return oracleData Oracle data\\n   */\\n  function _getOracleLatestRoundData(bytes32 priceIdentifier)\\n    internal\\n    view\\n    returns (OracleData memory oracleData)\\n  {\\n    AggregatorV3Interface aggregator = getAggregator(priceIdentifier);\\n    (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    ) = aggregator.latestRoundData();\\n    uint8 decimals = aggregator.decimals();\\n    oracleData = OracleData(\\n      roundId,\\n      convertPrice(answer),\\n      startedAt,\\n      updatedAt,\\n      answeredInRound,\\n      decimals\\n    );\\n  }\\n\\n  /**\\n   * @notice Get chainlink oracle data in a given round for a given price identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @param _roundId Round Id\\n   * @return oracleData Oracle data\\n   */\\n  function _getOracleRoundData(bytes32 priceIdentifier, uint80 _roundId)\\n    internal\\n    view\\n    returns (OracleData memory oracleData)\\n  {\\n    AggregatorV3Interface aggregator = getAggregator(priceIdentifier);\\n    (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    ) = aggregator.getRoundData(_roundId);\\n    uint8 decimals = aggregator.decimals();\\n    oracleData = OracleData(\\n      roundId,\\n      convertPrice(answer),\\n      startedAt,\\n      updatedAt,\\n      answeredInRound,\\n      decimals\\n    );\\n  }\\n\\n  //----------------------------------------\\n  // Internal pure functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Covert the price from int to uint and it reverts if negative\\n   * @param uncovertedPrice Price before conversion\\n   * @return price Price after conversion\\n   */\\n\\n  function convertPrice(int256 uncovertedPrice)\\n    internal\\n    pure\\n    returns (uint256 price)\\n  {\\n    require(uncovertedPrice > 0, 'Negative value');\\n    price = uint256(uncovertedPrice);\\n  }\\n\\n  /**\\n   * @notice Covert the price to a integer with 18 decimals\\n   * @param unscaledPrice Price before conversion\\n   * @param decimals Number of decimals of unconverted price\\n   * @return price Price after conversion\\n   */\\n\\n  function getScaledValue(uint256 unscaledPrice, uint8 decimals)\\n    internal\\n    pure\\n    returns (uint256 price)\\n  {\\n    price = unscaledPrice.mul(10**(uint256(18).sub(uint256(decimals))));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IFinder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface ISynthereumFinder {\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IPoolRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface ISynthereumPoolRegistry {\\n  function registerPool(\\n    string calldata syntheticTokenSymbol,\\n    IERC20 collateralToken,\\n    uint8 poolVersion,\\n    address pool\\n  ) external;\\n\\n  function isPoolDeployed(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion,\\n    address pool\\n  ) external view returns (bool isDeployed);\\n\\n  function getPools(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion\\n  ) external view returns (address[] memory);\\n\\n  function getCollaterals() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/common/interfaces/IPoolDeployment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {ISynthereumFinder} from '../../../versioning/interfaces/IFinder.sol';\\n\\ninterface ISynthereumPoolDeployment {\\n  function synthereumFinder() external view returns (ISynthereumFinder finder);\\n\\n  function version() external view returns (uint8 poolVersion);\\n\\n  function collateralToken() external view returns (IERC20 collateralCurrency);\\n\\n  function syntheticToken() external view returns (IERC20 syntheticCurrency);\\n\\n  function syntheticTokenSymbol() external view returns (string memory symbol);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nlibrary SynthereumInterfaces {\\n  bytes32 public constant Deployer = 'Deployer';\\n  bytes32 public constant FactoryVersioning = 'FactoryVersioning';\\n  bytes32 public constant PoolRegistry = 'PoolRegistry';\\n  bytes32 public constant PriceFeed = 'PriceFeed';\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/oracle/chainlink/interfaces/IChainlinkPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\nimport {\\n  AggregatorV3Interface\\n} from '../../../../@chainlink/contracts/v0.6/interfaces/AggregatorV3Interface.sol';\\nimport {ISynthereumPriceFeed} from '../../common/interfaces/IPriceFeed.sol';\\n\\ninterface ISynthereumChainlinkPriceFeed is ISynthereumPriceFeed {\\n  struct OracleData {\\n    uint80 roundId;\\n    uint256 answer;\\n    uint256 startedAt;\\n    uint256 updatedAt;\\n    uint80 answeredInRound;\\n    uint8 decimals;\\n  }\\n\\n  /**\\n   * @notice Set the address of aggregator associated to a pricee identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @param aggregator Address of chainlink proxy aggregator\\n   */\\n  function setAggregator(\\n    bytes32 priceIdentifier,\\n    AggregatorV3Interface aggregator\\n  ) external;\\n\\n  /**\\n   * @notice Remove the address of aggregator associated to a price identifier\\n   * @param priceIdentifier Price feed identifier\\n   */\\n  function removeAggregator(bytes32 priceIdentifier) external;\\n\\n  /**\\n   * @notice Returns the address of aggregator if exists, otherwise it reverts\\n   * @param priceIdentifier Price feed identifier\\n   * @return aggregator Aggregator associated with price identifier\\n   */\\n  function getAggregator(bytes32 priceIdentifier)\\n    external\\n    view\\n    returns (AggregatorV3Interface aggregator);\\n\\n  /**\\n   * @notice Get last chainlink oracle data for a given price identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @return oracleData Oracle data\\n   */\\n  function getOracleLatestData(bytes32 priceIdentifier)\\n    external\\n    view\\n    returns (OracleData memory oracleData);\\n\\n  /**\\n   * @notice Get chainlink oracle price in a given round for a given price identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @param _roundId Round Id\\n   * @return price Oracle price\\n   */\\n  function getRoundPrice(bytes32 priceIdentifier, uint80 _roundId)\\n    external\\n    view\\n    returns (uint256 price);\\n\\n  /**\\n   * @notice Get chainlink oracle data in a given round for a given price identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @param _roundId Round Id\\n   * @return oracleData Oracle data\\n   */\\n  function getOracleRoundData(bytes32 priceIdentifier, uint80 _roundId)\\n    external\\n    view\\n    returns (OracleData memory oracleData);\\n}\\n\"\r\n    },\r\n    \"contracts/@chainlink/contracts/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../utils/EnumerableSet.sol';\\nimport '../utils/Address.sol';\\nimport '../GSN/Context.sol';\\n\\nabstract contract AccessControl is Context {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using Address for address;\\n\\n  struct RoleData {\\n    EnumerableSet.AddressSet members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  event RoleGranted(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  event RoleRevoked(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  function hasRole(bytes32 role, address account) public view returns (bool) {\\n    return _roles[role].members.contains(account);\\n  }\\n\\n  function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n    return _roles[role].members.length();\\n  }\\n\\n  function getRoleMember(bytes32 role, uint256 index)\\n    public\\n    view\\n    returns (address)\\n  {\\n    return _roles[role].members.at(index);\\n  }\\n\\n  function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  function grantRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to grant'\\n    );\\n\\n    _grantRole(role, account);\\n  }\\n\\n  function revokeRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to revoke'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function renounceRole(bytes32 role, address account) public virtual {\\n    require(\\n      account == _msgSender(),\\n      'AccessControl: can only renounce roles for self'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (_roles[role].members.add(account)) {\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (_roles[role].members.remove(account)) {\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/oracle/common/interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface ISynthereumPriceFeed {\\n  /**\\n   * @notice Get last chainlink oracle price for a given price identifier\\n   * @param priceIdentifier Price feed identifier\\n   * @return price Oracle price\\n   */\\n  function getLatestPrice(bytes32 priceIdentifier)\\n    external\\n    view\\n    returns (uint256 price);\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary EnumerableSet {\\n  struct Set {\\n    bytes32[] _values;\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      bytes32 lastvalue = set._values[lastIndex];\\n\\n      set._values[toDeleteIndex] = lastvalue;\\n\\n      set._indexes[lastvalue] = toDeleteIndex + 1;\\n\\n      set._values.pop();\\n\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _contains(Set storage set, bytes32 value)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    require(set._values.length > index, 'EnumerableSet: index out of bounds');\\n    return set._values[index];\\n  }\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  function remove(Bytes32Set storage set, bytes32 value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, value);\\n  }\\n\\n  function contains(Bytes32Set storage set, bytes32 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, value);\\n  }\\n\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(Bytes32Set storage set, uint256 index)\\n    internal\\n    view\\n    returns (bytes32)\\n  {\\n    return _at(set._inner, index);\\n  }\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function remove(AddressSet storage set, address value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function contains(AddressSet storage set, address value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(AddressSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return address(uint256(_at(set._inner, index)));\\n  }\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  function contains(UintSet storage set, uint256 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(UintSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return uint256(_at(set._inner, index));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.8.0;\\n\\nlibrary Address {\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(\\n      success,\\n      'Address: unable to send value, recipient may have reverted'\\n    );\\n  }\\n\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return functionCall(target, data, 'Address: low-level call failed');\\n  }\\n\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        'Address: low-level call with value failed'\\n      );\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance >= value,\\n      'Address: insufficient balance for call'\\n    );\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(target, data, 'Address: low-level static call failed');\\n  }\\n\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), 'Address: static call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      if (returndata.length > 0) {\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this;\\n    return msg.data;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"_synthereumFinder\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maintainer\",\"type\":\"address\"}],\"internalType\":\"struct SynthereumChainlinkPriceFeed.Roles\",\"name\":\"_roles\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"}],\"name\":\"RemoveAggregator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"SetAggregator\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAINTAINER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"}],\"name\":\"getAggregator\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"aggregator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"}],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"}],\"name\":\"getOracleLatestData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"uint256\",\"name\":\"answer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct ISynthereumChainlinkPriceFeed.OracleData\",\"name\":\"oracleData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getOracleRoundData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"uint256\",\"name\":\"answer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct ISynthereumChainlinkPriceFeed.OracleData\",\"name\":\"oracleData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"}],\"name\":\"removeAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"setAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synthereumFinder\",\"outputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SynthereumChainlinkPriceFeed","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d451de78e297b496ee8a4f06dcf991c17580b452000000000000000000000000128c8e20dd4f2d8519dd605632660686ba35d21200000000000000000000000010d7c10a2f25ba6212968d8918eb687d589c6e0a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}