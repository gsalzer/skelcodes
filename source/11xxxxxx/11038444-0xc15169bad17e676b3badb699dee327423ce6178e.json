{"status":"1","message":"OK","result":[{"SourceCode":"/*\n * Origin Protocol\n * https://originprotocol.com\n *\n * Released under the MIT license\n * https://github.com/OriginProtocol/origin-dollar\n *\n * Copyright 2020 Origin Protocol, Inc\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n// File: contracts/interfaces/uniswap/IUniswapV2Pair.sol\n\npragma solidity 0.5.11;\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function sync() external;\n}\n\n// File: contracts/oracle/UniswapLib.sol\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.5.11;\n\n// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << 112) / denominator);\n    }\n\n    // decode a uq112x112 into a uint with 18 decimals of precision\n    function decode112with18(uq112x112 memory self)\n        internal\n        pure\n        returns (uint256)\n    {\n        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\n        // instead, get close to:\n        //  (x * 1e18) >> 112\n        // without risk of overflowing, e.g.:\n        //  (x) / 2 ** (112 - lg(1e18))\n        return uint256(self._x) / 5192296858534827;\n    }\n}\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2**32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(address pair)\n        internal\n        view\n        returns (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint32 blockTimestamp\n        )\n    {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        ) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative +=\n                uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n                timeElapsed;\n            // counterfactual\n            price1Cumulative +=\n                uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n                timeElapsed;\n        }\n    }\n}\n\n// File: contracts/interfaces/IPriceOracle.sol\n\npragma solidity 0.5.11;\n\ninterface IPriceOracle {\n    /**\n     * @dev returns the asset price in USD, 6 decimal digits.\n     * Compatible with the Open Price Feed.\n     */\n    function price(string calldata symbol) external view returns (uint256);\n}\n\n// File: contracts/interfaces/IEthUsdOracle.sol\n\npragma solidity 0.5.11;\n\ninterface IEthUsdOracle {\n    /**\n     * @notice Returns ETH price in USD.\n     * @return Price in USD with 6 decimal digits.\n     */\n    function ethUsdPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns token price in USD.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in USD with 6 decimal digits.\n     */\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the asset price in ETH.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in ETH with 8 decimal digits.\n     */\n    function tokEthPrice(string calldata symbol) external returns (uint256);\n}\n\ninterface IViewEthUsdOracle {\n    /**\n     * @notice Returns ETH price in USD.\n     * @return Price in USD with 6 decimal digits.\n     */\n    function ethUsdPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns token price in USD.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in USD with 6 decimal digits.\n     */\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the asset price in ETH.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in ETH with 8 decimal digits.\n     */\n    function tokEthPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n}\n\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/governance/Governable.sol\n\npragma solidity 0.5.11;\n\n/**\n * @title OUSD Governable Contract\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Origin Protocol Inc\n */\ncontract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    bytes32\n        private constant governorPosition = 0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n    //keccak256(\"OUSD.governor\");\n\n    bytes32\n        private constant pendingGovernorPosition = 0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n    //keccak256(\"OUSD.pending.governor\");\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial Governor.\n     */\n    constructor() internal {\n        _setGovernor(msg.sender);\n        emit GovernorshipTransferred(address(0), _governor());\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        bytes32 position = governorPosition;\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @dev Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        emit GovernorshipTransferred(_governor(), _newGovernor);\n        _setGovernor(_newGovernor);\n    }\n}\n\n// File: contracts/governance/InitializableGovernable.sol\n\npragma solidity 0.5.11;\n\n/**\n * @title OUSD InitializableGovernable Contract\n * @author Origin Protocol Inc\n */\n\ncontract InitializableGovernable is Governable, Initializable {\n    function _initialize(address _governor) internal {\n        _changeGovernor(_governor);\n    }\n}\n\n// File: contracts/oracle/OpenUniswapOracle.sol\n\npragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\n/**\n * @title OUSD OpenUniswapOracle Contract\n * @author Origin Protocol Inc\n */\n\n\n\n\ncontract OpenUniswapOracle is IEthUsdOracle, InitializableGovernable {\n    using FixedPoint for *;\n    uint256 public constant PERIOD = 2 minutes;\n\n    struct SwapConfig {\n        bool ethOnFirst; // whether the weth is the first in pair\n        address swap; // address of the uniswap pair\n        uint256 blockTimestampLast;\n        uint256 latestBlockTimestampLast;\n        uint256 priceCumulativeLast;\n        uint256 latestPriceCumulativeLast;\n        uint256 baseUnit;\n    }\n\n    mapping(bytes32 => SwapConfig) swaps;\n\n    IPriceOracle public ethPriceOracle; //price oracle for getting the Eth->USD price OPEN oracle..\n    address ethToken;\n    string constant ethSymbol = \"ETH\";\n    bytes32 constant ethHash = keccak256(abi.encodePacked(ethSymbol));\n\n    constructor(address ethPriceOracle_, address ethToken_) public {\n        ethPriceOracle = IPriceOracle(ethPriceOracle_);\n        ethToken = ethToken_;\n    }\n\n    function registerEthPriceOracle(address ethPriceOracle_)\n        public\n        onlyGovernor\n    {\n        ethPriceOracle = IPriceOracle(ethPriceOracle_);\n    }\n\n    function registerPair(address pair_) public onlyGovernor {\n        IUniswapV2Pair pair = IUniswapV2Pair(pair_);\n        address token;\n        bool ethOnFirst = true;\n        if (pair.token0() == ethToken) {\n            token = pair.token1();\n        } else {\n            token = pair.token0();\n            ethOnFirst = false;\n        }\n        SymboledERC20 st = SymboledERC20(token);\n        string memory symbol = st.symbol();\n        SwapConfig storage config = swaps[keccak256(abi.encodePacked(symbol))];\n\n        // is the first token the eth Token\n        config.ethOnFirst = ethOnFirst;\n        config.swap = pair_;\n        config.baseUnit = uint256(10)**st.decimals();\n\n        // we want everything relative to first\n        config.priceCumulativeLast = currentCumulativePrice(config);\n        config.blockTimestampLast = block.timestamp;\n        config.latestBlockTimestampLast = config.blockTimestampLast;\n        config.latestPriceCumulativeLast = config.priceCumulativeLast;\n    }\n\n    function currentCumulativePrice(SwapConfig storage config)\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            uint256 cumulativePrice0,\n            uint256 cumulativePrice1,\n\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(config.swap);\n        if (config.ethOnFirst) {\n            return cumulativePrice1;\n        } else {\n            return cumulativePrice0;\n        }\n    }\n\n    // This needs to be called regularly to update the pricing window\n    function pokePriceWindow(SwapConfig storage config)\n        internal\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 priceCumulative = currentCumulativePrice(config);\n\n        uint256 timeElapsed = block.timestamp - config.latestBlockTimestampLast;\n\n        if (timeElapsed >= PERIOD) {\n            config.blockTimestampLast = config.latestBlockTimestampLast;\n            config.priceCumulativeLast = config.latestPriceCumulativeLast;\n\n            config.latestBlockTimestampLast = block.timestamp;\n            config.latestPriceCumulativeLast = priceCumulative;\n        }\n\n        return (\n            priceCumulative,\n            config.priceCumulativeLast,\n            config.blockTimestampLast\n        );\n    }\n\n    // update to the latest window\n    function updatePriceWindows(bytes32[] calldata symbolHashes) external {\n        for (uint256 i = 0; i < symbolHashes.length; i++) {\n            SwapConfig storage config = swaps[symbolHashes[i]];\n            pokePriceWindow(config);\n        }\n    }\n\n    //eth to usd price\n    //precision from open is 6\n    function ethUsdPrice() external view returns (uint256) {\n        return ethPriceOracle.price(ethSymbol); // grab the eth price from the open oracle\n    }\n\n    //tok to Usd price\n    //Note: for USDC and USDT this is fixed to 1 on openoracle\n    // precision here is 8\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256)\n    {\n        return ethPriceOracle.price(symbol); // grab the eth price from the open oracle\n    }\n\n    //tok to Eth price\n    function tokEthPrice(string calldata symbol) external returns (uint256) {\n        bytes32 tokenSymbolHash = keccak256(abi.encodePacked(symbol));\n        SwapConfig storage config = swaps[tokenSymbolHash];\n        (\n            uint256 priceCumulative,\n            uint256 priceCumulativeLast,\n            uint256 blockTimestampLast\n        ) = pokePriceWindow(config);\n\n        require(\n            priceCumulative > priceCumulativeLast,\n            \"There has been no cumulative change\"\n        );\n        // This should be impossible, but better safe than sorry\n        require(\n            block.timestamp > blockTimestampLast,\n            \"now must come after before\"\n        );\n        uint256 timeElapsed = block.timestamp - blockTimestampLast;\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            uint224(\n                (priceCumulative - config.priceCumulativeLast) / timeElapsed\n            )\n        );\n        uint256 rawUniswapPriceMantissa = priceAverage.decode112with18();\n\n        // Divide by 1e28 because it's decoded to 18 and then we want 8 decimal places of precision out so 18+18-8\n        return mul(rawUniswapPriceMantissa, config.baseUnit) / 1e28;\n    }\n\n    // This actually calculate the latest price from outside oracles\n    // It's a view but substantially more costly in terms of calculation\n    function price(string calldata symbol) external view returns (uint256) {\n        bytes32 tokenSymbolHash = keccak256(abi.encodePacked(symbol));\n        uint256 ethPrice = ethPriceOracle.price(ethSymbol); // grab the eth price from the open oracle\n\n        if (ethHash == tokenSymbolHash) {\n            return ethPrice;\n        } else {\n            SwapConfig storage config = swaps[tokenSymbolHash];\n            uint256 priceCumulative = currentCumulativePrice(config);\n\n            require(\n                priceCumulative > config.priceCumulativeLast,\n                \"There has been no cumulative change\"\n            );\n            // This should be impossible, but better safe than sorry\n            require(\n                block.timestamp > config.blockTimestampLast,\n                \"now must come after before\"\n            );\n            uint256 timeElapsed = block.timestamp - config.blockTimestampLast;\n\n            // overflow is desired, casting never truncates\n            // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n            FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (priceCumulative - config.priceCumulativeLast) / timeElapsed\n                )\n            );\n            uint256 rawUniswapPriceMantissa = priceAverage.decode112with18();\n\n            uint256 unscaledPriceMantissa = mul(\n                rawUniswapPriceMantissa,\n                ethPrice\n            );\n\n            return mul(unscaledPriceMantissa, config.baseUnit) / 1e36;\n        }\n    }\n\n    function debugPrice(string calldata symbol)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        bytes32 tokenSymbolHash = keccak256(abi.encodePacked(symbol));\n        uint256 ethPrice = ethPriceOracle.price(ethSymbol); // grab the eth price from the open oracle\n\n        SwapConfig storage config = swaps[tokenSymbolHash];\n        uint256 priceCumulative = currentCumulativePrice(config);\n\n        require(\n            priceCumulative > config.priceCumulativeLast,\n            \"There has been no cumulative change\"\n        );\n        // This should be impossible, but better safe than sorry\n        require(\n            block.timestamp > config.blockTimestampLast,\n            \"now must come after before\"\n        );\n        uint256 timeElapsed = block.timestamp - config.blockTimestampLast;\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            uint224(\n                (priceCumulative - config.priceCumulativeLast) / timeElapsed\n            )\n        );\n        uint256 rawUniswapPriceMantissa = priceAverage.decode112with18();\n\n        uint256 unscaledPriceMantissa = mul(rawUniswapPriceMantissa, ethPrice);\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n\n        return (\n            priceCumulative - config.priceCumulativeLast,\n            timeElapsed,\n            rawUniswapPriceMantissa,\n            unscaledPriceMantissa\n        );\n    }\n\n    function openPrice(string calldata symbol) external view returns (uint256) {\n        return ethPriceOracle.price(symbol);\n    }\n\n    function getSwapConfig(string calldata symbol)\n        external\n        view\n        returns (SwapConfig memory)\n    {\n        bytes32 tokenSymbolHash = keccak256(abi.encodePacked(symbol));\n        return swaps[tokenSymbolHash];\n    }\n\n    /// @dev Overflow proof multiplication\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"multiplication overflow\");\n        return c;\n    }\n}\n\ncontract SymboledERC20 {\n    function symbol() public view returns (string memory);\n\n    function decimals() public view returns (uint8);\n}\n","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"tokEthPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"debugPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"tokUsdPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethPriceOracle_\",\"type\":\"address\"}],\"name\":\"registerEthPriceOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getSwapConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ethOnFirst\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"swap\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestampLast\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestBlockTimestampLast\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceCumulativeLast\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestPriceCumulativeLast\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"}],\"internalType\":\"struct OpenUniswapOracle.SwapConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"symbolHashes\",\"type\":\"bytes32[]\"}],\"name\":\"updatePriceWindows\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethUsdPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethPriceOracle\",\"outputs\":[{\"internalType\":\"contract IPriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"openPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"transferGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair_\",\"type\":\"address\"}],\"name\":\"registerPair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethPriceOracle_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ethToken_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"PendingGovernorshipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorshipTransferred\",\"type\":\"event\"}]","ContractName":"OpenUniswapOracle","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000922018674c12a7f0d394ebeef9b58f186cde13c1000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}