//SPDX-License-Identifier: UNLICENSED

// Solidity files have to start with this pragma.
// It will be used by the Solidity compiler to validate its version.
pragma solidity >0.6.1 <0.7.0;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/GSN/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "./BullrunBabesOracle.sol";
import "./BullrunBabesToken.sol";
import "./BullrunBabesInterfaces.sol";

contract BullrunBabesCoordinator is
    Context,
    AccessControl,
    ReentrancyGuard,
    BullrunBabesCoordinatorIAdmin
{
    using SafeMath for uint256;
    using Counters for Counters.Counter;
    using EnumerableSet for EnumerableSet.UintSet;

    struct CardType {
        uint256 typeId;
        string cid;
        uint256 tier;
        Counters.Counter serialCounter;
    }

    struct Card {
        uint256 typeId;
        uint256 serial;
    }

    bytes32 public constant OWNER_ROLE = keccak256("OWNER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE");

    // amount of ether to send to the oracle
    // remaining ether will be sent back to us
    uint256 private oracleFee = 0.2 ether;
    // amount of gas to pass to the oracle to make the provable query
    uint256 private oracleGas = 300000;

    uint256[][] private combinedPoolAllocation;
    uint256[] private tradeUpThresholds;

    // typeId -> CardType
    mapping(uint256 => CardType) private _types;
    uint256 private typeCount;

    Counters.Counter private _tokenIdTracker;
    // token -> card

    mapping(uint256 => Card) private _cards;

    struct TradeUp {
        address recipient;
        uint256[] tokens;
        uint256 newTier;
        uint256 tradeCost;
    }

    struct Draw {
        address recipient;
        uint256 drawCost;
    }

    address[] private splitAddresses;
    uint8[] private splitPercentage;

    // queryId -> Draw
    mapping(bytes32 => Draw) public _inflightDraws;

    // queryId -> TradeUp
    mapping(bytes32 => TradeUp) public _inflightTrades;

    uint256[] private _poolMax;

    BullrunBabesOracleI private oracle;
    BullrunBabesToken private brbToken;

    uint256[][] private curveVars;

    function _getPriceWithSupply(uint256 total) private view returns (uint256) {
        uint256 threshold;
        uint256 x;
        uint256 y;
        uint256 alg;
        for (uint256 i = 0; i < curveVars.length; i++) {
            threshold = curveVars[i][0];
            x = curveVars[i][1];
            y = curveVars[i][2];
            alg = curveVars[i][3]; // 0: price=y/(x-draw)
            if (total < threshold) {
                if (alg == 0) {
                    // 0: price=y/(x-draw)
                    return y.div(x.sub(total));
                } else if (alg == 1) {
                    // 1: price = x - (y / draw)
                    return x.sub(y.div(total));
                } else {
                    // 2: price = x
                    return x;
                }
            }
        }
        if (alg == 0) {
            // 0: price=y/(x-draw)
            return y.div(x.sub(total));
        } else if (alg == 1) {
            // 1: price = x - (y / draw)
            return x.sub(y.div(total));
        } else {
            // 2: price = x
            return x;
        }
    }

    function getPrice(uint256 reserve) public view override returns (uint256) {
        uint256 total = _tokenIdTracker.current();
        return _getPriceWithSupply(total + reserve);
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        BullrunBabesOracleI _oracle,
        BullrunBabesToken _token,
        address[] memory _splitAddresses,
        uint8[] memory _splitPercentage
    ) public {
        require(address(_oracle) != address(0));
        require(address(_token) != address(0));
        require(_splitAddresses.length == _splitPercentage.length);

        uint8 sum = 0;
        for (uint8 i = 0; i < _splitPercentage.length; i++) {
            sum += _splitPercentage[i];
        }

        require(sum == 100);

        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(OWNER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
        _setupRole(ORACLE_ROLE, _msgSender());

        oracle = _oracle;
        brbToken = _token;
        splitAddresses = _splitAddresses;
        splitPercentage = _splitPercentage;
    }

    // allow changing of oracles
    function setOracle(BullrunBabesOracleI _oracle) public {
        require(hasRole(OWNER_ROLE, _msgSender()), "Not Owner");
        require(address(_oracle) != address(0));
        oracle = _oracle;
    }

    function getOracleGasFee() public view override returns (uint256, uint256) {
        require(hasRole(OWNER_ROLE, _msgSender()), "Not Owner");
        return (oracleGas, oracleFee);
    }

    function setOracleGasFee(uint256 _gas, uint256 _fee) public override {
        require(hasRole(OWNER_ROLE, _msgSender()), "Not Owner");
        oracleGas = _gas;
        oracleFee = _fee;
    }

    function initCardTypes(
        string[] calldata _typeCids,
        uint256[] calldata _typeTiers
    ) external {
        require(hasRole(OWNER_ROLE, _msgSender()), "Not Owner");
        require(_typeCids.length == _typeTiers.length);
        // incoming types MUST be higher or same
        // already checked that _typeCids and _typeTiers are of same length
        require(_typeCids.length >= typeCount);

        // loop through existing to ensure that they are the same
        for (uint256 i = 0; i < typeCount; i++) {
            require(_types[i].typeId == i);
            require(
                keccak256(bytes(_types[i].cid)) ==
                    keccak256(bytes(_typeCids[i]))
            );
            require(_types[i].tier == _typeTiers[i]);
        }
        // copy over new values
        for (uint256 i = typeCount; i < _typeCids.length; i++) {
            _types[i] = CardType({
                typeId: i,
                cid: _typeCids[i],
                tier: _typeTiers[i],
                serialCounter: Counters.Counter({_value: 0})
            });
        }
        // set new typeCount
        typeCount = _typeCids.length;
    }

    struct ExistingCard {
        uint256 id;
        uint256 serial;
        uint256 typeId;
    }

    function initExistingCards(ExistingCard[] calldata _existingCards)
        external
    {
        require(hasRole(OWNER_ROLE, _msgSender()), "Not Owner");
        // copy over state of minted cards
        for (uint256 i = 0; i < _existingCards.length; i++) {
            _cards[_existingCards[i].id] = Card({
                typeId: _existingCards[i].typeId,
                serial: _existingCards[i].serial
            });
        }
    }

    function initExistingState(
        uint256[] calldata _cardTypeSerials,
        uint256[][] memory _combinedPoolAllocation,
        uint256 latestTokenId
    ) external {
        require(hasRole(OWNER_ROLE, _msgSender()), "Not Owner");
        require(_cardTypeSerials.length == typeCount);

        // reinitialize the type counts
        for (uint256 i = 0; i < typeCount; i++) {
            _types[i].serialCounter = Counters.Counter({
                _value: _cardTypeSerials[i]
            });
        }

        // copy over existing pool
        combinedPoolAllocation = _combinedPoolAllocation;
        // recalculate pool max since it was updated
        _calculatePoolMax();

        // update tokenIdTracker to latest
        _tokenIdTracker = Counters.Counter({_value: latestTokenId});
    }

    function initAllocation(
        uint256[] calldata _tradeUpThresholds,
        uint256[][] memory _combinedPoolAllocation,
        uint256[][] memory _curveVars
    ) external {
        require(hasRole(OWNER_ROLE, _msgSender()), "Not Owner");
        require(
            _tradeUpThresholds.length == _combinedPoolAllocation.length - 1
        );
        // combined pools are by [drawTier, ...Tiers][type] = count
        // require same or mor tiers
        require(
            _combinedPoolAllocation.length >= combinedPoolAllocation.length
        );

        // set tradeUpThreshold
        tradeUpThresholds = _tradeUpThresholds;

        // verify existing is the same
        for (uint256 tier = 0; tier < combinedPoolAllocation.length; tier++) {
            require(
                _combinedPoolAllocation[tier].length >=
                    combinedPoolAllocation[tier].length
            );
            for (uint256 c = 0; c < combinedPoolAllocation[tier].length; c++) {
                // any existing allocated values CANNOT be changed
                require(_combinedPoolAllocation[tier][c] == 0);
                // ensure that we use the existing allocation values
                _combinedPoolAllocation[tier][c] = combinedPoolAllocation[tier][
                    c
                ];
            }
        }
        combinedPoolAllocation = _combinedPoolAllocation;

        _calculatePoolMax();

        // no need to initialize _tokenIdTracker since it is always pre-initiated to 0
        // and we never want to reinitialize it

        // set curveVars
        curveVars = _curveVars;
    }

    function cancelRandom(bytes32 _queryId, bool refundOracleFees)
        public
        payable
        override
        nonReentrant
    {
        require(hasRole(OWNER_ROLE, _msgSender()), "Not Owner");
        return _cancelRandom(_queryId, refundOracleFees);
    }

    function _cancelRandom(bytes32 _queryId, bool refundOracleFees) private {
        if (_inflightDraws[_queryId].recipient != address(0)) {
            uint256 drawCost = _inflightDraws[_queryId].drawCost;
            uint256 amt =
                (refundOracleFees) ? drawCost : drawCost.sub(oracleFee);

            // refund draw cost
            Address.sendValue(payable(_inflightDraws[_queryId].recipient), amt);
            delete (_inflightDraws[_queryId]);
        } else if (_inflightTrades[_queryId].recipient != address(0)) {
            uint256 tradeCost = _inflightTrades[_queryId].tradeCost;
            uint256 amt =
                (refundOracleFees) ? tradeCost : tradeCost.sub(oracleFee);
            // user wanted to trade

            // refund trade cost
            Address.sendValue(
                payable(_inflightTrades[_queryId].recipient),
                amt
            );
            delete (_inflightTrades[_queryId]);
        } else {
            revert("No outstanding queries for ID");
        }
    }

    function checkInflight(bytes32[] memory _queryIds)
        external
        view
        override
        returns (bytes32[] memory)
    {
        require(hasRole(OWNER_ROLE, _msgSender()), "Not Owner");

        for (uint256 i = 0; i < _queryIds.length; i++) {
            if (
                _inflightDraws[_queryIds[i]].recipient == address(0) &&
                _inflightTrades[_queryIds[i]].recipient == address(0)
            ) {
                _queryIds[i] = 0;
            }
        }
        return _queryIds;
    }

    event DrawPoolExhausted(
        bytes32 queryId,
        address recipient,
        uint256 drawCost
    );
    event TradePoolExhausted(
        bytes32 queryId,
        address recipient,
        uint256[] tokens,
        uint256 newTier,
        uint256 tradeCost
    );
    event TradeOwnerMismatch(
        bytes32 queryId,
        address recipient,
        uint256[] tokens,
        uint256 newTier,
        uint256 tradeCost
    );

    function handleRandom(uint256 randomNumber, bytes32 _queryId)
        public
        payable
        nonReentrant
    {
        require(hasRole(ORACLE_ROLE, _msgSender()), "Not Oracle");
        emit RandomReceived(_queryId);

        if (_inflightDraws[_queryId].recipient != address(0)) {
            // user wanted to draw
            uint256 poolMax = _getPoolMax(0);

            // if not more cards available, cancel random
            if (poolMax <= 0) {
                emit DrawPoolExhausted(
                    _queryId,
                    _inflightDraws[_queryId].recipient,
                    _inflightDraws[_queryId].drawCost
                );
                _cancelRandom(_queryId, true);
                return;
            }

            uint256 randIdx = randomNumber % poolMax;
            uint256 selectedType = _allocatePool(0, randIdx);
            _mintWithType(
                selectedType,
                _inflightDraws[_queryId].recipient,
                _queryId
            );
            delete (_inflightDraws[_queryId]);
        } else if (_inflightTrades[_queryId].recipient != address(0)) {
            // user wanted to trade
            uint256 poolMax =
                _getPoolMax(_inflightTrades[_queryId].newTier + 1);

            // if not more cards available, cancel random
            if (poolMax <= 0) {
                emit TradePoolExhausted(
                    _queryId,
                    _inflightTrades[_queryId].recipient,
                    _inflightTrades[_queryId].tokens,
                    _inflightTrades[_queryId].newTier,
                    _inflightTrades[_queryId].tradeCost
                );
                _cancelRandom(_queryId, true);
                return;
            }

            uint256 randIdx = randomNumber % poolMax;

            // assume all owned
            bool allOwned = true;
            // loop through all the tokens and ensure that they are all currently owned by the tradeup user
            for (
                uint256 i = 0;
                i < _inflightTrades[_queryId].tokens.length;
                i++
            ) {
                // set all owned to false if any card is not owned by user
                try
                    brbToken.ownerOf(_inflightTrades[_queryId].tokens[i])
                returns (
                    // this raises if the token is already burnt
                    // we treat it as if it is not owned to prevent trading of burnt tokens
                    address owner
                ) {
                    allOwned = owner == _inflightTrades[_queryId].recipient;
                    if (!allOwned) {
                        break;
                    }
                } catch {
                    allOwned = false;
                    break;
                }
            }

            // if not all owned fire event and cancelRandom
            if (!allOwned) {
                emit TradeOwnerMismatch(
                    _queryId,
                    _inflightTrades[_queryId].recipient,
                    _inflightTrades[_queryId].tokens,
                    _inflightTrades[_queryId].newTier,
                    _inflightTrades[_queryId].tradeCost
                );
                // do not refund oracle fees owner tried to transfer a token away during trade
                // or trade burnt cards
                _cancelRandom(_queryId, false);
                return;
            }

            for (
                uint256 i = 0;
                i < _inflightTrades[_queryId].tokens.length;
                i++
            ) {
                brbToken.burn(_inflightTrades[_queryId].tokens[i]);
            }

            uint256 selectedType =
                _allocatePool(_inflightTrades[_queryId].newTier + 1, randIdx);

            _mintWithType(
                selectedType,
                _inflightTrades[_queryId].recipient,
                _queryId
            );
            delete (_inflightTrades[_queryId]);
        } else {
            revert("invalid queryId");
        }
    }

    function tradeUp(uint256[] memory tokens)
        public
        payable
        override
        nonReentrant
    {
        uint256 tradeCost = getPrice(0);
        require(msg.value >= tradeCost, "Not enough ether to trade");
        uint256 excess = msg.value.sub(tradeCost);
        if (excess > 0) {
            Address.sendValue(payable(_msgSender()), excess);
        }

        require(tokens.length > 0, "Requires tokens to trade");
        uint256 firstTier = tierOf(tokens[0]);
        uint256 cardsRequiredForTradeUp = tradeUpThresholds[firstTier];
        require(
            tokens.length == cardsRequiredForTradeUp,
            "10 Golds OR 4 Diamonds"
        );
        address firstOwner = brbToken.ownerOf(tokens[0]);
        require(firstOwner == _msgSender(), "Tokens must all be owned by you.");
        bool tokensTiersMatches = true;
        bool tokensOwnerMatches = true;
        for (uint256 i = 1; i < tokens.length; i++) {
            tokensTiersMatches = firstTier == tierOf(tokens[i]);
            tokensOwnerMatches = firstOwner == brbToken.ownerOf(tokens[i]);
            if (!tokensTiersMatches || !tokensOwnerMatches) {
                // short circuit if any tokens mismatch
                break;
            }
        }
        require(
            tokensTiersMatches,
            "All tokens provided must be of the same tier"
        );
        require(tokensOwnerMatches, "Tokens must all be owned by you.");
        uint256 newTier = firstTier + 1;
        require(
            newTier < tradeUpThresholds.length, // new tier still exists within the byte array
            "There must higher tiers to trade up to"
        );

        require(_getPoolMax(newTier + 1) > 0, "Exhausted");

        bytes32 queryId =
            oracle._init_random{value: oracleFee, gas: oracleGas}();

        _inflightTrades[queryId] = TradeUp({
            tokens: tokens,
            recipient: _msgSender(),
            newTier: newTier,
            tradeCost: tradeCost
        });
        emit RandomInitiated(queryId);
    }

    function draw() public payable override nonReentrant {
        require(_getPoolMax(0) > 0, "Exhausted");
        uint256 drawCost = getPrice(0);
        require(msg.value >= drawCost, "Not enough ether to draw");
        uint256 excess = msg.value.sub(drawCost);
        if (excess > 0) {
            Address.sendValue(payable(_msgSender()), excess);
        }

        bytes32 queryId =
            oracle._init_random{value: oracleFee, gas: oracleGas}();

        _inflightDraws[queryId] = Draw({
            recipient: _msgSender(),
            drawCost: drawCost
        });
        emit RandomInitiated(queryId);
    }

    /* Private allocation functions */
    function _calculatePoolMax() private {
        uint256[] memory poolMax = new uint256[](combinedPoolAllocation.length);
        for (uint256 i = 0; i < combinedPoolAllocation.length; i++) {
            uint256 max = 0;
            for (uint256 j = 0; j < combinedPoolAllocation[i].length; j++) {
                max += combinedPoolAllocation[i][j];
            }
            poolMax[i] = max;
        }
        _poolMax = poolMax;
    }

    function _getPoolMax(uint256 tierOrDrawIdx) private view returns (uint256) {
        return _poolMax[tierOrDrawIdx];
    }

    function _allocatePool(uint256 tierOrDrawIdx, uint256 idx)
        private
        returns (uint256)
    {
        uint256 curIdx = 0;
        for (
            uint256 i = 0;
            i < combinedPoolAllocation[tierOrDrawIdx].length;
            i++
        ) {
            if (idx < curIdx + combinedPoolAllocation[tierOrDrawIdx][i]) {
                combinedPoolAllocation[tierOrDrawIdx][i]--;
                _poolMax[tierOrDrawIdx]--;
                return i;
            }
            curIdx += combinedPoolAllocation[tierOrDrawIdx][i];
        }
        revert("Exhausted");
    }

    function _mintWithType(
        uint256 cardTypeId,
        address recipient,
        bytes32 queryId
    ) private {
        require(bytes(_types[cardTypeId].cid).length != 0, "Invalid type");
        require(recipient != address(this), "Contract cannot own cards");

        Counters.Counter storage serialCounter =
            _types[cardTypeId].serialCounter;
        uint256 curId = _tokenIdTracker.current();
        brbToken.mint(recipient, curId);
        _cards[curId] = Card({
            typeId: cardTypeId,
            serial: serialCounter.current()
        });
        _tokenIdTracker.increment();
        serialCounter.increment();

        emit CardAllocated(
            recipient,
            curId,
            _cards[curId].serial,
            cardTypeId,
            _types[cardTypeId].tier,
            _types[cardTypeId].cid,
            queryId
        );
    }

    /* PUBLIC ADMIN ONLY */
    function withdraw() public payable override nonReentrant {
        require(
            hasRole(OWNER_ROLE, _msgSender()),
            "must have owner role to withdraw"
        );
        uint256 remainder = (address(this).balance);
        uint256 division = remainder.div(100);
        for (uint8 i = 0; i < splitAddresses.length; i++) {
            // if at last address send the remainder
            if (i == splitAddresses.length - 1) {
                Address.sendValue(payable(splitAddresses[i]), remainder);
            } else {
                uint256 alloc = division.mul(splitPercentage[i]);
                Address.sendValue(payable(splitAddresses[i]), alloc);
                remainder -= alloc;
            }
        }
    }

    /* Public Getters */
    function getAllocations()
        public
        view
        override
        returns (uint256[][] memory)
    {
        return combinedPoolAllocation;
    }

    function getCard(uint256 id)
        public
        view
        override
        returns (CardView memory)
    {
        Card storage card = _cards[id];
        CardType storage cardType = _types[card.typeId];
        uint256 cardTypeCurrentSerial = cardType.serialCounter.current();
        return
            CardView({
                id: id,
                serial: card.serial,
                cid: cardType.cid,
                tier: cardType.tier,
                cardTypeId: card.typeId,
                currentSerialForType: cardTypeCurrentSerial
            });
    }

    function tierOfType(uint256 typeId) public view returns (uint256) {
        return _types[typeId].tier;
    }

    function cardTypeOf(uint256 tokenId) public view returns (uint256) {
        return _cards[tokenId].typeId;
    }

    function tierOf(uint256 tokenId) public view returns (uint256) {
        return tierOfType(cardTypeOf(tokenId));
    }
}

