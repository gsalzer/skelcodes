// SPDX-License-Identifier: MIT
pragma solidity >=0.7.3;

import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721BurnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";

/**
 * @title Prime NFT V1
 *
 * @author The VP Team
 * @notice ERC721 Token Contract
 */
contract PrimeNft is Initializable, ContextUpgradeable, AccessControlUpgradeable, ERC721BurnableUpgradeable, ERC721PausableUpgradeable {
  using SafeMathUpgradeable for uint256;
  using CountersUpgradeable for CountersUpgradeable.Counter;

  /**
   * @dev Initializer function.
   *
   */
  function initialize(string memory _name, string memory _symbol) public virtual initializer {
    __PrimeNft_init(_name, _symbol);
  }
  using CountersUpgradeable for CountersUpgradeable.Counter;

  bytes32 public constant CREATOR_ROLE = keccak256("CREATOR_ROLE");
  bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

  CountersUpgradeable.Counter private _tokenIdTracker;

  // Event indicating a token's URI was updated.
  event TokenURIUpdated(uint256 indexed _tokenId, string  _uri);

  // Mapping from token ID to the creator's address.
  mapping(uint256 => address) private tokenCreators;

  /**
    * @dev Grants `DEFAULT_ADMIN_ROLE`, `CREATOR_ROLE` and `PAUSER_ROLE` to the
    * account that deploys the contract.
    *
    * Token URIs will be autogenerated based on `baseURI` and their token IDs.
    * See {ERC721-tokenURI}.
    */
  function __PrimeNft_init(string memory _name, string memory _symbol) internal initializer {
      __Context_init_unchained();
      __AccessControl_init_unchained();
      __ERC165_init_unchained();
      __ERC721_init_unchained(_name, _symbol);
      __ERC721Burnable_init_unchained();
      __Pausable_init_unchained();
      __ERC721Pausable_init_unchained();
      __PrimeNft_init_unchained();
  }

  function __PrimeNft_init_unchained() internal initializer {
      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

      _setupRole(CREATOR_ROLE, _msgSender());
      _setupRole(PAUSER_ROLE, _msgSender());
      // start at ID 1, not 0
      _tokenIdTracker.increment();
  }


  /**
    * @dev Checks that the token is owned by the sender.
    * @param _tokenId uint256 ID of the token.
    */
  modifier onlyTokenOwner(uint256 _tokenId) {
    address tokenOwner = ownerOf(_tokenId);
    require(tokenOwner == msg.sender, "must be the owner of the token");
    _;
  }

  /**
    * @dev Checks that the token was created by the sender.
    * @param _tokenId uint256 ID of the token.
    */
  modifier onlyTokenCreator(uint256 _tokenId) {
    address creator = tokenCreator(_tokenId);
    require(creator == msg.sender, "must be the creator of the token");
    _;
  }

  /**
    * @dev Permanantly deletes the token with the provided ID.
    * @param _tokenId uint256 ID of the token.
    */
  function burnToken(uint256 _tokenId) public onlyTokenOwner(_tokenId) {
    _burn(_tokenId);
  }

  /**
    * @dev Updates the token metadata if the owner is also the
    *      creator.
    * @param _tokenId uint256 ID of the token.
    * @param _tokenURI string metadata URI.
    */
  function updateTokenURI(uint256 _tokenId, string memory _tokenURI)
    public
    onlyTokenOwner(_tokenId)
    onlyTokenCreator(_tokenId)
  {
    _setTokenURI(_tokenId, _tokenURI);
    emit TokenURIUpdated(_tokenId, _tokenURI);
  }

  /**
  * @dev Gets the creator of the token.
  * @param _tokenId uint256 ID of the token.
  * @return address of the creator.
  */
  function tokenCreator(uint256 _tokenId) public view returns (address) {
    return tokenCreators[_tokenId];
  }

  /**
    * @dev Internal function for setting the token's creator.
    * @param _tokenId uint256 id of the token.
    * @param _creator address of the creator of the token.
    */
  function _setTokenCreator(uint256 _tokenId, address _creator) internal {
    tokenCreators[_tokenId] = _creator;
  }

  /**
    * @dev Internal minting function; only the owner may call.
    *
    * @param _creator The token's creator.
    * @param _to The token's owner.
    * @param _tokenURI The URI for the token's metadata.
    */
  function _createToken(string memory _tokenURI, address _to, address _creator) internal returns (uint256 newTokenId) {
    newTokenId = _tokenIdTracker.current();
    super._safeMint(_to, newTokenId);
    super._setTokenURI(newTokenId, _tokenURI);
    _setTokenCreator(newTokenId, _creator);
    _tokenIdTracker.increment();
    return newTokenId;
  }

  /**
    * @dev Public minting function; must have CREATOR_ROLE to call.
    *
    * @param _tokenURI The URI for the token's metadata.
    */
  function createToken(string memory _tokenURI) public returns (uint256 newTokenId) {
    require(hasRole(CREATOR_ROLE, _msgSender()), "Must have creator role to create tokens");
    newTokenId = _createToken(_tokenURI, msg.sender, msg.sender);
    return newTokenId;
  }

  /**
    * @dev Public minting function; must have CREATOR_ROLE to call.
    *      Mints token directly to a specific address.
    *
    * @param _tokenURI The URI for the token's metadata.
    * @param _to The token's owner.
    */

  function createToken(string memory _tokenURI, address _to) public returns (uint256 newTokenId) {
    require(hasRole(CREATOR_ROLE, _msgSender()), "Must have creator role to create tokens");
    newTokenId = _createToken(_tokenURI, _to, msg.sender);
    return newTokenId;
  }

  /**
    * @dev Pauses all token transfers.
    *
    * See {ERC721Pausable} and {Pausable-_pause}.
    *
    * Requirements:
    *
    * - the caller must have the `PAUSER_ROLE`.
    */
  function pause() public virtual {
    require(hasRole(PAUSER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have pauser role to pause");
    super._pause();
  }

  /**
    * @dev Unpauses all token transfers.
    *
    * See {ERC721Pausable} and {Pausable-_unpause}.
    *
    * Requirements:
    *
    * - the caller must have the `PAUSER_ROLE`.
    */
  function unpause() public virtual {
    require(hasRole(PAUSER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have pauser role to pause");
    super._unpause();
  }

  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721Upgradeable, ERC721PausableUpgradeable) {
    super._beforeTokenTransfer(from, to, tokenId);
  }
  uint256[49] private __gap;
}
 
