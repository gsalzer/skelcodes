{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.7;\r\n\r\ninterface DenyLike {\r\n    function deny(address) external;\r\n}\r\n\r\ninterface FileLike {\r\n    function file(bytes32, uint256) external;\r\n}\r\n\r\ninterface FileIlkLike {\r\n    function file(bytes32, bytes32, uint256) external;\r\n}\r\n\r\n// Perform linear interpolation on a dss administrative value over time\r\n\r\nabstract contract BaseLerp {\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; }\r\n    function deny(address usr) external auth { wards[usr] = 0; }\r\n    modifier auth { require(wards[msg.sender] == 1); _; }\r\n\r\n    uint256 constant WAD = 10 ** 18;\r\n\r\n    address immutable public target;\r\n    bytes32 immutable public what;\r\n    uint256 immutable public start;\r\n    uint256 immutable public end;\r\n    uint256 immutable public duration;\r\n\r\n    bool public started;\r\n    bool public done;\r\n    uint256 public startTime;\r\n    \r\n    constructor(address target_, bytes32 what_, uint256 start_, uint256 end_, uint256 duration_) public {\r\n        require(duration_ != 0, \"Lerp/no-zero-duration\");\r\n        require(duration_ <= 365 days, \"Lerp/max-duration-one-year\");\r\n        // This is not the exact upper bound, but it's a practical one\r\n        // Ballparked from 2^256 / 10^18 and verified that this is less than that value\r\n        require(start_ <= 10 ** 59, \"Lerp/start-too-large\");\r\n        require(end_ <= 10 ** 59, \"Lerp/end-too-large\");\r\n        target = target_;\r\n        what = what_;\r\n        start = start_;\r\n        end = end_;\r\n        duration = duration_;\r\n        started = false;\r\n        done = false;\r\n        wards[msg.sender] = 1;\r\n    }\r\n\r\n    function init() external auth {\r\n        require(!started, \"Lerp/already-started\");\r\n        require(!done, \"Lerp/finished\");\r\n        update(start);\r\n        startTime = block.timestamp;\r\n        started = true;\r\n    }\r\n\r\n    function tick() external {\r\n        require(started, \"Lerp/not-started\");\r\n        require(block.timestamp > startTime, \"Lerp/no-time-elapsed\");\r\n        require(!done, \"Lerp/finished\");\r\n        if (block.timestamp < startTime + duration) {\r\n            // All bounds are constrained in the constructor so no need for safe-math\r\n            // 0 <= t < WAD\r\n            uint256 t = (block.timestamp - startTime) * WAD / duration;\r\n            // y = (end - start) * t + start [Linear Interpolation]\r\n            //   = end * t + start - start * t [Avoids overflow by moving the subtraction to the end]\r\n            update(end * t / WAD + start - start * t / WAD);\r\n        } else {\r\n            // Set the end value and de-auth yourself\r\n            update(end);\r\n            DenyLike(target).deny(address(this));\r\n            done = true;\r\n        }\r\n    }\r\n\r\n    function update(uint256 value) virtual internal;\r\n\r\n}\r\n\r\n// Standard Lerp with only a uint256 value\r\n\r\ncontract Lerp is BaseLerp {\r\n\r\n    constructor(address target_, bytes32 what_, uint256 start_, uint256 end_, uint256 duration_) public BaseLerp(target_, what_, start_, end_, duration_) {\r\n    }\r\n\r\n    function update(uint256 value) override internal {\r\n        FileLike(target).file(what, value);\r\n    }\r\n\r\n}\r\n\r\n// Lerp that takes an ilk parameter\r\n\r\ncontract IlkLerp is BaseLerp {\r\n\r\n    bytes32 immutable public ilk;\r\n\r\n    constructor(address target_, bytes32 ilk_, bytes32 what_, uint256 start_, uint256 end_, uint256 duration_) public BaseLerp(target_, what_, start_, end_, duration_) {\r\n        ilk = ilk_;\r\n    }\r\n\r\n    function update(uint256 value) override internal {\r\n        FileIlkLike(target).file(ilk, what, value);\r\n    }\r\n\r\n}\r\n\r\ncontract LerpFactory {\r\n\r\n    function newLerp(address target_, bytes32 what_, uint256 start_, uint256 end_, uint256 duration_) external returns (address) {\r\n        Lerp lerp = new Lerp(target_, what_, start_, end_, duration_);\r\n        lerp.rely(msg.sender);\r\n        lerp.deny(address(this));\r\n        return address(lerp);\r\n    }\r\n\r\n    function newIlkLerp(address target_, bytes32 ilk_, bytes32 what_, uint256 start_, uint256 end_, uint256 duration_) external returns (address) {\r\n        IlkLerp lerp = new IlkLerp(target_, ilk_, what_, start_, end_, duration_);\r\n        lerp.rely(msg.sender);\r\n        lerp.deny(address(this));\r\n        return address(lerp);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"what_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"start_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration_\",\"type\":\"uint256\"}],\"name\":\"newIlkLerp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"what_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"start_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration_\",\"type\":\"uint256\"}],\"name\":\"newLerp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LerpFactory","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5e6450ca8d0d346219bc7c392d3b4fcea812b5ceba7a8cb1a9b98fea4caea45b"}]}