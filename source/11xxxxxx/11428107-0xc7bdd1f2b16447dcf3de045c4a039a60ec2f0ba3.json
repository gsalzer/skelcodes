{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n/// DssAutoLine.sol\r\n\r\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.11;\r\n\r\ninterface VatLike {\r\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\r\n    function Line() external view returns (uint256);\r\n    function file(bytes32, uint256) external;\r\n    function file(bytes32, bytes32, uint256) external;\r\n}\r\n\r\ncontract DssAutoLine {\r\n    /*** Data ***/\r\n    struct Ilk {\r\n        uint256   line;  // Max ceiling possible                                               [rad]\r\n        uint256    gap;  // Max Value between current debt and line to be set                  [rad]\r\n        uint48     ttl;  // Min time to pass before a new increase                             [seconds]\r\n        uint48    last;  // Last block the ceiling was updated                                 [blocks]\r\n        uint48 lastInc;  // Last time the ceiling was increased compared to its previous value [seconds]\r\n    }\r\n\r\n    mapping (bytes32 => Ilk)     public ilks;\r\n    mapping (address => uint256) public wards;\r\n\r\n    VatLike immutable public vat;\r\n\r\n    /*** Events ***/\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n    event Setup(bytes32 indexed ilk, uint256 line, uint256 gap, uint256 ttl);\r\n    event Remove(bytes32 indexed ilk);\r\n    event Exec(bytes32 indexed ilk, uint256 line, uint256 lineNew);\r\n\r\n    /*** Init ***/\r\n    constructor(address vat_) public {\r\n        vat = VatLike(vat_);\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    /*** Math ***/\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    /*** Administration ***/\r\n\r\n    /**\r\n        @dev Add or update an ilk\r\n        @param ilk    Collateral type (ex. ETH-A)\r\n        @param line   Collateral maximum debt ceiling that can be configured [RAD]\r\n        @param gap    Amount of collateral to step [RAD]\r\n        @param ttl    Minimum time between increase [seconds]\r\n    */\r\n    function setIlk(bytes32 ilk, uint256 line, uint256 gap, uint256 ttl) external auth {\r\n        require(ttl  < uint48(-1), \"DssAutoLine/invalid-ttl\");\r\n        require(line > 0,          \"DssAutoLine/invalid-line\");\r\n        ilks[ilk] = Ilk(line, gap, uint48(ttl), 0, 0);\r\n        emit Setup(ilk, line, gap, ttl);\r\n    }\r\n\r\n    /**\r\n        @dev Remove an ilk\r\n        @param ilk    Collateral type (ex. ETH-A)\r\n    */\r\n    function remIlk(bytes32 ilk) external auth {\r\n        delete ilks[ilk];\r\n        emit Remove(ilk);\r\n    }\r\n\r\n    function rely(address usr) external auth {\r\n        wards[usr] = 1;\r\n        emit Rely(usr);\r\n    }\r\n\r\n    function deny(address usr) external auth {\r\n        wards[usr] = 0;\r\n        emit Deny(usr);\r\n    }\r\n\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"DssAutoLine/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    /*** Auto-Line Update ***/\r\n    // @param  _ilk  The bytes32 ilk tag to adjust (ex. \"ETH-A\")\r\n    // @return       The ilk line value as uint256\r\n    function exec(bytes32 _ilk) external returns (uint256) {\r\n        (uint256 Art, uint256 rate,, uint256 line,) = vat.ilks(_ilk);\r\n        uint256 ilkLine = ilks[_ilk].line;\r\n\r\n        // Return if the ilk is not enabled\r\n        if (ilkLine == 0) return line;\r\n\r\n        // 1 SLOAD\r\n        uint48 ilkTtl     = ilks[_ilk].ttl;\r\n        uint48 ilkLast    = ilks[_ilk].last;\r\n        uint48 ilkLastInc = ilks[_ilk].lastInc;\r\n        //\r\n\r\n        // Return if there was already an update in the same block\r\n        if (ilkLast == block.number) return line;\r\n\r\n        // Calculate collateral debt\r\n        uint256 debt = mul(Art, rate);\r\n\r\n        uint256 ilkGap  = ilks[_ilk].gap;\r\n\r\n        // Calculate new line based on the minimum between the maximum line and actual collateral debt + gap\r\n        uint256 lineNew = min(add(debt, ilkGap), ilkLine);\r\n\r\n        // Short-circuit if there wasn't an update or if the time since last increment has not passed\r\n        if (lineNew == line || lineNew > line && block.timestamp < add(ilkLastInc, ilkTtl)) return line;\r\n\r\n        // Set collateral debt ceiling\r\n        vat.file(_ilk, \"line\", lineNew);\r\n        // Set general debt ceiling\r\n        vat.file(\"Line\", add(sub(vat.Line(), line), lineNew));\r\n\r\n        // Update lastInc if it is an increment in the debt ceiling\r\n        // and update last whatever the update is\r\n        if (lineNew > line) {\r\n            // 1 SSTORE\r\n            ilks[_ilk].lastInc = uint48(block.timestamp);\r\n            ilks[_ilk].last    = uint48(block.number);\r\n            //\r\n        } else {\r\n            ilks[_ilk].last    = uint48(block.number);\r\n        }\r\n\r\n        emit Exec(_ilk, line, lineNew);\r\n\r\n        return lineNew;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vat_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lineNew\",\"type\":\"uint256\"}],\"name\":\"Exec\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"Remove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ttl\",\"type\":\"uint256\"}],\"name\":\"Setup\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ilk\",\"type\":\"bytes32\"}],\"name\":\"exec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ilks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gap\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"ttl\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"last\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"lastInc\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"remIlk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ttl\",\"type\":\"uint256\"}],\"name\":\"setIlk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract VatLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DssAutoLine","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"00000000000000000000000035d1b3f3d7966a1dfe207aa4514c12a259a0492b","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2151f36a69d5f41a34c5b2398bf46563bc83844edc55941a9fd66b62e1a0ccf4"}]}