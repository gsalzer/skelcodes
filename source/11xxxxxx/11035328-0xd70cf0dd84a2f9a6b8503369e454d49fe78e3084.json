{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/external/govblocks-protocol/interfaces/IProposalCategory.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IProposalCategory {\r\n\r\n    event Category(\r\n        uint indexed categoryId,\r\n        string categoryName,\r\n        string actionHash\r\n    );\r\n\r\n    mapping(uint256 => bytes) public categoryActionHashes;\r\n\r\n    /**\r\n    * @dev Adds new category\r\n    * @param _name Category name\r\n    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    * @param _closingTime Vote closing time for Each voting layer\r\n    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    * @param _contractAddress address of contract to call after proposal is accepted\r\n    * @param _contractName name of contract to be called after proposal is accepted\r\n    * @param _incentives rewards to distributed after proposal is accepted\r\n    * @param _functionHash function signature to be executed\r\n    */\r\n    function newCategory(\r\n        string calldata _name, \r\n        uint _memberRoleToVote,\r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] calldata _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string calldata _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] calldata _incentives,\r\n        string calldata _functionHash\r\n    )\r\n        external;\r\n\r\n    /** @dev gets category details\r\n    */\r\n    function category(uint _categoryId)\r\n        external\r\n        view\r\n        returns(\r\n            uint categoryId,\r\n            uint memberRoleToVote,\r\n            uint majorityVotePerc,\r\n            uint quorumPerc,\r\n            uint[] memory allowedToCreateProposal,\r\n            uint closingTime,\r\n            uint minStake\r\n        );\r\n    \r\n    /**@dev gets category action details\r\n    */\r\n    function categoryAction(uint _categoryId)\r\n        external\r\n        view\r\n        returns(\r\n            uint categoryId,\r\n            address contractAddress,\r\n            bytes2 contractName,\r\n            uint defaultIncentive\r\n        );\r\n    \r\n    /** @dev Gets Total number of categories added till now\r\n    */\r\n    function totalCategories() external view returns(uint numberOfCategories);\r\n\r\n    /**\r\n     * @dev Gets the category acion details of a category id\r\n     * @param _categoryId is the category id in concern\r\n     * @return the category id\r\n     * @return the contract address\r\n     * @return the contract name\r\n     * @return the default incentive\r\n     * @return action function hash\r\n     */\r\n    function categoryActionDetails(uint256 _categoryId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            address,\r\n            bytes2,\r\n            uint256,\r\n            bytes memory\r\n        );\r\n\r\n    /**\r\n    * @dev Updates category details\r\n    * @param _categoryId Category id that needs to be updated\r\n    * @param _name Category name\r\n    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    * @param _closingTime Vote closing time for Each voting layer\r\n    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    * @param _contractAddress address of contract to call after proposal is accepted\r\n    * @param _contractName name of contract to be called after proposal is accepted\r\n    * @param _incentives rewards to distributed after proposal is accepted\r\n    * @param _functionHash function signature to be executed\r\n    */\r\n    function editCategory(\r\n        uint _categoryId, \r\n        string calldata _name, \r\n        uint _memberRoleToVote, \r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] calldata _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string calldata _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] calldata _incentives,\r\n        string calldata _functionHash\r\n    )\r\n        external;\r\n\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/interfaces/IMemberRoles.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMemberRoles {\r\n\r\n    event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\r\n    \r\n    enum Role {UnAssigned, AdvisoryBoard, TokenHolder, DisputeResolution}\r\n\r\n    function setInititorAddress(address _initiator) external;\r\n\r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function addRole(bytes32 _roleName, string memory _roleDescription, address _authorized) public;\r\n\r\n    /// @dev Assign or Delete a member from specific role.\r\n    /// @param _memberAddress Address of Member\r\n    /// @param _roleId RoleId to update\r\n    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\r\n    function updateRole(address _memberAddress, uint _roleId, bool _active) public;\r\n\r\n    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\r\n    /// @param _roleId roleId to update its Authorized Address\r\n    /// @param _authorized New authorized address against role id\r\n    function changeAuthorized(uint _roleId, address _authorized) public;\r\n\r\n    /// @dev Return number of member roles\r\n    function totalRoles() public view returns(uint256);\r\n\r\n    /// @dev Gets the member addresses assigned by a specific role\r\n    /// @param _memberRoleId Member role id\r\n    /// @return roleId Role id\r\n    /// @return allMemberAddress Member addresses of specified role id\r\n    function members(uint _memberRoleId) public view returns(uint, address[] memory allMemberAddress);\r\n\r\n    /// @dev Gets all members' length\r\n    /// @param _memberRoleId Member role id\r\n    /// @return memberRoleData[_memberRoleId].memberAddress.length Member length\r\n    function numberOfMembers(uint _memberRoleId) public view returns(uint);\r\n    \r\n    /// @dev Return member address who holds the right to add/remove any member from specific role.\r\n    function authorized(uint _memberRoleId) public view returns(address);\r\n\r\n    /// @dev Get All role ids array that has been assigned to a member so far.\r\n    function roles(address _memberAddress) public view returns(uint[] memory assignedRoles);\r\n\r\n    /// @dev Returns true if the given role id is assigned to a member.\r\n    /// @param _memberAddress Address of member\r\n    /// @param _roleId Checks member's authenticity with the roleId.\r\n    /// i.e. Returns true if this roleId is assigned to member\r\n    function checkRole(address _memberAddress, uint _roleId) public view returns(bool);   \r\n}\r\n\r\n// File: contracts/external/proxy/Proxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n            }\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n}\r\n\r\n// File: contracts/external/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param _newImplementation address representing the new implementation to be set\r\n    */\r\n    function _setImplementation(address _newImplementation) internal {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n        sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address _newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor(address _implementation) public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\r\n        require(_newOwner != address(0));\r\n        _setUpgradeabilityOwner(_newOwner);\r\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param _implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address _implementation) public onlyProxyOwner {\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            sstore(position, _newProxyOwner)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/Governed.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMaster {\r\n    mapping(address => bool) public whitelistedSponsor;\r\n    function dAppToken() public view returns(address);\r\n    function isInternal(address _address) public view returns(bool);\r\n    function getLatestAddress(bytes2 _module) public view returns(address);\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool);\r\n}\r\n\r\n\r\ncontract Governed {\r\n\r\n    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\r\n\r\n    /// @dev modifier that allows only the authorized addresses to execute the function\r\n    modifier onlyAuthorizedToGovern() {\r\n        IMaster ms = IMaster(masterAddress);\r\n        require(ms.getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    /// @dev checks if an address is authorized to govern\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool) {\r\n        IMaster ms = IMaster(masterAddress);\r\n        return (ms.getLatestAddress(\"GV\") == _toCheck);\r\n    } \r\n\r\n}\r\n\r\n// File: contracts/interfaces/Iupgradable.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract Iupgradable {\r\n\r\n    /**\r\n     * @dev change master address\r\n     */\r\n    function setMasterAddress() public;\r\n}\r\n\r\n// File: contracts/ProposalCategory.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ProposalCategory is Governed, IProposalCategory, Iupgradable {\r\n    bool public constructorCheck;\r\n    IMemberRoles internal mr;\r\n\r\n    struct CategoryStruct {\r\n        uint256 memberRoleToVote;\r\n        uint256 majorityVotePerc;\r\n        uint256 quorumPerc;\r\n        uint256[] allowedToCreateProposal;\r\n        uint256 closingTime;\r\n        uint256 minStake;\r\n    }\r\n\r\n    struct CategoryAction {\r\n        uint256 defaultIncentive;\r\n        address contractAddress;\r\n        bytes2 contractName;\r\n    }\r\n\r\n    CategoryStruct[] internal allCategory;\r\n    mapping(uint256 => CategoryAction) internal categoryActionData;\r\n    mapping(uint256 => bytes) public categoryActionHashes;\r\n\r\n    bool public initiated;\r\n\r\n    /**\r\n     * @dev Initiates Default settings for Proposal Category contract (Adding default categories)\r\n     */\r\n    function proposalCategoryInitiate() external {\r\n        //solhint-disable-line\r\n        require(!initiated, \"Category action hashes already updated\");\r\n        initiated = true;\r\n\r\n        uint256 advisoryBoardRole = uint256(IMemberRoles.Role.AdvisoryBoard);\r\n        uint256 tokenHolder = uint256(IMemberRoles.Role.TokenHolder);\r\n        uint256 disputeResolutionBoard = uint256(IMemberRoles.Role.DisputeResolution);\r\n\r\n        _addInitialCategories(\"Uncategorized\", \"\", \"EX\", \"\", 0, 0);\r\n        _addInitialCategories(\r\n            \"Add new member role\",\r\n            \"QmQFnBep7AyMYU3LJDuHSpTYatnw65XjHzzirrghtZoR8U\",\r\n            \"MR\",\r\n            \"addRole(bytes32,string,address)\",\r\n            50,\r\n            advisoryBoardRole\r\n        ); //1\r\n        _addInitialCategories(\r\n            \"Update member role\",\r\n            \"QmXMzSViLBJ22P9oj51Zz7isKTRnXWPHZcQ5hzGvvWD3UV\",\r\n            \"MR\",\r\n            \"updateRole(address,uint256,bool)\",\r\n            50,\r\n            advisoryBoardRole\r\n        ); // 2\r\n        _addInitialCategories(\r\n            \"Add new category\",\r\n            \"QmaVtv7NDR36X2ZEBjCmh1ny4UXKYSHPMfg8peuPLnNc3f\",\r\n            \"PC\",\r\n            \"newCategory(string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\",\r\n            50,\r\n            advisoryBoardRole\r\n        ); // 3\r\n        _addInitialCategories(\r\n            \"Edit category\",\r\n            \"QmdmQhGo6hU5HzrNLuoyq2TUh1N3DQ7pT2SkPUhZvnsBYZ\",\r\n            \"PC\",\r\n            \"editCategory(uint256,string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\",\r\n            50,\r\n            advisoryBoardRole\r\n        ); //4\r\n        _addInitialCategories(\r\n            \"Update Market Implementations\",\r\n            \"QmbyrHnGgTU9WWFq7DgtRTdpExLg9MqcFRYpWNpo7Ezjd5\",\r\n            \"PL\",\r\n            \"updateMarketImplementations(uint256[],address[])\",\r\n            60,\r\n            tokenHolder\r\n        ); // 5\r\n        _addInitialCategories(\r\n            \"Update contract's Implementation\",\r\n            \"QmesiuX929bJHmgH8E58L6FWPazcLdgcdjmFzinEdsMfre\",\r\n            \"PL\",\r\n            \"upgradeContractImplementation(address,address)\",\r\n            60,\r\n            tokenHolder\r\n        ); // 6\r\n        _addInitialCategories(\r\n            \"Upgrade multiple contract Implementations\",\r\n            \"QmcL1jUk7oda2cumSUTCrF6vTSeQN7qd1bYDFdz3v7BbUH\",\r\n            \"MS\",\r\n            \"upgradeMultipleImplementations(bytes2[],address[])\",\r\n            50,\r\n            tokenHolder\r\n        ); // 7\r\n        _addInitialCategories(\r\n            \"Update master Implementation\",\r\n            \"QmPrGbWA4cuWzZbc9ZmqFmSRSFJnp5sa747wKsJnQkkj4t\",\r\n            \"MS\",\r\n            \"upgradeTo(address)\",\r\n            50,\r\n            tokenHolder\r\n        ); // 8\r\n        _addInitialCategories(\r\n            \"Add new contract\",\r\n            \"QmXq5Jb4oeNzD2NHBLuWqy2m9J4N1KtkwyirBjkPBRNHii\",\r\n            \"MS\",\r\n            \"addNewContract(bytes2,address)\",\r\n            50,\r\n            tokenHolder\r\n        );\r\n        _addInitialCategories(\r\n            \"Raise Dispute\",\r\n            \"QmQLKazba2dL8nTtGaoon6DsPv5FcpKqWZPRdxLv2tfUQW\",\r\n            \"PL\",\r\n            \"resolveDispute(address,uint256)\",\r\n            60,\r\n            disputeResolutionBoard\r\n        );\r\n        _addInitialCategories(\r\n            \"Burn Dispute Resolution Member Tokens\",\r\n            \"QmTV2xSz5R5LVi9VozCyvNgnguq6xEsfVx7JaFbSatVVvQ\",\r\n            \"TC\",\r\n            \"burnLockedTokens(address,bytes32,uint256)\",\r\n            60,\r\n            tokenHolder\r\n        ); //11\r\n        _addInitialCategories(\r\n            \"Swap AB member\",\r\n            \"QmV5HJMmhkEiHWt5qdNp6AbCqcn9Lw9ASA9efHDKGm8mdh\",\r\n            \"MR\",\r\n            \"swapABMember(address,address)\",\r\n            60,\r\n            tokenHolder\r\n        );\r\n        _addInitialCategories(\r\n            \"Update governance parameters\",\r\n            \"QmTzKKxzpp1E4b8N3ch1kumetYRieEpN7ecTd3MNg4V1T9\",\r\n            \"GV\",\r\n            \"updateUintParameters(bytes8,uint256)\",\r\n            60,\r\n            tokenHolder\r\n        );\r\n        _addInitialCategories(\r\n            \"Update Token Controller parameters\",\r\n            \"QmdVH5FdXbiGbqsj17643KVEEBQ3ciBZnjn9Mj24ehsrGm\",\r\n            \"TC\",\r\n            \"updateUintParameters(bytes8,uint256)\",\r\n            60,\r\n            tokenHolder\r\n        );\r\n        _addInitialCategories(\r\n            \"Add new market type\",\r\n            \"QmPwAdEj6quzB65JWr6hDz6HrLtjTfbezwUiAe6mBq2sxY\",\r\n            \"PL\",\r\n            \"addNewMarketType(uint64,uint64,uint64)\",\r\n            60,\r\n            tokenHolder\r\n        ); //15\r\n        _addInitialCategories(\r\n            \"Add new market currency\",\r\n            \"QmTu2FnkqUWhhNbeQraSrtbdA4DfGLavTsLRKRCeLV51x1\",\r\n            \"PL\",\r\n            \"addNewMarketCurrency(address,uint64)\",\r\n            60,\r\n            tokenHolder\r\n        );\r\n        _addInitialCategories(\r\n            \"Pause Market Creation\",\r\n            \"QmamFs4k5ZbzajipsbWb4LCaKtyxDUwb9U5dYiNFqExb2W\",\r\n            \"PL\",\r\n            \"pauseMarketCreation()\",\r\n            60,\r\n            tokenHolder\r\n        );\r\n        _addInitialCategories(\r\n            \"Resume Market Creation\",\r\n            \"QmZ9W1gHTJjSnt3ieiNv1Ux6ooX7ngU4Jrpvk3QiiBeP5r\",\r\n            \"PL\",\r\n            \"resumeMarketCreation()\",\r\n            60,\r\n            tokenHolder\r\n        );\r\n        _addInitialCategories(\r\n            \"Transfer Market Registry Assets\",\r\n            \"QmeRCfGJuA6oTqY8a7nuVxdHih2SmZUTaZLVrttGv6yKy5\",\r\n            \"PL\",\r\n            \"transferAssets(address,address,uint256)\",\r\n            60,\r\n            tokenHolder\r\n        );\r\n        _addInitialCategories(\r\n            \"Update Market Uint parameters\",\r\n            \"QmXPXBkSKfidTgbDcRBLqokqAa9SU2wwErTyedPAZPfr5z\",\r\n            \"PL\",\r\n            \"updateUintParameters(bytes8,uint256)\",\r\n            60,\r\n            tokenHolder\r\n        ); //20\r\n        _addInitialCategories(\r\n            \"Update Market Address parameters\",\r\n            \"QmbbNRchZHMULBbKFT8qjCWgCRPa4qdkst8mE8A2Kffy7N\",\r\n            \"PL\",\r\n            \"updateConfigAddressParameters(bytes8,address)\",\r\n            60,\r\n            tokenHolder\r\n        );\r\n        _addInitialCategories(\r\n            \"Update Member roles parameters\",\r\n            \"QmcG8KXLMTDL5CtiKed12bJxE4ioL7Wn7oXLdW1zYWpf62\",\r\n            \"MR\",\r\n            \"updateUintParameters(bytes8,uint256)\",\r\n            60,\r\n            tokenHolder\r\n        ); //22\r\n        _addInitialCategories(\r\n            \"Whitelist Sponsor\",\r\n            \"QmRB2twfkzjox4ZAStnZTvtqr7Tr7ByGVdjTziWnpxXmWw\",\r\n            \"MS\",\r\n            \"whitelistSponsor(address)\",\r\n            60,\r\n            tokenHolder\r\n        );\r\n        _addInitialCategories(\r\n            \"Any other item\",\r\n            \"\",\r\n            \"EX\",\r\n            \"\",\r\n            60,\r\n            tokenHolder\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Total number of categories added till now\r\n     */\r\n    function totalCategories() external view returns (uint256) {\r\n        return allCategory.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets category details\r\n     */\r\n    function category(uint256 _categoryId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256[] memory,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return (\r\n            _categoryId,\r\n            allCategory[_categoryId].memberRoleToVote,\r\n            allCategory[_categoryId].majorityVotePerc,\r\n            allCategory[_categoryId].quorumPerc,\r\n            allCategory[_categoryId].allowedToCreateProposal,\r\n            allCategory[_categoryId].closingTime,\r\n            allCategory[_categoryId].minStake\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the category action details\r\n     * @param _categoryId is the category id in concern\r\n     * @return the category id\r\n     * @return the contract address\r\n     * @return the contract name\r\n     * @return the default incentive\r\n     */\r\n    function categoryAction(uint256 _categoryId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            address,\r\n            bytes2,\r\n            uint256\r\n        )\r\n    {\r\n        return (\r\n            _categoryId,\r\n            categoryActionData[_categoryId].contractAddress,\r\n            categoryActionData[_categoryId].contractName,\r\n            categoryActionData[_categoryId].defaultIncentive\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the category action details of a category id\r\n     * @param _categoryId is the category id in concern\r\n     * @return the category id\r\n     * @return the contract address\r\n     * @return the contract name\r\n     * @return the default incentive\r\n     * @return action function hash\r\n     */\r\n    function categoryActionDetails(uint256 _categoryId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            address,\r\n            bytes2,\r\n            uint256,\r\n            bytes memory\r\n        )\r\n    {\r\n        return (\r\n            _categoryId,\r\n            categoryActionData[_categoryId].contractAddress,\r\n            categoryActionData[_categoryId].contractName,\r\n            categoryActionData[_categoryId].defaultIncentive,\r\n            categoryActionHashes[_categoryId]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the master address and update it's instance\r\n     */\r\n    function setMasterAddress() public {\r\n        OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(\r\n            address(uint160(address(this)))\r\n        );\r\n        require(msg.sender == proxy.proxyOwner(), \"Sender is not proxy owner.\");\r\n\r\n        require(masterAddress == address(0), \"Master address already set\");\r\n        masterAddress = msg.sender;\r\n        mr = IMemberRoles(IMaster(masterAddress).getLatestAddress(\"MR\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds new category\r\n     * @param _name Category name\r\n     * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n     * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n     * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n     * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n     * @param _closingTime Vote closing time for Each voting layer\r\n     * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n     * @param _contractAddress address of contract to call after proposal is accepted\r\n     * @param _contractName name of contract to be called after proposal is accepted\r\n     * @param _incentives rewards to distributed after proposal is accepted\r\n     * @param _functionHash function signature to be executed\r\n     */\r\n    function newCategory(\r\n        string memory _name,\r\n        uint256 _memberRoleToVote,\r\n        uint256 _majorityVotePerc,\r\n        uint256 _quorumPerc,\r\n        uint256[] memory _allowedToCreateProposal,\r\n        uint256 _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint256[] memory _incentives,\r\n        string memory _functionHash\r\n    ) public onlyAuthorizedToGovern {\r\n        require(\r\n            _quorumPerc <= 100 && _majorityVotePerc <= 100,\r\n            \"Invalid percentage\"\r\n        );\r\n\r\n        require(\r\n            (_contractName == \"EX\" && _contractAddress == address(0)) ||\r\n                bytes(_functionHash).length > 0,\r\n            \"Wrong parameters passed\"\r\n        );\r\n\r\n        _addCategory(\r\n            _name,\r\n            _memberRoleToVote,\r\n            _majorityVotePerc,\r\n            _quorumPerc,\r\n            _allowedToCreateProposal,\r\n            _closingTime,\r\n            _actionHash,\r\n            _contractAddress,\r\n            _contractName,\r\n            _incentives\r\n        );\r\n\r\n        bytes memory _encodedHash = abi.encodeWithSignature(_functionHash);\r\n        if (\r\n            bytes(_functionHash).length > 0 &&\r\n            _encodedHash.length == 4\r\n        ) {\r\n            if(keccak256(_encodedHash) == keccak256(abi.encodeWithSignature(\"resolveDispute(address,uint256)\"))) {\r\n                require(_memberRoleToVote == uint256(IMemberRoles.Role.DisputeResolution));\r\n            }\r\n            categoryActionHashes[allCategory.length - 1] = _encodedHash;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates category details\r\n     * @param _categoryId Category id that needs to be updated\r\n     * @param _name Category name\r\n     * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n     * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n     * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n     * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n     * @param _closingTime Vote closing time for Each voting layer\r\n     * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n     * @param _contractAddress address of contract to call after proposal is accepted\r\n     * @param _contractName name of contract to be called after proposal is accepted\r\n     * @param _incentives rewards to distributed after proposal is accepted\r\n     * @param _functionHash function signature to be executed\r\n     */\r\n    function editCategory(\r\n        uint256 _categoryId,\r\n        string memory _name,\r\n        uint256 _memberRoleToVote,\r\n        uint256 _majorityVotePerc,\r\n        uint256 _quorumPerc,\r\n        uint256[] memory _allowedToCreateProposal,\r\n        uint256 _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint256[] memory _incentives,\r\n        string memory _functionHash\r\n    ) public onlyAuthorizedToGovern {\r\n        require(\r\n            _verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal),\r\n            \"Invalid Role\"\r\n        );\r\n\r\n        require(\r\n            _quorumPerc <= 100 && _majorityVotePerc <= 100,\r\n            \"Invalid percentage\"\r\n        );\r\n\r\n        require(\r\n            (_contractName == \"EX\" && _contractAddress == address(0)) ||\r\n                bytes(_functionHash).length > 0,\r\n            \"Wrong parameters passed\"\r\n        );\r\n\r\n        delete categoryActionHashes[_categoryId];\r\n        if (\r\n            bytes(_functionHash).length > 0 &&\r\n            abi.encodeWithSignature(_functionHash).length == 4\r\n        ) {\r\n            if(keccak256(abi.encodeWithSignature(_functionHash)) == keccak256(abi.encodeWithSignature(\"resolveDispute(address,uint256)\"))) {\r\n                require(_memberRoleToVote == uint256(IMemberRoles.Role.DisputeResolution));\r\n            }\r\n            categoryActionHashes[_categoryId] = abi.encodeWithSignature(\r\n                _functionHash\r\n            );\r\n        }\r\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\r\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\r\n        allCategory[_categoryId].closingTime = _closingTime;\r\n        allCategory[_categoryId]\r\n            .allowedToCreateProposal = _allowedToCreateProposal;\r\n        allCategory[_categoryId].minStake = _incentives[0];\r\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\r\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\r\n        categoryActionData[_categoryId].contractName = _contractName;\r\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\r\n        emit Category(_categoryId, _name, _actionHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to add new category\r\n     * @param _name Category name\r\n     * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n     * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n     * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n     * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n     * @param _closingTime Vote closing time for Each voting layer\r\n     * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n     * @param _contractAddress address of contract to call after proposal is accepted\r\n     * @param _contractName name of contract to be called after proposal is accepted\r\n     * @param _incentives rewards to distributed after proposal is accepted\r\n     */\r\n    function _addCategory(\r\n        string memory _name,\r\n        uint256 _memberRoleToVote,\r\n        uint256 _majorityVotePerc,\r\n        uint256 _quorumPerc,\r\n        uint256[] memory _allowedToCreateProposal,\r\n        uint256 _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint256[] memory _incentives\r\n    ) internal {\r\n        require(\r\n            _verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal),\r\n            \"Invalid Role\"\r\n        );\r\n        allCategory.push(\r\n            CategoryStruct(\r\n                _memberRoleToVote,\r\n                _majorityVotePerc,\r\n                _quorumPerc,\r\n                _allowedToCreateProposal,\r\n                _closingTime,\r\n                _incentives[0]\r\n            )\r\n        );\r\n        uint256 categoryId = allCategory.length - 1;\r\n        categoryActionData[categoryId] = CategoryAction(\r\n            _incentives[1],\r\n            _contractAddress,\r\n            _contractName\r\n        );\r\n        emit Category(categoryId, _name, _actionHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to check if given roles are valid or not\r\n     */\r\n    function _verifyMemberRoles(\r\n        uint256 _memberRoleToVote,\r\n        uint256[] memory _allowedToCreateProposal\r\n    ) internal view returns (bool) {\r\n        uint256 totalRoles = mr.totalRoles();\r\n        if (_memberRoleToVote >= totalRoles) {\r\n            return false;\r\n        }\r\n        for (uint256 i = 0; i < _allowedToCreateProposal.length; i++) {\r\n            if (_allowedToCreateProposal[i] >= totalRoles) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev to add the initial categories\r\n     * @param _name is category name\r\n     * @param _actionHash hash of category action\r\n     * @param _contractName is the name of contract\r\n     * @param _majorityVotePerc percentage of majority vote\r\n     * @param _memberRoleToVote is the member role the category can vote on\r\n     */\r\n    function _addInitialCategories(\r\n        string memory _name,\r\n        string memory _solutionHash,\r\n        bytes2 _contractName,\r\n        string memory _actionHash,\r\n        uint256 _majorityVotePerc,\r\n        uint256 _memberRoleToVote\r\n    ) internal {\r\n        uint256[] memory allowedToCreateProposal = new uint256[](1);\r\n        uint256[] memory stakeIncentive = new uint256[](2);\r\n        uint256 closingTime = 3 days;\r\n        allowedToCreateProposal[0] = _memberRoleToVote;\r\n        stakeIncentive[0] = 0;\r\n        stakeIncentive[1] = 0;\r\n        if (_memberRoleToVote == uint256(IMemberRoles.Role.DisputeResolution)) {\r\n            stakeIncentive[1] = 100 ether;\r\n            allowedToCreateProposal[0] = uint256(IMemberRoles.Role.TokenHolder);\r\n            closingTime = 2 days;\r\n        }\r\n        if (bytes(_actionHash).length > 0) {\r\n            categoryActionHashes[allCategory.length] = abi.encodeWithSignature(\r\n                _actionHash\r\n            );\r\n        }\r\n        _addCategory(\r\n            _name,\r\n            _memberRoleToVote,\r\n            _majorityVotePerc,\r\n            10,\r\n            allowedToCreateProposal,\r\n            closingTime,\r\n            _solutionHash,\r\n            address(0),\r\n            _contractName,\r\n            stakeIncentive\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_toCheck\",\"type\":\"address\"}],\"name\":\"isAuthorizedToGovern\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_categoryId\",\"type\":\"uint256\"}],\"name\":\"category\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCategories\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"constructorCheck\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"categoryActionHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_categoryId\",\"type\":\"uint256\"}],\"name\":\"categoryAction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes2\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initiated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_memberRoleToVote\",\"type\":\"uint256\"},{\"name\":\"_majorityVotePerc\",\"type\":\"uint256\"},{\"name\":\"_quorumPerc\",\"type\":\"uint256\"},{\"name\":\"_allowedToCreateProposal\",\"type\":\"uint256[]\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_actionHash\",\"type\":\"string\"},{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_contractName\",\"type\":\"bytes2\"},{\"name\":\"_incentives\",\"type\":\"uint256[]\"},{\"name\":\"_functionHash\",\"type\":\"string\"}],\"name\":\"newCategory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_categoryId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_memberRoleToVote\",\"type\":\"uint256\"},{\"name\":\"_majorityVotePerc\",\"type\":\"uint256\"},{\"name\":\"_quorumPerc\",\"type\":\"uint256\"},{\"name\":\"_allowedToCreateProposal\",\"type\":\"uint256[]\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_actionHash\",\"type\":\"string\"},{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_contractName\",\"type\":\"bytes2\"},{\"name\":\"_incentives\",\"type\":\"uint256[]\"},{\"name\":\"_functionHash\",\"type\":\"string\"}],\"name\":\"editCategory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"proposalCategoryInitiate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_categoryId\",\"type\":\"uint256\"}],\"name\":\"categoryActionDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes2\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"categoryId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"categoryName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"actionHash\",\"type\":\"string\"}],\"name\":\"Category\",\"type\":\"event\"}]","ContractName":"ProposalCategory","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://223237d7491baffe63c4da8e84cb82c25f07289681b778a12fb144e3af42459b"}]}