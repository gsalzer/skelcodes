{"status":"1","message":"OK","result":[{"SourceCode":"{\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) public pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) public pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) public pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) public pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) public pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) public pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) public pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) public pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"SavixSupply.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev savix interest and supply calculations.\\r\\n *\\r\\n*/\\r\\n library SavixSupply {\\r\\n     \\r\\n    uint256 public constant MAX_UINT256 = 2**256 - 1;\\r\\n    uint256 public constant MAX_UINT128 = 2**128 - 1;\\r\\n    uint public constant MINTIMEWIN = 60;\\r\\n    uint public constant SECPERDAY = 3600 * 24;\\r\\n    uint public constant DECIMALS = 9;\\r\\n\\r\\n    struct SupplyWinBoundery \\r\\n    {\\r\\n        uint256 x1;\\r\\n        uint256 x2;\\r\\n        uint256 y1;\\r\\n        uint256 y2;\\r\\n    }\\r\\n\\r\\n    struct AdjustedSupplyData \\r\\n    {\\r\\n        uint256 newSupply;\\r\\n        uint256 adjustTime;\\r\\n        uint adjustGradient;\\r\\n    }\\r\\n    \\r\\n    function getSupplyWindow(uint256[2][] memory map, uint256 calcTime) internal pure returns (SupplyWinBoundery memory)\\r\\n    {\\r\\n        SupplyWinBoundery memory winBound;\\r\\n        \\r\\n        winBound.x1 = 0;\\r\\n        winBound.x2 = 0;\\r\\n\\r\\n        winBound.y1 = map[0][1];\\r\\n        winBound.y2 = 0;\\r\\n\\r\\n        for (uint i=0; i \\u003c map.length; i++) {\\r\\n            if (map[i][0] == 0) continue;\\r\\n            if (calcTime \\u003c map[i][0])\\r\\n            {\\r\\n                winBound.x2 = map[i][0];\\r\\n                winBound.y2 = map[i][1];\\r\\n                break;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                winBound.x1 = map[i][0];\\r\\n                winBound.y1 = map[i][1];\\r\\n            }\\r\\n        }\\r\\n        if (winBound.x2 == 0) winBound.x2 = MAX_UINT256;\\r\\n        if (winBound.y2 == 0) winBound.y2 = MAX_UINT128;\\r\\n        return winBound;\\r\\n    }\\r\\n\\r\\n\\r\\n    // function to calculate new Supply with SafeMath for divisions only, shortest (cheapest) form\\r\\n    function getAdjustedSupply(uint256[2][] memory map, uint256 transactionTime, uint256 lastAdjustTime, uint256 currentSupply, uint constGradient) internal pure returns (AdjustedSupplyData memory)\\r\\n    {\\r\\n        AdjustedSupplyData memory supplyData;\\r\\n        supplyData.newSupply = currentSupply;\\r\\n        supplyData.adjustTime = transactionTime;\\r\\n        supplyData.adjustGradient = 0;\\r\\n        \\r\\n        // return unchanged supply if less than MINTIMEWIN secounds have passed\\r\\n        // if (lastAdjustTime \\u003e 0 \\u0026\\u0026 transactionTime - lastAdjustTime \\u003c MINTIMEWIN)\\r\\n        if (transactionTime - lastAdjustTime \\u003c MINTIMEWIN)\\r\\n        {\\r\\n            return (supplyData);\\r\\n        }\\r\\n\\r\\n        if (transactionTime \\u003e= map[map.length-1][0])\\r\\n        {\\r\\n            supplyData.newSupply = map[map.length-1][1] + constGradient * (transactionTime - map[map.length-1][0]);\\r\\n            supplyData.adjustGradient = constGradient;\\r\\n            \\r\\n            return (supplyData);\\r\\n        }\\r\\n        \\r\\n        SupplyWinBoundery memory winBound = getSupplyWindow(map, transactionTime);\\r\\n        supplyData.adjustGradient = SafeMath.div(winBound.y2 - winBound.y1, winBound.x2 - winBound.x1);\\r\\n        supplyData.newSupply = winBound.y1 + supplyData.adjustGradient * (transactionTime - winBound.x1);\\r\\n\\r\\n        return (supplyData);\\r\\n    }\\r\\n\\r\\n    function getDailyInterest(uint256 currentTime, uint256 lastAdjustTime, uint256 currentSupply, uint256 lastSupply) internal pure returns (uint)\\r\\n    {\\r\\n            if (currentTime \\u003c= lastAdjustTime)\\r\\n                return currentTime;\\r\\n                \\r\\n            uint256 InterestSinceLastAdjust = SafeMath.div((currentSupply - lastSupply) * 100 * 10**DECIMALS, lastSupply);\\r\\n            return (SafeMath.div(InterestSinceLastAdjust * SECPERDAY, currentTime - lastAdjustTime));\\r\\n    }\\r\\n }\"}}","ABI":"[{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_UINT128\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTIMEWIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECPERDAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SavixSupply","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"petersburg","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://05c73e896c7d66fdeee929494ed37d1f60ef4e748eb1e8f94d829d0c75a16795"}]}