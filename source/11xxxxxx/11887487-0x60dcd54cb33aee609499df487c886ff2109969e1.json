{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/factory/PProxiedFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nimport \\\"@pie-dao/proxy/contracts/PProxyPausable.sol\\\";\\n\\nimport \\\"../interfaces/IBFactory.sol\\\";\\nimport \\\"../interfaces/IBPool.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../Ownable.sol\\\";\\nimport \\\"../interfaces/IPV2SmartPool.sol\\\";\\nimport \\\"../libraries/LibSafeApprove.sol\\\";\\n\\ncontract PProxiedFactory is Ownable {\\n  using LibSafeApprove for IERC20;\\n\\n  IBFactory public balancerFactory;\\n  address public smartPoolImplementation;\\n  mapping(address => bool) public isPool;\\n  address[] public pools;\\n\\n  event SmartPoolCreated(address indexed poolAddress, string name, string symbol);\\n\\n  function init(address _balancerFactory, address _implementation) public {\\n    require(smartPoolImplementation == address(0), \\\"Already initialised\\\");\\n    _setOwner(msg.sender);\\n    balancerFactory = IBFactory(_balancerFactory);\\n\\n    smartPoolImplementation = _implementation;\\n  }\\n\\n  function setImplementation(address _implementation) external onlyOwner {\\n    smartPoolImplementation = _implementation;\\n  }\\n\\n  function newProxiedSmartPool(\\n    string memory _name,\\n    string memory _symbol,\\n    uint256 _initialSupply,\\n    address[] memory _tokens,\\n    uint256[] memory _amounts,\\n    uint256[] memory _weights,\\n    uint256 _cap\\n  ) public onlyOwner returns (address) {\\n    // Deploy proxy contract\\n    PProxyPausable proxy = new PProxyPausable();\\n\\n    // Setup proxy\\n    proxy.setImplementation(smartPoolImplementation);\\n    proxy.setPauzer(msg.sender);\\n    proxy.setProxyOwner(msg.sender);\\n\\n    // Setup balancer pool\\n    address balancerPoolAddress = balancerFactory.newBPool();\\n    IBPool bPool = IBPool(balancerPoolAddress);\\n\\n    for (uint256 i = 0; i < _tokens.length; i++) {\\n      IERC20 token = IERC20(_tokens[i]);\\n      // Transfer tokens to this contract\\n      token.transferFrom(msg.sender, address(this), _amounts[i]);\\n      // Approve the balancer pool\\n      token.safeApprove(balancerPoolAddress, uint256(-1));\\n      // Bind tokens\\n      bPool.bind(_tokens[i], _amounts[i], _weights[i]);\\n    }\\n    bPool.setController(address(proxy));\\n\\n    // Setup smart pool\\n    IPV2SmartPool smartPool = IPV2SmartPool(address(proxy));\\n\\n    smartPool.init(balancerPoolAddress, _name, _symbol, _initialSupply);\\n    smartPool.setCap(_cap);\\n    smartPool.setPublicSwapSetter(msg.sender);\\n    smartPool.setTokenBinder(msg.sender);\\n    smartPool.setController(msg.sender);\\n    smartPool.approveTokens();\\n\\n    isPool[address(smartPool)] = true;\\n    pools.push(address(smartPool));\\n\\n    emit SmartPoolCreated(address(smartPool), _name, _symbol);\\n\\n    smartPool.transfer(msg.sender, _initialSupply);\\n\\n    return address(smartPool);\\n  }\\n}\\n\"\r\n    },\r\n    \"@pie-dao/proxy/contracts/PProxyPausable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport \\\"./PProxy.sol\\\";\\n\\ncontract PProxyPausable is PProxy {\\n\\n    bytes32 constant PAUSED_SLOT = keccak256(abi.encodePacked(\\\"PAUSED_SLOT\\\"));\\n    bytes32 constant PAUZER_SLOT = keccak256(abi.encodePacked(\\\"PAUZER_SLOT\\\"));\\n\\n    constructor() PProxy() public {\\n        setAddress(PAUZER_SLOT, msg.sender);\\n    }\\n\\n    modifier onlyPauzer() {\\n        require(msg.sender == readAddress(PAUZER_SLOT), \\\"PProxyPausable.onlyPauzer: msg sender not pauzer\\\");\\n        _;\\n    }\\n\\n    modifier notPaused() {\\n        require(!readBool(PAUSED_SLOT), \\\"PProxyPausable.notPaused: contract is paused\\\");\\n        _;\\n    }\\n\\n    function getPauzer() public view returns (address) {\\n        return readAddress(PAUZER_SLOT);\\n    }\\n\\n    function setPauzer(address _newPauzer) public onlyProxyOwner{\\n        setAddress(PAUZER_SLOT, _newPauzer);\\n    }\\n\\n    function renouncePauzer() public onlyPauzer {\\n        setAddress(PAUZER_SLOT, address(0));\\n    }\\n\\n    function getPaused() public view returns (bool) {\\n        return readBool(PAUSED_SLOT);\\n    }\\n\\n    function setPaused(bool _value) public onlyPauzer {\\n        setBool(PAUSED_SLOT, _value);\\n    }\\n\\n    function internalFallback() internal virtual override notPaused {\\n        super.internalFallback();\\n    }\\n\\n}\"\r\n    },\r\n    \"@pie-dao/proxy/contracts/PProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport \\\"./PProxyStorage.sol\\\";\\n\\ncontract PProxy is PProxyStorage {\\n\\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(abi.encodePacked(\\\"IMPLEMENTATION_SLOT\\\"));\\n    bytes32 constant OWNER_SLOT = keccak256(abi.encodePacked(\\\"OWNER_SLOT\\\"));\\n\\n    modifier onlyProxyOwner() {\\n        require(msg.sender == readAddress(OWNER_SLOT), \\\"PProxy.onlyProxyOwner: msg sender not owner\\\");\\n        _;\\n    }\\n\\n    constructor () public {\\n        setAddress(OWNER_SLOT, msg.sender);\\n    }\\n\\n    function getProxyOwner() public view returns (address) {\\n       return readAddress(OWNER_SLOT);\\n    }\\n\\n    function setProxyOwner(address _newOwner) onlyProxyOwner public {\\n        setAddress(OWNER_SLOT, _newOwner);\\n    }\\n\\n    function getImplementation() public view returns (address) {\\n        return readAddress(IMPLEMENTATION_SLOT);\\n    }\\n\\n    function setImplementation(address _newImplementation) onlyProxyOwner public {\\n        setAddress(IMPLEMENTATION_SLOT, _newImplementation);\\n    }\\n\\n\\n    fallback () external payable {\\n       return internalFallback();\\n    }\\n\\n    function internalFallback() internal virtual {\\n        address contractAddr = readAddress(IMPLEMENTATION_SLOT);\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(gas(), contractAddr, ptr, calldatasize(), 0, 0)\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n            case 0 { revert(ptr, size) }\\n            default { return(ptr, size) }\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"@pie-dao/proxy/contracts/PProxyStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\ncontract PProxyStorage {\\n\\n    function readString(bytes32 _key) public view returns(string memory) {\\n        return bytes32ToString(storageRead(_key));\\n    }\\n\\n    function setString(bytes32 _key, string memory _value) internal {\\n        storageSet(_key, stringToBytes32(_value));\\n    }\\n\\n    function readBool(bytes32 _key) public view returns(bool) {\\n        return storageRead(_key) == bytes32(uint256(1));\\n    }\\n\\n    function setBool(bytes32 _key, bool _value) internal {\\n        if(_value) {\\n            storageSet(_key, bytes32(uint256(1)));\\n        } else {\\n            storageSet(_key, bytes32(uint256(0)));\\n        }\\n    }\\n\\n    function readAddress(bytes32 _key) public view returns(address) {\\n        return bytes32ToAddress(storageRead(_key));\\n    }\\n\\n    function setAddress(bytes32 _key, address _value) internal {\\n        storageSet(_key, addressToBytes32(_value));\\n    }\\n\\n    function storageRead(bytes32 _key) public view returns(bytes32) {\\n        bytes32 value;\\n        //solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            value := sload(_key)\\n        }\\n        return value;\\n    }\\n\\n    function storageSet(bytes32 _key, bytes32 _value) internal {\\n        // targetAddress = _address;  // No!\\n        bytes32 implAddressStorageKey = _key;\\n        //solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            sstore(implAddressStorageKey, _value)\\n        }\\n    }\\n\\n    function bytes32ToAddress(bytes32 _value) public pure returns(address) {\\n        return address(uint160(uint256(_value)));\\n    }\\n\\n    function addressToBytes32(address _value) public pure returns(bytes32) {\\n        return bytes32(uint256(_value));\\n    }\\n\\n    function stringToBytes32(string memory _value) public pure returns (bytes32 result) {\\n        bytes memory tempEmptyStringTest = bytes(_value);\\n        if (tempEmptyStringTest.length == 0) {\\n            return 0x0;\\n        }\\n\\n        assembly {\\n            result := mload(add(_value, 32))\\n        }\\n    }\\n\\n    function bytes32ToString(bytes32 _value) public pure returns (string memory) {\\n        bytes memory bytesString = new bytes(32);\\n        uint charCount = 0;\\n        for (uint256 j = 0; j < 32; j++) {\\n            byte char = byte(bytes32(uint(_value) * 2 ** (8 * j)));\\n            if (char != 0) {\\n                bytesString[charCount] = char;\\n                charCount++;\\n            }\\n        }\\n        bytes memory bytesStringTrimmed = new bytes(charCount);\\n        for (uint256 j = 0; j < charCount; j++) {\\n            bytesStringTrimmed[j] = bytesString[j];\\n        }\\n        return string(bytesStringTrimmed);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\ninterface IBFactory {\\n  function newBPool() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBPool.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is disstributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.4;\\n\\ninterface IBPool {\\n  function isBound(address token) external view returns (bool);\\n\\n  function getBalance(address token) external view returns (uint256);\\n\\n  function rebind(\\n    address token,\\n    uint256 balance,\\n    uint256 denorm\\n  ) external;\\n\\n  function setSwapFee(uint256 swapFee) external;\\n\\n  function setPublicSwap(bool _public) external;\\n\\n  function bind(\\n    address token,\\n    uint256 balance,\\n    uint256 denorm\\n  ) external;\\n\\n  function unbind(address token) external;\\n\\n  function getDenormalizedWeight(address token) external view returns (uint256);\\n\\n  function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n  function getCurrentTokens() external view returns (address[] memory);\\n\\n  function setController(address manager) external;\\n\\n  function isPublicSwap() external view returns (bool);\\n\\n  function getSwapFee() external view returns (uint256);\\n\\n  function gulp(address token) external;\\n\\n  function calcPoolOutGivenSingleIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) external pure returns (uint256 poolAmountOut);\\n\\n  function calcSingleInGivenPoolOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountOut,\\n    uint256 swapFee\\n  ) external pure returns (uint256 tokenAmountIn);\\n\\n  function calcSingleOutGivenPoolIn(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountIn,\\n    uint256 swapFee\\n  ) external pure returns (uint256 tokenAmountOut);\\n\\n  function calcPoolInGivenSingleOut(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) external pure returns (uint256 poolAmountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\ninterface IERC20 {\\n  event Approval(address indexed _src, address indexed _dst, uint256 _amount);\\n  event Transfer(address indexed _src, address indexed _dst, uint256 _amount);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address _whom) external view returns (uint256);\\n\\n  function allowance(address _src, address _dst) external view returns (uint256);\\n\\n  function approve(address _dst, uint256 _amount) external returns (bool);\\n\\n  function transfer(address _dst, uint256 _amount) external returns (bool);\\n\\n  function transferFrom(\\n    address _src,\\n    address _dst,\\n    uint256 _amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\n\\nimport {OwnableStorage as OStorage} from \\\"./storage/OwnableStorage.sol\\\"; \\n\\ncontract Ownable {\\n  event OwnerChanged(address indexed previousOwner, address indexed newOwner);\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == OStorage.load().owner, \\\"Ownable.onlyOwner: msg.sender not owner\\\");\\n    _;\\n  }\\n\\n  /**\\n        @notice Transfer ownership to a new address\\n        @param _newOwner Address of the new owner\\n    */\\n  function transferOwnership(address _newOwner) external onlyOwner {\\n    _setOwner(_newOwner);\\n  }\\n\\n  /**\\n        @notice Internal method to set the owner\\n        @param _newOwner Address of the new owner\\n    */\\n  function _setOwner(address _newOwner) internal {\\n    OStorage.StorageStruct storage s = OStorage.load();\\n    emit OwnerChanged(s.owner, _newOwner);\\n    s.owner = _newOwner;\\n  }\\n\\n}\"\r\n    },\r\n    \"contracts/storage/OwnableStorage.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\nlibrary OwnableStorage {\\n  bytes32 public constant oSlot = keccak256(\\\"Ownable.storage.location\\\");\\n  struct StorageStruct {\\n    address owner;\\n  }\\n\\n  /**\\n        @notice Load pool token storage\\n        @return s Storage pointer to the pool token struct\\n    */\\n  function load() internal pure returns (StorageStruct storage s) {\\n    bytes32 loc = oSlot;\\n    assembly {\\n      s_slot := loc\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPV2SmartPool.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.4;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport {PV2SmartPoolStorage as P2Storage} from \\\"../storage/PV2SmartPoolStorage.sol\\\";\\n\\ninterface IPV2SmartPool is IERC20 {\\n  /**\\n    @notice Initialise smart pool. Can only be called once\\n    @param _bPool Address of the underlying bPool\\n    @param _name Token name\\n    @param _symbol Token symbol (ticker)\\n    @param _initialSupply Initial token supply\\n  */\\n  function init(\\n    address _bPool,\\n    string calldata _name,\\n    string calldata _symbol,\\n    uint256 _initialSupply\\n  ) external;\\n\\n  /**\\n    @notice Set the address that can set public swap enabled or disabled.\\n    Can only be called by the controller\\n    @param _swapSetter Address of the new swapSetter\\n  */\\n  function setPublicSwapSetter(address _swapSetter) external;\\n\\n  /**\\n    @notice Set the address that can bind, unbind and rebind tokens.\\n    Can only be called by the controller\\n    @param _tokenBinder Address of the new token binder\\n  */\\n  function setTokenBinder(address _tokenBinder) external;\\n\\n  /**\\n    @notice Enable or disable trading on the underlying balancer pool.\\n    Can only be called by the public swap setter\\n    @param _public Wether public swap is enabled or not\\n  */\\n  function setPublicSwap(bool _public) external;\\n\\n  /**\\n    @notice Set the swap fee. Can only be called by the controller\\n    @param _swapFee The new swap fee. 10**18 == 100%. Max 10%\\n  */\\n  function setSwapFee(uint256 _swapFee) external;\\n\\n  /**\\n    @notice Set the totalSuppy cap. Can only be called by the controller\\n    @param _cap New cap\\n  */\\n  function setCap(uint256 _cap) external;\\n\\n  /**\\n    @notice Set the annual fee. Can only be called by the controller\\n    @param _newFee new fee 10**18 == 100% per 365 days. Max 10%\\n  */\\n  function setAnnualFee(uint256 _newFee) external;\\n\\n  /**\\n    @notice Charge the outstanding annual fee\\n  */\\n  function chargeOutstandingAnnualFee() external;\\n\\n  /**\\n    @notice Set the address that receives the annual fee. Can only be called by the controller\\n  */\\n  function setFeeRecipient(address _newRecipient) external;\\n\\n  /**\\n    @notice Set the controller address. Can only be called by the current address\\n    @param _controller Address of the new controller\\n  */\\n  function setController(address _controller) external;\\n\\n  /**\\n    @notice Set the circuit breaker address. Can only be called by the controller\\n    @param _newCircuitBreaker Address of the new circuit breaker\\n  */\\n  function setCircuitBreaker(address _newCircuitBreaker) external;\\n\\n  /**\\n    @notice Enable or disable joining and exiting\\n    @param _newValue enabled or not\\n  */\\n  function setJoinExitEnabled(bool _newValue) external;\\n\\n  /**\\n    @notice Trip the circuit breaker which disabled exit, join and swaps\\n  */\\n  function tripCircuitBreaker() external;\\n\\n  /**\\n    @notice Update the weight of a token. Can only be called by the controller\\n    @param _token Token to adjust the weight of\\n    @param _newWeight New denormalized weight\\n  */\\n  function updateWeight(address _token, uint256 _newWeight) external;\\n\\n  /**\\n    @notice Gradually adjust the weights of a token. Can only be called by the controller\\n    @param _newWeights Target weights\\n    @param _startBlock Block to start weight adjustment\\n    @param _endBlock Block to finish weight adjustment\\n  */\\n  function updateWeightsGradually(\\n    uint256[] calldata _newWeights,\\n    uint256 _startBlock,\\n    uint256 _endBlock\\n  ) external;\\n\\n  /**\\n    @notice Poke the weight adjustment\\n  */\\n  function pokeWeights() external;\\n\\n  /**\\n    @notice Apply the adding of a token. Can only be called by the controller\\n  */\\n  function applyAddToken() external;\\n\\n  /**\\n    @notice Commit a token to be added. Can only be called by the controller\\n    @param _token Address of the token to add\\n    @param _balance Amount of token to add\\n    @param _denormalizedWeight Denormalized weight\\n  */\\n  function commitAddToken(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denormalizedWeight\\n  ) external;\\n\\n  /**\\n    @notice Remove a token from the smart pool. Can only be called by the controller\\n    @param _token Address of the token to remove\\n  */\\n  function removeToken(address _token) external;\\n\\n  /**\\n    @notice Approve bPool to pull tokens from smart pool\\n  */\\n  function approveTokens() external;\\n\\n  /**\\n    @notice Mint pool tokens, locking underlying assets\\n    @param _amount Amount of pool tokens\\n  */\\n  function joinPool(uint256 _amount) external;\\n\\n  /**\\n    @notice Mint pool tokens, locking underlying assets. With front running protection\\n    @param _amount Amount of pool tokens\\n    @param _maxAmountsIn Maximum amounts of underlying assets\\n  */\\n  function joinPool(uint256 _amount, uint256[] calldata _maxAmountsIn) external;\\n\\n  /**\\n    @notice Burn pool tokens and redeem underlying assets\\n    @param _amount Amount of pool tokens to burn\\n  */\\n  function exitPool(uint256 _amount) external;\\n\\n  /**\\n    @notice Burn pool tokens and redeem underlying assets. With front running protection\\n    @param _amount Amount of pool tokens to burn\\n    @param _minAmountsOut Minimum amounts of underlying assets\\n  */\\n  function exitPool(uint256 _amount, uint256[] calldata _minAmountsOut) external;\\n\\n  /**\\n    @notice Join with a single asset, given amount of token in\\n    @param _token Address of the underlying token to deposit\\n    @param _amountIn Amount of underlying asset to deposit\\n    @param _minPoolAmountOut Minimum amount of pool tokens to receive\\n  */\\n  function joinswapExternAmountIn(\\n    address _token,\\n    uint256 _amountIn,\\n    uint256 _minPoolAmountOut\\n  ) external returns (uint256);\\n\\n  /**\\n    @notice Join with a single asset, given amount pool out\\n    @param _token Address of the underlying token to deposit\\n    @param _amountOut Amount of pool token to mint\\n    @param _maxAmountIn Maximum amount of underlying asset\\n  */\\n  function joinswapPoolAmountOut(\\n    address _token,\\n    uint256 _amountOut,\\n    uint256 _maxAmountIn\\n  ) external returns (uint256 tokenAmountIn);\\n\\n  /**\\n    @notice Exit with a single asset, given pool amount in\\n    @param _token Address of the underlying token to withdraw\\n    @param _poolAmountIn Amount of pool token to burn\\n    @param _minAmountOut Minimum amount of underlying asset to withdraw\\n  */\\n  function exitswapPoolAmountIn(\\n    address _token,\\n    uint256 _poolAmountIn,\\n    uint256 _minAmountOut\\n  ) external returns (uint256 tokenAmountOut);\\n\\n  /**\\n    @notice Exit with a single asset, given token amount out\\n    @param _token Address of the underlying token to withdraw\\n    @param _tokenAmountOut Amount of underlying asset to withdraw\\n    @param _maxPoolAmountIn Maximimum pool amount to burn\\n  */\\n  function exitswapExternAmountOut(\\n    address _token,\\n    uint256 _tokenAmountOut,\\n    uint256 _maxPoolAmountIn\\n  ) external returns (uint256 poolAmountIn);\\n\\n  /**\\n    @notice Exit pool, ignoring some tokens\\n    @param _amount Amount of pool tokens to burn\\n    @param _lossTokens Addresses of tokens to ignore\\n  */\\n  function exitPoolTakingloss(uint256 _amount, address[] calldata _lossTokens) external;\\n\\n  /**\\n    @notice Bind(add) a token to the pool\\n    @param _token Address of the token to bind\\n    @param _balance Amount of token to bind\\n    @param _denorm Denormalised weight\\n  */\\n  function bind(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denorm\\n  ) external;\\n\\n  /**\\n    @notice Rebind(adjust) a token's weight or amount\\n    @param _token Address of the token to rebind\\n    @param _balance New token amount\\n    @param _denorm New denormalised weight\\n  */\\n  function rebind(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denorm\\n  ) external;\\n\\n  /**\\n    @notice Unbind(remove) a token from the smart pool\\n    @param _token Address of the token to unbind\\n  */\\n  function unbind(address _token) external;\\n\\n  /**\\n    @notice Get the controller address\\n    @return Address of the controller\\n  */\\n  function getController() external view returns (address);\\n\\n  /**\\n    @notice Get the public swap setter address\\n    @return Address of the public swap setter\\n  */\\n  function getPublicSwapSetter() external view returns (address);\\n\\n  /**\\n    @notice Get the address of the token binder\\n    @return Token binder address\\n  */\\n  function getTokenBinder() external view returns (address);\\n\\n  /**\\n    @notice Get the circuit breaker address\\n    @return Circuit breaker address\\n  */\\n  function getCircuitBreaker() external view returns (address);\\n\\n  /**\\n    @notice Get if public trading is enabled or not\\n    @return Enabled or not\\n  */\\n  function isPublicSwap() external view returns (bool);\\n\\n  /**\\n    @notice Get the current tokens in the smart pool\\n    @return Addresses of the tokens in the smart pool\\n  */\\n  function getTokens() external view returns (address[] memory);\\n\\n  /**\\n    @notice Get the totalSupply cap\\n    @return The totalSupply cap\\n  */\\n  function getCap() external view returns (uint256);\\n\\n  /**\\n    @notice Get the annual fee\\n    @return the annual fee\\n  */\\n  function getAnnualFee() external view returns (uint256);\\n\\n  /**\\n    @notice Get the address receiving the fees\\n    @return Fee recipient address\\n  */\\n  function getFeeRecipient() external view returns (address);\\n\\n  /**\\n    @notice Get the denormalized weight of a token\\n    @param _token Address of the token\\n    @return The denormalised weight of the token\\n  */\\n  function getDenormalizedWeight(address _token) external view returns (uint256);\\n\\n  /**\\n    @notice Get all denormalized weights\\n    @return weights Denormalized weights\\n  */\\n  function getDenormalizedWeights() external view returns (uint256[] memory weights);\\n\\n  /**\\n    @notice Get the target weights\\n    @return weights Target weights\\n  */\\n  function getNewWeights() external view returns (uint256[] memory weights);\\n\\n  /**\\n    @notice Get weights at start of weight adjustment\\n    @return weights Start weights\\n  */\\n  function getStartWeights() external view returns (uint256[] memory weights);\\n\\n  /**\\n    @notice Get start block of weight adjustment\\n    @return Start block\\n  */\\n  function getStartBlock() external view returns (uint256);\\n\\n  /**\\n    @notice Get end block of weight adjustment\\n    @return End block\\n  */\\n  function getEndBlock() external view returns (uint256);\\n\\n  /**\\n    @notice Get new token being added\\n    @return New token\\n  */\\n  function getNewToken() external view returns (P2Storage.NewToken memory);\\n\\n  /**\\n    @notice Get if joining and exiting is enabled\\n    @return Enabled or not\\n  */\\n  function getJoinExitEnabled() external view returns (bool);\\n\\n  /**\\n    @notice Get the underlying Balancer pool address\\n    @return Address of the underlying Balancer pool\\n  */\\n  function getBPool() external view returns (address);\\n\\n  /**\\n    @notice Get the swap fee\\n    @return Swap fee\\n  */\\n  function getSwapFee() external view returns (uint256);\\n\\n  /**\\n    @notice Not supported\\n  */\\n  function finalizeSmartPool() external view;\\n\\n  /**\\n    @notice Not supported\\n  */\\n  function createPool(uint256 initialSupply) external view;\\n\\n  /**\\n    @notice Calculate the amount of underlying needed to mint a certain amount\\n    @return tokens Addresses of the underlying tokens\\n    @return amounts Amounts of the underlying tokens\\n  */\\n  function calcTokensForAmount(uint256 _amount)\\n    external\\n    view\\n    returns (address[] memory tokens, uint256[] memory amounts);\\n\\n  /**\\n    @notice Calculate the amount of pool tokens out given underlying in\\n    @param _token Underlying asset to deposit\\n    @param _amount Amount of underlying asset to deposit\\n    @return Pool amount out\\n  */\\n  function calcPoolOutGivenSingleIn(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n    @notice Calculate underlying deposit amount given pool amount out\\n    @param _token Underlying token to deposit\\n    @param _amount Amount of pool out\\n    @return Underlying asset deposit amount\\n  */\\n  function calcSingleInGivenPoolOut(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n    @notice Calculate underlying amount out given pool amount in\\n    @param _token Address of the underlying token to withdraw\\n    @param _amount Pool amount to burn\\n    @return Amount of underlying to withdraw\\n  */\\n  function calcSingleOutGivenPoolIn(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n    @notice Calculate pool amount in given underlying input\\n    @param _token Address of the underlying token to withdraw\\n    @param _amount Underlying output amount\\n    @return Pool burn amount\\n  */\\n  function calcPoolInGivenSingleOut(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/storage/PV2SmartPoolStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nlibrary PV2SmartPoolStorage {\\n  bytes32 public constant pasSlot = keccak256(\\\"PV2SmartPoolStorage.storage.location\\\");\\n\\n  struct StorageStruct {\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256[] startWeights;\\n    uint256[] newWeights;\\n    NewToken newToken;\\n    bool joinExitEnabled;\\n    uint256 annualFee;\\n    uint256 lastAnnualFeeClaimed;\\n    address feeRecipient;\\n    address circuitBreaker;\\n  }\\n\\n  struct NewToken {\\n    address addr;\\n    bool isCommitted;\\n    uint256 balance;\\n    uint256 denorm;\\n    uint256 commitBlock;\\n  }\\n\\n  function load() internal pure returns (StorageStruct storage s) {\\n    bytes32 loc = pasSlot;\\n    assembly {\\n      s_slot := loc\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibSafeApprove.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary LibSafeApprove {\\n    function safeApprove(IERC20 _token, address _spender, uint256 _amount) internal {\\n        uint256 currentAllowance = _token.allowance(address(this), _spender);\\n\\n        // Do nothing if allowance is already set to this value\\n        if(currentAllowance == _amount) {\\n            return;\\n        }\\n\\n        // If approval is not zero reset it to zero first\\n        if(currentAllowance != 0) {\\n            _token.approve(_spender, 0);\\n        }\\n\\n        // do the actual approval\\n        _token.approve(_spender, _amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPV3SmartPool.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity ^0.6.4;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport {PV2SmartPoolStorage as P2Storage} from \\\"../storage/PV2SmartPoolStorage.sol\\\";\\n\\ninterface IPV3SmartPool is IERC20 {\\n  /**\\n    @notice Initialise smart pool. Can only be called once\\n    @param _bPool Address of the underlying bPool\\n    @param _name Token name\\n    @param _symbol Token symbol (ticker)\\n    @param _initialSupply Initial token supply\\n  */\\n  function init(\\n    address _bPool,\\n    string calldata _name,\\n    string calldata _symbol,\\n    uint256 _initialSupply\\n  ) external;\\n\\n  /**\\n    @notice Set the address that can set public swap enabled or disabled.\\n    Can only be called by the controller\\n    @param _swapSetter Address of the new swapSetter\\n  */\\n  function setPublicSwapSetter(address _swapSetter) external;\\n\\n  /**\\n    @notice Set the address that can bind, unbind and rebind tokens.\\n    Can only be called by the controller\\n    @param _tokenBinder Address of the new token binder\\n  */\\n  function setTokenBinder(address _tokenBinder) external;\\n\\n  /**\\n    @notice Enable or disable trading on the underlying balancer pool.\\n    Can only be called by the public swap setter\\n    @param _public Wether public swap is enabled or not\\n  */\\n  function setPublicSwap(bool _public) external;\\n\\n  /**\\n    @notice Set the swap fee. Can only be called by the controller\\n    @param _swapFee The new swap fee. 10**18 == 100%. Max 10%\\n  */\\n  function setSwapFee(uint256 _swapFee) external;\\n\\n  /**\\n    @notice Set the totalSuppy cap. Can only be called by the controller\\n    @param _cap New cap\\n  */\\n  function setCap(uint256 _cap) external;\\n\\n  /**\\n    @notice Set the annual fee. Can only be called by the controller\\n    @param _newFee new fee 10**18 == 100% per 365 days. Max 10%\\n  */\\n  function setAnnualFee(uint256 _newFee) external;\\n\\n  /**\\n    @notice Charge the outstanding annual fee\\n  */\\n  function chargeOutstandingAnnualFee() external;\\n\\n  /**\\n    @notice Set the address that receives the annual fee. Can only be called by the controller\\n  */\\n  function setFeeRecipient(address _newRecipient) external;\\n\\n  /**\\n    @notice Set the controller address. Can only be called by the current address\\n    @param _controller Address of the new controller\\n  */\\n  function setController(address _controller) external;\\n\\n  /**\\n    @notice Set the circuit breaker address. Can only be called by the controller\\n    @param _newCircuitBreaker Address of the new circuit breaker\\n  */\\n  function setCircuitBreaker(address _newCircuitBreaker) external;\\n\\n  /**\\n    @notice Enable or disable joining and exiting\\n    @param _newValue enabled or not\\n  */\\n  function setJoinExitEnabled(bool _newValue) external;\\n\\n  /**\\n    @notice Trip the circuit breaker which disabled exit, join and swaps\\n  */\\n  function tripCircuitBreaker() external;\\n\\n  /**\\n    @notice Update the weight of a token. Can only be called by the controller\\n    @param _token Token to adjust the weight of\\n    @param _newWeight New denormalized weight\\n  */\\n  function updateWeight(address _token, uint256 _newWeight) external;\\n\\n  /**\\n    @notice Gradually adjust the weights of a token. Can only be called by the controller\\n    @param _newWeights Target weights\\n    @param _startBlock Block to start weight adjustment\\n    @param _endBlock Block to finish weight adjustment\\n  */\\n  function updateWeightsGradually(\\n    uint256[] calldata _newWeights,\\n    uint256 _startBlock,\\n    uint256 _endBlock\\n  ) external;\\n\\n  /**\\n    @notice Poke the weight adjustment\\n  */\\n  function pokeWeights() external;\\n\\n  /**\\n    @notice Apply the adding of a token. Can only be called by the controller\\n  */\\n  function applyAddToken() external;\\n\\n  /**\\n    @notice Commit a token to be added. Can only be called by the controller\\n    @param _token Address of the token to add\\n    @param _balance Amount of token to add\\n    @param _denormalizedWeight Denormalized weight\\n  */\\n  function commitAddToken(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denormalizedWeight\\n  ) external;\\n\\n  /**\\n    @notice Remove a token from the smart pool. Can only be called by the controller\\n    @param _token Address of the token to remove\\n  */\\n  function removeToken(address _token) external;\\n\\n  /**\\n    @notice Approve bPool to pull tokens from smart pool\\n  */\\n  function approveTokens() external;\\n\\n  /**\\n    @notice Mint pool tokens, locking underlying assets\\n    @param _amount Amount of pool tokens\\n    @param _referral partners may receive rewards with their referral code\\n  */\\n  function joinPoolExpress(uint256 _amount, uint16 _referral) external;\\n\\n  /**\\n    @notice Mint pool tokens, locking underlying assets. With front running protection\\n    @param _amount Amount of pool tokens\\n    @param _maxAmountsIn Maximum amounts of underlying assets\\n    @param _referral partners may receive rewards with their referral code\\n  */\\n  function joinPool(\\n    uint256 _amount,\\n    uint256[] calldata _maxAmountsIn,\\n    uint16 _referral\\n  ) external;\\n\\n  /**\\n    @notice Burn pool tokens and redeem underlying assets\\n    @param _amount Amount of pool tokens to burn\\n  */\\n  function exitPool(uint256 _amount) external;\\n\\n  /**\\n    @notice Burn pool tokens and redeem underlying assets. With front running protection\\n    @param _amount Amount of pool tokens to burn\\n    @param _minAmountsOut Minimum amounts of underlying assets\\n  */\\n  function exitPool(uint256 _amount, uint256[] calldata _minAmountsOut) external;\\n\\n  /**\\n    @notice Join with a single asset, given amount of token in\\n    @param _token Address of the underlying token to deposit\\n    @param _amountIn Amount of underlying asset to deposit\\n    @param _minPoolAmountOut Minimum amount of pool tokens to receive\\n    @param _referral partners may receive rewards with their referral code\\n  */\\n  function joinswapExternAmountIn(\\n    address _token,\\n    uint256 _amountIn,\\n    uint256 _minPoolAmountOut,\\n    uint16 _referral\\n  ) external returns (uint256);\\n\\n  /**\\n    @notice Join with a single asset, given amount pool out\\n    @param _token Address of the underlying token to deposit\\n    @param _amountOut Amount of pool token to mint\\n    @param _maxAmountIn Maximum amount of underlying asset\\n    @param _referral partners may receive rewards with their referral code\\n  */\\n  function joinswapPoolAmountOut(\\n    address _token,\\n    uint256 _amountOut,\\n    uint256 _maxAmountIn,\\n    uint16 _referral\\n  ) external returns (uint256 tokenAmountIn);\\n\\n  /**\\n    @notice Exit with a single asset, given pool amount in\\n    @param _token Address of the underlying token to withdraw\\n    @param _poolAmountIn Amount of pool token to burn\\n    @param _minAmountOut Minimum amount of underlying asset to withdraw\\n  */\\n  function exitswapPoolAmountIn(\\n    address _token,\\n    uint256 _poolAmountIn,\\n    uint256 _minAmountOut\\n  ) external returns (uint256 tokenAmountOut);\\n\\n  /**\\n    @notice Exit with a single asset, given token amount out\\n    @param _token Address of the underlying token to withdraw\\n    @param _tokenAmountOut Amount of underlying asset to withdraw\\n    @param _maxPoolAmountIn Maximimum pool amount to burn\\n  */\\n  function exitswapExternAmountOut(\\n    address _token,\\n    uint256 _tokenAmountOut,\\n    uint256 _maxPoolAmountIn\\n  ) external returns (uint256 poolAmountIn);\\n\\n  /**\\n    @notice Exit pool, ignoring some tokens\\n    @param _amount Amount of pool tokens to burn\\n    @param _lossTokens Addresses of tokens to ignore\\n  */\\n  function exitPoolTakingloss(uint256 _amount, address[] calldata _lossTokens) external;\\n\\n  /**\\n    @notice Bind(add) a token to the pool\\n    @param _token Address of the token to bind\\n    @param _balance Amount of token to bind\\n    @param _denorm Denormalised weight\\n  */\\n  function bind(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denorm\\n  ) external;\\n\\n  /**\\n    @notice Rebind(adjust) a token's weight or amount\\n    @param _token Address of the token to rebind\\n    @param _balance New token amount\\n    @param _denorm New denormalised weight\\n  */\\n  function rebind(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denorm\\n  ) external;\\n\\n  /**\\n    @notice Unbind(remove) a token from the smart pool\\n    @param _token Address of the token to unbind\\n  */\\n  function unbind(address _token) external;\\n\\n  /**\\n    @notice Get the controller address\\n    @return Address of the controller\\n  */\\n  function getController() external view returns (address);\\n\\n  /**\\n    @notice Get the public swap setter address\\n    @return Address of the public swap setter\\n  */\\n  function getPublicSwapSetter() external view returns (address);\\n\\n  /**\\n    @notice Get the address of the token binder\\n    @return Token binder address\\n  */\\n  function getTokenBinder() external view returns (address);\\n\\n  /**\\n    @notice Get the circuit breaker address\\n    @return Circuit breaker address\\n  */\\n  function getCircuitBreaker() external view returns (address);\\n\\n  /**\\n    @notice Get if public trading is enabled or not\\n    @return Enabled or not\\n  */\\n  function isPublicSwap() external view returns (bool);\\n\\n  /**\\n    @notice Get the current tokens in the smart pool\\n    @return Addresses of the tokens in the smart pool\\n  */\\n  function getTokens() external view returns (address[] memory);\\n\\n  /**\\n    @notice Get the totalSupply cap\\n    @return The totalSupply cap\\n  */\\n  function getCap() external view returns (uint256);\\n\\n  /**\\n    @notice Get the annual fee\\n    @return the annual fee\\n  */\\n  function getAnnualFee() external view returns (uint256);\\n\\n  /**\\n    @notice Get the address receiving the fees\\n    @return Fee recipient address\\n  */\\n  function getFeeRecipient() external view returns (address);\\n\\n  /**\\n    @notice Get the denormalized weight of a token\\n    @param _token Address of the token\\n    @return The denormalised weight of the token\\n  */\\n  function getDenormalizedWeight(address _token) external view returns (uint256);\\n\\n  /**\\n    @notice Get all denormalized weights\\n    @return weights Denormalized weights\\n  */\\n  function getDenormalizedWeights() external view returns (uint256[] memory weights);\\n\\n  /**\\n    @notice Get the target weights\\n    @return weights Target weights\\n  */\\n  function getNewWeights() external view returns (uint256[] memory weights);\\n\\n  /**\\n    @notice Get weights at start of weight adjustment\\n    @return weights Start weights\\n  */\\n  function getStartWeights() external view returns (uint256[] memory weights);\\n\\n  /**\\n    @notice Get start block of weight adjustment\\n    @return Start block\\n  */\\n  function getStartBlock() external view returns (uint256);\\n\\n  /**\\n    @notice Get end block of weight adjustment\\n    @return End block\\n  */\\n  function getEndBlock() external view returns (uint256);\\n\\n  /**\\n    @notice Get new token being added\\n    @return New token\\n  */\\n  function getNewToken() external view returns (P2Storage.NewToken memory);\\n\\n  /**\\n    @notice Get if joining and exiting is enabled\\n    @return Enabled or not\\n  */\\n  function getJoinExitEnabled() external view returns (bool);\\n\\n  /**\\n    @notice Get the underlying Balancer pool address\\n    @return Address of the underlying Balancer pool\\n  */\\n  function getBPool() external view returns (address);\\n\\n  /**\\n    @notice Get the swap fee\\n    @return Swap fee\\n  */\\n  function getSwapFee() external view returns (uint256);\\n\\n  /**\\n    @notice Not supported\\n  */\\n  function finalizeSmartPool() external view;\\n\\n  /**\\n    @notice Not supported\\n  */\\n  function createPool(uint256 initialSupply) external view;\\n\\n  /**\\n    @notice Calculate the amount of underlying needed to mint a certain amount\\n    @return tokens Addresses of the underlying tokens\\n    @return amounts Amounts of the underlying tokens\\n  */\\n  function calcTokensForAmount(uint256 _amount)\\n    external\\n    view\\n    returns (address[] memory tokens, uint256[] memory amounts);\\n\\n  /**\\n    @notice Calculate the amount of pool tokens out given underlying in\\n    @param _token Underlying asset to deposit\\n    @param _amount Amount of underlying asset to deposit\\n    @return Pool amount out\\n  */\\n  function calcPoolOutGivenSingleIn(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n    @notice Calculate underlying deposit amount given pool amount out\\n    @param _token Underlying token to deposit\\n    @param _amount Amount of pool out\\n    @return Underlying asset deposit amount\\n  */\\n  function calcSingleInGivenPoolOut(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n    @notice Calculate underlying amount out given pool amount in\\n    @param _token Address of the underlying token to withdraw\\n    @param _amount Pool amount to burn\\n    @return Amount of underlying to withdraw\\n  */\\n  function calcSingleOutGivenPoolIn(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n    @notice Calculate pool amount in given underlying input\\n    @param _token Address of the underlying token to withdraw\\n    @param _amount Underlying output amount\\n    @return Pool burn amount\\n  */\\n  function calcPoolInGivenSingleOut(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibAddRemoveToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nimport {PBasicSmartPoolStorage as PBStorage} from \\\"../storage/PBasicSmartPoolStorage.sol\\\";\\nimport {PV2SmartPoolStorage as P2Storage} from \\\"../storage/PV2SmartPoolStorage.sol\\\";\\nimport {PCTokenStorage as PCStorage} from \\\"../storage/PCTokenStorage.sol\\\";\\nimport {LibConst as constants} from \\\"./LibConst.sol\\\";\\nimport \\\"./LibSafeApprove.sol\\\";\\nimport \\\"./LibPoolToken.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\nlibrary LibAddRemoveToken {\\n  using Math for uint256;\\n  using LibSafeApprove for IERC20;\\n\\n  function applyAddToken() external {\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n\\n    require(ws.newToken.isCommitted, \\\"ERR_NO_TOKEN_COMMIT\\\");\\n\\n    uint256 totalSupply = PCStorage.load().totalSupply;\\n\\n    uint256 poolShares = totalSupply.bmul(ws.newToken.denorm).bdiv(\\n      s.bPool.getTotalDenormalizedWeight()\\n    );\\n\\n    ws.newToken.isCommitted = false;\\n\\n    require(\\n      IERC20(ws.newToken.addr).transferFrom(msg.sender, address(this), ws.newToken.balance),\\n      \\\"ERR_ERC20_FALSE\\\"\\n    );\\n\\n    // Cancel potential weight adjustment process.\\n    ws.startBlock = 0;\\n\\n    // Approves bPool to pull from this controller\\n    IERC20(ws.newToken.addr).safeApprove(address(s.bPool), uint256(-1));\\n    s.bPool.bind(ws.newToken.addr, ws.newToken.balance, ws.newToken.denorm);\\n    LibPoolToken._mint(msg.sender, poolShares);\\n  }\\n\\n  function commitAddToken(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denormalizedWeight\\n  ) external {\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n\\n    require(!s.bPool.isBound(_token), \\\"ERR_IS_BOUND\\\");\\n    require(_denormalizedWeight <= constants.MAX_WEIGHT, \\\"ERR_WEIGHT_ABOVE_MAX\\\");\\n    require(_denormalizedWeight >= constants.MIN_WEIGHT, \\\"ERR_WEIGHT_BELOW_MIN\\\");\\n    require(\\n      s.bPool.getTotalDenormalizedWeight().badd(_denormalizedWeight) <= constants.MAX_TOTAL_WEIGHT,\\n      \\\"ERR_MAX_TOTAL_WEIGHT\\\"\\n    );\\n\\n    ws.newToken.addr = _token;\\n    ws.newToken.balance = _balance;\\n    ws.newToken.denorm = _denormalizedWeight;\\n    ws.newToken.commitBlock = block.number;\\n    ws.newToken.isCommitted = true;\\n  }\\n\\n  function removeToken(address _token) external {\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n\\n    uint256 totalSupply = PCStorage.load().totalSupply;\\n\\n    // poolShares = totalSupply * tokenWeight / totalWeight\\n    uint256 poolShares = totalSupply.bmul(s.bPool.getDenormalizedWeight(_token)).bdiv(\\n      s.bPool.getTotalDenormalizedWeight()\\n    );\\n\\n    // this is what will be unbound from the pool\\n    // Have to get it before unbinding\\n    uint256 balance = s.bPool.getBalance(_token);\\n\\n    // Cancel potential weight adjustment process.\\n    ws.startBlock = 0;\\n\\n    // Unbind and get the tokens out of balancer pool\\n    s.bPool.unbind(_token);\\n\\n    require(IERC20(_token).transfer(msg.sender, balance), \\\"ERR_ERC20_FALSE\\\");\\n\\n    LibPoolToken._burn(msg.sender, poolShares);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/storage/PBasicSmartPoolStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nimport \\\"../interfaces/IBPool.sol\\\";\\n\\nlibrary PBasicSmartPoolStorage {\\n  bytes32 public constant pbsSlot = keccak256(\\\"PBasicSmartPool.storage.location\\\");\\n\\n  struct StorageStruct {\\n    IBPool bPool;\\n    address controller;\\n    address publicSwapSetter;\\n    address tokenBinder;\\n  }\\n\\n  /**\\n        @notice Load PBasicPool storage\\n        @return s Pointer to the storage struct\\n    */\\n  function load() internal pure returns (StorageStruct storage s) {\\n    bytes32 loc = pbsSlot;\\n    assembly {\\n      s_slot := loc\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/storage/PCTokenStorage.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\nlibrary PCTokenStorage {\\n  bytes32 public constant ptSlot = keccak256(\\\"PCToken.storage.location\\\");\\n  struct StorageStruct {\\n    string name;\\n    string symbol;\\n    uint256 totalSupply;\\n    mapping(address => uint256) balance;\\n    mapping(address => mapping(address => uint256)) allowance;\\n  }\\n\\n  /**\\n        @notice Load pool token storage\\n        @return s Storage pointer to the pool token struct\\n    */\\n  function load() internal pure returns (StorageStruct storage s) {\\n    bytes32 loc = ptSlot;\\n    assembly {\\n      s_slot := loc\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibConst.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nlibrary LibConst {\\n  uint256 internal constant MIN_WEIGHT = 10**18;\\n  uint256 internal constant MAX_WEIGHT = 10**18 * 50;\\n  uint256 internal constant MAX_TOTAL_WEIGHT = 10**18 * 50;\\n  uint256 internal constant MIN_BALANCE = (10**18) / (10**12);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibPoolToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nimport {PCTokenStorage as PCStorage} from \\\"../storage/PCTokenStorage.sol\\\";\\nimport \\\"../libraries/Math.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary LibPoolToken {\\n  using Math for uint256;\\n\\n  event Transfer(address indexed _src, address indexed _dst, uint256 _amount);\\n\\n  function _mint(address _to, uint256 _amount) internal {\\n    PCStorage.StorageStruct storage s = PCStorage.load();\\n    s.balance[_to] = s.balance[_to].badd(_amount);\\n    s.totalSupply = s.totalSupply.badd(_amount);\\n    emit Transfer(address(0), _to, _amount);\\n  }\\n\\n  function _burn(address _from, uint256 _amount) internal {\\n    PCStorage.StorageStruct storage s = PCStorage.load();\\n    require(s.balance[_from] >= _amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\n    s.balance[_from] = s.balance[_from].bsub(_amount);\\n    s.totalSupply = s.totalSupply.bsub(_amount);\\n    emit Transfer(_from, address(0), _amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nlibrary Math {\\n  uint256 internal constant BONE = 10**18;\\n  uint256 internal constant MIN_BPOW_BASE = 1 wei;\\n  uint256 internal constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\\n  uint256 internal constant BPOW_PRECISION = BONE / 10**10;\\n\\n  function btoi(uint256 a) internal pure returns (uint256) {\\n    return a / BONE;\\n  }\\n\\n  // Add two numbers together checking for overflows\\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n    return c;\\n  }\\n\\n  // subtract two numbers and return diffecerence when it underflows\\n  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\\n    if (a >= b) {\\n      return (a - b, false);\\n    } else {\\n      return (b - a, true);\\n    }\\n  }\\n\\n  // Subtract two numbers checking for underflows\\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    (uint256 c, bool flag) = bsubSign(a, b);\\n    require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n    return c;\\n  }\\n\\n  // Multiply two 18 decimals numbers\\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c0 = a * b;\\n    require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n    uint256 c1 = c0 + (BONE / 2);\\n    require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n    uint256 c2 = c1 / BONE;\\n    return c2;\\n  }\\n\\n  // Overflow protected multiplication\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"Math: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  // Divide two 18 decimals numbers\\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n    uint256 c0 = a * BONE;\\n    require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n    uint256 c1 = c0 + (b / 2);\\n    require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n    uint256 c2 = c1 / b;\\n    return c2;\\n  }\\n\\n  // Overflow protected division\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0, \\\"Division by zero\\\");\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  // DSMath.wpow\\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\\n    uint256 z = n % 2 != 0 ? a : BONE;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n      a = bmul(a, a);\\n\\n      if (n % 2 != 0) {\\n        z = bmul(z, a);\\n      }\\n    }\\n    return z;\\n  }\\n\\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n  // of approximation of b^0.w\\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\\n    require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n    require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n    uint256 whole = bfloor(exp);\\n    uint256 remain = bsub(exp, whole);\\n\\n    uint256 wholePow = bpowi(base, btoi(whole));\\n\\n    if (remain == 0) {\\n      return wholePow;\\n    }\\n\\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n    return bmul(wholePow, partialResult);\\n  }\\n\\n  function bpowApprox(\\n    uint256 base,\\n    uint256 exp,\\n    uint256 precision\\n  ) internal pure returns (uint256) {\\n    // term 0:\\n    uint256 a = exp;\\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\\n    uint256 term = BONE;\\n    uint256 sum = term;\\n    bool negative = false;\\n\\n    // term(k) = numer / denom\\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\\n    // continue until term is less than precision\\n    for (uint256 i = 1; term >= precision; i++) {\\n      uint256 bigK = i * BONE;\\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n      term = bmul(term, bmul(c, x));\\n      term = bdiv(term, bigK);\\n      if (term == 0) break;\\n\\n      if (xneg) negative = !negative;\\n      if (cneg) negative = !negative;\\n      if (negative) {\\n        sum = bsub(sum, term);\\n      } else {\\n        sum = badd(sum, term);\\n      }\\n    }\\n\\n    return sum;\\n  }\\n\\n  function bfloor(uint256 a) internal pure returns (uint256) {\\n    return btoi(a) * BONE;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibFees.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nimport \\\"./Math.sol\\\";\\nimport \\\"./LibPoolToken.sol\\\";\\nimport {PV2SmartPoolStorage as P2Storage} from \\\"../storage/PV2SmartPoolStorage.sol\\\";\\nimport {PCTokenStorage as PCStorage} from \\\"../storage/PCTokenStorage.sol\\\";\\n\\nlibrary LibFees {\\n  using Math for uint256;\\n\\n  uint256 public constant MAX_ANNUAL_FEE = 1 ether / 10; // Max annual fee\\n\\n  event AnnualFeeClaimed(uint256 amount);\\n  event AnnualFeeChanged(uint256 oldFee, uint256 newFee);\\n  event FeeRecipientChanged(address indexed oldRecipient, address indexed newRecipient);\\n\\n  function calcOutstandingAnnualFee() internal view returns (uint256) {\\n    P2Storage.StorageStruct storage v2s = P2Storage.load();\\n    uint256 totalSupply = PCStorage.load().totalSupply;\\n\\n    uint256 lastClaimed = v2s.lastAnnualFeeClaimed;\\n\\n    if (lastClaimed == 0) {\\n      return 0;\\n    }\\n\\n    uint256 timePassed = block.timestamp.bsub(lastClaimed);\\n    // TODO check this calc;\\n    return totalSupply.mul(v2s.annualFee).div(10**18).mul(timePassed).div(365 days);\\n  }\\n\\n  function chargeOutstandingAnnualFee() internal {\\n    P2Storage.StorageStruct storage v2s = P2Storage.load();\\n    uint256 outstandingFee = calcOutstandingAnnualFee();\\n\\n    if (outstandingFee == 0) {\\n      v2s.lastAnnualFeeClaimed = block.timestamp;\\n      return;\\n    }\\n\\n    LibPoolToken._mint(v2s.feeRecipient, outstandingFee);\\n\\n    v2s.lastAnnualFeeClaimed = block.timestamp;\\n\\n    emit AnnualFeeClaimed(outstandingFee);\\n  }\\n\\n  function setFeeRecipient(address _newRecipient) internal {\\n    emit FeeRecipientChanged(P2Storage.load().feeRecipient, _newRecipient);\\n    P2Storage.load().feeRecipient = _newRecipient;\\n  }\\n\\n  function setAnnualFee(uint256 _newFee) internal {\\n    require(_newFee <= MAX_ANNUAL_FEE, \\\"LibFees.setAnnualFee: Annual fee too high\\\");\\n    // Charge fee when the fee changes\\n    chargeOutstandingAnnualFee();\\n    emit AnnualFeeChanged(P2Storage.load().annualFee, _newFee);\\n    P2Storage.load().annualFee = _newFee;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibPoolEntryExit.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\nimport {PBasicSmartPoolStorage as PBStorage} from \\\"../storage/PBasicSmartPoolStorage.sol\\\";\\nimport {PCTokenStorage as PCStorage} from \\\"../storage/PCTokenStorage.sol\\\";\\nimport \\\"./LibFees.sol\\\";\\n\\nimport \\\"./LibPoolToken.sol\\\";\\nimport \\\"./LibUnderlying.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\nlibrary LibPoolEntryExit {\\n  using Math for uint256;\\n\\n  event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\\n  event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\\n  event PoolExited(address indexed from, uint256 amount);\\n  event PoolExitedWithLoss(address indexed from, uint256 amount, address[] lossTokens);\\n  event PoolJoined(address indexed from, uint256 amount);\\n\\n  modifier lockBPoolSwap() {\\n    IBPool bPool = PBStorage.load().bPool;\\n    if(bPool.isPublicSwap()) {\\n      // If public swap is enabled turn it of, execute function and turn it off again\\n      bPool.setPublicSwap(false);\\n      _;\\n      bPool.setPublicSwap(true);\\n    } else {\\n      // If public swap is not enabled just execute\\n      _;\\n    }\\n  }\\n\\n  function exitPool(uint256 _amount) internal {\\n    IBPool bPool = PBStorage.load().bPool;\\n    uint256[] memory minAmountsOut = new uint256[](bPool.getCurrentTokens().length);\\n    _exitPool(_amount, minAmountsOut);\\n  }\\n\\n  function exitPool(uint256 _amount, uint256[] calldata _minAmountsOut) external {\\n    _exitPool(_amount, _minAmountsOut);\\n  }\\n\\n  function _exitPool(uint256 _amount, uint256[] memory _minAmountsOut) internal lockBPoolSwap {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    uint256 poolTotal = PCStorage.load().totalSupply;\\n    uint256 ratio = _amount.bdiv(poolTotal);\\n    require(ratio != 0);\\n\\n    LibPoolToken._burn(msg.sender, _amount);\\n\\n    address[] memory tokens = bPool.getCurrentTokens();\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address token = tokens[i];\\n      uint256 balance = bPool.getBalance(token);\\n      uint256 tokenAmountOut = ratio.bmul(balance);\\n\\n      require(\\n        tokenAmountOut >= _minAmountsOut[i],\\n        \\\"LibPoolEntryExit.exitPool: Token amount out too small\\\"\\n      );\\n\\n      emit LOG_EXIT(msg.sender, token, tokenAmountOut);\\n      LibUnderlying._pushUnderlying(token, msg.sender, tokenAmountOut, balance);\\n    }\\n    emit PoolExited(msg.sender, _amount);\\n  }\\n\\n  function exitswapPoolAmountIn(\\n    address _token,\\n    uint256 _poolAmountIn,\\n    uint256 _minAmountOut\\n  ) external lockBPoolSwap returns (uint256 tokenAmountOut) {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    require(bPool.isBound(_token), \\\"LibPoolEntryExit.exitswapPoolAmountIn: Token Not Bound\\\");\\n\\n    tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\\n      bPool.getBalance(_token),\\n      bPool.getDenormalizedWeight(_token),\\n      PCStorage.load().totalSupply,\\n      bPool.getTotalDenormalizedWeight(),\\n      _poolAmountIn,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(\\n      tokenAmountOut >= _minAmountOut,\\n      \\\"LibPoolEntryExit.exitswapPoolAmountIn: Token Not Bound\\\"\\n    );\\n\\n    emit LOG_EXIT(msg.sender, _token, tokenAmountOut);\\n\\n    LibPoolToken._burn(msg.sender, _poolAmountIn);\\n\\n    emit PoolExited(msg.sender, tokenAmountOut);\\n\\n    uint256 bal = bPool.getBalance(_token);\\n    LibUnderlying._pushUnderlying(_token, msg.sender, tokenAmountOut, bal);\\n\\n    return tokenAmountOut;\\n  }\\n\\n  function exitswapExternAmountOut(\\n    address _token,\\n    uint256 _tokenAmountOut,\\n    uint256 _maxPoolAmountIn\\n  ) external lockBPoolSwap returns (uint256 poolAmountIn) {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    require(bPool.isBound(_token), \\\"LibPoolEntryExit.exitswapExternAmountOut: Token Not Bound\\\");\\n\\n    poolAmountIn = bPool.calcPoolInGivenSingleOut(\\n      bPool.getBalance(_token),\\n      bPool.getDenormalizedWeight(_token),\\n      PCStorage.load().totalSupply,\\n      bPool.getTotalDenormalizedWeight(),\\n      _tokenAmountOut,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(\\n      poolAmountIn <= _maxPoolAmountIn,\\n      \\\"LibPoolEntryExit.exitswapExternAmountOut: pool amount in too large\\\"\\n    );\\n\\n    emit LOG_EXIT(msg.sender, _token, _tokenAmountOut);\\n\\n    LibPoolToken._burn(msg.sender, poolAmountIn);\\n\\n    emit PoolExited(msg.sender, _tokenAmountOut);\\n\\n    uint256 bal = bPool.getBalance(_token);\\n    LibUnderlying._pushUnderlying(_token, msg.sender, _tokenAmountOut, bal);\\n\\n    return poolAmountIn;\\n  }\\n\\n  function exitPoolTakingloss(uint256 _amount, address[] calldata _lossTokens)\\n    external\\n    lockBPoolSwap\\n  {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    uint256 poolTotal = PCStorage.load().totalSupply;\\n    uint256 ratio = _amount.bdiv(poolTotal);\\n    require(ratio != 0);\\n\\n    LibPoolToken._burn(msg.sender, _amount);\\n\\n    address[] memory tokens = bPool.getCurrentTokens();\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      // If taking loss on token skip one iteration of the loop\\n      if (_contains(tokens[i], _lossTokens)) {\\n        continue;\\n      }\\n      address t = tokens[i];\\n      uint256 bal = bPool.getBalance(t);\\n      uint256 tAo = ratio.bmul(bal);\\n      emit LOG_EXIT(msg.sender, t, tAo);\\n      LibUnderlying._pushUnderlying(t, msg.sender, tAo, bal);\\n    }\\n    emit PoolExitedWithLoss(msg.sender, _amount, _lossTokens);\\n  }\\n\\n  /**\\n        @notice Searches for an address in an array of addresses and returns if found\\n        @param _needle Address to look for\\n        @param _haystack Array to search\\n        @return If value is found\\n    */\\n  function _contains(address _needle, address[] memory _haystack) internal pure returns (bool) {\\n    for (uint256 i = 0; i < _haystack.length; i++) {\\n      if (_haystack[i] == _needle) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function joinPool(uint256 _amount) external {\\n    IBPool bPool = PBStorage.load().bPool;\\n    uint256[] memory maxAmountsIn = new uint256[](bPool.getCurrentTokens().length);\\n    for (uint256 i = 0; i < maxAmountsIn.length; i++) {\\n      maxAmountsIn[i] = uint256(-1);\\n    }\\n    _joinPool(_amount, maxAmountsIn);\\n  }\\n\\n  function joinPool(uint256 _amount, uint256[] calldata _maxAmountsIn) external {\\n    _joinPool(_amount, _maxAmountsIn);\\n  }\\n\\n  function _joinPool(uint256 _amount, uint256[] memory _maxAmountsIn) internal lockBPoolSwap {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    uint256 poolTotal = PCStorage.load().totalSupply;\\n    uint256 ratio = _amount.bdiv(poolTotal);\\n    require(ratio != 0);\\n\\n    address[] memory tokens = bPool.getCurrentTokens();\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address t = tokens[i];\\n      uint256 bal = bPool.getBalance(t);\\n      uint256 tokenAmountIn = ratio.bmul(bal);\\n      require(\\n        tokenAmountIn <= _maxAmountsIn[i],\\n        \\\"LibPoolEntryExit.joinPool: Token in amount too big\\\"\\n      );\\n      emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n      LibUnderlying._pullUnderlying(t, msg.sender, tokenAmountIn, bal);\\n    }\\n    LibPoolToken._mint(msg.sender, _amount);\\n    emit PoolJoined(msg.sender, _amount);\\n  }\\n\\n  function joinswapExternAmountIn(\\n    address _token,\\n    uint256 _amountIn,\\n    uint256 _minPoolAmountOut\\n  ) external lockBPoolSwap returns (uint256 poolAmountOut)  {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    require(bPool.isBound(_token), \\\"LibPoolEntryExit.joinswapExternAmountIn: Token Not Bound\\\");\\n\\n    poolAmountOut = bPool.calcPoolOutGivenSingleIn(\\n      bPool.getBalance(_token),\\n      bPool.getDenormalizedWeight(_token),\\n      PCStorage.load().totalSupply,\\n      bPool.getTotalDenormalizedWeight(),\\n      _amountIn,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(\\n      poolAmountOut >= _minPoolAmountOut,\\n      \\\"LibPoolEntryExit.joinswapExternAmountIn: Insufficient pool amount out\\\"\\n    );\\n\\n    emit LOG_JOIN(msg.sender, _token, _amountIn);\\n\\n    LibPoolToken._mint(msg.sender, poolAmountOut);\\n\\n    emit PoolJoined(msg.sender, poolAmountOut);\\n\\n    uint256 bal = bPool.getBalance(_token);\\n    LibUnderlying._pullUnderlying(_token, msg.sender, _amountIn, bal);\\n\\n    return poolAmountOut;\\n  }\\n\\n  function joinswapPoolAmountOut(\\n    address _token,\\n    uint256 _amountOut,\\n    uint256 _maxAmountIn\\n  ) external lockBPoolSwap returns (uint256 tokenAmountIn) {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    require(bPool.isBound(_token), \\\"LibPoolEntryExit.joinswapPoolAmountOut: Token Not Bound\\\");\\n\\n    tokenAmountIn = bPool.calcSingleInGivenPoolOut(\\n      bPool.getBalance(_token),\\n      bPool.getDenormalizedWeight(_token),\\n      PCStorage.load().totalSupply,\\n      bPool.getTotalDenormalizedWeight(),\\n      _amountOut,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(\\n      tokenAmountIn <= _maxAmountIn,\\n      \\\"LibPoolEntryExit.joinswapPoolAmountOut: Token amount in too big\\\"\\n    );\\n\\n    emit LOG_JOIN(msg.sender, _token, tokenAmountIn);\\n\\n    LibPoolToken._mint(msg.sender, _amountOut);\\n\\n    emit PoolJoined(msg.sender, _amountOut);\\n\\n    uint256 bal = bPool.getBalance(_token);\\n    LibUnderlying._pullUnderlying(_token, msg.sender, tokenAmountIn, bal);\\n\\n    return tokenAmountIn;\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/LibUnderlying.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IBPool.sol\\\";\\n\\nimport {PBasicSmartPoolStorage as PBStorage} from \\\"../storage/PBasicSmartPoolStorage.sol\\\";\\n\\nimport \\\"./Math.sol\\\";\\n\\nlibrary LibUnderlying {\\n  using Math for uint256;\\n\\n  function _pullUnderlying(\\n    address _token,\\n    address _from,\\n    uint256 _amount,\\n    uint256 _tokenBalance\\n  ) internal {\\n    IBPool bPool = PBStorage.load().bPool;\\n    // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\\n    uint256 tokenWeight = bPool.getDenormalizedWeight(_token);\\n\\n    require(\\n      IERC20(_token).transferFrom(_from, address(this), _amount),\\n      \\\"LibUnderlying._pullUnderlying: transferFrom failed\\\"\\n    );\\n    bPool.rebind(_token, _tokenBalance.badd(_amount), tokenWeight);\\n  }\\n\\n  function _pushUnderlying(\\n    address _token,\\n    address _to,\\n    uint256 _amount,\\n    uint256 _tokenBalance\\n  ) internal {\\n    IBPool bPool = PBStorage.load().bPool;\\n    // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\\n    uint256 tokenWeight = bPool.getDenormalizedWeight(_token);\\n    bPool.rebind(_token, _tokenBalance.bsub(_amount), tokenWeight);\\n\\n    require(\\n      IERC20(_token).transfer(_to, _amount),\\n      \\\"LibUnderlying._pushUnderlying: transfer failed\\\"\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibPoolEntryExitV2.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\nimport {PBasicSmartPoolStorage as PBStorage} from \\\"../storage/PBasicSmartPoolStorage.sol\\\";\\nimport {PCTokenStorage as PCStorage} from \\\"../storage/PCTokenStorage.sol\\\";\\nimport \\\"./LibFees.sol\\\";\\n\\nimport \\\"./LibPoolToken.sol\\\";\\nimport \\\"./LibUnderlying.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\nlibrary LibPoolEntryExitV2 {\\n  using Math for uint256;\\n\\n  event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\\n  event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\\n  event PoolExited(address indexed from, uint256 amount);\\n  event PoolExitedWithLoss(address indexed from, uint256 amount, address[] lossTokens);\\n  event PoolJoined(address indexed from, uint256 amount, uint16 indexed _referral);\\n\\n  modifier lockBPoolSwap() {\\n    IBPool bPool = PBStorage.load().bPool;\\n    if(bPool.isPublicSwap()) {\\n      // If public swap is enabled turn it of, execute function and turn it off again\\n      bPool.setPublicSwap(false);\\n      _;\\n      bPool.setPublicSwap(true);\\n    } else {\\n      // If public swap is not enabled just execute\\n      _;\\n    }\\n  }\\n\\n  function exitPool(uint256 _amount) internal {\\n    IBPool bPool = PBStorage.load().bPool;\\n    uint256[] memory minAmountsOut = new uint256[](bPool.getCurrentTokens().length);\\n    _exitPool(_amount, minAmountsOut);\\n  }\\n\\n  function exitPool(uint256 _amount, uint256[] calldata _minAmountsOut) external {\\n    _exitPool(_amount, _minAmountsOut);\\n  }\\n\\n  function _exitPool(uint256 _amount, uint256[] memory _minAmountsOut) internal lockBPoolSwap {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    uint256 poolTotal = PCStorage.load().totalSupply;\\n    uint256 ratio = _amount.bdiv(poolTotal);\\n    require(ratio != 0);\\n\\n    LibPoolToken._burn(msg.sender, _amount);\\n\\n    address[] memory tokens = bPool.getCurrentTokens();\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address token = tokens[i];\\n      uint256 balance = bPool.getBalance(token);\\n      uint256 tokenAmountOut = ratio.bmul(balance);\\n\\n      require(\\n        tokenAmountOut >= _minAmountsOut[i],\\n        \\\"LibPoolEntryExit.exitPool: Token amount out too small\\\"\\n      );\\n\\n      emit LOG_EXIT(msg.sender, token, tokenAmountOut);\\n      LibUnderlying._pushUnderlying(token, msg.sender, tokenAmountOut, balance);\\n    }\\n    emit PoolExited(msg.sender, _amount);\\n  }\\n\\n  function exitswapPoolAmountIn(\\n    address _token,\\n    uint256 _poolAmountIn,\\n    uint256 _minAmountOut\\n  ) external lockBPoolSwap returns (uint256 tokenAmountOut) {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    require(bPool.isBound(_token), \\\"LibPoolEntryExit.exitswapPoolAmountIn: Token Not Bound\\\");\\n\\n    tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\\n      bPool.getBalance(_token),\\n      bPool.getDenormalizedWeight(_token),\\n      PCStorage.load().totalSupply,\\n      bPool.getTotalDenormalizedWeight(),\\n      _poolAmountIn,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(\\n      tokenAmountOut >= _minAmountOut,\\n      \\\"LibPoolEntryExit.exitswapPoolAmountIn: Token Not Bound\\\"\\n    );\\n\\n    emit LOG_EXIT(msg.sender, _token, tokenAmountOut);\\n\\n    LibPoolToken._burn(msg.sender, _poolAmountIn);\\n\\n    emit PoolExited(msg.sender, tokenAmountOut);\\n\\n    uint256 bal = bPool.getBalance(_token);\\n    LibUnderlying._pushUnderlying(_token, msg.sender, tokenAmountOut, bal);\\n\\n    return tokenAmountOut;\\n  }\\n\\n  function exitswapExternAmountOut(\\n    address _token,\\n    uint256 _tokenAmountOut,\\n    uint256 _maxPoolAmountIn\\n  ) external lockBPoolSwap returns (uint256 poolAmountIn) {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    require(bPool.isBound(_token), \\\"LibPoolEntryExit.exitswapExternAmountOut: Token Not Bound\\\");\\n\\n    poolAmountIn = bPool.calcPoolInGivenSingleOut(\\n      bPool.getBalance(_token),\\n      bPool.getDenormalizedWeight(_token),\\n      PCStorage.load().totalSupply,\\n      bPool.getTotalDenormalizedWeight(),\\n      _tokenAmountOut,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(\\n      poolAmountIn <= _maxPoolAmountIn,\\n      \\\"LibPoolEntryExit.exitswapExternAmountOut: pool amount in too large\\\"\\n    );\\n\\n    emit LOG_EXIT(msg.sender, _token, _tokenAmountOut);\\n\\n    LibPoolToken._burn(msg.sender, poolAmountIn);\\n\\n    emit PoolExited(msg.sender, _tokenAmountOut);\\n\\n    uint256 bal = bPool.getBalance(_token);\\n    LibUnderlying._pushUnderlying(_token, msg.sender, _tokenAmountOut, bal);\\n\\n    return poolAmountIn;\\n  }\\n\\n  function exitPoolTakingloss(uint256 _amount, address[] calldata _lossTokens)\\n    external\\n    lockBPoolSwap\\n  {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    uint256 poolTotal = PCStorage.load().totalSupply;\\n    uint256 ratio = _amount.bdiv(poolTotal);\\n    require(ratio != 0);\\n\\n    LibPoolToken._burn(msg.sender, _amount);\\n\\n    address[] memory tokens = bPool.getCurrentTokens();\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      // If taking loss on token skip one iteration of the loop\\n      if (_contains(tokens[i], _lossTokens)) {\\n        continue;\\n      }\\n      address t = tokens[i];\\n      uint256 bal = bPool.getBalance(t);\\n      uint256 tAo = ratio.bmul(bal);\\n      emit LOG_EXIT(msg.sender, t, tAo);\\n      LibUnderlying._pushUnderlying(t, msg.sender, tAo, bal);\\n    }\\n    emit PoolExitedWithLoss(msg.sender, _amount, _lossTokens);\\n  }\\n\\n  /**\\n        @notice Searches for an address in an array of addresses and returns if found\\n        @param _needle Address to look for\\n        @param _haystack Array to search\\n        @return If value is found\\n    */\\n  function _contains(address _needle, address[] memory _haystack) internal pure returns (bool) {\\n    for (uint256 i = 0; i < _haystack.length; i++) {\\n      if (_haystack[i] == _needle) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function joinPoolExpress(uint256 _amount, uint16 _referral) external {\\n    IBPool bPool = PBStorage.load().bPool;\\n    uint256[] memory maxAmountsIn = new uint256[](bPool.getCurrentTokens().length);\\n    for (uint256 i = 0; i < maxAmountsIn.length; i++) {\\n      maxAmountsIn[i] = uint256(-1);\\n    }\\n    _joinPool(_amount, maxAmountsIn, _referral);\\n  }\\n\\n  function joinPool(uint256 _amount, uint256[] calldata _maxAmountsIn, uint16 _referral) external {\\n    _joinPool(_amount, _maxAmountsIn, _referral);\\n  }\\n\\n  function _joinPool(uint256 _amount, uint256[] memory _maxAmountsIn, uint16 _referral) internal lockBPoolSwap {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    uint256 poolTotal = PCStorage.load().totalSupply;\\n    uint256 ratio = _amount.bdiv(poolTotal);\\n    require(ratio != 0);\\n\\n    address[] memory tokens = bPool.getCurrentTokens();\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address t = tokens[i];\\n      uint256 bal = bPool.getBalance(t);\\n      uint256 tokenAmountIn = ratio.bmul(bal);\\n      require(\\n        tokenAmountIn <= _maxAmountsIn[i],\\n        \\\"LibPoolEntryExit.joinPool: Token in amount too big\\\"\\n      );\\n      emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n      LibUnderlying._pullUnderlying(t, msg.sender, tokenAmountIn, bal);\\n    }\\n    LibPoolToken._mint(msg.sender, _amount);\\n    emit PoolJoined(msg.sender, _amount, _referral);\\n  }\\n\\n  function joinswapExternAmountIn(\\n    address _token,\\n    uint256 _amountIn,\\n    uint256 _minPoolAmountOut,\\n    uint16 _referral\\n  ) external lockBPoolSwap returns (uint256 poolAmountOut)  {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    require(bPool.isBound(_token), \\\"LibPoolEntryExit.joinswapExternAmountIn: Token Not Bound\\\");\\n\\n    poolAmountOut = bPool.calcPoolOutGivenSingleIn(\\n      bPool.getBalance(_token),\\n      bPool.getDenormalizedWeight(_token),\\n      PCStorage.load().totalSupply,\\n      bPool.getTotalDenormalizedWeight(),\\n      _amountIn,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(\\n      poolAmountOut >= _minPoolAmountOut,\\n      \\\"LibPoolEntryExit.joinswapExternAmountIn: Insufficient pool amount out\\\"\\n    );\\n\\n    emit LOG_JOIN(msg.sender, _token, _amountIn);\\n\\n    LibPoolToken._mint(msg.sender, poolAmountOut);\\n\\n    emit PoolJoined(msg.sender, poolAmountOut, _referral);\\n\\n    uint256 bal = bPool.getBalance(_token);\\n    LibUnderlying._pullUnderlying(_token, msg.sender, _amountIn, bal);\\n\\n    return poolAmountOut;\\n  }\\n\\n  function joinswapPoolAmountOut(\\n    address _token,\\n    uint256 _amountOut,\\n    uint256 _maxAmountIn,\\n    uint16 _referral\\n  ) external lockBPoolSwap returns (uint256 tokenAmountIn) {\\n    IBPool bPool = PBStorage.load().bPool;\\n    LibFees.chargeOutstandingAnnualFee();\\n    require(bPool.isBound(_token), \\\"LibPoolEntryExit.joinswapPoolAmountOut: Token Not Bound\\\");\\n\\n    tokenAmountIn = bPool.calcSingleInGivenPoolOut(\\n      bPool.getBalance(_token),\\n      bPool.getDenormalizedWeight(_token),\\n      PCStorage.load().totalSupply,\\n      bPool.getTotalDenormalizedWeight(),\\n      _amountOut,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(\\n      tokenAmountIn <= _maxAmountIn,\\n      \\\"LibPoolEntryExit.joinswapPoolAmountOut: Token amount in too big\\\"\\n    );\\n\\n    emit LOG_JOIN(msg.sender, _token, tokenAmountIn);\\n\\n    LibPoolToken._mint(msg.sender, _amountOut);\\n\\n    emit PoolJoined(msg.sender, _amountOut, _referral);\\n\\n    uint256 bal = bPool.getBalance(_token);\\n    LibUnderlying._pullUnderlying(_token, msg.sender, tokenAmountIn, bal);\\n\\n    return tokenAmountIn;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibPoolMath.sol\": {\r\n      \"content\": \"// modified version of\\n// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BMath.sol\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.4;\\n\\nimport \\\"./Math.sol\\\";\\nimport \\\"./LibFees.sol\\\";\\nimport {PBasicSmartPoolStorage as PBStorage} from \\\"../storage/PBasicSmartPoolStorage.sol\\\";\\nimport {PCTokenStorage as PCStorage} from \\\"../storage/PCTokenStorage.sol\\\";\\n\\nlibrary LibPoolMath {\\n  using Math for uint256;\\n\\n  uint256 constant BONE = 1 * 10**18;\\n  uint256 constant EXIT_FEE = 0;\\n\\n  /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcSpotPrice(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 spotPrice) {\\n    uint256 numer = tokenBalanceIn.bdiv(tokenWeightIn);\\n    uint256 denom = tokenBalanceOut.bdiv(tokenWeightOut);\\n    uint256 ratio = numer.bdiv(denom);\\n    uint256 scale = BONE.bdiv(BONE.bsub(swapFee));\\n    return (spotPrice = ratio.bmul(scale));\\n  }\\n\\n  /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcOutGivenIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountOut) {\\n    uint256 weightRatio = tokenWeightIn.bdiv(tokenWeightOut);\\n    uint256 adjustedIn = BONE.bsub(swapFee);\\n    adjustedIn = tokenAmountIn.bmul(adjustedIn);\\n    uint256 y = tokenBalanceIn.bdiv(tokenBalanceIn.badd(adjustedIn));\\n    uint256 foo = y.bpow(weightRatio);\\n    uint256 bar = BONE.bsub(foo);\\n    tokenAmountOut = tokenBalanceOut.bmul(bar);\\n    return tokenAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcInGivenOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountIn) {\\n    uint256 weightRatio = tokenWeightOut.bdiv(tokenWeightIn);\\n    uint256 diff = tokenBalanceOut.bsub(tokenAmountOut);\\n    uint256 y = tokenBalanceOut.bdiv(diff);\\n    uint256 foo = y.bpow(weightRatio);\\n    foo = foo.bsub(BONE);\\n    tokenAmountIn = BONE.bsub(swapFee);\\n    tokenAmountIn = tokenBalanceIn.bmul(foo).bdiv(tokenAmountIn);\\n    return tokenAmountIn;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n  function calcPoolOutGivenSingleIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 poolAmountOut) {\\n    // Charge the trading fee for the proportion of tokenAi\\n    ///  which is implicitly traded to the other pool tokens.\\n    // That proportion is (1- weightTokenIn)\\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n    uint256 normalizedWeight = tokenWeightIn.bdiv(totalWeight);\\n    uint256 zaz = BONE.bsub(normalizedWeight).bmul(swapFee);\\n    uint256 tokenAmountInAfterFee = tokenAmountIn.bmul(BONE.bsub(zaz));\\n\\n    uint256 newTokenBalanceIn = tokenBalanceIn.badd(tokenAmountInAfterFee);\\n    uint256 tokenInRatio = newTokenBalanceIn.bdiv(tokenBalanceIn);\\n\\n    uint256 poolRatio = tokenInRatio.bpow(normalizedWeight);\\n    uint256 newPoolSupply = poolRatio.bmul(poolSupply);\\n    poolAmountOut = newPoolSupply.bsub(poolSupply);\\n    return poolAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                      1 - |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n  function calcSingleInGivenPoolOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountIn) {\\n    uint256 normalizedWeight = tokenWeightIn.bdiv(totalWeight);\\n    uint256 newPoolSupply = poolSupply.badd(poolAmountOut);\\n    uint256 poolRatio = newPoolSupply.bdiv(poolSupply);\\n\\n    //uint256 newBalTi = poolRatio^(1/weightTi) * balTi;\\n    uint256 boo = BONE.bdiv(normalizedWeight);\\n    uint256 tokenInRatio = poolRatio.bpow(boo);\\n    uint256 newTokenBalanceIn = tokenInRatio.bmul(tokenBalanceIn);\\n    uint256 tokenAmountInAfterFee = newTokenBalanceIn.bsub(tokenBalanceIn);\\n    // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\\n    //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n    //uint256 tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n    uint256 zar = BONE.bsub(normalizedWeight).bmul(swapFee);\\n    tokenAmountIn = tokenAmountInAfterFee.bdiv(BONE.bsub(zar));\\n    return tokenAmountIn;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n  function calcSingleOutGivenPoolIn(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountOut) {\\n    uint256 normalizedWeight = tokenWeightOut.bdiv(totalWeight);\\n    // charge exit fee on the pool token side\\n    // pAiAfterExitFee = pAi*(1-exitFee)\\n    uint256 poolAmountInAfterExitFee = poolAmountIn.bmul(BONE.bsub(EXIT_FEE));\\n    uint256 newPoolSupply = poolSupply.bsub(poolAmountInAfterExitFee);\\n    uint256 poolRatio = newPoolSupply.bdiv(poolSupply);\\n\\n    // newBalTo = poolRatio^(1/weightTo) * balTo;\\n    uint256 tokenOutRatio = poolRatio.bpow(BONE.bdiv(normalizedWeight));\\n    uint256 newTokenBalanceOut = tokenOutRatio.bmul(tokenBalanceOut);\\n\\n    uint256 tokenAmountOutBeforeSwapFee = tokenBalanceOut.bsub(newTokenBalanceOut);\\n\\n    // charge swap fee on the output token side\\n    //uint256 tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n    uint256 zaz = BONE.bsub(normalizedWeight).bmul(swapFee);\\n    tokenAmountOut = tokenAmountOutBeforeSwapFee.bmul(BONE.bsub(zaz));\\n    return tokenAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n  function calcPoolInGivenSingleOut(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 poolAmountIn) {\\n    // charge swap fee on the output token side\\n    uint256 normalizedWeight = tokenWeightOut.bdiv(totalWeight);\\n    //uint256 tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n    uint256 zoo = BONE.bsub(normalizedWeight);\\n    uint256 zar = zoo.bmul(swapFee);\\n    uint256 tokenAmountOutBeforeSwapFee = tokenAmountOut.bdiv(BONE.bsub(zar));\\n\\n    uint256 newTokenBalanceOut = tokenBalanceOut.bsub(tokenAmountOutBeforeSwapFee);\\n    uint256 tokenOutRatio = newTokenBalanceOut.bdiv(tokenBalanceOut);\\n\\n    //uint256 newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n    uint256 poolRatio = tokenOutRatio.bpow(normalizedWeight);\\n    uint256 newPoolSupply = poolRatio.bmul(poolSupply);\\n    uint256 poolAmountInAfterExitFee = poolSupply.bsub(newPoolSupply);\\n\\n    // charge exit fee on the pool token side\\n    // pAi = pAiAfterExitFee/(1-exitFee)\\n    poolAmountIn = poolAmountInAfterExitFee.bdiv(BONE.bsub(EXIT_FEE));\\n    return poolAmountIn;\\n  }\\n\\n  // Wrapped public functions --------------------------------------------------------------------\\n\\n  /**\\n        @notice Gets the underlying assets and amounts to mint specific pool shares.\\n        @param _amount Amount of pool shares to calculate the values for\\n        @return tokens The addresses of the tokens\\n        @return amounts The amounts of tokens needed to mint that amount of pool shares\\n    */\\n  function calcTokensForAmount(uint256 _amount)\\n    external\\n    view\\n    returns (address[] memory tokens, uint256[] memory amounts)\\n  {\\n    tokens = PBStorage.load().bPool.getCurrentTokens();\\n    amounts = new uint256[](tokens.length);\\n    uint256 ratio = _amount.bdiv(\\n      PCStorage.load().totalSupply.badd(LibFees.calcOutstandingAnnualFee())\\n    );\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address t = tokens[i];\\n      uint256 bal = PBStorage.load().bPool.getBalance(t);\\n      uint256 amount = ratio.bmul(bal);\\n      amounts[i] = amount;\\n    }\\n  }\\n\\n  /**\\n    @notice Calculate the amount of pool tokens out for a given amount in\\n    @param _token Address of the input token\\n    @param _amount Amount of input token\\n    @return Amount of pool token\\n  */\\n  function calcPoolOutGivenSingleIn(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    uint256 tokenBalanceIn = s.bPool.getBalance(_token);\\n    uint256 tokenWeightIn = s.bPool.getDenormalizedWeight(_token);\\n    uint256 poolSupply = PCStorage.load().totalSupply.badd(LibFees.calcOutstandingAnnualFee());\\n    uint256 totalWeight = s.bPool.getTotalDenormalizedWeight();\\n    uint256 swapFee = s.bPool.getSwapFee();\\n\\n    return (\\n      LibPoolMath.calcPoolOutGivenSingleIn(\\n        tokenBalanceIn,\\n        tokenWeightIn,\\n        poolSupply,\\n        totalWeight,\\n        _amount,\\n        swapFee\\n      )\\n    );\\n  }\\n\\n  /**\\n    @notice Calculate single in given pool out\\n    @param _token Address of the input token\\n    @param _amount Amount of pool out token\\n    @return Amount of token in\\n  */\\n  function calcSingleInGivenPoolOut(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    uint256 tokenBalanceIn = s.bPool.getBalance(_token);\\n    uint256 tokenWeightIn = s.bPool.getDenormalizedWeight(_token);\\n    uint256 poolSupply = PCStorage.load().totalSupply.badd(LibFees.calcOutstandingAnnualFee());\\n    uint256 totalWeight = s.bPool.getTotalDenormalizedWeight();\\n    uint256 swapFee = s.bPool.getSwapFee();\\n\\n    return (\\n      LibPoolMath.calcSingleInGivenPoolOut(\\n        tokenBalanceIn,\\n        tokenWeightIn,\\n        poolSupply,\\n        totalWeight,\\n        _amount,\\n        swapFee\\n      )\\n    );\\n  }\\n\\n  /**\\n    @notice Calculate single out given pool in\\n    @param _token Address of output token\\n    @param _amount Amount of pool in\\n    @return Amount of token in\\n  */\\n  function calcSingleOutGivenPoolIn(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    uint256 tokenBalanceOut = s.bPool.getBalance(_token);\\n    uint256 tokenWeightOut = s.bPool.getDenormalizedWeight(_token);\\n    uint256 poolSupply = PCStorage.load().totalSupply.badd(LibFees.calcOutstandingAnnualFee());\\n    uint256 totalWeight = s.bPool.getTotalDenormalizedWeight();\\n    uint256 swapFee = s.bPool.getSwapFee();\\n\\n    return (\\n      LibPoolMath.calcSingleOutGivenPoolIn(\\n        tokenBalanceOut,\\n        tokenWeightOut,\\n        poolSupply,\\n        totalWeight,\\n        _amount,\\n        swapFee\\n      )\\n    );\\n  }\\n\\n  /**\\n    @notice Calculate pool in given single token out\\n    @param _token Address of output token\\n    @param _amount Amount of output token\\n    @return Amount of pool in\\n  */\\n  function calcPoolInGivenSingleOut(address _token, uint256 _amount)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    uint256 tokenBalanceOut = s.bPool.getBalance(_token);\\n    uint256 tokenWeightOut = s.bPool.getDenormalizedWeight(_token);\\n    uint256 poolSupply = PCStorage.load().totalSupply.badd(LibFees.calcOutstandingAnnualFee());\\n    uint256 totalWeight = s.bPool.getTotalDenormalizedWeight();\\n    uint256 swapFee = s.bPool.getSwapFee();\\n\\n    return (\\n      LibPoolMath.calcPoolInGivenSingleOut(\\n        tokenBalanceOut,\\n        tokenWeightOut,\\n        poolSupply,\\n        totalWeight,\\n        _amount,\\n        swapFee\\n      )\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibWeights.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nimport {PBasicSmartPoolStorage as PBStorage} from \\\"../storage/PBasicSmartPoolStorage.sol\\\";\\nimport {PV2SmartPoolStorage as P2Storage} from \\\"../storage/PV2SmartPoolStorage.sol\\\";\\nimport {PCTokenStorage as PCStorage} from \\\"../storage/PCTokenStorage.sol\\\";\\nimport {LibConst as constants} from \\\"./LibConst.sol\\\";\\nimport \\\"./LibPoolToken.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\nlibrary LibWeights {\\n  using Math for uint256;\\n\\n  function updateWeight(address _token, uint256 _newWeight) external {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n\\n    require(_newWeight >= constants.MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n    require(_newWeight <= constants.MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n\\n    uint256 currentWeight = s.bPool.getDenormalizedWeight(_token);\\n    uint256 currentBalance = s.bPool.getBalance(_token);\\n    uint256 poolShares;\\n    uint256 deltaBalance;\\n    uint256 deltaWeight;\\n    uint256 totalSupply = PCStorage.load().totalSupply;\\n    uint256 totalWeight = s.bPool.getTotalDenormalizedWeight();\\n\\n    if (_newWeight < currentWeight) {\\n      // If weight goes down we need to pull tokens and burn pool shares\\n      require(\\n        totalWeight.badd(currentWeight.bsub(_newWeight)) <= constants.MAX_TOTAL_WEIGHT,\\n        \\\"ERR_MAX_TOTAL_WEIGHT\\\"\\n      );\\n\\n      deltaWeight = currentWeight.bsub(_newWeight);\\n\\n      poolShares = totalSupply.bmul(deltaWeight.bdiv(totalWeight));\\n\\n      deltaBalance = currentBalance.bmul(deltaWeight.bdiv(currentWeight));\\n\\n      // New balance cannot be lower than MIN_BALANCE\\n      require(currentBalance.bsub(deltaBalance) >= constants.MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n      // First gets the tokens from this contract (Pool Controller) to msg.sender\\n      s.bPool.rebind(_token, currentBalance.bsub(deltaBalance), _newWeight);\\n\\n      // Now with the tokens this contract can send them to msg.sender\\n      require(IERC20(_token).transfer(msg.sender, deltaBalance), \\\"ERR_ERC20_FALSE\\\");\\n\\n      // Cancel potential weight adjustment process.\\n      ws.startBlock = 0;\\n\\n      LibPoolToken._burn(msg.sender, poolShares);\\n    } else {\\n      // This means the controller will deposit tokens to keep the price.\\n      // They will be minted and given PCTokens\\n      require(\\n        totalWeight.badd(_newWeight.bsub(currentWeight)) <= constants.MAX_TOTAL_WEIGHT,\\n        \\\"ERR_MAX_TOTAL_WEIGHT\\\"\\n      );\\n\\n      deltaWeight = _newWeight.bsub(currentWeight);\\n      poolShares = totalSupply.bmul(deltaWeight.bdiv(totalWeight));\\n      deltaBalance = currentBalance.bmul(deltaWeight.bdiv(currentWeight));\\n\\n      // First gets the tokens from msg.sender to this contract (Pool Controller)\\n      require(\\n        IERC20(_token).transferFrom(msg.sender, address(this), deltaBalance),\\n        \\\"TRANSFER_FAILED\\\"\\n      );\\n      // Now with the tokens this contract can bind them to the pool it controls\\n      s.bPool.rebind(_token, currentBalance.badd(deltaBalance), _newWeight);\\n\\n      // Cancel potential weight adjustment process.\\n      ws.startBlock = 0;\\n\\n      LibPoolToken._mint(msg.sender, poolShares);\\n    }\\n  }\\n\\n  function updateWeightsGradually(\\n    uint256[] calldata _newWeights,\\n    uint256 _startBlock,\\n    uint256 _endBlock\\n  ) external {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n\\n    uint256 weightsSum = 0;\\n    address[] memory tokens = s.bPool.getCurrentTokens();\\n    // Check that endWeights are valid now to avoid reverting in a future pokeWeights call\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      require(_newWeights[i] <= constants.MAX_WEIGHT, \\\"ERR_WEIGHT_ABOVE_MAX\\\");\\n      require(_newWeights[i] >= constants.MIN_WEIGHT, \\\"ERR_WEIGHT_BELOW_MIN\\\");\\n      weightsSum = weightsSum.badd(_newWeights[i]);\\n    }\\n    require(weightsSum <= constants.MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n\\n    if (block.number > _startBlock) {\\n      // This means the weight update should start ASAP\\n      ws.startBlock = block.number;\\n    } else {\\n      ws.startBlock = _startBlock;\\n    }\\n    ws.endBlock = _endBlock;\\n    ws.newWeights = _newWeights;\\n\\n    require(\\n      _endBlock > _startBlock,\\n      \\\"PWeightControlledSmartPool.updateWeightsGradually: End block must be after start block\\\"\\n    );\\n\\n    delete ws.startWeights;\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      // startWeights are current weights\\n      ws.startWeights.push(s.bPool.getDenormalizedWeight(tokens[i]));\\n    }\\n  }\\n\\n  function pokeWeights() external {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n\\n    require(ws.startBlock != 0, \\\"ERR_WEIGHT_ADJUSTMENT_FINISHED\\\");\\n    require(block.number >= ws.startBlock, \\\"ERR_CANT_POKE_YET\\\");\\n\\n    // This allows for pokes after endBlock that get weights to endWeights\\n    uint256 minBetweenEndBlockAndThisBlock;\\n    if (block.number > ws.endBlock) {\\n      minBetweenEndBlockAndThisBlock = ws.endBlock;\\n    } else {\\n      minBetweenEndBlockAndThisBlock = block.number;\\n    }\\n\\n    uint256 blockPeriod = ws.endBlock.bsub(ws.startBlock);\\n    uint256 weightDelta;\\n    uint256 newWeight;\\n    address[] memory tokens = s.bPool.getCurrentTokens();\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      if (ws.startWeights[i] >= ws.newWeights[i]) {\\n        weightDelta = ws.startWeights[i].bsub(ws.newWeights[i]);\\n        newWeight = ws.startWeights[i].bsub(\\n          (minBetweenEndBlockAndThisBlock.bsub(ws.startBlock)).bmul(weightDelta.bdiv(blockPeriod))\\n        );\\n      } else {\\n        weightDelta = ws.newWeights[i].bsub(ws.startWeights[i]);\\n        newWeight = ws.startWeights[i].badd(\\n          (minBetweenEndBlockAndThisBlock.bsub(ws.startBlock)).bmul(weightDelta.bdiv(blockPeriod))\\n        );\\n      }\\n      s.bPool.rebind(tokens[i], s.bPool.getBalance(tokens[i]), newWeight);\\n    }\\n\\n    if(minBetweenEndBlockAndThisBlock == ws.endBlock) {\\n      // All the weights are adjusted, adjustment finished.\\n\\n      // save gas option: set this to max number instead of 0\\n      // And be able to remove ERR_WEIGHT_ADJUSTMENT_FINISHED check\\n      ws.startBlock = 0;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/PCToken.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.4;\\n\\nimport {PCTokenStorage as PCStorage} from \\\"./storage/PCTokenStorage.sol\\\";\\nimport \\\"./libraries/LibPoolToken.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\n\\n\\n// Highly opinionated token implementation\\n// Based on the balancer Implementation\\n\\ncontract PCToken is IERC20 {\\n  using Math for uint256;\\n\\n  event Approval(address indexed _src, address indexed _dst, uint256 _amount);\\n  event Transfer(address indexed _src, address indexed _dst, uint256 _amount);\\n\\n  uint8 public constant decimals = 18;\\n\\n  function _mint(uint256 _amount) internal {\\n    LibPoolToken._mint(address(this), _amount);\\n  }\\n\\n  function _burn(uint256 _amount) internal {\\n    LibPoolToken._burn(address(this), _amount);\\n  }\\n\\n  function _move(\\n    address _src,\\n    address _dst,\\n    uint256 _amount\\n  ) internal {\\n    PCStorage.StorageStruct storage s = PCStorage.load();\\n    require(s.balance[_src] >= _amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\n    s.balance[_src] = s.balance[_src].bsub(_amount);\\n    s.balance[_dst] = s.balance[_dst].badd(_amount);\\n    emit Transfer(_src, _dst, _amount);\\n  }\\n\\n  function _push(address _to, uint256 _amount) internal {\\n    _move(address(this), _to, _amount);\\n  }\\n\\n  function _pull(address _from, uint256 _amount) internal {\\n    _move(_from, address(this), _amount);\\n  }\\n\\n  function allowance(address _src, address _dst) external override view returns (uint256) {\\n    return PCStorage.load().allowance[_src][_dst];\\n  }\\n\\n  function balanceOf(address _whom) external override view returns (uint256) {\\n    return PCStorage.load().balance[_whom];\\n  }\\n\\n  function totalSupply() public override view returns (uint256) {\\n    return PCStorage.load().totalSupply;\\n  }\\n\\n  function name() external view returns (string memory) {\\n    return PCStorage.load().name;\\n  }\\n\\n  function symbol() external view returns (string memory) {\\n    return PCStorage.load().symbol;\\n  }\\n\\n  function approve(address _dst, uint256 _amount) external override returns (bool) {\\n    PCStorage.load().allowance[msg.sender][_dst] = _amount;\\n    emit Approval(msg.sender, _dst, _amount);\\n    return true;\\n  }\\n\\n  function increaseApproval(address _dst, uint256 _amount) external returns (bool) {\\n    PCStorage.StorageStruct storage s = PCStorage.load();\\n    s.allowance[msg.sender][_dst] = s.allowance[msg.sender][_dst].badd(_amount);\\n    emit Approval(msg.sender, _dst, s.allowance[msg.sender][_dst]);\\n    return true;\\n  }\\n\\n  function decreaseApproval(address _dst, uint256 _amount) external returns (bool) {\\n    PCStorage.StorageStruct storage s = PCStorage.load();\\n    uint256 oldValue = s.allowance[msg.sender][_dst];\\n    if (_amount > oldValue) {\\n      s.allowance[msg.sender][_dst] = 0;\\n    } else {\\n      s.allowance[msg.sender][_dst] = oldValue.bsub(_amount);\\n    }\\n    emit Approval(msg.sender, _dst, s.allowance[msg.sender][_dst]);\\n    return true;\\n  }\\n\\n  function transfer(address _dst, uint256 _amount) external override returns (bool) {\\n    _move(msg.sender, _dst, _amount);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address _src,\\n    address _dst,\\n    uint256 _amount\\n  ) external override returns (bool) {\\n    PCStorage.StorageStruct storage s = PCStorage.load();\\n    require(\\n      msg.sender == _src || _amount <= s.allowance[_src][msg.sender],\\n      \\\"ERR_PCTOKEN_BAD_CALLER\\\"\\n    );\\n    _move(_src, _dst, _amount);\\n    if (msg.sender != _src && s.allowance[_src][msg.sender] != uint256(-1)) {\\n      s.allowance[_src][msg.sender] = s.allowance[_src][msg.sender].bsub(_amount);\\n      emit Approval(msg.sender, _dst, s.allowance[_src][msg.sender]);\\n    }\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ReentryProtection.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\nimport {ReentryProtectionStorage as RPStorage} from \\\"./storage/ReentryProtectionStorage.sol\\\";\\n\\ncontract ReentryProtection {\\n\\n  modifier noReentry {\\n    // Use counter to only write to storage once\\n    RPStorage.StorageStruct storage s = RPStorage.load();\\n    s.lockCounter++;\\n    uint256 lockValue = s.lockCounter;\\n    _;\\n    require(lockValue == s.lockCounter, \\\"ReentryProtection.noReentry: reentry detected\\\");\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/storage/ReentryProtectionStorage.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\nlibrary ReentryProtectionStorage {\\n  bytes32 public constant rpSlot = keccak256(\\\"ReentryProtection.storage.location\\\");\\n  struct StorageStruct {\\n    uint256 lockCounter;\\n  }\\n\\n  /**\\n        @notice Load pool token storage\\n        @return s Storage pointer to the pool token struct\\n    */\\n  function load() internal pure returns (StorageStruct storage s) {\\n    bytes32 loc = rpSlot;\\n    assembly {\\n      s_slot := loc\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/smart-pools/PV2SmartPool.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity 0.6.4;\\n\\nimport \\\"../interfaces/IPV2SmartPool.sol\\\";\\nimport \\\"../interfaces/IBPool.sol\\\";\\nimport \\\"../PCToken.sol\\\";\\nimport \\\"../ReentryProtection.sol\\\";\\n\\nimport \\\"../libraries/LibPoolToken.sol\\\";\\nimport \\\"../libraries/LibAddRemoveToken.sol\\\";\\nimport \\\"../libraries/LibPoolEntryExit.sol\\\";\\nimport \\\"../libraries/LibPoolMath.sol\\\";\\nimport \\\"../libraries/LibWeights.sol\\\";\\nimport \\\"../libraries/LibSafeApprove.sol\\\";\\n\\nimport {PBasicSmartPoolStorage as PBStorage} from \\\"../storage/PBasicSmartPoolStorage.sol\\\";\\nimport {PCTokenStorage as PCStorage} from \\\"../storage/PCTokenStorage.sol\\\";\\nimport {PCappedSmartPoolStorage as PCSStorage} from \\\"../storage/PCappedSmartPoolStorage.sol\\\";\\nimport {PV2SmartPoolStorage as P2Storage} from \\\"../storage/PV2SmartPoolStorage.sol\\\";\\n\\ncontract PV2SmartPool is IPV2SmartPool, PCToken, ReentryProtection {\\n  using LibSafeApprove for IERC20;\\n\\n  event TokensApproved();\\n  event ControllerChanged(address indexed previousController, address indexed newController);\\n  event PublicSwapSetterChanged(address indexed previousSetter, address indexed newSetter);\\n  event TokenBinderChanged(address indexed previousTokenBinder, address indexed newTokenBinder);\\n  event PublicSwapSet(address indexed setter, bool indexed value);\\n  event SwapFeeSet(address indexed setter, uint256 newFee);\\n  event CapChanged(address indexed setter, uint256 oldCap, uint256 newCap);\\n  event CircuitBreakerTripped();\\n  event JoinExitEnabledChanged(address indexed setter, bool oldValue, bool newValue);\\n  event CircuitBreakerChanged(\\n    address indexed _oldCircuitBreaker,\\n    address indexed _newCircuitBreaker\\n  );\\n\\n  modifier ready() {\\n    require(address(PBStorage.load().bPool) != address(0), \\\"PV2SmartPool.ready: not ready\\\");\\n    _;\\n  }\\n\\n  modifier onlyController() {\\n    require(\\n      msg.sender == PBStorage.load().controller,\\n      \\\"PV2SmartPool.onlyController: not controller\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyPublicSwapSetter() {\\n    require(\\n      msg.sender == PBStorage.load().publicSwapSetter,\\n      \\\"PV2SmartPool.onlyPublicSwapSetter: not public swap setter\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyTokenBinder() {\\n    require(\\n      msg.sender == PBStorage.load().tokenBinder,\\n      \\\"PV2SmartPool.onlyTokenBinder: not token binder\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyPublicSwap() {\\n    require(\\n      PBStorage.load().bPool.isPublicSwap(),\\n      \\\"PV2SmartPool.onlyPublicSwap: swapping not enabled\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyCircuitBreaker() {\\n    require(\\n      msg.sender == P2Storage.load().circuitBreaker,\\n      \\\"PV2SmartPool.onlyCircuitBreaker: not circuit breaker\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyJoinExitEnabled() {\\n    require(\\n      P2Storage.load().joinExitEnabled,\\n      \\\"PV2SmartPool.onlyJoinExitEnabled: join and exit not enabled\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier withinCap() {\\n    _;\\n    require(totalSupply() < PCSStorage.load().cap, \\\"PV2SmartPool.withinCap: Cap limit reached\\\");\\n  }\\n\\n  /**\\n        @notice Initialises the contract\\n        @param _bPool Address of the underlying balancer pool\\n        @param _name Name for the smart pool token\\n        @param _symbol Symbol for the smart pool token\\n        @param _initialSupply Initial token supply to mint\\n    */\\n  function init(\\n    address _bPool,\\n    string calldata _name,\\n    string calldata _symbol,\\n    uint256 _initialSupply\\n  ) external override {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    require(address(s.bPool) == address(0), \\\"PV2SmartPool.init: already initialised\\\");\\n    require(_bPool != address(0), \\\"PV2SmartPool.init: _bPool cannot be 0x00....000\\\");\\n    require(_initialSupply != 0, \\\"PV2SmartPool.init: _initialSupply can not zero\\\");\\n    s.bPool = IBPool(_bPool);\\n    s.controller = msg.sender;\\n    s.publicSwapSetter = msg.sender;\\n    s.tokenBinder = msg.sender;\\n    PCStorage.load().name = _name;\\n    PCStorage.load().symbol = _symbol;\\n\\n    LibPoolToken._mint(msg.sender, _initialSupply);\\n  }\\n\\n  /**\\n    @notice Sets approval to all tokens to the underlying balancer pool\\n    @dev It uses this function to save on gas in joinPool\\n  */\\n  function approveTokens() public override noReentry {\\n    IBPool bPool = PBStorage.load().bPool;\\n    address[] memory tokens = bPool.getCurrentTokens();\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      IERC20(tokens[i]).safeApprove(address(bPool), uint256(-1));\\n    }\\n    emit TokensApproved();\\n  }\\n\\n  // POOL EXIT ------------------------------------------------\\n\\n  /**\\n        @notice Burns pool shares and sends back the underlying assets leaving some in the pool\\n        @param _amount Amount of pool tokens to burn\\n        @param _lossTokens Tokens skipped on redemption\\n    */\\n  function exitPoolTakingloss(uint256 _amount, address[] calldata _lossTokens)\\n    external\\n    override\\n    ready\\n    noReentry\\n    onlyJoinExitEnabled\\n  {\\n    LibPoolEntryExit.exitPoolTakingloss(_amount, _lossTokens);\\n  }\\n\\n  /**\\n        @notice Burns pool shares and sends back the underlying assets\\n        @param _amount Amount of pool tokens to burn\\n    */\\n  function exitPool(uint256 _amount) external override ready noReentry onlyJoinExitEnabled {\\n    LibPoolEntryExit.exitPool(_amount);\\n  }\\n\\n  /**\\n    @notice Burn pool tokens and redeem underlying assets. With front running protection\\n    @param _amount Amount of pool tokens to burn\\n    @param _minAmountsOut Minimum amounts of underlying assets\\n  */\\n  function exitPool(uint256 _amount, uint256[] calldata _minAmountsOut)\\n    external\\n    override\\n    ready\\n    noReentry\\n    onlyJoinExitEnabled\\n  {\\n    LibPoolEntryExit.exitPool(_amount, _minAmountsOut);\\n  }\\n\\n  /**\\n        @notice Exitswap single asset pool exit given pool amount in\\n        @param _token Address of exit token\\n        @param _poolAmountIn Amount of pool tokens sending to the pool\\n        @return tokenAmountOut amount of exit tokens being withdrawn\\n    */\\n  function exitswapPoolAmountIn(\\n    address _token,\\n    uint256 _poolAmountIn,\\n    uint256 _minAmountOut\\n  )\\n    external\\n    override\\n    ready\\n    noReentry\\n    onlyPublicSwap\\n    onlyJoinExitEnabled\\n    returns (uint256 tokenAmountOut)\\n  {\\n    return LibPoolEntryExit.exitswapPoolAmountIn(_token, _poolAmountIn, _minAmountOut);\\n  }\\n\\n  /**\\n        @notice Exitswap single asset pool entry given token amount out\\n        @param _token Address of exit token\\n        @param _tokenAmountOut Amount of exit tokens\\n        @return poolAmountIn amount of pool tokens being deposited\\n    */\\n  function exitswapExternAmountOut(\\n    address _token,\\n    uint256 _tokenAmountOut,\\n    uint256 _maxPoolAmountIn\\n  )\\n    external\\n    override\\n    ready\\n    noReentry\\n    onlyPublicSwap\\n    onlyJoinExitEnabled\\n    returns (uint256 poolAmountIn)\\n  {\\n    return LibPoolEntryExit.exitswapExternAmountOut(_token, _tokenAmountOut, _maxPoolAmountIn);\\n  }\\n\\n  // POOL ENTRY -----------------------------------------------\\n  /**\\n        @notice Takes underlying assets and mints smart pool tokens. Enforces the cap\\n        @param _amount Amount of pool tokens to mint\\n    */\\n  function joinPool(uint256 _amount)\\n    external\\n    override\\n    withinCap\\n    ready\\n    noReentry\\n    onlyJoinExitEnabled\\n  {\\n    LibPoolEntryExit.joinPool(_amount);\\n  }\\n\\n  /**\\n      @notice Takes underlying assets and mints smart pool tokens.\\n      Enforces the cap. Allows you to specify the maximum amounts of underlying assets\\n      @param _amount Amount of pool tokens to mint\\n  */\\n  function joinPool(uint256 _amount, uint256[] calldata _maxAmountsIn)\\n    external\\n    override\\n    withinCap\\n    ready\\n    noReentry\\n    onlyJoinExitEnabled\\n  {\\n    LibPoolEntryExit.joinPool(_amount, _maxAmountsIn);\\n  }\\n\\n  /**\\n        @notice Joinswap single asset pool entry given token amount in\\n        @param _token Address of entry token\\n        @param _amountIn Amount of entry tokens\\n        @return poolAmountOut\\n    */\\n  function joinswapExternAmountIn(\\n    address _token,\\n    uint256 _amountIn,\\n    uint256 _minPoolAmountOut\\n  )\\n    external\\n    override\\n    ready\\n    withinCap\\n    onlyPublicSwap\\n    noReentry\\n    onlyJoinExitEnabled\\n    returns (uint256 poolAmountOut)\\n  {\\n    return LibPoolEntryExit.joinswapExternAmountIn(_token, _amountIn, _minPoolAmountOut);\\n  }\\n\\n  /**\\n        @notice Joinswap single asset pool entry given pool amount out\\n        @param _token Address of entry token\\n        @param _amountOut Amount of entry tokens to deposit into the pool\\n        @return tokenAmountIn\\n    */\\n  function joinswapPoolAmountOut(\\n    address _token,\\n    uint256 _amountOut,\\n    uint256 _maxAmountIn\\n  )\\n    external\\n    override\\n    ready\\n    withinCap\\n    onlyPublicSwap\\n    noReentry\\n    onlyJoinExitEnabled\\n    returns (uint256 tokenAmountIn)\\n  {\\n    return LibPoolEntryExit.joinswapPoolAmountOut(_token, _amountOut, _maxAmountIn);\\n  }\\n\\n  // ADMIN FUNCTIONS ------------------------------------------\\n\\n  /**\\n        @notice Bind a token to the underlying balancer pool. Can only be called by the token binder\\n        @param _token Token to bind\\n        @param _balance Amount to bind\\n        @param _denorm Denormalised weight\\n    */\\n  function bind(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denorm\\n  ) external override onlyTokenBinder noReentry {\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n    IBPool bPool = PBStorage.load().bPool;\\n    IERC20 token = IERC20(_token);\\n    require(\\n      token.transferFrom(msg.sender, address(this), _balance),\\n      \\\"PV2SmartPool.bind: transferFrom failed\\\"\\n    );\\n    // Cancel potential weight adjustment process.\\n    ws.startBlock = 0;\\n    token.safeApprove(address(bPool), uint256(-1));\\n    bPool.bind(_token, _balance, _denorm);\\n  }\\n\\n  /**\\n        @notice Rebind a token to the pool\\n        @param _token Token to bind\\n        @param _balance Amount to bind\\n        @param _denorm Denormalised weight\\n    */\\n  function rebind(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denorm\\n  ) external override onlyTokenBinder noReentry {\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n    IBPool bPool = PBStorage.load().bPool;\\n    IERC20 token = IERC20(_token);\\n\\n    // gulp old non acounted for token balance in the contract\\n    bPool.gulp(_token);\\n\\n    uint256 oldBalance = token.balanceOf(address(bPool));\\n    // If tokens need to be pulled from msg.sender\\n    if (_balance > oldBalance) {\\n      require(\\n        token.transferFrom(msg.sender, address(this), _balance.bsub(oldBalance)),\\n        \\\"PV2SmartPool.rebind: transferFrom failed\\\"\\n      );\\n      token.safeApprove(address(bPool), uint256(-1));\\n    }\\n\\n    bPool.rebind(_token, _balance, _denorm);\\n    // Cancel potential weight adjustment process.\\n    ws.startBlock = 0;\\n    // If any tokens are in this contract send them to msg.sender\\n    uint256 tokenBalance = token.balanceOf(address(this));\\n    if (tokenBalance > 0) {\\n      require(token.transfer(msg.sender, tokenBalance), \\\"PV2SmartPool.rebind: transfer failed\\\");\\n    }\\n  }\\n\\n  /**\\n        @notice Unbind a token\\n        @param _token Token to unbind\\n    */\\n  function unbind(address _token) external override onlyTokenBinder noReentry {\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n    IBPool bPool = PBStorage.load().bPool;\\n    IERC20 token = IERC20(_token);\\n    // unbind the token in the bPool\\n    bPool.unbind(_token);\\n\\n    // Cancel potential weight adjustment process.\\n    ws.startBlock = 0;\\n\\n    // If any tokens are in this contract send them to msg.sender\\n    uint256 tokenBalance = token.balanceOf(address(this));\\n    if (tokenBalance > 0) {\\n      require(token.transfer(msg.sender, tokenBalance), \\\"PV2SmartPool.unbind: transfer failed\\\");\\n    }\\n  }\\n\\n  /**\\n        @notice Sets the controller address. Can only be set by the current controller\\n        @param _controller Address of the new controller\\n    */\\n  function setController(address _controller) external override onlyController noReentry {\\n    emit ControllerChanged(PBStorage.load().controller, _controller);\\n    PBStorage.load().controller = _controller;\\n  }\\n\\n  /**\\n        @notice Sets public swap setter address. Can only be set by the controller\\n        @param _newPublicSwapSetter Address of the new public swap setter\\n    */\\n  function setPublicSwapSetter(address _newPublicSwapSetter)\\n    external\\n    override\\n    onlyController\\n    noReentry\\n  {\\n    emit PublicSwapSetterChanged(PBStorage.load().publicSwapSetter, _newPublicSwapSetter);\\n    PBStorage.load().publicSwapSetter = _newPublicSwapSetter;\\n  }\\n\\n  /**\\n        @notice Sets the token binder address. Can only be set by the controller\\n        @param _newTokenBinder Address of the new token binder\\n    */\\n  function setTokenBinder(address _newTokenBinder) external override onlyController noReentry {\\n    emit TokenBinderChanged(PBStorage.load().tokenBinder, _newTokenBinder);\\n    PBStorage.load().tokenBinder = _newTokenBinder;\\n  }\\n\\n  /**\\n        @notice Enables or disables public swapping on the underlying balancer pool.\\n                Can only be set by the controller.\\n        @param _public Public or not\\n    */\\n  function setPublicSwap(bool _public) external override onlyPublicSwapSetter noReentry {\\n    emit PublicSwapSet(msg.sender, _public);\\n    PBStorage.load().bPool.setPublicSwap(_public);\\n  }\\n\\n  /**\\n        @notice Set the swap fee on the underlying balancer pool.\\n                Can only be called by the controller.\\n        @param _swapFee The new swap fee\\n    */\\n  function setSwapFee(uint256 _swapFee) external override onlyController noReentry {\\n    emit SwapFeeSet(msg.sender, _swapFee);\\n    PBStorage.load().bPool.setSwapFee(_swapFee);\\n  }\\n\\n  /**\\n        @notice Set the maximum cap of the contract\\n        @param _cap New cap in wei\\n    */\\n  function setCap(uint256 _cap) external override onlyController noReentry {\\n    emit CapChanged(msg.sender, PCSStorage.load().cap, _cap);\\n    PCSStorage.load().cap = _cap;\\n  }\\n\\n  /**\\n    @notice Enable or disable joining and exiting\\n    @param _newValue enabled or not\\n  */\\n  function setJoinExitEnabled(bool _newValue) external override onlyController noReentry {\\n    emit JoinExitEnabledChanged(msg.sender, P2Storage.load().joinExitEnabled, _newValue);\\n    P2Storage.load().joinExitEnabled = _newValue;\\n  }\\n\\n  /**\\n    @notice Set the circuit breaker address. Can only be called by the controller\\n    @param _newCircuitBreaker Address of the new circuit breaker\\n  */\\n  function setCircuitBreaker(\\n    address _newCircuitBreaker\\n  ) external override onlyController noReentry {\\n    emit CircuitBreakerChanged(P2Storage.load().circuitBreaker, _newCircuitBreaker);\\n    P2Storage.load().circuitBreaker = _newCircuitBreaker;\\n  }\\n\\n  /**\\n    @notice Set the annual fee. Can only be called by the controller\\n    @param _newFee new fee 10**18 == 100% per 365 days. Max 10%\\n  */\\n  function setAnnualFee(uint256 _newFee) external override onlyController noReentry {\\n    LibFees.setAnnualFee(_newFee);\\n  }\\n\\n  /**\\n    @notice Charge the outstanding annual fee\\n  */\\n  function chargeOutstandingAnnualFee() external override noReentry {\\n    LibFees.chargeOutstandingAnnualFee();\\n  }\\n\\n  /**\\n    @notice Set the address that receives the annual fee. Can only be called by the controller\\n  */\\n  function setFeeRecipient(address _newRecipient) external override onlyController noReentry {\\n    LibFees.setFeeRecipient(_newRecipient);\\n  }\\n\\n  /**\\n    @notice Trip the circuit breaker which disabled exit, join and swaps\\n  */\\n  function tripCircuitBreaker() external override onlyCircuitBreaker {\\n    P2Storage.load().joinExitEnabled = false;\\n    PBStorage.load().bPool.setPublicSwap(false);\\n    emit CircuitBreakerTripped();\\n  }\\n\\n  // TOKEN AND WEIGHT FUNCTIONS -------------------------------\\n\\n  /**\\n    @notice Update the weight of a token. Can only be called by the controller\\n    @param _token Token to adjust the weight of\\n    @param _newWeight New denormalized weight\\n  */\\n  function updateWeight(address _token, uint256 _newWeight)\\n    external\\n    override\\n    noReentry\\n    onlyController\\n  {\\n    LibWeights.updateWeight(_token, _newWeight);\\n  }\\n\\n  /**\\n    @notice Gradually adjust the weights of a token. Can only be called by the controller\\n    @param _newWeights Target weights\\n    @param _startBlock Block to start weight adjustment\\n    @param _endBlock Block to finish weight adjustment\\n  */\\n  function updateWeightsGradually(\\n    uint256[] calldata _newWeights,\\n    uint256 _startBlock,\\n    uint256 _endBlock\\n  ) external override noReentry onlyController {\\n    LibWeights.updateWeightsGradually(_newWeights, _startBlock, _endBlock);\\n  }\\n\\n  /**\\n    @notice Poke the weight adjustment\\n  */\\n  function pokeWeights() external override noReentry {\\n    LibWeights.pokeWeights();\\n  }\\n\\n  /**\\n    @notice Apply the adding of a token. Can only be called by the controller\\n  */\\n  function applyAddToken() external override noReentry onlyController {\\n    LibAddRemoveToken.applyAddToken();\\n  }\\n\\n  /**\\n    @notice Commit a token to be added. Can only be called by the controller\\n    @param _token Address of the token to add\\n    @param _balance Amount of token to add\\n    @param _denormalizedWeight Denormalized weight\\n  */\\n  function commitAddToken(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denormalizedWeight\\n  ) external override noReentry onlyController {\\n    LibAddRemoveToken.commitAddToken(_token, _balance, _denormalizedWeight);\\n  }\\n\\n  /**\\n    @notice Remove a token from the smart pool. Can only be called by the controller\\n    @param _token Address of the token to remove\\n  */\\n  function removeToken(address _token) external override noReentry onlyController {\\n    LibAddRemoveToken.removeToken(_token);\\n  }\\n\\n  // VIEW FUNCTIONS -------------------------------------------\\n\\n  /**\\n        @notice Gets the underlying assets and amounts to mint specific pool shares.\\n        @param _amount Amount of pool shares to calculate the values for\\n        @return tokens The addresses of the tokens\\n        @return amounts The amounts of tokens needed to mint that amount of pool shares\\n    */\\n  function calcTokensForAmount(uint256 _amount)\\n    external\\n    override\\n    view\\n    returns (address[] memory tokens, uint256[] memory amounts)\\n  {\\n    return LibPoolMath.calcTokensForAmount(_amount);\\n  }\\n\\n  /**\\n    @notice Calculate the amount of pool tokens out for a given amount in\\n    @param _token Address of the input token\\n    @param _amount Amount of input token\\n    @return Amount of pool token\\n  */\\n  function calcPoolOutGivenSingleIn(address _token, uint256 _amount)\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    return LibPoolMath.calcPoolOutGivenSingleIn(_token, _amount);\\n  }\\n\\n  /**\\n    @notice Calculate single in given pool out\\n    @param _token Address of the input token\\n    @param _amount Amount of pool out token\\n    @return Amount of token in\\n  */\\n  function calcSingleInGivenPoolOut(address _token, uint256 _amount)\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    return LibPoolMath.calcSingleInGivenPoolOut(_token, _amount);\\n  }\\n\\n  /**\\n    @notice Calculate single out given pool in\\n    @param _token Address of output token\\n    @param _amount Amount of pool in\\n    @return Amount of token in\\n  */\\n  function calcSingleOutGivenPoolIn(address _token, uint256 _amount)\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    return LibPoolMath.calcSingleOutGivenPoolIn(_token, _amount);\\n  }\\n\\n  /**\\n    @notice Calculate pool in given single token out\\n    @param _token Address of output token\\n    @param _amount Amount of output token\\n    @return Amount of pool in\\n  */\\n  function calcPoolInGivenSingleOut(address _token, uint256 _amount)\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    return LibPoolMath.calcPoolInGivenSingleOut(_token, _amount);\\n  }\\n\\n  /**\\n    @notice Get the current tokens in the smart pool\\n    @return Addresses of the tokens in the smart pool\\n  */\\n  function getTokens() external override view returns (address[] memory) {\\n    return PBStorage.load().bPool.getCurrentTokens();\\n  }\\n\\n  /**\\n    @notice Get the address of the controller\\n    @return The address of the pool\\n  */\\n  function getController() external override view returns (address) {\\n    return PBStorage.load().controller;\\n  }\\n\\n  /**\\n    @notice Get the address of the public swap setter\\n    @return The public swap setter address\\n  */\\n  function getPublicSwapSetter() external override view returns (address) {\\n    return PBStorage.load().publicSwapSetter;\\n  }\\n\\n  /**\\n    @notice Get the address of the token binder\\n    @return The token binder address\\n  */\\n  function getTokenBinder() external override view returns (address) {\\n    return PBStorage.load().tokenBinder;\\n  }\\n\\n  /**\\n    @notice Get the address of the circuitBreaker\\n    @return The address of the circuitBreaker\\n  */\\n  function getCircuitBreaker() external override view returns (address) {\\n    return P2Storage.load().circuitBreaker;\\n  }\\n\\n  /**\\n    @notice Get if public swapping is enabled\\n    @return If public swapping is enabled\\n  */\\n  function isPublicSwap() external override view returns (bool) {\\n    return PBStorage.load().bPool.isPublicSwap();\\n  }\\n\\n  /**\\n    @notice Get the current cap\\n    @return The current cap in wei\\n  */\\n  function getCap() external override view returns (uint256) {\\n    return PCSStorage.load().cap;\\n  }\\n\\n  function getAnnualFee() external override view returns (uint256) {\\n    return P2Storage.load().annualFee;\\n  }\\n\\n  function getFeeRecipient() external override view returns (address) {\\n    return P2Storage.load().feeRecipient;\\n  }\\n\\n  /**\\n    @notice Get the denormalized weight of a specific token in the underlying balancer pool\\n    @return the normalized weight of the token in uint\\n  */\\n  function getDenormalizedWeight(address _token) external override view returns (uint256) {\\n    return PBStorage.load().bPool.getDenormalizedWeight(_token);\\n  }\\n\\n  /**\\n    @notice Get all denormalized weights\\n    @return weights Denormalized weights\\n  */\\n  function getDenormalizedWeights() external override view returns (uint256[] memory weights) {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    address[] memory tokens = s.bPool.getCurrentTokens();\\n    weights = new uint256[](tokens.length);\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      weights[i] = s.bPool.getDenormalizedWeight(tokens[i]);\\n    }\\n  }\\n\\n  /**\\n    @notice Get the address of the underlying Balancer pool\\n    @return The address of the underlying balancer pool\\n  */\\n  function getBPool() external override view returns (address) {\\n    return address(PBStorage.load().bPool);\\n  }\\n\\n  /**\\n    @notice Get the current swap fee\\n    @return The current swap fee\\n  */\\n  function getSwapFee() external override view returns (uint256) {\\n    return PBStorage.load().bPool.getSwapFee();\\n  }\\n\\n  /**\\n    @notice Get the target weights\\n    @return weights Target weights\\n  */\\n  function getNewWeights() external override view returns (uint256[] memory weights) {\\n    return P2Storage.load().newWeights;\\n  }\\n\\n  /**\\n    @notice Get weights at start of weight adjustment\\n    @return weights Start weights\\n  */\\n  function getStartWeights() external override view returns (uint256[] memory weights) {\\n    return P2Storage.load().startWeights;\\n  }\\n\\n  /**\\n    @notice Get start block of weight adjustment\\n    @return Start block\\n  */\\n  function getStartBlock() external override view returns (uint256) {\\n    return P2Storage.load().startBlock;\\n  }\\n\\n  /**\\n    @notice Get end block of weight adjustment\\n    @return End block\\n  */\\n  function getEndBlock() external override view returns (uint256) {\\n    return P2Storage.load().endBlock;\\n  }\\n\\n  /**\\n    @notice Get new token being added\\n    @return New token\\n  */\\n  function getNewToken() external override view returns (P2Storage.NewToken memory) {\\n    return P2Storage.load().newToken;\\n  }\\n\\n  /**\\n    @notice Get if joining and exiting is enabled\\n    @return Enabled or not\\n  */\\n  function getJoinExitEnabled() external override view returns (bool) {\\n    return P2Storage.load().joinExitEnabled;\\n  }\\n\\n  // UNSUPORTED METHODS ---------------------------------------\\n\\n  /**\\n    @notice Not Supported in PieDAO implementation of Balancer Smart Pools\\n  */\\n  function finalizeSmartPool() external override view {\\n    revert(\\\"PV2SmartPool.finalizeSmartPool: unsupported function\\\");\\n  }\\n\\n  /**\\n    @notice Not Supported in PieDAO implementation of Balancer Smart Pools\\n  */\\n  function createPool(uint256 initialSupply) external override view {\\n    revert(\\\"PV2SmartPool.createPool: unsupported function\\\");\\n  }\\n}\"\r\n    },\r\n    \"contracts/storage/PCappedSmartPoolStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.4;\\n\\nlibrary PCappedSmartPoolStorage {\\n  bytes32 public constant pcsSlot = keccak256(\\\"PCappedSmartPool.storage.location\\\");\\n\\n  struct StorageStruct {\\n    uint256 cap;\\n  }\\n\\n  /**\\n        @notice Load PBasicPool storage\\n        @return s Pointer to the storage struct\\n    */\\n  function load() internal pure returns (StorageStruct storage s) {\\n    bytes32 loc = pcsSlot;\\n    assembly {\\n      s_slot := loc\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/smart-pools/PV3SmartPool.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity 0.6.4;\\n\\nimport \\\"../interfaces/IPV3SmartPool.sol\\\";\\nimport \\\"../interfaces/IBPool.sol\\\";\\nimport \\\"../PCToken.sol\\\";\\nimport \\\"../ReentryProtection.sol\\\";\\n\\nimport \\\"../libraries/LibPoolToken.sol\\\";\\nimport \\\"../libraries/LibAddRemoveToken.sol\\\";\\nimport \\\"../libraries/LibPoolEntryExitV2.sol\\\";\\nimport \\\"../libraries/LibPoolMath.sol\\\";\\nimport \\\"../libraries/LibWeights.sol\\\";\\nimport \\\"../libraries/LibSafeApprove.sol\\\";\\n\\nimport {PBasicSmartPoolStorage as PBStorage} from \\\"../storage/PBasicSmartPoolStorage.sol\\\";\\nimport {PCTokenStorage as PCStorage} from \\\"../storage/PCTokenStorage.sol\\\";\\nimport {PCappedSmartPoolStorage as PCSStorage} from \\\"../storage/PCappedSmartPoolStorage.sol\\\";\\nimport {PV2SmartPoolStorage as P2Storage} from \\\"../storage/PV2SmartPoolStorage.sol\\\";\\n\\ncontract PV3SmartPool is IPV3SmartPool, PCToken, ReentryProtection {\\n  using LibSafeApprove for IERC20;\\n\\n  event TokensApproved();\\n  event ControllerChanged(address indexed previousController, address indexed newController);\\n  event PublicSwapSetterChanged(address indexed previousSetter, address indexed newSetter);\\n  event TokenBinderChanged(address indexed previousTokenBinder, address indexed newTokenBinder);\\n  event PublicSwapSet(address indexed setter, bool indexed value);\\n  event SwapFeeSet(address indexed setter, uint256 newFee);\\n  event CapChanged(address indexed setter, uint256 oldCap, uint256 newCap);\\n  event CircuitBreakerTripped();\\n  event JoinExitEnabledChanged(address indexed setter, bool oldValue, bool newValue);\\n  event CircuitBreakerChanged(\\n    address indexed _oldCircuitBreaker,\\n    address indexed _newCircuitBreaker\\n  );\\n\\n  modifier ready() {\\n    require(address(PBStorage.load().bPool) != address(0), \\\"PV3SmartPool.ready: not ready\\\");\\n    _;\\n  }\\n\\n  modifier onlyController() {\\n    require(\\n      msg.sender == PBStorage.load().controller,\\n      \\\"PV3SmartPool.onlyController: not controller\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyPublicSwapSetter() {\\n    require(\\n      msg.sender == PBStorage.load().publicSwapSetter,\\n      \\\"PV3SmartPool.onlyPublicSwapSetter: not public swap setter\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyTokenBinder() {\\n    require(\\n      msg.sender == PBStorage.load().tokenBinder,\\n      \\\"PV3SmartPool.onlyTokenBinder: not token binder\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyPublicSwap() {\\n    require(\\n      PBStorage.load().bPool.isPublicSwap(),\\n      \\\"PV3SmartPool.onlyPublicSwap: swapping not enabled\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyCircuitBreaker() {\\n    require(\\n      msg.sender == P2Storage.load().circuitBreaker,\\n      \\\"PV3SmartPool.onlyCircuitBreaker: not circuit breaker\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyJoinExitEnabled() {\\n    require(\\n      P2Storage.load().joinExitEnabled,\\n      \\\"PV3SmartPool.onlyJoinExitEnabled: join and exit not enabled\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier withinCap() {\\n    _;\\n    require(totalSupply() < PCSStorage.load().cap, \\\"PV3SmartPool.withinCap: Cap limit reached\\\");\\n  }\\n\\n  /**\\n        @notice Initialises the contract\\n        @param _bPool Address of the underlying balancer pool\\n        @param _name Name for the smart pool token\\n        @param _symbol Symbol for the smart pool token\\n        @param _initialSupply Initial token supply to mint\\n    */\\n  function init(\\n    address _bPool,\\n    string calldata _name,\\n    string calldata _symbol,\\n    uint256 _initialSupply\\n  ) external override {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    require(address(s.bPool) == address(0), \\\"PV3SmartPool.init: already initialised\\\");\\n    require(_bPool != address(0), \\\"PV3SmartPool.init: _bPool cannot be 0x00....000\\\");\\n    require(_initialSupply != 0, \\\"PV3SmartPool.init: _initialSupply can not zero\\\");\\n    s.bPool = IBPool(_bPool);\\n    s.controller = msg.sender;\\n    s.publicSwapSetter = msg.sender;\\n    s.tokenBinder = msg.sender;\\n    PCStorage.load().name = _name;\\n    PCStorage.load().symbol = _symbol;\\n\\n    LibPoolToken._mint(msg.sender, _initialSupply);\\n  }\\n\\n  /**\\n    @notice Sets approval to all tokens to the underlying balancer pool\\n    @dev It uses this function to save on gas in joinPool\\n  */\\n  function approveTokens() public override noReentry {\\n    IBPool bPool = PBStorage.load().bPool;\\n    address[] memory tokens = bPool.getCurrentTokens();\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      IERC20(tokens[i]).safeApprove(address(bPool), uint256(-1));\\n    }\\n    emit TokensApproved();\\n  }\\n\\n  // POOL EXIT ------------------------------------------------\\n\\n  /**\\n        @notice Burns pool shares and sends back the underlying assets leaving some in the pool\\n        @param _amount Amount of pool tokens to burn\\n        @param _lossTokens Tokens skipped on redemption\\n    */\\n  function exitPoolTakingloss(uint256 _amount, address[] calldata _lossTokens)\\n    external\\n    override\\n    ready\\n    noReentry\\n    onlyJoinExitEnabled\\n  {\\n    LibPoolEntryExitV2.exitPoolTakingloss(_amount, _lossTokens);\\n  }\\n\\n  /**\\n        @notice Burns pool shares and sends back the underlying assets\\n        @param _amount Amount of pool tokens to burn\\n    */\\n  function exitPool(uint256 _amount) external override ready noReentry onlyJoinExitEnabled {\\n    LibPoolEntryExitV2.exitPool(_amount);\\n  }\\n\\n  /**\\n    @notice Burn pool tokens and redeem underlying assets. With front running protection\\n    @param _amount Amount of pool tokens to burn\\n    @param _minAmountsOut Minimum amounts of underlying assets\\n  */\\n  function exitPool(uint256 _amount, uint256[] calldata _minAmountsOut)\\n    external\\n    override\\n    ready\\n    noReentry\\n    onlyJoinExitEnabled\\n  {\\n    LibPoolEntryExitV2.exitPool(_amount, _minAmountsOut);\\n  }\\n\\n  /**\\n        @notice Exitswap single asset pool exit given pool amount in\\n        @param _token Address of exit token\\n        @param _poolAmountIn Amount of pool tokens sending to the pool\\n        @return tokenAmountOut amount of exit tokens being withdrawn\\n    */\\n  function exitswapPoolAmountIn(\\n    address _token,\\n    uint256 _poolAmountIn,\\n    uint256 _minAmountOut\\n  )\\n    external\\n    override\\n    ready\\n    noReentry\\n    onlyPublicSwap\\n    onlyJoinExitEnabled\\n    returns (uint256 tokenAmountOut)\\n  {\\n    return LibPoolEntryExitV2.exitswapPoolAmountIn(_token, _poolAmountIn, _minAmountOut);\\n  }\\n\\n  /**\\n        @notice Exitswap single asset pool entry given token amount out\\n        @param _token Address of exit token\\n        @param _tokenAmountOut Amount of exit tokens\\n        @return poolAmountIn amount of pool tokens being deposited\\n    */\\n  function exitswapExternAmountOut(\\n    address _token,\\n    uint256 _tokenAmountOut,\\n    uint256 _maxPoolAmountIn\\n  )\\n    external\\n    override\\n    ready\\n    noReentry\\n    onlyPublicSwap\\n    onlyJoinExitEnabled\\n    returns (uint256 poolAmountIn)\\n  {\\n    return LibPoolEntryExitV2.exitswapExternAmountOut(_token, _tokenAmountOut, _maxPoolAmountIn);\\n  }\\n\\n  // POOL ENTRY -----------------------------------------------\\n  /**\\n        @notice Takes underlying assets and mints smart pool tokens. Enforces the cap\\n        @param _amount Amount of pool tokens to mint\\n    */\\n  function joinPoolExpress(uint256 _amount, uint16 _referral)\\n    external\\n    override\\n    withinCap\\n    ready\\n    noReentry\\n    onlyJoinExitEnabled\\n  {\\n    LibPoolEntryExitV2.joinPoolExpress(_amount, _referral);\\n  }\\n\\n  /**\\n      @notice Takes underlying assets and mints smart pool tokens.\\n      Enforces the cap. Allows you to specify the maximum amounts of underlying assets\\n      @param _amount Amount of pool tokens to mint\\n  */\\n  function joinPool(\\n    uint256 _amount,\\n    uint256[] calldata _maxAmountsIn,\\n    uint16 _referral\\n  ) external override withinCap ready noReentry onlyJoinExitEnabled {\\n    LibPoolEntryExitV2.joinPool(_amount, _maxAmountsIn, _referral);\\n  }\\n\\n  /**\\n        @notice Joinswap single asset pool entry given token amount in\\n        @param _token Address of entry token\\n        @param _amountIn Amount of entry tokens\\n        @return poolAmountOut\\n    */\\n  function joinswapExternAmountIn(\\n    address _token,\\n    uint256 _amountIn,\\n    uint256 _minPoolAmountOut,\\n    uint16 _referral\\n  )\\n    external\\n    override\\n    ready\\n    withinCap\\n    onlyPublicSwap\\n    noReentry\\n    onlyJoinExitEnabled\\n    returns (uint256 poolAmountOut)\\n  {\\n    return LibPoolEntryExitV2.joinswapExternAmountIn(_token, _amountIn, _minPoolAmountOut, _referral);\\n  }\\n\\n  /**\\n        @notice Joinswap single asset pool entry given pool amount out\\n        @param _token Address of entry token\\n        @param _amountOut Amount of entry tokens to deposit into the pool\\n        @return tokenAmountIn\\n    */\\n  function joinswapPoolAmountOut(\\n    address _token,\\n    uint256 _amountOut,\\n    uint256 _maxAmountIn,\\n    uint16 _referral\\n  )\\n    external\\n    override\\n    ready\\n    withinCap\\n    onlyPublicSwap\\n    noReentry\\n    onlyJoinExitEnabled\\n    returns (uint256 tokenAmountIn)\\n  {\\n    return LibPoolEntryExitV2.joinswapPoolAmountOut(_token, _amountOut, _maxAmountIn, _referral);\\n  }\\n\\n  // ADMIN FUNCTIONS ------------------------------------------\\n\\n  /**\\n        @notice Bind a token to the underlying balancer pool. Can only be called by the token binder\\n        @param _token Token to bind\\n        @param _balance Amount to bind\\n        @param _denorm Denormalised weight\\n    */\\n  function bind(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denorm\\n  ) external override onlyTokenBinder noReentry {\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n    IBPool bPool = PBStorage.load().bPool;\\n    IERC20 token = IERC20(_token);\\n    require(\\n      token.transferFrom(msg.sender, address(this), _balance),\\n      \\\"PV3SmartPool.bind: transferFrom failed\\\"\\n    );\\n    // Cancel potential weight adjustment process.\\n    ws.startBlock = 0;\\n    token.safeApprove(address(bPool), uint256(-1));\\n    bPool.bind(_token, _balance, _denorm);\\n  }\\n\\n  /**\\n        @notice Rebind a token to the pool\\n        @param _token Token to bind\\n        @param _balance Amount to bind\\n        @param _denorm Denormalised weight\\n    */\\n  function rebind(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denorm\\n  ) external override onlyTokenBinder noReentry {\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n    IBPool bPool = PBStorage.load().bPool;\\n    IERC20 token = IERC20(_token);\\n\\n    // gulp old non acounted for token balance in the contract\\n    bPool.gulp(_token);\\n\\n    uint256 oldBalance = token.balanceOf(address(bPool));\\n    // If tokens need to be pulled from msg.sender\\n    if (_balance > oldBalance) {\\n      require(\\n        token.transferFrom(msg.sender, address(this), _balance.bsub(oldBalance)),\\n        \\\"PV3SmartPool.rebind: transferFrom failed\\\"\\n      );\\n      token.safeApprove(address(bPool), uint256(-1));\\n    }\\n\\n    bPool.rebind(_token, _balance, _denorm);\\n    // Cancel potential weight adjustment process.\\n    ws.startBlock = 0;\\n    // If any tokens are in this contract send them to msg.sender\\n    uint256 tokenBalance = token.balanceOf(address(this));\\n    if (tokenBalance > 0) {\\n      require(token.transfer(msg.sender, tokenBalance), \\\"PV3SmartPool.rebind: transfer failed\\\");\\n    }\\n  }\\n\\n  /**\\n        @notice Unbind a token\\n        @param _token Token to unbind\\n    */\\n  function unbind(address _token) external override onlyTokenBinder noReentry {\\n    P2Storage.StorageStruct storage ws = P2Storage.load();\\n    IBPool bPool = PBStorage.load().bPool;\\n    IERC20 token = IERC20(_token);\\n    // unbind the token in the bPool\\n    bPool.unbind(_token);\\n\\n    // Cancel potential weight adjustment process.\\n    ws.startBlock = 0;\\n\\n    // If any tokens are in this contract send them to msg.sender\\n    uint256 tokenBalance = token.balanceOf(address(this));\\n    if (tokenBalance > 0) {\\n      require(token.transfer(msg.sender, tokenBalance), \\\"PV3SmartPool.unbind: transfer failed\\\");\\n    }\\n  }\\n\\n  /**\\n        @notice Sets the controller address. Can only be set by the current controller\\n        @param _controller Address of the new controller\\n    */\\n  function setController(address _controller) external override onlyController noReentry {\\n    emit ControllerChanged(PBStorage.load().controller, _controller);\\n    PBStorage.load().controller = _controller;\\n  }\\n\\n  /**\\n        @notice Sets public swap setter address. Can only be set by the controller\\n        @param _newPublicSwapSetter Address of the new public swap setter\\n    */\\n  function setPublicSwapSetter(address _newPublicSwapSetter)\\n    external\\n    override\\n    onlyController\\n    noReentry\\n  {\\n    emit PublicSwapSetterChanged(PBStorage.load().publicSwapSetter, _newPublicSwapSetter);\\n    PBStorage.load().publicSwapSetter = _newPublicSwapSetter;\\n  }\\n\\n  /**\\n        @notice Sets the token binder address. Can only be set by the controller\\n        @param _newTokenBinder Address of the new token binder\\n    */\\n  function setTokenBinder(address _newTokenBinder) external override onlyController noReentry {\\n    emit TokenBinderChanged(PBStorage.load().tokenBinder, _newTokenBinder);\\n    PBStorage.load().tokenBinder = _newTokenBinder;\\n  }\\n\\n  /**\\n        @notice Enables or disables public swapping on the underlying balancer pool.\\n                Can only be set by the controller.\\n        @param _public Public or not\\n    */\\n  function setPublicSwap(bool _public) external override onlyPublicSwapSetter noReentry {\\n    emit PublicSwapSet(msg.sender, _public);\\n    PBStorage.load().bPool.setPublicSwap(_public);\\n  }\\n\\n  /**\\n        @notice Set the swap fee on the underlying balancer pool.\\n                Can only be called by the controller.\\n        @param _swapFee The new swap fee\\n    */\\n  function setSwapFee(uint256 _swapFee) external override onlyController noReentry {\\n    emit SwapFeeSet(msg.sender, _swapFee);\\n    PBStorage.load().bPool.setSwapFee(_swapFee);\\n  }\\n\\n  /**\\n        @notice Set the maximum cap of the contract\\n        @param _cap New cap in wei\\n    */\\n  function setCap(uint256 _cap) external override onlyController noReentry {\\n    emit CapChanged(msg.sender, PCSStorage.load().cap, _cap);\\n    PCSStorage.load().cap = _cap;\\n  }\\n\\n  /**\\n    @notice Enable or disable joining and exiting\\n    @param _newValue enabled or not\\n  */\\n  function setJoinExitEnabled(bool _newValue) external override onlyController noReentry {\\n    emit JoinExitEnabledChanged(msg.sender, P2Storage.load().joinExitEnabled, _newValue);\\n    P2Storage.load().joinExitEnabled = _newValue;\\n  }\\n\\n  /**\\n    @notice Set the circuit breaker address. Can only be called by the controller\\n    @param _newCircuitBreaker Address of the new circuit breaker\\n  */\\n  function setCircuitBreaker(address _newCircuitBreaker)\\n    external\\n    override\\n    onlyController\\n    noReentry\\n  {\\n    emit CircuitBreakerChanged(P2Storage.load().circuitBreaker, _newCircuitBreaker);\\n    P2Storage.load().circuitBreaker = _newCircuitBreaker;\\n  }\\n\\n  /**\\n    @notice Set the annual fee. Can only be called by the controller\\n    @param _newFee new fee 10**18 == 100% per 365 days. Max 10%\\n  */\\n  function setAnnualFee(uint256 _newFee) external override onlyController noReentry {\\n    LibFees.setAnnualFee(_newFee);\\n  }\\n\\n  /**\\n    @notice Charge the outstanding annual fee\\n  */\\n  function chargeOutstandingAnnualFee() external override noReentry {\\n    LibFees.chargeOutstandingAnnualFee();\\n  }\\n\\n  /**\\n    @notice Set the address that receives the annual fee. Can only be called by the controller\\n  */\\n  function setFeeRecipient(address _newRecipient) external override onlyController noReentry {\\n    LibFees.setFeeRecipient(_newRecipient);\\n  }\\n\\n  /**\\n    @notice Trip the circuit breaker which disabled exit, join and swaps\\n  */\\n  function tripCircuitBreaker() external override onlyCircuitBreaker {\\n    P2Storage.load().joinExitEnabled = false;\\n    PBStorage.load().bPool.setPublicSwap(false);\\n    emit CircuitBreakerTripped();\\n  }\\n\\n  // TOKEN AND WEIGHT FUNCTIONS -------------------------------\\n\\n  /**\\n    @notice Update the weight of a token. Can only be called by the controller\\n    @param _token Token to adjust the weight of\\n    @param _newWeight New denormalized weight\\n  */\\n  function updateWeight(address _token, uint256 _newWeight)\\n    external\\n    override\\n    noReentry\\n    onlyController\\n  {\\n    LibWeights.updateWeight(_token, _newWeight);\\n  }\\n\\n  /**\\n    @notice Gradually adjust the weights of a token. Can only be called by the controller\\n    @param _newWeights Target weights\\n    @param _startBlock Block to start weight adjustment\\n    @param _endBlock Block to finish weight adjustment\\n  */\\n  function updateWeightsGradually(\\n    uint256[] calldata _newWeights,\\n    uint256 _startBlock,\\n    uint256 _endBlock\\n  ) external override noReentry onlyController {\\n    LibWeights.updateWeightsGradually(_newWeights, _startBlock, _endBlock);\\n  }\\n\\n  /**\\n    @notice Poke the weight adjustment\\n  */\\n  function pokeWeights() external override noReentry {\\n    LibWeights.pokeWeights();\\n  }\\n\\n  /**\\n    @notice Apply the adding of a token. Can only be called by the controller\\n  */\\n  function applyAddToken() external override noReentry onlyController {\\n    LibAddRemoveToken.applyAddToken();\\n  }\\n\\n  /**\\n    @notice Commit a token to be added. Can only be called by the controller\\n    @param _token Address of the token to add\\n    @param _balance Amount of token to add\\n    @param _denormalizedWeight Denormalized weight\\n  */\\n  function commitAddToken(\\n    address _token,\\n    uint256 _balance,\\n    uint256 _denormalizedWeight\\n  ) external override noReentry onlyController {\\n    LibAddRemoveToken.commitAddToken(_token, _balance, _denormalizedWeight);\\n  }\\n\\n  /**\\n    @notice Remove a token from the smart pool. Can only be called by the controller\\n    @param _token Address of the token to remove\\n  */\\n  function removeToken(address _token) external override noReentry onlyController {\\n    LibAddRemoveToken.removeToken(_token);\\n  }\\n\\n  // VIEW FUNCTIONS -------------------------------------------\\n\\n  /**\\n        @notice Gets the underlying assets and amounts to mint specific pool shares.\\n        @param _amount Amount of pool shares to calculate the values for\\n        @return tokens The addresses of the tokens\\n        @return amounts The amounts of tokens needed to mint that amount of pool shares\\n    */\\n  function calcTokensForAmount(uint256 _amount)\\n    external\\n    view\\n    override\\n    returns (address[] memory tokens, uint256[] memory amounts)\\n  {\\n    return LibPoolMath.calcTokensForAmount(_amount);\\n  }\\n\\n  /**\\n    @notice Calculate the amount of pool tokens out for a given amount in\\n    @param _token Address of the input token\\n    @param _amount Amount of input token\\n    @return Amount of pool token\\n  */\\n  function calcPoolOutGivenSingleIn(address _token, uint256 _amount)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return LibPoolMath.calcPoolOutGivenSingleIn(_token, _amount);\\n  }\\n\\n  /**\\n    @notice Calculate single in given pool out\\n    @param _token Address of the input token\\n    @param _amount Amount of pool out token\\n    @return Amount of token in\\n  */\\n  function calcSingleInGivenPoolOut(address _token, uint256 _amount)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return LibPoolMath.calcSingleInGivenPoolOut(_token, _amount);\\n  }\\n\\n  /**\\n    @notice Calculate single out given pool in\\n    @param _token Address of output token\\n    @param _amount Amount of pool in\\n    @return Amount of token in\\n  */\\n  function calcSingleOutGivenPoolIn(address _token, uint256 _amount)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return LibPoolMath.calcSingleOutGivenPoolIn(_token, _amount);\\n  }\\n\\n  /**\\n    @notice Calculate pool in given single token out\\n    @param _token Address of output token\\n    @param _amount Amount of output token\\n    @return Amount of pool in\\n  */\\n  function calcPoolInGivenSingleOut(address _token, uint256 _amount)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return LibPoolMath.calcPoolInGivenSingleOut(_token, _amount);\\n  }\\n\\n  /**\\n    @notice Get the current tokens in the smart pool\\n    @return Addresses of the tokens in the smart pool\\n  */\\n  function getTokens() external view override returns (address[] memory) {\\n    return PBStorage.load().bPool.getCurrentTokens();\\n  }\\n\\n  /**\\n    @notice Get the address of the controller\\n    @return The address of the pool\\n  */\\n  function getController() external view override returns (address) {\\n    return PBStorage.load().controller;\\n  }\\n\\n  /**\\n    @notice Get the address of the public swap setter\\n    @return The public swap setter address\\n  */\\n  function getPublicSwapSetter() external view override returns (address) {\\n    return PBStorage.load().publicSwapSetter;\\n  }\\n\\n  /**\\n    @notice Get the address of the token binder\\n    @return The token binder address\\n  */\\n  function getTokenBinder() external view override returns (address) {\\n    return PBStorage.load().tokenBinder;\\n  }\\n\\n  /**\\n    @notice Get the address of the circuitBreaker\\n    @return The address of the circuitBreaker\\n  */\\n  function getCircuitBreaker() external view override returns (address) {\\n    return P2Storage.load().circuitBreaker;\\n  }\\n\\n  /**\\n    @notice Get if public swapping is enabled\\n    @return If public swapping is enabled\\n  */\\n  function isPublicSwap() external view override returns (bool) {\\n    return PBStorage.load().bPool.isPublicSwap();\\n  }\\n\\n  /**\\n    @notice Get the current cap\\n    @return The current cap in wei\\n  */\\n  function getCap() external view override returns (uint256) {\\n    return PCSStorage.load().cap;\\n  }\\n\\n  function getAnnualFee() external view override returns (uint256) {\\n    return P2Storage.load().annualFee;\\n  }\\n\\n  function getFeeRecipient() external view override returns (address) {\\n    return P2Storage.load().feeRecipient;\\n  }\\n\\n  /**\\n    @notice Get the denormalized weight of a specific token in the underlying balancer pool\\n    @return the normalized weight of the token in uint\\n  */\\n  function getDenormalizedWeight(address _token) external view override returns (uint256) {\\n    return PBStorage.load().bPool.getDenormalizedWeight(_token);\\n  }\\n\\n  /**\\n    @notice Get all denormalized weights\\n    @return weights Denormalized weights\\n  */\\n  function getDenormalizedWeights() external view override returns (uint256[] memory weights) {\\n    PBStorage.StorageStruct storage s = PBStorage.load();\\n    address[] memory tokens = s.bPool.getCurrentTokens();\\n    weights = new uint256[](tokens.length);\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      weights[i] = s.bPool.getDenormalizedWeight(tokens[i]);\\n    }\\n  }\\n\\n  /**\\n    @notice Get the address of the underlying Balancer pool\\n    @return The address of the underlying balancer pool\\n  */\\n  function getBPool() external view override returns (address) {\\n    return address(PBStorage.load().bPool);\\n  }\\n\\n  /**\\n    @notice Get the current swap fee\\n    @return The current swap fee\\n  */\\n  function getSwapFee() external view override returns (uint256) {\\n    return PBStorage.load().bPool.getSwapFee();\\n  }\\n\\n  /**\\n    @notice Get the target weights\\n    @return weights Target weights\\n  */\\n  function getNewWeights() external view override returns (uint256[] memory weights) {\\n    return P2Storage.load().newWeights;\\n  }\\n\\n  /**\\n    @notice Get weights at start of weight adjustment\\n    @return weights Start weights\\n  */\\n  function getStartWeights() external view override returns (uint256[] memory weights) {\\n    return P2Storage.load().startWeights;\\n  }\\n\\n  /**\\n    @notice Get start block of weight adjustment\\n    @return Start block\\n  */\\n  function getStartBlock() external view override returns (uint256) {\\n    return P2Storage.load().startBlock;\\n  }\\n\\n  /**\\n    @notice Get end block of weight adjustment\\n    @return End block\\n  */\\n  function getEndBlock() external view override returns (uint256) {\\n    return P2Storage.load().endBlock;\\n  }\\n\\n  /**\\n    @notice Get new token being added\\n    @return New token\\n  */\\n  function getNewToken() external view override returns (P2Storage.NewToken memory) {\\n    return P2Storage.load().newToken;\\n  }\\n\\n  /**\\n    @notice Get if joining and exiting is enabled\\n    @return Enabled or not\\n  */\\n  function getJoinExitEnabled() external view override returns (bool) {\\n    return P2Storage.load().joinExitEnabled;\\n  }\\n\\n  // UNSUPORTED METHODS ---------------------------------------\\n\\n  /**\\n    @notice Not Supported in PieDAO implementation of Balancer Smart Pools\\n  */\\n  function finalizeSmartPool() external view override {\\n    revert(\\\"PV3SmartPool.finalizeSmartPool: unsupported function\\\");\\n  }\\n\\n  /**\\n    @notice Not Supported in PieDAO implementation of Balancer Smart Pools\\n  */\\n  function createPool(uint256 initialSupply) external view override {\\n    revert(\\\"PV3SmartPool.createPool: unsupported function\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestLibSafeApprove.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\nimport \\\"../libraries/LibSafeApprove.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\ncontract TestLibSafeApprove {\\n    using LibSafeApprove for IERC20;\\n\\n    function doubleApprovalUnsafe(address _token) external {\\n        IERC20 token = IERC20(_token);\\n\\n        token.approve(msg.sender, 1337);\\n        token.approve(msg.sender, 42);\\n    }\\n\\n    function doubleApprovalSafe(address _token) external {\\n        IERC20 token = IERC20(_token);\\n\\n        token.safeApprove(msg.sender, 1337);\\n        token.safeApprove(msg.sender, 42);\\n    }\\n}\"\r\n    },\r\n    \"contracts/test/TestPCToken.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\nimport \\\"../PCToken.sol\\\";\\n\\ncontract TestPCToken is PCToken {\\n  constructor(string memory _name, string memory _symbol) public {\\n    PCStorage.load().name = _name;\\n    PCStorage.load().symbol = _symbol;\\n  }\\n\\n  function mint(address _to, uint256 _amount) external {\\n    _mint(_amount);\\n    _push(_to, _amount);\\n  }\\n\\n  function burn(address _from, uint256 _amount) external {\\n    _pull(_from, _amount);\\n    _burn(_amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestReentryProtection.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\nimport \\\"../ReentryProtection.sol\\\";\\n\\ncontract TestReentryProtection is ReentryProtection {\\n  // This should fail\\n  function test() external noReentry {\\n    reenter();\\n  }\\n\\n  function reenter() public noReentry {\\n    // Do nothing\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[]","ContractName":"LibWeights","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}