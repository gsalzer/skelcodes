{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@gelatonetwork/core/contracts/external/Ownable.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_actions/GelatoActionPipeline.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {Action, Operation, DataFlow} from \\\"../gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {GelatoBytes} from \\\"../libraries/GelatoBytes.sol\\\";\\nimport {IGelatoInFlowAction} from \\\"./action_pipeline_interfaces/IGelatoInFlowAction.sol\\\";\\nimport {IGelatoOutFlowAction} from \\\"./action_pipeline_interfaces/IGelatoOutFlowAction.sol\\\";\\nimport {\\n    IGelatoInAndOutFlowAction\\n} from \\\"./action_pipeline_interfaces/IGelatoInAndOutFlowAction.sol\\\";\\n\\n/// @title GelatoActionPipeline\\n/// @notice Runtime Environment for executing multiple Actions that can share data\\ncontract GelatoActionPipeline {\\n\\n    using GelatoBytes for bytes;\\n\\n    address public immutable thisActionAddress;\\n    constructor() public { thisActionAddress = address(this); }\\n\\n    /// @notice This code can be delegatecalled by User Proxies during the execution\\n    ///  of multiple Actions, in order to let data flow between them, in\\n    ///  accordance with their Action.DataFlow specifications.\\n    /// @dev ProviderModules should encode their execPayload with this function selector.\\n    /// @param _actions List of _actions to be executed sequentially in pipeline\\n    function execActionsAndPipeData(Action[] calldata _actions) external {\\n        require(thisActionAddress != address(this), \\\"GelatoActionPipeline.delegatecallOnly\\\");\\n\\n        // Store for reusable data from Actions that DataFlow.Out or DataFlow.InAndOut\\n        bytes memory dataFromLastOutFlowAction;\\n\\n        // We execute Actions sequentially and store reusable outflowing Data\\n        for (uint i = 0; i < _actions.length; i++) {\\n            require(_actions[i].addr != address(0), \\\"GelatoActionPipeline.noZeroAddress\\\");\\n\\n            bytes memory actionPayload;\\n\\n            if (_actions[i].dataFlow == DataFlow.In) {\\n                actionPayload = abi.encodeWithSelector(\\n                    IGelatoInFlowAction.execWithDataFlowIn.selector,\\n                    _actions[i].data,\\n                    dataFromLastOutFlowAction\\n                );\\n            } else if (_actions[i].dataFlow == DataFlow.Out) {\\n                actionPayload = abi.encodeWithSelector(\\n                    IGelatoOutFlowAction.execWithDataFlowOut.selector,\\n                    _actions[i].data\\n                );\\n            } else if (_actions[i].dataFlow == DataFlow.InAndOut) {\\n                actionPayload = abi.encodeWithSelector(\\n                    IGelatoInAndOutFlowAction.execWithDataFlowInAndOut.selector,\\n                    _actions[i].data,\\n                    dataFromLastOutFlowAction\\n                );\\n            } else {\\n                actionPayload = _actions[i].data;\\n            }\\n\\n            bool success;\\n            bytes memory returndata;\\n            if (_actions[i].operation == Operation.Call){\\n                (success, returndata) = _actions[i].addr.call{value: _actions[i].value}(\\n                    actionPayload\\n                );\\n            } else {\\n                (success, returndata) = _actions[i].addr.delegatecall(actionPayload);\\n            }\\n\\n            if (!success)\\n                returndata.revertWithErrorString(\\\"GelatoActionPipeline.execActionsAndPipeData:\\\");\\n\\n            if (\\n                _actions[i].dataFlow == DataFlow.Out ||\\n                _actions[i].dataFlow == DataFlow.InAndOut\\n            ) {\\n                // All OutFlow actions return (bytes memory). But the low-level\\n                // delegatecall encoded those bytes into returndata.\\n                // So we have to decode them again to obtain the original bytes value.\\n                dataFromLastOutFlowAction = abi.decode(returndata, (bytes));\\n            }\\n        }\\n    }\\n\\n    function isValid(Action[] calldata _actions)\\n        external\\n        pure\\n        returns (\\n            bool ok,\\n            uint256 outActionIndex,\\n            uint256 inActionIndex,\\n            bytes32 currentOutflowType,\\n            bytes32 nextInflowType\\n        )\\n    {\\n        ok = true;\\n        for (uint256 i = 0; i < _actions.length; i++) {\\n            if (_actions[i].dataFlow == DataFlow.In || _actions[i].dataFlow == DataFlow.InAndOut) {\\n                // Make sure currentOutflowType matches what the inFlowAction expects\\n                try IGelatoInFlowAction(_actions[i].addr).DATA_FLOW_IN_TYPE()\\n                    returns (bytes32 inFlowType)\\n                {\\n                    if (inFlowType != currentOutflowType) {\\n                        nextInflowType = inFlowType;\\n                        inActionIndex = i;\\n                        ok = false;\\n                        break;\\n                    } else {\\n                        ok = true;\\n                    }\\n                } catch {\\n                    revert(\\\"GelatoActionPipeline.isValid: error DATA_FLOW_IN_TYPE\\\");\\n                }\\n            }\\n            if (_actions[i].dataFlow == DataFlow.Out || _actions[i].dataFlow == DataFlow.InAndOut) {\\n                if (ok == false) break;\\n                // Store this Actions outFlowType to be used by the next inFlowAction\\n                try IGelatoOutFlowAction(_actions[i].addr).DATA_FLOW_OUT_TYPE()\\n                    returns (bytes32 outFlowType)\\n                {\\n                    currentOutflowType = outFlowType;\\n                    outActionIndex = i;\\n                    ok = false;\\n                } catch {\\n                    revert(\\\"GelatoActionPipeline.isValid: error DATA_FLOW_OUT_TYPE\\\");\\n                }\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_actions/action_pipeline_interfaces/IGelatoInAndOutFlowAction.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\n\\nimport {Action} from \\\"../../gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\n/// @title IGelatoInAndOutFlowAction\\n/// @notice Solidity interface for Actions that make use of DataFlow.InAndOut\\ninterface IGelatoInAndOutFlowAction {\\n\\n    /// @notice Executes the Action implementation with data flowing in from a previous\\n    ///  Action in the GelatoActionPipeline and with data flowing out to consecutive\\n    ///  Actions in the pipeline.\\n    /// @dev The _inFlowData format should be defined by DATA_FLOW_IN_TYPE and\\n    ///  the outFlowData format should be defined by DATA_FLOW_OUT_TYPE.\\n    /// @param _actionData Known prior to execution and probably encoded off-chain.\\n    /// @param _inFlowData Not known prior to execution. Passed in via GelatoActionPipeline.\\n    /// @return outFlowData The bytes encoded data this action implementation emits.\\n    function execWithDataFlowInAndOut(\\n        bytes calldata _actionData,\\n        bytes calldata _inFlowData\\n    )\\n        external\\n        payable\\n        returns (bytes memory outFlowData);\\n\\n    /// @notice Returns the expected format of the execWithDataFlowIn _inFlowData.\\n    /// @dev Strict adherence to these formats is crucial for GelatoActionPipelines.\\n    function DATA_FLOW_IN_TYPE() external pure returns (bytes32);\\n\\n    /// @notice Returns the expected format of the execWithDataFlowOut outFlowData.\\n    /// @dev Strict adherence to these formats is crucial for GelatoActionPipelines.\\n    function DATA_FLOW_OUT_TYPE() external pure returns (bytes32);\\n}\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_actions/action_pipeline_interfaces/IGelatoInFlowAction.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\n\\n/// @title IGelatoInFlowAction\\n/// @notice Solidity interface for Actions that make use of DataFlow.In\\n/// @dev Inherit this, if you want your Action to use DataFlow.In in a standard way.\\ninterface IGelatoInFlowAction {\\n    /// @notice Executes the action implementation with data flowing in from a previous\\n    ///  Action in the sequence.\\n    /// @dev The _inFlowData format should be defined by DATA_FLOW_IN_TYPE\\n    /// @param _actionData Known prior to execution and probably encoded off-chain.\\n    /// @param _inFlowData Not known prior to execution. Passed in via GelatoActionPipeline.\\n    function execWithDataFlowIn(bytes calldata _actionData, bytes calldata _inFlowData)\\n        external\\n        payable;\\n\\n    /// @notice Returns the expected format of the execWithDataFlowIn _inFlowData.\\n    /// @dev Strict adherence to these formats is crucial for GelatoActionPipelines.\\n    function DATA_FLOW_IN_TYPE() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_actions/action_pipeline_interfaces/IGelatoOutFlowAction.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\n\\n/// @title IGelatoOutFlowAction\\n/// @notice Solidity interface for Actions that make use of DataFlow.Out\\n/// @dev Inherit this, if you want implement your Action.DataFlow.Out in a standard way.\\ninterface IGelatoOutFlowAction {\\n    /// @notice Executes the Action implementation with data flowing out to consecutive\\n    ///  Actions in a GelatoActionPipeline.\\n    /// @dev The outFlowData format should be defined by DATA_FLOW_OUT_TYPE\\n    /// @param _actionData Known prior to execution and probably encoded off-chain.\\n    /// @return outFlowData The bytes encoded data this action implementation emits.\\n    function execWithDataFlowOut(bytes calldata _actionData)\\n        external\\n        payable\\n        returns (bytes memory outFlowData);\\n\\n    /// @notice Returns the expected format of the execWithDataFlowOut outFlowData.\\n    /// @dev Strict adherence to these formats is crucial for GelatoActionPipelines.\\n    function DATA_FLOW_OUT_TYPE() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_conditions/IGelatoCondition.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\\n/// @notice all the APIs of GelatoConditionsStandard\\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\\ninterface IGelatoCondition {\\n\\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\\n    ///  \\\"ok\\\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\\n    ///  source of Task identification.\\n    /// @param _conditionData This is the Condition.data field developers must encode their\\n    ///  Condition's specific parameters in.\\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\\n        external\\n        view\\n        returns(string memory);\\n}\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {IGelatoProviderModule} from \\\"../../gelato_provider_modules/IGelatoProviderModule.sol\\\";\\nimport {IGelatoCondition} from \\\"../../gelato_conditions/IGelatoCondition.sol\\\";\\n\\nstruct Provider {\\n    address addr;  //  if msg.sender == provider => self-Provider\\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\\n}\\n\\nstruct Condition {\\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\\n    bytes data;  // can be bytes32(0) for self-conditional Actions\\n}\\n\\nenum Operation { Call, Delegatecall }\\n\\nenum DataFlow { None, In, Out, InAndOut }\\n\\nstruct Action {\\n    address addr;\\n    bytes data;\\n    Operation operation;\\n    DataFlow dataFlow;\\n    uint256 value;\\n    bool termsOkCheck;\\n}\\n\\nstruct Task {\\n    Condition[] conditions;  // optional\\n    Action[] actions;\\n    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\\n    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\\n}\\n\\nstruct TaskReceipt {\\n    uint256 id;\\n    address userProxy;\\n    Provider provider;\\n    uint256 index;\\n    Task[] tasks;\\n    uint256 expiryDate;\\n    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\\n    uint256 submissionsLeft;\\n}\\n\\ninterface IGelatoCore {\\n    event LogTaskSubmitted(\\n        uint256 indexed taskReceiptId,\\n        bytes32 indexed taskReceiptHash,\\n        TaskReceipt taskReceipt\\n    );\\n\\n    event LogExecSuccess(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        uint256 executorSuccessFee,\\n        uint256 sysAdminSuccessFee\\n    );\\n    event LogCanExecFailed(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        string reason\\n    );\\n    event LogExecReverted(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        uint256 executorRefund,\\n        string reason\\n    );\\n\\n    event LogTaskCancelled(uint256 indexed taskReceiptId, address indexed cancellor);\\n\\n    /// @notice API to query whether Task can be submitted successfully.\\n    /// @dev In submitTask the msg.sender must be the same as _userProxy here.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _userProxy The userProxy from which the task will be submitted.\\n    /// @param _task Selected provider, conditions, actions, expiry date of the task\\n    function canSubmitTask(\\n        address _userProxy,\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    )\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice API to submit a single Task.\\n    /// @dev You can let users submit multiple tasks at once by batching calls to this.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _task A Gelato Task object: provider, conditions, actions.\\n    /// @param _expiryDate From then on the task cannot be executed. 0 for infinity.\\n    function submitTask(\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    )\\n        external;\\n\\n\\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\\n    ///  the next one, after they have been executed.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _tasks This can be a single task or a sequence of tasks.\\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\\n    /// @param _cycles How many full cycles will be submitted\\n    function submitTaskCycle(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _cycles\\n    )\\n        external;\\n\\n\\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\\n    ///  the next one, after they have been executed.\\n    /// @dev CAUTION: _sumOfRequestedTaskSubmits does not mean the number of cycles.\\n    /// @dev If _sumOfRequestedTaskSubmits = 1 && _tasks.length = 2, only the first task\\n    ///  would be submitted, but not the second\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _tasks This can be a single task or a sequence of tasks.\\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\\n    /// @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\\n    ///  that should have occured once the cycle is complete:\\n    ///  _sumOfRequestedTaskSubmits = 0 => One Task will resubmit the next Task infinitly\\n    ///  _sumOfRequestedTaskSubmits = 1 => One Task will resubmit no other task\\n    ///  _sumOfRequestedTaskSubmits = 2 => One Task will resubmit 1 other task\\n    ///  ...\\n    function submitTaskChain(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _sumOfRequestedTaskSubmits\\n    )\\n        external;\\n\\n    // ================  Exec Suite =========================\\n    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\\n    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\\n    /// @param _gasLimit Task.selfProviderGasLimit is used for SelfProviders. All other\\n    ///  Providers must use gelatoMaxGas. If the _gasLimit is used by an Executor and the\\n    ///  tx reverts, a refund is paid by the Provider and the TaskReceipt is annulated.\\n    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\\n    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\\n    function canExec(TaskReceipt calldata _TR, uint256 _gasLimit, uint256 _execTxGasPrice)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\\n    /// @dev Executors get rewarded for successful Execution. The Task remains open until\\n    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\\n    ///   In the latter case Executors are refunded by the Task Provider.\\n    /// @param _TR TaskReceipt: id, userProxy, Task.\\n    function exec(TaskReceipt calldata _TR) external;\\n\\n    /// @notice Cancel task\\n    /// @dev Callable only by userProxy or selected provider\\n    /// @param _TR TaskReceipt: id, userProxy, Task.\\n    function cancelTask(TaskReceipt calldata _TR) external;\\n\\n    /// @notice Cancel multiple tasks at once\\n    /// @dev Callable only by userProxy or selected provider\\n    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\\n\\n    /// @notice Compute hash of task receipt\\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\\n    /// @return hash of taskReceipt\\n    function hashTaskReceipt(TaskReceipt calldata _TR) external pure returns(bytes32);\\n\\n    // ================  Getters =========================\\n    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\\n    /// @return currentId currentId, last TaskReceiptId submitted\\n    function currentTaskReceiptId() external view returns(uint256);\\n\\n    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\\n    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\\n    /// @return hash of taskReceipt\\n    function taskReceiptHash(uint256 _taskReceiptId) external view returns(bytes32);\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_provider_modules/GelatoProviderModuleStandard.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {IGelatoProviderModule} from \\\"./IGelatoProviderModule.sol\\\";\\nimport {Task} from \\\"../gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\nabstract contract GelatoProviderModuleStandard is IGelatoProviderModule {\\n\\n    string internal constant OK = \\\"OK\\\";\\n\\n    function isProvided(address, address, Task calldata)\\n        external\\n        view\\n        virtual\\n        override\\n        returns(string memory)\\n    {\\n        return OK;\\n    }\\n\\n    function execPayload(uint256, address, address, Task calldata, uint256)\\n        external\\n        view\\n        virtual\\n        override\\n        returns(bytes memory payload, bool)\\n    {\\n        return (payload, false);\\n    }\\n\\n    /// @dev Overriding fns should revert with the revertMsg they detected on the userProxy\\n    function execRevertCheck(bytes calldata) external pure override virtual {\\n        // By default no reverts detected => do nothing\\n    }\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_provider_modules/IGelatoProviderModule.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {Action, Task} from \\\"../gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\ninterface IGelatoProviderModule {\\n\\n    /// @notice Check if provider agrees to pay for inputted task receipt\\n    /// @dev Enables arbitrary checks by provider\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @return \\\"OK\\\" if provider agrees\\n    function isProvided(address _userProxy, address _provider, Task calldata _task)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice Convert action specific payload into proxy specific payload\\n    /// @dev Encoded multiple actions into a multisend\\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\\n    /// @return Encoded payload that will be used for low-level .call on user proxy\\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\\n    function execPayload(\\n        uint256 _taskReceiptId,\\n        address _userProxy,\\n        address _provider,\\n        Task calldata _task,\\n        uint256 _cycleId\\n    )\\n        external\\n        view\\n        returns(bytes memory, bool checkReturndata);\\n\\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/libraries/GelatoBytes.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\nlibrary GelatoBytes {\\n    function calldataSliceSelector(bytes calldata _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function memorySliceSelector(bytes memory _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function revertWithErrorString(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\\n            } else {\\n                revert(\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"))\\n                );\\n            }\\n        } else {\\n            revert(\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"))\\n            );\\n        }\\n    }\\n\\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\\n            } else {\\n                return\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"));\\n            }\\n        } else {\\n            return\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ProviderModuleGnosisSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {GelatoProviderModuleStandard} from \\\"@gelatonetwork/core/contracts/gelato_provider_modules/GelatoProviderModuleStandard.sol\\\";\\nimport {IProviderModuleGnosisSafe} from \\\"./dapp_interfaces/gnosis_safe/IProviderModuleGnosisSafe.sol\\\";\\nimport {Ownable} from \\\"@gelatonetwork/core/contracts/external/Ownable.sol\\\";\\nimport {GelatoBytes} from \\\"@gelatonetwork/core/contracts/libraries/GelatoBytes.sol\\\";\\nimport {GelatoActionPipeline} from \\\"@gelatonetwork/core/contracts/gelato_actions/GelatoActionPipeline.sol\\\";\\nimport {\\n    IGnosisSafe\\n} from \\\"./dapp_interfaces/gnosis_safe/IGnosisSafe.sol\\\";\\nimport {Task} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\ncontract ProviderModuleGnosisSafe is\\n    GelatoProviderModuleStandard,\\n    IProviderModuleGnosisSafe,\\n    Ownable\\n{\\n    using GelatoBytes for bytes;\\n\\n    mapping(bytes32 => bool) public override isProxyExtcodehashProvided;\\n    mapping(address => bool) public override isMastercopyProvided;\\n    address public override immutable gelatoCore;\\n    address public override immutable gelatoActionPipeline;\\n\\n    constructor(\\n        bytes32[] memory hashes,\\n        address[] memory masterCopies,\\n        address _gelatoCore,\\n        address _gelatoActionPipeline\\n    )\\n        public\\n    {\\n        multiProvide(hashes, masterCopies);\\n        gelatoCore = _gelatoCore;\\n        gelatoActionPipeline = _gelatoActionPipeline;\\n    }\\n\\n    // ================= GELATO PROVIDER MODULE STANDARD ================\\n    // @dev since we check extcodehash prior to execution, we forego the execution option\\n    //  where the userProxy is deployed at execution time.\\n    function isProvided(address _userProxy, address, Task calldata)\\n        external\\n        view\\n        override\\n        returns(string memory)\\n    {\\n        bytes32 codehash;\\n        assembly { codehash := extcodehash(_userProxy) }\\n        if (!isProxyExtcodehashProvided[codehash])\\n            return \\\"ProviderModuleGnosisSafeProxy.isProvided:InvalidGSPCodehash\\\";\\n        address mastercopy = IGnosisSafe(_userProxy).masterCopy();\\n        if (!isMastercopyProvided[mastercopy])\\n            return \\\"ProviderModuleGnosisSafeProxy.isProvided:InvalidGSPMastercopy\\\";\\n        if (!isGelatoCoreWhitelisted(_userProxy))\\n            return \\\"ProviderModuleGnosisSafeProxy.isProvided:GelatoCoreNotWhitelisted\\\";\\n        return OK;\\n    }\\n\\n    function execPayload(uint256, address, address, Task calldata _task, uint256)\\n        external\\n        view\\n        override\\n        returns(bytes memory payload, bool proxyReturndataCheck)\\n    {\\n        // execTransactionFromModuleReturnData catches reverts so must check for reverts\\n        proxyReturndataCheck = true;\\n\\n        if (_task.actions.length == 1) {\\n            payload = abi.encodeWithSelector(\\n                IGnosisSafe.execTransactionFromModuleReturnData.selector,\\n                _task.actions[0].addr,  // to\\n                _task.actions[0].value,\\n                _task.actions[0].data,\\n                _task.actions[0].operation\\n            );\\n        } else if (_task.actions.length > 1) {\\n            // Action.Operation encoded into multiSendPayload and handled by Multisend\\n            bytes memory gelatoActionPipelinePayload = abi.encodeWithSelector(\\n                GelatoActionPipeline.execActionsAndPipeData.selector,\\n                _task.actions\\n            );\\n\\n            payload = abi.encodeWithSelector(\\n                IGnosisSafe.execTransactionFromModuleReturnData.selector,\\n                gelatoActionPipeline,  // to\\n                0,  // value\\n                gelatoActionPipelinePayload,  // data\\n                IGnosisSafe.Operation.DelegateCall\\n            );\\n\\n        } else {\\n            revert(\\\"ProviderModuleGnosisSafeProxy.execPayload: 0 _task.actions length\\\");\\n        }\\n    }\\n\\n    function execRevertCheck(bytes calldata _proxyReturndata)\\n        external\\n        pure\\n        virtual\\n        override\\n    {\\n        (bool success, bytes memory returndata) = abi.decode(_proxyReturndata, (bool,bytes));\\n        if (!success) returndata.revertWithErrorString(\\\":ProviderModuleGnosisSafeProxy:\\\");\\n    }\\n\\n    // GnosisSafeProxy\\n    function provideProxyExtcodehashes(bytes32[] memory _hashes) public override onlyOwner {\\n        for (uint i; i < _hashes.length; i++) {\\n            require(\\n                !isProxyExtcodehashProvided[_hashes[i]],\\n                \\\"ProviderModuleGnosisSafeProxy.provideProxyExtcodehashes: redundant\\\"\\n            );\\n            isProxyExtcodehashProvided[_hashes[i]] = true;\\n            emit LogProvideProxyExtcodehash(_hashes[i]);\\n        }\\n    }\\n\\n    function unprovideProxyExtcodehashes(bytes32[] memory _hashes) public override onlyOwner {\\n        for (uint i; i < _hashes.length; i++) {\\n            require(\\n                isProxyExtcodehashProvided[_hashes[i]],\\n                \\\"ProviderModuleGnosisSafeProxy.unprovideProxyExtcodehashes: redundant\\\"\\n            );\\n            delete isProxyExtcodehashProvided[_hashes[i]];\\n            emit LogUnprovideProxyExtcodehash(_hashes[i]);\\n        }\\n    }\\n\\n    function provideMastercopies(address[] memory _mastercopies) public override onlyOwner {\\n        for (uint i; i < _mastercopies.length; i++) {\\n            require(\\n                !isMastercopyProvided[_mastercopies[i]],\\n                \\\"ProviderModuleGnosisSafeProxy.provideMastercopy: redundant\\\"\\n            );\\n            isMastercopyProvided[_mastercopies[i]] = true;\\n            emit LogProvideMastercopy(_mastercopies[i]);\\n        }\\n    }\\n\\n    function unprovideMastercopies(address[] memory _mastercopies) public override onlyOwner {\\n        for (uint i; i < _mastercopies.length; i++) {\\n            require(\\n                isMastercopyProvided[_mastercopies[i]],\\n                \\\"ProviderModuleGnosisSafeProxy.unprovideMastercopies: redundant\\\"\\n            );\\n            delete isMastercopyProvided[_mastercopies[i]];\\n            emit LogUnprovideMastercopy(_mastercopies[i]);\\n        }\\n    }\\n\\n    // Batch (un-)provide\\n    function multiProvide(bytes32[] memory _hashes, address[] memory _mastercopies)\\n        public\\n        override\\n        onlyOwner\\n    {\\n        provideProxyExtcodehashes(_hashes);\\n        provideMastercopies(_mastercopies);\\n    }\\n\\n    function multiUnprovide(bytes32[] calldata _hashes, address[] calldata _mastercopies)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        unprovideProxyExtcodehashes(_hashes);\\n        unprovideMastercopies(_mastercopies);\\n    }\\n\\n    function isGelatoCoreWhitelisted(address _userProxy)\\n        view\\n        internal\\n        returns(bool)\\n    {\\n        address[] memory whitelistedModules = IGnosisSafe(_userProxy).getModules();\\n        for (uint i = 0; i < whitelistedModules.length; i++)\\n            if (whitelistedModules[i] == gelatoCore) return true;\\n        return false;\\n    }\\n}\"\r\n    },\r\n    \"contracts/dapp_interfaces/gnosis_safe/IGnosisSafe.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\n\\ninterface IGnosisSafe {\\n    enum Operation {Call, DelegateCall}\\n\\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\\n\\n    function setup(\\n        address[] calldata _owners,\\n        uint256 _threshold,\\n        address to,\\n        bytes calldata data,\\n        address fallbackHandler,\\n        address paymentToken,\\n        uint256 payment,\\n        address payable paymentReceiver\\n    ) external;\\n\\n    function execTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        bytes calldata signatures\\n    ) external returns (bool success);\\n\\n    function enableModule(address module) external;\\n    function disableModule(address prevModule, address module) external;\\n\\n    function execTransactionFromModuleReturnData(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Operation operation\\n    ) external returns (bool success, bytes memory returndata);\\n\\n    function isOwner(address owner) external view returns (bool);\\n    function getOwners() external view returns (address[] memory);\\n\\n    function getModules() external view returns (address[] memory);\\n    function masterCopy() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/dapp_interfaces/gnosis_safe/IProviderModuleGnosisSafe.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.6.10;\\n\\ninterface IProviderModuleGnosisSafe {\\n    event LogProvideProxyExtcodehash(bytes32 indexed extcodehash);\\n    event LogUnprovideProxyExtcodehash(bytes32 indexed extcodehash);\\n\\n    event LogProvideMastercopy(address indexed mastercopy);\\n    event LogUnprovideMastercopy(address indexed mastercopy);\\n\\n    // GnosisSafeProxy\\n    function provideProxyExtcodehashes(bytes32[] calldata _hashes) external;\\n    function unprovideProxyExtcodehashes(bytes32[] calldata _hashes) external;\\n\\n    function provideMastercopies(address[] calldata _mastercopies) external;\\n    function unprovideMastercopies(address[] calldata _mastercopies) external;\\n\\n    // Batch (un-)provide\\n    function multiProvide(bytes32[] calldata _hashes, address[] calldata _mastercopies)\\n        external;\\n\\n    function multiUnprovide(bytes32[] calldata _hashes, address[] calldata _mastercopies)\\n        external;\\n\\n    function isProxyExtcodehashProvided(bytes32 _hash)\\n        external\\n        view\\n        returns(bool);\\n    function isMastercopyProvided(address _mastercopy)\\n        external\\n        view\\n        returns(bool);\\n\\n\\n    function gelatoCore() external pure returns(address);\\n    function gelatoActionPipeline() external pure returns(address);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"masterCopies\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_gelatoCore\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gelatoActionPipeline\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mastercopy\",\"type\":\"address\"}],\"name\":\"LogProvideMastercopy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"extcodehash\",\"type\":\"bytes32\"}],\"name\":\"LogProvideProxyExtcodehash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mastercopy\",\"type\":\"address\"}],\"name\":\"LogUnprovideMastercopy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"extcodehash\",\"type\":\"bytes32\"}],\"name\":\"LogUnprovideProxyExtcodehash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"contract IGelatoCondition\",\"name\":\"inst\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Condition[]\",\"name\":\"conditions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"enum DataFlow\",\"name\":\"dataFlow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"termsOkCheck\",\"type\":\"bool\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasPriceCeil\",\"type\":\"uint256\"}],\"internalType\":\"struct Task\",\"name\":\"_task\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"execPayload\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"proxyReturndataCheck\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proxyReturndata\",\"type\":\"bytes\"}],\"name\":\"execRevertCheck\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gelatoActionPipeline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gelatoCore\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMastercopyProvided\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"contract IGelatoCondition\",\"name\":\"inst\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Condition[]\",\"name\":\"conditions\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"enum DataFlow\",\"name\":\"dataFlow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"termsOkCheck\",\"type\":\"bool\"}],\"internalType\":\"struct Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selfProviderGasPriceCeil\",\"type\":\"uint256\"}],\"internalType\":\"struct Task\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"isProvided\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isProxyExtcodehashProvided\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_mastercopies\",\"type\":\"address[]\"}],\"name\":\"multiProvide\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_mastercopies\",\"type\":\"address[]\"}],\"name\":\"multiUnprovide\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_mastercopies\",\"type\":\"address[]\"}],\"name\":\"provideMastercopies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_hashes\",\"type\":\"bytes32[]\"}],\"name\":\"provideProxyExtcodehashes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_mastercopies\",\"type\":\"address[]\"}],\"name\":\"unprovideMastercopies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_hashes\",\"type\":\"bytes32[]\"}],\"name\":\"unprovideProxyExtcodehashes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ProviderModuleGnosisSafe","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000025030bdaa159f281cae63873e68313a703725a5000000000000000000000000d2540644c2b110a8f45bde903e111fa518d41b6c000000000000000000000000000000000000000000000000000000000000000108c5547e6a24e8e11059160715b82d6533df7061e5175cc6dd77c80fcef95b0e000000000000000000000000000000000000000000000000000000000000000200000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f0000000000000000000000006851d6fdfafd08c0295c392436245e5bc78b0185","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":""}]}