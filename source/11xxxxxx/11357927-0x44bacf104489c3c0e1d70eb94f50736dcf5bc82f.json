{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/nh2/dev/nazizombies/contracts/ERC20_Mintable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.17;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title Standard ERC20 token (+ minting)\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Originally based on code by FirstBlood:\\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n *\\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\\n * compliant implementations may not do it.\\n */\\ncontract ERC20_Mintable is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    address public minter;\\n\\n    string public name;\\n    uint8 public decimals;\\n    string public symbol;\\n\\n    event Mint(address indexed to, uint256 amount);\\n\\n    constructor (string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\\n        minter = msg.sender;\\n        name = _tokenName;\\n        decimals = _decimalUnits;\\n        symbol = _tokenSymbol;\\n    }\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner The address to query the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified address\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another.\\n     * Note that while this function emits an Approval event, this is not required as per the specification,\\n     * and other compliant implementations may not emit the event.\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to mint tokens\\n     * @param to The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to mint.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n    function mint(address to, uint256 amount) public returns (bool) {\\n        require(msg.sender == minter);\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[to] = _balances[to].add(amount);\\n        emit Mint(to, amount);\\n        emit Transfer(address(0), to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified addresses\\n     * @param from The address to transfer from.\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Approve an address to spend another addresses' tokens.\\n     * @param owner The address that owns the tokens.\\n     * @param spender The address that will spend the tokens.\\n     * @param value The number of tokens that can be spent.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(spender != address(0));\\n        require(owner != address(0));\\n\\n        _allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n}\"\r\n    },\r\n    \"/Users/nh2/dev/nazizombies/contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.17;\\n\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"/Users/nh2/dev/nazizombies/contracts/MerkleTreeWithHistory.sol\": {\r\n      \"content\": \"// https://tornado.cash\\n/*\\n* d888888P                                           dP              a88888b.                   dP\\n*    88                                              88             d8'   `88                   88\\n*    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\\n*    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\\n*    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\\n*    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\\n* ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\\n*/\\n\\npragma solidity 0.5.17;\\n\\nlibrary Hasher {\\n  function MiMCSponge(uint256 in_xL, uint256 in_xR) public pure returns (uint256 xL, uint256 xR);\\n}\\n\\ncontract MerkleTreeWithHistory {\\n  uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n  uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\\\"tornado\\\") % FIELD_SIZE\\n\\n  uint32 public levels;\\n\\n  // the following variables are made public for easier testing and debugging and\\n  // are not supposed to be accessed in regular code\\n  bytes32[] public filledSubtrees;\\n  bytes32[] public zeros;\\n  uint32 public currentRootIndex = 0;\\n  uint32 public nextIndex = 0;\\n  uint32 public constant ROOT_HISTORY_SIZE = 100;\\n  bytes32[ROOT_HISTORY_SIZE] public roots;\\n\\n  constructor(uint32 _treeLevels) public {\\n    require(_treeLevels > 0, \\\"_treeLevels should be greater than zero\\\");\\n    require(_treeLevels < 32, \\\"_treeLevels should be less than 32\\\");\\n    levels = _treeLevels;\\n\\n    bytes32 currentZero = bytes32(ZERO_VALUE);\\n    zeros.push(currentZero);\\n    filledSubtrees.push(currentZero);\\n\\n    for (uint32 i = 1; i < levels; i++) {\\n      currentZero = hashLeftRight(currentZero, currentZero);\\n      zeros.push(currentZero);\\n      filledSubtrees.push(currentZero);\\n    }\\n\\n    roots[0] = hashLeftRight(currentZero, currentZero);\\n  }\\n\\n  /**\\n    @dev Hash 2 tree leaves, returns MiMC(_left, _right)\\n  */\\n  function hashLeftRight(bytes32 _left, bytes32 _right) public pure returns (bytes32) {\\n    require(uint256(_left) < FIELD_SIZE, \\\"_left should be inside the field\\\");\\n    require(uint256(_right) < FIELD_SIZE, \\\"_right should be inside the field\\\");\\n    uint256 R = uint256(_left);\\n    uint256 C = 0;\\n    (R, C) = Hasher.MiMCSponge(R, C);\\n    R = addmod(R, uint256(_right), FIELD_SIZE);\\n    (R, C) = Hasher.MiMCSponge(R, C);\\n    return bytes32(R);\\n  }\\n\\n  function _insert(bytes32 _leaf) internal returns(uint32 index) {\\n    uint32 currentIndex = nextIndex;\\n    require(currentIndex != uint32(2)**levels, \\\"Merkle tree is full. No more leafs can be added\\\");\\n    nextIndex += 1;\\n    bytes32 currentLevelHash = _leaf;\\n    bytes32 left;\\n    bytes32 right;\\n\\n    for (uint32 i = 0; i < levels; i++) {\\n      if (currentIndex % 2 == 0) {\\n        left = currentLevelHash;\\n        right = zeros[i];\\n\\n        filledSubtrees[i] = currentLevelHash;\\n      } else {\\n        left = filledSubtrees[i];\\n        right = currentLevelHash;\\n      }\\n\\n      currentLevelHash = hashLeftRight(left, right);\\n\\n      currentIndex /= 2;\\n    }\\n\\n    currentRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\\n    roots[currentRootIndex] = currentLevelHash;\\n    return nextIndex - 1;\\n  }\\n\\n  /**\\n    @dev Whether the root is present in the root history\\n  */\\n  function isKnownRoot(bytes32 _root) public view returns(bool) {\\n    if (_root == 0) {\\n      return false;\\n    }\\n    uint32 i = currentRootIndex;\\n    do {\\n      if (_root == roots[i]) {\\n        return true;\\n      }\\n      if (i == 0) {\\n        i = ROOT_HISTORY_SIZE;\\n      }\\n      i--;\\n    } while (i != currentRootIndex);\\n    return false;\\n  }\\n\\n  /**\\n    @dev Returns the last root\\n  */\\n  function getLastRoot() public view returns(bytes32) {\\n    return roots[currentRootIndex];\\n  }\\n}\\n\"\r\n    },\r\n    \"/Users/nh2/dev/nazizombies/contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/nh2/dev/nazizombies/contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.17;\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        require(b > 0);\\n        uint256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n\\n        return c;\\n    }\\n}\"\r\n    },\r\n    \"/Users/nh2/dev/nazizombies/contracts/Tornado.sol\": {\r\n      \"content\": \"// https://anon.credit\\n// https://anoncredit.eth.link\\n/*\\n* d888888P                                           dP              a88888b.                   dP\\n*    88                                              88             d8'   `88                   88\\n*    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\\n*    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\\n*    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\\n*    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\\n* ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\\n*\\n*\\n* \\\"Full anonymity is not plausible.\\\"\\n* \\n*/\\n\\npragma solidity 0.5.17;\\n\\nimport \\\"./MerkleTreeWithHistory.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ERC20_Mintable.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract IVerifier {\\n  function verifyProof(bytes memory _proof, uint256[6] memory _input) public returns(bool);\\n}\\n\\ncontract Tornado is MerkleTreeWithHistory, ReentrancyGuard {\\n  using SafeMath for uint256;\\n\\n  uint256 public denomination; // 100 ETH\\n  mapping(bytes32 => bool) public nullifierHashes;\\n  // we store all commitments just to prevent accidental deposits with the same commitment\\n  mapping(bytes32 => bool) public commitments;\\n  IVerifier public verifier;\\n\\n  uint256 public _1e18 = 1000000000000000000;\\n  uint256 public startTime; // epoch time at contract deployment\\n  uint256 public growthPhaseEndTime; // epoch time of end of growth phase (00:00 PST, July 4th, 2021)\\n  uint256 public bonusRoundLength; // length of a period in seconds\\n\\n  uint256 public totalDeposits; // total number of deposits\\n  uint256 public totalWithdrawals; // total number of withdrawals\\n  \\n  mapping(uint256 => BonusPool) public bonusPoolByRound;\\n\\n  struct BonusPool {\\n    address creditToken; // credit token address for this round\\n    uint256 bonusCollected; // total accumulated bonus ETH\\n    uint256 bonusWithdrawn; // total ETH withdrawn from bonus pool\\n    uint256 bonusRolledOver; // total ETH rolled over from the previous round\\n  }\\n  \\n  uint256 public baseBonusRate; // % of deposit set aside for bonus pool (unit = bps)\\n  uint256 public growthBonusRate; // extra % of deposit set aside for growth phase bonus pool (unit = bps)\\n  ERC20_Mintable public bonusToken; // ANON token generated on every deposit\\n  address public stakingToken; // ETH/ANON token used to stake and earn bonus rewards\\n\\n  mapping(address => Staker) public stakers;\\n\\n  struct Staker {\\n    uint256 unlockRound;\\n    uint256 stakingTokenBalance;\\n  }\\n\\n  modifier stakingActivated {\\n    require(stakingToken != address(0), \\\"staking has not been activated\\\");\\n    _;\\n  }\\n \\n  uint256 public operatorBonusTokenShare; // the operator's share of bonus tokens issued (10%) (unit = bps)\\n\\n  // operator can update snark verification key\\n  // after the final trusted setup ceremony operator rights are supposed to be transferred to zero address\\n  address public operator;\\n  modifier onlyOperator {\\n    require(msg.sender == operator, \\\"Only operator can call this function.\\\");\\n    _;\\n  }\\n\\n  event Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp);\\n  event Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee);\\n  event Stake(address indexed staker, uint256 amountToStake, uint256 creditsMinted);\\n  event AddToStake(address indexed staker, uint256 amountToStake, uint256 totalStake, uint256 creditsMinted);\\n  event Unstake(address indexed staker, uint256 amountUnstaked);\\n  event CollectBonus(address indexed staker, uint256 creditsToRedeem, uint256 bonusCollected);\\n\\n  /**\\n    @dev The constructor\\n    @param _verifier the address of SNARK verifier for this contract\\n    @param _denomination transfer amount for each deposit\\n    @param _merkleTreeHeight the height of deposits' Merkle Tree\\n    @param _operator operator address (see operator comment above)\\n  */\\n  constructor(\\n    IVerifier _verifier,\\n    uint256 _denomination,\\n    uint32 _merkleTreeHeight,\\n    address _operator,\\n    uint256 _baseBonusRate,\\n    uint256 _growthBonusRate,\\n    uint256 _growthPhaseEndTime,\\n    uint256 _bonusRoundLength,\\n    uint256 _operatorBonusTokenShare\\n  ) MerkleTreeWithHistory(_merkleTreeHeight) public {\\n    require(_denomination > 0, \\\"denomination should be greater than 0\\\");\\n    startTime = now;\\n    verifier = _verifier;\\n    operator = _operator;\\n    denomination = _denomination;\\n    baseBonusRate = _baseBonusRate;\\n    growthBonusRate = _growthBonusRate;\\n    growthPhaseEndTime = _growthPhaseEndTime;\\n    bonusRoundLength = _bonusRoundLength;\\n    operatorBonusTokenShare = _operatorBonusTokenShare;\\n    bonusToken = new ERC20_Mintable(\\\"anon\\\", 18, \\\"ANON\\\");\\n  }\\n\\n  /**\\n    @dev Deposit funds into the contract. The caller must send (for ETH) or approve (for ERC20) value equal to or `denomination` of this instance.\\n    @param _commitment the note commitment, which is PedersenHash(nullifier + secret)\\n  */\\n  function deposit(bytes32 _commitment) external payable nonReentrant {\\n    require(address(bonusToken) != address(0), \\\"token not deployed\\\");\\n    require(!commitments[_commitment], \\\"The commitment has been submitted\\\");\\n\\n    uint256 bonusRound = getCurrentBonusRound();\\n\\n    uint256 depositReserve = _calcDepositReserve();\\n    uint256 bonusRate = baseBonusRate;\\n\\n    if (bonusRound == 0) { // growth phase\\n      bonusRate = bonusRate.add(growthBonusRate);\\n    }\\n\\n    uint256 depositBonus = denomination.add(depositReserve).mul(bonusRate).div(10000);\\n    uint256 depositAmount = denomination.add(depositReserve).add(depositBonus);\\n      \\n    require(msg.value >= depositAmount,\\\"deposit amount is insufficient\\\");\\n\\n    BonusPool storage bonusPool = bonusPoolByRound[bonusRound];\\n    bonusPool.bonusCollected = bonusPool.bonusCollected.add(depositBonus);\\n    totalDeposits = totalDeposits.add(1);\\n\\n    if (bonusRound == 0) { // growth phase\\n      bonusToken.mint(msg.sender, _1e18);\\n      bonusToken.mint(operator, _1e18.mul(operatorBonusTokenShare).div(10000));\\n    }\\n\\n    uint256 refund = msg.value.sub(depositAmount);\\n    msg.sender.transfer(refund);\\n\\n    uint32 insertedIndex = _insert(_commitment);\\n    commitments[_commitment] = true;\\n\\n    emit Deposit(_commitment, insertedIndex, block.timestamp);\\n  }\\n\\n  function _calcDepositReserve() internal view returns (uint256) {\\n    uint256 anonSet = totalDeposits.sub(totalWithdrawals);\\n    return _calcReserveBondingCurve(anonSet);\\n  }\\n\\n  function _calcWithdrawalReserve() internal view returns (uint256) {\\n    if (totalDeposits == totalWithdrawals) {\\n      return 0;\\n    }\\n    uint256 anonSet = totalDeposits.sub(totalWithdrawals).sub(1); // 1 less to match the deposit bonus\\n    return _calcReserveBondingCurve(anonSet);\\n  }\\n\\n  function _calcReserveBondingCurve(uint256 anonSet) internal view returns (uint256) {\\n    if (anonSet <= 100) {\\n      // 0 -> 0%; 100 -> 3% (0.03 / anon)\\n      return denomination.mul(anonSet).mul(300).div(10000).div(100);\\n    } else if (anonSet > 100 && anonSet <= 1000) {\\n      // 100 -> 3%; 1,000 -> 12% (0.01 / anon)\\n      return (denomination.mul(2).add(denomination.mul(anonSet).mul(100).div(10000))).div(100);\\n    } else if (anonSet > 1000 && anonSet <= 10000) {\\n      // 1,000 -> 12%; 10,000 -> 39% (0.003 / anon)\\n      return (denomination.mul(9).add(denomination.mul(anonSet).mul(30).div(10000))).div(100);\\n    } else {\\n      // 10,000+ -> 39%\\n      return denomination.mul(39).div(100);\\n    }\\n  }\\n\\n  /**\\n    @dev Withdraw a deposit from the contract. `proof` is a zkSNARK proof data, and input is an array of circuit public inputs\\n    `input` array consists of:\\n      - merkle root of all deposits in the contract\\n      - hash of unique deposit nullifier to prevent double spends\\n      - the recipient of funds\\n      - optional fee that goes to the transaction sender (usually a relay)\\n  */\\n  function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _relayerFee, uint256 _refund) external payable nonReentrant {\\n    require(address(bonusToken) != address(0), \\\"token not deployed\\\");\\n    uint256 withdrawAmount = denomination.add(_calcWithdrawalReserve());\\n    require(_relayerFee <= withdrawAmount, \\\"Fee exceeds transfer value\\\");\\n    require(!nullifierHashes[_nullifierHash], \\\"The note has been already spent\\\");\\n    require(isKnownRoot(_root), \\\"Cannot find your merkle root\\\"); // Make sure to use a recent one\\n    require(verifier.verifyProof(_proof, [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _relayerFee, _refund]), \\\"Invalid withdraw proof\\\");\\n\\n    nullifierHashes[_nullifierHash] = true;\\n    \\n    // sanity checks\\n    require(msg.value == 0, \\\"Message value is supposed to be zero for ETH instance\\\");\\n    require(_refund == 0, \\\"Refund value is supposed to be zero for ETH instance\\\");\\n\\n    totalWithdrawals = totalWithdrawals.add(1);\\n\\n    (bool success, ) = _recipient.call.value(withdrawAmount.sub(_relayerFee))(\\\"\\\");\\n    require(success, \\\"payment to _recipient did not go thru\\\");\\n\\n    if (_relayerFee > 0) {\\n      (success, ) = _relayer.call.value(_relayerFee)(\\\"\\\");\\n      require(success, \\\"payment to _relayer did not go thru\\\");\\n    }\\n    emit Withdrawal(_recipient, _nullifierHash, _relayer, _relayerFee);\\n  }\\n\\n  /** @dev whether a note is already spent */\\n  function isSpent(bytes32 _nullifierHash) public view returns(bool) {\\n    return nullifierHashes[_nullifierHash];\\n  }\\n\\n  /** @dev whether an array of notes is already spent */\\n  function isSpentArray(bytes32[] calldata _nullifierHashes) external view returns(bool[] memory spent) {\\n    spent = new bool[](_nullifierHashes.length);\\n    for(uint i = 0; i < _nullifierHashes.length; i++) {\\n      if (isSpent(_nullifierHashes[i])) {\\n        spent[i] = true;\\n      }\\n    }\\n  }\\n\\n  // open a fresh stake\\n  function stake(uint256 amount) stakingActivated external {\\n    require(address(bonusToken) != address(0), \\\"token not deployed\\\");\\n    Staker storage staker = stakers[msg.sender];\\n    require(staker.stakingTokenBalance == 0, \\\"user is already staked\\\");\\n    require(IERC20(stakingToken).transferFrom(msg.sender, address(this), amount), \\\"staking token transfer failed\\\");\\n\\n    uint256 bonusRound = getCurrentBonusRound();\\n    staker.unlockRound = bonusRound.add(1);\\n\\n    BonusPool storage bonusPool = bonusPoolByRound[bonusRound];\\n    if (bonusPool.creditToken == address(0)) { // first stake in new round\\n      bonusPool.creditToken = address(new ERC20_Mintable(\\\"credit\\\" , 18, \\\"CREDIT\\\"));\\n    }\\n\\n    staker.stakingTokenBalance = staker.stakingTokenBalance.add(amount);\\n    uint256 timeRemaining = getBonusRoundEndingTime(bonusRound).sub(now);\\n    uint256 creditsToMint = amount.mul(timeRemaining).mul(timeRemaining);\\n    ERC20_Mintable(bonusPool.creditToken).mint(msg.sender, creditsToMint);\\n    emit Stake(msg.sender, amount, creditsToMint);\\n  }\\n\\n  // add to an existing stake\\n  function addToStake(uint256 amount) external {\\n    require(address(bonusToken) != address(0), \\\"token not deployed\\\");\\n    Staker storage staker = stakers[msg.sender];\\n    require(staker.stakingTokenBalance > 0, \\\"staker has no balance\\\");\\n    require(IERC20(stakingToken).transferFrom(msg.sender, address(this), amount), \\\"staking token transfer failed\\\");\\n\\n    uint256 bonusRound = getCurrentBonusRound();\\n    require(staker.unlockRound == bonusRound.add(1), \\\"staker is not active in current round\\\");\\n\\n    BonusPool memory bonusPool = bonusPoolByRound[bonusRound];\\n    \\n    staker.stakingTokenBalance = staker.stakingTokenBalance.add(amount);\\n    uint256 timeRemaining = getBonusRoundEndingTime(bonusRound).sub(now);\\n    uint256 creditsToMint = amount.mul(timeRemaining).mul(timeRemaining);\\n    ERC20_Mintable(bonusPool.creditToken).mint(msg.sender, creditsToMint);\\n    emit AddToStake(msg.sender, amount, staker.stakingTokenBalance, creditsToMint);\\n  }\\n\\n  // withdraw a stake\\n  function unstake() external {\\n    require(address(bonusToken) != address(0), \\\"token not deployed\\\");\\n    Staker storage staker = stakers[msg.sender];\\n    uint256 bonusRound = getCurrentBonusRound();\\n\\n    uint256 tokensToUnstake = staker.stakingTokenBalance;\\n    staker.stakingTokenBalance = 0;\\n\\n    require(staker.unlockRound <= bonusRound, \\\"staker is locked in to the current round\\\");\\n    require(IERC20(stakingToken).transfer(msg.sender, tokensToUnstake), \\\"staking token transfer failed\\\");\\n    emit Unstake(msg.sender, tokensToUnstake);\\n  }\\n\\n  function stakerCollectBonus(uint256 creditsToRedeem) external {\\n    require(address(bonusToken) != address(0), \\\"token not deployed\\\");\\n    uint256 bonusRound = getCurrentBonusRound();\\n    require(bonusRound > 0, \\\"no bonus rewards yet\\\");\\n\\n    BonusPool storage bonusPool = bonusPoolByRound[bonusRound.sub(1)];\\n    ERC20_Mintable credit = ERC20_Mintable(bonusPool.creditToken);\\n\\n    require(credit.transferFrom(msg.sender, address(this), creditsToRedeem), \\\"credit token transfer failed\\\");\\n\\n    if (bonusPool.bonusWithdrawn == 0 && bonusRound > 1) { // first staker to withdraw bonus\\n      // rollover any remaining balance from the previous bonus pool\\n      uint256 remainingBonusFromLastRound = getBonusRoundBalance(bonusRound.sub(2));\\n      bonusPool.bonusCollected = bonusPool.bonusCollected.add(remainingBonusFromLastRound);\\n      bonusPool.bonusRolledOver = remainingBonusFromLastRound;\\n      bonusPoolByRound[bonusRound.sub(2)].bonusWithdrawn = bonusPoolByRound[bonusRound.sub(2)].bonusCollected;\\n    }\\n\\n    uint256 stakerBonus = bonusPool.bonusCollected.mul(creditsToRedeem).div(credit.totalSupply());\\n    bonusPool.bonusWithdrawn = bonusPool.bonusWithdrawn.add(stakerBonus);\\n    msg.sender.transfer(stakerBonus);\\n    emit CollectBonus(msg.sender, creditsToRedeem, stakerBonus);\\n  }\\n\\n  function setStakingToken(address _stakingToken) external onlyOperator {\\n    require(stakingToken == address(0), \\\"staking token already set\\\");\\n    require(_stakingToken != address(0), \\\"must provide staking token address\\\");\\n    stakingToken = _stakingToken;\\n  }\\n\\n  /** @dev operator can change his address */\\n  function changeOperator(address _newOperator) external onlyOperator {\\n    operator = _newOperator;\\n  }\\n\\n  function getCurrentBonusRound() public view returns (uint256) {\\n    if (now < growthPhaseEndTime) {\\n      return 0;\\n    } else {\\n      return (now.sub(growthPhaseEndTime)).div(bonusRoundLength).add(1);\\n    }\\n  }\\n\\n  function getBonusRoundEndingTime(uint256 bonusRound) public view returns (uint256) {\\n    if (bonusRound == 0) {\\n      return growthPhaseEndTime;\\n    } else {\\n      return growthPhaseEndTime.add((bonusRound).mul(bonusRoundLength));\\n    }\\n  }\\n\\n  function getDepositAmount() public view returns (uint256) {\\n    uint256 bonusRound = getCurrentBonusRound();\\n    uint256 depositReserve = _calcDepositReserve();\\n    uint256 bonusRate = baseBonusRate;\\n\\n    if (bonusRound == 0) { // growth phase\\n      bonusRate = bonusRate.add(growthBonusRate);\\n    }\\n\\n    uint256 depositBonus = (denomination.add(depositReserve)).mul(bonusRate).div(10000);\\n    uint256 depositAmount = denomination.add(depositReserve).add(depositBonus);\\n    return depositAmount;\\n  }\\n\\n  function getWithdrawalAmount() public view returns (uint256) {\\n    uint256 withdrawalReserve = _calcWithdrawalReserve();\\n    uint256 withdrawalAmount = denomination.add(withdrawalReserve);\\n    return withdrawalAmount;\\n\\n  }\\n\\n  function getReservePool() public view returns (uint256) {\\n    uint256 bonusRound = getCurrentBonusRound();\\n    uint256 totalBonusRoundBalance = getBonusRoundBalance(bonusRound);\\n\\n    if (bonusRound > 0) {\\n      totalBonusRoundBalance = totalBonusRoundBalance.add(getBonusRoundBalance(bonusRound.sub(1)));\\n    }\\n\\n    if (bonusRound > 1) { \\n      totalBonusRoundBalance = totalBonusRoundBalance.add(getBonusRoundBalance(bonusRound.sub(2)));\\n    }\\n\\n    return address(this).balance.sub(denomination.mul(totalDeposits.sub(totalWithdrawals))).sub(totalBonusRoundBalance);\\n  }\\n\\n  function getBonusRoundBalance(uint256 bonusRound) public view returns (uint256) {\\n    BonusPool memory bonusPool = bonusPoolByRound[bonusRound];\\n    return bonusPool.bonusCollected.sub(bonusPool.bonusWithdrawn);\\n  }\\n\\n  function getStakerCreditsByRound(address staker, uint256 bonusRound) public view returns (uint256) {\\n    BonusPool memory bonusPool = bonusPoolByRound[bonusRound];\\n    if (bonusPool.creditToken == address(0)) {\\n     return 0;\\n    }\\n    return ERC20_Mintable(bonusPool.creditToken).balanceOf(staker);\\n  }\\n\\n  function getTotalCreditsByRound(uint256 bonusRound) public view returns (uint256) {\\n    BonusPool memory bonusPool = bonusPoolByRound[bonusRound];\\n    if (bonusPool.creditToken == address(0)) {\\n     return 0;\\n    }\\n    return ERC20_Mintable(bonusPool.creditToken).totalSupply();\\n  }\\n\\n  function getDepositReserve() public view returns (uint256) {\\n    return _calcDepositReserve();\\n  }\\n\\n  function getWithdrawalReserve() public view returns (uint256) {\\n    return _calcWithdrawalReserve();\\n  }\\n\\n  function getReserveBondingCurve(uint256 anonSet) public view returns (uint256) {\\n    return _calcReserveBondingCurve(anonSet);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {\r\n        \"Hasher\": \"0x83584f83f26aF4eDDA9CBe8C730bc87C364b28fe\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_denomination\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_merkleTreeHeight\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_baseBonusRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_growthBonusRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_growthPhaseEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusRoundLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_operatorBonusTokenShare\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creditsMinted\",\"type\":\"uint256\"}],\"name\":\"AddToStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creditsToRedeem\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusCollected\",\"type\":\"uint256\"}],\"name\":\"CollectBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"leafIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creditsMinted\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountUnstaked\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nullifierHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIELD_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROOT_HISTORY_SIZE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_1e18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addToStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseBonusRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusPoolByRound\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creditToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bonusCollected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRolledOver\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusRoundLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusToken\",\"outputs\":[{\"internalType\":\"contract ERC20_Mintable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRootIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"denomination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"filledSubtrees\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusRound\",\"type\":\"uint256\"}],\"name\":\"getBonusRoundBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusRound\",\"type\":\"uint256\"}],\"name\":\"getBonusRoundEndingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBonusRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDepositReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anonSet\",\"type\":\"uint256\"}],\"name\":\"getReserveBondingCurve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReservePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bonusRound\",\"type\":\"uint256\"}],\"name\":\"getStakerCreditsByRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusRound\",\"type\":\"uint256\"}],\"name\":\"getTotalCreditsByRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawalReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"growthBonusRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"growthPhaseEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_left\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_right\",\"type\":\"bytes32\"}],\"name\":\"hashLeftRight\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"isKnownRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_nullifierHash\",\"type\":\"bytes32\"}],\"name\":\"isSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_nullifierHashes\",\"type\":\"bytes32[]\"}],\"name\":\"isSpentArray\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"spent\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nullifierHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operatorBonusTokenShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"}],\"name\":\"setStakingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"creditsToRedeem\",\"type\":\"uint256\"}],\"name\":\"stakerCollectBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockRound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTokenBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_nullifierHash\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refund\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"zeros\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Tornado","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ce172ce1f20ec0b3728c9965470eaf994a03557a0000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000770f2b281db359887eb1305a301fd4e5dc5c4759000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000060e15c700000000000000000000000000000000000000000000000000000000001e1338000000000000000000000000000000000000000000000000000000000000003e8","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}