{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\nimport \\\"./IGelatoCondition.sol\\\";\\n\\nabstract contract GelatoConditionsStandard is IGelatoCondition {\\n    string internal constant OK = \\\"OK\\\";\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/conditions/IGelatoCondition.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\\n/// @notice all the APIs of GelatoConditionsStandard\\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\\ninterface IGelatoCondition {\\n\\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\\n    ///  \\\"ok\\\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\\n    ///  source of Task identification.\\n    /// @param _conditionData This is the Condition.data field developers must encode their\\n    ///  Condition's specific parameters in.\\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\\n        external\\n        view\\n        returns(string memory);\\n}\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/ConditionMakerVaultUnsafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\\\";\\nimport {wmul, wdiv} from \\\"../../../vendor/DSMath.sol\\\";\\nimport {GelatoBytes} from \\\"../../../lib/GelatoBytes.sol\\\";\\nimport {\\n    IInstaMakerResolver\\n} from \\\"../../../interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol\\\";\\n\\n/// @title ConditionMakerVaultUnsafe\\n/// @notice Condition tracking Maker vault collateralization safety requirements.\\n/// @author Gelato Team\\ncontract ConditionMakerVaultUnsafe is GelatoConditionsStandard {\\n    using GelatoBytes for bytes;\\n\\n    /// @notice Convenience function for off-chain _conditionData encoding\\n    /// @dev Use the return for your Task's Condition.data field off-chain.\\n    /// @return The encoded payload for your Task's Condition.data field.\\n    function getConditionData(\\n        uint256 _vaultId,\\n        address _priceOracle,\\n        bytes calldata _oraclePayload,\\n        uint256 _minColRatio\\n    ) public pure virtual returns (bytes memory) {\\n        return abi.encode(_vaultId, _priceOracle, _oraclePayload, _minColRatio);\\n    }\\n\\n    /// @notice Standard GelatoCore system function\\n    /// @dev A standard interface for GelatoCore to read Conditions\\n    /// @param _conditionData The data you get from `getConditionData()`\\n    /// @return OK if the Condition is there, else some error message.\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            uint256 _vaultID,\\n            address _priceOracle,\\n            bytes memory _oraclePayload,\\n            uint256 _minColRatio\\n        ) = abi.decode(_conditionData, (uint256, address, bytes, uint256));\\n\\n        return\\n            isVaultUnsafe(_vaultID, _priceOracle, _oraclePayload, _minColRatio);\\n    }\\n\\n    /// @notice Specific implementation of this Condition's ok function\\n    /// @dev The price oracle must return a uint256 WAD (10**18) value.\\n    /// @param _vaultId The id of the Maker vault\\n    /// @param _priceOracle The price oracle contract to supply the collateral price\\n    ///  e.g. Maker's ETH/USD oracle for ETH collateral pricing.\\n    /// @param _oraclePayload The data for making the staticcall to the oracle's read\\n    ///  method e.g. the selector for MakerOracle's read fn.\\n    /// @param _minColRatio The minimum collateral ratio measured in the price\\n    /// of the collateral as specified by the _priceOracle.\\n    /// @return OK if the Maker Vault is unsafe, otherwise some error message.\\n    function isVaultUnsafe(\\n        uint256 _vaultId,\\n        address _priceOracle,\\n        bytes memory _oraclePayload,\\n        uint256 _minColRatio\\n    ) public view virtual returns (string memory) {\\n        (bool success, bytes memory returndata) = _priceOracle.staticcall(\\n            _oraclePayload\\n        );\\n\\n        if (!success) {\\n            returndata.revertWithError(\\n                \\\"ConditionMakerVaultUnsafe.isVaultUnsafe:oracle:\\\"\\n            );\\n        }\\n\\n        uint256 colPriceInWad = abi.decode(returndata, (uint256));\\n\\n        IInstaMakerResolver.VaultData memory vault = IInstaMakerResolver(\\n            0x0A7008B38E7015F8C36A49eEbc32513ECA8801E5\\n        )\\n            .getVaultById(_vaultId);\\n\\n        uint256 colRatio = wdiv(\\n            wmul(vault.collateral, colPriceInWad),\\n            vault.debt\\n        );\\n\\n        return colRatio < _minColRatio ? OK : \\\"MakerVaultNotUnsafe\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface IInstaMakerResolver {\\n    struct VaultData {\\n        uint256 id;\\n        address owner;\\n        string colType;\\n        uint256 collateral;\\n        uint256 art;\\n        uint256 debt;\\n        uint256 liquidatedCol;\\n        uint256 borrowRate;\\n        uint256 colPrice;\\n        uint256 liquidationRatio;\\n        address vaultAddress;\\n    }\\n\\n    function getVaultById(uint256 id) external view returns (VaultData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GelatoBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nlibrary GelatoBytes {\\n    function calldataSliceSelector(bytes calldata _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function memorySliceSelector(bytes memory _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\\n            } else {\\n                revert(\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"))\\n                );\\n            }\\n        } else {\\n            revert(\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"))\\n            );\\n        }\\n    }\\n\\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\\n            } else {\\n                return\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"));\\n            }\\n        } else {\\n            return\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/DSMath.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: AGPL-3.0-or-later\\\"\\n/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.4;\\n\\nfunction add(uint x, uint y) pure returns (uint z) {\\n    require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n}\\nfunction sub(uint x, uint y) pure returns (uint z) {\\n    require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n}\\nfunction mul(uint x, uint y) pure returns (uint z) {\\n    require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n}\\n\\nfunction min(uint x, uint y) pure returns (uint z) {\\n    return x <= y ? x : y;\\n}\\nfunction max(uint x, uint y) pure returns (uint z) {\\n    return x >= y ? x : y;\\n}\\nfunction imin(int x, int y) pure returns (int z) {\\n    return x <= y ? x : y;\\n}\\nfunction imax(int x, int y) pure returns (int z) {\\n    return x >= y ? x : y;\\n}\\n\\nuint constant WAD = 10 ** 18;\\nuint constant RAY = 10 ** 27;\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction wmul(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, y), WAD / 2) / WAD;\\n}\\n//rounds to zero if x*y < WAD / 2\\nfunction rmul(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, y), RAY / 2) / RAY;\\n}\\n//rounds to zero if x*y < WAD / 2\\nfunction wdiv(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, WAD), y / 2) / y;\\n}\\n//rounds to zero if x*y < RAY / 2\\nfunction rdiv(uint x, uint y) pure returns (uint z) {\\n    z = add(mul(x, RAY), y / 2) / y;\\n}\\n\\n// This famous algorithm is called \\\"exponentiation by squaring\\\"\\n// and calculates x^n with x as fixed-point and n as regular unsigned.\\n//\\n// It's O(log n), instead of O(n) for naive repeated multiplication.\\n//\\n// These facts are why it works:\\n//\\n//  If n is even, then x^n = (x^2)^(n/2).\\n//  If n is odd,  then x^n = x * x^(n-1),\\n//   and applying the equation for even x gives\\n//    x^n = x * (x^2)^((n-1) / 2).\\n//\\n//  Also, EVM division is flooring and\\n//    floor[(n-1) / 2] = floor[n / 2].\\n//\\nfunction rpow(uint x, uint n) pure returns (uint z) {\\n    z = n % 2 != 0 ? x : RAY;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n        x = rmul(x, x);\\n\\n        if (n % 2 != 0) {\\n            z = rmul(z, x);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_oraclePayload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_minColRatio\",\"type\":\"uint256\"}],\"name\":\"getConditionData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_oraclePayload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_minColRatio\",\"type\":\"uint256\"}],\"name\":\"isVaultUnsafe\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_conditionData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ok\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConditionMakerVaultUnsafe","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":""}]}