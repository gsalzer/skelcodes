{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\n     * function returns false is an externally-owned account (EOA) and not a\\n     * contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n\\ncontract Context {\\n    function _msgSender() internal view  returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view  returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"},\"IERC20.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\n\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address who) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function transfer(address to, uint value) external returns (bool);\\n    function approve(address spender, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\"},\"IntMonaToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface MonaToken is IERC20 {\\n    \\n    function burn(uint256 amount) external;\\n}\"},\"MONA__Presale.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./safemath.sol\\\";\\nimport \\\"./UniswapV2Router02.sol\\\";\\nimport \\\"./UniswapV2Helper.sol\\\";\\nimport \\\"./UniswapV2Factory.sol\\\";\\nimport \\\"./IntMonaToken.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./Context.sol\\\"; \\n\\n\\ncontract MONA__Presale is Context {\\n    \\n    using SafeMath for uint;\\n    using SafeERC20 for IERC20;\\n    \\n    IERC20 token;\\n    IERC20 LISAv1;\\n    \\n    uint public tokensBought;\\n    bool public isRunning = true;\\n    bool public poolgenEnd = false;\\n    bool public EnableEmergencyRefund = false;\\n    bool public FirstPhaseEnd = false;\\n    address payable owner;\\n    \\n    uint256 public ethSent;\\n    uint256 tokensPerETH                = 800; // 80.0 ( 1 ETH = 80.0 LISAv2 )\\n    uint256 tokensPerETHAfterPresale    = 500; // 50.0 ( 1 ETH = 50.0 LISAv2 )\\n    uint256 tokensPerV1Tokens           =   6; //  0.6 ( 1 LISA = 0.6 LISAv2 )\\n    \\n    uint256 public lockedLiquidityAmount;\\n    \\n\\n    mapping(address =\\u003e uint) ethSpent; \\n    \\n    mapping(address =\\u003e mapping ( address =\\u003e uint256)) _allowances;\\n    \\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"You are not the owner\\\");\\n        _;\\n    }\\n    \\n    \\n    // UNISWAP DECLARATIONS - BEGIN\\n    address public uniswapPair;\\n    \\n    \\n    address public constant uniswapHelperAddress = 0x5CdF8D8CbCFf0AD458efed22A7451b69bAa0e8B6; \\n    address public constant uniswapFactoryAddress = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\\n    address public constant uniswapRouterAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;  \\n    \\n\\n    UniswapV2Router02 private uniswapRouter;\\n    UniswapV2Factory private uniswapFactory;\\n    UniswapV2Helper private uniswapHelper; \\n    \\n    // UNISWAP DECLARATIONS - END\\n    \\n    MonaToken private LISAv2;\\n    \\n    \\n    // address where liquidity pool tokens will be locked\\n    constructor(IERC20 _tokenV2, IERC20 _tokenV1 ) {\\n        token = _tokenV2;\\n        owner = msg.sender; \\n        \\n        LISAv2 = MonaToken( address( _tokenV2 ) ); \\n        LISAv1 = IERC20( _tokenV1 );\\n        \\n        uniswapFactory = UniswapV2Factory( uniswapFactoryAddress );\\n        uniswapRouter = UniswapV2Router02( uniswapRouterAddress );\\n        \\n        \\n        if( uniswapPair == address(0) ){\\n            uniswapPair = uniswapFactory.createPair(\\n                address( uniswapRouter.WETH() ),\\n                address( token )\\n            );\\n        } \\n    }\\n    \\n    \\n    receive() external payable { \\n        \\n        require(isRunning, \\\"Actual presale is off!\\\");\\n        \\n        require(msg.value \\u003e= 0.01 ether, \\\"You sent less than 0.01 ETH\\\");\\n        require(msg.value \\u003c= 2 ether,    \\\"You sent more than 2.00 ETH\\\");\\n        \\n        require(ethSent.add(msg.value) \\u003c= 150 ether, \\\"Hard cap reached\\\");\\n        \\n        require(ethSpent[msg.sender].add(msg.value) \\u003c= 2 ether, \\\"You can\\u0027t buy more\\\");\\n        \\n        uint256 tokens = msg.value.mul(tokensPerETH).div( 10 );\\n        require(token.balanceOf(address(this)) \\u003e= tokens, \\\"Not enough tokens in the contract\\\");\\n        token.transfer(msg.sender, tokens);\\n        \\n        ethSpent[msg.sender] = ethSpent[msg.sender].add(msg.value);\\n        tokensBought = tokensBought.add(tokens);\\n        \\n        ethSent = ethSent.add(msg.value);\\n    }\\n    \\n    function releaseLISAv1() public onlyOwner {\\n        \\n        uint256 amount = LISAv1.balanceOf( address(this) );\\n        LISAv1.approve( owner, amount);\\n        LISAv1.safeTransferFrom( address(this), owner, amount);\\n        \\n    }\\n   \\n    function userEthSpenttInPresale(address user) external view returns(uint){\\n        return ethSpent[user];\\n    }\\n    \\n    function phaseEnd( ) external onlyOwner{\\n        FirstPhaseEnd = true;\\n    }\\n    function presaleEndAndCreateLiquidity( address _liquidityLockAddress ) external onlyOwner{\\n        // lock Preslae\\n        isRunning = false;\\n        \\n        // unlock emergencyRefund if something goes wrong\\n        EnableEmergencyRefund = true;\\n        \\n        // check if Create Liquidity has already been done\\n        require( poolgenEnd == false, \\\"Liquidity generation already finished\\\");\\n        \\n        // create liquidity - BEGIN\\n        \\n        // [ ETH to liquidity ] = [ ETH balance ]\\n        uint256 liquidityETH = address(this).balance;\\n        \\n        // [ tokens to liquidity ] = [ liquidity eth ] * [ tokens per ETH ]\\n        uint256 liquidityDesiredTokens = liquidityETH.mul( tokensPerETHAfterPresale ).div(10);\\n        \\n        // transaction must be completed within 5 minutes\\n        uint256 transactionDeadline = block.timestamp.add(5 minutes);\\n        \\n        LISAv2.approve(address(uniswapRouter), liquidityDesiredTokens);\\n        \\n        // send tokens and ETH to liquidity pool \\n        try uniswapRouter.addLiquidityETH{ value: liquidityETH }(\\n                address( LISAv2 ),\\n                liquidityDesiredTokens,\\n                liquidityDesiredTokens,\\n                liquidityETH,\\n                address( _liquidityLockAddress ),\\n                transactionDeadline\\n            ) returns (uint amountToken, uint amountETH, uint liquidity)\\n        {\\n            // burn rest of tokens\\n            LISAv2.burn( token.balanceOf(address(this)));\\n            \\n        } catch {\\n            // error handling\\n        }\\n        \\n        // create liquidity - END\\n        \\n        // lock Create Liquidity\\n        poolgenEnd = true;\\n    }\\n    \\n    function swap(uint256 amount) external payable { \\n        if(FirstPhaseEnd == true){\\n             revert( \\\"First Phase already finished\\\" );\\n        }\\n        require(isRunning, \\\"Actual swap is off!\\\");\\n        require(amount \\u003e 0, \\\"Cannot swap 0\\\");\\n        \\n        LISAv1.safeTransferFrom(msg.sender, address(this), amount);\\n        \\n        uint256 tokens = amount.mul( tokensPerV1Tokens ).div( 10 );\\n        require( token.balanceOf(address(this)) \\u003e= tokens, \\\"Not enough tokens in the contract\\\");\\n        token.transfer(msg.sender, tokens);\\n        \\n    }\\n    \\n    \\n    \\n    // emergencyRefund in case of a bug in liquidity generation\\n    // transfer all funds to owner to refund people\\n    // Only available when liquidity pool not created ( if poolGenFailed == true )\\n    function emergencyRefund() public onlyOwner {\\n        // check if emergencyRefund is unlocked\\n        if(EnableEmergencyRefund == true){\\n            // send rest of tokens and eth to owner for refund or manualy create Liquidity\\n            owner.transfer(address(this).balance); \\n            token.transfer(owner, token.balanceOf(address(this)));\\n        }\\n    }\\n}\\n\\n    \"},\"SafeERC20.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./safemath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length \\u003e 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"safemath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"},\"UniswapV2Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.5.0;\\n\\ninterface UniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function migrator() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n    function setMigrator(address) external;\\n}\\n\"},\"UniswapV2Helper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface UniswapV2Helper {\\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\\n\\n    function pairFor(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function getFactoryAddress() external view returns (address factory);\\n\\n    function getRouterAddress() external view returns (address router);\\n\\n    function getUniswapV2OracleAddress() external view returns (address oracle);\\n}\"},\"UniswapV2Router01.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.2;\\n\\ninterface UniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"},\"UniswapV2Router02.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.2;\\n\\nimport \\u0027./UniswapV2Router01.sol\\u0027;\\n\\ninterface UniswapV2Router02 is UniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_tokenV2\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_tokenV1\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EnableEmergencyRefund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FirstPhaseEnd\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethSent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRunning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedLiquidityAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phaseEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolgenEnd\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityLockAddress\",\"type\":\"address\"}],\"name\":\"presaleEndAndCreateLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseLISAv1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensBought\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapFactoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapHelperAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userEthSpenttInPresale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MONA__Presale","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000129085f138eb2ebb1a7705362b0750970c6c205400000000000000000000000074d8c60b2134f80a6dd9f3366d623776673f4f88","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://97db43902664e6d7113970567c8709ddbee8f938007ec0d31338fee737c2f338"}]}