{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/intf/IERC20.sol\r\n\r\n// This is a file copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/DecimalMath.sol\r\n\r\n/**\r\n * @title DecimalMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Functions for fixed point number with 18 decimals\r\n */\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant ONE = 10**18;\r\n    uint256 internal constant ONE2 = 10**36;\r\n\r\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d) / (10**18);\r\n    }\r\n\r\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d).divCeil(10**18);\r\n    }\r\n\r\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).div(d);\r\n    }\r\n\r\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).divCeil(d);\r\n    }\r\n\r\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).div(target);\r\n    }\r\n\r\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).divCeil(target);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/InitializableOwnable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @author DODO Breeder\r\n *\r\n * @notice Ownership related functions\r\n */\r\ncontract InitializableOwnable {\r\n    address public _OWNER_;\r\n    address public _NEW_OWNER_;\r\n    bool internal _INITIALIZED_;\r\n\r\n    // ============ Events ============\r\n\r\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier notInitialized() {\r\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function initOwner(address newOwner) public notInitialized {\r\n        _INITIALIZED_ = true;\r\n        _OWNER_ = newOwner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\r\n        _NEW_OWNER_ = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public {\r\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\r\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\r\n        _OWNER_ = _NEW_OWNER_;\r\n        _NEW_OWNER_ = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SafeERC20.sol\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/intf/IDODOApprove.sol\r\n\r\n\r\ninterface IDODOApprove {\r\n    function claimTokens(address token,address who,address dest,uint256 amount) external;\r\n    function getDODOProxy() external view returns (address);\r\n}\r\n\r\n// File: contracts/SmartRoute/DODOApproveProxy.sol\r\n\r\n\r\ninterface IDODOApproveProxy {\r\n    function isAllowedProxy(address _proxy) external view returns (bool);\r\n    function claimTokens(address token,address who,address dest,uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @title DODOApproveProxy\r\n * @author DODO Breeder\r\n *\r\n * @notice Allow different version dodoproxy to claim from DODOApprove\r\n */\r\ncontract DODOApproveProxy is InitializableOwnable {\r\n    \r\n    // ============ Storage ============\r\n    uint256 private constant _TIMELOCK_DURATION_ = 3 days;\r\n    mapping (address => bool) public _IS_ALLOWED_PROXY_;\r\n    uint256 public _TIMELOCK_;\r\n    address public _PENDING_ADD_DODO_PROXY_;\r\n    address public immutable _DODO_APPROVE_;\r\n\r\n    // ============ Modifiers ============\r\n    modifier notLocked() {\r\n        require(\r\n            _TIMELOCK_ <= block.timestamp,\r\n            \"SetProxy is timelocked\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address dodoApporve) public {\r\n        _DODO_APPROVE_ = dodoApporve;\r\n    }\r\n\r\n    function init(address owner, address[] memory proxies) external {\r\n        initOwner(owner);\r\n        for(uint i = 0; i < proxies.length; i++) \r\n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\r\n    }\r\n\r\n    function unlockAddProxy(address newDodoProxy) public onlyOwner {\r\n        _TIMELOCK_ = block.timestamp + _TIMELOCK_DURATION_;\r\n        _PENDING_ADD_DODO_PROXY_ = newDodoProxy;\r\n    }\r\n\r\n    function lockAddProxy() public onlyOwner {\r\n       _PENDING_ADD_DODO_PROXY_ = address(0);\r\n       _TIMELOCK_ = 0;\r\n    }\r\n\r\n\r\n    function addDODOProxy() external onlyOwner notLocked() {\r\n        _IS_ALLOWED_PROXY_[_PENDING_ADD_DODO_PROXY_] = true;\r\n        lockAddProxy();\r\n    }\r\n\r\n    function removeDODOProxy (address oldDodoProxy) public onlyOwner {\r\n        _IS_ALLOWED_PROXY_[oldDodoProxy] = false;\r\n    }\r\n    \r\n    function claimTokens(\r\n        address token,\r\n        address who,\r\n        address dest,\r\n        uint256 amount\r\n    ) external {\r\n        require(_IS_ALLOWED_PROXY_[msg.sender], \"DODOApproveProxy:Access restricted\");\r\n        IDODOApprove(_DODO_APPROVE_).claimTokens(\r\n            token,\r\n            who,\r\n            dest,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function isAllowedProxy(address _proxy) external view returns (bool) {\r\n        return _IS_ALLOWED_PROXY_[_proxy];\r\n    }\r\n}\r\n\r\n// File: contracts/DODOToken/vDODOToken.sol\r\n\r\n\r\n\r\ninterface IGovernance {\r\n    function getLockedvDODO(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IDODOCirculationHelper {\r\n    // Locked vDOOD not counted in circulation\r\n    function getCirculation() external view returns (uint256);\r\n\r\n    function getDodoWithdrawFeeRatio() external view returns (uint256);\r\n}\r\n\r\ncontract vDODOToken is InitializableOwnable {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Storage(ERC20) ============\r\n\r\n    string public name = \"vDODO Membership Token\";\r\n    string public symbol = \"vDODO\";\r\n    uint8 public decimals = 18;\r\n    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\r\n\r\n    // ============ Storage ============\r\n\r\n    address public immutable _DODO_TOKEN_;\r\n    address public immutable _DODO_APPROVE_PROXY_;\r\n    address public immutable _DODO_TEAM_;\r\n    address public _DOOD_GOV_;\r\n    address public _DODO_CIRCULATION_HELPER_;\r\n\r\n    bool public _CAN_TRANSFER_;\r\n\r\n    // staking reward parameters\r\n    uint256 public _DODO_PER_BLOCK_;\r\n    uint256 public constant _SUPERIOR_RATIO_ = 10**17; // 0.1\r\n    uint256 public constant _DODO_RATIO_ = 100; // 100\r\n    uint256 public _DODO_FEE_BURN_RATIO_;\r\n\r\n    // accounting\r\n    uint112 public alpha = 10**18; // 1\r\n    uint112 public _TOTAL_BLOCK_DISTRIBUTION_;\r\n    uint32 public _LAST_REWARD_BLOCK_;\r\n\r\n    uint256 public _TOTAL_BLOCK_REWARD_;\r\n    uint256 public _TOTAL_STAKING_POWER_;\r\n    mapping(address => UserInfo) public userInfo;\r\n\r\n    struct UserInfo {\r\n        uint128 stakingPower;\r\n        uint128 superiorSP;\r\n        address superior;\r\n        uint256 credit;\r\n    }\r\n\r\n    // ============ Events ============\r\n\r\n    event MintVDODO(address user, address superior, uint256 mintDODO);\r\n    event RedeemVDODO(address user, uint256 receiveDODO, uint256 burnDODO, uint256 feeDODO);\r\n    event DonateDODO(address user, uint256 donateDODO);\r\n    event SetCantransfer(bool allowed);\r\n\r\n    event PreDeposit(uint256 dodoAmount);\r\n    event ChangePerReward(uint256 dodoPerBlock);\r\n    event UpdateDODOFeeBurnRatio(uint256 dodoFeeBurnRatio);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier canTransfer() {\r\n        require(_CAN_TRANSFER_, \"vDODOToken: not allowed transfer\");\r\n        _;\r\n    }\r\n\r\n    modifier balanceEnough(address account, uint256 amount) {\r\n        require(availableBalanceOf(account) >= amount, \"vDODOToken: available amount not enough\");\r\n        _;\r\n    }\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address dodoGov,\r\n        address dodoToken,\r\n        address dodoApproveProxy,\r\n        address dodoTeam\r\n    ) public {\r\n        _DOOD_GOV_ = dodoGov;\r\n        _DODO_TOKEN_ = dodoToken;\r\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\r\n        _DODO_TEAM_ = dodoTeam;\r\n    }\r\n\r\n    // ============ Ownable Functions ============`\r\n\r\n    function setCantransfer(bool allowed) public onlyOwner {\r\n        _CAN_TRANSFER_ = allowed;\r\n        emit SetCantransfer(allowed);\r\n    }\r\n\r\n    function changePerReward(uint256 dodoPerBlock) public onlyOwner {\r\n        _updateAlpha();\r\n        _DODO_PER_BLOCK_ = dodoPerBlock;\r\n        emit ChangePerReward(dodoPerBlock);\r\n    }\r\n\r\n    function updateDODOFeeBurnRatio(uint256 dodoFeeBurnRatio) public onlyOwner {\r\n        _DODO_FEE_BURN_RATIO_ = dodoFeeBurnRatio;\r\n        emit UpdateDODOFeeBurnRatio(_DODO_FEE_BURN_RATIO_);\r\n    }\r\n\r\n    function updateDODOCirculationHelper(address helper) public onlyOwner {\r\n        _DODO_CIRCULATION_HELPER_ = helper;\r\n    }\r\n\r\n    function updateGovernance(address governance) public onlyOwner {\r\n        _DOOD_GOV_ = governance;\r\n    }\r\n\r\n    function emergencyWithdraw() public onlyOwner {\r\n        uint256 dodoBalance = IERC20(_DODO_TOKEN_).balanceOf(address(this));\r\n        IERC20(_DODO_TOKEN_).transfer(_OWNER_, dodoBalance);\r\n    }\r\n\r\n    // ============ Mint & Redeem & Donate ============\r\n\r\n    function mint(uint256 dodoAmount, address superiorAddress) public {\r\n        require(\r\n            superiorAddress != address(0) && superiorAddress != msg.sender,\r\n            \"vDODOToken: Superior INVALID\"\r\n        );\r\n        require(dodoAmount > 0, \"vDODOToken: must mint greater than 0\");\r\n\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        if (user.superior == address(0)) {\r\n            require(\r\n                superiorAddress == _DODO_TEAM_ || userInfo[superiorAddress].superior != address(0),\r\n                \"vDODOToken: INVALID_SUPERIOR_ADDRESS\"\r\n            );\r\n            user.superior = superiorAddress;\r\n        }\r\n\r\n        _updateAlpha();\r\n\r\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\r\n            _DODO_TOKEN_,\r\n            msg.sender,\r\n            address(this),\r\n            dodoAmount\r\n        );\r\n\r\n        uint256 newStakingPower = DecimalMath.divFloor(dodoAmount, alpha);\r\n\r\n        _mint(user, newStakingPower);\r\n\r\n        emit MintVDODO(msg.sender, superiorAddress, dodoAmount);\r\n    }\r\n\r\n    function redeem(uint256 vdodoAmount, bool all) public balanceEnough(msg.sender, vdodoAmount) {\r\n        _updateAlpha();\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        uint256 dodoAmount;\r\n        uint256 stakingPower;\r\n\r\n        if (all) {\r\n            stakingPower = uint256(user.stakingPower).sub(DecimalMath.divFloor(user.credit, alpha));\r\n            dodoAmount = DecimalMath.mulFloor(stakingPower, alpha);\r\n        } else {\r\n            dodoAmount = vdodoAmount.mul(_DODO_RATIO_);\r\n            stakingPower = DecimalMath.divFloor(dodoAmount, alpha);\r\n        }\r\n\r\n        _redeem(user, stakingPower);\r\n\r\n        (uint256 dodoReceive, uint256 burnDodoAmount, uint256 withdrawFeeDodoAmount) = getWithdrawResult(dodoAmount);\r\n\r\n        IERC20(_DODO_TOKEN_).transfer(msg.sender, dodoReceive);\r\n        \r\n        if (burnDodoAmount > 0) {\r\n            IERC20(_DODO_TOKEN_).transfer(address(0), burnDodoAmount);\r\n        }\r\n        \r\n        if (withdrawFeeDodoAmount > 0) {\r\n            alpha = uint112(\r\n                uint256(alpha).add(\r\n                    DecimalMath.divFloor(withdrawFeeDodoAmount, _TOTAL_STAKING_POWER_)\r\n                )\r\n            );\r\n        }\r\n\r\n        emit RedeemVDODO(msg.sender, dodoReceive, burnDodoAmount, withdrawFeeDodoAmount);\r\n    }\r\n\r\n    function donate(uint256 dodoAmount) public {\r\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\r\n            _DODO_TOKEN_,\r\n            msg.sender,\r\n            address(this),\r\n            dodoAmount\r\n        );\r\n        alpha = uint112(\r\n            uint256(alpha).add(DecimalMath.divFloor(dodoAmount, _TOTAL_STAKING_POWER_))\r\n        );\r\n        emit DonateDODO(msg.sender, dodoAmount);\r\n    }\r\n\r\n    function preDepositedBlockReward(uint256 dodoAmount) public {\r\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\r\n            _DODO_TOKEN_,\r\n            msg.sender,\r\n            address(this),\r\n            dodoAmount\r\n        );\r\n        _TOTAL_BLOCK_REWARD_ = _TOTAL_BLOCK_REWARD_.add(dodoAmount);\r\n        emit PreDeposit(dodoAmount);\r\n    }\r\n\r\n    // ============ ERC20 Functions ============\r\n\r\n    function totalSupply() public view returns (uint256 vDODOSupply) {\r\n        uint256 totalDODO = IERC20(_DODO_TOKEN_).balanceOf(address(this));\r\n        (,uint256 curDistribution) = getLatestAlpha();\r\n        uint256 actualDODO = totalDODO.sub(_TOTAL_BLOCK_REWARD_.sub(curDistribution.add(_TOTAL_BLOCK_DISTRIBUTION_)));\r\n        vDODOSupply = actualDODO / _DODO_RATIO_;\r\n    }\r\n    \r\n    function balanceOf(address account) public view returns (uint256 vDODOAmount) {\r\n        vDODOAmount = dodoBalanceOf(account) / _DODO_RATIO_;\r\n    }\r\n\r\n    function transfer(address to, uint256 vDODOAmount) public returns (bool) {\r\n        _updateAlpha();\r\n        _transfer(msg.sender, to, vDODOAmount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 vDODOAmount) canTransfer public returns (bool) {\r\n        _ALLOWED_[msg.sender][spender] = vDODOAmount;\r\n        emit Approval(msg.sender, spender, vDODOAmount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 vDODOAmount\r\n    ) public returns (bool) {\r\n        require(vDODOAmount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\r\n        _updateAlpha();\r\n        _transfer(from, to, vDODOAmount);\r\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender].sub(vDODOAmount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _ALLOWED_[owner][spender];\r\n    }\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function getLatestAlpha() public view returns (uint256 newAlpha, uint256 curDistribution) {\r\n        if (_LAST_REWARD_BLOCK_ == 0) {\r\n            curDistribution = 0;\r\n        } else {\r\n            curDistribution = _DODO_PER_BLOCK_ * (block.number - _LAST_REWARD_BLOCK_);\r\n        }\r\n        if (_TOTAL_STAKING_POWER_ > 0) {\r\n            newAlpha = uint256(alpha).add(DecimalMath.divFloor(curDistribution, _TOTAL_STAKING_POWER_));\r\n        } else {\r\n            newAlpha = alpha;\r\n        }\r\n    }\r\n\r\n    function availableBalanceOf(address account) public view returns (uint256 vDODOAmount) {\r\n        if (_DOOD_GOV_ == address(0)) {\r\n            vDODOAmount = balanceOf(account);\r\n        } else {\r\n            uint256 lockedvDODOAmount = IGovernance(_DOOD_GOV_).getLockedvDODO(account);\r\n            vDODOAmount = balanceOf(account).sub(lockedvDODOAmount);\r\n        }\r\n    }\r\n\r\n    function dodoBalanceOf(address account) public view returns (uint256 dodoAmount) {\r\n        UserInfo memory user = userInfo[account];\r\n        (uint256 newAlpha,) = getLatestAlpha();\r\n        uint256 nominalDodo =  DecimalMath.mulFloor(uint256(user.stakingPower), newAlpha);\r\n        if(nominalDodo > user.credit) {\r\n            dodoAmount = nominalDodo - user.credit;\r\n        }else {\r\n            dodoAmount = 0;\r\n        }\r\n    }\r\n\r\n    function getWithdrawResult(uint256 dodoAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 dodoReceive,\r\n            uint256 burnDodoAmount,\r\n            uint256 withdrawFeeDodoAmount\r\n        )\r\n    {\r\n        uint256 feeRatio =\r\n            IDODOCirculationHelper(_DODO_CIRCULATION_HELPER_).getDodoWithdrawFeeRatio();\r\n\r\n        withdrawFeeDodoAmount = DecimalMath.mulFloor(dodoAmount, feeRatio);\r\n        dodoReceive = dodoAmount.sub(withdrawFeeDodoAmount);\r\n\r\n        burnDodoAmount = DecimalMath.mulFloor(withdrawFeeDodoAmount, _DODO_FEE_BURN_RATIO_);\r\n        withdrawFeeDodoAmount = withdrawFeeDodoAmount.sub(burnDodoAmount);\r\n    }\r\n\r\n    function getDODOWithdrawFeeRatio() public view returns (uint256 feeRatio) {\r\n        feeRatio = IDODOCirculationHelper(_DODO_CIRCULATION_HELPER_).getDodoWithdrawFeeRatio();\r\n    }\r\n\r\n    function getSuperior(address account) public view returns (address superior) {\r\n        return userInfo[account].superior;\r\n    }\r\n\r\n    // ============ Internal Functions ============\r\n\r\n    function _updateAlpha() internal {\r\n        (uint256 newAlpha, uint256 curDistribution) = getLatestAlpha();\r\n        uint256 newTotalDistribution = curDistribution.add(_TOTAL_BLOCK_DISTRIBUTION_);\r\n        require(newAlpha <= uint112(-1) && newTotalDistribution <= uint112(-1), \"OVERFLOW\");\r\n        alpha = uint112(newAlpha);\r\n        _TOTAL_BLOCK_DISTRIBUTION_ = uint112(newTotalDistribution);\r\n        _LAST_REWARD_BLOCK_ = uint32(block.number);\r\n    }\r\n\r\n    function _mint(UserInfo storage to, uint256 stakingPower) internal {\r\n        require(stakingPower <= uint128(-1), \"OVERFLOW\");\r\n        UserInfo storage superior = userInfo[to.superior];\r\n        uint256 superiorIncreSP = DecimalMath.mulFloor(stakingPower, _SUPERIOR_RATIO_);\r\n        uint256 superiorIncreCredit = DecimalMath.mulFloor(superiorIncreSP, alpha);\r\n\r\n        to.stakingPower = uint128(uint256(to.stakingPower).add(stakingPower));\r\n        to.superiorSP = uint128(uint256(to.superiorSP).add(superiorIncreSP));\r\n\r\n        superior.stakingPower = uint128(uint256(superior.stakingPower).add(superiorIncreSP));\r\n        superior.credit = uint128(uint256(superior.credit).add(superiorIncreCredit));\r\n\r\n        _TOTAL_STAKING_POWER_ = _TOTAL_STAKING_POWER_.add(stakingPower).add(superiorIncreSP);\r\n    }\r\n\r\n    function _redeem(UserInfo storage from, uint256 stakingPower) internal {\r\n        from.stakingPower = uint128(uint256(from.stakingPower).sub(stakingPower));\r\n\r\n        // superior decrease sp = min(stakingPower*0.1, from.superiorSP)\r\n        uint256 superiorDecreSP = DecimalMath.mulFloor(stakingPower, _SUPERIOR_RATIO_);\r\n        superiorDecreSP = from.superiorSP <= superiorDecreSP ? from.superiorSP : superiorDecreSP;\r\n        from.superiorSP = uint128(uint256(from.superiorSP).sub(superiorDecreSP));\r\n\r\n        UserInfo storage superior = userInfo[from.superior];\r\n        uint256 creditSP = DecimalMath.divFloor(superior.credit, alpha);\r\n\r\n        if (superiorDecreSP >= creditSP) {\r\n            superior.credit = 0;\r\n            superior.stakingPower = uint128(uint256(superior.stakingPower).sub(creditSP));\r\n        } else {\r\n            superior.credit = uint128(\r\n                uint256(superior.credit).sub(DecimalMath.mulFloor(superiorDecreSP, alpha))\r\n            );\r\n            superior.stakingPower = uint128(uint256(superior.stakingPower).sub(superiorDecreSP));\r\n        }\r\n\r\n        _TOTAL_STAKING_POWER_ = _TOTAL_STAKING_POWER_.sub(stakingPower).sub(superiorDecreSP);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 vDODOAmount\r\n    ) internal canTransfer balanceEnough(from, vDODOAmount) {\r\n        require(from != address(0), \"transfer from the zero address\");\r\n        require(to != address(0), \"transfer to the zero address\");\r\n        require(from != to, \"transfer from same with to\");\r\n\r\n        uint256 stakingPower = DecimalMath.divFloor(vDODOAmount * _DODO_RATIO_, alpha);\r\n\r\n        UserInfo storage fromUser = userInfo[from];\r\n        UserInfo storage toUser = userInfo[to];\r\n\r\n        _redeem(fromUser, stakingPower);\r\n        _mint(toUser, stakingPower);\r\n\r\n        emit Transfer(from, to, vDODOAmount);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dodoGov\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dodoToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dodoApproveProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dodoTeam\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dodoPerBlock\",\"type\":\"uint256\"}],\"name\":\"ChangePerReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"donateDODO\",\"type\":\"uint256\"}],\"name\":\"DonateDODO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"superior\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintDODO\",\"type\":\"uint256\"}],\"name\":\"MintVDODO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dodoAmount\",\"type\":\"uint256\"}],\"name\":\"PreDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiveDODO\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnDODO\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeDODO\",\"type\":\"uint256\"}],\"name\":\"RedeemVDODO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"SetCantransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dodoFeeBurnRatio\",\"type\":\"uint256\"}],\"name\":\"UpdateDODOFeeBurnRatio\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_CAN_TRANSFER_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DODO_APPROVE_PROXY_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DODO_CIRCULATION_HELPER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DODO_FEE_BURN_RATIO_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DODO_PER_BLOCK_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DODO_RATIO_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DODO_TEAM_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DODO_TOKEN_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DOOD_GOV_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LAST_REWARD_BLOCK_\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NEW_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_SUPERIOR_RATIO_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TOTAL_BLOCK_DISTRIBUTION_\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TOTAL_BLOCK_REWARD_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TOTAL_STAKING_POWER_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alpha\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vDODOAmount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"availableBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vDODOAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vDODOAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dodoPerBlock\",\"type\":\"uint256\"}],\"name\":\"changePerReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dodoBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dodoAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dodoAmount\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDODOWithdrawFeeRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestAlpha\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newAlpha\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curDistribution\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getSuperior\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"superior\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dodoAmount\",\"type\":\"uint256\"}],\"name\":\"getWithdrawResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dodoReceive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnDodoAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFeeDodoAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dodoAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"superiorAddress\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dodoAmount\",\"type\":\"uint256\"}],\"name\":\"preDepositedBlockReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vdodoAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"all\",\"type\":\"bool\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setCantransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vDODOSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vDODOAmount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vDODOAmount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"helper\",\"type\":\"address\"}],\"name\":\"updateDODOCirculationHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dodoFeeBurnRatio\",\"type\":\"uint256\"}],\"name\":\"updateDODOFeeBurnRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"updateGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"stakingPower\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"superiorSP\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"superior\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"credit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"vDODOToken","CompilerVersion":"v0.6.9+commit.3e3065ac","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000043dfc4159d86f3a37a5a4b3d4580b888ad7d4ddd000000000000000000000000335ac99bb3e51bdbf22025f092ebc1cf2c5cc61900000000000000000000000095c4f5b83aa70810d4f142d58e5f7242bd891cb0","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7b4fb94c47a1c1d4eb8a67cf39d4a9890a6ea811b50c1406bf846bb511c4b87b"}]}