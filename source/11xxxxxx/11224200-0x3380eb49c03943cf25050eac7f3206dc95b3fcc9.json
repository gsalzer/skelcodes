{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: openzeppelin-solidity/contracts/access/Roles.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: contracts/role/interface/IBaseOperators.sol\n\n/**\n * @title IBaseOperators\n * @notice Interface for BaseOperators contract\n */\n\npragma solidity 0.5.12;\n\n\ninterface IBaseOperators {\n    function isOperator(address _account) external view returns (bool);\n    function isAdmin(address _account) external view returns (bool);\n    function isSystem(address _account) external view returns (bool);\n    function isRelay(address _account) external view returns (bool);\n    function isMultisig(address _contract) external view returns (bool);\n\n    function confirmFor(address _address) external;\n\n    function addOperator(address _account) external;\n    function removeOperator(address _account) external;\n    function addAdmin(address _account) external;\n    function removeAdmin(address _account) external;\n    function addSystem(address _account) external;\n    function removeSystem(address _account) external;\n    function addRelay(address _account) external;\n    function removeRelay(address _account) external;\n\n    function addOperatorAndAdmin(address _account) external;\n    function removeOperatorAndAdmin(address _account) external;\n}\n\n// File: contracts/helpers/Initializable.sol\n\npragma solidity 0.5.12;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Initializable: Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  function isInitialized() public view returns (bool) {\n    return initialized;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/role/base/Operatorable.sol\n\n/**\n * @title Operatorable\n * @author Connor Howe <Connor.howe@sygnum.com>\n * @dev Operatorable contract stores the BaseOperators contract address, and modifiers for\n *       contracts.\n */\n\npragma solidity 0.5.12;\n\n\n\ncontract Operatorable is Initializable {\n    IBaseOperators internal operatorsInst;\n    address private operatorsPending;\n\n    event OperatorsContractChanged(address indexed caller, address indexed operatorsAddress);\n    event OperatorsContractPending(address indexed caller, address indexed operatorsAddress);\n\n    /**\n     * @dev Reverts if sender does not have operator role associated.\n     */\n    modifier onlyOperator() {\n        require(isOperator(msg.sender), \"Operatorable: caller does not have the operator role\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have admin role associated.\n     */\n    modifier onlyAdmin() {\n        require(isAdmin(msg.sender), \"Operatorable: caller does not have the admin role\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have system role associated.\n     */\n    modifier onlySystem() {\n        require(isSystem(msg.sender), \"Operatorable: caller does not have the system role\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have multisig privileges.\n     */\n    modifier onlyMultisig() {\n        require(isMultisig(msg.sender), \"Operatorable: caller does not have multisig role\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have admin or system role associated.\n     */\n    modifier onlyAdminOrSystem() {\n        require(isAdminOrSystem(msg.sender), \"Operatorable: caller does not have the admin role nor system\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have operator or system role associated.\n     */\n    modifier onlyOperatorOrSystem() {\n        require(isOperatorOrSystem(msg.sender), \"Operatorable: caller does not have the operator role nor system\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have the relay role associated.\n     */\n\tmodifier onlyRelay() {\n        require(isRelay(msg.sender), \"Operatorable: caller does not have relay role associated\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have relay or operator role associated.\n     */\n\tmodifier onlyOperatorOrRelay() {\n        require(isOperator(msg.sender) || isRelay(msg.sender), \"Operatorable: caller does not have the operator role nor relay\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have relay or admin role associated.\n     */\n\tmodifier onlyAdminOrRelay() {\n        require(isAdmin(msg.sender) || isRelay(msg.sender), \"Operatorable: caller does not have the admin role nor relay\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have the operator, or system, or relay role associated.\n     */\n\tmodifier onlyOperatorOrSystemOrRelay() {\n        require(isOperator(msg.sender) || isSystem(msg.sender) || isRelay(msg.sender), \"Operatorable: caller does not have the operator role nor system nor relay\");\n        _;\n    }\n\n    /**\n     * @dev Initialization instead of constructor, called once. The setOperatorsContract function can be called only by Admin role with\n     *       confirmation through the operators contract.\n     * @param _baseOperators BaseOperators contract address.\n     */\n    function initialize(address _baseOperators) public initializer {\n        _setOperatorsContract(_baseOperators);\n    }\n\n    /**\n     * @dev Set the new the address of Operators contract, should be confirmed from operators contract by calling confirmFor(addr)\n     *       where addr is the address of current contract instance. This is done to prevent the case when the new contract address is\n     *       broken and control of the contract can be lost in such case\n     * @param _baseOperators BaseOperators contract address.\n     */\n    function setOperatorsContract(address _baseOperators) public onlyAdmin {\n        require(_baseOperators != address(0), \"Operatorable: address of new operators contract can not be zero\");\n        operatorsPending = _baseOperators;\n        emit OperatorsContractPending(msg.sender, _baseOperators);\n    }\n\n    /**\n     * @dev The function should be called from new operators contract by admin to ensure that operatorsPending address\n     *       is the real contract address.\n     */\n    function confirmOperatorsContract() public {\n        require(operatorsPending != address(0), \"Operatorable: address of new operators contract can not be zero\");\n        require(msg.sender == operatorsPending, \"Operatorable: should be called from new operators contract\");\n        _setOperatorsContract(operatorsPending);\n    }\n\n    /**\n     * @return The address of the BaseOperators contract.\n     */\n    function getOperatorsContract() public view returns(address) {\n        return address(operatorsInst);\n    }\n\n    /**\n     * @return The pending address of the BaseOperators contract.\n     */\n    function getOperatorsPending() public view returns(address) {\n        return operatorsPending;\n    }\n\n    /**\n     * @return If '_account' has operator privileges.\n     */\n    function isOperator(address _account) public view returns (bool) {\n        return operatorsInst.isOperator(_account);\n    }\n\n    /**\n     * @return If '_account' has admin privileges.\n     */\n    function isAdmin(address _account) public view returns (bool) {\n        return operatorsInst.isAdmin(_account);\n    }\n\n    /**\n     * @return If '_account' has system privileges.\n     */\n    function isSystem(address _account) public view returns (bool) {\n        return operatorsInst.isSystem(_account);\n    }\n\n    /**\n     * @return If '_account' has relay privileges.\n     */\n    function isRelay(address _account) public view returns (bool) {\n        return operatorsInst.isRelay(_account);\n    }\n\n    /**\n     * @return If '_contract' has multisig privileges.\n     */\n    function isMultisig(address _contract) public view returns (bool) {\n        return operatorsInst.isMultisig(_contract);\n    }\n\n    /**\n     * @return If '_account' has admin or system privileges.\n     */\n    function isAdminOrSystem(address _account) public view returns (bool) {\n        return (operatorsInst.isAdmin(_account) || operatorsInst.isSystem(_account));\n    }\n\n    /**\n     * @return If '_account' has operator or system privileges.\n     */\n    function isOperatorOrSystem(address _account) public view returns (bool) {\n        return (operatorsInst.isOperator(_account) || operatorsInst.isSystem(_account));\n    }\n\n    /** INTERNAL FUNCTIONS */\n    function _setOperatorsContract(address _baseOperators) internal {\n        require(_baseOperators != address(0), \"Operatorable: address of new operators contract cannot be zero\");\n        operatorsInst = IBaseOperators(_baseOperators);\n        emit OperatorsContractChanged(msg.sender, _baseOperators);\n    }\n}\n\n// File: contracts/role/interface/IBlockerOperators.sol\n\n/**\n * @title IBlockerOperators\n * @notice Interface for BlockerOperators contract\n */\n\npragma solidity 0.5.12;\n\n\ncontract IBlockerOperators {\n    function isBlocker(address _account) external view returns (bool);\n    function addBlocker(address _account) external;\n    function removeBlocker(address _account) external;\n}\n\n// File: contracts/role/blocker/BlockerOperatorable.sol\n\n/**\n * @title BlockerOperatorable\n * @author Connor Howe <Connor.howe@sygnum.com>\n * @dev BlockerOperatorable contract stores BlockerOperators contract address, and modifiers for\n *      contracts.\n */\n\npragma solidity 0.5.12;\n\n\n\n\n\ncontract BlockerOperatorable is Operatorable {\n    IBlockerOperators internal blockerOperatorsInst;\n    address private blockerOperatorsPending;\n\n    event BlockerOperatorsContractChanged(address indexed caller, address indexed blockerOperatorAddress);\n    event BlockerOperatorsContractPending(address indexed caller, address indexed blockerOperatorAddress);\n\n    /**\n     * @dev Reverts if sender does not have the blocker role associated.\n     */\n\tmodifier onlyBlocker() {\n        require(isBlocker(msg.sender), \"BlockerOperatorable: caller is not blocker role\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have the blocker or operator role associated.\n     */\n\tmodifier onlyBlockerOrOperator() {\n        require(isBlocker(msg.sender) || isOperator(msg.sender), \"BlockerOperatorable: caller is not blocker or operator role\");\n        _;\n    }\n\n    /**\n     * @dev Initialization instead of constructor, called once. The setBlockerOperatorsContract function can be called only by Admin role with\n     * confirmation through the operators contract.\n     * @param _baseOperators BaseOperators contract address.\n     * @param _blockerOperators BlockerOperators contract address.\n     */\n    function initialize(address _baseOperators, address _blockerOperators) public initializer {\n        super.initialize(_baseOperators);\n        _setBlockerOperatorsContract(_blockerOperators);\n    }\n\n    /**\n     * @dev Set the new the address of BlockerOperators contract, should be confirmed from BlockerOperators contract by calling confirmFor(addr)\n     * where addr is the address of current contract instance. This is done to prevent the case when the new contract address is\n     * broken and control of the contract can be lost in such case.\n     * @param _blockerOperators BlockerOperators contract address.\n     */\n    function setBlockerOperatorsContract(address _blockerOperators) public onlyAdmin {\n        require(_blockerOperators != address(0), \"BlockerOperatorable: address of new blockerOperators contract can not be zero.\");\n        blockerOperatorsPending = _blockerOperators;\n        emit BlockerOperatorsContractPending(msg.sender, _blockerOperators);\n    }\n\n    /**\n     * @dev The function should be called from new BlockerOperators contract by admin to insure that blockerOperatorsPending address\n     *       is the real contract address.\n     */\n    function confirmBlockerOperatorsContract() public {\n        require(blockerOperatorsPending != address(0), \"BlockerOperatorable: address of pending blockerOperators contract can not be zero\");\n        require(msg.sender == blockerOperatorsPending, \"BlockerOperatorable: should be called from new blockerOperators contract\");\n        _setBlockerOperatorsContract(blockerOperatorsPending);\n    }\n\n    /**\n     * @return The address of the BlockerOperators contract.\n     */\n    function getBlockerOperatorsContract() public view returns(address) {\n        return address(blockerOperatorsInst);\n    }\n\n    /**\n     * @return The pending BlockerOperators contract address\n     */\n    function getBlockerOperatorsPending() public view returns(address) {\n        return blockerOperatorsPending;\n    }\n\n    /**\n     * @return If '_account' has blocker privileges.\n     */\n    function isBlocker(address _account) public view returns (bool) {\n        return blockerOperatorsInst.isBlocker(_account);\n    }\n\n    /** INTERNAL FUNCTIONS */\n    function _setBlockerOperatorsContract(address _blockerOperators) internal {\n        require(_blockerOperators != address(0), \"BlockerOperatorable: address of new blockerOperators contract can not be zero\");\n        blockerOperatorsInst = IBlockerOperators(_blockerOperators);\n        emit BlockerOperatorsContractChanged(msg.sender, _blockerOperators);\n    }\n}\n\n// File: contracts/role/blocker/BlockerOperators.sol\n\n/**\n * @title BlockOperators\n * @author Connor Howe <Connor.howe@sygnum.com>\n * @dev For managing account privileges associated to blocking of DCHF and equity tokens: blockers.\n */\n\npragma solidity 0.5.12;\n\n\n\n\ncontract BlockerOperators is Operatorable {\n    using Roles for Roles.Role;\n\n    Roles.Role private _blockers;\n\n    event BlockerAdded(address indexed caller, address indexed account);\n    event BlockerRemoved(address indexed caller, address indexed account);\n\n     /**\n     * @dev Confirms BlockerOperator contract address once acive.\n     * @param _address Address of BlockerOperator contract.\n     */\n    function confirmFor(address _address) public onlyAdmin {\n        BlockerOperatorable(_address).confirmBlockerOperatorsContract();\n    }\n\n    /* --------------- BLOCKER --------------- */\n    /**\n     * @return If '_account' has blocker privileges.\n     */\n    function isBlocker(address _account) public view returns (bool) {\n        return _blockers.has(_account);\n    }\n\n    /**\n     * @dev Operator or relay can give '_account' address blocker privileges.\n     * @param _account address that should be given blocker privileges.\n     */\n    function addBlocker(address _account) public onlyOperatorOrRelay {\n        _addBlocker(_account);\n    }\n\n    /**\n     * @dev Operator or relay can revoke '_account' address blocker privileges.\n     * @param _account address that should be revoked blocker privileges.\n     */\n    function removeBlocker(address _account) public onlyOperatorOrRelay {\n        _removeBlocker(_account);\n    }\n\n    /* --------------- INTERNAL --------------- */\n    function _addBlocker(address _account) internal {\n        _blockers.add(_account);\n        emit BlockerAdded(msg.sender, _account);\n    }\n\n    function _removeBlocker(address _account) internal {\n        _blockers.remove(_account);\n        emit BlockerRemoved(msg.sender, _account);\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BlockerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BlockerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operatorsAddress\",\"type\":\"address\"}],\"name\":\"OperatorsContractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operatorsAddress\",\"type\":\"address\"}],\"name\":\"OperatorsContractPending\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addBlocker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"confirmFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOperatorsContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperatorsContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperatorsPending\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseOperators\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isAdminOrSystem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isBlocker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"isMultisig\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOperatorOrSystem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isRelay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isSystem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeBlocker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseOperators\",\"type\":\"address\"}],\"name\":\"setOperatorsContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BlockerOperators","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}