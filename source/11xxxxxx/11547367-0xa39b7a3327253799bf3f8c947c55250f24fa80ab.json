{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/legendarypanda/Desktop/Swan-Finance/swan_smart_contracts/merged/SwanStake.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\n\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n\\n    constructor(address _owner) public {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n}\\n\\ncontract Pausable is Owned {\\n    uint private lastPauseTime;\\n    bool private paused;\\n\\n    event Pause(bool isPaused);\\n    event Unpause(bool isPaused);\\n\\n    constructor() internal {\\n    require(owner != address(0), \\\"Owner must be set\\\");\\n  }\\n\\n    modifier whenNotPaused() {\\n      require(!paused,\\\"Contract is Paused\\\");\\n      _;\\n    }\\n\\n    modifier whenPaused() {\\n      require(paused,\\\"Contract is Not Paused\\\");\\n      _;\\n    }\\n\\n    function isPaused() public view returns(bool) {\\n        return paused;\\n    }\\n\\n    function getLastPauseTime () public view returns(uint256){\\n    \\treturn lastPauseTime;\\t\\n    }\\n    \\n    function pause() onlyOwner whenNotPaused external {\\n      paused = true;\\n      lastPauseTime = now;\\n      emit Pause(paused);\\n    }\\n\\n    function unpause() onlyOwner whenPaused external {\\n      paused = false;\\n      emit Unpause(paused);\\n    }\\n}\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\ninterface ERC20 {\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function allowance(address, address) external view returns (uint256);\\n\\n    function transfer(address, uint256) external returns (bool);\\n}\\n\\n///@title Swan Staking Contract\\ncontract SwanStake is Pausable {\\n    using SafeMath for uint256;\\n    address public swanTokenAddress;\\n    uint256 public currentPrice;\\n\\n    constructor(address swanToken,address _owner) public Owned(_owner) {\\n        require(\\n            swanToken != address(0),\\n            \\\"Token Address cannot be a Zero Address\\\"\\n        );\\n        swanTokenAddress = swanToken;\\n        currentPrice = 1000;\\n    }\\n\\n    // @notice Stores STAKE ACCOUNT details of the USER\\n    struct StakeAccount {\\n        uint256 stakedAmount;\\n        uint256 time;\\n        uint256 interestRate;\\n        bool unstaked;\\n    }\\n    // @notice Stores INTEREST ACCOUNT details of the USER\\n    struct InterestAccount {\\n        uint256 amount;\\n        uint256 time;\\n        uint256 interestRate;\\n        uint256 interestPayouts;\\n        uint256 timeperiod;\\n        uint256 proposalId;\\n        bool withdrawn;\\n    }\\n\\n    mapping(address => bool) public isStaker;\\n    mapping(address => uint256) public userTotalStakes;\\n    mapping(address => uint256) public interestAccountNumber;\\n    mapping(address => StakeAccount) public stakeAccountDetails;\\n    mapping(address => mapping(uint256 => uint256)) public lastPayoutCall;\\n    mapping(address => mapping(uint256 => uint256)) public totalPoolRewards;\\n    mapping(address => mapping(uint256 => bool)) public checkCycle;\\n    mapping(address => mapping(uint256 => InterestAccount))\\n        public interestAccountDetails;\\n\\n    //  @dev emitted whenever user stakes tokens in the Stake Account\\n    event staked(\\n        address indexed _user,\\n        uint256 _amount,\\n        uint256 _lockupPeriod,\\n        uint256 _interest\\n    );\\n    // @dev emitted whenever user stakes tokens in the Stake Account\\n    event ClaimedStakedTokens(address indexed _user, uint256 _amount);\\n    // @dev emitted whenever user stakes tokens for One month LockUp period\\n    event OneMonthStaked(\\n        uint256 _proposalId,\\n        address indexed _user,\\n        uint256 _amount,\\n        uint256 _lockupPeriod,\\n        uint256 _interest\\n    );\\n    // @dev emitted whenever user stakes tokens for Three month LockUp period\\n    event ThreeMonthStaked(\\n        uint256 _proposalId,\\n        address indexed _user,\\n        uint256 _amount,\\n        uint256 _lockupPeriod,\\n        uint256 _interest\\n    );\\n    // @dev emitted whenever user's staked tokens are successfully unstaked and trasnferred back to the user\\n    event ClaimedInterestTokens(address indexed _user, uint256 _amount);\\n    // @dev emitted whenever weekly token rewards are transferred to the user.\\n    event TokenRewardTransferred(address indexed _user, uint256 _amount);\\n    // @dev returns the current tokenBalance of the Stake Contract\\n    function totalStakedTokens() external view returns (uint256) {\\n        return ERC20(swanTokenAddress).balanceOf(address(this));\\n    }\\n\\n    function setPrice(uint256 price) external onlyOwner {\\n        require(price > 0, \\\"Price Cannot be ZERO\\\");\\n        currentPrice = price;\\n    }\\n\\n    /**\\n     * @param _amount - the amount user wants to stake\\n     * @dev allows the user to stake the initial $2000 worth of SWAN tokens\\n     *      Lists the user as a valid Staker.(by adding True in the isStaker mapping)\\n     *      User can earn comparatively more interest on Future stakes by calling this function\\n     **/\\n    function stake(uint256 _amount) external whenNotPaused returns (bool) {\\n        require(\\n            !isStaker[msg.sender],\\n            \\\"Previous Staked Amount is not Withdrawn yet\\\"\\n        );\\n        require(\\n            _amount >= currentPrice.mul(2000),\\n            \\\"Staking Amount is Less Than $2000\\\"\\n        );\\n\\t\\trequire(\\n            ERC20(swanTokenAddress).transferFrom(\\n                msg.sender,\\n                address(this),\\n                _amount\\n            ),\\n            \\\"Token Transfer Failed\\\"\\n        );\\n\\n        stakeAccountDetails[msg.sender] = StakeAccount({\\n            stakedAmount: _amount,\\n            time: now,\\n            interestRate: 14,\\n            unstaked: false\\n        });\\n        isStaker[msg.sender] = true;\\n        userTotalStakes[msg.sender] = userTotalStakes[msg.sender].add(_amount);\\n        emit staked(msg.sender, _amount, 4, 14);\\n        return true;\\n    }\\n\\n    /**\\n     *  @notice Assigns the interestRates to users investments based on their time Duration and Stake Criteria\\n     *  @param  amount-  The amount user wishes to Stake\\n     *  @param  duration-   The lockUp duration\\n     *  @return true or false based on the function execution\\n     */\\n\\n    function earnInterest(uint256 amount, uint256 duration)\\n        external\\n        whenNotPaused\\n        returns (bool)\\n    {\\n        require(amount > 0, \\\"Amount can not be equal to ZERO\\\");\\n        require(duration > 0, \\\"Duration can not be Zero\\\");\\n        require(\\n            ERC20(swanTokenAddress).transferFrom(\\n                msg.sender,\\n                address(this),\\n                amount\\n            ),\\n            \\\"transfer From failed\\\"\\n        );\\n\\n        uint256 oneMonthNum = interestAccountNumber[msg.sender].add(1);\\n        if (isStaker[msg.sender]) {\\n            if (duration == 3) {\\n                interestAccountDetails[msg.sender][\\n                    oneMonthNum\\n                ] = InterestAccount({\\n                    amount: amount,\\n                    time: now,\\n                    interestRate: 20,\\n                    interestPayouts: 0,\\n                    timeperiod: duration,\\n                    proposalId: oneMonthNum,\\n                    withdrawn: false\\n                });\\n                emit ThreeMonthStaked(\\n                    oneMonthNum,\\n                    msg.sender,\\n                    amount,\\n                    duration,\\n                    20\\n                );\\n            } else if (duration == 1) {\\n                interestAccountDetails[msg.sender][\\n                    oneMonthNum\\n                ] = InterestAccount({\\n                    amount: amount,\\n                    time: now,\\n                    interestRate: 16,\\n                    interestPayouts: 0,\\n                    timeperiod: duration,\\n                    proposalId: oneMonthNum,\\n                    withdrawn: false\\n                });\\n                emit OneMonthStaked(\\n                    oneMonthNum,\\n                    msg.sender,\\n                    amount,\\n                    duration,\\n                    16\\n                );\\n            }\\n        } else {\\n            if (duration == 3) {\\n                interestAccountDetails[msg.sender][\\n                    oneMonthNum\\n                ] = InterestAccount({\\n                    amount: amount,\\n                    time: now,\\n                    interestRate: 16,\\n                    interestPayouts: 0,\\n                    timeperiod: duration,\\n                    proposalId: oneMonthNum,\\n                    withdrawn: false\\n                });\\n                emit ThreeMonthStaked(\\n                    oneMonthNum,\\n                    msg.sender,\\n                    amount,\\n                    duration,\\n                    16\\n                );\\n            } else if (duration == 1) {\\n                interestAccountDetails[msg.sender][\\n                    oneMonthNum\\n                ] = InterestAccount({\\n                    amount: amount,\\n                    time: now,\\n                    interestRate: 12,\\n                    interestPayouts: 0,\\n                    timeperiod: duration,\\n                    proposalId: oneMonthNum,\\n                    withdrawn: false\\n                });\\n                emit OneMonthStaked(\\n                    oneMonthNum,\\n                    msg.sender,\\n                    amount,\\n                    duration,\\n                    12\\n                );\\n            }\\n        }\\n        userTotalStakes[msg.sender] = userTotalStakes[msg.sender].add(amount);\\n        interestAccountNumber[msg.sender] = interestAccountNumber[msg.sender]\\n            .add(1);\\n        return true;\\n    }\\n\\n    /**\\n     *  @param id - the interestAccount id\\n     *  @dev  allows users to claim their invested tokens for 1 or 3 months from same function\\n     *        calculates the remaining interest to be transferred to the user\\n     *        transfers the invested amount as well as the remaining interest to the user.\\n     *        updates the user's staked balance to ZERO\\n     */\\n    function claimInterestTokens(uint256 id) external{\\n        InterestAccount memory interestData =\\n            interestAccountDetails[msg.sender][id];\\n        require(\\n            now >= interestData.time.add(interestData.timeperiod.mul(2629746)),\\n            \\\"LockUp Period NOT OVER Yet\\\"\\n        ); // 2,629,746 seconds = 1 month\\n        require(interestData.amount > 0, \\\"Invested Amount is ZERO\\\");\\n\\n        uint256 interestAmount =\\n            interestData.amount.mul(interestData.interestRate).div(100);\\n        uint256 remainingInterest =\\n            interestAmount.sub(totalPoolRewards[msg.sender][id]);\\n        uint256 tokensToSend = interestData.amount.add(remainingInterest);\\n\\n        userTotalStakes[msg.sender] = userTotalStakes[msg.sender].sub(interestData.amount);\\n        interestData.withdrawn = true;\\n        interestData.amount = 0;\\n        interestAccountDetails[msg.sender][id] = interestData;\\n        require(\\n            ERC20(swanTokenAddress).transfer(msg.sender, tokensToSend),\\n            \\\"Token Transfer Failed\\\"\\n        );\\n        emit ClaimedInterestTokens(msg.sender, tokensToSend);\\n    }\\n\\n    /**\\n     *  @dev  allows users to claim their staked tokens for 4 months\\n     *        calculates the total interest to be transferred to the user after 4 months\\n     *        transfers the staked amount as well as the remaining interest to the user.\\n     *        marks the user as NON STAKER.\\n     */\\n    function claimStakeTokens() external {\\n        require(isStaker[msg.sender], \\\"User is not a Staker\\\");\\n\\n        StakeAccount memory stakeData = stakeAccountDetails[msg.sender];\\n        require(\\n            now >= stakeData.time.add(10518984),\\n            \\\"LockUp Period NOT OVER Yet\\\"\\n        ); // 10,518,984 seconds = 4 months\\n        uint256 interestAmount = stakeData.stakedAmount.mul(14).div(100);\\n        uint256 tokensToSend = stakeData.stakedAmount.add(interestAmount);\\n        userTotalStakes[msg.sender] = userTotalStakes[msg.sender].sub(stakeData.stakedAmount);\\n        isStaker[msg.sender] = false;\\n        stakeData.unstaked = true;\\n        stakeAccountDetails[msg.sender] = stakeData;\\n        require(\\n            ERC20(swanTokenAddress).transfer(msg.sender, tokensToSend),\\n            \\\"Token Transfer Failed\\\"\\n        );\\n        emit ClaimedStakedTokens(msg.sender, tokensToSend);\\n    }\\n\\n    /**\\n     *  @param id - the interestAccount id\\n     *  @dev  allows users to claim their weekly interests\\n     *        updates the totalRewards earned by the user on a particular investment\\n     *        Total interest is divided into the number of weeks during the lockUpPeriod\\n     *        The remaining weekly interests(if any) will be withdrawn at the time of claiming the particular interestAccount.\\n     *\\n     */\\n    function payOuts(uint256 id) external returns (bool) {\\n        InterestAccount memory interestData =\\n            interestAccountDetails[msg.sender][id];\\n        require(\\n            now <= interestData.time.add(interestData.timeperiod.mul(2629746)),\\n            \\\"Reward Timeline is Over\\\"\\n        ); // 2,629,746 seconds = 1 month\\n        require(!interestData.withdrawn, \\\"Amount Has already Been Withdrawn\\\");\\n\\n        uint256 weeklyCycle = _getCycle(msg.sender, id);\\n        require(weeklyCycle > 0, \\\"Cycle is not complete\\\");\\n\\n        uint256 interestAmount =\\n            interestData.amount.mul(interestData.interestRate).div(100);\\n        uint256 interestForOneWeek =\\n            interestAmount.div(interestData.timeperiod.mul(4));\\n\\n        if (\\n            interestData.interestPayouts <=\\n            interestForOneWeek.mul(weeklyCycle)\\n        ) {\\n            uint256 tokenToSend =\\n                interestForOneWeek.mul(weeklyCycle).sub(\\n                    interestData.interestPayouts\\n                );\\n            require(\\n                tokenToSend.add(totalPoolRewards[msg.sender][id]) <=\\n                    interestAmount,\\n                \\\"Total Interest Paid Out or Week Cycle Exceeded\\\"\\n            );\\n            interestData.interestPayouts = interestForOneWeek.mul(\\n                weeklyCycle\\n            );\\n\\n            totalPoolRewards[msg.sender][id] = totalPoolRewards[msg.sender][id].add(tokenToSend);\\n            require(\\n                ERC20(swanTokenAddress).transfer(msg.sender, tokenToSend),\\n                \\\"Token Transfer Failed\\\"\\n            );\\n            emit TokenRewardTransferred(msg.sender, tokenToSend);\\n            return true;\\n        }\\n    }\\n    /**\\n     *  @notice returns the cycle for weekly payouts\\n     *  @param userAddress,id - takes caller's address and interstAccount\\n     *  @dev  calculates the number of week cycles passed\\n     */\\n    function _getCycle(address userAddress, uint256 id)\\n        internal\\n        returns (uint256)\\n    {\\n        InterestAccount memory interestData =\\n            interestAccountDetails[userAddress][id];\\n        require(interestData.amount > 0, \\\"Amount Withdrawn Already\\\");\\n        uint256 cycle;\\n        if (checkCycle[userAddress][id]) {\\n            cycle = now.sub(lastPayoutCall[userAddress][id]);\\n        } else {\\n            cycle = now.sub(interestData.time);\\n            checkCycle[userAddress][id] = true;\\n        }\\n        if (cycle <= 604800) //604800 = 7 days\\n        {\\n            return 0;\\n        } else if (cycle > 604800) \\n        {\\n            require(\\n                now.sub(lastPayoutCall[userAddress][id]) >= 604800,\\n                \\\"Cannot Call Before 7 days\\\"\\n            );\\n            uint256 secondsToHours = cycle.div(604800); \\n            lastPayoutCall[userAddress][id] = now;\\n            return secondsToHours;\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedInterestTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedStakedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lockupPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_interest\",\"type\":\"uint256\"}],\"name\":\"OneMonthStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lockupPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_interest\",\"type\":\"uint256\"}],\"name\":\"ThreeMonthStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenRewardTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lockupPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_interest\",\"type\":\"uint256\"}],\"name\":\"staked\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"checkCycle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"claimInterestTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimStakeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"earnInterest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastPauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"interestAccountDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestPayouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeperiod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"interestAccountNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isStaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastPayoutCall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"payOuts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeAccountDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swanTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalPoolRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SwanStake","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000adcc610f96c386d78f68b7f0a04e3a7c8ff94ff8000000000000000000000000b3e276a62b2b0ce4c12d66dc1615e46ce2e9494a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}