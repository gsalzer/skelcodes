{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: MIT\\r\\n*\\r\\n* Copyright (c) 2016-2019 zOS Global Limited\\r\\n*\\r\\n*/\\r\\npragma solidity \\u003e=0.7;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see `ERC20Detailed`.\\r\\n */\\r\\n\\r\\ninterface IERC20 {\\r\\n\\r\\n    // Optional functions\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when `approve` or `transferFrom` are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to `approve`. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"IUniswapV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Copied from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol\\r\\npragma solidity \\u003e=0.7;\\r\\n\\r\\ninterface IUniswapV2 {\\r\\n\\r\\n        function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n                external payable returns (uint[] memory amounts);\\r\\n\\r\\n        function getAmountsIn(uint amountOut, address[] memory path)\\r\\n                external view returns (uint[] memory amounts);\\r\\n\\r\\n        function getAmountsOut(uint amountIn, address[] memory path)\\r\\n                external view returns (uint[] memory amounts);\\r\\n        \\r\\n        function WETH() external pure returns (address);\\r\\n}\"},\"MarketMaker.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\r\\n*\\r\\n* MIT License with Automated License Fee Payments\\r\\n*\\r\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\r\\n*\\r\\n* Permission is hereby granted to any person obtaining a copy of this software\\r\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\r\\n* without restriction, including without limitation the rights to use, copy,\\r\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\r\\n* Software, and to permit persons to whom the Software is furnished to do so,\\r\\n* subject to the following conditions:\\r\\n*\\r\\n* - The above copyright notice and this permission notice shall be included in\\r\\n*   all copies or substantial portions of the Software.\\r\\n* - All automated license fee payments integrated into this and related Software\\r\\n*   are preserved.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n* SOFTWARE.\\r\\n*/\\r\\npragma solidity \\u003e=0.7;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IUniswapV2.sol\\\";\\r\\n\\r\\ncontract MarketMaker is Ownable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public base;  // ERC-20 currency\\r\\n    address public token; // ERC-20 share token\\r\\n\\r\\n    address public copyright;\\r\\n    uint8 public licenseFeeBps; // only charged on sales, max 1% i.e. 100\\r\\n\\r\\n    uint256 private price; // current offer price, without drift\\r\\n    uint256 public increment; // increment\\r\\n\\r\\n    uint256 public driftStart;\\r\\n    uint256 public timeToDrift; // seconds until drift pushes price by one drift increment\\r\\n    int256 public driftIncrement;\\r\\n\\r\\n    bool public buyingEnabled = true;\\r\\n    bool public sellingEnabled = true;\\r\\n\\r\\n    IUniswapV2 constant uniswap = IUniswapV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n    address public weth;\\r\\n\\r\\n    event Trade(address indexed token, address who, bytes ref, int amount, address base, uint totPrice, uint fee, uint newprice);\\r\\n\\r\\n    function initialize(address baseCurrency, address shareToken) public {\\r\\n        require(token == address(0), \\\"Already initialized.\\\");\\r\\n        base = baseCurrency;\\r\\n        token = shareToken;\\r\\n        weth = uniswap.WETH();\\r\\n        copyright = 0x29Fe8914e76da5cE2d90De98a64d0055f199d06D; // Aktionariat AG\\r\\n        driftStart = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function setPrice(uint256 newPrice, uint256 newIncrement) public onlyOwner {\\r\\n        anchorPrice(newPrice);\\r\\n        increment = newIncrement;\\r\\n    }\\r\\n\\r\\n    function hasDrift() public view returns (bool) {\\r\\n        return timeToDrift != 0;\\r\\n    }\\r\\n\\r\\n    // secondsPerStep should be negative for downwards drift\\r\\n    function setDrift(uint256 secondsPerStep, int256 newDriftIncrement) public onlyOwner {\\r\\n        anchorPrice(getPrice());\\r\\n        timeToDrift = secondsPerStep;\\r\\n        driftIncrement = newDriftIncrement;\\r\\n    }\\r\\n\\r\\n    function anchorPrice(uint256 currentPrice) private {\\r\\n        price = currentPrice;\\r\\n        driftStart = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function getPrice() public view returns (uint256) {\\r\\n        return getPriceAtTime(block.timestamp);\\r\\n    }\\r\\n\\r\\n    function getPriceAtTime(uint256 timestamp) public view returns (uint256) {\\r\\n        if (hasDrift()){\\r\\n            uint256 passed = timestamp - driftStart;\\r\\n            int256 drifted = int256(passed / timeToDrift) * driftIncrement;\\r\\n            int256 driftedPrice = int256(price) + drifted;\\r\\n            if (driftedPrice \\u003c 0){\\r\\n                return 0;\\r\\n            } else {\\r\\n                return uint256(driftedPrice);\\r\\n            }\\r\\n        } else {\\r\\n            return price;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPriceInEther(uint256 shares) public view returns (uint256) {\\r\\n        uint256 totPrice = getBuyPrice(shares);\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = weth;\\r\\n        path[1] = base;\\r\\n        return uniswap.getAmountsIn(totPrice, path)[0];\\r\\n    }\\r\\n\\r\\n    function buyWithEther(uint256 shares, bytes calldata ref) public payable returns (uint256) {\\r\\n        require(buyingEnabled);\\r\\n        uint256 totPrice = getBuyPrice(shares);\\r\\n        uint256 totPriceEth = getPriceInEther(shares);\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = weth;\\r\\n        path[1] = base;\\r\\n        uint256[] memory amounts = uniswap.swapETHForExactTokens{value: totPriceEth}(totPrice, path, address(this), block.timestamp);\\r\\n        assert(totPrice == amounts[1]);\\r\\n        _buy(msg.sender, msg.sender, shares, amounts[1], ref);\\r\\n        uint256 contractEtherBalance = address(this).balance;\\r\\n        if (contractEtherBalance \\u003e 0){\\r\\n            msg.sender.transfer(contractEtherBalance);\\r\\n        }\\r\\n        return amounts[0];\\r\\n    }\\r\\n\\r\\n    function buy(uint256 numberOfSharesToBuy, bytes calldata ref) public returns (uint256) {\\r\\n        require(buyingEnabled);\\r\\n        return buy(msg.sender, numberOfSharesToBuy, ref);\\r\\n    }\\r\\n\\r\\n    function buy(address recipient, uint256 numberOfSharesToBuy, bytes calldata ref) public returns (uint256) {\\r\\n        require(buyingEnabled);\\r\\n        return _buy(msg.sender, recipient, numberOfSharesToBuy, 0, ref);\\r\\n    }\\r\\n\\r\\n    function _buy(address paying, address recipient, uint256 shares, uint256 alreadyPaid, bytes calldata ref) internal returns (uint256) {\\r\\n        uint256 totPrice = getBuyPrice(shares);\\r\\n        IERC20 baseToken = IERC20(base);\\r\\n        if (totPrice \\u003e alreadyPaid){\\r\\n            require(baseToken.transferFrom(paying, address(this), totPrice - alreadyPaid));\\r\\n        } else if (totPrice \\u003c alreadyPaid){\\r\\n            // caller paid to much, return excess amount\\r\\n            require(baseToken.transfer(paying, alreadyPaid - totPrice));\\r\\n        }\\r\\n        IERC20 shareToken = IERC20(token);\\r\\n        require(shareToken.transfer(recipient, shares));\\r\\n        price = price.add(shares.mul(increment));\\r\\n        emit Trade(token, paying, ref, int256(shares), base, totPrice, 0, price);\\r\\n        return totPrice;\\r\\n    }\\r\\n\\r\\n    function _notifyMoneyReceived(address from, uint256 amount, bytes calldata ref) internal {\\r\\n        uint shares = getShares(amount);\\r\\n        _buy(from, from, shares, amount, ref);\\r\\n    }\\r\\n\\r\\n    function sell(uint256 tokens, bytes calldata ref) public returns (uint256){\\r\\n        require(sellingEnabled);\\r\\n        return sell(msg.sender, tokens, ref);\\r\\n    }\\r\\n\\r\\n    function sell(address recipient, uint256 tokens, bytes calldata ref) public returns (uint256){\\r\\n        require(sellingEnabled);\\r\\n        return _sell(msg.sender, recipient, tokens, ref);\\r\\n    }\\r\\n\\r\\n    function _sell(address seller, address recipient, uint256 shares, bytes calldata ref) internal returns (uint256) {\\r\\n        IERC20 shareToken = IERC20(token);\\r\\n        require(shareToken.transferFrom(seller, address(this), shares));\\r\\n        return _notifyTokensReceived(recipient, shares, ref);\\r\\n    }\\r\\n\\r\\n    // ERC-677 recipient\\r\\n    function onTokenTransfer(address from, uint256 amount, bytes calldata ref) public returns (bool success) {\\r\\n        require(msg.sender == token || msg.sender == base);\\r\\n        if (msg.sender == token){\\r\\n            require(sellingEnabled);\\r\\n            _notifyTokensReceived(from, amount, ref);\\r\\n        } else if (msg.sender == base){\\r\\n            require(buyingEnabled);\\r\\n            _notifyMoneyReceived(from, amount, ref);\\r\\n        } else {\\r\\n            require(false);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _notifyTokensReceived(address recipient, uint256 amount, bytes calldata ref) internal returns (uint256) {\\r\\n        uint256 totPrice = getSellPrice(amount);\\r\\n        IERC20 baseToken = IERC20(base);\\r\\n        uint256 fee = getSaleFee(totPrice);\\r\\n        if (fee \\u003e 0){\\r\\n            require(baseToken.transfer(copyright, fee));\\r\\n        }\\r\\n        require(baseToken.transfer(recipient, totPrice - fee));\\r\\n        price = price.sub(amount.mul(increment));\\r\\n        emit Trade(token, recipient, ref, -int256(amount), base, totPrice, fee, price);\\r\\n        return totPrice;\\r\\n    }\\r\\n\\r\\n    function getSaleFee(uint256 totalPrice) public view returns (uint256) {\\r\\n        return totalPrice.mul(licenseFeeBps).div(10000);\\r\\n    }\\r\\n\\r\\n    function getSaleProceeds(uint256 shares) public view returns (uint256) {\\r\\n        uint256 total = getSellPrice(shares);\\r\\n        return total - getSaleFee(total);\\r\\n    }\\r\\n\\r\\n    function getSellPrice(uint256 shares) public view returns (uint256) {\\r\\n        return getPrice(getPrice().sub(shares.mul(increment)), shares);\\r\\n    }\\r\\n\\r\\n    function getBuyPrice(uint256 shares) public view returns (uint256) {\\r\\n        return getPrice(getPrice(), shares);\\r\\n    }\\r\\n\\r\\n    function getPrice(uint256 lowest, uint256 shares) internal view returns (uint256){\\r\\n        if (shares == 0){\\r\\n            return 0;\\r\\n        } else {\\r\\n            uint256 highest = lowest + (shares - 1).mul(increment);\\r\\n            return (lowest.add(highest) / 2).mul(shares);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getShares(uint256 money) public view returns (uint256) {\\r\\n        uint256 currentPrice = getPrice();\\r\\n        uint256 min = 0;\\r\\n        uint256 max = money / currentPrice;\\r\\n        while (min + 1 \\u003c max){\\r\\n            uint256 middle = (min + max)/2;\\r\\n            uint256 totalPrice = getPrice(currentPrice, middle);\\r\\n            if (totalPrice \\u003e money){\\r\\n                max = middle;\\r\\n            } else {\\r\\n                min = middle;\\r\\n            }\\r\\n        }\\r\\n        return min;\\r\\n    }\\r\\n\\r\\n    function setCopyright(address newOwner) public {\\r\\n        require(msg.sender == copyright);\\r\\n        copyright = newOwner;\\r\\n    }\\r\\n\\r\\n    function setLicenseFee(uint8 bps) public {\\r\\n        require(msg.sender == copyright);\\r\\n        require(bps \\u003c= 100);\\r\\n        licenseFeeBps = bps;\\r\\n    }\\r\\n\\r\\n    function withdraw(address ercAddress, address to, uint256 amount) public onlyOwner() {\\r\\n        IERC20 erc20 = IERC20(ercAddress);\\r\\n        require(erc20.transfer(to, amount), \\\"Transfer failed\\\");\\r\\n    }\\r\\n\\r\\n    function setEnabled(bool newBuyingEnabled, bool newSellingEnabled) public onlyOwner() {\\r\\n        buyingEnabled = newBuyingEnabled;\\r\\n        sellingEnabled = newSellingEnabled;\\r\\n    }\\r\\n}\"},\"MarketMakerFactory.sol\":{\"content\":\"\\r\\n/**\\r\\n * SPDX-License-Identifier: MIT\\r\\n */\\r\\n\\r\\npragma solidity \\u003e=0.7;\\r\\n\\r\\nimport \\\"./MarketMaker.sol\\\";\\r\\n\\r\\ncontract MarketMakerFactory {\\r\\n\\r\\n  event ContractDeployed(address contractAddress);\\r\\n    \\r\\n  function create(bytes32 salt, address baseCurrency, address shareToken) public returns (address) {\\r\\n    MarketMaker marketMaker = new MarketMaker{salt: salt}();\\r\\n    marketMaker.initialize(baseCurrency, shareToken);\\r\\n    emit ContractDeployed(address(marketMaker));\\r\\n    marketMaker.transferOwnership(msg.sender);\\r\\n    return address(marketMaker);\\r\\n  }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n//\\r\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\r\\n//\\r\\n// Modifications:\\r\\n// - Replaced Context._msgSender() with msg.sender\\r\\n// - Added possibility to modify itself for multisig setup\\r\\n// - Made leaner\\r\\n\\r\\npragma solidity \\u003e=0.7;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable {\\r\\n\\r\\n    address public owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        emit OwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: MIT\\r\\n*\\r\\n* Copyright (c) 2016-2019 zOS Global Limited\\r\\n*/\\r\\npragma solidity \\u003e=0.7;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, throws on overflow.\\r\\n  */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n        // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        c = a * b;\\r\\n        assert(c / a == b);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers, truncating the quotient.\\r\\n  */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n        // uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        assert(b \\u003c= a);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, throws on overflow.\\r\\n  */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n        c = a + b;\\r\\n        assert(c \\u003e= a);\\r\\n        return c;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"baseCurrency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"shareToken\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MarketMakerFactory","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1909e9be776776de3e0a5eca57534b2096bc9c2892be0d08f2beaaf15bece37c"}]}