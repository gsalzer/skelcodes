{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/upgrades/GraphProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../governance/Governed.sol\\\";\\n\\nimport \\\"./IGraphProxy.sol\\\";\\nimport \\\"./GraphUpgradeable.sol\\\";\\n\\n/** \\n * @title GraphProxyAdmin\\n * @dev This is the owner of upgradeable proxy contracts.\\n * Proxy contracts use a TransparentProxy pattern, any admin related call\\n * like upgrading a contract or changing the admin needs to be send through\\n * this contract.\\n */\\ncontract GraphProxyAdmin is Governed {\\n\\n    /** \\n     * @dev Contract constructor.\\n     */\\n    constructor() {\\n        Governed._initialize(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation of a proxy.\\n     * This is needed because only the proxy admin can query it.\\n     * @return The address of the current implementation of the proxy.\\n     */\\n    function getProxyImplementation(IGraphProxy _proxy) public view returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(_proxy).staticcall(hex\\\"5c60da1b\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the pending implementation of a proxy.\\n     * This is needed because only the proxy admin can query it.\\n     * @return The address of the pending implementation of the proxy.\\n     */\\n    function getProxyPendingImplementation(IGraphProxy _proxy) public view returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"pendingImplementation()\\\")) == 0x396f7b23\\n        (bool success, bytes memory returndata) = address(_proxy).staticcall(hex\\\"396f7b23\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the admin of a proxy. Only the admin can query it.\\n     * @return The address of the current admin of the proxy.\\n     */\\n    function getProxyAdmin(IGraphProxy _proxy) public view returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(_proxy).staticcall(hex\\\"f851a440\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of a proxy.\\n     * @param _proxy Proxy to change admin.\\n     * @param _newAdmin Address to transfer proxy administration to.\\n     */\\n    function changeProxyAdmin(IGraphProxy _proxy, address _newAdmin) public onlyGovernor {\\n        _proxy.setAdmin(_newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades a proxy to the newest implementation of a contract.\\n     * @param _proxy Proxy to be upgraded.\\n     * @param _implementation the address of the Implementation.\\n     */\\n    function upgrade(IGraphProxy _proxy, address _implementation) public onlyGovernor {\\n        _proxy.upgradeTo(_implementation);\\n    }\\n\\n    /**\\n     * @dev Accepts a proxy.\\n     * @param _implementation Address of the implementation accepting the proxy.\\n     * @param _proxy Address of the proxy being accepted.\\n     */\\n    function acceptProxy(GraphUpgradeable _implementation, IGraphProxy _proxy) public onlyGovernor {\\n        _implementation.acceptProxy(_proxy);\\n    }\\n\\n    /**\\n     * @dev Accepts a proxy and call a function on the implementation.\\n     * @param _implementation Address of the implementation accepting the proxy.\\n     * @param _proxy Address of the proxy being accepted.\\n     * @param _data Encoded function to call on the implementation after accepting the proxy.\\n     */\\n    function acceptProxyAndCall(\\n        GraphUpgradeable _implementation,\\n        IGraphProxy _proxy,\\n        bytes calldata _data\\n    ) external onlyGovernor {\\n        _implementation.acceptProxyAndCall(_proxy, _data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Governed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\n/**\\n * @title Graph Governance contract\\n * @dev All contracts that will be owned by a Governor entity should extend this contract.\\n */\\ncontract Governed {\\n    // -- State --\\n\\n    address public governor;\\n    address public pendingGovernor;\\n\\n    // -- Events --\\n\\n    event NewPendingOwnership(address indexed from, address indexed to);\\n    event NewOwnership(address indexed from, address indexed to);\\n\\n    /**\\n     * @dev Check if the caller is the governor.\\n     */\\n    modifier onlyGovernor {\\n        require(msg.sender == governor, \\\"Only Governor can call\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize the governor to the contract caller.\\n     */\\n    function _initialize(address _initGovernor) internal {\\n        governor = _initGovernor;\\n    }\\n\\n    /**\\n     * @dev Admin function to begin change of governor. The `_newGovernor` must call\\n     * `acceptOwnership` to finalize the transfer.\\n     * @param _newGovernor Address of new `governor`\\n     */\\n    function transferOwnership(address _newGovernor) external onlyGovernor {\\n        require(_newGovernor != address(0), \\\"Governor must be set\\\");\\n\\n        address oldPendingGovernor = pendingGovernor;\\n        pendingGovernor = _newGovernor;\\n\\n        emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\\n    }\\n\\n    /**\\n     * @dev Admin function for pending governor to accept role and update governor.\\n     * This function must called by the pending governor.\\n     */\\n    function acceptOwnership() external {\\n        require(\\n            pendingGovernor != address(0) && msg.sender == pendingGovernor,\\n            \\\"Caller must be pending governor\\\"\\n        );\\n\\n        address oldGovernor = governor;\\n        address oldPendingGovernor = pendingGovernor;\\n\\n        governor = pendingGovernor;\\n        pendingGovernor = address(0);\\n\\n        emit NewOwnership(oldGovernor, governor);\\n        emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/IGraphProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ninterface IGraphProxy {\\n    function admin() external returns (address);\\n\\n    function setAdmin(address _newAdmin) external;\\n\\n    function implementation() external returns (address);\\n\\n    function pendingImplementation() external returns (address);\\n\\n    function upgradeTo(address _newImplementation) external;\\n\\n    function acceptUpgrade() external;\\n\\n    function acceptUpgradeAndCall(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/GraphUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IGraphProxy.sol\\\";\\n\\n/**\\n * @title Graph Upgradeable\\n * @dev This contract is intended to be inherited from upgradeable contracts.\\n */\\ncontract GraphUpgradeable {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32\\n        internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Check if the caller is the proxy admin.\\n     */\\n    modifier onlyProxyAdmin(IGraphProxy _proxy) {\\n        require(msg.sender == _proxy.admin(), \\\"Caller must be the proxy admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check if the caller is the implementation.\\n     */\\n    modifier onlyImpl {\\n        require(msg.sender == _implementation(), \\\"Caller must be the implementation\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     * @return impl Address of the current implementation\\n     */\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Accept to be an implementation of proxy.\\n     */\\n    function acceptProxy(IGraphProxy _proxy) external onlyProxyAdmin(_proxy) {\\n        _proxy.acceptUpgrade();\\n    }\\n\\n    /**\\n     * @dev Accept to be an implementation of proxy and then call a function from the new\\n     * implementation as specified by `_data`, which should be an encoded function call. This is\\n     * useful to initialize new storage variables in the proxied contract.\\n     */\\n    function acceptProxyAndCall(IGraphProxy _proxy, bytes calldata _data)\\n        external\\n        onlyProxyAdmin(_proxy)\\n    {\\n        _proxy.acceptUpgradeAndCall(_data);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"NewOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"NewPendingOwnership\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract GraphUpgradeable\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"acceptProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract GraphUpgradeable\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"acceptProxyAndCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeProxyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"getProxyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"getProxyPendingImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GraphProxyAdmin","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}