{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.7.0;    \r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\ncontract DSMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"\");\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint256 constant WAD = 10**18;\r\n    uint256 constant RAY = 10**27;\r\n\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}    \r\n\r\n\r\nabstract contract IFlashLoanParamsGetter {\r\n\tfunction getFlashLoanParams(bytes memory _data) public view virtual returns (address[] memory tokens, uint256[] memory amount, uint256[] memory modes);\r\n}    \r\n\r\n\r\n\r\nabstract contract ILendingPoolAddressesProvider {\r\n    function getLendingPool() public view virtual returns (address);\r\n\r\n    function setLendingPoolImpl(address _pool) public virtual;\r\n\r\n    function getLendingPoolCore() public view virtual returns (address payable);\r\n\r\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public virtual;\r\n\r\n    function getLendingPoolConfigurator() public view virtual returns (address);\r\n\r\n    function setLendingPoolConfiguratorImpl(address _configurator) public virtual;\r\n\r\n    function getLendingPoolDataProvider() public view virtual returns (address);\r\n\r\n    function setLendingPoolDataProviderImpl(address _provider) public virtual;\r\n\r\n    function getLendingPoolParametersProvider() public view virtual returns (address);\r\n\r\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public virtual;\r\n\r\n    function getTokenDistributor() public view virtual returns (address);\r\n\r\n    function setTokenDistributor(address _tokenDistributor) public virtual;\r\n\r\n    function getFeeProvider() public view virtual returns (address);\r\n\r\n    function setFeeProviderImpl(address _feeProvider) public virtual;\r\n\r\n    function getLendingPoolLiquidationManager() public view virtual returns (address);\r\n\r\n    function setLendingPoolLiquidationManager(address _manager) public virtual;\r\n\r\n    function getLendingPoolManager() public view virtual returns (address);\r\n\r\n    function setLendingPoolManager(address _lendingPoolManager) public virtual;\r\n\r\n    function getPriceOracle() public view virtual returns (address);\r\n\r\n    function setPriceOracle(address _priceOracle) public virtual;\r\n\r\n    function getLendingRateOracle() public view virtual returns (address);\r\n\r\n    function setLendingRateOracle(address _lendingRateOracle) public virtual;\r\n}\r\n\r\nlibrary EthAddressLib {\r\n    function ethAddress() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n}    \r\n\r\n\r\nabstract contract ILendingPool {\r\n    function flashLoan( address payable _receiver, address _reserve, uint _amount, bytes calldata _params) external virtual;\r\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external virtual payable;\r\n\tfunction setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external virtual;\r\n\tfunction borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external virtual;\r\n\tfunction repay( address _reserve, uint256 _amount, address payable _onBehalfOf) external virtual payable;\r\n\tfunction swapBorrowRateMode(address _reserve) external virtual;\r\n    function getReserves() external virtual view returns(address[] memory);\r\n\r\n    /// @param _reserve underlying token address\r\n    function getReserveData(address _reserve)\r\n        external virtual\r\n        view\r\n        returns (\r\n            uint256 totalLiquidity,               // reserve total liquidity\r\n            uint256 availableLiquidity,           // reserve available liquidity for borrowing\r\n            uint256 totalBorrowsStable,           // total amount of outstanding borrows at Stable rate\r\n            uint256 totalBorrowsVariable,         // total amount of outstanding borrows at Variable rate\r\n            uint256 liquidityRate,                // current deposit APY of the reserve for depositors, in Ray units.\r\n            uint256 variableBorrowRate,           // current variable rate APY of the reserve pool, in Ray units.\r\n            uint256 stableBorrowRate,             // current stable rate APY of the reserve pool, in Ray units.\r\n            uint256 averageStableBorrowRate,      // current average stable borrow rate\r\n            uint256 utilizationRate,              // expressed as total borrows/total liquidity.\r\n            uint256 liquidityIndex,               // cumulative liquidity index\r\n            uint256 variableBorrowIndex,          // cumulative variable borrow index\r\n            address aTokenAddress,                // aTokens contract address for the specific _reserve\r\n            uint40 lastUpdateTimestamp            // timestamp of the last update of reserve data\r\n        );\r\n\r\n    /// @param _user users address\r\n    function getUserAccountData(address _user)\r\n        external virtual\r\n        view\r\n        returns (\r\n            uint256 totalLiquidityETH,            // user aggregated deposits across all the reserves. In Wei\r\n            uint256 totalCollateralETH,           // user aggregated collateral across all the reserves. In Wei\r\n            uint256 totalBorrowsETH,              // user aggregated outstanding borrows across all the reserves. In Wei\r\n            uint256 totalFeesETH,                 // user aggregated current outstanding fees in ETH. In Wei\r\n            uint256 availableBorrowsETH,          // user available amount to borrow in ETH\r\n            uint256 currentLiquidationThreshold,  // user current average liquidation threshold across all the collaterals deposited\r\n            uint256 ltv,                          // user average Loan-to-Value between all the collaterals\r\n            uint256 healthFactor                  // user current Health Factor\r\n    );    \r\n\r\n    /// @param _reserve underlying token address\r\n    /// @param _user users address\r\n    function getUserReserveData(address _reserve, address _user)\r\n        external virtual\r\n        view\r\n        returns (\r\n            uint256 currentATokenBalance,         // user current reserve aToken balance\r\n            uint256 currentBorrowBalance,         // user current reserve outstanding borrow balance\r\n            uint256 principalBorrowBalance,       // user balance of borrowed asset\r\n            uint256 borrowRateMode,               // user borrow rate mode either Stable or Variable\r\n            uint256 borrowRate,                   // user current borrow rate APY\r\n            uint256 liquidityRate,                // user current earn rate on _reserve\r\n            uint256 originationFee,               // user outstanding loan origination fee\r\n            uint256 variableBorrowIndex,          // user variable cumulative index\r\n            uint256 lastUpdateTimestamp,          // Timestamp of the last data update\r\n            bool usageAsCollateralEnabled         // Whether the user's current reserve is enabled as a collateral\r\n    );\r\n\r\n    function getReserveConfigurationData(address _reserve)\r\n        external virtual\r\n        view\r\n        returns (\r\n            uint256 ltv,\r\n            uint256 liquidationThreshold,\r\n            uint256 liquidationBonus,\r\n            address rateStrategyAddress,\r\n            bool usageAsCollateralEnabled,\r\n            bool borrowingEnabled,\r\n            bool stableBorrowRateEnabled,\r\n            bool isActive\r\n    );\r\n\r\n    // ------------------ LendingPoolCoreData ------------------------\r\n    function getReserveATokenAddress(address _reserve) public virtual view returns (address);\r\n    function getReserveConfiguration(address _reserve)\r\n        external virtual\r\n        view\r\n        returns (uint256, uint256, uint256, bool);\r\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\r\n        public virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function getReserveCurrentLiquidityRate(address _reserve)\r\n        public virtual\r\n        view\r\n        returns (uint256);\r\n    function getReserveCurrentVariableBorrowRate(address _reserve)\r\n        public virtual\r\n        view\r\n        returns (uint256);\r\n    function getReserveCurrentStableBorrowRate(address _reserve) \r\n        public virtual\r\n        view\r\n        returns (uint256);\r\n    function getReserveTotalLiquidity(address _reserve)\r\n        public virtual\r\n        view\r\n        returns (uint256);\r\n    function getReserveAvailableLiquidity(address _reserve)\r\n        public virtual\r\n        view\r\n        returns (uint256);\r\n    function getReserveTotalBorrowsVariable(address _reserve)\r\n        public virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    // ---------------- LendingPoolDataProvider ---------------------\r\n    function calculateUserGlobalData(address _user)\r\n        public virtual\r\n        view\r\n        returns (\r\n            uint256 totalLiquidityBalanceETH,\r\n            uint256 totalCollateralBalanceETH,\r\n            uint256 totalBorrowBalanceETH,\r\n            uint256 totalFeesETH,\r\n            uint256 currentLtv,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 healthFactor,\r\n            bool healthFactorBelowThreshold\r\n        );\r\n}    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Getter contract for positions from Aave protocol\r\ncontract AaveV1FullPositionView is DSMath, IFlashLoanParamsGetter {\r\n\r\n    address public constant AAVE_V1_LENDING_POOL_ADDRESSES = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\r\n\r\n    struct UserBorrows {\r\n        address[] borrowAddr;\r\n        uint256[] borrowAmounts;\r\n        uint256[] borrowRateModes;\r\n    }\r\n\r\n    function getUserBorrows(address _user, address[] memory _borrTokens) public view returns (UserBorrows memory borrowsData) {\r\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_V1_LENDING_POOL_ADDRESSES).getLendingPool();\r\n\r\n        borrowsData = UserBorrows({\r\n            borrowAddr: new address[](_borrTokens.length),\r\n            borrowAmounts: new uint[](_borrTokens.length),\r\n            borrowRateModes: new uint[](_borrTokens.length)\r\n        });\r\n\r\n        uint64 borrowPos = 0;\r\n\r\n        for (uint64 i = 0; i < _borrTokens.length; i++) {\r\n            address reserve = _borrTokens[i];\r\n\r\n            (,uint256 borrowBalance,,uint256 borrowRateMode,,,,,,) = ILendingPool(lendingPoolAddress).getUserReserveData(reserve, _user);\r\n\r\n            // Sum up debt in Eth\r\n            if (borrowBalance > 0) {\r\n                borrowsData.borrowAddr[borrowPos] = reserve;\r\n                borrowsData.borrowAmounts[borrowPos] = borrowBalance;\r\n                borrowsData.borrowRateModes[borrowPos] = borrowRateMode;\r\n                borrowPos++;\r\n            }\r\n        }\r\n\r\n        return borrowsData;\r\n    }\r\n\r\n\r\n    function getFlashLoanParams(bytes memory _data) public view override returns (address[] memory tokens, uint256[] memory amount, uint256[] memory modes) {\r\n        (address account, address[] memory borrTokens) = abi.decode(_data, (address,address[]));\r\n\r\n        UserBorrows memory borrowsData = getUserBorrows(account, borrTokens);\r\n\r\n        return (borrowsData.borrowAddr, borrowsData.borrowAmounts, borrowsData.borrowRateModes);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"AAVE_V1_LENDING_POOL_ADDRESSES\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"getFlashLoanParams\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"modes\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_borrTokens\",\"type\":\"address[]\"}],\"name\":\"getUserBorrows\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"borrowAddr\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowRateModes\",\"type\":\"uint256[]\"}],\"internalType\":\"struct AaveV1FullPositionView.UserBorrows\",\"name\":\"borrowsData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AaveV1FullPositionView","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d2b9b324aaa1da325775ec48d5b3ecc064ca036fe5720a43afde262639550778"}]}