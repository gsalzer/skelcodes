{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IGraSwapBlackList {\r\n    // event OwnerChanged(address);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event AddedBlackLists(address[]);\r\n    event RemovedBlackLists(address[]);\r\n\r\n    function owner()external view returns (address);\r\n    // function newOwner()external view returns (address);\r\n    function isBlackListed(address)external view returns (bool);\r\n\r\n    // function changeOwner(address ownerToSet) external;\r\n    // function updateOwner() external;\r\n    function transferOwnership(address newOwner) external;\r\n    function addBlackLists(address[] calldata  accounts)external;\r\n    function removeBlackLists(address[] calldata  accounts)external;\r\n}\r\n\r\ninterface IGraWhiteList {\r\n    event AppendWhiter(address adder);\r\n    event RemoveWhiter(address remover);\r\n    \r\n    function appendWhiter(address account) external;\r\n    function removeWhiter(address account) external;\r\n    function isWhiter(address account) external;\r\n    function isNotWhiter(address account) external;\r\n}\r\n\r\ninterface IGraSwapToken is IERC20, IGraSwapBlackList, IGraWhiteList{\r\n    function burn(uint256 amount) external;\r\n    function burnFrom(address account, uint256 amount) external;\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    // function multiTransfer(uint256[] calldata mixedAddrVal) external returns (bool);\r\n    function batchTransfer(address[] memory addressList, uint256[] memory amountList) external returns (bool);\r\n}\r\n\r\ninterface IGraSwapFactory {\r\n    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\r\n\r\n    function createPair(address stock, address money, bool isOnlySwap) external returns (address pair);\r\n    function setFeeToAddresses(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setFeeBPS(uint32 bps) external;\r\n    function setPairLogic(address implLogic) external;\r\n\r\n    function allPairsLength() external view returns (uint);\r\n    function feeTo_1() external view returns (address);\r\n    function feeTo_2() external view returns (address);\r\n    function feeToPrivate() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function feeBPS() external view returns (uint32);\r\n    function pairLogic() external returns (address);\r\n    function getTokensFromPair(address pair) external view returns (address stock, address money);\r\n    function tokensToPair(address stock, address money, bool isOnlySwap) external view returns (address pair);\r\n}\r\n\r\ninterface IGraSwapRouter {\r\n    event AddLiquidity(uint stockAmount, uint moneyAmount, uint liquidity);\r\n    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    // liquidity\r\n    function addLiquidity(\r\n        address stock,\r\n        address money,\r\n        bool isOnlySwap,\r\n        uint amountStockDesired,\r\n        uint amountMoneyDesired,\r\n        uint amountStockMin,\r\n        uint amountMoneyMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountStock, uint amountMoney, uint liquidity);\r\n    function removeLiquidity(\r\n        address pair,\r\n        uint liquidity,\r\n        uint amountStockMin,\r\n        uint amountMoneyMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountStock, uint amountMoney);\r\n\r\n    // swap token\r\n    function swapToken(\r\n        address token,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    // limit order\r\n    function limitOrder(\r\n        bool isBuy,\r\n        address pair,\r\n        uint prevKey,\r\n        uint price,\r\n        uint32 id,\r\n        uint stockAmount,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\ninterface IGraSwapBuyback {\r\n    event BurnGras(uint256 burntAmt);\r\n\r\n    function graContract() external pure returns (address);\r\n    function router() external pure returns (address);\r\n    function factory() external pure returns (address);\r\n\r\n    function addMainToken(address token) external;\r\n    function removeMainToken(address token) external;\r\n    function isMainToken(address token) external view returns (bool);\r\n    function mainTokens() external view returns (address[] memory list);\r\n\r\n    function removeLiquidity(address[] calldata pairs) external;\r\n    function swapForMainToken(address[] calldata pairs) external;\r\n    function swapForGrasAndBurn(address[] calldata pairs) external;\r\n}\r\n\r\ncontract GraSwapBuyback is IGraSwapBuyback {\r\n\r\n    uint256 private constant _MAX_UINT256 = uint256(-1); \r\n    address private constant _ETH = address(0);\r\n\r\n    address public immutable override graContract;\r\n    address public immutable override router;\r\n    address public immutable override factory;\r\n\r\n    mapping (address => bool) private _mainTokens;\r\n    address[] private _mainTokenArr;\r\n\r\n    constructor(address _graContract, address _router, address _factory) public {\r\n        graContract = _graContract;\r\n        router = _router;\r\n        factory = _factory;\r\n\r\n        // add ETH & GraS to main token list\r\n        _mainTokens[_ETH] = true;\r\n        _mainTokenArr.push(_ETH);\r\n        _mainTokens[_graContract] = true;\r\n        _mainTokenArr.push(_graContract);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    // add token into main token list\r\n    function addMainToken(address token) external override {\r\n        require(msg.sender == IGraSwapToken(graContract).owner(), \"GraSwapBuyback: NOT_Gra_OWNER\");\r\n        if (!_mainTokens[token]) {\r\n            _mainTokens[token] = true;\r\n            _mainTokenArr.push(token);\r\n        }\r\n    }\r\n    // remove token from main token list\r\n    function removeMainToken(address token) external override {\r\n        require(msg.sender == IGraSwapToken(graContract).owner(), \"GraSwapBuyback: NOT_Gra_OWNER\");\r\n        require(token != _ETH, \"GraSwapBuyback: REMOVE_ETH_FROM_MAIN\");\r\n        require(token != graContract, \"GraSwapBuyback: REMOVE_Gra_FROM_MAIN\");\r\n        if (_mainTokens[token]) {\r\n            _mainTokens[token] = false;\r\n            uint256 lastIdx = _mainTokenArr.length - 1;\r\n            for (uint256 i = 2; i < lastIdx; i++) { // skip ETH & Gra\r\n                if (_mainTokenArr[i] == token) {\r\n                    _mainTokenArr[i] = _mainTokenArr[lastIdx];\r\n                    break;\r\n                }\r\n            }\r\n            _mainTokenArr.pop();\r\n        }\r\n    }\r\n    // check if token is in main token list\r\n    function isMainToken(address token) external view override returns (bool) {\r\n        return _mainTokens[token];\r\n    }\r\n    // query main token list\r\n    function mainTokens() external view override returns (address[] memory list) {\r\n        list = _mainTokenArr;\r\n    }\r\n\r\n    // remove Buyback's liquidity from all pairs\r\n    // swap got minor tokens for main tokens if possible\r\n    function removeLiquidity(address[] calldata pairs) external override {\r\n        for (uint256 i = 0; i < pairs.length; i++) {\r\n            _removeLiquidity(pairs[i]);\r\n        }\r\n    }\r\n    function _removeLiquidity(address pair) private {\r\n        (address a, address b) = IGraSwapFactory(factory).getTokensFromPair(pair);\r\n        require(a != address(0) || b != address(0), \"GraSwapBuyback: INVALID_PAIR\");\r\n\r\n        uint256 amt = IERC20(pair).balanceOf(address(this));\r\n        // require(amt > 0, \"GraSwapBuyback: NO_LIQUIDITY\");\r\n        if (amt == 0) { return; }\r\n\r\n        IERC20(pair).approve(router, 0);\r\n        IERC20(pair).approve(router, amt);\r\n        IGraSwapRouter(router).removeLiquidity(\r\n            pair, amt, 0, 0, address(this), _MAX_UINT256);\r\n\r\n        // minor -> main\r\n        bool aIsMain = _mainTokens[a];\r\n        bool bIsMain = _mainTokens[b];\r\n        if ((aIsMain && !bIsMain) || (!aIsMain && bIsMain)) {\r\n            _swapForMainToken(pair);\r\n        }\r\n    }\r\n\r\n    // swap minor tokens for main tokens\r\n    function swapForMainToken(address[] calldata pairs) external override {\r\n        for (uint256 i = 0; i < pairs.length; i++) {\r\n            _swapForMainToken(pairs[i]);\r\n        }\r\n    }\r\n    function _swapForMainToken(address pair) private {\r\n        (address a, address b) = IGraSwapFactory(factory).getTokensFromPair(pair);\r\n        require(a != address(0) || b != address(0), \"GraSwapBuyback: INVALID_PAIR\");\r\n\r\n        address mainToken;\r\n        address minorToken;\r\n        if (_mainTokens[a]) {\r\n            require(!_mainTokens[b], \"GraSwapBuyback: SWAP_TWO_MAIN_TOKENS\");\r\n            (mainToken, minorToken) = (a, b);\r\n        } else {\r\n            require(_mainTokens[b], \"GraSwapBuyback: SWAP_TWO_MINOR_TOKENS\");\r\n            (mainToken, minorToken) = (b, a);\r\n        }\r\n\r\n        uint256 minorTokenAmt = IERC20(minorToken).balanceOf(address(this));\r\n        // require(minorTokenAmt > 0, \"GraSwapBuyback: NO_MINOR_TOKENS\");\r\n        if (minorTokenAmt == 0) { return; }\r\n\r\n        address[] memory path = new address[](1);\r\n        path[0] = pair;\r\n\r\n        // minor -> main\r\n        IERC20(minorToken).approve(router, 0);\r\n        IERC20(minorToken).approve(router, minorTokenAmt);\r\n        IGraSwapRouter(router).swapToken(\r\n            minorToken, minorTokenAmt, 0, path, address(this), _MAX_UINT256);\r\n    }\r\n\r\n    // swap main tokens for Gras, then burn all Gras\r\n    function swapForGrasAndBurn(address[] calldata pairs) external override {\r\n        for (uint256 i = 0; i < pairs.length; i++) {\r\n            _swapForGras(pairs[i]);\r\n        }\r\n\r\n        // burn all Gras\r\n        uint256 allGras = IERC20(graContract).balanceOf(address(this));\r\n        if (allGras == 0) { return; }\r\n        IGraSwapToken(graContract).burn(allGras);\r\n        emit BurnGras(allGras);\r\n    }\r\n    function _swapForGras(address pair) private {\r\n        (address a, address b) = IGraSwapFactory(factory).getTokensFromPair(pair);\r\n        require(a != address(0) || b != address(0), \"GraSwapBuyback: INVALID_PAIR\");\r\n        require(a == graContract || b == graContract, \"GraSwapBuyback: GraS_NOT_IN_PAIR\");\r\n\r\n        address token = (a == graContract) ? b : a;\r\n        require(_mainTokens[token], \"GraSwapBuyback: MAIN_TOKEN_NOT_IN_PAIR\");\r\n\r\n        address[] memory path = new address[](1);\r\n        path[0] = pair;\r\n\r\n        if (token == _ETH) { // eth -> Gras\r\n            uint256 ethAmt = address(this).balance;\r\n            // require(ethAmt > 0, \"GraSwapBuyback: NO_ETH\");\r\n            if (ethAmt == 0) { return; }\r\n\r\n            IGraSwapRouter(router).swapToken{value: ethAmt}(\r\n                _ETH, ethAmt, 0, path, address(this), _MAX_UINT256);\r\n        } else { // main token -> Gras\r\n            uint256 tokenAmt = IERC20(token).balanceOf(address(this));\r\n            // require(tokenAmt > 0, \"GraSwapBuyback: NO_MAIN_TOKENS\");\r\n            if (tokenAmt == 0) { return; }\r\n\r\n            IERC20(token).approve(router, 0);\r\n            IERC20(token).approve(router, tokenAmt);\r\n            IGraSwapRouter(router).swapToken(\r\n                token, tokenAmt, 0, path, address(this), _MAX_UINT256);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burntAmt\",\"type\":\"uint256\"}],\"name\":\"BurnGras\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addMainToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"graContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isMainToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeMainToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"swapForGrasAndBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"swapForMainToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"GraSwapBuyback","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005a23b7e3bb936c7753b5e7a6c304a8fb43979d20000000000000000000000000345a688369e60999f0f2567dc948dca620b9a4920000000000000000000000006b74e5c4137afd6a7dbd9d43c9d7af2a258e57a7","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f9e96d4764ac662468e627964c58aa4f71029b8294418677af84f3a8abbe97ab"}]}