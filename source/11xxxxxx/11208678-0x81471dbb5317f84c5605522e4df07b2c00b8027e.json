{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface PermittedAddressesInterface {\r\n  function permittedAddresses(address _address) external view returns(bool);\r\n  function addressesTypes(address _address) external view returns(string memory);\r\n  function isMatchTypes(address _address, uint256 addressType) external view returns(bool);\r\n}\r\ninterface ICoTraderGlobalConfig {\r\n  function MAX_TOKENS() external view returns(uint256);\r\n\r\n  function TRADE_FREEZE_TIME() external view returns(uint256);\r\n\r\n  function DW_FREEZE_TIME() external view returns(uint256);\r\n\r\n  function PLATFORM_ADDRESS() external view returns(address);\r\n}\r\ninterface IFundValueOracle {\r\n  function requestValue(address _fundAddress, uint256 _fee) external payable returns (bytes32 requestId);\r\n  function getFundValueByID(bytes32 _requestId) external view returns(uint256 value);\r\n  function fee() external returns(uint256);\r\n}\r\ninterface DefiPortalInterface {\r\n  function callPayableProtocol(\r\n    address[] memory tokensToSend,\r\n    uint256[] memory amountsToSend,\r\n    bytes calldata _additionalData,\r\n    bytes32[] calldata _additionalArgs\r\n  )\r\n    external\r\n    payable\r\n    returns(\r\n      string memory eventType,\r\n      address[] memory tokensToReceive,\r\n      uint256[] memory amountsToReceive\r\n    );\r\n\r\n  function callNonPayableProtocol(\r\n    address[] memory tokensToSend,\r\n    uint256[] memory amountsToSend,\r\n    bytes calldata _additionalData,\r\n    bytes32[] calldata _additionalArgs\r\n  )\r\n    external\r\n    returns(\r\n      string memory eventType,\r\n      address[] memory tokensToReceive,\r\n      uint256[] memory amountsToReceive\r\n    );\r\n}\r\n\r\n\r\ninterface PoolPortalInterface {\r\n  function buyPool\r\n  (\r\n    uint256 _amount,\r\n    uint _type,\r\n    address _poolToken,\r\n    address[] calldata _connectorsAddress,\r\n    uint256[] calldata _connectorsAmount,\r\n    bytes32[] calldata _additionalArgs,\r\n    bytes calldata _additionalData\r\n  )\r\n  external\r\n  payable\r\n  returns(uint256 poolAmountReceive, uint256[] memory connectorsSpended);\r\n\r\n  function sellPool\r\n  (\r\n    uint256 _amount,\r\n    uint _type,\r\n    IERC20 _poolToken,\r\n    bytes32[] calldata _additionalArgs,\r\n    bytes calldata _additionData\r\n  )\r\n  external\r\n  payable\r\n  returns(\r\n    address[] memory connectorsAddress,\r\n    uint256[] memory connectorsAmount\r\n  );\r\n}\r\n\r\n\r\n// interface for fund contract\r\ninterface IExchangePortal {\r\n  function trade(\r\n    IERC20 _source,\r\n    uint256 _sourceAmount,\r\n    IERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] calldata _proof,\r\n    uint256[] calldata _positions,\r\n    bytes calldata _additionalData,\r\n    bool _verifyDestanation\r\n  )\r\n    external\r\n    payable\r\n    returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n  The SmartFund contract is what holds all the tokens and ether, and contains all the logic\r\n  for calculating its value (and ergo profit), allows users to deposit/withdraw their funds,\r\n  and calculates the fund managers cut of the funds profit among other things.\r\n  The SmartFund gets the value of its token holdings (in Ether) and trades through the ExchangePortal\r\n  contract. This means that as new exchange capabalities are added to new exchange portals, the\r\n  SmartFund will be able to upgrade to a new exchange portal, and trade a wider variety of assets\r\n  with a wider variety of exchanges. The SmartFund is also connected to a permittedAddresses contract,\r\n  which determines which exchange, pool, defi portals the SmartFund is allowed to connect to, restricting\r\n  the fund owners ability to connect to a potentially malicious contract.\r\n\r\n  In additional this contract can use pools and defi protocols voa pool and defi portals.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\nabstract contract SmartFundCore is Ownable, IERC20 {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  // Fund type\r\n  bool public isLightFund = false;\r\n\r\n  // Total amount of ether or stable deposited by all users\r\n  uint256 public totalWeiDeposited;\r\n\r\n  // Total amount of ether or stable withdrawn by all users\r\n  uint256 public totalWeiWithdrawn;\r\n\r\n  // The Interface of the Exchange Portal\r\n  IExchangePortal public exchangePortal;\r\n\r\n  // The Interface of pool portall\r\n  PoolPortalInterface public poolPortal;\r\n\r\n  // The interface of DefiPortal\r\n  DefiPortalInterface public defiPortal;\r\n\r\n  // The Smart Contract which stores the addresses of all the authorized Exchange Portals\r\n  PermittedAddressesInterface public permittedAddresses;\r\n\r\n  // portals recognizes ETH by this address\r\n  IERC20 constant internal ETH_TOKEN_ADDRESS = IERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n  // For ERC20 compliance\r\n  string public name;\r\n\r\n  // Percentages are rounded to 3 decimal places\r\n  uint256 public TOTAL_PERCENTAGE = 10000;\r\n\r\n  // The percentage of earnings paid to the fund manager. 10000 = 100%\r\n  // e.g. 10% is 1000\r\n  uint256 public successFee;\r\n\r\n  // The percentage of fund manager earnings paid to the platform. 10000 = 100%\r\n  // e.g. 10% is 1000\r\n  uint256 public platformFee;\r\n\r\n  // An array of all the erc20 token addresses the smart fund holds\r\n  address[] public tokenAddresses;\r\n\r\n  // Boolean value that determines whether the fund accepts deposits from anyone or\r\n  // only specific addresses approved by the manager\r\n  bool public onlyWhitelist;\r\n\r\n  // Mapping of addresses that are approved to deposit if the manager only want's specific\r\n  // addresses to be able to invest in their fund\r\n  mapping (address => bool) public whitelist;\r\n\r\n  uint public version = 8;\r\n\r\n  // the total number of shares in the fund\r\n  uint256 public totalShares;\r\n\r\n  // Denomination of initial shares\r\n  uint256 constant internal INITIAL_SHARES = 10 ** 18;\r\n\r\n  // The earnings the fund manager has already cashed out\r\n  uint256 public fundManagerCashedOut;\r\n\r\n  // for ETH and USD fund this asset different\r\n  address public coreFundAsset;\r\n\r\n  // If true the contract will require each new asset to buy to be on a special Merkle tree list\r\n  bool public isRequireTradeVerification;\r\n\r\n  // Oracle contract instance\r\n  IFundValueOracle public fundValueOracle;\r\n\r\n  // Data for Oracle updates\r\n  bytes32 public latestOracleRequestID;\r\n  uint256 public latestOracleCallOnTime;\r\n  uint256 public latestOracleCallOnBlock;\r\n  address public latestOracleCaller;\r\n\r\n  // CoTrader platform config\r\n  ICoTraderGlobalConfig public cotraderGlobalConfig;\r\n\r\n  // how many shares belong to each address\r\n  mapping (address => uint256) public addressToShares;\r\n\r\n  // so that we can easily check that we don't add duplicates to our array\r\n  mapping (address => bool) public tokensTraded;\r\n\r\n  // this is really only being used to more easily show profits, but may not be necessary\r\n  // if we do a lot of this offchain using events to track everything\r\n  // total `depositToken` deposited - total `depositToken` withdrawn\r\n  mapping (address => int256) public addressesNetDeposit;\r\n\r\n  // Events\r\n  event DefiCall(\r\n    string eventType,\r\n    address[] tokensToSend,\r\n    uint256[] amountsToSend,\r\n    address[] tokensToReceive,\r\n    uint256[] amountsToReceive\r\n    );\r\n\r\n  event BuyPool(\r\n    address poolAddress,\r\n    uint256 poolAmount,\r\n    address[] connectorsAddress,\r\n    uint256[] connectorsAmount);\r\n\r\n  event SellPool(\r\n    address poolAddress,\r\n    uint256 poolAmount,\r\n    address[] connectorsAddress,\r\n    uint256[] connectorsAmount);\r\n\r\n  event Deposit(address indexed user, uint256 amount, uint256 sharesReceived, uint256 totalShares);\r\n  event Withdraw(address indexed user, uint256 sharesRemoved, uint256 totalShares);\r\n  event Trade(address src, uint256 srcAmount, address dest, uint256 destReceived);\r\n  event SmartFundCreated(address indexed owner);\r\n  event OracleUpdate(address caller, uint256 triggerTime, bytes32 id);\r\n\r\n\r\n  constructor(\r\n    address _owner,\r\n    string memory _name,\r\n    uint256 _successFee,\r\n    address _exchangePortalAddress,\r\n    address _poolPortalAddress,\r\n    address _defiPortal,\r\n    address _permittedAddresses,\r\n    address _coreFundAsset,\r\n    address _fundValueOracle,\r\n    bool    _isRequireTradeVerification,\r\n    address _cotraderGlobalConfig\r\n  )public{\r\n    // never allow a 100% fee\r\n    require(_successFee < TOTAL_PERCENTAGE);\r\n\r\n    name = _name;\r\n    successFee = _successFee;\r\n    platformFee = _successFee; // platform fee the same as manager fee\r\n\r\n    // Init manager\r\n    if(_owner == address(0)){\r\n      transferOwnership(msg.sender);\r\n    }\r\n    else{\r\n      transferOwnership(_owner);\r\n    }\r\n\r\n    // Initial Token is Ether\r\n    tokenAddresses.push(address(ETH_TOKEN_ADDRESS));\r\n\r\n    // Initial interfaces\r\n    exchangePortal = IExchangePortal(_exchangePortalAddress);\r\n    poolPortal = PoolPortalInterface(_poolPortalAddress);\r\n    defiPortal = DefiPortalInterface(_defiPortal);\r\n    permittedAddresses = PermittedAddressesInterface(_permittedAddresses);\r\n\r\n    // Initial core assets\r\n    coreFundAsset = _coreFundAsset;\r\n\r\n    // Initial fund Oracle\r\n    fundValueOracle = IFundValueOracle(_fundValueOracle);\r\n\r\n    // Initial check if fund require trade verification or not\r\n    isRequireTradeVerification = _isRequireTradeVerification;\r\n\r\n    // Initial platform config\r\n    cotraderGlobalConfig = ICoTraderGlobalConfig(_cotraderGlobalConfig);\r\n\r\n    emit SmartFundCreated(owner());\r\n  }\r\n\r\n  // Modifiers\r\n  // We use function instead modifiers because modifiers require more bytes\r\n\r\n  // Not allow trade while user do deposit or withdraw\r\n  function verifyTradeBetweenDW() internal view {\r\n    require(\r\n        now >= latestOracleCallOnTime + cotraderGlobalConfig.TRADE_FREEZE_TIME(),\r\n        \"FREEZE_FOR_UPDATE_PRICE\"\r\n     );\r\n  }\r\n\r\n  // not allow call user B (for a freeze minutes) if user A not finished operation\r\n  // allow call any user for a first deposit\r\n  function verifyDWSender() internal view {\r\n    if(totalShares > 0){\r\n      if(latestOracleCallOnTime + cotraderGlobalConfig.TRADE_FREEZE_TIME() >= now){\r\n        require(msg.sender == latestOracleCaller, \"NOT_LATEST_ORACLE_CALLER\");\r\n      }\r\n      else{\r\n        revert(\"ORACLE_TIME_EXPIRED\");\r\n      }\r\n    }\r\n  }\r\n\r\n  // allow update oracle price\r\n  // _oracleTokenAddress it's fee token address\r\n  function updateFundValueFromOracle(address _oracleTokenAddress, uint256 _oracleFee) public payable {\r\n    // allow call Oracle only after a certain time\r\n    require(now >= latestOracleCallOnTime + cotraderGlobalConfig.DW_FREEZE_TIME(), \"DW_FREEZE\");\r\n\r\n    // pay for using Oracle with ETH\r\n    if(_oracleTokenAddress == address(ETH_TOKEN_ADDRESS)){\r\n      require(msg.value == _oracleFee, \"REQUIRE_ETH\");\r\n      // call oracle\r\n      latestOracleRequestID = fundValueOracle.requestValue.value(_oracleFee)(address(this), _oracleFee);\r\n    }\r\n    // for using Oracle with ERC20\r\n    else{\r\n      require(msg.value == 0, \"NO_NEED_ETH\");\r\n      // transfer oracle token from sender and approve to oracle portal\r\n      _transferFromSenderAndApproveTo(IERC20(_oracleTokenAddress), _oracleFee, address(fundValueOracle));\r\n      // call oracle\r\n      latestOracleRequestID = fundValueOracle.requestValue(address(this), _oracleFee);\r\n    }\r\n\r\n    // update data\r\n    latestOracleCallOnTime = now;\r\n    latestOracleCallOnBlock = block.number;\r\n    latestOracleCaller = msg.sender;\r\n\r\n    // emit events\r\n    emit OracleUpdate(latestOracleCaller, latestOracleCallOnTime, latestOracleRequestID);\r\n  }\r\n\r\n  // core function for calculate deposit and withdraw and managerWithdraw\r\n  // return data from Oracle\r\n  function calculateFundValue() public view returns (uint256) {\r\n    // return latest data from Oracle\r\n    return fundValueOracle.getFundValueByID(latestOracleRequestID);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Sends (_mul/_div) of every token (and ether) the funds holds to _withdrawAddress\r\n  *\r\n  * @param _mul                The numerator\r\n  * @param _div                The denominator\r\n  * @param _withdrawAddress    Address to send the tokens/ether to\r\n  *\r\n  * NOTE: _withdrawAddress changed from address to address[] arrays because balance calculation should be performed\r\n  * once for all usesr who wants to withdraw from the current balance.\r\n  *\r\n  */\r\n  function _withdraw(\r\n    uint256[] memory _mul,\r\n    uint256[] memory _div,\r\n    address[] memory _withdrawAddress\r\n    )\r\n    internal\r\n    returns (uint256)\r\n  {\r\n    for (uint8 i = 1; i < tokenAddresses.length; i++) {\r\n      // Transfer that _mul/_div of each token we hold to the user\r\n      IERC20 token = IERC20(tokenAddresses[i]);\r\n      uint256 fundAmount = token.balanceOf(address(this));\r\n\r\n      // Transfer ERC20 to _withdrawAddress\r\n      for(uint8 j = 0; j < _withdrawAddress.length; j++){\r\n        // calculate withdraw ERC20 share\r\n        uint256 payoutAmount = fundAmount.mul(_mul[j]).div(_div[j]);\r\n        if(payoutAmount > 0)\r\n          token.transfer(_withdrawAddress[j], payoutAmount);\r\n      }\r\n    }\r\n    // Transfer ETH to _withdrawAddress\r\n    uint256 etherBalance = address(this).balance;\r\n    for(uint8 k = 0; k < _withdrawAddress.length; k++){\r\n      // calculate withdraw ETH share\r\n      uint256 etherPayoutAmount = (etherBalance).mul(_mul[k]).div(_div[k]);\r\n      if(etherPayoutAmount > 0)\r\n        payable(_withdrawAddress[k]).transfer(etherPayoutAmount);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraws users fund holdings, sends (userShares/totalShares) of every held token\r\n  * to msg.sender, defaults to 100% of users shares.\r\n  *\r\n  * @param _percentageWithdraw    The percentage of the users shares to withdraw.\r\n  */\r\n  function withdraw(uint256 _percentageWithdraw) external {\r\n    verifyDWSender();\r\n    require(totalShares != 0, \"EMPTY_SHARES\");\r\n    require(_percentageWithdraw <= TOTAL_PERCENTAGE, \"WRONG_PERCENT\");\r\n\r\n    uint256 percentageWithdraw = (_percentageWithdraw == 0) ? TOTAL_PERCENTAGE : _percentageWithdraw;\r\n\r\n    uint256 addressShares = addressToShares[msg.sender];\r\n\r\n    uint256 numberOfWithdrawShares = addressShares.mul(percentageWithdraw).div(TOTAL_PERCENTAGE);\r\n\r\n    uint256 fundManagerCut;\r\n    uint256 fundValue;\r\n\r\n    // Withdraw the users share minus the fund manager's success fee\r\n    (fundManagerCut, fundValue, ) = calculateFundManagerCut();\r\n\r\n    // reset latest Oracle Caller for protect from double call\r\n    latestOracleCaller = address(0);\r\n\r\n    uint256 withdrawShares = numberOfWithdrawShares.mul(fundValue.sub(fundManagerCut)).div(fundValue);\r\n\r\n    // prepare call data for _withdarw\r\n    address[] memory spenders = new address[](1);\r\n    spenders[0] = msg.sender;\r\n\r\n    uint256[] memory value = new uint256[](1);\r\n    value[0] = totalShares;\r\n\r\n    uint256[] memory cut = new uint256[](1);\r\n    cut[0] = withdrawShares;\r\n\r\n    // do withdraw\r\n    _withdraw(cut, value, spenders);\r\n\r\n    // Store the value we are withdrawing in ether\r\n    uint256 valueWithdrawn = fundValue.mul(withdrawShares).div(totalShares);\r\n\r\n    totalWeiWithdrawn = totalWeiWithdrawn.add(valueWithdrawn);\r\n    addressesNetDeposit[msg.sender] -= int256(valueWithdrawn);\r\n\r\n    // Subtract from total shares the number of withdrawn shares\r\n    totalShares = totalShares.sub(numberOfWithdrawShares);\r\n    addressToShares[msg.sender] = addressToShares[msg.sender].sub(numberOfWithdrawShares);\r\n\r\n    emit Withdraw(msg.sender, numberOfWithdrawShares, totalShares);\r\n  }\r\n\r\n  /**\r\n  * @dev Facilitates a trade of the funds holdings via the exchange portal\r\n  *\r\n  * @param _source            ERC20 token to convert from\r\n  * @param _sourceAmount      Amount to convert (in _source token)\r\n  * @param _destination       ERC20 token to convert to\r\n  * @param _type              The type of exchange to trade with\r\n  * @param _proof             Merkle tree proof (if not used just set [])\r\n  * @param _positions         Merkle tree positions (if not used just set [])\r\n  * @param _additionalData    For additional data (if not used just set \"0x0\")\r\n  * @param _minReturn         Min expected amount of destination\r\n  */\r\n  function trade(\r\n    IERC20 _source,\r\n    uint256 _sourceAmount,\r\n    IERC20 _destination,\r\n    uint256 _type,\r\n    bytes32[] calldata _proof,\r\n    uint256[] calldata _positions,\r\n    bytes calldata _additionalData,\r\n    uint256 _minReturn\r\n  )\r\n   external\r\n   onlyOwner\r\n  {\r\n    verifyTradeBetweenDW();\r\n\r\n    require(_minReturn > 0, \"MIN_RETURN_0\");\r\n\r\n    uint256 receivedAmount;\r\n\r\n    if (_source == ETH_TOKEN_ADDRESS) {\r\n      // Make sure fund contains enough ether\r\n      require(address(this).balance >= _sourceAmount, \"NOT_ENOUGH_ETH\");\r\n      // Call trade on ExchangePortal along with ether\r\n      receivedAmount = exchangePortal.trade.value(_sourceAmount)(\r\n        _source,\r\n        _sourceAmount,\r\n        _destination,\r\n        _type,\r\n        _proof,\r\n        _positions,\r\n        _additionalData,\r\n        isRequireTradeVerification\r\n      );\r\n    } else {\r\n      _source.approve(address(exchangePortal), _sourceAmount);\r\n      receivedAmount = exchangePortal.trade(\r\n        _source,\r\n        _sourceAmount,\r\n        _destination,\r\n        _type,\r\n        _proof,\r\n        _positions,\r\n        _additionalData,\r\n        isRequireTradeVerification\r\n      );\r\n    }\r\n\r\n    // make sure fund recive destanation\r\n    require(receivedAmount >= _minReturn, \"RECEIVED_LESS_THAN_MIN\");\r\n\r\n    // add token to trader list\r\n    _addToken(address(_destination));\r\n\r\n    // emit event\r\n    emit Trade(\r\n      address(_source),\r\n      _sourceAmount,\r\n      address(_destination),\r\n      receivedAmount);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev buy pool via pool portal\r\n  *\r\n  * @param _amount             For Bancor amount it's relay, for Uniswap amount it's ETH, for Bancor and Uniswap v2 can be 0\r\n  * @param _type               type of pool (0 - Bancor, 1 - Uniswap)\r\n  * @param _poolToken          address of relay for Bancor and exchange for Uniswap\r\n  * @param _connectorsAddress  address of pool connectors\r\n  * @param _connectorsAmount   amount of pool connectors\r\n  * @param _additionalArgs     bytes32 array for case if need pass some extra params, can be empty\r\n  * @param _additionData       for provide any additional data, if not used just set \"0x\"\r\n  */\r\n  function buyPool(\r\n   uint256            _amount,\r\n   uint               _type,\r\n   address            _poolToken,\r\n   address[] calldata _connectorsAddress,\r\n   uint256[] memory   _connectorsAmount,  // WARNING: this array rewrite from buyPool return (details below)\r\n   bytes32[] calldata _additionalArgs,\r\n   bytes calldata     _additionData\r\n  )\r\n   external\r\n   onlyOwner\r\n  {\r\n   verifyTradeBetweenDW();\r\n   // for determine the exact number of received pool\r\n   uint256 poolAmountReceive;\r\n\r\n   // approve connectors\r\n   // etherAmount for detect ETH case\r\n   uint256 etherAmount = approveArrayOfTokensToSpender(\r\n     _connectorsAddress,\r\n     _connectorsAmount,\r\n     address(poolPortal)\r\n   );\r\n\r\n   // buy pool with ETH (payable case)\r\n   if(etherAmount > 0){\r\n     // WARNING: rewrire _connectorsAmount from return\r\n     // some pools can return some remains for connectors, and for get correct result,\r\n     // for connectors amount to spend for emit event\r\n     // poolPortal calculates and return exactly how many tokens were spent (total - remains),\r\n     // unfortunate due stack too deep issue, we can't declarate new variable\r\n     // so we rewrire _connectorsAmount\r\n    (poolAmountReceive, _connectorsAmount) = poolPortal.buyPool.value(etherAmount)(\r\n      _amount,\r\n      _type,\r\n     _poolToken,\r\n     _connectorsAddress,\r\n     _connectorsAmount,\r\n     _additionalArgs,\r\n     _additionData\r\n     );\r\n   }\r\n   // buy pool only with ERC20 (non payable case)\r\n   else{\r\n     // WARNING: rewrire _connectorsAmount from return\r\n     (poolAmountReceive, _connectorsAmount) = poolPortal.buyPool(\r\n      _amount,\r\n      _type,\r\n     _poolToken,\r\n     _connectorsAddress,\r\n     _connectorsAmount,\r\n     _additionalArgs,\r\n     _additionData\r\n     );\r\n   }\r\n   // make sure fund receive pool token\r\n   require(poolAmountReceive > 0, \"EMPTY_POOL\");\r\n   // Add pool as ERC20 for withdraw\r\n   _addToken(_poolToken);\r\n   // emit event\r\n   emit BuyPool(\r\n     _poolToken,\r\n     poolAmountReceive,\r\n     _connectorsAddress,\r\n     _connectorsAmount);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev sell pool via pool portal\r\n  *\r\n  * @param _amount          amount of Bancor relay or Uniswap exchange to sell\r\n  * @param _type            type of pool (0 - Bancor, 1 - Uniswap)\r\n  * @param _poolToken       address of Bancor relay or Uniswap exchange\r\n  * @param _additionalArgs  bytes32 array for case if need pass some extra params, can be empty\r\n  * @param _additionData    for provide any additional data, if not used just set \"0x\"\r\n  */\r\n  function sellPool(\r\n    uint256 _amount,\r\n    uint _type,\r\n    IERC20 _poolToken,\r\n    bytes32[] calldata _additionalArgs,\r\n    bytes calldata _additionData\r\n  )\r\n   external\r\n   onlyOwner\r\n  {\r\n    verifyTradeBetweenDW();\r\n    // approve pool\r\n    _poolToken.approve(address(poolPortal), _amount);\r\n\r\n    // sell pool\r\n    (address[] memory connectorsAddress,\r\n     uint256[] memory connectorsAmount) = poolPortal.sellPool(\r\n      _amount,\r\n      _type,\r\n     _poolToken,\r\n     _additionalArgs,\r\n     _additionData\r\n    );\r\n\r\n    // Add connectors to fund\r\n    for(uint8 i = 0; i < connectorsAddress.length; i++){\r\n      _addToken(connectorsAddress[i]);\r\n    }\r\n\r\n    // event\r\n    emit SellPool(\r\n      address(_poolToken),\r\n      _amount,\r\n      connectorsAddress,\r\n      connectorsAmount);\r\n  }\r\n\r\n  /**\r\n  * @dev allow manager use newest DEFI protocols\r\n  * NOTE: all logic in DEFI portal hardcoded, and also fund manager can't update\r\n  * non permitted DEFI portal, so this is safe call\r\n  *\r\n\r\n  * @param _additionalData               params data packed in bytes\r\n  * @param _additionalArgs      additional params array for quick unpack\r\n\r\n  */\r\n  function callDefiPortal(\r\n    address[] memory tokensToSend,\r\n    uint256[] memory amountsToSend,\r\n    bytes32[] calldata _additionalArgs,\r\n    bytes calldata _additionalData\r\n  )\r\n    external\r\n    onlyOwner\r\n  {\r\n    verifyTradeBetweenDW();\r\n    // event data\r\n    string memory eventType;\r\n    address[] memory tokensToReceive;\r\n    uint256[] memory amountsToReceive;\r\n\r\n    // approve connectors\r\n    // etherAmount for detect ETH case\r\n    uint256 etherAmount = approveArrayOfTokensToSpender(\r\n      tokensToSend,\r\n      amountsToSend,\r\n      address(defiPortal)\r\n    );\r\n\r\n    // call defi payable case\r\n    if(etherAmount > 0){\r\n      (eventType,\r\n       tokensToReceive,\r\n       amountsToReceive) = defiPortal.callPayableProtocol.value(etherAmount)(\r\n         tokensToSend,\r\n         amountsToSend,\r\n         _additionalData,\r\n         _additionalArgs\r\n        );\r\n    }\r\n    // call defi not payable case\r\n    else{\r\n      (eventType,\r\n       tokensToReceive,\r\n       amountsToReceive) = defiPortal.callNonPayableProtocol(\r\n         tokensToSend,\r\n         amountsToSend,\r\n         _additionalData,\r\n         _additionalArgs\r\n        );\r\n    }\r\n\r\n   // add new tokens in fund\r\n   for(uint8 i = 0; i < tokensToReceive.length; i++){\r\n     _addToken(tokensToReceive[i]);\r\n   }\r\n\r\n   // emit event\r\n    emit DefiCall(\r\n      eventType,\r\n      tokensToSend,\r\n      amountsToSend,\r\n      tokensToReceive,\r\n      amountsToReceive\r\n    );\r\n  }\r\n\r\n\r\n  // pivate helper for approve arary of tokens\r\n  // spender can be Pool or Defi portals\r\n  function approveArrayOfTokensToSpender(\r\n    address[] memory addresses,\r\n    uint256[] memory amounts,\r\n    address spender\r\n  )\r\n    private\r\n    returns (uint256 etherAmount)\r\n  {\r\n    for(uint8 i = 0; i < addresses.length; i++){\r\n      if(addresses[i] != address(ETH_TOKEN_ADDRESS)){\r\n        // approve\r\n        IERC20(addresses[i]).approve(spender, amounts[i]);\r\n      }\r\n      else{\r\n        etherAmount = amounts[i];\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  // return all tokens addresses from fund\r\n  function getAllTokenAddresses() external view returns (address[] memory) {\r\n    return tokenAddresses;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds a token to tokensTraded if it's not already there\r\n  * @param _token    The token to add\r\n  */\r\n  function _addToken(address _token) internal {\r\n    // don't add token to if we already have it in our list\r\n    if (tokensTraded[_token] || (_token == address(ETH_TOKEN_ADDRESS)))\r\n      return;\r\n\r\n    tokensTraded[_token] = true;\r\n    tokenAddresses.push(_token);\r\n    uint256 tokenCount = tokenAddresses.length;\r\n\r\n    // we can't hold more than MAX_TOKENS tokens\r\n    require(tokenCount <= cotraderGlobalConfig.MAX_TOKENS(), \"MAX_TOKENS\");\r\n  }\r\n\r\n  /**\r\n  * @dev Removes a token from tokensTraded\r\n  *\r\n  * @param _token         The address of the token to be removed\r\n  * @param _tokenIndex    The index of the token to be removed\r\n  *\r\n  */\r\n  function removeToken(address _token, uint256 _tokenIndex) public onlyOwner {\r\n    require(_token != address(ETH_TOKEN_ADDRESS));\r\n    require(tokensTraded[_token]);\r\n    require(IERC20(_token).balanceOf(address(this)) == 0);\r\n    require(tokenAddresses[_tokenIndex] == _token);\r\n\r\n    tokensTraded[_token] = false;\r\n\r\n    // remove token from array\r\n    uint256 arrayLength = tokenAddresses.length - 1;\r\n    tokenAddresses[_tokenIndex] = tokenAddresses[arrayLength];\r\n    delete tokenAddresses[arrayLength];\r\n    tokenAddresses.pop();\r\n  }\r\n\r\n  /**\r\n  * @dev Calculates the amount of shares received according to ether deposited\r\n  *\r\n  * @param _amount    Amount of ether to convert to shares\r\n  *\r\n  * @return Amount of shares to be received\r\n  */\r\n  function calculateDepositToShares(uint256 _amount) internal view returns (uint256) {\r\n    uint256 fundManagerCut;\r\n    uint256 fundValue;\r\n\r\n    // If there are no shares in the contract, whoever deposits owns 100% of the fund\r\n    // we will set this to 10^18 shares, but this could be any amount\r\n    if (totalShares == 0)\r\n      return INITIAL_SHARES;\r\n\r\n    (fundManagerCut, fundValue, ) = calculateFundManagerCut();\r\n\r\n    uint256 fundValueBeforeDeposit = fundValue.sub(fundManagerCut);\r\n\r\n    if (fundValueBeforeDeposit == 0)\r\n      return 0;\r\n\r\n    return _amount.mul(totalShares).div(fundValueBeforeDeposit);\r\n\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Calculates the fund managers cut, depending on the funds profit and success fee\r\n  *\r\n  * @return fundManagerRemainingCut    The fund managers cut that they have left to withdraw\r\n  * @return fundValue                  The funds current value\r\n  * @return fundManagerTotalCut        The fund managers total cut of the profits until now\r\n  */\r\n  function calculateFundManagerCut() public view returns (\r\n    uint256 fundManagerRemainingCut, // fm's cut of the profits that has yet to be cashed out (in `depositToken`)\r\n    uint256 fundValue, // total value of fund (in `depositToken`)\r\n    uint256 fundManagerTotalCut // fm's total cut of the profits (in `depositToken`)\r\n  ) {\r\n    fundValue = calculateFundValue();\r\n    // The total amount of ether currently deposited into the fund, takes into account the total ether\r\n    // withdrawn by investors as well as ether withdrawn by the fund manager\r\n    // NOTE: value can be negative if the manager performs well and investors withdraw more\r\n    // ether than they deposited\r\n    int256 curtotalWeiDeposited = int256(totalWeiDeposited) - int256(totalWeiWithdrawn.add(fundManagerCashedOut));\r\n\r\n    // If profit < 0, the fund managers totalCut and remainingCut are 0\r\n    if (int256(fundValue) <= curtotalWeiDeposited) {\r\n      fundManagerTotalCut = 0;\r\n      fundManagerRemainingCut = 0;\r\n    } else {\r\n      // calculate profit. profit = current fund value - total deposited + total withdrawn + total withdrawn by fm\r\n      uint256 profit = uint256(int256(fundValue) - curtotalWeiDeposited);\r\n      // remove the money already taken by the fund manager and take percentage\r\n      fundManagerTotalCut = profit.mul(successFee).div(TOTAL_PERCENTAGE);\r\n      fundManagerRemainingCut = fundManagerTotalCut.sub(fundManagerCashedOut);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the fund manager to withdraw their cut of the funds profit\r\n  */\r\n  function fundManagerWithdraw() external onlyOwner {\r\n    verifyDWSender();\r\n    uint256 fundManagerCut;\r\n    uint256 fundValue;\r\n\r\n    (fundManagerCut, fundValue, ) = calculateFundManagerCut();\r\n\r\n    uint256 platformCut = (platformFee == 0) ? 0 : fundManagerCut.mul(platformFee).div(TOTAL_PERCENTAGE);\r\n\r\n    // prepare call data for _withdarw\r\n    address[] memory spenders = new address[](2);\r\n    spenders[0] = cotraderGlobalConfig.PLATFORM_ADDRESS();\r\n    spenders[1] = owner();\r\n\r\n    uint256[] memory value = new uint256[](2);\r\n    value[0] = fundValue;\r\n    value[1] = fundValue;\r\n\r\n    uint256[] memory cut = new uint256[](2);\r\n    cut[0] = platformCut;\r\n    cut[1] = fundManagerCut - platformCut;\r\n\r\n    // do withdraw\r\n    _withdraw(cut, value, spenders);\r\n\r\n    // add report\r\n    fundManagerCashedOut = fundManagerCashedOut.add(fundManagerCut);\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the manager to set whether or not only whitelisted addresses can deposit into\r\n  * their fund\r\n  *\r\n  * @param _onlyWhitelist    boolean representing whether only whitelisted addresses can deposit\r\n  */\r\n  function setWhitelistOnly(bool _onlyWhitelist) external onlyOwner {\r\n    onlyWhitelist = _onlyWhitelist;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the fund manager to whitelist specific addresses to control\r\n  * whos allowed to deposit into the fund\r\n  *\r\n  * @param _user       The user address to whitelist\r\n  * @param _allowed    The status of _user, true means allowed to deposit, false means not allowed\r\n  */\r\n  function setWhitelistAddress(address _user, bool _allowed) external onlyOwner {\r\n    whitelist[_user] = _allowed;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the fund manager to connect to a new permitted exchange portal\r\n  *\r\n  * @param _newExchangePortalAddress    The address of the new permitted exchange portal to use\r\n  */\r\n  function setNewExchangePortal(address _newExchangePortalAddress) public onlyOwner {\r\n    // Require correct permitted address type\r\n    require(permittedAddresses.isMatchTypes(_newExchangePortalAddress, 1), \"WRONG_ADDRESS\");\r\n    // Set new\r\n    exchangePortal = IExchangePortal(_newExchangePortalAddress);\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the fund manager to connect to a new permitted poolPortal\r\n  *\r\n  * @param _newPoolPortal   The address of the new permitted pool portal to use\r\n  */\r\n  function setNewPoolPortal(address _newPoolPortal) public onlyOwner {\r\n    // Require correct permitted address type\r\n    require(permittedAddresses.isMatchTypes(_newPoolPortal, 2), \"WRONG_ADDRESS\");\r\n    // Set new\r\n    poolPortal = PoolPortalInterface(_newPoolPortal);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Allows the fund manager to connect to a new permitted defi portal\r\n  *\r\n  * @param _newDefiPortalAddress    The address of the new permitted defi portal to use\r\n  */\r\n  function setNewDefiPortal(address _newDefiPortalAddress) public onlyOwner {\r\n    // Require correct permitted address type\r\n    require(permittedAddresses.isMatchTypes(_newDefiPortalAddress, 3), \"WRONG_ADDRESS\");\r\n    // Set new\r\n    defiPortal = DefiPortalInterface(_newDefiPortalAddress);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Allows the fund manager to connect to a new Oracle\r\n  *\r\n  * @param _newOracle    address of new fund value Oracle contract\r\n  */\r\n  function setNewFundValueOracle(address _newOracle) public onlyOwner {\r\n    // Require permitted Oracle\r\n    require(permittedAddresses.isMatchTypes(_newOracle, 5), \"WRONG_ADDRESS\");\r\n    // Set new\r\n    fundValueOracle = IFundValueOracle(_newOracle);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev This method is present in the alpha testing phase in case for some reason there are funds\r\n  * left in the SmartFund after all shares were withdrawn\r\n  *\r\n  * @param _token    The address of the token to withdraw\r\n  */\r\n  function emergencyWithdraw(address _token) external onlyOwner {\r\n    require(totalShares == 0);\r\n    if (_token == address(ETH_TOKEN_ADDRESS)) {\r\n      msg.sender.transfer(address(this).balance);\r\n    } else {\r\n      IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Approve 0 for a certain address\r\n  *\r\n  * NOTE: Some ERC20 has no standard approve logic, and not allow do new approve\r\n  * if alredy approved.\r\n  *\r\n  * @param _token                   address of ERC20\r\n  * @param _spender                 address of spender\r\n  */\r\n  function resetApprove(address _token, address _spender) external onlyOwner {\r\n    IERC20(_token).approve(_spender, 0);\r\n  }\r\n\r\n  /**\r\n  * @dev Transfers tokens to this contract and approves them to another address\r\n  *\r\n  * @param _source          Token to transfer and approve\r\n  * @param _sourceAmount    The amount to transfer and approve (in _source token)\r\n  * @param _to              Address to approve to\r\n  */\r\n  function _transferFromSenderAndApproveTo(IERC20 _source, uint256 _sourceAmount, address _to) private {\r\n    _source.transferFrom(msg.sender, address(this), _sourceAmount);\r\n    // approve\r\n    _source.approve(_to, _sourceAmount);\r\n  }\r\n\r\n  // Fallback payable function in order to be able to receive ether from other contracts\r\n  fallback() external payable {}\r\n\r\n  /**\r\n    **************************** ERC20 Compliance ****************************\r\n  **/\r\n\r\n  // Note that addressesNetDeposit does not get updated when transferring shares, since\r\n  // this is used for updating off-chain data it doesn't affect the smart contract logic,\r\n  // but is an issue that currently exists\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  uint8 public decimals = 18;\r\n\r\n  string public symbol = \"FND\";\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  /**\r\n  * @dev Total number of shares in existence\r\n  */\r\n  function totalSupply() external override view returns (uint256) {\r\n    return totalShares;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  *\r\n  * @param _who    The address to query the the balance of.\r\n  *\r\n  * @return A uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _who) external override view returns (uint256) {\r\n    return addressToShares[_who];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer shares for a specified address\r\n  *\r\n  * @param _to       The address to transfer to.\r\n  * @param _value    The amount to be transferred.\r\n  *\r\n  * @return true upon success\r\n  */\r\n  function transfer(address _to, uint256 _value) external override returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= addressToShares[msg.sender]);\r\n\r\n    addressToShares[msg.sender] = addressToShares[msg.sender].sub(_value);\r\n    addressToShares[_to] = addressToShares[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer shares from one address to another\r\n   *\r\n   * @param _from     The address which you want to send tokens from\r\n   * @param _to       The address which you want to transfer to\r\n   * @param _value    The amount of shares to be transferred\r\n   *\r\n   * @return true upon success\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) external override returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= addressToShares[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    addressToShares[_from] = addressToShares[_from].sub(_value);\r\n    addressToShares[_to] = addressToShares[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of shares on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * @param _spender    The address which will spend the funds.\r\n   * @param _value      The amount of shares to be spent.\r\n   *\r\n   * @return true upon success\r\n   */\r\n  function approve(address _spender, uint256 _value) external override returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of shares that an owner allowed to a spender.\r\n   *\r\n   * @param _owner      The address which owns the funds.\r\n   * @param _spender    The address which will spend the funds.\r\n   *\r\n   * @return A uint256 specifying the amount of shares still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) external override view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/*\r\n  Note: this smart fund smart fund inherits SmartFundCore and make core operations like deposit,\r\n  calculate fund value etc in ERC20\r\n*/\r\ncontract SmartFundERC20 is SmartFundCore {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  // State for recognize if this fund stable asset based\r\n  bool public isStableCoinBasedFund;\r\n\r\n  /**\r\n  * @dev constructor\r\n  *\r\n  * @param _owner                        Address of the fund manager\r\n  * @param _name                         Name of the fund, required for DetailedERC20 compliance\r\n  * @param _successFee                   Percentage of profit that the fund manager receives\r\n  * @param _exchangePortalAddress        Address of initial exchange portal\r\n  * @param _poolPortalAddress            Address of initial pool portal\r\n  * @param _permittedAddresses           Address of permittedAddresses contract\r\n  * @param _fundValueOracle              Address of Oracle contract\r\n  * @param _isRequireTradeVerification   If true fund will require verification from Merkle White list for each new asset\r\n  * @param _cotraderGlobalConfig         Address of CoTrader global config\r\n  */\r\n  constructor(\r\n    address _owner,\r\n    string memory _name,\r\n    uint256 _successFee,\r\n    address _exchangePortalAddress,\r\n    address _poolPortalAddress,\r\n    address _defiPortal,\r\n    address _permittedAddresses,\r\n    address _coinAddress,\r\n    address _fundValueOracle,\r\n    bool    _isRequireTradeVerification,\r\n    address _cotraderGlobalConfig\r\n  )\r\n  SmartFundCore(\r\n    _owner,\r\n    _name,\r\n    _successFee,\r\n    _exchangePortalAddress,\r\n    _poolPortalAddress,\r\n    _defiPortal,\r\n    _permittedAddresses,\r\n    _coinAddress,\r\n    _fundValueOracle,\r\n    _isRequireTradeVerification,\r\n    _cotraderGlobalConfig\r\n  )\r\n  public {\r\n    // Initial stable coint permitted interface\r\n    permittedAddresses = PermittedAddressesInterface(_permittedAddresses);\r\n    // Push coin in tokens list\r\n    _addToken(_coinAddress);\r\n    // Define is stable based fund\r\n    isStableCoinBasedFund = permittedAddresses.isMatchTypes(_coinAddress, 4);\r\n  }\r\n\r\n  /**\r\n  * @dev Deposits core coin into the fund and allocates a number of shares to the sender\r\n  * depending on the current number of shares, the funds value, and amount deposited\r\n  *\r\n  * @return The amount of shares allocated to the depositor\r\n  */\r\n  function deposit(uint256 depositAmount) external returns (uint256) {\r\n    verifyDWSender();\r\n\r\n    // Check if the sender is allowed to deposit into the fund\r\n    if (onlyWhitelist)\r\n      require(whitelist[msg.sender]);\r\n\r\n    // Require that the amount sent is not 0\r\n    require(depositAmount > 0, \"ZERO_DEPOSIT\");\r\n\r\n    // Transfer core ERC20 coin from sender\r\n    require(IERC20(coreFundAsset).transferFrom(msg.sender, address(this), depositAmount),\r\n    \"TRANSFER_FROM_ISSUE\");\r\n\r\n    // Calculate number of shares\r\n    uint256 shares = calculateDepositToShares(depositAmount);\r\n\r\n    // reset latest Oracle Caller for protect from double call\r\n    latestOracleCaller = address(0);\r\n\r\n    totalWeiDeposited += depositAmount;\r\n\r\n    // If user would receive 0 shares, don't continue with deposit\r\n    require(shares != 0, \"ZERO_SHARES\");\r\n\r\n    // Add shares to total\r\n    totalShares = totalShares.add(shares);\r\n\r\n    // Add shares to address\r\n    addressToShares[msg.sender] = addressToShares[msg.sender].add(shares);\r\n\r\n    addressesNetDeposit[msg.sender] += int256(depositAmount);\r\n\r\n    emit Deposit(msg.sender, depositAmount, shares, totalShares);\r\n\r\n    return shares;\r\n  }\r\n\r\n  /**\r\n  * @dev sets new coreFundAsset NOTE: this works only for stable coins\r\n  *\r\n  * @param _coinAddress    New stable address\r\n  */\r\n  function changeStableCoinAddress(address _coinAddress) external onlyOwner {\r\n    require(isStableCoinBasedFund, \"NOT_USD_FUND\");\r\n    require(totalWeiDeposited == 0, \"NOT_EMPTY_DEPOSIT\");\r\n    require(permittedAddresses.isMatchTypes(_coinAddress, 4), \"WRONG_ADDRESS\");\r\n\r\n    coreFundAsset = _coinAddress;\r\n  }\r\n}\r\n\r\n\r\ncontract SmartFundERC20Factory {\r\n  function createSmartFund(\r\n    address _owner,\r\n    string memory _name,\r\n    uint256 _successFee,\r\n    address _exchangePortalAddress,\r\n    address _poolPortalAddress,\r\n    address _defiPortal,\r\n    address _permittedAddresses,\r\n    address _coinAddress,\r\n    address _fundValueOracle,\r\n    bool    _isRequireTradeVerification,\r\n    address _cotraderGlobalConfig\r\n  )\r\n  public\r\n  returns(address)\r\n  {\r\n    SmartFundERC20 smartFundERC20 = new SmartFundERC20(\r\n      _owner,\r\n      _name,\r\n      _successFee,\r\n      _exchangePortalAddress,\r\n      _poolPortalAddress,\r\n      _defiPortal,\r\n      _permittedAddresses,\r\n      _coinAddress,\r\n      _fundValueOracle,\r\n      _isRequireTradeVerification,\r\n      _cotraderGlobalConfig\r\n    );\r\n\r\n    return address(smartFundERC20);\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_successFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_exchangePortalAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolPortalAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defiPortal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_permittedAddresses\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_coinAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fundValueOracle\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isRequireTradeVerification\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_cotraderGlobalConfig\",\"type\":\"address\"}],\"name\":\"createSmartFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SmartFundERC20Factory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f2bc7223e200d31857d4d2bde81230a55c7b9ae7ad8c8ada8f35d10180527b63"}]}