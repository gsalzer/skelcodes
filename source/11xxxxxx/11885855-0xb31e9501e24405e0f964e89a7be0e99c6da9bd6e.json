{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\nimport \\\"./IGelatoCondition.sol\\\";\\n\\nabstract contract GelatoConditionsStandard is IGelatoCondition {\\n    string internal constant OK = \\\"OK\\\";\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_conditions/IGelatoCondition.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\\n/// @notice all the APIs of GelatoConditionsStandard\\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\\ninterface IGelatoCondition {\\n\\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\\n    ///  \\\"ok\\\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\\n    ///  source of Task identification.\\n    /// @param _conditionData This is the Condition.data field developers must encode their\\n    ///  Condition's specific parameters in.\\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\\n        external\\n        view\\n        returns(string memory);\\n}\"\r\n    },\r\n    \"contracts/constants/CGelato.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IGelatoGasPriceOracle\\n} from \\\"../interfaces/gelato/IGelatoGasPriceOracle.sol\\\";\\n\\nIGelatoGasPriceOracle constant GELATO_GAS_PRICE_ORACLE = IGelatoGasPriceOracle(\\n    0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C\\n);\\n\\naddress constant GELATO_EXECUTOR_MODULE = 0x98edc8067Cc671BCAE82D36dCC609C3E4e078AC8;\\n\\naddress constant CONDITION_MAKER_VAULT_UNSAFE_OSM = 0xDF3CDd10e646e4155723a3bC5b1191741DD90333;\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/maker/ConditionMakerVaultUnSafePosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {\\n    CONDITION_MAKER_VAULT_UNSAFE_OSM\\n} from \\\"../../../../constants/CGelato.sol\\\";\\nimport {\\n    IConditionMakerVaultUnsafeOSM\\n} from \\\"../../../../interfaces/gelato/conditions/IConditionMakerVaultUnsafeOSM.sol\\\";\\n\\n/// @title ConditionMakerVaultUnSafePosition\\n/// @notice Condition tracking Maker Vault safety requirements.\\n/// @author Gelato Team\\ncontract ConditionMakerVaultUnSafePosition is GelatoConditionsStandard {\\n    /// @notice Standard GelatoCore system function\\n    /// @dev A standard interface for GelatoCore to read Conditions\\n    /// @param _conditionData The data you get from `getConditionData()`\\n    /// @return OK if the Condition is there, else some error message.\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            uint256 _vaultID,\\n            address _priceOracle,\\n            bytes memory _oraclePeekPayload,\\n            bytes memory _oraclePeepPayload,\\n            uint256 _minPeekLimit,\\n            uint256 _minPeepLimit\\n        ) =\\n            abi.decode(\\n                _conditionData[4:],\\n                (uint256, address, bytes, bytes, uint256, uint256)\\n            );\\n\\n        return\\n            _isOk(\\n                isVaultUnsafeOSM(\\n                    _vaultID,\\n                    _priceOracle,\\n                    _oraclePeekPayload,\\n                    _minPeekLimit\\n                )\\n            ) ||\\n                _isOk(\\n                    isVaultUnsafeOSM(\\n                        _vaultID,\\n                        _priceOracle,\\n                        _oraclePeepPayload,\\n                        _minPeepLimit\\n                    )\\n                )\\n                ? OK\\n                : \\\"MakerVaultNotUnsafe\\\";\\n    }\\n\\n    /// @notice Specific implementation of this Condition's ok function\\n    /// @dev The price oracle must return (bytes32, bool).\\n    /// @param _vaultID The id of the Maker vault\\n    /// @param _priceOracle The price oracle contract to supply the collateral price\\n    ///  e.g. Maker's ETH/USD oracle for ETH collateral pricing.\\n    /// @param _oraclePayload The data for making the staticcall to the oracle's read\\n    ///  method e.g. the selector for MakerOracle's read fn.\\n    /// @param _minLimit The minimum collateral ratio measured in the price\\n    /// of the collateral as specified by the _priceOracle.\\n    /// @return OK if the Maker Vault is unsafe, otherwise some error message.\\n    function isVaultUnsafeOSM(\\n        uint256 _vaultID,\\n        address _priceOracle,\\n        bytes memory _oraclePayload,\\n        uint256 _minLimit\\n    ) public view virtual returns (string memory) {\\n        return\\n            IConditionMakerVaultUnsafeOSM(CONDITION_MAKER_VAULT_UNSAFE_OSM)\\n                .isVaultUnsafeOSM(\\n                _vaultID,\\n                _priceOracle,\\n                _oraclePayload,\\n                _minLimit\\n            );\\n    }\\n\\n    /// @notice Convenience function for off-chain _conditionData encoding\\n    /// @dev Use the return for your Task's Condition.data field off-chain.\\n    /// @return The encoded payload for your Task's Condition.data field.\\n    function getConditionData(\\n        uint256 _vaultId,\\n        address _priceOracle,\\n        bytes calldata _oraclePeekPayload,\\n        bytes calldata _oraclePeepPayload,\\n        uint256 _minPeekLimit,\\n        uint256 _minPeepLimit\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                this.isVaultUnsafeOSM.selector,\\n                _vaultId,\\n                _priceOracle,\\n                _oraclePeekPayload,\\n                _oraclePeepPayload,\\n                _minPeekLimit,\\n                _minPeepLimit\\n            );\\n    }\\n\\n    function _isOk(string memory _isSafe) internal view returns (bool) {\\n        return\\n            keccak256(abi.encodePacked(_isSafe)) ==\\n            keccak256(abi.encodePacked(OK));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/gelato/IGelatoGasPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IGelatoGasPriceOracle {\\n    function latestAnswer() external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/gelato/conditions/IConditionMakerVaultUnsafeOSM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConditionMakerVaultUnsafeOSM {\\n    function isVaultUnsafeOSM(\\n        uint256 _vaultID,\\n        address _priceOracle,\\n        bytes memory _oraclePayload,\\n        uint256 _minColRatio\\n    ) external view returns (string memory);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_oraclePeekPayload\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_oraclePeepPayload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_minPeekLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPeepLimit\",\"type\":\"uint256\"}],\"name\":\"getConditionData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_oraclePayload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_minLimit\",\"type\":\"uint256\"}],\"name\":\"isVaultUnsafeOSM\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_conditionData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ok\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConditionMakerVaultUnSafePosition","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":""}]}