{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n   \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n   \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    \r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public  onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary BasisPoints {\r\n    using SafeMath for uint;\r\n\r\n    uint constant private BASIS_POINTS = 10000;\r\n\r\n    function mulBP(uint amt, uint bp) internal pure returns (uint) {\r\n        if (amt == 0) return 0;\r\n        return amt.mul(bp).div(BASIS_POINTS);\r\n    }\r\n\r\n    function divBP(uint amt, uint bp) internal pure returns (uint) {\r\n        require(bp > 0, \"Cannot divide by zero.\");\r\n        if (amt == 0) return 0;\r\n        return amt.mul(BASIS_POINTS).div(bp);\r\n    }\r\n\r\n    function addBP(uint amt, uint bp) internal pure returns (uint) {\r\n        if (amt == 0) return 0;\r\n        if (bp == 0) return amt;\r\n        return amt.add(mulBP(amt, bp));\r\n    }\r\n\r\n    function subBP(uint amt, uint bp) internal pure returns (uint) {\r\n        if (amt == 0) return 0;\r\n        if (bp == 0) return amt;\r\n        return amt.sub(mulBP(amt, bp));\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Staking is Context, Ownable {\r\n    using BasisPoints for uint;\r\n    using SafeMath for uint;\r\n\r\n    uint256 constant internal DISTRIBUTION_MULTIPLIER = 2 ** 64;\r\n\r\n    IERC20 private token;\r\n\r\n    mapping(address => uint) public stakeValue;\r\n    mapping(address => int) public stakerPayouts;\r\n\r\n    uint public totalDistributions;\r\n    uint public totalStaked;\r\n    uint public totalStakers;\r\n    uint public profitPerShare;\r\n    uint private emptyStakeTokens; //These are eth given to the contract when there are no stakers.\r\n\r\n    uint public startTime;\r\n\r\n    event OnDistribute(address sender, uint amountSent);\r\n    event OnStake(address sender, uint amount);\r\n    event OnUnstake(address sender, uint amount);\r\n    event OnReinvest(address sender, uint amount);\r\n    event OnWithdraw(address sender, uint amount);\r\n\r\n    struct Checkpoint {\r\n      uint128 fromBlock;\r\n      uint128 value;\r\n    }\r\n\r\n    mapping(address => Checkpoint[]) internal stakeValueHistory;\r\n\r\n    Checkpoint[] internal totalStakedHistory;\r\n\r\n    modifier whenStakingActive {\r\n        require(startTime != 0 && now > startTime, \"Staking not yet started.\");\r\n        _;\r\n    }\r\n\r\n    constructor(IERC20 _token) public {\r\n        token = _token;\r\n    }\r\n\r\n    function setStartTime(uint _startTime) external onlyOwner {\r\n        startTime = _startTime;\r\n    }\r\n\r\n    function stake(uint amount) public whenStakingActive {\r\n        require(token.balanceOf(msg.sender) >= amount, \"Cannot stake more Tokens than you hold unstaked.\");\r\n        if (stakeValue[msg.sender] == 0) totalStakers = totalStakers.add(1);\r\n        _addStake(amount);\r\n        require(token.transferFrom(msg.sender, address(this), amount), \"Stake failed due to failed transfer.\");\r\n        emit OnStake(msg.sender, amount);\r\n    }\r\n\r\n    function unstake(uint amount) external whenStakingActive {\r\n        require(stakeValue[msg.sender] >= amount, \"Cannot unstake more Token than you have staked.\");\r\n        // Update staker's history\r\n        _updateCheckpointValueAtNow(\r\n        stakeValueHistory[msg.sender],\r\n        stakeValue[msg.sender],\r\n        stakeValue[msg.sender].sub(amount)\r\n        );\r\n\r\n        // Update total staked history\r\n        _updateCheckpointValueAtNow(\r\n        totalStakedHistory,\r\n        totalStaked,\r\n        totalStaked.sub(amount)\r\n        );\r\n        \r\n        //must withdraw all dividends, to prevent overflows\r\n        withdraw(dividendsOf(msg.sender));\r\n        if (stakeValue[msg.sender] == amount) totalStakers = totalStakers.sub(1);\r\n        totalStaked = totalStaked.sub(amount);\r\n        stakeValue[msg.sender] = stakeValue[msg.sender].sub(amount);\r\n\r\n        stakerPayouts[msg.sender] = uintToInt(profitPerShare.mul(stakeValue[msg.sender]));\r\n        \r\n        require(token.transferFrom(address(this), msg.sender, amount), \"Unstake failed due to failed transfer.\");\r\n        emit OnUnstake(msg.sender, amount);\r\n    }\r\n\r\n    function withdraw(uint amount) public whenStakingActive {\r\n        require(dividendsOf(msg.sender) >= amount, \"Cannot withdraw more dividends than you have earned.\");\r\n        stakerPayouts[msg.sender] = stakerPayouts[msg.sender] + uintToInt(amount.mul(DISTRIBUTION_MULTIPLIER));\r\n        msg.sender.transfer(amount);\r\n        emit OnWithdraw(msg.sender, amount);\r\n    }\r\n\r\n    function distribute() external payable {\r\n        uint amount = msg.value;\r\n        if(amount > 0){\r\n            totalDistributions = totalDistributions.add(amount);\r\n            _increaseProfitPerShare(amount);\r\n            emit OnDistribute(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    function dividendsOf(address staker) public view returns (uint) {\r\n        int divPayout = uintToInt(profitPerShare.mul(stakeValue[staker]));\r\n        require(divPayout >= stakerPayouts[staker], \"dividend calc overflow\");\r\n        return uint(divPayout - stakerPayouts[staker])\r\n            .div(DISTRIBUTION_MULTIPLIER);\r\n    }\r\n\r\n    function totalStakedAt(uint _blockNumber) public view returns(uint) {\r\n        // If we haven't initialized history yet\r\n        if (totalStakedHistory.length == 0) {\r\n            // Use the existing value\r\n            return totalStaked;\r\n        } else {\r\n            // Binary search history for the proper staked amount\r\n            return _getCheckpointValueAt(\r\n                totalStakedHistory,\r\n                _blockNumber\r\n            );\r\n        }\r\n    }\r\n\r\n    function stakeValueAt(address _owner, uint _blockNumber) public view returns (uint) {\r\n        // If we haven't initialized history yet\r\n        if (stakeValueHistory[_owner].length == 0) {\r\n            // Use the existing latest value\r\n            return stakeValue[_owner];\r\n        } else {\r\n            // Binary search history for the proper staked amount\r\n            return _getCheckpointValueAt(stakeValueHistory[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    function uintToInt(uint val) internal pure returns (int) {\r\n        if (val >= uint(-1).div(2)) {\r\n            require(false, \"Overflow. Cannot convert uint to int.\");\r\n        } else {\r\n            return int(val);\r\n        }\r\n    }\r\n\r\n    function _addStake(uint _amount) internal {\r\n        // Update staker's history\r\n        _updateCheckpointValueAtNow(\r\n        stakeValueHistory[msg.sender],\r\n        stakeValue[msg.sender],\r\n        stakeValue[msg.sender].add(_amount)\r\n        );\r\n\r\n        // Update total staked history\r\n        _updateCheckpointValueAtNow(\r\n        totalStakedHistory,\r\n        totalStaked,\r\n        totalStaked.add(_amount)\r\n        );\r\n\r\n        totalStaked = totalStaked.add(_amount);\r\n        stakeValue[msg.sender] = stakeValue[msg.sender].add(_amount);\r\n        \r\n        uint payout = profitPerShare.mul(_amount);\r\n        stakerPayouts[msg.sender] = stakerPayouts[msg.sender] + uintToInt(payout);\r\n    }\r\n\r\n    function _increaseProfitPerShare(uint amount) internal {\r\n        if (totalStaked != 0) {\r\n            if (emptyStakeTokens != 0) {\r\n                amount = amount.add(emptyStakeTokens);\r\n                emptyStakeTokens = 0;\r\n            }\r\n            profitPerShare = profitPerShare.add(amount.mul(DISTRIBUTION_MULTIPLIER).div(totalStaked));\r\n        } else {\r\n            emptyStakeTokens = emptyStakeTokens.add(amount);\r\n        }\r\n    }\r\n\r\n    function _getCheckpointValueAt(Checkpoint[] storage checkpoints, uint _block) view internal returns (uint) {\r\n    // This case should be handled by caller\r\n    if (checkpoints.length == 0)\r\n      return 0;\r\n\r\n    // Use the latest checkpoint\r\n    if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n      return checkpoints[checkpoints.length-1].value;\r\n\r\n    // Use the oldest checkpoint\r\n    if (_block < checkpoints[0].fromBlock)\r\n      return checkpoints[0].value;\r\n\r\n    // Binary search of the value in the array\r\n    uint min = 0;\r\n    uint max = checkpoints.length-1;\r\n    while (max > min) {\r\n      uint mid = (max + min + 1) / 2;\r\n      if (checkpoints[mid].fromBlock<=_block) {\r\n        min = mid;\r\n      } else {\r\n        max = mid-1;\r\n      }\r\n    }\r\n    return checkpoints[min].value;\r\n  }\r\n\r\n  function _updateCheckpointValueAtNow(\r\n    Checkpoint[] storage checkpoints,\r\n    uint _oldValue,\r\n    uint _value\r\n  ) internal {\r\n    require(_value <= uint128(-1));\r\n    require(_oldValue <= uint128(-1));\r\n\r\n    if (checkpoints.length == 0) {\r\n      Checkpoint storage genesis = checkpoints[checkpoints.length++];\r\n      genesis.fromBlock = uint128(block.number - 1);\r\n      genesis.value = uint128(_oldValue);\r\n    }\r\n\r\n    if (checkpoints[checkpoints.length - 1].fromBlock < block.number) {\r\n      Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\r\n      newCheckPoint.fromBlock = uint128(block.number);\r\n      newCheckPoint.value = uint128(_value);\r\n    } else {\r\n      Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\r\n      oldCheckPoint.value = uint128(_value);\r\n    }\r\n  }\r\n  \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSent\",\"type\":\"uint256\"}],\"name\":\"OnDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OnReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OnStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OnUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OnWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"stakeValueAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerPayouts\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDistributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalStakedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ec56077f47c26d79a9b169cfbdacf28d0da81d5f","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6c5aec21fe49711d5127c521a82a2bba69f155bf9f39895e5f947a3bbf4b3c6d"}]}