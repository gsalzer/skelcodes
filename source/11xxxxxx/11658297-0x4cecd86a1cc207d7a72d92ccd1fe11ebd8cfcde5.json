{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\ninterface iERC20 {\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n\r\n    function increaseAllowance(address spender, uint addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint subtractedValue) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\nlibrary TimeLineValue {\r\n\r\n    struct Data {\r\n                uint timeInterval_final;\r\n                uint[] timeList;\r\n                mapping(uint => uint) valueMapping;\r\n    }\r\n\r\n        function init(Data storage self, uint interval, uint t, uint value) internal {\r\n        uint tz = t / interval * interval;\r\n\r\n        self.timeInterval_final = interval;\r\n        self.timeList.push(tz);\r\n        self.valueMapping[tz] = value;\r\n    }\r\n\r\n        function increase(Data storage self, uint addValue) internal returns(uint) {\r\n\r\n                uint t = now / self.timeInterval_final * self.timeInterval_final;\r\n\r\n                                                \r\n                uint latestTime = self.timeList[self.timeList.length - 1];\r\n\r\n                if (latestTime == t) {\r\n            self.valueMapping[latestTime] += addValue;\r\n            return self.valueMapping[latestTime];\r\n        } else {\r\n            self.timeList.push(t);\r\n            self.valueMapping[t] = (self.valueMapping[latestTime] + addValue);\r\n            return self.valueMapping[t];\r\n        }\r\n    }\r\n\r\n        function decrease(Data storage self, uint subValue) internal returns(uint) {\r\n\r\n                uint t = now / self.timeInterval_final * self.timeInterval_final;\r\n\r\n                \r\n                uint latestTime = self.timeList.length == 0 ? t : self.timeList[self.timeList.length - 1];\r\n\r\n                require(self.valueMapping[latestTime] >= subValue, \"InsufficientQuota\");\r\n\r\n                if (latestTime == t) {\r\n            self.valueMapping[latestTime] -= subValue;\r\n            return self.valueMapping[latestTime];\r\n        } else {\r\n            self.timeList.push(t);\r\n            self.valueMapping[t] = (self.valueMapping[latestTime] - subValue);\r\n            return self.valueMapping[t];\r\n        }\r\n\r\n    }\r\n\r\n        function forceSet(Data storage self, uint value) internal {\r\n\r\n                uint t = now / self.timeInterval_final * self.timeInterval_final;\r\n\r\n                                        \r\n                uint latestTime = self.timeList[self.timeList.length - 1];\r\n\r\n                if (latestTime == t) {\r\n            self.valueMapping[latestTime] = value;\r\n        } else {\r\n            self.timeList.push(t);\r\n            self.valueMapping[t] = value;\r\n        }\r\n    }\r\n\r\n        function latestValue(Data storage self) internal view returns (uint) {\r\n        uint[] storage s = self.timeList;\r\n        if ( s.length <= 0 ) {\r\n            return 0;\r\n        }\r\n        return self.valueMapping[s[s.length - 1]];\r\n    }\r\n\r\n        function bestMatchValue(Data storage self, uint time) internal view returns(uint) {\r\n\r\n        uint[] storage s = self.timeList;\r\n\r\n                if (s.length <= 0 || time < s[0]) {\r\n            return 0;\r\n        }\r\n\r\n                if ( time >= s[s.length - 1] ) {\r\n            return self.valueMapping[s[s.length - 1]];\r\n        }\r\n\r\n                uint t = time / self.timeInterval_final * self.timeInterval_final;\r\n\r\n                for (uint d = t; d >= t - 7 * self.timeInterval_final; d -= self.timeInterval_final ) {\r\n            if ( self.valueMapping[d] > 0 ) {\r\n                return self.valueMapping[d];\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n}\r\n\r\ncontract KTimeController {\r\n\r\n    uint public offsetTime;\r\n\r\n    function timestemp() external view returns (uint) {\r\n        return now + offsetTime;\r\n    }\r\n\r\n    function increaseTime(uint t) external {\r\n        offsetTime += t;\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\ncontract KOwnerable {\r\n\r\n        address[] internal _authAddress = [\r\n        address(0x013a0Fe4a79afFF253Fd0ACBDC891384EBbD0630)\r\n    ];\r\n\r\n        address[] public KContractOwners;\r\n\r\n        bool private _call_locked;\r\n\r\n    constructor() public {\r\n        KContractOwners.push(msg.sender);\r\n        _authAddress.push(msg.sender);\r\n    }\r\n\r\n        function KAuthAddresses() external view returns (address[] memory) {\r\n        return _authAddress;\r\n    }\r\n\r\n            function KAddAuthAddress(address auther) external KOwnerOnly {\r\n        _authAddress.push(auther);\r\n    }\r\n\r\n            function KDelAuthAddress(address auther) external KOwnerOnly {\r\n        for (uint i = 0; i < _authAddress.length; i++) {\r\n            if (_authAddress[i] == auther) {\r\n                for (uint j = 0; j < _authAddress.length - 1; j++) {\r\n                    _authAddress[j] = _authAddress[j+1];\r\n                }\r\n                delete _authAddress[_authAddress.length - 1];\r\n                _authAddress.pop();\r\n                return ;\r\n            }\r\n        }\r\n    }\r\n\r\n        modifier KOwnerOnly() {\r\n        bool exist = false;\r\n        for ( uint i = 0; i < KContractOwners.length; i++ ) {\r\n            if ( KContractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n        require(exist, 'NotAuther'); _;\r\n    }\r\n\r\n        modifier KOwnerOnlyAPI() {\r\n        bool exist = false;\r\n        for ( uint i = 0; i < KContractOwners.length; i++ ) {\r\n            if ( KContractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n        require(exist, 'NotAuther'); _;\r\n    }\r\n\r\n        modifier KRejectContractCall() {\r\n        uint256 size;\r\n        address payable safeAddr = msg.sender;\r\n        assembly {size := extcodesize(safeAddr)}\r\n        require( size == 0, \"Sender Is Contract\" );\r\n        _;\r\n    }\r\n\r\n        modifier KDAODefense() {\r\n        require(!_call_locked, \"DAO_Warning\");\r\n        _call_locked = true;\r\n        _;\r\n        _call_locked = false;\r\n    }\r\n\r\n        modifier KDelegateMethod() {\r\n        bool exist = false;\r\n        for (uint i = 0; i < _authAddress.length; i++) {\r\n            if ( _authAddress[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n        require(exist, \"PermissionDeny\"); _;\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory c) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte( uint8(48 + i % 10) );\r\n            i /= 10;\r\n        }\r\n        c = string(bstr);\r\n    }\r\n}\r\n\r\n\r\ncontract KPausable is KOwnerable {\r\n\r\n    event Paused(address account);\r\n\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool public paused;\r\n\r\n\r\n    constructor () internal {\r\n        paused = false;\r\n    }\r\n\r\n\r\n    modifier KWhenNotPaused() {\r\n        require(!paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n\r\n    modifier KWhenPaused() {\r\n        require(paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n\r\n    function Pause() public KOwnerOnly {\r\n        paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n\r\n    function Unpause() public KOwnerOnly {\r\n        paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\ncontract KDebug is KPausable {\r\n\r\n    KTimeController internal debugTimeController;\r\n\r\n    function timestempZero() internal view returns (uint) {\r\n        return timestemp() / 1 days * 1 days;\r\n    }\r\n\r\n    function timestemp() internal view returns (uint) {\r\n        if ( debugTimeController != KTimeController(0) ) {\r\n            return debugTimeController.timestemp();\r\n        } else {\r\n            return now;\r\n        }\r\n    }\r\n\r\n    function KSetDebugTimeController(address tc) external KOwnerOnly {\r\n        debugTimeController = KTimeController(tc);\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\ncontract KStorage is KDebug {\r\n\r\n        address public KImplementAddress;\r\n\r\n        function SetKImplementAddress(address impl) external KOwnerOnly {\r\n        KImplementAddress = impl;\r\n    }\r\n\r\n        function () external {\r\n        address impl_address = KImplementAddress;\r\n        assembly {\r\n            calldatacopy(0x0, 0x0, calldatasize())\r\n            let success := delegatecall(sub(gas(), 10000), impl_address, 0x0, calldatasize(), 0, 0)\r\n            let retSz := returndatasize()\r\n            returndatacopy(0, 0, retSz)\r\n            switch success\r\n            case 0 {\r\n                revert(0, retSz)\r\n            }\r\n            default {\r\n                return(0, retSz)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract KStoragePayable is KDebug {\r\n\r\n        address public KImplementAddress;\r\n\r\n        function SetKImplementAddress(address impl) external KOwnerOnly {\r\n        KImplementAddress = impl;\r\n    }\r\n\r\n        function () external payable {\r\n        address impl_address = KImplementAddress;\r\n        assembly {\r\n\r\n                        if eq(calldatasize(), 0) {\r\n                return(0, 0)\r\n            }\r\n\r\n            calldatacopy(0x0, 0x0, calldatasize())\r\n            let success := delegatecall(gas(), impl_address, 0x0, calldatasize(), 0, 0)\r\n            let retSz := returndatasize()\r\n            returndatacopy(0, 0, retSz)\r\n            switch success\r\n            case 0 {\r\n                revert(0, retSz)\r\n            }\r\n            default {\r\n                return(0, retSz)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\ncontract KState {\r\n\r\n    address private _KDeveloper;\r\n    address internal _KIMPLAddress;\r\n\r\n    address[] _KAuthAddress;\r\n\r\n    address payable public _KDefaultReciver = address(0x2E5600376D4F07F13Ea69Caf416FB2F7B6659897);\r\n\r\n    address payable[] public _KContractOwners = [\r\n        address(0xc99D13544297d5baD9e0b0Ca0E94A4E614312F33)\r\n    ];\r\n\r\n    bool public _KContractBroken;\r\n    mapping (address => bool) _KWithdrawabledAddress;\r\n\r\n    constructor() public {\r\n        _KDeveloper = msg.sender;\r\n        _KContractOwners.push(msg.sender);\r\n    }\r\n\r\n    modifier KWhenBroken() {\r\n        require(_KContractBroken); _;\r\n    }\r\n\r\n    modifier KWhenNotBroken() {\r\n        require(!_KContractBroken); _;\r\n    }\r\n\r\n    modifier KOwnerOnly() {\r\n\r\n        bool exist = false;\r\n\r\n        for ( uint i = 0; i < _KContractOwners.length; i++ ) {\r\n            if ( _KContractOwners[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function KSetContractBroken(bool broken) external KOwnerOnly {\r\n        _KContractBroken = broken;\r\n    }\r\n\r\n    modifier KDAODefense() {\r\n        uint256 size;\r\n        address payable safeAddr = msg.sender;\r\n        assembly {size := extcodesize(safeAddr)}\r\n        require( size == 0, \"DAO_Warning\" );\r\n        _;\r\n    }\r\n\r\n    modifier KAPIMethod() {\r\n\r\n        bool exist = false;\r\n\r\n        for (uint i = 0; i < _KAuthAddress.length; i++) {\r\n            if ( _KAuthAddress[i] == msg.sender ) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(exist); _;\r\n    }\r\n\r\n    function KAuthAddresses() external view returns (address[] memory authAddr) {\r\n        return _KAuthAddress;\r\n    }\r\n\r\n    function KAddAuthAddress(address _addr) external KOwnerOnly {\r\n        _KAuthAddress.push(_addr);\r\n    }\r\n\r\n    modifier KDeveloperOnly {\r\n        require(msg.sender == _KDeveloper); _;\r\n    }\r\n\r\n    function KSetImplAddress(address impl) external KDeveloperOnly {\r\n        _KIMPLAddress = impl;\r\n    }\r\n\r\n    function KGetImplAddress() external view KDeveloperOnly returns (address) {\r\n        return _KIMPLAddress;\r\n    }\r\n\r\n}\r\n\r\ncontract KDoctor is KState {\r\n    modifier write {_;}\r\n}\r\n\r\ncontract KContract is KState {\r\n\r\n    modifier write {\r\n\r\n        if ( _KIMPLAddress != address(0x0) ) {\r\n\r\n            (, bytes memory ret) = address(_KIMPLAddress).delegatecall(msg.data);\r\n\r\n            assembly {\r\n                return( add(ret, 0x20), mload(ret) )\r\n            }\r\n\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.4.22 <0.7.0;\r\n\r\nlibrary UserRelation {\r\n\r\n    struct MainDB {\r\n\r\n        uint totalAddresses;\r\n                mapping ( address => address ) _recommerMapping;\r\n                mapping ( address => address[] ) _recommerList;\r\n                mapping ( address => uint256 ) _recommerCountMapping;\r\n                mapping ( bytes6 => address ) _shortCodeMapping;\r\n                mapping ( address => bytes6 ) _addressShotCodeMapping;\r\n    }\r\n\r\n    function Init(MainDB storage self) internal {\r\n\r\n        address rootAddr = address(0xdead);\r\n        bytes6 rootCode = 0x303030303030;\r\n\r\n                self._recommerMapping[rootAddr] = address(0xdeaddead);\r\n        self._shortCodeMapping[rootCode] = rootAddr;\r\n        self._addressShotCodeMapping[rootAddr] = rootCode;\r\n    }\r\n\r\n        function GetIntroducer( MainDB storage self, address _owner ) internal view returns (address) {\r\n        return self._recommerMapping[_owner];\r\n    }\r\n\r\n        function RecommendList( MainDB storage self, address _owner ) internal view returns ( address[] memory list, uint256 len ) {\r\n        return (self._recommerList[_owner], self._recommerList[_owner].length );\r\n    }\r\n\r\n        function RegisterShortCode( MainDB storage self, address _owner, bytes6 shortCode ) internal returns (bool) {\r\n\r\n                if ( self._shortCodeMapping[shortCode] != address(0x0) ) {\r\n            return false;\r\n        }\r\n\r\n                if ( self._addressShotCodeMapping[_owner] != bytes6(0x0) ) {\r\n            return false;\r\n        }\r\n\r\n                self._shortCodeMapping[shortCode] = _owner;\r\n        self._addressShotCodeMapping[_owner] = shortCode;\r\n\r\n        return true;\r\n    }\r\n\r\n        function ShortCodeToAddress( MainDB storage self, bytes6 shortCode ) internal view returns (address) {\r\n        return self._shortCodeMapping[shortCode];\r\n    }\r\n\r\n        function AddressToShortCode( MainDB storage self, address addr ) internal view returns (bytes6) {\r\n        return self._addressShotCodeMapping[addr];\r\n    }\r\n\r\n                            function AddRelation( MainDB storage self, address owner, address recommer ) internal returns (int) {\r\n\r\n\r\n        if ( recommer == owner )  {\r\n            require(false, \"-1\");\r\n            return -1;\r\n        }\r\n\r\n                require( recommer != owner, \"-1\" );\r\n\r\n                require( self._recommerMapping[owner] == address(0x0), \"-2\");\r\n\r\n                if ( recommer != address(0xdead) ) {\r\n            require( self._recommerMapping[recommer] != address(0x0), \"-3\");\r\n        }\r\n\r\n                self._recommerMapping[owner] = recommer;\r\n\r\n        self._recommerList[recommer].push(owner);\r\n\r\n        self._recommerCountMapping[recommer] ++;\r\n\r\n        self.totalAddresses++;\r\n\r\n        return 0;\r\n    }\r\n\r\n                                function AddRelationEx( MainDB storage self, address owner, address recommer, bytes6 regShoutCode ) internal returns (int) {\r\n\r\n        if ( !RegisterShortCode(self, owner, regShoutCode) ) {\r\n            return -4;\r\n        }\r\n\r\n        return AddRelation(self, owner, recommer);\r\n    }\r\n\r\n        function TeamMemberTotal( MainDB storage self, address _addr ) internal view returns (uint256) {\r\n        return self._recommerCountMapping[_addr];\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.4.22 <0.7.0;\r\n\r\n\r\nlibrary Achievement {\r\n\r\n    using UserRelation for UserRelation.MainDB;\r\n\r\n    struct MainDB {\r\n\r\n                        uint latestVersion;\r\n\r\n                uint currVersion;\r\n\r\n                mapping(uint => mapping(address => uint) ) achievementMapping;\r\n\r\n                mapping ( address => uint256 ) _vaildMemberCountMapping;\r\n\r\n                mapping ( address => bool ) _vaildMembersMapping;\r\n\r\n                mapping ( address => uint256 ) _despositTotalMapping;\r\n    }\r\n\r\n        function AppendAchievement( MainDB storage self, UserRelation.MainDB storage userRelation, address owner, uint value )\r\n    internal {\r\n\r\n        require(value > 0, \"ValueIsZero\");\r\n\r\n        for (\r\n            address parent = owner;\r\n            parent != address(0x0) && parent != address(0xdead);\r\n            parent = userRelation.GetIntroducer(parent)\r\n        ) {\r\n            self.achievementMapping[self.currVersion][parent] += value;\r\n        }\r\n\r\n    }\r\n\r\n        function DivestmentAchievement( MainDB storage self, UserRelation.MainDB storage userRelation, address owner, uint value)\r\n    internal {\r\n\r\n        for (\r\n            address parent = owner;\r\n            parent != address(0x0) && parent != address(0xdaed);\r\n            parent = userRelation.GetIntroducer(parent)\r\n        ) {\r\n            if ( self.achievementMapping[self.currVersion][parent] < value ) {\r\n                self.achievementMapping[self.currVersion][parent] = 0;\r\n            } else {\r\n                self.achievementMapping[self.currVersion][parent] -= value;\r\n            }\r\n        }\r\n    }\r\n\r\n    function AchievementValueOfOwner( MainDB storage self, address owner )\r\n    internal view\r\n    returns (uint) {\r\n        return self.achievementMapping[self.currVersion][owner];\r\n    }\r\n\r\n        function AchievementDistribution( MainDB storage self, UserRelation.MainDB storage userRelation, address owner)\r\n    internal view\r\n    returns (\r\n                uint totalSum,\r\n                uint large,\r\n                uint len,\r\n                address[] memory addrs,\r\n                uint[] memory values\r\n    ) {\r\n        totalSum = self.achievementMapping[self.currVersion][owner];\r\n\r\n                (addrs, len) = userRelation.RecommendList(owner);\r\n\r\n        for ( uint i = 0; i < len; i++ ) {\r\n\r\n            values[i] = self.achievementMapping[self.currVersion][addrs[i]];\r\n\r\n            if ( self.achievementMapping[self.currVersion][addrs[i]] > large ) {\r\n                large = self.achievementMapping[self.currVersion][addrs[i]];\r\n            }\r\n        }\r\n    }\r\n\r\n        function AchievementDynamicValue( MainDB storage self, UserRelation.MainDB storage userRelation, address owner)\r\n    internal view\r\n    returns (\r\n        uint v\r\n    ) {\r\n                uint large;\r\n        uint largeId;\r\n        (address[] memory addrs, uint len) = userRelation.RecommendList(owner);\r\n        uint[] memory values = new uint[](len);\r\n\r\n        for ( uint i = 0; i < len; i++ ) {\r\n\r\n            values[i] = self.achievementMapping[self.currVersion][addrs[i]];\r\n\r\n            if ( self.achievementMapping[self.currVersion][addrs[i]] > large ) {\r\n                large = self.achievementMapping[self.currVersion][addrs[i]];\r\n                largeId = i;\r\n            }\r\n        }\r\n\r\n        for ( uint i = 0; i < len; i++ ) {\r\n\r\n            if ( i != largeId ) {\r\n                                if ( values[i] > 10000 ether ) {\r\n\r\n                    v += ((values[i]) / 1 ether) + 90000;\r\n\r\n                } else {\r\n\r\n                    v += (values[i] / 1 ether) * 10;\r\n                }\r\n\r\n            } else {\r\n\r\n                                v += (values[i] / 1 ether) / 1000;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n        function ValidMembersCountOf( MainDB storage self, address _addr ) internal view returns (uint256) {\r\n        return self._vaildMemberCountMapping[_addr];\r\n    }\r\n\r\n    function InvestTotalEtherOf( MainDB storage self, address _addr ) internal view returns (uint256) {\r\n        return self._despositTotalMapping[_addr];\r\n    }\r\n\r\n    function DirectValidMembersCount( MainDB storage self, UserRelation.MainDB storage userRelation, address _addr ) internal view returns (uint256) {\r\n\r\n        uint256 count = 0;\r\n        address[] storage rlist = userRelation._recommerList[_addr];\r\n        for ( uint i = 0; i < rlist.length; i++ ) {\r\n            if ( self._vaildMembersMapping[rlist[i]] ) {\r\n                count ++;\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n        function IsValidMember( MainDB storage self, address _addr ) internal view returns (bool) {\r\n        return self._vaildMembersMapping[_addr];\r\n    }\r\n\r\n    function MarkValidAddress( MainDB storage self, UserRelation.MainDB storage userRelation, address _addr, uint256 _evalue ) external {\r\n\r\n        if ( self._vaildMembersMapping[_addr] == false ) {\r\n\r\n                                    address parent = userRelation._recommerMapping[_addr];\r\n\r\n            for ( uint i = 0; i < 15; i++ ) {\r\n\r\n                self._vaildMemberCountMapping[parent] ++;\r\n\r\n                parent = userRelation._recommerMapping[parent];\r\n\r\n                if ( parent == address(0x0) ) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            self._vaildMembersMapping[_addr] = true;\r\n        }\r\n\r\n                self._despositTotalMapping[_addr] += _evalue;\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.6.0;\r\n\r\n\r\n\r\ncontract Recommend is KContract {\r\n\r\n    UserRelation.MainDB _userRelation;\r\n    using UserRelation for UserRelation.MainDB;\r\n\r\n    constructor() public {\r\n        _userRelation.Init();\r\n    }\r\n\r\n    function GetIntroducer( address _owner ) external view returns (address) {\r\n        return _userRelation.GetIntroducer(_owner);\r\n    }\r\n\r\n    function RecommendList( address _owner) external view returns ( address[] memory list, uint256 len ) {\r\n        return _userRelation.RecommendList(_owner);\r\n    }\r\n\r\n    function ShortCodeToAddress( bytes6 shortCode ) external view returns (address) {\r\n        return _userRelation.ShortCodeToAddress(shortCode);\r\n    }\r\n\r\n    function AddressToShortCode( address _addr ) external view returns (bytes6) {\r\n        return _userRelation.AddressToShortCode(_addr);\r\n    }\r\n\r\n    function TeamMemberTotal( address _addr ) external view returns (uint256) {\r\n        return _userRelation.TeamMemberTotal(_addr);\r\n    }\r\n\r\n    function RegisterShortCode( bytes6 shortCode ) external write {\r\n        require(_userRelation.RegisterShortCode(msg.sender, shortCode));\r\n    }\r\n\r\n    function BindRelation( address _recommer ) external write {\r\n        require( _userRelation.AddRelation(msg.sender, _recommer) >= 0, \"-1\" );\r\n    }\r\n\r\n    function BindRelationEx( address _recommer, bytes6 shortCode ) external write{\r\n        require( _userRelation.AddRelationEx(msg.sender, _recommer, shortCode) >= 0, \"-1\" );\r\n    }\r\n\r\n    function AddressesCount() external view returns (uint) {\r\n        return _userRelation.totalAddresses;\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.6.0;\r\n\r\n\r\n\r\n\r\ncontract Relations is Recommend {\r\n\r\n    Achievement.MainDB _achievementer;\r\n    using Achievement for Achievement.MainDB;\r\n\r\n        function API_AppendAchievement( address owner, uint value )\r\n    external write KAPIMethod {\r\n        _achievementer.AppendAchievement( _userRelation, owner, value );\r\n    }\r\n\r\n        function API_DivestmentAchievement( address owner, uint value)\r\n    external write KAPIMethod {\r\n        _achievementer.DivestmentAchievement( _userRelation, owner, value );\r\n    }\r\n\r\n        function AchievementValueOf( address owner )\r\n    external view\r\n    returns (uint) {\r\n        return _achievementer.AchievementValueOfOwner(owner);\r\n    }\r\n\r\n        function AchievementDistributionOf( address owner)\r\n    external view\r\n    returns (\r\n                uint totalSum,\r\n                uint large,\r\n                uint len,\r\n                address[] memory addrs,\r\n                uint[] memory values\r\n    ) {\r\n        return _achievementer.AchievementDistribution(_userRelation, owner );\r\n    }\r\n\r\n        function AchievementDynamicValue( address owner)\r\n    external view\r\n    returns ( uint ) {\r\n        return _achievementer.AchievementDynamicValue(_userRelation, owner);\r\n    }\r\n\r\n        function ValidMembersCountOf( address _addr ) external view returns (uint256) {\r\n        return _achievementer.ValidMembersCountOf(_addr);\r\n    }\r\n\r\n    function InvestTotalEtherOf( address _addr ) external view returns (uint256) {\r\n        return _achievementer.InvestTotalEtherOf(_addr);\r\n    }\r\n\r\n    function DirectValidMembersCount( address _addr ) external view returns (uint256) {\r\n        return _achievementer.DirectValidMembersCount(_userRelation, _addr);\r\n    }\r\n\r\n        function IsValidMember( address _addr ) external view returns (bool) {\r\n        return _achievementer.IsValidMember(_addr);\r\n    }\r\n\r\n    function TotalAddresses() external view returns (uint) {\r\n        return _userRelation.totalAddresses;\r\n    }\r\n\r\n        function API_MarkValid( address _addr, uint256 _evalue ) external KAPIMethod {\r\n        return _achievementer.MarkValidAddress(_userRelation, _addr, _evalue);\r\n    }\r\n\r\n        function Developer_VersionInfo() external view returns (uint latest, uint curr) {\r\n        return (_achievementer.latestVersion, _achievementer.currVersion);\r\n    }\r\n\r\n    function Developer_PushNewDataVersion() external write KDeveloperOnly {\r\n        _achievementer.latestVersion++;\r\n    }\r\n\r\n    function Developer_SetDataVersion(uint v) external write KDeveloperOnly {\r\n        _achievementer.currVersion = v;\r\n    }\r\n\r\n    function Developer_WriteRelation( address _parent, address[] calldata _children, bytes6[] calldata _shortCode, bool force ) external write KDeveloperOnly {\r\n\r\n        for ( uint i = 0; i < _children.length; i++ ) {\r\n\r\n                        _userRelation._recommerMapping[_children[i]] = _parent;\r\n\r\n                        _userRelation._shortCodeMapping[_shortCode[i]] = _children[i];\r\n            _userRelation._addressShotCodeMapping[_children[i]] = _shortCode[i];\r\n        }\r\n\r\n        if ( force ) {\r\n\r\n                        for ( uint i = 0; i < _children.length; i++ ) {\r\n                _userRelation._recommerList[_parent].push(_children[i]);\r\n            }\r\n\r\n                        _userRelation._recommerCountMapping[_parent] += _children.length;\r\n\r\n        } else {\r\n\r\n                        _userRelation._recommerList[_parent] = _children;\r\n\r\n                        _userRelation._recommerCountMapping[_parent] = _children.length;\r\n        }\r\n\r\n                _userRelation.totalAddresses += _children.length;\r\n\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.5.1 <0.7.0;\r\n\r\n\r\n\r\n\r\n\r\ninterface RecommendValidUserInterface {\r\n    function recommendValidUserTotalOf(address owner) external view returns (uint);\r\n}\r\n\r\ninterface V1CompensateInterface {\r\n    function API_AppendLockedDepositAmount(address owner, uint amount) external;\r\n}\r\n\r\ncontract MineStorage is KStorage {\r\n\r\n    struct UserInfomation {\r\n\r\n                uint pow_st;\r\n\r\n                uint pow_dy;\r\n\r\n                uint totalProfix;\r\n\r\n                uint latestWithdrawTime;\r\n    }\r\n\r\n    mapping(address => UserInfomation) public userInfomationOf;\r\n\r\n    uint public issueTime;\r\n    uint public latestCutDownTime;\r\n    uint public releaseToken = 33000 ether;\r\n\r\n    using TimeLineValue for TimeLineValue.Data;\r\n        TimeLineValue.Data _networkPowST;\r\n        TimeLineValue.Data _networkPowDY;\r\n\r\n    iERC20 internal _erc20Inc;\r\n    Relations internal _rlsInc;\r\n    RecommendValidUserInterface internal _bankInc;\r\n\r\n    constructor(iERC20 erc20Inc, Relations rlsInc) public {\r\n        _erc20Inc = erc20Inc;\r\n        _rlsInc = rlsInc;\r\n\r\n        _networkPowST.init(1 days, timestempZero(), 0);\r\n        _networkPowDY.init(1 days, timestempZero(), 0);\r\n\r\n        issueTime = timestempZero();\r\n        latestCutDownTime = timestempZero();\r\n    }\r\n\r\n}\r\n\r\ncontract Mine is MineStorage( iERC20(0), Relations(0) ) {\r\n\r\n    event Log_Profix(address indexed owner, uint indexed time, uint st, uint dy);\r\n\r\n    function setRecommendValidUserInterface(RecommendValidUserInterface i) external KOwnerOnly {\r\n        _bankInc = i;\r\n    }\r\n\r\n    function networkPowerInfo() external view returns (uint totalSt, uint totalDy) {\r\n        if (issueTime == 0) {\r\n            return (0,0);\r\n        }\r\n        return (\r\n            _networkPowST.bestMatchValue(timestemp()),\r\n            _networkPowDY.bestMatchValue(timestemp())\r\n        );\r\n    }\r\n\r\n    function networkPowerInfo(uint time) external view returns (uint totalSt, uint totalDy) {\r\n        if (issueTime == 0) {\r\n            return (0,0);\r\n        }\r\n        return (\r\n            _networkPowST.bestMatchValue(time),\r\n            _networkPowDY.bestMatchValue(time)\r\n        );\r\n    }\r\n\r\n        function _currentReleaseToken() internal returns (uint) {\r\n\r\n        uint issueMonth = (timestemp() - issueTime) / 30 days;\r\n\r\n                uint cutdownInterval = timestempZero() - latestCutDownTime;\r\n        if ( cutdownInterval < 30 days ) {\r\n            return releaseToken;\r\n        }\r\n\r\n        if      ( issueMonth <= 6 )  {  releaseToken = releaseToken * 1.10e12 / 1e12; }\r\n        else if ( issueMonth <= 12 ) {  releaseToken = releaseToken * 1.08e12 / 1e12; }\r\n        else if ( issueMonth <= 24 ) {  releaseToken = releaseToken * 1.05e12 / 1e12; }\r\n        else if ( issueMonth <= 36 ) {  releaseToken = releaseToken * 1.03e12 / 1e12; }\r\n        else                         {  releaseToken = releaseToken * 1.02e12 / 1e12; }\r\n\r\n        latestCutDownTime = timestempZero();\r\n        return releaseToken;\r\n    }\r\n\r\n    function settlement() external returns (uint st, uint dy, uint sent) {\r\n        if ( issueTime == 0 ) {\r\n            return (0,0,0);\r\n        }\r\n        return _settlement();\r\n    }\r\n    function _settlement() internal returns (uint st, uint dy, uint sent) {\r\n\r\n        UserInfomation storage userInfo = userInfomationOf[msg.sender];\r\n\r\n        uint intervalDay = (timestempZero() - userInfo.latestWithdrawTime) / 1 days;\r\n\r\n        uint totalSt = (\r\n            _networkPowST.bestMatchValue( userInfo.latestWithdrawTime ) +\r\n            _networkPowST.bestMatchValue( timestempZero() - 1 days )\r\n        ) / 2;\r\n\r\n\r\n\r\n        if ( totalSt > 0 ) {\r\n            st = (userInfo.pow_st * (_currentReleaseToken() / 2) / totalSt) * intervalDay;\r\n        }\r\n\r\n        \r\n        dy = userInfo.pow_dy;\r\n\r\n                if ( intervalDay > 0 && totalSt > 0 ) {\r\n                        uint40[15] memory props = [\r\n                0.20e12,                 0.15e12,                 0.10e12,                 0.05e12,                 0.05e12,                 0.05e12,                 0.05e12,                 0.05e12,                 0.05e12,                 0.05e12,                 0.04e12,                 0.04e12,                 0.04e12,                 0.04e12,                 0.04e12              ];\r\n\r\n            for (\r\n                (address parent, uint i) = (_rlsInc.GetIntroducer(msg.sender), 0);\r\n                parent != address(0) && parent != address(0xdead) && i < props.length;\r\n                (i++, parent = _rlsInc.GetIntroducer(parent))\r\n            ) {\r\n\r\n                    uint amount = st * props[i] / 1e12;\r\n                    _networkPowDY.increase( amount );\r\n                    userInfomationOf[parent].pow_dy += ( amount );\r\n\r\n            }\r\n        }\r\n\r\n        if ( st + dy > 0 && userInfo.totalProfix < userInfo.pow_st * 3 ) {\r\n\r\n                        if ( userInfo.totalProfix + st + dy > userInfo.pow_st * 3 ) {\r\n                sent = userInfo.pow_st * 3 - userInfo.totalProfix;\r\n                userInfo.totalProfix = userInfo.pow_st * 3;\r\n            } else {\r\n                sent = (st + dy);\r\n                userInfo.totalProfix += sent;\r\n            }\r\n\r\n            if ( sent > 0 ) {\r\n                userInfo.pow_dy = 0;\r\n                userInfo.latestWithdrawTime = timestempZero();\r\n\r\n                _erc20Inc.transfer(msg.sender, sent);\r\n                emit Log_Profix(msg.sender, timestempZero(), st, dy);\r\n            }\r\n        }\r\n    }\r\n\r\n        function burn(uint amount) external returns (uint profix) {\r\n        _erc20Inc.transferFrom( msg.sender, address(0xdead), amount );\r\n        return _burned(msg.sender, amount);\r\n    }\r\n    function _burned(address owner, uint amount) internal returns (uint profix) {\r\n\r\n        UserInfomation storage userInfo = userInfomationOf[owner];\r\n\r\n                if ( userInfo.latestWithdrawTime == 0 ) {\r\n            userInfo.latestWithdrawTime = timestempZero();\r\n        } else {\r\n            (, , profix) = _settlement();\r\n        }\r\n\r\n                userInfo.pow_st += amount;\r\n        _networkPowST.increase(amount);\r\n    }\r\n\r\n        function increasePOWDelegate(address owner, uint pow) external KDelegateMethod {\r\n        _burned(owner, pow);\r\n    }\r\n\r\n    function API_AppendLockedDepositAmount(address owner, uint amount) external KDelegateMethod {\r\n        _erc20Inc.transfer( address(0xdead), amount );\r\n        _burned(owner, amount);\r\n    }\r\n\r\n    function increasePOWGroupDelegate(address[] calldata addressList, uint[] calldata pow) external KOwnerOnly {\r\n        uint totalNeedBurn = 0;\r\n        for ( uint i = 0; i < addressList.length; i++ ) {\r\n            _burned(addressList[i], pow[i]);\r\n            totalNeedBurn += pow[i];\r\n        }\r\n        _erc20Inc.transfer( address(0xdead), totalNeedBurn );\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract iERC20\",\"name\":\"erc20Inc\",\"type\":\"address\"},{\"internalType\":\"contract Relations\",\"name\":\"rlsInc\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"auther\",\"type\":\"address\"}],\"name\":\"KAddAuthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KAuthAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"KContractOwners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"auther\",\"type\":\"address\"}],\"name\":\"KDelAuthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KImplementAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tc\",\"type\":\"address\"}],\"name\":\"KSetDebugTimeController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"SetKImplementAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestCutDownTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfomationOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pow_st\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pow_dy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalProfix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestWithdrawTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MineStorage","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000091c4b0cfc5eac8b8c5fd953ae9fbc707b520a7d60000000000000000000000003fe5eb14a8e99d7ba8b421c5285b5c0d8292cd13","EVMVersion":"byzantium","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://fd8a0e92d583bb6e6ad6d6fcd1748a5195dc473ef1f9b9258c9bf3282149f944"}]}