{"status":"1","message":"OK","result":[{"SourceCode":"// This probably won't explode... for real this time\r\npragma solidity >=0.8.0 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\ninterface ZeroXChanSticker {\r\n\tfunction originalTokenOwner(uint256 tokenId) external view returns(address);\r\n\tfunction tokenProperty(uint256 tokenId) external view returns(uint256);\r\n}\r\ncontract EtherGiverFromSticker2{\r\n    uint256 constant MAX_TOKENS = 195;\r\n    address internal admin;\r\n    ZeroXChanSticker internal thingWithUserWorth;\r\n    uint256 internal contractAirdropStore;\r\n    uint256 internal contractBalanceStore;\r\n    uint256 internal contractStore;\r\n    mapping (address => uint256) public userShares;\r\n    address[] internal airdropReceivers;\r\n    constructor(){\r\n        contractStore = (\r\n            0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 | // claimStartTime = claimEndTime = inifnity (later set by deposit)\r\n            (241655500000000000000) // totalShares = 241655500000000000000\r\n        );\r\n        thingWithUserWorth = ZeroXChanSticker(0x238C0ebf1Af19b9A8881155b4FffaA202Be50D35);\r\n\t    admin = 0x8FFDE97829408c39cdE8fAdcD4060fd6fFd5A355;\r\n    }\r\n    function totalDeposit() public view returns (uint128){\r\n        return (uint128(contractBalanceStore >> 128));\r\n    }\r\n    function leftoverAmount() public view returns(uint128){\r\n       return (uint128(contractBalanceStore));\r\n    }\r\n    function airdropShares() public view returns(uint128){\r\n        return (uint128(contractAirdropStore));\r\n    }\r\n    function airdropIndex() public view returns(uint128){\r\n        return (uint128(contractAirdropStore >> 128));\r\n    }\r\n    function totalUsersClaimed() public view returns(uint128){\r\n        return (uint128(airdropReceivers.length));\r\n    }\r\n    function claimStartTime() public view returns(uint64){\r\n        return(uint64(contractStore >> 192));\r\n    }\r\n    function claimEndTime() public view returns(uint64){\r\n        return(uint64(contractStore >> 128));\r\n    }\r\n    function totalShares() public view returns(uint128){\r\n        return(uint128(contractStore));\r\n    }\r\n    function abort() public{\r\n        require(msg.sender == admin, \"a\"); // \"You're not allowed to do this\"\r\n\t    require(block.timestamp < claimStartTime(), \"b\"); // \"Too late to abort\"\r\n\t    selfdestruct(payable(msg.sender));\r\n    }\r\n    // Must be fallback in order to receive funds from the multisig contract\r\n    fallback() external payable{\r\n        require(msg.sender == admin, \"a\"); // \"You're not allowed to do this\"\r\n        require(block.timestamp < claimStartTime(), \"c\"); // \"Cannot do this during claim time\"\r\n        // Add value to leftoverAmount and totalDeposit \r\n        contractBalanceStore += ((msg.value << 128) | msg.value);\r\n        // Get this shit on the road\r\n        contractStore &= (\r\n            ((block.timestamp + 3600) << 192) | // claimStartTime = currenTime + 1 hour\r\n            ((block.timestamp + 608400) << 128) | // claimEndTime = currenTime + 1 hour + 1 week\r\n            0xffffffffffffffffffffffffffffffff\r\n        );\r\n    }\r\n    function makeClaim(uint256[] calldata tokenIds) public{\r\n        require(block.timestamp >= claimStartTime(), \"d\"); // \"Too early to make a claim\"\r\n        require(block.timestamp < claimEndTime(), \"e\"); // \"Too late to make a claim\"\r\n        require(tokenIds.length > 0, \"f\"); // \"Nothing to claim\"\r\n        uint256 localUserShares = userShares[msg.sender];\r\n        require(localUserShares == 0, \"g\"); // \"Already claimed\"\r\n        uint256 tokensClaimed = 0;\r\n        uint256 tokenId;\r\n        for(uint256 i = 0; i < tokenIds.length; i += 1){\r\n            tokenId = tokenIds[i];\r\n            require(tokenId < MAX_TOKENS, \"h\"); // \"Invalid token ID\"\r\n            // This works because there are less than 255 total tokens\r\n            require(tokensClaimed & (2 ** tokenId) == 0, \"i\"); // \"You cannot claim the same token twice\"\r\n            require(thingWithUserWorth.originalTokenOwner(tokenId) == msg.sender, \"j\"); // \"Token must be created by you\"\r\n            localUserShares += thingWithUserWorth.tokenProperty(tokenId);\r\n            tokensClaimed |= (2 ** tokenId); // We don't need to store claimed tokens as each address can only claim once\r\n        }\r\n        unchecked{\r\n            // Add to airdropShares, Impossible to overflow\r\n            contractAirdropStore += localUserShares;\r\n        }\r\n        uint256 valueToSend = uint256(totalDeposit()) * localUserShares / uint256(totalShares());\r\n        // Subtract from leftoverAmount, used in airdrops later\r\n        contractBalanceStore -= valueToSend;\r\n        payable(msg.sender).transfer(valueToSend);\r\n        airdropReceivers.push(msg.sender);\r\n        \r\n        userShares[msg.sender] = localUserShares;\r\n    }\r\n    function doAirdrop(uint128 amountToDo) public{\r\n        require(block.timestamp >= claimEndTime(), \"c\"); // \"Cannot do this during claim time\"\r\n        uint128 startIndex = airdropIndex();\r\n        // amountToDo becomes endIndex\r\n        amountToDo += startIndex;\r\n        if(amountToDo > uint128(airdropReceivers.length)){\r\n            amountToDo = uint128(airdropReceivers.length);\r\n        }\r\n        uint256 localAirdropShares = uint256(airdropShares());\r\n        for(uint128 i = startIndex; i < amountToDo; i += 1){\r\n            payable(airdropReceivers[i]).transfer(uint256(leftoverAmount()) * userShares[airdropReceivers[i]] / localAirdropShares);\r\n        }\r\n        contractAirdropStore &= 0xffffffffffffffffffffffffffffffff;\r\n        contractAirdropStore |= uint256(amountToDo) << 128;\r\n        if(amountToDo == uint128(airdropReceivers.length)){\r\n            selfdestruct(payable(msg.sender));\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"abort\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropIndex\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropShares\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimEndTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimStartTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amountToDo\",\"type\":\"uint128\"}],\"name\":\"doAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leftoverAmount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"makeClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposit\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsersClaimed\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EtherGiverFromSticker2","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://256792ca8bfa700f62f5478badfb8ce1338384b7a532996d8db12997d8fb1343"}]}