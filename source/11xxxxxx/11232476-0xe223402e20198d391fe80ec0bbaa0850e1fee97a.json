{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  @authors: [@mtsalenc]\r\n *  @reviewers: []\r\n *  @auditors: []\r\n *  @bounties: []\r\n *  @deployments: []\r\n */\r\n\r\npragma solidity ^0.5.17;\r\n\r\ninterface IArbitrableTCR {\r\n\r\n    enum Party {\r\n        None,      // Party per default when there is no challenger or requester. Also used for unconclusive ruling.\r\n        Requester, // Party that made the request to change an address status.\r\n        Challenger // Party that challenges the request to change an address status.\r\n    }\r\n\r\n    function governor() external view returns(address);\r\n    function arbitrator() external view returns(address);\r\n    function arbitratorExtraData() external view returns(bytes memory);\r\n    function requesterBaseDeposit() external view returns(uint);\r\n    function challengerBaseDeposit() external view returns(uint);\r\n    function challengePeriodDuration() external view returns(uint);\r\n    function metaEvidenceUpdates() external view returns(uint);\r\n    function winnerStakeMultiplier() external view returns(uint);\r\n    function loserStakeMultiplier() external view returns(uint);\r\n    function sharedStakeMultiplier() external view returns(uint);\r\n    function MULTIPLIER_DIVISOR() external view returns(uint);\r\n    function countByStatus()\r\n        external\r\n        view\r\n        returns(\r\n            uint absent,\r\n            uint registered,\r\n            uint registrationRequest,\r\n            uint clearingRequest,\r\n            uint challengedRegistrationRequest,\r\n            uint challengedClearingRequest\r\n        );\r\n}\r\n\r\ninterface IArbitrableAddressTCR {\r\n    enum AddressStatus {\r\n        Absent, // The address is not in the registry.\r\n        Registered, // The address is in the registry.\r\n        RegistrationRequested, // The address has a request to be added to the registry.\r\n        ClearingRequested // The address has a request to be removed from the registry.\r\n    }\r\n\r\n    function addressCount() external view returns(uint);\r\n    function addressList(uint index) external view returns(address);\r\n    function getAddressInfo(address _address)\r\n        external\r\n        view\r\n        returns (\r\n            AddressStatus status,\r\n            uint numberOfRequests\r\n        );\r\n\r\n    function getRequestInfo(address _address, uint _request)\r\n        external\r\n        view\r\n        returns (\r\n            bool disputed,\r\n            uint disputeID,\r\n            uint submissionTime,\r\n            bool resolved,\r\n            address[3] memory parties,\r\n            uint numberOfRounds,\r\n            IArbitrableTCR.Party ruling,\r\n            address arbitrator,\r\n            bytes memory arbitratorExtraData\r\n        );\r\n\r\n    function getRoundInfo(address _address, uint _request, uint _round)\r\n        external\r\n        view\r\n        returns (\r\n            bool appealed,\r\n            uint[3] memory paidFees,\r\n            bool[3] memory hasPaid,\r\n            uint feeRewards\r\n        );\r\n}\r\n\r\ninterface IArbitrableTokenTCR {\r\n\r\n    enum TokenStatus {\r\n        Absent, // The address is not in the registry.\r\n        Registered, // The address is in the registry.\r\n        RegistrationRequested, // The address has a request to be added to the registry.\r\n        ClearingRequested // The address has a request to be removed from the registry.\r\n    }\r\n\r\n    function tokenCount() external view returns(uint);\r\n    function tokensList(uint index) external view returns(bytes32);\r\n    function getTokenInfo(bytes32 _tokenID)\r\n        external\r\n        view\r\n        returns (\r\n            string memory name,\r\n            string memory ticker,\r\n            address addr,\r\n            string memory symbolMultihash,\r\n            TokenStatus status,\r\n            uint numberOfRequests\r\n        );\r\n\r\n    function getRequestInfo(bytes32 _tokenID, uint _request)\r\n        external\r\n        view\r\n        returns (\r\n            bool disputed,\r\n            uint disputeID,\r\n            uint submissionTime,\r\n            bool resolved,\r\n            address[3] memory parties,\r\n            uint numberOfRounds,\r\n            IArbitrableTCR.Party ruling,\r\n            address arbitrator,\r\n            bytes memory arbitratorExtraData\r\n        );\r\n\r\n    function getRoundInfo(bytes32 _tokenID, uint _request, uint _round)\r\n        external\r\n        view\r\n        returns (\r\n            bool appealed,\r\n            uint[3] memory paidFees,\r\n            bool[3] memory hasPaid,\r\n            uint feeRewards\r\n        );\r\n\r\n    function addressToSubmissions(address _addr, uint _index) external view returns (bytes32);\r\n}\r\n\r\ninterface IArbitrator {\r\n    enum DisputeStatus {Waiting, Appealable, Solved}\r\n\r\n    function createDispute(uint _choices, bytes calldata _extraData) external payable returns(uint disputeID);\r\n    function arbitrationCost(bytes calldata _extraData) external view returns(uint cost);\r\n    function appeal(uint _disputeID, bytes calldata _extraData) external payable;\r\n    function appealCost(uint _disputeID, bytes calldata _extraData) external view returns(uint cost);\r\n    function appealPeriod(uint _disputeID) external view returns(uint start, uint end);\r\n    function disputeStatus(uint _disputeID) external view returns(DisputeStatus status);\r\n    function currentRuling(uint _disputeID) external view returns(uint ruling);\r\n}\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract ArbitrableTCRView {\r\n\r\n    struct CountByStatus {\r\n        uint absent;\r\n        uint registered;\r\n        uint registrationRequest;\r\n        uint clearingRequest;\r\n        uint challengedRegistrationRequest;\r\n        uint challengedClearingRequest;\r\n    }\r\n\r\n    struct ArbitrableTCRData {\r\n        address governor;\r\n        address arbitrator;\r\n        bytes arbitratorExtraData;\r\n        uint requesterBaseDeposit;\r\n        uint challengerBaseDeposit;\r\n        uint challengePeriodDuration;\r\n        uint metaEvidenceUpdates;\r\n        uint winnerStakeMultiplier;\r\n        uint loserStakeMultiplier;\r\n        uint sharedStakeMultiplier;\r\n        uint MULTIPLIER_DIVISOR;\r\n        CountByStatus countByStatus;\r\n        uint arbitrationCost;\r\n    }\r\n\r\n    struct Token {\r\n        bytes32 ID;\r\n        string name;\r\n        string ticker;\r\n        address addr;\r\n        string symbolMultihash;\r\n        IArbitrableTokenTCR.TokenStatus status;\r\n        uint decimals;\r\n    }\r\n\r\n    // Some arrays below have 3 elements to map with the Party enums for better readability:\r\n    // - 0: is unused, matches `Party.None`.\r\n    // - 1: for `Party.Requester`.\r\n    // - 2: for `Party.Challenger`.\r\n    struct Request {\r\n        bool disputed;\r\n        uint disputeID;\r\n        uint submissionTime;\r\n        bool resolved;\r\n        address[3] parties;\r\n        uint numberOfRounds;\r\n        IArbitrableTCR.Party ruling;\r\n        address arbitrator;\r\n        bytes arbitratorExtraData;\r\n        IArbitrator.DisputeStatus disputeStatus;\r\n        uint currentRuling;\r\n        uint appealCost;\r\n        uint[3] requiredForSide;\r\n        uint[2] appealPeriod;\r\n        uint[3] paidFees;\r\n        uint feeRewards;\r\n        bool[3] hasPaid;\r\n        bool appealed;\r\n    }\r\n\r\n    struct AppealableToken {\r\n        uint disputeID;\r\n        address arbitrator;\r\n        bytes32 tokenID;\r\n        bool inAppealPeriod;\r\n    }\r\n\r\n    struct AppealableAddress {\r\n        uint disputeID;\r\n        address arbitrator;\r\n        address addr;\r\n        bool inAppealPeriod;\r\n    }\r\n\r\n    /** @dev Fetch arbitrable TCR data in a single call.\r\n     *  @param _address The address of the Generalized TCR to query.\r\n     *  @return The latest data on an arbitrable TCR contract.\r\n     */\r\n    function fetchArbitrable(address _address) public view returns (ArbitrableTCRData memory result) {\r\n        IArbitrableTCR tcr = IArbitrableTCR(_address);\r\n        result.governor = tcr.governor();\r\n        result.arbitrator = tcr.arbitrator();\r\n        result.arbitratorExtraData = tcr.arbitratorExtraData();\r\n        result.requesterBaseDeposit = tcr.requesterBaseDeposit();\r\n        result.challengerBaseDeposit = tcr.challengerBaseDeposit();\r\n        result.challengePeriodDuration = tcr.challengePeriodDuration();\r\n        result.metaEvidenceUpdates = tcr.metaEvidenceUpdates();\r\n        result.winnerStakeMultiplier = tcr.winnerStakeMultiplier();\r\n        result.loserStakeMultiplier = tcr.loserStakeMultiplier();\r\n        result.sharedStakeMultiplier = tcr.sharedStakeMultiplier();\r\n        result.MULTIPLIER_DIVISOR = tcr.MULTIPLIER_DIVISOR();\r\n\r\n        {\r\n            (\r\n                uint absent,\r\n                uint registered,\r\n                uint registrationRequest,\r\n                uint clearingRequest,\r\n                uint challengedRegistrationRequest,\r\n                uint challengedClearingRequest\r\n            ) = tcr.countByStatus();\r\n            result.countByStatus = CountByStatus({\r\n                absent: absent,\r\n                registered: registered,\r\n                registrationRequest: registrationRequest,\r\n                clearingRequest: clearingRequest,\r\n                challengedRegistrationRequest: challengedRegistrationRequest,\r\n                challengedClearingRequest: challengedClearingRequest\r\n            });\r\n        }\r\n\r\n        IArbitrator arbitrator = IArbitrator(result.arbitrator);\r\n        result.arbitrationCost = arbitrator.arbitrationCost(result.arbitratorExtraData);\r\n    }\r\n\r\n    function fetchAppealableAddresses(address _addressTCR, uint _cursor, uint _count) external view returns (AppealableAddress[] memory results) {\r\n        IArbitrableAddressTCR tcr = IArbitrableAddressTCR(_addressTCR);\r\n        results = new AppealableAddress[]( tcr.addressCount() < _count ?  tcr.addressCount() : _count);\r\n\r\n        for (uint i = _cursor; i < tcr.addressCount() && _count - i > 0; i++) {\r\n            address itemAddr = tcr.addressList(i);\r\n            (\r\n                IArbitrableAddressTCR.AddressStatus status,\r\n                uint numberOfRequests\r\n            ) = tcr.getAddressInfo(itemAddr);\r\n\r\n            if (status == IArbitrableAddressTCR.AddressStatus.Absent || status == IArbitrableAddressTCR.AddressStatus.Registered) continue;\r\n\r\n            // Using arrays to get around stack limit.\r\n            bool[] memory disputedResolved = new bool[](2);\r\n            uint[] memory disputeIDNumberOfRounds = new uint[](2);\r\n            address arbitrator;\r\n            (\r\n                disputedResolved[0],\r\n                disputeIDNumberOfRounds[0],\r\n                ,\r\n                disputedResolved[1],\r\n                ,\r\n                disputeIDNumberOfRounds[1],\r\n                ,\r\n                arbitrator,\r\n            ) = tcr.getRequestInfo(itemAddr, numberOfRequests - 1);\r\n\r\n            if (!disputedResolved[0] || disputedResolved[1]) continue;\r\n\r\n            IArbitrator arbitratorContract = IArbitrator(arbitrator);\r\n            uint[] memory appealPeriod = new uint[](2);\r\n            (appealPeriod[0], appealPeriod[1]) = arbitratorContract.appealPeriod(disputeIDNumberOfRounds[0]);\r\n            if (appealPeriod[0] > 0 && appealPeriod[1] > 0) {\r\n                results[i] = AppealableAddress({\r\n                    disputeID: disputeIDNumberOfRounds[0],\r\n                    arbitrator: arbitrator,\r\n                    addr: itemAddr,\r\n                    inAppealPeriod: now < appealPeriod[1]\r\n                });\r\n\r\n                // If the arbitrator gave a decisive ruling (i.e. did not rule for Party.None)\r\n                // we must check if the loser fully funded and the dispute is in the second half\r\n                // of the appeal period. If the dispute is in the second half, and the loser is not\r\n                // funded the appeal period is over.\r\n                IArbitrableTCR.Party currentRuling = IArbitrableTCR.Party(arbitratorContract.currentRuling(disputeIDNumberOfRounds[0]));\r\n                if (\r\n                    currentRuling != IArbitrableTCR.Party.None &&\r\n                    now > (appealPeriod[1] - appealPeriod[0]) / 2 + appealPeriod[0]\r\n                ) {\r\n                    IArbitrableTCR.Party loser = currentRuling == IArbitrableTCR.Party.Requester\r\n                        ? IArbitrableTCR.Party.Challenger\r\n                        : IArbitrableTCR.Party.Requester;\r\n\r\n                    (\r\n                        ,\r\n                        ,\r\n                        bool[3] memory hasPaid,\r\n                    ) = tcr.getRoundInfo(itemAddr, numberOfRequests - 1, disputeIDNumberOfRounds[1] - 1);\r\n\r\n                    if(!hasPaid[uint(loser)]) results[i].inAppealPeriod = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function fetchAppealableToken(address _addressTCR, uint _cursor, uint _count) external view returns (AppealableToken[] memory results) {\r\n        IArbitrableTokenTCR tcr = IArbitrableTokenTCR(_addressTCR);\r\n        results = new AppealableToken[](tcr.tokenCount() < _count ? tcr.tokenCount() : _count);\r\n\r\n        for (uint i = _cursor; i < tcr.tokenCount() && _count - i > 0; i++) {\r\n            bytes32 tokenID = tcr.tokensList(i);\r\n            (\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                IArbitrableTokenTCR.TokenStatus status,\r\n                uint numberOfRequests\r\n            ) = tcr.getTokenInfo(tokenID);\r\n\r\n            if (status == IArbitrableTokenTCR.TokenStatus.Absent || status == IArbitrableTokenTCR.TokenStatus.Registered) continue;\r\n\r\n            // Using arrays to get around stack limit.\r\n            bool[] memory disputedResolved = new bool[](2);\r\n            uint[] memory disputeIDNumberOfRounds = new uint[](2);\r\n            address arbitrator;\r\n            (\r\n                disputedResolved[0],\r\n                disputeIDNumberOfRounds[0],\r\n                ,\r\n                disputedResolved[1],\r\n                ,\r\n                disputeIDNumberOfRounds[1],\r\n                ,\r\n                arbitrator,\r\n            ) = tcr.getRequestInfo(tokenID, numberOfRequests - 1);\r\n\r\n            if (!disputedResolved[0] || disputedResolved[1]) continue;\r\n\r\n            IArbitrator arbitratorContract = IArbitrator(arbitrator);\r\n            uint[] memory appealPeriod = new uint[](2);\r\n            (appealPeriod[0], appealPeriod[1]) = arbitratorContract.appealPeriod(disputeIDNumberOfRounds[0]);\r\n            if (appealPeriod[0] > 0 && appealPeriod[1] > 0) {\r\n                results[i] = AppealableToken({\r\n                    disputeID: disputeIDNumberOfRounds[0],\r\n                    arbitrator: arbitrator,\r\n                    tokenID: tokenID,\r\n                    inAppealPeriod: now < appealPeriod[1]\r\n                });\r\n\r\n                // If the arbitrator gave a decisive ruling (i.e. did not rule for Party.None)\r\n                // we must check if the loser fully funded and the dispute is in the second half\r\n                // of the appeal period. If the dispute is in the second half, and the loser is not\r\n                // funded the appeal period is over.\r\n                IArbitrableTCR.Party currentRuling = IArbitrableTCR.Party(arbitratorContract.currentRuling(disputeIDNumberOfRounds[0]));\r\n                if (\r\n                    currentRuling != IArbitrableTCR.Party.None &&\r\n                    now > (appealPeriod[1] - appealPeriod[0]) / 2 + appealPeriod[0]\r\n                ) {\r\n                    IArbitrableTCR.Party loser = currentRuling == IArbitrableTCR.Party.Requester\r\n                        ? IArbitrableTCR.Party.Challenger\r\n                        : IArbitrableTCR.Party.Requester;\r\n\r\n                    (\r\n                        ,\r\n                        ,\r\n                        bool[3] memory hasPaid,\r\n                    ) = tcr.getRoundInfo(tokenID, numberOfRequests - 1, disputeIDNumberOfRounds[1] - 1);\r\n\r\n                    if(!hasPaid[uint(loser)]) results[i].inAppealPeriod = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev Fetch token IDs of the first tokens present on the tcr for the addresses.\r\n     *  @param _t2crAddress The address of the t2cr contract from where to fetch token information.\r\n     *  @param _tokenAddresses The address of each token.\r\n     */\r\n    function getTokensIDsForAddresses(\r\n        address _t2crAddress,\r\n        address[] calldata _tokenAddresses\r\n    ) external view returns (bytes32[] memory result) {\r\n        IArbitrableTokenTCR t2cr = IArbitrableTokenTCR(_t2crAddress);\r\n        result = new bytes32[](_tokenAddresses.length);\r\n        for (uint i = 0; i < _tokenAddresses.length;  i++){\r\n            // Count how many submissions were made for an address.\r\n            address tokenAddr = _tokenAddresses[i];\r\n            bool counting = true;\r\n            bytes4 sig = bytes4(keccak256(\"addressToSubmissions(address,uint256)\"));\r\n            uint submissions = 0;\r\n            while(counting) {\r\n                assembly {\r\n                    let x := mload(0x40)   // Find empty storage location using \"free memory pointer\"\r\n                    mstore(x, sig)         // Set the signature to the first call parameter.\r\n                    mstore(add(x, 0x04), tokenAddr)\r\n                    mstore(add(x, 0x24), submissions)\r\n                    counting := staticcall( // `counting` will be set to false if the call reverts (which will happen if we reached the end of the array.)\r\n                        30000,              // 30k gas\r\n                        _t2crAddress,       // The call target.\r\n                        x,                  // Inputs are stored at location x\r\n                        0x44,               // Input is 44 bytes long (signature (4B) + address (20B) + index(20B))\r\n                        x,                  // Overwrite x with output\r\n                        0x20                // The output length\r\n                    )\r\n                }\r\n\r\n                if (counting) {\r\n                    submissions++;\r\n                }\r\n            }\r\n\r\n            // Search for the oldest submission currently in the registry.\r\n            for(uint j = 0; j < submissions; j++) {\r\n                bytes32 tokenID = t2cr.addressToSubmissions(tokenAddr, j);\r\n                (,,,,IArbitrableTokenTCR.TokenStatus status,) = t2cr.getTokenInfo(tokenID);\r\n                if (status == IArbitrableTokenTCR.TokenStatus.Registered || status == IArbitrableTokenTCR.TokenStatus.ClearingRequested)\r\n                {\r\n                    result[i] = tokenID;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev Fetch token information with token IDs. If a token contract does not implement the decimals() function, its decimals field will be 0.\r\n     *  @param _t2crAddress The address of the t2cr contract from where to fetch token information.\r\n     *  @param _tokenIDs The IDs of the tokens we want to query.\r\n     *  @return tokens The tokens information.\r\n     */\r\n    function getTokens(address _t2crAddress, bytes32[] calldata _tokenIDs)\r\n        external\r\n        view\r\n        returns (Token[] memory tokens)\r\n    {\r\n        IArbitrableTokenTCR t2cr = IArbitrableTokenTCR(_t2crAddress);\r\n        tokens = new Token[](_tokenIDs.length);\r\n        for (uint i = 0; i < _tokenIDs.length ; i++){\r\n            string[] memory strings = new string[](3); // name, ticker and symbolMultihash respectively.\r\n            address tokenAddress;\r\n            IArbitrableTokenTCR.TokenStatus status;\r\n            (\r\n                strings[0],\r\n                strings[1],\r\n                tokenAddress,\r\n                strings[2],\r\n                status,\r\n            ) = t2cr.getTokenInfo(_tokenIDs[i]);\r\n\r\n            tokens[i] = Token(\r\n                _tokenIDs[i],\r\n                strings[0],\r\n                strings[1],\r\n                tokenAddress,\r\n                strings[2],\r\n                status,\r\n                0\r\n            );\r\n\r\n            // Call the contract's decimals() function without reverting when\r\n            // the contract does not implement it.\r\n            //\r\n            // Two things should be noted: if the contract does not implement the function\r\n            // and does not implement the contract fallback function, `success` will be set to\r\n            // false and decimals won't be set. However, in some cases (such as old contracts)\r\n            // the fallback function is implemented, and so staticcall will return true\r\n            // even though the value returned will not be correct (the number below):\r\n            //\r\n            // 22270923699561257074107342068491755213283769984150504402684791726686939079929\r\n            //\r\n            // We handle that edge case by also checking against this value.\r\n            uint decimals;\r\n            bool success;\r\n            bytes4 sig = bytes4(keccak256(\"decimals()\"));\r\n            assembly {\r\n                let x := mload(0x40)   // Find empty storage location using \"free memory pointer\"\r\n                mstore(x, sig)          // Set the signature to the first call parameter. 0x313ce567 === bytes4(keccak256(\"decimals()\")\r\n                success := staticcall(\r\n                    30000,              // 30k gas\r\n                    tokenAddress,       // The call target.\r\n                    x,                  // Inputs are stored at location x\r\n                    0x04,               // Input is 4 bytes long\r\n                    x,                  // Overwrite x with output\r\n                    0x20                // The output length\r\n                )\r\n\r\n                decimals := mload(x)\r\n            }\r\n            if (success && decimals != 22270923699561257074107342068491755213283769984150504402684791726686939079929) {\r\n                tokens[i].decimals = decimals;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev Fetch token information in batches\r\n     *  @param _t2crAddress The address of the t2cr contract from where to fetch token information.\r\n     *  @param _cursor The index from where to start iterating.\r\n     *  @param _count The number of items to iterate. If 0 is given, defaults to t2cr.tokenCount().\r\n     *  @param _filter The filter to use. Each element of the array in sequence means:\r\n     *  - Include absent addresses in result.\r\n     *  - Include registered addresses in result.\r\n     *  - Include addresses with registration requests that are not disputed in result.\r\n     *  - Include addresses with clearing requests that are not disputed in result.\r\n     *  - Include disputed addresses with registration requests in result.\r\n     *  - Include disputed addresses with clearing requests in result.\r\n     *  @return tokens The tokens information.\r\n     */\r\n    function getTokensCursor(address _t2crAddress, uint _cursor, uint _count, bool[6] calldata _filter)\r\n        external\r\n        view\r\n        returns (Token[] memory tokens, bool hasMore)\r\n    {\r\n        IArbitrableTokenTCR t2cr = IArbitrableTokenTCR(_t2crAddress);\r\n        if (_count == 0) _count = t2cr.tokenCount();\r\n        if (_cursor >= t2cr.tokenCount()) _cursor = t2cr.tokenCount() - 1;\r\n        if (_cursor + _count > t2cr.tokenCount() - 1) _count = t2cr.tokenCount() - _cursor - 1;\r\n        if (_cursor + _count < t2cr.tokenCount() - 1) hasMore = true;\r\n\r\n        tokens = new Token[](_count);\r\n        uint index = 0;\r\n\r\n\r\n        for (uint i = _cursor; i < t2cr.tokenCount() && i < _cursor + _count ; i++){\r\n            bytes32 tokenID = t2cr.tokensList(i);\r\n            string[] memory strings = new string[](3); // name, ticker and symbolMultihash respectively.\r\n            address tokenAddress;\r\n            IArbitrableTokenTCR.TokenStatus status;\r\n            uint numberOfRequests;\r\n            (\r\n                strings[0],\r\n                strings[1],\r\n                tokenAddress,\r\n                strings[2],\r\n                status,\r\n                numberOfRequests\r\n            ) = t2cr.getTokenInfo(tokenID);\r\n\r\n            tokens[index] = Token(\r\n                tokenID,\r\n                strings[0],\r\n                strings[1],\r\n                tokenAddress,\r\n                strings[2],\r\n                status,\r\n                0\r\n            );\r\n\r\n            (bool disputed,,,,,,,,) = t2cr.getRequestInfo(tokenID, numberOfRequests - 1);\r\n\r\n            if (\r\n                /* solium-disable operator-whitespace */\r\n                (_filter[0] && status == IArbitrableTokenTCR.TokenStatus.Absent) ||\r\n                (_filter[1] && status == IArbitrableTokenTCR.TokenStatus.Registered) ||\r\n                (_filter[2] && status == IArbitrableTokenTCR.TokenStatus.RegistrationRequested && !disputed) ||\r\n                (_filter[3] && status == IArbitrableTokenTCR.TokenStatus.ClearingRequested && !disputed) ||\r\n                (_filter[4] && status == IArbitrableTokenTCR.TokenStatus.RegistrationRequested && disputed) ||\r\n                (_filter[5] && status == IArbitrableTokenTCR.TokenStatus.ClearingRequested && disputed)\r\n                /* solium-enable operator-whitespace */\r\n            ) {\r\n                if (index < _count) {\r\n                    // Call the contract's decimals() function without reverting when\r\n                    // the contract does not implement it.\r\n                    //\r\n                    // Two things should be noted: if the contract does not implement the function\r\n                    // and does not implement the contract fallback function, `success` will be set to\r\n                    // false and decimals won't be set. However, in some cases (such as old contracts)\r\n                    // the fallback function is implemented, and so staticcall will return true\r\n                    // even though the value returned will not be correct (the number below):\r\n                    //\r\n                    // 22270923699561257074107342068491755213283769984150504402684791726686939079929\r\n                    //\r\n                    // We handle that edge case by also checking against this value.\r\n                    uint decimals;\r\n                    bool success;\r\n                    bytes4 sig = bytes4(keccak256(\"decimals()\"));\r\n                    assembly {\r\n                        let x := mload(0x40)   // Find empty storage location using \"free memory pointer\"\r\n                        mstore(x, sig)          // Set the signature to the first call parameter. 0x313ce567 === bytes4(keccak256(\"decimals()\")\r\n                        success := staticcall(\r\n                            30000,              // 30k gas\r\n                            tokenAddress,       // The call target.\r\n                            x,                  // Inputs are stored at location x\r\n                            0x04,               // Input is 4 bytes long\r\n                            x,                  // Overwrite x with output\r\n                            0x20                // The output length\r\n                        )\r\n\r\n                        decimals := mload(x)\r\n                    }\r\n                    if (success && decimals != 22270923699561257074107342068491755213283769984150504402684791726686939079929) {\r\n                        tokens[index].decimals = decimals;\r\n                    }\r\n                    index++;\r\n                } else {\r\n                    hasMore = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getRequestDetails(address _t2crAddress, bytes32 _tokenID, uint _requestID) public view returns (Request memory request) {\r\n        // Making multiple block-scoped calls to avoid passing the stack limit.\r\n        IArbitrableTokenTCR t2cr = IArbitrableTokenTCR(_t2crAddress);\r\n        {\r\n            (\r\n                request.disputed,\r\n                request.disputeID,\r\n                request.submissionTime,\r\n                request.resolved,\r\n                request.parties,\r\n                request.numberOfRounds,\r\n                request.ruling,\r\n                ,\r\n            ) = t2cr.getRequestInfo(_tokenID, _requestID);\r\n        }\r\n        \r\n        {\r\n            (\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                request.arbitrator,\r\n                request.arbitratorExtraData\r\n            ) = t2cr.getRequestInfo(_tokenID, _requestID);\r\n        }\r\n\r\n        {\r\n            (\r\n                request.appealed,// appealed\r\n                request.paidFees, // paidFees\r\n                request.hasPaid, // hasPaid\r\n                request.feeRewards // feeRewards\r\n            ) = IArbitrableTokenTCR(_t2crAddress).getRoundInfo(_tokenID, _requestID, request.numberOfRounds - 1);    \r\n        }\r\n        \r\n        if (request.disputed) {\r\n            IArbitrator arbitrator = IArbitrator(request.arbitrator);\r\n            request.disputeStatus = arbitrator.disputeStatus(request.disputeID);\r\n            request.currentRuling = arbitrator.currentRuling(request.disputeID);\r\n\r\n            if (request.disputeStatus == IArbitrator.DisputeStatus.Appealable) {\r\n                request.appealCost = arbitrator.appealCost(request.disputeID, request.arbitratorExtraData);\r\n\r\n                ArbitrableTCRData memory arbitrableTCRData = fetchArbitrable(_t2crAddress);\r\n\r\n                if (request.ruling == IArbitrableTCR.Party.None) {\r\n                    request.requiredForSide[1] = request.appealCost + request.appealCost * arbitrableTCRData.sharedStakeMultiplier / arbitrableTCRData.MULTIPLIER_DIVISOR;\r\n                    request.requiredForSide[2] = request.appealCost + request.appealCost * arbitrableTCRData.sharedStakeMultiplier / arbitrableTCRData.MULTIPLIER_DIVISOR;\r\n                } else if (request.ruling == IArbitrableTCR.Party.Requester) {\r\n                    request.requiredForSide[1] = request.appealCost + request.appealCost * arbitrableTCRData.winnerStakeMultiplier / arbitrableTCRData.MULTIPLIER_DIVISOR;\r\n                    request.requiredForSide[2] = request.appealCost + request.appealCost * arbitrableTCRData.loserStakeMultiplier / arbitrableTCRData.MULTIPLIER_DIVISOR;\r\n                } else {\r\n                    request.requiredForSide[1] = request.appealCost + request.appealCost * arbitrableTCRData.loserStakeMultiplier / arbitrableTCRData.MULTIPLIER_DIVISOR;\r\n                    request.requiredForSide[2] = request.appealCost + request.appealCost * arbitrableTCRData.winnerStakeMultiplier / arbitrableTCRData.MULTIPLIER_DIVISOR;\r\n                }\r\n\r\n                (request.appealPeriod[0], request.appealPeriod[1]) = arbitrator.appealPeriod(request.disputeID);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getRequestsDetails(address _t2crAddress, bytes32 _tokenID) public view returns (\r\n       Request[10] memory requests // Ideally this should be resizable. In practice it is unlikely submissions will have more than 2 or 3 requests.\r\n    ) {\r\n        IArbitrableTokenTCR t2cr = IArbitrableTokenTCR(_t2crAddress);\r\n        (,,,,, uint numberOfRequests) = t2cr.getTokenInfo(_tokenID);\r\n\r\n        for (uint256 i = 0; i < numberOfRequests; i++) {\r\n            requests[i] = getRequestDetails(_t2crAddress, _tokenID, i);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressTCR\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"fetchAppealableAddresses\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"disputeID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"inAppealPeriod\",\"type\":\"bool\"}],\"internalType\":\"struct ArbitrableTCRView.AppealableAddress[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressTCR\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"fetchAppealableToken\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"disputeID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenID\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"inAppealPeriod\",\"type\":\"bool\"}],\"internalType\":\"struct ArbitrableTCRView.AppealableToken[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"fetchArbitrable\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"arbitratorExtraData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"requesterBaseDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengerBaseDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengePeriodDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"metaEvidenceUpdates\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winnerStakeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loserStakeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharedStakeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MULTIPLIER_DIVISOR\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"absent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registrationRequest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"clearingRequest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengedRegistrationRequest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengedClearingRequest\",\"type\":\"uint256\"}],\"internalType\":\"struct ArbitrableTCRView.CountByStatus\",\"name\":\"countByStatus\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"arbitrationCost\",\"type\":\"uint256\"}],\"internalType\":\"struct ArbitrableTCRView.ArbitrableTCRData\",\"name\":\"result\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_t2crAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_tokenID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_requestID\",\"type\":\"uint256\"}],\"name\":\"getRequestDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"disputed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"disputeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submissionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"resolved\",\"type\":\"bool\"},{\"internalType\":\"address[3]\",\"name\":\"parties\",\"type\":\"address[3]\"},{\"internalType\":\"uint256\",\"name\":\"numberOfRounds\",\"type\":\"uint256\"},{\"internalType\":\"enum IArbitrableTCR.Party\",\"name\":\"ruling\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"arbitratorExtraData\",\"type\":\"bytes\"},{\"internalType\":\"enum IArbitrator.DisputeStatus\",\"name\":\"disputeStatus\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"currentRuling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"appealCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256[3]\",\"name\":\"requiredForSide\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[2]\",\"name\":\"appealPeriod\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[3]\",\"name\":\"paidFees\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256\",\"name\":\"feeRewards\",\"type\":\"uint256\"},{\"internalType\":\"bool[3]\",\"name\":\"hasPaid\",\"type\":\"bool[3]\"},{\"internalType\":\"bool\",\"name\":\"appealed\",\"type\":\"bool\"}],\"internalType\":\"struct ArbitrableTCRView.Request\",\"name\":\"request\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_t2crAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_tokenID\",\"type\":\"bytes32\"}],\"name\":\"getRequestsDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"disputed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"disputeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submissionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"resolved\",\"type\":\"bool\"},{\"internalType\":\"address[3]\",\"name\":\"parties\",\"type\":\"address[3]\"},{\"internalType\":\"uint256\",\"name\":\"numberOfRounds\",\"type\":\"uint256\"},{\"internalType\":\"enum IArbitrableTCR.Party\",\"name\":\"ruling\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"arbitratorExtraData\",\"type\":\"bytes\"},{\"internalType\":\"enum IArbitrator.DisputeStatus\",\"name\":\"disputeStatus\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"currentRuling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"appealCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256[3]\",\"name\":\"requiredForSide\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[2]\",\"name\":\"appealPeriod\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[3]\",\"name\":\"paidFees\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256\",\"name\":\"feeRewards\",\"type\":\"uint256\"},{\"internalType\":\"bool[3]\",\"name\":\"hasPaid\",\"type\":\"bool[3]\"},{\"internalType\":\"bool\",\"name\":\"appealed\",\"type\":\"bool\"}],\"internalType\":\"struct ArbitrableTCRView.Request[10]\",\"name\":\"requests\",\"type\":\"tuple[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_t2crAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_tokenIDs\",\"type\":\"bytes32[]\"}],\"name\":\"getTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"ID\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbolMultihash\",\"type\":\"string\"},{\"internalType\":\"enum IArbitrableTokenTCR.TokenStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"internalType\":\"struct ArbitrableTCRView.Token[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_t2crAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"},{\"internalType\":\"bool[6]\",\"name\":\"_filter\",\"type\":\"bool[6]\"}],\"name\":\"getTokensCursor\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"ID\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbolMultihash\",\"type\":\"string\"},{\"internalType\":\"enum IArbitrableTokenTCR.TokenStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"internalType\":\"struct ArbitrableTCRView.Token[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"hasMore\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_t2crAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"getTokensIDsForAddresses\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"result\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ArbitrableTCRView","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://92b36f94729605076ac913ed4cd64b2c6ae93c7d5fede2f1741241a5d3f59aa4"}]}