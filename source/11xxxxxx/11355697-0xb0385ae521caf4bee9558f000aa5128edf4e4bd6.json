{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n██╗     ███████╗██╗  ██╗    \r\n██║     ██╔════╝╚██╗██╔╝    \r\n██║     █████╗   ╚███╔╝     \r\n██║     ██╔══╝   ██╔██╗     \r\n███████╗███████╗██╔╝ ██╗    \r\n╚══════╝╚══════╝╚═╝  ╚═╝                                                                             \r\n██╗      ██████╗  ██████╗██╗  ██╗███████╗██████╗     \r\n██║     ██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗    \r\n██║     ██║   ██║██║     █████╔╝ █████╗  ██████╔╝    \r\n██║     ██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗    \r\n███████╗╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║    \r\n╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\r\nDEAR MSG.SENDER(S):\r\n/ LXL is a project in beta\r\n// Please audit & use at your own risk\r\n/// Entry into LXL shall not create an attorney/client relationship\r\n//// Likewise, LXL should not be construed as legal advice or replacement for professional counsel\r\n///// STEAL THIS C0D3SL4W \r\n~presented by LexDAO LLC \\+|+/ \r\n*/\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.7.5;\r\n\r\ninterface IERC20 { // brief interface for erc20 token\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary Address { // helper for address type - see openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 { // wrapper around erc20 token tx for non-standard contract - see openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    using Address for address;\r\n    \r\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\r\n    }\r\n    \r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\r\n    }\r\n    \r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returnData) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returnData.length > 0) { // return data is optional\r\n            require(abi.decode(returnData, (bool)), \"SafeERC20: erc20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath { // arithmetic wrapper for under/overflow check\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard { // call wrapper for reentrancy check - see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @title LexLocker.\r\n * @author LexDAO LLC.\r\n * @notice Token locker registry with embedded terms and resolution.\r\n */\r\ncontract LexLocker is ReentrancyGuard { \r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    /*$<⚖️️> LXL <⚔️>$*/\r\n    address public manager; // account managing LXL settings - see 'Manager Functions' - updateable by manager\r\n    address public swiftResolverToken; // token required to participate as swift resolver - updateable by manager\r\n    address public userRewardToken; // token for LXL user rewards - updateable by manager\r\n    address public wETH; // ether token wrapper contract reference - updateable by manager\r\n    uint256 public lockerCount; // lockers counted into LXL registry\r\n    uint256 public MAX_DURATION; // time limit in seconds on token lockup - default 63113904 (2-year) - updateable by manager\r\n    uint256 public resolutionRate; // rate to determine resolution fee for disputed locker (e.g., 20 = 5% of remainder) - updateable by manager\r\n    uint256 public swiftResolverTokenBalance; // balance required in `swiftResolverToken` to participate as swift resolver - updateable by manager\r\n    uint256 public userReward; // reward amount granted to LXL users in `userRewardToken`- updateable by manager\r\n    string public lockerTerms; // general terms wrapping LXL - updateable by manager\r\n    string[] public marketTerms; // embedded market LXL terms - attach to locker `details` (e.g., \"MT:1\") - updateable by manager\r\n    string[] public resolutions; // locker resolutions stamped by LXL resolvers\r\n    \r\n    mapping(address => uint256[]) private registrations; // tracks registered lockers per account (client/provider)\r\n    mapping(address => bool) public swiftResolverRegistrations; // tracks registered swift resolvers\r\n    mapping(uint256 => ADR) public adrs; // tracks ADR details for registered lockers\r\n    mapping(uint256 => Locker) public lockers; // tracks registered lockers details\r\n    \r\n    event DepositLocker(address indexed client, address clientOracle, address indexed provider, address indexed resolver, address token, uint256[] amount, uint256 registration, uint256 sum, uint256 termination, string details, bool swiftResolver);\r\n    event RegisterLocker(address indexed client, address clientOracle, address indexed provider, address indexed resolver, address token, uint256[] amount, uint256 registration, uint256 sum, uint256 termination, string details, bool swiftResolver);\r\n    event ConfirmLocker(uint256 registration); \r\n    event RequestLockerResolution(address indexed client, address indexed counterparty, address indexed resolver, address token, uint256 registration, uint256 sum, string details, bool swiftResolver); \r\n    event Release(uint256 milestone, uint256 payment, uint256 registration); \r\n    event Withdraw(uint256 registration);\r\n    event AssignClientOracle(address indexed clientOracle, uint256 registration);\r\n    event ClientProposeResolver(address indexed proposedResolver, uint256 registration, string details);\r\n    event ProviderProposeResolver(address indexed proposedResolver, uint256 registration, string details);\r\n    event UpdateSwiftResolverStatus(address indexed swiftResolver, string details, bool registered);\r\n    event Lock(address indexed caller, uint256 registration, string details);\r\n    event Resolve(address indexed resolver, uint256 clientAward, uint256 providerAward, uint256 registration, uint256 resolutionFee, string resolution); \r\n    event AddMarketTerms(uint256 index, string terms);\r\n    event AmendMarketTerms(uint256 index, string terms);\r\n    event UpdateLockerSettings(address indexed manager, address swiftResolverToken, address userRewardToken, address wETH, uint256 MAX_DURATION, uint256 resolutionRate, uint256 swiftResolverTokenBalance, uint256 userReward, string lockerTerms);\r\n    event TributeToManager(address indexed caller, uint256 amount, string details);\r\n\r\n    struct ADR {  \r\n        address proposedResolver;\r\n        address resolver;\r\n        uint8 clientProposedResolver;\r\n        uint8 providerProposedResolver;\r\n        uint256 clientAward;\r\n        uint256 providerAward;\r\n\t    uint256 resolutionRate;\r\n\t    string resolution;\r\n\t    bool swiftResolver;\r\n    }\r\n    \r\n    struct Locker {  \r\n        address client; \r\n        address clientOracle;\r\n        address provider;\r\n        address token;\r\n        uint8 confirmed;\r\n        uint8 locked;\r\n        uint256[] amount;\r\n        uint256 currentMilestone;\r\n        uint256 milestones;\r\n        uint256 released;\r\n        uint256 sum;\r\n        uint256 termination;\r\n        string details; \r\n    }\r\n    \r\n    constructor(\r\n        address _manager, \r\n        address _swiftResolverToken,\r\n        address _userRewardToken,\r\n        address _wETH,\r\n        uint256 _MAX_DURATION,\r\n        uint256 _resolutionRate, \r\n        uint256 _swiftResolverTokenBalance, \r\n        uint256 _userReward,\r\n        string memory _lockerTerms\r\n    ) {\r\n        require(_resolutionRate > 0, \"_resolutionRate < 1\");\r\n        \r\n        manager = _manager;\r\n        swiftResolverToken = _swiftResolverToken;\r\n        userRewardToken = _userRewardToken;\r\n        wETH = _wETH;\r\n        MAX_DURATION = _MAX_DURATION;\r\n        resolutionRate = _resolutionRate;\r\n        swiftResolverTokenBalance = _swiftResolverTokenBalance;\r\n        userReward = _userReward;\r\n        lockerTerms = _lockerTerms;\r\n    }\r\n\r\n    /***************\r\n    LOCKER FUNCTIONS\r\n    ***************/\r\n    // ************\r\n    // REGISTRATION\r\n    // ************\r\n    /**\r\n     * @notice LXL can be registered as deposit from `client` for benefit of `provider`.\r\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\r\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\r\n     * @param provider Account to receive registered `amount`s.\r\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\r\n     * @param token Token address for `amount` deposit.\r\n     * @param amount Array of milestone `amount`s to be sent to `provider` on call of `release()`.\r\n     * @param termination Exact `termination` date in seconds since epoch.\r\n     * @param details Context re: LXL.\r\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\r\n     */\r\n    function depositLocker( // CLIENT-TRACK\r\n        address clientOracle, \r\n        address provider,\r\n        address resolver,\r\n        address token,\r\n        uint256[] calldata amount, \r\n        uint256 termination, \r\n        string memory details,\r\n        bool swiftResolver \r\n    ) external nonReentrant payable returns (uint256) {\r\n        require(msg.sender != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\r\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\r\n        \r\n        uint256 sum;\r\n        for (uint256 i = 0; i < amount.length; i++) {\r\n            sum = sum.add(amount[i]);\r\n        }\r\n\r\n        if (msg.value > 0) {\r\n            address weth = wETH;\r\n            require(token == weth && msg.value == sum, \"!ethBalance\");\r\n            (bool success, ) = weth.call{value: msg.value}(\"\");\r\n            require(success, \"!ethCall\");\r\n            IERC20(weth).transfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(token).safeTransferFrom(msg.sender, address(this), sum);\r\n        }\r\n        \r\n        lockerCount++;\r\n        uint256 registration = lockerCount;\r\n        \r\n        registrations[msg.sender].push(registration);\r\n        registrations[provider].push(registration);\r\n        \r\n        adrs[registration] = ADR( \r\n            address(0),\r\n            resolver,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n\t        resolutionRate, \r\n\t        \"\",\r\n\t        swiftResolver);\r\n\r\n        lockers[registration] = Locker( \r\n            msg.sender, \r\n            clientOracle,\r\n            provider,\r\n            token,\r\n            1,\r\n            0,\r\n            amount,\r\n            1,\r\n            amount.length,\r\n            0,\r\n            sum,\r\n            termination,\r\n            details);\r\n        \r\n        if (userReward > 0) {IERC20(userRewardToken).transfer(msg.sender, userReward);} // grant LXL user reward\r\n\r\n        emit DepositLocker(msg.sender, clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \r\n        \r\n\t    return registration;\r\n    }\r\n    \r\n    /**\r\n     * @notice LXL can be registered as single deposit (lump sum) from `client` for benefit of `provider`.\r\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\r\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\r\n     * @param provider Account to receive registered `amount`s.\r\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\r\n     * @param token Token address for `amount` deposit.\r\n     * @param sum Lump `sum` to be sent to `provider` on call of `release()`.\r\n     * @param termination Exact `termination` date in seconds since epoch.\r\n     * @param details Context re: LXL.\r\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\r\n     */\r\n    function depositLockerSingleMilestone( // CLIENT-TRACK\r\n        address clientOracle, \r\n        address provider,\r\n        address resolver,\r\n        address token,\r\n        uint256 sum, \r\n        uint256 termination, \r\n        string calldata details,\r\n        bool swiftResolver \r\n    ) external nonReentrant payable returns (uint256) {\r\n        require(msg.sender != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\r\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\r\n        \r\n        if (msg.value > 0) {\r\n            address weth = wETH;\r\n            require(token == weth && msg.value == sum, \"!ethBalance\");\r\n            (bool success, ) = weth.call{value: msg.value}(\"\");\r\n            require(success, \"!ethCall\");\r\n            IERC20(weth).transfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(token).safeTransferFrom(msg.sender, address(this), sum);\r\n        }\r\n        \r\n        uint256[] memory amount = new uint256[](1);\r\n        amount[0] = sum;\r\n        \r\n        lockerCount++;\r\n        uint256 registration = lockerCount;\r\n        \r\n        registrations[msg.sender].push(registration);\r\n        registrations[provider].push(registration);\r\n        \r\n        adrs[registration] = ADR( \r\n            address(0),\r\n            resolver,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n\t        resolutionRate, \r\n\t        \"\",\r\n\t        swiftResolver);\r\n\r\n        lockers[registration] = Locker( \r\n            msg.sender, \r\n            clientOracle,\r\n            provider,\r\n            token,\r\n            1,\r\n            0,\r\n            amount,\r\n            1,\r\n            1,\r\n            0,\r\n            sum,\r\n            termination,\r\n            details);\r\n        \r\n        if (userReward > 0) {IERC20(userRewardToken).transfer(msg.sender, userReward);} // grant LXL user reward\r\n\r\n        emit DepositLocker(msg.sender, clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \r\n        \r\n\t    return registration;\r\n    }\r\n    \r\n    /**\r\n     * @notice LXL can be registered as `provider` request for `client` deposit (by calling `confirmLocker()`).\r\n     * @param client Account to provide `sum` deposit and call `release()` of registered `amount`s.\r\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\r\n     * @param provider Account to receive registered `amount`s.\r\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\r\n     * @param token Token address for `amount` deposit.\r\n     * @param amount Array of milestone `amount`s to be sent to `provider` on call of `release()`.\r\n     * @param termination Exact `termination` date in seconds since epoch.\r\n     * @param details Context re: LXL.\r\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\r\n     */\r\n    function registerLocker( // PROVIDER-TRACK\r\n        address client,\r\n        address clientOracle, \r\n        address provider,\r\n        address resolver,\r\n        address token,\r\n        uint256[] calldata amount, \r\n        uint256 termination, \r\n        string memory details,\r\n        bool swiftResolver \r\n    ) external nonReentrant returns (uint256) {\r\n        require(client != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\r\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\r\n        \r\n        uint256 sum;\r\n        for (uint256 i = 0; i < amount.length; i++) {\r\n            sum = sum.add(amount[i]);\r\n        }\r\n \r\n        lockerCount++;\r\n        uint256 registration = lockerCount;\r\n        \r\n        registrations[client].push(registration);\r\n        registrations[provider].push(registration);\r\n       \r\n        adrs[registration] = ADR( \r\n            address(0),\r\n            resolver,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n\t        resolutionRate, \r\n\t        \"\",\r\n\t        swiftResolver);\r\n\r\n        lockers[registration] = Locker( \r\n            client, \r\n            clientOracle,\r\n            provider,\r\n            token,\r\n            0,\r\n            0,\r\n            amount,\r\n            1,\r\n            amount.length,\r\n            0,\r\n            sum,\r\n            termination,\r\n            details);\r\n        \r\n        if (userReward > 0) {IERC20(userRewardToken).transfer(msg.sender, userReward);} // grant LXL user reward\r\n\r\n        emit RegisterLocker(client, clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \r\n        \r\n\t    return registration;\r\n    }\r\n    \r\n    /**\r\n     * @notice LXL `client` can confirm after `registerLocker()` is called to deposit `sum` for `provider`.\r\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\r\n     * @param registration Registered LXL number.\r\n     */\r\n    function confirmLocker(uint256 registration) external nonReentrant payable { // PROVIDER-TRACK\r\n        Locker storage locker = lockers[registration];\r\n        \r\n        require(msg.sender == locker.client, \"!client\");\r\n        require(locker.confirmed == 0, \"confirmed\");\r\n        \r\n        if (msg.value > 0) {\r\n            address weth = wETH;\r\n            require(locker.token == weth && msg.value == locker.sum, \"!ethBalance\");\r\n            (bool success, ) = weth.call{value: msg.value}(\"\");\r\n            require(success, \"!ethCall\");\r\n            IERC20(weth).transfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(locker.token).safeTransferFrom(msg.sender, address(this), locker.sum);\r\n        }\r\n        \r\n        locker.confirmed = 1;\r\n        \r\n        emit ConfirmLocker(registration); \r\n    }\r\n    \r\n    /**\r\n     * @notice LXL depositor (`client`) can request direct resolution between selected `counterparty` over `sum`. E.g., staked wager to benefit charity as `counterparty`.\r\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call. \r\n     * @param counterparty Other account (`provider`) that can receive award from `resolver`.\r\n     * @param resolver Account that can call `resolve()` to award `sum` between LXL parties.\r\n     * @param token Token address for `sum`.\r\n     * @param sum Lump `sum` amount for resolution.\r\n     * @param details Context re: resolution request.\r\n     * @param swiftResolver If `true`, `sum` can be resolved by holders of `swiftResolverToken`.\r\n     */\r\n    function requestLockerResolution(address counterparty, address resolver, address token, uint256 sum, string calldata details, bool swiftResolver) external nonReentrant payable returns (uint256) {\r\n        require(msg.sender != resolver && counterparty != resolver, \"client/counterparty = resolver\");\r\n        \r\n        if (msg.value > 0) {\r\n            address weth = wETH;\r\n            require(token == weth && msg.value == sum, \"!ethBalance\");\r\n            (bool success, ) = weth.call{value: msg.value}(\"\");\r\n            require(success, \"!ethCall\");\r\n            IERC20(weth).transfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(token).safeTransferFrom(msg.sender, address(this), sum);\r\n        }\r\n        \r\n        uint256[] memory amount = new uint256[](1);\r\n        amount[0] = sum;\r\n        \r\n        lockerCount++;\r\n        uint256 registration = lockerCount;\r\n        \r\n        registrations[msg.sender].push(registration);\r\n        registrations[counterparty].push(registration);\r\n        \r\n        adrs[registration] = ADR( \r\n            address(0),\r\n            resolver,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n\t        resolutionRate, \r\n\t        \"\",\r\n\t        swiftResolver);\r\n     \r\n        lockers[registration] = Locker( \r\n            msg.sender, \r\n            address(0),\r\n            counterparty,\r\n            token,\r\n            1,\r\n            1,\r\n            amount,\r\n            0,\r\n            0,\r\n            0,\r\n            sum,\r\n            0,\r\n            details);\r\n        \r\n        if (userReward > 0) {IERC20(userRewardToken).transfer(msg.sender, userReward);} // grant LXL user reward\r\n\r\n        emit RequestLockerResolution(msg.sender, counterparty, resolver, token, registration, sum, details, swiftResolver); \r\n        \r\n\t    return registration;\r\n    }\r\n    \r\n    // ***********\r\n    // CLIENT MGMT\r\n    // ***********\r\n    /**\r\n     * @notice LXL `client` can assign account as `clientOracle` to help call `release()` and `withdraw()`.\r\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\r\n     * @param registration Registered LXL number.\r\n     */\r\n    function assignClientOracle(address clientOracle, uint256 registration) external nonReentrant {\r\n        ADR storage adr = adrs[registration];\r\n        Locker storage locker = lockers[registration];\r\n        \r\n        require(msg.sender == locker.client, \"!client\");\r\n        require(clientOracle != adr.resolver, \"clientOracle = resolver\");\r\n        require(locker.locked == 0, \"locked\");\r\n\t    require(locker.released < locker.sum, \"released\");\r\n        \r\n        locker.clientOracle = clientOracle;\r\n        \r\n        emit AssignClientOracle(clientOracle, registration);\r\n    }\r\n    \r\n    /**\r\n     * @notice LXL `client` or `clientOracle` can release milestone `amount` to `provider`. \r\n     * @param registration Registered LXL number.\r\n     */\r\n    function release(uint256 registration) external nonReentrant {\r\n    \tLocker storage locker = lockers[registration];\r\n    \t\r\n    \tuint256 milestone = locker.currentMilestone-1;\r\n        uint256 payment = locker.amount[milestone];\r\n        uint256 released = locker.released;\r\n        uint256 sum = locker.sum;\r\n\t    \r\n\t    require(msg.sender == locker.client || msg.sender == locker.clientOracle, \"!client/oracle\");\r\n\t    require(locker.confirmed == 1, \"!confirmed\");\r\n\t    require(locker.locked == 0, \"locked\");\r\n\t    require(released < sum, \"released\");\r\n\r\n        IERC20(locker.token).safeTransfer(locker.provider, payment);\r\n        locker.released = released.add(payment);\r\n        \r\n        if (locker.released < sum) {locker.currentMilestone++;}\r\n        \r\n\t    emit Release(milestone+1, payment, registration); \r\n    }\r\n    \r\n    /**\r\n     * @notice LXL `client` or `clientOracle` can withdraw `sum` remainder after `termination`. \r\n     * @dev `release()` can still be called by `client` or `clientOracle` after `termination` to preserve extension option. \r\n     * @param registration Registered LXL number.\r\n     */\r\n    function withdraw(uint256 registration) external nonReentrant {\r\n    \tLocker storage locker = lockers[registration];\r\n    \t\r\n    \taddress client = locker.client;\r\n    \tuint256 released = locker.released;\r\n    \tuint256 sum = locker.sum;\r\n        \r\n        require(msg.sender == client || msg.sender == locker.clientOracle, \"!client/oracle\");\r\n        require(locker.confirmed == 1, \"!confirmed\");\r\n        require(locker.locked == 0, \"locked\");\r\n        require(released < sum, \"released\");\r\n        require(locker.termination < block.timestamp, \"!terminated\");\r\n        \r\n        IERC20(locker.token).safeTransfer(client, sum.sub(released));\r\n        locker.released = sum; \r\n        \r\n\t    emit Withdraw(registration); \r\n    }\r\n    \r\n    // **********\r\n    // RESOLUTION\r\n    // **********\r\n    /**\r\n     * @notice LXL `client` or `provider` can lock to freeze release and withdrawal of `sum` remainder until `resolver` calls `resolve()`. \r\n     * @dev `lock()` can be called repeatedly to allow LXL parties to continue to provide context until resolution. \r\n     * @param registration Registered LXL number.\r\n     * @param details Context re: lock / dispute.\r\n     */\r\n    function lock(uint256 registration, string calldata details) external nonReentrant {\r\n        Locker storage locker = lockers[registration]; \r\n        \r\n        require(msg.sender == locker.client || msg.sender == locker.provider, \"!party\"); \r\n        require(locker.confirmed == 1, \"!confirmed\");\r\n        require(locker.released < locker.sum, \"released\");\r\n\r\n\t    locker.locked = 1; \r\n\t    \r\n\t    emit Lock(msg.sender, registration, details);\r\n    }\r\n    \r\n    /**\r\n     * @notice After LXL is locked, selected `resolver` awards `sum` remainder between `client` and `provider` minus fee.\r\n     * @param clientAward Remainder awarded to `client`.\r\n     * @param providerAward Remainder awarded to `provider`.\r\n     * @param registration Registered LXL number.\r\n     * @param resolution Context re: resolution.\r\n     */\r\n    function resolve(uint256 clientAward, uint256 providerAward, uint256 registration, string calldata resolution) external nonReentrant {\r\n        ADR storage adr = adrs[registration];\r\n        Locker storage locker = lockers[registration];\r\n        \r\n        address token = locker.token;\r\n        uint256 released = locker.released;\r\n\t    uint256 sum = locker.sum;\r\n\t    // calculate resolution fee as set on registration:\r\n\t    uint256 remainder = sum.sub(released); \r\n\t    uint256 resolutionFee = remainder.div(adr.resolutionRate); \r\n\t    \r\n\t    require(locker.locked == 1, \"!locked\"); \r\n\t    require(released < sum, \"released\");\r\n\t    require(clientAward.add(providerAward) == remainder.sub(resolutionFee), \"awards != remainder - fee\");\r\n\t    \r\n\t    if (adr.swiftResolver) {\r\n\t        require(msg.sender != locker.client && msg.sender != locker.provider, \"client/provider = swiftResolver\");\r\n\t        require(IERC20(swiftResolverToken).balanceOf(msg.sender) >= swiftResolverTokenBalance && swiftResolverRegistrations[msg.sender], \"!swiftResolverTokenBalance/registered\");\r\n        } else {\r\n            require(msg.sender == adr.resolver, \"!resolver\");\r\n        }\r\n        \r\n        IERC20(token).safeTransfer(msg.sender, resolutionFee);\r\n        IERC20(token).safeTransfer(locker.client, clientAward);\r\n        IERC20(token).safeTransfer(locker.provider, providerAward);\r\n        \r\n        adr.clientAward = clientAward;\r\n\t    adr.providerAward = providerAward;\r\n\t    adr.resolution = resolution;\r\n\t    locker.released = sum; \r\n\t    resolutions.push(resolution);\r\n\t    \r\n\t    emit Resolve(msg.sender, clientAward, providerAward, registration, resolutionFee, resolution);\r\n    }\r\n    \r\n    /**\r\n     * @notice Fallback to allow LXL party to suggest new `resolver` to counterparty.\r\n     * @dev LXL `client` calls to update `resolver` selection - if matches `provider` suggestion or confirmed, `resolver` updates. \r\n     * @param proposedResolver Proposed account to resolve LXL.\r\n     * @param registration Registered LXL number.\r\n     * @param details Context re: proposed `resolver`.\r\n     */\r\n    function clientProposeResolver(address proposedResolver, uint256 registration, string calldata details) external nonReentrant { \r\n        ADR storage adr = adrs[registration];\r\n        Locker storage locker = lockers[registration]; \r\n        \r\n        require(msg.sender == locker.client, \"!client\"); \r\n        require(msg.sender != proposedResolver && locker.clientOracle != proposedResolver && locker.provider != proposedResolver, \"client/clientOracle/provider = proposedResolver\");\r\n        require(adr.clientProposedResolver == 0, \"pending\");\r\n\t    require(locker.released < locker.sum, \"released\");\r\n        \r\n        if (adr.proposedResolver == proposedResolver) {\r\n            adr.resolver = proposedResolver;\r\n        } \r\n\r\n\t    adr.proposedResolver = proposedResolver; \r\n\t    adr.clientProposedResolver = 1;\r\n\t    adr.providerProposedResolver = 0;\r\n\t    \r\n\t    emit ClientProposeResolver(proposedResolver, registration, details);\r\n    }\r\n    \r\n    /**\r\n     * @notice Fallback to allow LXL party to suggest new `resolver` to counterparty.\r\n     * @dev LXL `provider` calls to update `resolver` selection - if matches `client` suggestion or confirmed, `resolver` updates. \r\n     * @param proposedResolver Proposed account to resolve LXL.\r\n     * @param registration Registered LXL number.\r\n     * @param details Context re: proposed `resolver`.\r\n     */\r\n    function providerProposeResolver(address proposedResolver, uint256 registration, string calldata details) external nonReentrant { \r\n        ADR storage adr = adrs[registration];\r\n        Locker storage locker = lockers[registration]; \r\n        \r\n        require(msg.sender == locker.provider, \"!provider\"); \r\n        require(locker.client != proposedResolver && locker.clientOracle != proposedResolver && msg.sender != proposedResolver, \"client/clientOracle/provider = proposedResolver\");\r\n        require(adr.providerProposedResolver == 0, \"pending\");\r\n\t    require(locker.released < locker.sum, \"released\");\r\n\r\n\t    if (adr.proposedResolver == proposedResolver) {\r\n            adr.resolver = proposedResolver;\r\n        } \r\n\t    \r\n\t    adr.proposedResolver = proposedResolver;\r\n\t    adr.clientProposedResolver = 0;\r\n\t    adr.providerProposedResolver = 1;\r\n\t    \r\n\t    emit ProviderProposeResolver(proposedResolver, registration, details);\r\n    }\r\n    \r\n    /**\r\n     * @notice Swift resolvers call to update LXL service status.\r\n     * @dev Swift resolvers must first confirm to participate and can continue with details / cancel LXL service.  \r\n     * @param details Context re: status update.\r\n     * @param registered If `true`, swift resolver can participate in LXL resolution.\r\n     */\r\n    function updateSwiftResolverStatus(string calldata details, bool registered) external nonReentrant {\r\n        require(IERC20(swiftResolverToken).balanceOf(msg.sender) >= swiftResolverTokenBalance, \"!swiftResolverTokenBalance\");\r\n        swiftResolverRegistrations[msg.sender] = registered;\r\n        emit UpdateSwiftResolverStatus(msg.sender, details, registered);\r\n    }\r\n    \r\n    // *******\r\n    // GETTERS\r\n    // *******\r\n    function latestLockerRegistration(address account) external view returns (uint256 latest) { // get latest registered locker per account\r\n        uint256[] memory registered = registrations[account];\r\n        if (registered.length == 0) {return 0;} else {return registered[registered.length-1];}\r\n    }\r\n    \r\n    function lockerRegistrations(address account) external view returns (uint256[] memory registered) { // get registered lockers per account\r\n        return registrations[account];\r\n    }\r\n    \r\n    function marketTermsCount() external view returns (uint256 count) { // get total market terms stamped by `manager`\r\n        return marketTerms.length;\r\n    }\r\n    \r\n    function providerAmounts(uint256 registration) external view returns (address token, uint256[] memory amount) { // get `token` and milestone `amount`s for `provider`\r\n        return (lockers[registration].token, lockers[registration].amount);\r\n    }\r\n    \r\n    function resolutionsCount() external view returns (uint256 count) { // get total resolutions passed by LXL `resolver`s\r\n        return resolutions.length;\r\n    }\r\n   \r\n    /****************\r\n    MANAGER FUNCTIONS\r\n    ****************/\r\n    /**\r\n     * @dev Throws if caller is not LXL `manager`.\r\n     */\r\n    modifier onlyManager {\r\n        require(msg.sender == manager, \"!manager\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @notice Updates LXL with new market `terms`. \r\n     * @param terms New `terms` to add to LXL market. \r\n     */\r\n    function addMarketTerms(string calldata terms) external nonReentrant onlyManager {\r\n        marketTerms.push(terms);\r\n        emit AddMarketTerms(marketTerms.length-1, terms);\r\n    }\r\n    \r\n    /**\r\n     * @notice Updates LXL with amended market `terms`. \r\n     * @param index Targeted location in `marketTerms` array.\r\n     * @param terms Amended `terms` to add to LXL market. \r\n     */\r\n    function amendMarketTerms(uint256 index, string calldata terms) external nonReentrant onlyManager {\r\n        marketTerms[index] = terms;\r\n        emit AmendMarketTerms(index, terms);\r\n    }\r\n    \r\n    /**\r\n     * @notice General ether payment function for `manager` of LXL contract. \r\n     * @param details Describes context for ether transfer.\r\n     */\r\n    function tributeToManager(string calldata details) external nonReentrant payable { \r\n        (bool success, ) = manager.call{value: msg.value}(\"\");\r\n        require(success, \"!ethCall\");\r\n        emit TributeToManager(msg.sender, msg.value, details);\r\n    }\r\n    \r\n    /**\r\n     * @notice Updates LXL management settings.\r\n     * @param _manager Account that governs LXL contract settings.\r\n     * @param _swiftResolverToken Token to mark participants in swift resolution.\r\n     * @param _userRewardToken Token for LXL user rewards.\r\n     * @param _wETH Standard contract reference to wrap ether. \r\n     * @param _MAX_DURATION Time limit in seconds on token lockup - default 63113904 (2-year).\r\n     * @param _resolutionRate Rate to determine resolution fee for locker (e.g., 20 = 5% of remainder).\r\n     * @param _swiftResolverTokenBalance Token balance required to perform swift resolution. \r\n     * @param _userReward Reward amount granted to LXL users in `userRewardToken`.\r\n     * @param _lockerTerms General terms wrapping LXL.  \r\n     */\r\n    function updateLockerSettings(\r\n        address _manager, \r\n        address _swiftResolverToken, \r\n        address _userRewardToken,\r\n        address _wETH, \r\n        uint256 _MAX_DURATION, \r\n        uint256 _resolutionRate, \r\n        uint256 _swiftResolverTokenBalance,\r\n        uint256 _userReward,\r\n        string calldata _lockerTerms\r\n    ) external nonReentrant onlyManager { \r\n        require(_resolutionRate > 0, \"_resolutionRate < 1\");\r\n        \r\n        manager = _manager;\r\n        swiftResolverToken = _swiftResolverToken;\r\n        userRewardToken = _userRewardToken;\r\n        wETH = _wETH;\r\n        MAX_DURATION = _MAX_DURATION;\r\n        resolutionRate = _resolutionRate;\r\n        swiftResolverTokenBalance = _swiftResolverTokenBalance;\r\n        userReward = _userReward;\r\n        lockerTerms = _lockerTerms;\r\n\t    \r\n\t    emit UpdateLockerSettings(_manager, _swiftResolverToken, _userRewardToken, _wETH, _MAX_DURATION, _resolutionRate, _swiftResolverTokenBalance, _userReward, _lockerTerms);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swiftResolverToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userRewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wETH\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_MAX_DURATION\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_resolutionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swiftResolverTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userReward\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_lockerTerms\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"terms\",\"type\":\"string\"}],\"name\":\"AddMarketTerms\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"terms\",\"type\":\"string\"}],\"name\":\"AmendMarketTerms\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"clientOracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"}],\"name\":\"AssignClientOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedResolver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"ClientProposeResolver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"}],\"name\":\"ConfirmLocker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"clientOracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"swiftResolver\",\"type\":\"bool\"}],\"name\":\"DepositLocker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedResolver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"ProviderProposeResolver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"clientOracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"swiftResolver\",\"type\":\"bool\"}],\"name\":\"RegisterLocker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"milestone\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"counterparty\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"swiftResolver\",\"type\":\"bool\"}],\"name\":\"RequestLockerResolution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"clientAward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"providerAward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolutionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"resolution\",\"type\":\"string\"}],\"name\":\"Resolve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"TributeToManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"swiftResolverToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userRewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wETH\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"MAX_DURATION\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolutionRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swiftResolverTokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"lockerTerms\",\"type\":\"string\"}],\"name\":\"UpdateLockerSettings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"swiftResolver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"}],\"name\":\"UpdateSwiftResolverStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"terms\",\"type\":\"string\"}],\"name\":\"addMarketTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adrs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proposedResolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"clientProposedResolver\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"providerProposedResolver\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"clientAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"providerAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resolutionRate\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"resolution\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"swiftResolver\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"terms\",\"type\":\"string\"}],\"name\":\"amendMarketTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clientOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"}],\"name\":\"assignClientOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposedResolver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"clientProposeResolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"}],\"name\":\"confirmLocker\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clientOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"swiftResolver\",\"type\":\"bool\"}],\"name\":\"depositLocker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clientOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"swiftResolver\",\"type\":\"bool\"}],\"name\":\"depositLockerSingleMilestone\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"latestLockerRegistration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"latest\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"lockerRegistrations\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"registered\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockerTerms\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"clientOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"confirmed\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"locked\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"currentMilestone\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"milestones\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketTerms\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketTermsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"}],\"name\":\"providerAmounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposedResolver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"providerProposeResolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"clientOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"termination\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"swiftResolver\",\"type\":\"bool\"}],\"name\":\"registerLocker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"counterparty\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"swiftResolver\",\"type\":\"bool\"}],\"name\":\"requestLockerResolution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolutionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolutions\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolutionsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"clientAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"providerAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"resolution\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"swiftResolverRegistrations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swiftResolverToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swiftResolverTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"tributeToManager\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swiftResolverToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userRewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wETH\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_MAX_DURATION\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_resolutionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swiftResolverTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userReward\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_lockerTerms\",\"type\":\"string\"}],\"name\":\"updateLockerSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"}],\"name\":\"updateSwiftResolverStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userRewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"registration\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LexLocker","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001c0aa8ccd568d90d61659f060d1bfb1e6f855a2000000000000000000000000001b92e2c0d06325089c6fd53c98a214f5c75b2ac00000000000000000000000063125c0d5cd9071de9a1ac84c400982f41c697ae000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000003c30ab0000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000021e19e0c9bab24000000000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000001b42455441202d20557365204c584c206174206f776e207269736b210000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8ff16d97c1b773511f11af63784017a0247e699b77c815b0a16ec59d8daa7e30"}]}