{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"petersburg\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Create2.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n *\\n * _Available since v2.5.0._\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}. Note that\\n     * a contract cannot be deployed twice using the same salt.\\n     */\\n    function deploy(bytes32 salt, bytes memory bytecode) internal returns (address) {\\n        address addr;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the `bytecode`\\n     * or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes memory bytecode) internal view returns (address) {\\n        return computeAddress(salt, bytecode, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes memory bytecodeHash, address deployer) internal pure returns (address) {\\n        bytes32 bytecodeHashHash = keccak256(bytecodeHash);\\n        bytes32 _data = keccak256(\\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHashHash)\\n        );\\n        return address(bytes20(_data << 96));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GSNModules/GSNLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport { SliceLib } from \\\"../libraries/SliceLib.sol\\\";\\n\\nlibrary GSNLib {\\n  bytes32 constant SIGNATURE_MASK = 0xffffffff00000000000000000000000000000000000000000000000000000000;\\n  function toSignature(bytes memory input) internal pure returns (bytes4 signature) {\\n    bytes32 local = SIGNATURE_MASK;\\n    assembly {\\n      signature := and(mload(add(0x20, input)), local)\\n    }\\n  }\\n  function splitPayload(bytes memory payload) internal pure returns (bytes4 signature, bytes memory args) {\\n    signature = toSignature(payload);\\n    args = SliceLib.copy(SliceLib.toSlice(payload, 4));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/GSNModules/GSNModule04.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {IProxyWalletFactory} from \\\"../interfaces/IProxyWalletFactory.sol\\\";\\nimport {GSNLib} from \\\"./GSNLib.sol\\\";\\nimport {ProxyWalletLib} from \\\"../ProxyWallet/ProxyWalletLib.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport { IChi } from \\\"../interfaces/IChi.sol\\\";\\n\\ncontract GSNModule04 is Ownable {\\n    using GSNLib for *;\\n    address public whitelistedRelayer;\\n    address constant CHI_TOKEN = 0x0000000000004946c0e9F43F4Dee607b0eF1fA1c;\\n    // Maximum amount of CHI to burn\\n    uint256 constant MAX_BURN_AMOUNT = 8;\\n\\n    constructor(address _whitelistedRelayer) public Ownable() {\\n        whitelistedRelayer = _whitelistedRelayer;\\n        // Prefill all slots with current gas price\\n        for (uint256 i = 0; i < AVERAGE_N_RECORDS; i++) {\\n            _storeThisGasPrice();\\n        }\\n    }\\n\\n    function _getGSNModule() internal view returns (GSNModule04 gsnModule) {\\n        gsnModule = GSNModule04(ProxyWalletLib.getGSNModule());\\n    }\\n\\n    function _getChiAddress() public view returns (address) {\\n        return CHI_TOKEN;\\n    }\\n\\n    bytes32 constant GAS_PRICE_STORAGE_SLOT =\\n        0x6176eedb4178e8eb1b4156527c106860b74026ff26f7dbc11da0c373efba968a; // keccak256(\\\"gasprice\\\")\\n    bytes32 constant GAS_PRICE_NEXT_POSITION_SLOT =\\n        0x69cf67c52ac5c3626369a2c4ce103b3fffd46fa4d3948f125cbfdc25a5f01d2c; // keccak256(\\\"gasprice-length\\\")\\n    uint256 constant AVERAGE_N_RECORDS = 5;\\n\\n    function _storeNextGasPricePosition(uint256 length) internal {\\n        bytes32 slot = GAS_PRICE_NEXT_POSITION_SLOT;\\n        assembly {\\n            sstore(slot, length)\\n        }\\n    }\\n\\n    function _readNextGasPricePosition() public view returns (uint256 length) {\\n        bytes32 slot = GAS_PRICE_NEXT_POSITION_SLOT;\\n        assembly {\\n            length := sload(slot)\\n        }\\n    }\\n\\n    function _storeGasPrice(\\n        uint256 i,\\n        uint256 gasPrice\\n    ) internal {\\n        bytes32 slot = keccak256(abi.encodePacked(GAS_PRICE_STORAGE_SLOT, i));\\n        assembly {\\n            sstore(slot, gasPrice)\\n        }\\n    }\\n\\n    function _readGasPrice(uint256 i)\\n        public\\n        view\\n        returns (uint256 gasPrice)\\n    {\\n        bytes32 slot = keccak256(abi.encodePacked(GAS_PRICE_STORAGE_SLOT, i));\\n        assembly {\\n            gasPrice := sload(slot)\\n        }\\n    }\\n\\n    function _storeThisGasPrice() internal {\\n        // Get the index of the slot to store gas price in\\n        uint256 position = _readNextGasPricePosition();\\n        _storeGasPrice(position, tx.gasprice);\\n        // Rotate through every AVERAGE_N_RECORDS slots\\n        _storeNextGasPricePosition((position + 1) % AVERAGE_N_RECORDS);\\n    }\\n\\n    function _getMeanGasPrice() public view returns (uint256 result) {\\n        uint256 sum;\\n        for (uint256 i = 0; i < AVERAGE_N_RECORDS; i++) {\\n            uint256 gasPrice = _readGasPrice(i);\\n            sum += gasPrice;\\n        }\\n        result = sum / AVERAGE_N_RECORDS;\\n    }\\n\\n    bytes32 constant GASPRICE_THRESHOLD_SLOT =\\n        0x07350205221d0ce9cc016414b10dfaac01bc9c2a8ddbb38c7fb370049017d90d; // keccak256(\\\"gasprice.threshold\\\")\\n\\n    function setGasPriceThreshold(uint256 threshold) public onlyOwner {\\n        bytes32 slot = GASPRICE_THRESHOLD_SLOT;\\n        assembly {\\n            sstore(slot, threshold)\\n        }\\n    }\\n\\n    function getGasPriceThresholdHandler() public view returns (uint256 threshold) {\\n        bytes32 slot = GASPRICE_THRESHOLD_SLOT;\\n        assembly {\\n            threshold := sload(slot)\\n        }\\n    }\\n\\n    function getGasPriceThreshold() public view returns (uint256 threshold) {\\n        return _getGSNModule().getGasPriceThresholdHandler();\\n    }\\n\\n    function acceptRelayedCall(\\n        address relay,\\n        address from,\\n        bytes memory encodedFunction,\\n        uint256, /* transactionFee */\\n        uint256, /* gasPrice */\\n        uint256, /* gasLimit */\\n        uint256, /* nonce */\\n        bytes memory, /* approvalData */\\n        uint256 /* maxPossibleCharge */\\n    ) public view returns (uint256 doCall, bytes memory) {\\n        (bytes4 signature, bytes memory args) = encodedFunction.splitPayload();\\n        // Allow whitelisted relayer to perform any proxy call\\n        address _whitelistedRelayer = whitelistedRelayer; // save 800 gas\\n        if (\\n            signature == IProxyWalletFactory(0).proxy.selector &&\\n            (relay == _whitelistedRelayer || _whitelistedRelayer == address(0x0))) {\\n            doCall = 0;\\n        } else doCall = 1;\\n    }\\n\\n    function preRelayedCall(\\n        bytes memory /* context */\\n    ) public returns (bytes32) {\\n        _storeThisGasPrice();\\n    }\\n\\n    function postRelayedCall(\\n        bytes memory, /* context */\\n        bool, /* success */\\n        uint256 gasAmount,\\n        bytes32 /* preRetVal */\\n    ) public {\\n        // If moving average of past 5 txs' gas prices is above threshold\\n        if (_getMeanGasPrice() >= getGasPriceThreshold()) {\\n            // Burn Chi to reduce gas costs\\n            IChi(_getChiAddress()).freeUpTo(\\n                Math.min((gasAmount + 14154) / 41947, MAX_BURN_AMOUNT)\\n            ); // divide by twice the max gasrefund Chi token qty since we can only get 50% refunded\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ProxyWallet/ProxyWalletLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { MemcpyLib } from \\\"../libraries/MemcpyLib.sol\\\";\\n\\nlibrary ProxyWalletLib {\\n  bytes32 constant _OWNER_SLOT = 0x734a2a5caf82146a5ddd5263d9af379f9f72724959f0567ddc9df2c40cf2cc20; // keccak256(\\\"owner\\\")\\n  bytes32 constant _WALLET_FACTORY_SALT = 0x154d67e25bcc1ea1986fa661b5b80b8facf3a90be6159e155e199e54a74fcb4d; // keccak256(\\\"wallet-factory\\\")\\n  bytes32 constant _IMPLEMENTATION_SLOT = 0x8ba0ed1f62da1d3048614c2c1feb566f041c8467eb00fb8294776a9179dc1643; // keccak256(\\\"implementation\\\")\\n  bytes32 constant _GSN_MODULE_SLOT = 0x73c1ac149a67e4e6e228d78c3a8df342639f43de1a2480627ae6fad35761d9af; // keccak256(\\\"gsn-module\\\")\\n  function WALLET_FACTORY_SALT() internal pure returns (bytes32 salt) {\\n    salt = _WALLET_FACTORY_SALT;\\n  }\\n  function getImplementation() internal view returns (address implementation) {\\n     bytes32 local = _IMPLEMENTATION_SLOT;\\n     assembly {\\n       implementation := sload(local)\\n     }\\n  }\\n  function setImplementation(address implementation) internal {\\n    bytes32 local = _IMPLEMENTATION_SLOT;\\n    assembly {\\n      sstore(local, implementation)\\n    }\\n  }\\n  function setGSNModule(address gsnModule) internal {\\n    bytes32 local = _GSN_MODULE_SLOT;\\n    assembly {\\n      sstore(local, gsnModule)\\n    }\\n  }\\n  function getGSNModule() internal view returns (address gsnModule) {\\n    bytes32 local = _GSN_MODULE_SLOT;\\n    assembly {\\n      gsnModule := sload(local)\\n    }\\n  }\\n  function getOwner() internal view returns (address owner) {\\n    bytes32 OWNER_SLOT = _OWNER_SLOT;\\n    assembly {\\n      owner := sload(OWNER_SLOT)\\n    }\\n  }\\n  enum CallType {\\n    INVALID,\\n    CALL,\\n    DELEGATECALL\\n  }\\n  struct ProxyCall {\\n    CallType typeCode;\\n    address payable to;\\n    uint256 value;\\n    bytes data;\\n  }\\n  function setOwner(address owner) internal {\\n    bytes32 local = _OWNER_SLOT;\\n    assembly {\\n      sstore(local, owner)\\n    }\\n  }\\n  function proxyCall(ProxyCall memory callDetails) internal returns (bool success, bytes memory returnData) {\\n    if (callDetails.typeCode == CallType.DELEGATECALL) {\\n      (success, returnData) = callDetails.to.delegatecall(callDetails.data);\\n    } else if (callDetails.typeCode == CallType.CALL) {\\n      (success, returnData) = callDetails.to.call.value(callDetails.value)(callDetails.data);\\n    }\\n  }\\n  function computeCreationCode(address target) internal view returns (bytes memory clone) {\\n    clone = computeCreationCode(address(this), target);\\n  }\\n  function computeCreationCode(address deployer, address target) internal pure returns (bytes memory clone) {\\n      bytes memory consData = abi.encodeWithSignature(\\\"cloneConstructor(bytes)\\\", new bytes(0));\\n      clone = new bytes(99 + consData.length);\\n      assembly {\\n        mstore(add(clone, 0x20),\\n           0x3d3d606380380380913d393d73bebebebebebebebebebebebebebebebebebebe)\\n        mstore(add(clone, 0x2d),\\n           mul(deployer, 0x01000000000000000000000000))\\n        mstore(add(clone, 0x41),\\n           0x5af4602a57600080fd5b602d8060366000396000f3363d3d373d3d3d363d73be)\\n           mstore(add(clone, 0x60),\\n           mul(target, 0x01000000000000000000000000))\\n        mstore(add(clone, 116),\\n           0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n      }\\n      for (uint256 i = 0; i < consData.length; i++) {\\n        clone[i + 99] = consData[i];\\n      }\\n  }\\n  function deriveInstanceAddress(address target, bytes32 salt) internal view returns (address) {\\n    return Create2.computeAddress(salt, computeCreationCode(target));\\n  }\\n  function deriveInstanceAddress(address from, address target, bytes32 salt) internal pure returns (address) {\\n     return Create2.computeAddress(salt, computeCreationCode(from, target), from);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChi.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\ninterface IChi {\\n  function freeUpTo(uint256) external returns (uint256);\\n  function mint(uint256) external;\\n  function transfer(address, uint256) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProxyWalletFactory.sol\": {\r\n      \"content\": \"pragma experimental ABIEncoderV2;\\npragma solidity ^0.5.0;\\n\\nimport { ProxyWalletLib } from \\\"../ProxyWallet/ProxyWalletLib.sol\\\";\\n\\ninterface IProxyWalletFactory {\\n  function proxy(ProxyWalletLib.ProxyCall[] calldata /* calls */) external payable returns (bytes[] memory /* returnValues */);\\n  function getImplementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MemcpyLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nlibrary MemcpyLib {\\n  function memcpy(bytes32 dest, bytes32 src, uint256 len) internal pure {\\n    assembly {\\n      for {} iszero(lt(len, 0x20)) { len := sub(len, 0x20) } {\\n        mstore(dest, mload(src))\\n        dest := add(dest, 0x20)\\n        src := add(src, 0x20)\\n      }\\n      let mask := sub(shl(mul(sub(32, len), 8), 1), 1)\\n      mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SliceLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport { MemcpyLib } from \\\"./MemcpyLib.sol\\\";\\n\\nlibrary SliceLib {\\n  struct Slice {\\n    uint256 data;\\n    uint256 length;\\n    uint256 offset;\\n  }\\n  function toPtr(bytes memory input, uint256 offset) internal pure returns (uint256 data) {\\n    assembly {\\n      data := add(input, add(offset, 0x20))\\n    }\\n  }\\n  function toSlice(bytes memory input, uint256 offset, uint256 length) internal pure returns (Slice memory retval) {\\n    retval.data = toPtr(input, offset);\\n    retval.length = length;\\n    retval.offset = offset;\\n  }\\n  function toSlice(bytes memory input) internal pure returns (Slice memory) {\\n    return toSlice(input, 0);\\n  }\\n  function toSlice(bytes memory input, uint256 offset) internal pure returns (Slice memory) {\\n    if (input.length < offset) offset = input.length;\\n    return toSlice(input, offset, input.length - offset);\\n  }\\n  function toSlice(Slice memory input, uint256 offset, uint256 length) internal pure returns (Slice memory) {\\n    return Slice({\\n      data: input.data + offset,\\n      offset: input.offset + offset,\\n      length: length\\n    });\\n  }\\n  function toSlice(Slice memory input, uint256 offset) internal pure returns (Slice memory) {\\n    return toSlice(input, offset, input.length - offset);\\n  }\\n  function toSlice(Slice memory input) internal pure returns (Slice memory) {\\n    return toSlice(input, 0);\\n  }\\n  function maskLastByteOfWordAt(uint256 data) internal pure returns (uint8 lastByte) {\\n    assembly {\\n      lastByte := and(mload(data), 0xff)\\n    }\\n  }\\n  function get(Slice memory slice, uint256 index) internal pure returns (bytes1 result) {\\n    return bytes1(maskLastByteOfWordAt(slice.data - 0x1f + index));\\n  }\\n  function setByteAt(uint256 ptr, uint8 value) internal pure {\\n    assembly {\\n      mstore8(ptr, value)\\n    }\\n  }\\n  function set(Slice memory slice, uint256 index, uint8 value) internal pure {\\n    setByteAt(slice.data + index, value);\\n  }\\n  function wordAt(uint256 ptr, uint256 length) internal pure returns (bytes32 word) {\\n    assembly {\\n      let mask := sub(shl(mul(length, 0x8), 0x1), 0x1)\\n      word := and(mload(sub(ptr, sub(0x20, length))), mask)\\n    }\\n  }\\n  function asWord(Slice memory slice) internal pure returns (bytes32 word) {\\n    uint256 data = slice.data;\\n    uint256 length = slice.length;\\n    return wordAt(data, length);\\n  }\\n  function toDataStart(bytes memory input) internal pure returns (bytes32 start) {\\n    assembly {\\n      start := add(input, 0x20)\\n    }\\n  }\\n  function copy(Slice memory slice) internal pure returns (bytes memory retval) {\\n    uint256 length = slice.length;\\n    retval = new bytes(length);\\n    bytes32 src = bytes32(slice.data);\\n    bytes32 dest = toDataStart(retval);\\n    MemcpyLib.memcpy(dest, src, length);\\n  }\\n  function keccakAt(uint256 data, uint256 length) internal pure returns (bytes32 result) {\\n    assembly {\\n      result := keccak256(data, length)\\n    }\\n  }\\n  function toKeccak(Slice memory slice) internal pure returns (bytes32 result) {\\n    return keccakAt(slice.data, slice.length);\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"_readGasPrice\",\"outputs\":[{\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGasPriceThresholdHandler\",\"outputs\":[{\"name\":\"threshold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setGasPriceThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_getMeanGasPrice\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"preRelayedCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"relay\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"encodedFunction\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"acceptRelayedCall\",\"outputs\":[{\"name\":\"doCall\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_getChiAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_readNextGasPricePosition\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"gasAmount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"postRelayedCall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistedRelayer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGasPriceThreshold\",\"outputs\":[{\"name\":\"threshold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_whitelistedRelayer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"GSNModule04","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000064ff2d76fe3095fb9f0a18c088b345ffd2bf8e85","EVMVersion":"petersburg","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}