{"status":"1","message":"OK","result":[{"SourceCode":"// File: util\\IERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.4;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: util\\IERC1155Receiver.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.4;\r\n\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n}\r\n\r\n// File: IWhereIsMyDragon.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.4;\r\n\r\n\r\ninterface IWhereIsMyDragon is IERC1155Receiver {\r\n    function opt() external view returns(address);\r\n\r\n    function get() external;\r\n}\r\n\r\n// File: util\\ERC165.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.4;\r\n\r\n\r\nabstract contract ERC165 is IERC165 {\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: util\\IEthItem.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.4;\r\n\r\ninterface IEthItem {\r\n\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    function burnBatch(\r\n        uint256[] calldata objectIds,\r\n        uint256[] calldata amounts\r\n    ) external;\r\n}\r\n\r\n// File: WhereIsMyDragon.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.4;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Where Is My Dragon\r\n * In this Contract yoy can find all the ruleHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH!!!!\r\n */\r\ncontract WhereIsMyDragon is IWhereIsMyDragon, ERC165 {\r\n\r\n    uint256 private constant RAG = 0x172 - 0x16f;\r\n\r\n    address private _san;\r\n    address private _frid;\r\n\r\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256)))))) private _bor;\r\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256)))))) private _lid;\r\n\r\n    uint256 private _baskin;\r\n    uint256 private _dolbur;\r\n    uint256[] private _sagar;\r\n    bool[] private _franco;\r\n\r\n    uint256 private _gel;\r\n    uint256 private _sic;\r\n\r\n    constructor(address mon, uint256 tue, uint256 wed, uint256[] memory thru, uint256 fri) ERC165() {\r\n        _san = msg.sender;\r\n        _frid = mon;\r\n        _baskin = tue;\r\n        _dolbur = wed;\r\n        _sagar = thru;\r\n        _gel = fri;\r\n        for(uint256 i = 0; i < _sagar.length; i++) {\r\n            _franco.push(false);\r\n        }\r\n        _parabara();\r\n    }\r\n\r\n    function _parabara() private {\r\n        _registerInterface(this.onERC1155BatchReceived.selector);\r\n    }\r\n\r\n    function opt() public view override returns(address) {\r\n        return _san;\r\n    }\r\n\r\n    function get() public override {\r\n        require(msg.sender == _san);\r\n        _san = address(0);\r\n    }\r\n\r\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns(bytes4) {\r\n        revert();\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address fal,\r\n        uint256[] memory cik,\r\n        uint256[] memory hse,\r\n        bytes memory cas\r\n    ) public virtual override returns (bytes4) {\r\n        require(msg.sender == _frid);\r\n        if(_san != address(0)) {\r\n            (uint256[] memory zik, uint256[] memory bol) = abi.decode(cas, (uint256[], uint256[]));\r\n            _doz(fal, cik, zik, bol);\r\n        } else {\r\n            _dabor(fal, cik, hse, block.number);\r\n        }\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    function _doz(address fal, uint256[] memory cik, uint256[] memory zik, uint256[] memory bol) private {\r\n        require(fal == _san);\r\n        require(zik.length >= RAG && ((zik.length % RAG) == 0));\r\n        require((zik.length / RAG) == cik.length);\r\n        require(zik.length == bol.length);\r\n        for(uint256 i = 0 ; i < zik.length; i+= RAG) {\r\n            uint256 mat = i / RAG;\r\n            (uint256 bil, uint256 cul, uint256 mar) = _moler(zik, i);\r\n            _bor\r\n                [zik[bil]][bol[bil]]\r\n                [zik[cul]][bol[cul]]\r\n                [zik[mar]][bol[mar]] = cik[mat];\r\n\r\n            if(cik[mat] == _gel) {\r\n                _lid\r\n                    [zik[bil]][bol[bil]]\r\n                    [zik[cul]][bol[cul]]\r\n                    [zik[mar]][bol[mar]] = _sic++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _dabor(address fal, uint256[] memory cik, uint256[] memory hse, uint256 sog) private {\r\n        require(_san == address(0));\r\n        require(cik.length >= RAG && ((cik.length % RAG) == 0));\r\n        for(uint256 i = 0; i < cik.length; i+= RAG) {\r\n            (uint256 bil, uint256 cul, uint256 mar) = _moler(cik, i);\r\n\r\n            uint256 ter = _bor\r\n                                [cik[bil]][hse[bil]]\r\n                                [cik[cul]][hse[cul]]\r\n                                [cik[mar]][hse[mar]];\r\n            _sop(cik, hse, bil, cul, mar, ter, sog);\r\n            _irn(cik, hse, bil, cul, mar);\r\n            IEthItem(_frid).safeTransferFrom(address(this), fal, ter, 1, \"\");\r\n        }\r\n    }\r\n\r\n    function _sop(uint256[] memory cik, uint256[] memory hse, uint256 bil, uint256 cul, uint256 mar, uint256 ter, uint256 gis) private {\r\n        if(ter != _gel) {\r\n            return;\r\n        }\r\n        uint256 postadel = _lid\r\n            [cik[bil]][hse[bil]]\r\n            [cik[cul]][hse[cul]]\r\n            [cik[mar]][hse[mar]];\r\n        require(!_franco[postadel]);\r\n        uint256 lav = _sagar[postadel];\r\n        require(gis >= lav);\r\n        uint256 sch = gis - lav;\r\n        uint256 acq = sch / _baskin;\r\n        uint256 lov = lav + (_baskin * acq);\r\n        uint256 gel = lov + _dolbur;\r\n        require(gis >= lov && gis <= gel);\r\n        _franco[postadel] = true;\r\n    }\r\n\r\n    function _irn(uint256[] memory cik, uint256[] memory hse, uint256 bil, uint256 cul, uint256 mar) private {\r\n        uint256[] memory ids = new uint256[](RAG);\r\n        ids[0] = cik[bil];\r\n        ids[1] = cik[cul];\r\n        ids[2] = cik[mar];\r\n        uint256[] memory amts = new uint256[](RAG);\r\n        amts[0] = hse[bil];\r\n        amts[1] = hse[cul];\r\n        amts[2] = hse[mar];\r\n        IEthItem(_frid).burnBatch(ids, amts);\r\n    }\r\n\r\n    function _moler(uint256[] memory sus, uint256 tfo) private pure returns(uint256 bil, uint256 cul, uint256 mar) {\r\n        bil = tfo;\r\n        mar = tfo;\r\n        for(uint256 i = tfo; i < tfo + RAG; i++) {\r\n            if(sus[i] < sus[bil]) {\r\n                bil = i;\r\n            } else if(sus[i] > sus[mar]) {\r\n                mar = i;\r\n            }\r\n        }\r\n        for(uint256 i = tfo; i < tfo + RAG; i++) {\r\n            if(i != mar && i != bil) {\r\n                cul = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mon\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"thru\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"fri\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"get\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fal\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"cik\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"hse\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"cas\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WhereIsMyDragon","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b6ab68a44ecc9fb2244aab83eb2f6dba54205ebf00000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000386c00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000022e6559f495f97af51ff56719cdff80f65a0b93a00000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000af79e00000000000000000000000000000000000000000000000000000000000b204ea0000000000000000000000000000000000000000000000000000000000aa0cfc0000000000000000000000000000000000000000000000000000000000b3b6f10000000000000000000000000000000000000000000000000000000000b71aff0000000000000000000000000000000000000000000000000000000000b568f8","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5e459cd055aeb2d046c371e64b38dc75a1b86a15c9f07c9c93186f2856d17f0c"}]}