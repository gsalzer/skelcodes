{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/libs/common/ZeroCopySource.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over decoding and deserialization operation from bytes into bassic types in Solidity for PolyNetwork cross chain utility.\r\n *\r\n * Decode into basic types in Solidity from bytes easily. It's designed to be used\r\n * for PolyNetwork cross chain application, and the decoding rules on Ethereum chain\r\n * and the encoding rule on other chains should be consistent, and . Here we\r\n * follow the underlying deserialization rule with implementation found here:\r\n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_source.go\r\n *\r\n * Using this library instead of the unchecked serialization method can help reduce\r\n * the risk of serious bugs and handfule, so it's recommended to use it.\r\n *\r\n * Please note that risk can be minimized, yet not eliminated.\r\n */\r\nlibrary ZeroCopySource {\r\n    /* @notice              Read next byte as boolean type starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the boolean value\r\n    *  @return              The the read boolean value and new offset\r\n    */\r\n    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\r\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\r\n        // byte === bytes1\r\n        byte v;\r\n        assembly{\r\n            v := mload(add(add(buff, 0x20), offset))\r\n        }\r\n        bool value;\r\n        if (v == 0x01) {\r\n\t\t    value = true;\r\n    \t} else if (v == 0x00) {\r\n            value = false;\r\n        } else {\r\n            revert(\"NextBool value error\");\r\n        }\r\n        return (value, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next byte starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the byte value\r\n    *  @return              The read byte value and new offset\r\n    */\r\n    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\r\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\r\n        byte v;\r\n        assembly{\r\n            v := mload(add(add(buff, 0x20), offset))\r\n        }\r\n        return (v, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next byte as uint8 starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the byte value\r\n    *  @return              The read uint8 value and new offset\r\n    */\r\n    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\r\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\r\n        uint8 v;\r\n        assembly{\r\n            let tmpbytes := mload(0x40)\r\n            let bvalue := mload(add(add(buff, 0x20), offset))\r\n            mstore8(tmpbytes, byte(0, bvalue))\r\n            mstore(0x40, add(tmpbytes, 0x01))\r\n            v := mload(sub(tmpbytes, 0x1f))\r\n        }\r\n        return (v, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next two bytes as uint16 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint16 value\r\n    *  @return              The read uint16 value and updated offset\r\n    */\r\n    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\r\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\r\n\r\n        uint16 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let bvalue := mload(add(add(buff, 0x20), offset))\r\n            mstore8(tmpbytes, byte(0x01, bvalue))\r\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\r\n            mstore(0x40, add(tmpbytes, 0x02))\r\n            v := mload(sub(tmpbytes, 0x1e))\r\n        }\r\n        return (v, offset + 2);\r\n    }\r\n\r\n\r\n    /* @notice              Read next four bytes as uint32 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint32 value\r\n    *  @return              The read uint32 value and updated offset\r\n    */\r\n    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\r\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\r\n        uint32 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x04\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\r\n        }\r\n        return (v, offset + 4);\r\n    }\r\n\r\n    /* @notice              Read next eight bytes as uint64 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint64 value\r\n    *  @return              The read uint64 value and updated offset\r\n    */\r\n    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\r\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\r\n        uint64 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x08\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\r\n        }\r\n        return (v, offset + 8);\r\n    }\r\n\r\n    /* @notice              Read next 32 bytes as uint256 type starting from offset,\r\n                            there are limits considering the numerical limits in multi-chain\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint256 value\r\n    *  @return              The read uint256 value and updated offset\r\n    */\r\n    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\r\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\r\n        uint256 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x20\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(tmpbytes)\r\n        }\r\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n        return (v, offset + 32);\r\n    }\r\n    /* @notice              Read next variable bytes starting from offset,\r\n                            the decoding rule coming from multi-chain\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read variable bytes array value and updated offset\r\n    */\r\n    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\r\n        uint len;\r\n        (len, offset) = NextVarUint(buff, offset);\r\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\r\n        bytes memory tempBytes;\r\n        assembly{\r\n            switch iszero(len)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(len, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, len)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, len)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return (tempBytes, offset + len);\r\n    }\r\n    /* @notice              Read next 32 bytes starting from offset,\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read bytes32 value and updated offset\r\n    */\r\n    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\r\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\r\n        bytes32 v;\r\n        assembly {\r\n            v := mload(add(buff, add(offset, 0x20)))\r\n        }\r\n        return (v, offset + 32);\r\n    }\r\n\r\n    /* @notice              Read next 20 bytes starting from offset,\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read bytes20 value and updated offset\r\n    */\r\n    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\r\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\r\n        bytes20 v;\r\n        assembly {\r\n            v := mload(add(buff, add(offset, 0x20)))\r\n        }\r\n        return (v, offset + 20);\r\n    }\r\n\r\n    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\r\n        byte v;\r\n        (v, offset) = NextByte(buff, offset);\r\n\r\n        uint value;\r\n        if (v == 0xFD) {\r\n            // return NextUint16(buff, offset);\r\n            (value, offset) = NextUint16(buff, offset);\r\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\r\n            return (value, offset);\r\n        } else if (v == 0xFE) {\r\n            // return NextUint32(buff, offset);\r\n            (value, offset) = NextUint32(buff, offset);\r\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\r\n            return (value, offset);\r\n        } else if (v == 0xFF) {\r\n            // return NextUint64(buff, offset);\r\n            (value, offset) = NextUint64(buff, offset);\r\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\r\n            return (value, offset);\r\n        } else{\r\n            // return (uint8(v), offset);\r\n            value = uint8(v);\r\n            require(value < 0xFD, \"NextVarUint, value outside range\");\r\n            return (value, offset);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libs/common/ZeroCopySink.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over encoding and serialization operation into bytes from bassic types in Solidity for PolyNetwork cross chain utility.\r\n *\r\n * Encode basic types in Solidity into bytes easily. It's designed to be used\r\n * for PolyNetwork cross chain application, and the encoding rules on Ethereum chain\r\n * and the decoding rules on other chains should be consistent. Here we\r\n * follow the underlying serialization rule with implementation found here:\r\n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_sink.go\r\n *\r\n * Using this library instead of the unchecked serialization method can help reduce\r\n * the risk of serious bugs and handfule, so it's recommended to use it.\r\n *\r\n * Please note that risk can be minimized, yet not eliminated.\r\n */\r\nlibrary ZeroCopySink {\r\n    /* @notice          Convert boolean value into bytes\r\n    *  @param b         The boolean value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteBool(bool b) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            mstore(buff, 1)\r\n            switch iszero(b)\r\n            case 1 {\r\n                mstore(add(buff, 0x20), shl(248, 0x00))\r\n                // mstore8(add(buff, 0x20), 0x00)\r\n            }\r\n            default {\r\n                mstore(add(buff, 0x20), shl(248, 0x01))\r\n                // mstore8(add(buff, 0x20), 0x01)\r\n            }\r\n            mstore(0x40, add(buff, 0x21))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert byte value into bytes\r\n    *  @param b         The byte value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteByte(byte b) internal pure returns (bytes memory) {\r\n        return WriteUint8(uint8(b));\r\n    }\r\n\r\n    /* @notice          Convert uint8 value into bytes\r\n    *  @param v         The uint8 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            mstore(buff, 1)\r\n            mstore(add(buff, 0x20), shl(248, v))\r\n            // mstore(add(buff, 0x20), byte(0x1f, v))\r\n            mstore(0x40, add(buff, 0x21))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert uint16 value into bytes\r\n    *  @param v         The uint16 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x02\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x22))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert uint32 value into bytes\r\n    *  @param v         The uint32 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x04\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x24))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert uint64 value into bytes\r\n    *  @param v         The uint64 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x08\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x28))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert limited uint256 value into bytes\r\n    *  @param v         The uint256 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\r\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x20\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x40))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Encode bytes format data into bytes\r\n    *  @param data      The bytes array data\r\n    *  @return          Encoded bytes array\r\n    */\r\n    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\r\n        uint64 l = uint64(data.length);\r\n        return abi.encodePacked(WriteVarUint(l), data);\r\n    }\r\n\r\n    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\r\n        if (v < 0xFD){\r\n    \t\treturn WriteUint8(uint8(v));\r\n    \t} else if (v <= 0xFFFF) {\r\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\r\n    \t} else if (v <= 0xFFFFFFFF) {\r\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\r\n    \t} else {\r\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\r\n    \t}\r\n    }\r\n}\r\n\r\n// File: contracts/libs/utils/ReentrancyGuard.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/utils/Utils.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary Utils {\r\n\r\n    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32\r\n    *  @param _bs   Source bytes array\r\n    *  @return      bytes32\r\n    */\r\n    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\r\n        require(_bs.length == 32, \"bytes length is not 32.\");\r\n        assembly {\r\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\r\n            value := mload(add(_bs, 0x20))\r\n        }\r\n    }\r\n\r\n    /* @notice      Convert bytes to uint256\r\n    *  @param _b    Source bytes should have length of 32\r\n    *  @return      uint256\r\n    */\r\n    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\r\n        require(_bs.length == 32, \"bytes length is not 32.\");\r\n        assembly {\r\n            // load 32 bytes from memory starting from position _bs + 32\r\n            value := mload(add(_bs, 0x20))\r\n        }\r\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n    }\r\n\r\n    /* @notice      Convert uint256 to bytes\r\n    *  @param _b    uint256 that needs to be converted\r\n    *  @return      bytes\r\n    */\r\n    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\r\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n        assembly {\r\n            // Get a location of some free memory and store it in result as\r\n            // Solidity does for memory variables.\r\n            bs := mload(0x40)\r\n            // Put 0x20 at the first word, the length of bytes for uint256 value\r\n            mstore(bs, 0x20)\r\n            //In the next word, put value in bytes format to the next 32 bytes\r\n            mstore(add(bs, 0x20), _value)\r\n            // Update the free-memory pointer by padding our last write location to 32 bytes\r\n            mstore(0x40, add(bs, 0x40))\r\n        }\r\n    }\r\n\r\n    /* @notice      Convert bytes to address\r\n    *  @param _bs   Source bytes: bytes length must be 20\r\n    *  @return      Converted address from source bytes\r\n    */\r\n    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\r\n    {\r\n        require(_bs.length == 20, \"bytes length does not match address\");\r\n        assembly {\r\n            // for _bs, first word store _bs.length, second word store _bs.value\r\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\r\n            addr := mload(add(_bs, 0x14))\r\n        }\r\n\r\n    }\r\n\r\n    /* @notice      Convert address to bytes\r\n    *  @param _addr Address need to be converted\r\n    *  @return      Converted bytes from address\r\n    */\r\n    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\r\n        assembly {\r\n            // Get a location of some free memory and store it in result as\r\n            // Solidity does for memory variables.\r\n            bs := mload(0x40)\r\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\r\n            mstore(bs, 0x14)\r\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\r\n            mstore(add(bs, 0x20), shl(96, _addr))\r\n            // Update the free-memory pointer by padding our last write location to 32 bytes\r\n            mstore(0x40, add(bs, 0x40))\r\n       }\r\n    }\r\n\r\n    /* @notice          Do hash leaf as the multi-chain does\r\n    *  @param _data     Data in bytes format\r\n    *  @return          Hashed value in bytes32 format\r\n    */\r\n    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\r\n        result = sha256(abi.encodePacked(byte(0x0), _data));\r\n    }\r\n\r\n    /* @notice          Do hash children as the multi-chain does\r\n    *  @param _l        Left node\r\n    *  @param _r        Right node\r\n    *  @return          Hashed value in bytes32 format\r\n    */\r\n    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\r\n        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\r\n    }\r\n\r\n    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately\r\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368\r\n    *  @param _preBytes     The bytes stored in storage\r\n    *  @param _postBytes    The bytes stored in memory\r\n    *  @return              Bool type indicating if they are equal\r\n    */\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // fslot can contain both the length and contents of the array\r\n                // if slength < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                // slength != 0\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    /* @notice              Slice the _bytes from _start index till the result has length of _length\r\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246\r\n    *  @param _bytes        The original bytes needs to be sliced\r\n    *  @param _start        The index of _bytes for the start of sliced bytes\r\n    *  @param _length       The index of _bytes for the end of sliced bytes\r\n    *  @return              The sliced bytes\r\n    */\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                // lengthmod <= _length % 32\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m\r\n    *  @param _keepers      The array consists of serveral address\r\n    *  @param _signers      Some specific addresses to be looked into\r\n    *  @param _m            The number requirement paramter\r\n    *  @return              True means containment, false meansdo do not contain.\r\n    */\r\n    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\r\n        uint m = 0;\r\n        for(uint i = 0; i < _signers.length; i++){\r\n            for (uint j = 0; j < _keepers.length; j++) {\r\n                if (_signers[i] == _keepers[j]) {\r\n                    m++;\r\n                    delete _keepers[j];\r\n                }\r\n            }\r\n        }\r\n        return m >= _m;\r\n    }\r\n\r\n    /* @notice              TODO\r\n    *  @param key\r\n    *  @return\r\n    */\r\n    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {\r\n         require(key.length >= 67, \"key lenggh is too short\");\r\n         newkey = slice(key, 0, 35);\r\n         if (uint8(key[66]) % 2 == 0){\r\n             newkey[2] = byte(0x02);\r\n         } else {\r\n             newkey[2] = byte(0x03);\r\n         }\r\n         return newkey;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/math/SafeMath.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Wallet.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface ERC20 {\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n/// @title The Wallet contract for Switcheo TradeHub\r\n/// @author Switcheo Network\r\n/// @notice This contract faciliates deposits for Switcheo TradeHub.\r\n/// @dev This contract is used together with the LockProxy contract to allow users\r\n/// to deposit funds without requiring them to have ETH\r\ncontract Wallet {\r\n    bool public isInitialized;\r\n    address public creator;\r\n    address public owner;\r\n    bytes public swthAddress;\r\n\r\n    function initialize(address _owner, bytes calldata _swthAddress) external {\r\n        require(isInitialized == false, \"Contract already initialized\");\r\n        isInitialized = true;\r\n        creator = msg.sender;\r\n        owner = _owner;\r\n        swthAddress = _swthAddress;\r\n    }\r\n\r\n    /// @dev Allow this contract to receive Ethereum\r\n    receive() external payable {}\r\n\r\n    /// @dev Allow this contract to receive ERC223 tokens\r\n    // An empty implementation is required so that the ERC223 token will not\r\n    // throw an error on transfer\r\n    function tokenFallback(address, uint, bytes calldata) external {}\r\n\r\n    /// @dev send ETH from this contract to its creator\r\n    function sendETHToCreator(uint256 _amount) external {\r\n        require(msg.sender == creator, \"Sender must be creator\");\r\n        // we use `call` here following the recommendation from\r\n        // https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/\r\n        (bool success,  ) = creator.call{value: _amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    /// @dev send tokens from this contract to its creator\r\n    function sendERC20ToCreator(address _assetId, uint256 _amount) external {\r\n        require(msg.sender == creator, \"Sender must be creator\");\r\n\r\n        ERC20 token = ERC20(_assetId);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.transfer.selector,\r\n                creator,\r\n                _amount\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(ERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(_isContract(address(token)), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `_isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function _isContract(address account) private view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\n// File: contracts/LockProxy.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface CCM {\r\n    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\r\n}\r\n\r\ninterface CCMProxy {\r\n    function getEthCrossChainManager() external view returns (address);\r\n}\r\n\r\n/// @title The LockProxy contract for Switcheo TradeHub\r\n/// @author Switcheo Network\r\n/// @notice This contract faciliates deposits and withdrawals to Switcheo TradeHub.\r\n/// @dev The contract also allows for additional features in the future through \"extension\" contracts.\r\ncontract LockProxy is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    // used for cross-chain addExtension and removeExtension methods\r\n    struct ExtensionTxArgs {\r\n        bytes extensionAddress;\r\n    }\r\n\r\n    // used for cross-chain registerAsset method\r\n    struct RegisterAssetTxArgs {\r\n        bytes assetHash;\r\n        bytes nativeAssetHash;\r\n    }\r\n\r\n    // used for cross-chain lock and unlock methods\r\n    struct TransferTxArgs {\r\n        bytes fromAssetHash;\r\n        bytes toAssetHash;\r\n        bytes toAddress;\r\n        uint256 amount;\r\n        uint256 feeAmount;\r\n        bytes feeAddress;\r\n        bytes fromAddress;\r\n        uint256 nonce;\r\n    }\r\n\r\n    // used to create a unique salt for wallet creation\r\n    bytes public constant SALT_PREFIX = \"switcheo-eth-wallet-factory-v1\";\r\n    address public constant ETH_ASSET_HASH = address(0);\r\n\r\n    CCMProxy public ccmProxy;\r\n    uint64 public counterpartChainId;\r\n    uint256 public currentNonce = 0;\r\n\r\n    // a mapping of assetHashes to the hash of\r\n    // (associated proxy address on Switcheo TradeHub, associated asset hash on Switcheo TradeHub)\r\n    mapping(address => bytes32) public registry;\r\n\r\n    // a record of signed messages to prevent replay attacks\r\n    mapping(bytes32 => bool) public seenMessages;\r\n\r\n    // a mapping of extension contracts\r\n    mapping(address => bool) public extensions;\r\n\r\n    // a record of created wallets\r\n    mapping(address => bool) public wallets;\r\n\r\n    event LockEvent(\r\n        address fromAssetHash,\r\n        address fromAddress,\r\n        uint64 toChainId,\r\n        bytes toAssetHash,\r\n        bytes toAddress,\r\n        bytes txArgs\r\n    );\r\n\r\n    event UnlockEvent(\r\n        address toAssetHash,\r\n        address toAddress,\r\n        uint256 amount,\r\n        bytes txArgs\r\n    );\r\n\r\n    constructor(address _ccmProxyAddress, uint64 _counterpartChainId) public {\r\n        require(_counterpartChainId > 0, \"counterpartChainId cannot be zero\");\r\n        require(_ccmProxyAddress != address(0), \"ccmProxyAddress cannot be empty\");\r\n        counterpartChainId = _counterpartChainId;\r\n        ccmProxy = CCMProxy(_ccmProxyAddress);\r\n    }\r\n\r\n    modifier onlyManagerContract() {\r\n        require(\r\n            msg.sender == ccmProxy.getEthCrossChainManager(),\r\n            \"msg.sender is not CCM\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Allow this contract to receive Ethereum\r\n    receive() external payable {}\r\n\r\n    /// @dev Allow this contract to receive ERC223 tokens\r\n    /// An empty implementation is required so that the ERC223 token will not\r\n    /// throw an error on transfer, this is specific to ERC223 tokens which\r\n    /// require this implementation, e.g. DGTX\r\n    function tokenFallback(address, uint, bytes calldata) external {}\r\n\r\n    /// @dev Calculate the wallet address for the given owner and Switcheo TradeHub address\r\n    /// @param _ownerAddress the Ethereum address which the user has control over, i.e. can sign msgs with\r\n    /// @param _swthAddress the hex value of the user's Switcheo TradeHub address\r\n    /// @param _bytecodeHash the hash of the wallet contract's bytecode\r\n    /// @return the wallet address\r\n    function getWalletAddress(\r\n        address _ownerAddress,\r\n        bytes calldata _swthAddress,\r\n        bytes32 _bytecodeHash\r\n    )\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        bytes32 salt = _getSalt(\r\n            _ownerAddress,\r\n            _swthAddress\r\n        );\r\n\r\n        bytes32 data = keccak256(\r\n            abi.encodePacked(bytes1(0xff), address(this), salt, _bytecodeHash)\r\n        );\r\n\r\n        return address(bytes20(data << 96));\r\n    }\r\n\r\n    /// @dev Create the wallet for the given owner and Switcheo TradeHub address\r\n    /// @param _ownerAddress the Ethereum address which the user has control over, i.e. can sign msgs with\r\n    /// @param _swthAddress the hex value of the user's Switcheo TradeHub address\r\n    /// @return true if success\r\n    function createWallet(\r\n        address _ownerAddress,\r\n        bytes calldata _swthAddress\r\n    )\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        require(_ownerAddress != address(0), \"Empty ownerAddress\");\r\n        require(_swthAddress.length != 0, \"Empty swthAddress\");\r\n\r\n        bytes32 salt = _getSalt(\r\n            _ownerAddress,\r\n            _swthAddress\r\n        );\r\n\r\n        Wallet wallet = new Wallet{salt: salt}();\r\n        wallet.initialize(_ownerAddress, _swthAddress);\r\n        wallets[address(wallet)] = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Add a contract as an extension\r\n    /// @param _argsBz the serialized ExtensionTxArgs\r\n    /// @param _fromChainId the originating chainId\r\n    /// @return true if success\r\n    function addExtension(\r\n        bytes calldata _argsBz,\r\n        bytes calldata /* _fromContractAddr */,\r\n        uint64 _fromChainId\r\n    )\r\n        external\r\n        onlyManagerContract\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        require(_fromChainId == counterpartChainId, \"Invalid chain ID\");\r\n\r\n        ExtensionTxArgs memory args = _deserializeExtensionTxArgs(_argsBz);\r\n        address extensionAddress = Utils.bytesToAddress(args.extensionAddress);\r\n        extensions[extensionAddress] = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Remove a contract from the extensions mapping\r\n    /// @param _argsBz the serialized ExtensionTxArgs\r\n    /// @param _fromChainId the originating chainId\r\n    /// @return true if success\r\n    function removeExtension(\r\n        bytes calldata _argsBz,\r\n        bytes calldata /* _fromContractAddr */,\r\n        uint64 _fromChainId\r\n    )\r\n        external\r\n        onlyManagerContract\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        require(_fromChainId == counterpartChainId, \"Invalid chain ID\");\r\n\r\n        ExtensionTxArgs memory args = _deserializeExtensionTxArgs(_argsBz);\r\n        address extensionAddress = Utils.bytesToAddress(args.extensionAddress);\r\n        extensions[extensionAddress] = false;\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Marks an asset as registered by mapping the asset's address to\r\n    /// the specified _fromContractAddr and assetHash on Switcheo TradeHub\r\n    /// @param _argsBz the serialized RegisterAssetTxArgs\r\n    /// @param _fromContractAddr the associated contract address on Switcheo TradeHub\r\n    /// @param _fromChainId the originating chainId\r\n    /// @return true if success\r\n    function registerAsset(\r\n        bytes calldata _argsBz,\r\n        bytes calldata _fromContractAddr,\r\n        uint64 _fromChainId\r\n    )\r\n        external\r\n        onlyManagerContract\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        require(_fromChainId == counterpartChainId, \"Invalid chain ID\");\r\n\r\n        RegisterAssetTxArgs memory args = _deserializeRegisterAssetTxArgs(_argsBz);\r\n        _markAssetAsRegistered(\r\n            Utils.bytesToAddress(args.nativeAssetHash),\r\n            _fromContractAddr,\r\n            args.assetHash\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Performs a deposit from a Wallet contract\r\n    /// @param _walletAddress address of the wallet contract, the wallet contract\r\n    /// does not receive ETH in this call, but _walletAddress still needs to be payable\r\n    /// since the wallet contract can receive ETH, there would be compile errors otherwise\r\n    /// @param _assetHash the asset to deposit\r\n    /// @param _targetProxyHash the associated proxy hash on Switcheo TradeHub\r\n    /// @param _toAssetHash the associated asset hash on Switcheo TradeHub\r\n    /// @param _feeAddress the hex version of the Switcheo TradeHub address to send the fee to\r\n    /// @param _values[0]: amount, the number of tokens to deposit\r\n    /// @param _values[1]: feeAmount, the number of tokens to be used as fees\r\n    /// @param _values[2]: nonce, to prevent replay attacks\r\n    /// @param _values[3]: callAmount, some tokens may burn an amount before transfer\r\n    /// so we allow a callAmount to support these tokens\r\n    /// @param _v: the v value of the wallet owner's signature\r\n    /// @param _rs: the r, s values of the wallet owner's signature\r\n    function lockFromWallet(\r\n        address payable _walletAddress,\r\n        address _assetHash,\r\n        bytes calldata _targetProxyHash,\r\n        bytes calldata _toAssetHash,\r\n        bytes calldata _feeAddress,\r\n        uint256[] calldata _values,\r\n        uint8 _v,\r\n        bytes32[] calldata _rs\r\n    )\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        require(wallets[_walletAddress], \"Invalid wallet address\");\r\n\r\n        Wallet wallet = Wallet(_walletAddress);\r\n        _validateLockFromWallet(\r\n            wallet.owner(),\r\n            _assetHash,\r\n            _targetProxyHash,\r\n            _toAssetHash,\r\n            _feeAddress,\r\n            _values,\r\n            _v,\r\n            _rs\r\n        );\r\n\r\n        // it is very important that this function validates the success of a transfer correctly\r\n        // since, once this line is passed, the deposit is assumed to be successful\r\n        // which will eventually result in the specified amount of tokens being minted for the\r\n        // wallet.swthAddress on Switcheo TradeHub\r\n        _transferInFromWallet(_walletAddress, _assetHash, _values[0], _values[3]);\r\n\r\n        _lock(\r\n            _assetHash,\r\n            _targetProxyHash,\r\n            _toAssetHash,\r\n            wallet.swthAddress(),\r\n            _values[0],\r\n            _values[1],\r\n            _feeAddress\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Performs a deposit\r\n    /// @param _assetHash the asset to deposit\r\n    /// @param _targetProxyHash the associated proxy hash on Switcheo TradeHub\r\n    /// @param _toAddress the hex version of the Switcheo TradeHub address to deposit to\r\n    /// @param _toAssetHash the associated asset hash on Switcheo TradeHub\r\n    /// @param _feeAddress the hex version of the Switcheo TradeHub address to send the fee to\r\n    /// @param _values[0]: amount, the number of tokens to deposit\r\n    /// @param _values[1]: feeAmount, the number of tokens to be used as fees\r\n    /// @param _values[2]: callAmount, some tokens may burn an amount before transfer\r\n    /// so we allow a callAmount to support these tokens\r\n    function lock(\r\n        address _assetHash,\r\n        bytes calldata _targetProxyHash,\r\n        bytes calldata _toAddress,\r\n        bytes calldata _toAssetHash,\r\n        bytes calldata _feeAddress,\r\n        uint256[] calldata _values\r\n    )\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n\r\n        // it is very important that this function validates the success of a transfer correctly\r\n        // since, once this line is passed, the deposit is assumed to be successful\r\n        // which will eventually result in the specified amount of tokens being minted for the\r\n        // _toAddress on Switcheo TradeHub\r\n        _transferIn(_assetHash, _values[0], _values[2]);\r\n\r\n        _lock(\r\n            _assetHash,\r\n            _targetProxyHash,\r\n            _toAssetHash,\r\n            _toAddress,\r\n            _values[0],\r\n            _values[1],\r\n            _feeAddress\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Performs a withdrawal that was initiated on Switcheo TradeHub\r\n    /// @param _argsBz the serialized TransferTxArgs\r\n    /// @param _fromContractAddr the associated contract address on Switcheo TradeHub\r\n    /// @param _fromChainId the originating chainId\r\n    /// @return true if success\r\n    function unlock(\r\n        bytes calldata _argsBz,\r\n        bytes calldata _fromContractAddr,\r\n        uint64 _fromChainId\r\n    )\r\n        external\r\n        onlyManagerContract\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        require(_fromChainId == counterpartChainId, \"Invalid chain ID\");\r\n\r\n        TransferTxArgs memory args = _deserializeTransferTxArgs(_argsBz);\r\n        require(args.fromAssetHash.length > 0, \"Invalid fromAssetHash\");\r\n        require(args.toAssetHash.length == 20, \"Invalid toAssetHash\");\r\n\r\n        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\r\n        address toAddress = Utils.bytesToAddress(args.toAddress);\r\n\r\n        _validateAssetRegistration(toAssetHash, _fromContractAddr, args.fromAssetHash);\r\n        _transferOut(toAddress, toAssetHash, args.amount);\r\n\r\n        emit UnlockEvent(toAssetHash, toAddress, args.amount, _argsBz);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Performs a transfer of funds, this is only callable by approved extension contracts\r\n    /// the `nonReentrant` guard is intentionally not added to this function, to allow for more flexibility.\r\n    /// The calling contract should be secure and have its own `nonReentrant` guard as needed.\r\n    /// @param _receivingAddress the address to transfer to\r\n    /// @param _assetHash the asset to transfer\r\n    /// @param _amount the amount to transfer\r\n    /// @return true if success\r\n    function extensionTransfer(\r\n        address _receivingAddress,\r\n        address _assetHash,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool)\r\n    {\r\n        require(\r\n            extensions[msg.sender] == true,\r\n            \"Invalid extension\"\r\n        );\r\n\r\n        if (_assetHash == ETH_ASSET_HASH) {\r\n            // we use `call` here since the _receivingAddress could be a contract\r\n            // see https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/\r\n            // for more info\r\n            (bool success,  ) = _receivingAddress.call{value: _amount}(\"\");\r\n            require(success, \"Transfer failed\");\r\n            return true;\r\n        }\r\n\r\n        ERC20 token = ERC20(_assetHash);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                _receivingAddress,\r\n                _amount\r\n            )\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Marks an asset as registered by associating it to a specified Switcheo TradeHub proxy and asset hash\r\n    /// @param _assetHash the address of the asset to mark\r\n    /// @param _proxyAddress the associated proxy address on Switcheo TradeHub\r\n    /// @param _toAssetHash the associated asset hash on Switcheo TradeHub\r\n    function _markAssetAsRegistered(\r\n        address _assetHash,\r\n        bytes memory _proxyAddress,\r\n        bytes memory _toAssetHash\r\n    )\r\n        private\r\n    {\r\n        require(_proxyAddress.length == 20, \"Invalid proxyAddress\");\r\n        require(\r\n            registry[_assetHash] == bytes32(0),\r\n            \"Asset already registered\"\r\n        );\r\n\r\n        bytes32 value = keccak256(abi.encodePacked(\r\n            _proxyAddress,\r\n            _toAssetHash\r\n        ));\r\n\r\n        registry[_assetHash] = value;\r\n    }\r\n\r\n    /// @dev Validates that an asset's registration matches the given params\r\n    /// @param _assetHash the address of the asset to check\r\n    /// @param _proxyAddress the expected proxy address on Switcheo TradeHub\r\n    /// @param _toAssetHash the expected asset hash on Switcheo TradeHub\r\n    function _validateAssetRegistration(\r\n        address _assetHash,\r\n        bytes memory _proxyAddress,\r\n        bytes memory _toAssetHash\r\n    )\r\n        private\r\n        view\r\n    {\r\n        require(_proxyAddress.length == 20, \"Invalid proxyAddress\");\r\n        bytes32 value = keccak256(abi.encodePacked(\r\n            _proxyAddress,\r\n            _toAssetHash\r\n        ));\r\n        require(registry[_assetHash] == value, \"Asset not registered\");\r\n    }\r\n\r\n    /// @dev validates the asset registration and calls the CCM contract\r\n    function _lock(\r\n        address _fromAssetHash,\r\n        bytes memory _targetProxyHash,\r\n        bytes memory _toAssetHash,\r\n        bytes memory _toAddress,\r\n        uint256 _amount,\r\n        uint256 _feeAmount,\r\n        bytes memory _feeAddress\r\n    )\r\n        private\r\n    {\r\n        require(_targetProxyHash.length == 20, \"Invalid targetProxyHash\");\r\n        require(_toAssetHash.length > 0, \"Empty toAssetHash\");\r\n        require(_toAddress.length > 0, \"Empty toAddress\");\r\n        require(_amount > 0, \"Amount must be more than zero\");\r\n        require(_feeAmount < _amount, \"Fee amount cannot be greater than amount\");\r\n\r\n        _validateAssetRegistration(_fromAssetHash, _targetProxyHash, _toAssetHash);\r\n\r\n        TransferTxArgs memory txArgs = TransferTxArgs({\r\n            fromAssetHash: Utils.addressToBytes(_fromAssetHash),\r\n            toAssetHash: _toAssetHash,\r\n            toAddress: _toAddress,\r\n            amount: _amount,\r\n            feeAmount: _feeAmount,\r\n            feeAddress: _feeAddress,\r\n            fromAddress: abi.encodePacked(msg.sender),\r\n            nonce: _getNextNonce()\r\n        });\r\n\r\n        bytes memory txData = _serializeTransferTxArgs(txArgs);\r\n        CCM ccm = _getCcm();\r\n        require(\r\n            ccm.crossChain(counterpartChainId, _targetProxyHash, \"unlock\", txData),\r\n            \"EthCrossChainManager crossChain executed error!\"\r\n        );\r\n\r\n        emit LockEvent(_fromAssetHash, msg.sender, counterpartChainId, _toAssetHash, _toAddress, txData);\r\n    }\r\n\r\n    /// @dev validate the signature for lockFromWallet\r\n    function _validateLockFromWallet(\r\n        address _walletOwner,\r\n        address _assetHash,\r\n        bytes memory _targetProxyHash,\r\n        bytes memory _toAssetHash,\r\n        bytes memory _feeAddress,\r\n        uint256[] memory _values,\r\n        uint8 _v,\r\n        bytes32[] memory _rs\r\n    )\r\n        private\r\n    {\r\n        bytes32 message = keccak256(abi.encodePacked(\r\n            \"sendTokens\",\r\n            _assetHash,\r\n            _targetProxyHash,\r\n            _toAssetHash,\r\n            _feeAddress,\r\n            _values[0],\r\n            _values[1],\r\n            _values[2]\r\n        ));\r\n\r\n        require(seenMessages[message] == false, \"Message already seen\");\r\n        seenMessages[message] = true;\r\n        _validateSignature(message, _walletOwner, _v, _rs[0], _rs[1]);\r\n    }\r\n\r\n    /// @dev transfers funds from a Wallet contract into this contract\r\n    /// the difference between this contract's before and after balance must equal _amount\r\n    /// this is assumed to be sufficient in ensuring that the expected amount\r\n    /// of funds were transferred in\r\n    function _transferInFromWallet(\r\n        address payable _walletAddress,\r\n        address _assetHash,\r\n        uint256 _amount,\r\n        uint256 _callAmount\r\n    )\r\n        private\r\n    {\r\n        Wallet wallet = Wallet(_walletAddress);\r\n        if (_assetHash == ETH_ASSET_HASH) {\r\n            uint256 before = address(this).balance;\r\n\r\n            wallet.sendETHToCreator(_callAmount);\r\n\r\n            uint256 transferred = address(this).balance.sub(before);\r\n            require(transferred == _amount, \"ETH transferred does not match the expected amount\");\r\n            return;\r\n        }\r\n\r\n        ERC20 token = ERC20(_assetHash);\r\n        uint256 before = token.balanceOf(address(this));\r\n\r\n        wallet.sendERC20ToCreator(_assetHash, _callAmount);\r\n\r\n        uint256 transferred = token.balanceOf(address(this)).sub(before);\r\n        require(transferred == _amount, \"Tokens transferred does not match the expected amount\");\r\n    }\r\n\r\n    /// @dev transfers funds from an address into this contract\r\n    /// for ETH transfers, we only check that msg.value == _amount, and _callAmount is ignored\r\n    /// for token transfers, the difference between this contract's before and after balance must equal _amount\r\n    /// these checks are assumed to be sufficient in ensuring that the expected amount\r\n    /// of funds were transferred in\r\n    function _transferIn(\r\n        address _assetHash,\r\n        uint256 _amount,\r\n        uint256 _callAmount\r\n    )\r\n        private\r\n    {\r\n        if (_assetHash == ETH_ASSET_HASH) {\r\n            require(msg.value == _amount, \"ETH transferred does not match the expected amount\");\r\n            return;\r\n        }\r\n\r\n        ERC20 token = ERC20(_assetHash);\r\n        uint256 before = token.balanceOf(address(this));\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.transferFrom.selector,\r\n                msg.sender,\r\n                address(this),\r\n                _callAmount\r\n            )\r\n        );\r\n        uint256 transferred = token.balanceOf(address(this)).sub(before);\r\n        require(transferred == _amount, \"Tokens transferred does not match the expected amount\");\r\n    }\r\n\r\n    /// @dev transfers funds from this contract to the _toAddress\r\n    function _transferOut(\r\n        address _toAddress,\r\n        address _assetHash,\r\n        uint256 _amount\r\n    )\r\n        private\r\n    {\r\n        if (_assetHash == ETH_ASSET_HASH) {\r\n            // we use `call` here since the _receivingAddress could be a contract\r\n            // see https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/\r\n            // for more info\r\n            (bool success,  ) = _toAddress.call{value: _amount}(\"\");\r\n            require(success, \"Transfer failed\");\r\n            return;\r\n        }\r\n\r\n        ERC20 token = ERC20(_assetHash);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.transfer.selector,\r\n                _toAddress,\r\n                _amount\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @dev validates a signature against the specified user address\r\n    function _validateSignature(\r\n        bytes32 _message,\r\n        address _user,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        bytes32 prefixedMessage = keccak256(abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n32\",\r\n            _message\r\n        ));\r\n\r\n        require(\r\n            _user == ecrecover(prefixedMessage, _v, _r, _s),\r\n            \"Invalid signature\"\r\n        );\r\n    }\r\n\r\n    function _serializeTransferTxArgs(TransferTxArgs memory args) private pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        buff = abi.encodePacked(\r\n            ZeroCopySink.WriteVarBytes(args.fromAssetHash),\r\n            ZeroCopySink.WriteVarBytes(args.toAssetHash),\r\n            ZeroCopySink.WriteVarBytes(args.toAddress),\r\n            ZeroCopySink.WriteUint255(args.amount),\r\n            ZeroCopySink.WriteUint255(args.feeAmount),\r\n            ZeroCopySink.WriteVarBytes(args.feeAddress),\r\n            ZeroCopySink.WriteVarBytes(args.fromAddress),\r\n            ZeroCopySink.WriteUint255(args.nonce)\r\n        );\r\n        return buff;\r\n    }\r\n\r\n    function _deserializeTransferTxArgs(bytes memory valueBz) private pure returns (TransferTxArgs memory) {\r\n        TransferTxArgs memory args;\r\n        uint256 off = 0;\r\n        (args.fromAssetHash, off) = ZeroCopySource.NextVarBytes(valueBz, off);\r\n        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBz, off);\r\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBz, off);\r\n        (args.amount, off) = ZeroCopySource.NextUint255(valueBz, off);\r\n        return args;\r\n    }\r\n\r\n    function _deserializeRegisterAssetTxArgs(bytes memory valueBz) private pure returns (RegisterAssetTxArgs memory) {\r\n        RegisterAssetTxArgs memory args;\r\n        uint256 off = 0;\r\n        (args.assetHash, off) = ZeroCopySource.NextVarBytes(valueBz, off);\r\n        (args.nativeAssetHash, off) = ZeroCopySource.NextVarBytes(valueBz, off);\r\n        return args;\r\n    }\r\n\r\n    function _deserializeExtensionTxArgs(bytes memory valueBz) private pure returns (ExtensionTxArgs memory) {\r\n        ExtensionTxArgs memory args;\r\n        uint256 off = 0;\r\n        (args.extensionAddress, off) = ZeroCopySource.NextVarBytes(valueBz, off);\r\n        return args;\r\n    }\r\n\r\n    function _getCcm() private view returns (CCM) {\r\n      CCM ccm = CCM(ccmProxy.getEthCrossChainManager());\r\n      return ccm;\r\n    }\r\n\r\n    function _getNextNonce() private returns (uint256) {\r\n      currentNonce = currentNonce.add(1);\r\n      return currentNonce;\r\n    }\r\n\r\n    function _getSalt(\r\n        address _ownerAddress,\r\n        bytes memory _swthAddress\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n            SALT_PREFIX,\r\n            _ownerAddress,\r\n            _swthAddress\r\n        ));\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(ERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(_isContract(address(token)), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `_isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function _isContract(address account) private view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ccmProxyAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_counterpartChainId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAssetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toAssetHash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"txArgs\",\"type\":\"bytes\"}],\"name\":\"LockEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAssetHash\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"txArgs\",\"type\":\"bytes\"}],\"name\":\"UnlockEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH_ASSET_HASH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SALT_PREFIX\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_argsBz\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_fromChainId\",\"type\":\"uint64\"}],\"name\":\"addExtension\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ccmProxy\",\"outputs\":[{\"internalType\":\"contract CCMProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"counterpartChainId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swthAddress\",\"type\":\"bytes\"}],\"name\":\"createWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receivingAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assetHash\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"extensionTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"extensions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swthAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_bytecodeHash\",\"type\":\"bytes32\"}],\"name\":\"getWalletAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetHash\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_targetProxyHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_toAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_toAssetHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_feeAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_walletAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assetHash\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_targetProxyHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_toAssetHash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_feeAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"_rs\",\"type\":\"bytes32[]\"}],\"name\":\"lockFromWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_argsBz\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_fromContractAddr\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_fromChainId\",\"type\":\"uint64\"}],\"name\":\"registerAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_argsBz\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_fromChainId\",\"type\":\"uint64\"}],\"name\":\"removeExtension\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"seenMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_argsBz\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_fromContractAddr\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_fromChainId\",\"type\":\"uint64\"}],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LockProxy","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005a51e2ebf8d136926b9ca7b59b60464e7c44d2eb0000000000000000000000000000000000000000000000000000000000000005","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cf7112f021f9e2524cc4412d735952b2778a93a00ac3ae2b1657c7f004965357"}]}