{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address _who) public view returns (uint256);\n    function transfer(address _to, uint256 _value) public returns (bool);\n    function allowance(address _ocwner, address _spender) public view returns (uint256);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ncontract IERC20 {\n    function balanceOf(\n        address whom\n    )\n    external\n    view\n    returns (uint);\n\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n    public\n    returns (bool);\n\n\n\n    function decimals()\n    external\n    view\n    returns (uint);\n\n\n    function symbol()\n    external\n    view\n    returns (string);\n\n\n    function name()\n    external\n    view\n    returns (string);\n\n\n    function freezeTransfers()\n    external;\n\n\n    function unfreezeTransfers()\n    external;\n}\n\ncontract IKyberReserveInterface {\n\n    // Pricing contract\n    uint public collectedFeesInTwei;\n    // Pricing contract\n    function resetCollectedFees() public;\n    // Pricing contract\n    function setLiquidityParams(\n        uint _rInFp,\n        uint _pMinInFp,\n        uint _numFpBits,\n        uint _maxCapBuyInWei,\n        uint _maxCapSellInWei,\n        uint _feeInBps,\n        uint _maxTokenToEthRateInPrecision,\n        uint _minTokenToEthRateInPrecision\n    ) public;\n\n    function withdraw(ERC20 token, uint amount, address destination) public returns(bool);\n    function disableTrade() public returns (bool);\n    function enableTrade() public returns (bool);\n    function withdrawEther(uint amount, address sendTo) external;\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external;\n    function setContracts(address _kyberNetwork, address _conversionRates, address _sanityRates) public;\n    function getDestQty(ERC20 src, ERC20 dest, uint srcQty, uint rate) public view returns(uint);\n}\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITwoKeyCampaign {\n\n    function getNumberOfUsersToContractor(\n        address _user\n    )\n    public\n    view\n    returns (uint);\n\n    function getReceivedFrom(\n        address _receiver\n    )\n    public\n    view\n    returns (address);\n\n    function balanceOf(\n        address _owner\n    )\n    public\n    view\n    returns (uint256);\n\n    function getReferrerCut(\n        address me\n    )\n    public\n    view\n    returns (uint256);\n\n    function getReferrerPlasmaBalance(\n        address _influencer\n    )\n    public\n    view\n    returns (uint);\n\n    function updateReferrerPlasmaBalance(\n        address _influencer,\n        uint _balance\n    )\n    public;\n\n    function updateModeratorRewards(\n        uint moderatorTokens\n    )\n    public;\n\n    address public logicHandler;\n    address public conversionHandler;\n\n}\n\ncontract ITwoKeyCampaignValidator {\n    function isCampaignValidated(address campaign) public view returns (bool);\n    function validateAcquisitionCampaign(address campaign, string nonSingletonHash) public;\n    function validateDonationCampaign(address campaign, address donationConversionHandler, address donationLogicHandler, string nonSingletonHash) public;\n    function validateCPCCampaign(address campaign, string nonSingletonHash) public;\n}\n\ncontract ITwoKeyDeepFreezeTokenPool {\n    function updateReceivedTokensForSuccessfulConversions(\n        uint amount,\n        address campaignAddress\n    )\n    public;\n}\n\ncontract ITwoKeyEventSource {\n\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n    function isAddressMaintainer(address _maintainer) public view returns (bool);\n    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n    function joined(address _campaign, address _from, address _to) external;\n    function rejected(address _campaign, address _converter) external;\n\n    function convertedAcquisition(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _baseTokens,\n        uint256 _bonusTokens,\n        uint256 _conversionAmount,\n        bool _isFiatConversion,\n        uint _conversionId\n    )\n    external;\n\n    function getTwoKeyDefaultNetworkTaxPercent()\n    public\n    view\n    returns (uint);\n\n    function convertedDonation(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _conversionAmount,\n        uint256 _conversionId\n    )\n    external;\n\n    function executed(\n        address _campaignAddress,\n        address _converterPlasmaAddress,\n        uint _conversionId,\n        uint tokens\n    )\n    external;\n\n    function tokensWithdrawnFromPurchasesHandler(\n        address campaignAddress,\n        uint _conversionID,\n        uint _tokensAmountWithdrawn\n    )\n    external;\n\n    function emitDebtEvent(\n        address _plasmaAddress,\n        uint _amount,\n        bool _isAddition,\n        string _currency\n    )\n    external;\n\n    function emitReceivedTokensToDeepFreezeTokenPool(\n        address _campaignAddress,\n        uint _amountOfTokens\n    )\n    public;\n\n    function emitReceivedTokensAsModerator(\n        address _campaignAddress,\n        uint _amountOfTokens\n    )\n    public;\n\n    function emitDAIReleasedAsIncome(\n        address _campaignContractAddress,\n        uint _amountOfDAI\n    )\n    public;\n\n    function emitEndedBudgetCampaign(\n        address campaignPlasmaAddress,\n        uint contractorLeftover,\n        uint moderatorEarningsDistributed\n    )\n    public;\n\n\n    function emitUserWithdrawnNetworkEarnings(\n        address user,\n        uint amountOfTokens\n    )\n    public;\n\n    function emitRebalancedRewards(\n        uint cycleId,\n        uint difference,\n        string action\n    )\n    public;\n}\n\ncontract ITwoKeyFeeManager {\n    function payDebtWhenConvertingOrWithdrawingProceeds(address _plasmaAddress, uint _debtPaying) public payable;\n    function getDebtForUser(address _userPlasma) public view returns (uint);\n    function payDebtWithDAI(address _plasmaAddress, uint _totalDebt, uint _debtPaid) public;\n    function payDebtWith2Key(address _beneficiaryPublic, address _plasmaAddress, uint _amountOf2keyForRewards) public;\n    function payDebtWith2KeyV2(\n        address _beneficiaryPublic,\n        address _plasmaAddress,\n        uint _amountOf2keyForRewards,\n        address _twoKeyEconomy,\n        address _twoKeyAdmin\n    ) public;\n    function setRegistrationFeeForUser(address _plasmaAddress, uint _registrationFee) public;\n    function addDebtForUser(address _plasmaAddress, uint _debtAmount, string _debtType) public;\n    function withdrawEtherCollected() public returns (uint);\n    function withdraw2KEYCollected() public returns (uint);\n    function withdrawDAICollected(address _dai) public returns (uint);\n}\n\ncontract ITwoKeyMaintainersRegistry {\n    function checkIsAddressMaintainer(address _sender) public view returns (bool);\n    function checkIsAddressCoreDev(address _sender) public view returns (bool);\n\n    function addMaintainers(address [] _maintainers) public;\n    function addCoreDevs(address [] _coreDevs) public;\n    function removeMaintainers(address [] _maintainers) public;\n    function removeCoreDevs(address [] _coreDevs) public;\n}\n\ncontract ITwoKeyReg {\n    function addTwoKeyEventSource(address _twoKeyEventSource) public;\n    function changeTwoKeyEventSource(address _twoKeyEventSource) public;\n    function addWhereContractor(address _userAddress, address _contractAddress) public;\n    function addWhereModerator(address _userAddress, address _contractAddress) public;\n    function addWhereReferrer(address _userAddress, address _contractAddress) public;\n    function addWhereConverter(address _userAddress, address _contractAddress) public;\n    function getContractsWhereUserIsContractor(address _userAddress) public view returns (address[]);\n    function getContractsWhereUserIsModerator(address _userAddress) public view returns (address[]);\n    function getContractsWhereUserIsRefferer(address _userAddress) public view returns (address[]);\n    function getContractsWhereUserIsConverter(address _userAddress) public view returns (address[]);\n    function getTwoKeyEventSourceAddress() public view returns (address);\n    function addName(string _name, address _sender, string _fullName, string _email, bytes signature) public;\n    function addNameByUser(string _name) public;\n    function getName2Owner(string _name) public view returns (address);\n    function getOwner2Name(address _sender) public view returns (string);\n    function getPlasmaToEthereum(address plasma) public view returns (address);\n    function getEthereumToPlasma(address ethereum) public view returns (address);\n    function checkIfTwoKeyMaintainerExists(address _maintainer) public view returns (bool);\n    function getUserData(address _user) external view returns (bytes);\n}\n\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestCampaignApprovedVersion(string campaignType) public view returns (string);\n}\n\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    * @param contractName is the name of the contract we added new version\n    */\n    event VersionAdded(string version, address implementation, string contractName);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ncontract IUpgradableExchange {\n\n    function buyRate2key() public view returns (uint);\n    function sellRate2key() public view returns (uint);\n\n    function buyTokensWithERC20(\n        uint amountOfTokens,\n        address tokenAddress\n    )\n    public\n    returns (uint,uint);\n\n    function buyTokens(\n        address _beneficiary\n    )\n    public\n    payable\n    returns (uint,uint);\n\n    function buyStableCoinWith2key(\n        uint _twoKeyUnits,\n        address _beneficiary\n    )\n    public\n    payable;\n\n    function report2KEYWithdrawnFromNetwork(\n        uint amountOfTokensWithdrawn\n    )\n    public;\n\n    function getEth2DaiAverageExchangeRatePerContract(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint);\n\n    function getContractId(\n        address _contractAddress\n    )\n    public\n    view\n    returns (uint);\n\n    function getEth2KeyAverageRatePerContract(\n        uint _contractID\n    )\n    public\n    view\n    returns (uint);\n\n    function returnLeftoverAfterRebalancing(\n        uint amountOf2key\n    )\n    public;\n\n\n    function getMore2KeyTokensForRebalancing(\n        uint amountOf2KeyRequested\n    )\n    public\n    view\n    returns (uint);\n\n\n    function releaseAllDAIFromContractToReserve()\n    public;\n\n    function setKyberReserveInterfaceContractAddress(\n        address kyberReserveContractAddress\n    )\n    public;\n\n    function setSpreadWei(\n        uint newSpreadWei\n    )\n    public;\n\n    function withdrawDAIAvailableToFill2KEYReserve(\n        uint amountOfDAI\n    )\n    public\n    returns (uint);\n\n    function returnTokensBackToExchangeV1(\n        uint amountOfTokensToReturn\n    )\n    public;\n\n\n    function getMore2KeyTokensForRebalancingV1(\n        uint amountOfTokensRequested\n    )\n    public;\n}\n\ncontract ITwoKeyAdminStorage is IStructuredStorage {\n\n}\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\ncontract ITwoKeySingletonUtils {\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    // Modifier to restrict method calls only to maintainers\n    modifier onlyMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).checkIsAddressMaintainer(msg.sender));\n        _;\n    }\n\n    /**\n     * @notice Function to get any singleton contract proxy address from TwoKeySingletonRegistry contract\n     * @param contractName is the name of the contract we're looking for\n     */\n    function getAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getContractProxyAddress(contractName);\n    }\n\n    function getNonUpgradableContractAddressFromTwoKeySingletonRegistry(\n        string contractName\n    )\n    internal\n    view\n    returns (address)\n    {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n            .getNonUpgradableContractAddress(contractName);\n    }\n}\n\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\n\ncontract TwoKeyAdmin is Upgradeable, ITwoKeySingletonUtils {\n\n\tusing SafeMath for *;\n\n\n\t/**\n\t * Storage keys are stored on the top. Here they are in order to avoid any typos\n\t */\n\tstring constant _twoKeyIntegratorDefaultFeePercent = \"twoKeyIntegratorDefaultFeePercent\";\n\tstring constant _twoKeyNetworkTaxPercent = \"twoKeyNetworkTaxPercent\";\n\tstring constant _twoKeyTokenRate = \"twoKeyTokenRate\";\n\tstring constant _rewardReleaseAfter = \"rewardReleaseAfter\";\n\n    /**\n     * Accounting necessary stuff\n     */\n\n    //Income to ADMIN\n    string constant _rewardsReceivedAsModeratorTotal = \"rewardsReceivedAsModeratorTotal\";\n    string constant _moderatorEarningsPerCampaign = \"moderatorEarningsPerCampaign\";\n    string constant _feesFromFeeManagerCollectedInCurrency = \"feesFromFeeManagerCollectedInCurrency\";\n\tstring constant _feesCollectedFromKyber = \"feesCollectedFromKyber\";\n\tstring constant _daiCollectedFromUpgradableExchange = \"daiCollectedFromUpgradableExchange\";\n\tstring constant _feesCollectedFromDistributionRewards = \"feesCollectedFromDistributionRewards\";\n\n\n\t// Withdrawals from ADMIN\n\tstring constant _amountWithdrawnFromModeratorEarningsPool = \"amountWithdrawnFromModeratorEarningsPool\";\n\tstring constant _amountWithdrawnFromFeeManagerPoolInCurrency = \"amountWithdrawnFromFeeManagerPoolInCurrency\";\n\tstring constant _amountWithdrawnFromKyberFeesPool = \"amountWithdrawnFromKyberFeesPool\";\n\tstring constant _amountWithdrawnFromCollectedDaiFromUpgradableExchange = \"amountWithdrawnFromCollectedDaiFromUpgradableExchange\";\n\tstring constant _amountWithdrawnFromCollectedDistributionRewards = \"amountWithdrawnFromCollectedDistributionRewards\";\n\n\t/**\n     * Keys for the addresses we're accessing\n     */\n\tstring constant _twoKeyCongress = \"TwoKeyCongress\";\n\tstring constant _twoKeyUpgradableExchange = \"TwoKeyUpgradableExchange\";\n\tstring constant _twoKeyRegistry = \"TwoKeyRegistry\";\n\tstring constant _twoKeyEconomy = \"TwoKeyEconomy\";\n\tstring constant _twoKeyCampaignValidator = \"TwoKeyCampaignValidator\";\n\tstring constant _twoKeyEventSource = \"TwoKeyEventSource\";\n\tstring constant _twoKeyFeeManager = \"TwoKeyFeeManager\";\n\tstring constant _twoKeyMaintainersRegistry = \"TwoKeyMaintainersRegistry\";\n\tstring constant _DAI_TOKEN = \"DAI\";\n\n\tbool initialized = false;\n\n\n\tITwoKeyAdminStorage public PROXY_STORAGE_CONTRACT; \t\t\t//Pointer to storage contract\n\n\n\t/**\n\t * @notice \t\t\tModifier which throws if caller is not TwoKeyCongress\n\t */\n\tmodifier onlyTwoKeyCongress {\n\t\trequire(msg.sender == getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyCongress));\n\t    _;\n\t}\n\n\tmodifier onlyTwoKeyBudgetCampaignsPaymentsHandler {\n\t\taddress twoKeyBudgetCampaignsPaymentsHandler = getAddressFromTwoKeySingletonRegistry(\"TwoKeyBudgetCampaignsPaymentsHandler\");\n\t\trequire(msg.sender == twoKeyBudgetCampaignsPaymentsHandler);\n\t\t_;\n\t}\n\n\t/**\n\t * @notice \t\t\tModifier which throws if the campaign contract sending request is not validated\n\t * \t\t\t\t\tby TwoKeyCampaignValidator contract\n\t */\n\tmodifier onlyAllowedContracts {\n\t\taddress twoKeyCampaignValidator = getAddressFromTwoKeySingletonRegistry(_twoKeyCampaignValidator);\n\t\trequire(ITwoKeyCampaignValidator(twoKeyCampaignValidator).isCampaignValidated(msg.sender) == true);\n\t\t_;\n\t}\n\n\n\t/**\n\t * @notice\t\t\tModifier which throws if the contract sending request is not\n\t *\t\t\t\t\tTwoKeyFeeManager contract\n\t */\n\tmodifier onlyTwoKeyFeeManager {\n\t\trequire(msg.sender == getAddressFromTwoKeySingletonRegistry(_twoKeyFeeManager));\n\t\t_;\n\t}\n\n\n    /**\n     * @notice \t\t\tFunction to set initial parameters in the contract including singletones\n     *\n     * @param \t\t\t_twoKeySingletonRegistry is the singletons registry contract address\n     * @param \t\t\t_proxyStorageContract is the address of proxy for storage for this contract\n     *\n     * @dev \t\t\tThis function can be called only once, which will be done immediately after deployment.\n     */\n    function setInitialParams(\n\t\taddress _twoKeySingletonRegistry,\n\t\taddress _proxyStorageContract,\n\t\tuint _twoKeyTokenReleaseDate\n    )\n\tpublic\n\t{\n        require(initialized == false);\n\n\t\tTWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonRegistry;\n\t\tPROXY_STORAGE_CONTRACT = ITwoKeyAdminStorage(_proxyStorageContract);\n\n\t\tsetUint(_twoKeyIntegratorDefaultFeePercent,2);\n\t\tsetUint(_twoKeyNetworkTaxPercent,25);\n\t\tsetUint(_rewardReleaseAfter, _twoKeyTokenReleaseDate);\n\n        initialized = true;\n    }\n\n\n    /**\n     * @notice \t\t\tFunction where only TwoKeyCongress can transfer ether to an address\n     *\n     * @dev \t\t\tWe're recurring to address different from address 0 and value is in WEI\n     *\n     * @param \t\t\tto is representing receiver's address\n     * @param \t\t\tamount of ether to be transferred\n\n     */\n\tfunction transferEtherByAdmins(\n\t\taddress to,\n\t\tuint256 amount\n\t)\n\texternal\n\tonlyTwoKeyCongress\n\t{\n\t\trequire(to != address(0));\n\t\tto.transfer(amount);\n\t}\n\n\n\t/**\n\t * @notice \t\t\tFunction to forward call from congress to the Maintainers Registry and add core devs\n\t *\n\t * @param \t\t\t_coreDevs is the array of core devs to be added to the system\n\t */\n\tfunction addCoreDevsToMaintainerRegistry(\n\t\taddress [] _coreDevs\n\t)\n\texternal\n\tonlyTwoKeyCongress\n\t{\n\t\taddress twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(_twoKeyMaintainersRegistry);\n\t\tITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).addCoreDevs(_coreDevs);\n\t}\n\n\n\t/**\n\t * @notice \t\t\tFunction to forward call from congress to the Maintainers Registry and add maintainers\n\t *\n\t * @param \t\t\t_maintainers is the array of core devs to be added to the system\n\t */\n\tfunction addMaintainersToMaintainersRegistry(\n\t\taddress [] _maintainers\n\t)\n\texternal\n\tonlyTwoKeyCongress\n\t{\n\t\taddress twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(_twoKeyMaintainersRegistry);\n\t\tITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).addMaintainers(_maintainers);\n\t}\n\n\n\t/**\n\t * @notice \t\t\tFunction to forward call from congress to the Maintainers Registry and remove core devs\n\t *\n\t * @param \t\t\t_coreDevs is the array of core devs to be removed from the system\n\t */\n\tfunction removeCoreDevsFromMaintainersRegistry(\n\t\taddress [] _coreDevs\n\t)\n\texternal\n\tonlyTwoKeyCongress\n\t{\n\t\taddress twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(_twoKeyMaintainersRegistry);\n\t\tITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).removeCoreDevs(_coreDevs);\n\t}\n\n\n\t/**\n\t * @notice \t\t\tFunction to forward call from congress to the Maintainers Registry and remove maintainers\n\t *\n\t * @param \t\t\t_maintainers is the array of maintainers to be removed from the system\n\t */\n\tfunction removeMaintainersFromMaintainersRegistry(\n\t\taddress [] _maintainers\n\t)\n\texternal\n\tonlyTwoKeyCongress\n\t{\n\t\taddress twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(_twoKeyMaintainersRegistry);\n\t\tITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).removeMaintainers(_maintainers);\n\t}\n\n\n\n\t/**\n\t * @notice \t\t\tFunction to freeze all transfers for 2KEY token\n\t *\t\t\t\t\tWhich means that no one transfer of ERC20 2KEY can be performed\n\t * @dev \t\t\tRestricted only to TwoKeyCongress contract\n\t */\n\tfunction freezeTransfersInEconomy()\n\texternal\n\tonlyTwoKeyCongress\n\t{\n\t\taddress twoKeyEconomy = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy);\n\t\tIERC20(twoKeyEconomy).freezeTransfers();\n\t}\n\n\n\t/**\n\t * @notice \t\t\tFunction to unfreeze all transfers for 2KEY token\n\t *\n\t * @dev \t\t\tRestricted only to TwoKeyCongress contract\n\t */\n\tfunction unfreezeTransfersInEconomy()\n\texternal\n\tonlyTwoKeyCongress\n\t{\n\t\taddress twoKeyEconomy = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy);\n\t\tIERC20(twoKeyEconomy).unfreezeTransfers();\n\t}\n\n\n\t/**\n\t * @notice \t\t\tFunction to transfer 2key tokens from the admin contract\n\t * @dev \t\t\tonly TwoKeyCongress can call this function\n\t * @param \t\t\t_to is address representing tokens receiver\n\t * @param \t\t\t_amount is the amount of tokens to be transferred\n \t */\n    function transfer2KeyTokens(\n\t\taddress _to,\n\t\tuint256 _amount\n\t)\n\texternal\n\tonlyTwoKeyCongress\n\treturns (bool)\n\t{\n\t\taddress twoKeyEconomy = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy);\n\t\tbool completed = IERC20(twoKeyEconomy).transfer(_to, _amount);\n\t\treturn completed;\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t *                                                                               *\n\t *\t\t\t\tACCOUNTING (BOOKKEEPING) NECESSARY STUFF                         *\n\t *                                                                               *\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\t/**\n\t * @notice\t\t\tFunction to update whenever some funds are arriving to TwoKeyAdmin\n\t *\t\t\t\t\tfrom TwoKeyFeeManager contract\n\t *\n\t * @param\t\t\tcurrency is in which currency contract received asset\n\t * @param\t\t\tamount is the amount which is received\n\t */\n\tfunction addFeesCollectedInCurrency(\n\t\tstring currency,\n\t\tuint amount\n\t)\n\tpublic\n\tpayable\n\tonlyTwoKeyFeeManager\n\t{\n\t\tbytes32 key = keccak256(_feesFromFeeManagerCollectedInCurrency, currency);\n\t\tuint feesCollectedFromFeeManagerInCurrency = PROXY_STORAGE_CONTRACT.getUint(key);\n\t\tPROXY_STORAGE_CONTRACT.setUint(key, feesCollectedFromFeeManagerInCurrency.add(amount));\n\t}\n\n\n\t//\t/**\n\t//\t * @notice\t\t\tFunction to handle and update state every time there's an\n\t//\t *\t\t\t\t\tincome from Kyber network fees\n\t//\t *\n\t//\t * @param\t\t\tamount is the amount contract have received from there\n\t//\t */\n\t//\tfunction addFeesCollectedFromKyber(\n\t//\t\tuint amount\n\t//\t)\n\t//\tinternal\n\t//\t{\n\t//\t\tbytes32 key = keccak256(_feesCollectedFromKyber);\n\t//\t\tuint feesCollectedFromKyber = PROXY_STORAGE_CONTRACT.getUint(key);\n\t//\t\tPROXY_STORAGE_CONTRACT.setUint(key, feesCollectedFromKyber.add(amount));\n\t//\t}\n\n\t//\t/**\n\t//\t * @notice\t\t\tFunction to withdraw fees collected on Kyber contract to Admin contract\n\t//\t *\n\t//\t * @param\t\t\treserveContract\tis the address of kyber reserve contract for 2KEY token\n\t//\t * @param\t\t\tpricingContract is the address of kyber pricing contract for 2KEY token\n\t//\t */\n\t//\tfunction withdrawFeesFromKyber(\n\t//\t\taddress reserveContract,\n\t//\t\taddress pricingContract\n\t//\t)\n\t//\texternal\n\t//\tonlyTwoKeyCongress\n\t//\t{\n\t//\t\tdisableTradeInKyberInternal(reserveContract);\n\t//\t\tuint availableFees = getKyberAvailableFeesOnReserve(pricingContract);\n\t//\t\twithdrawTokensFromKyberReserveInternal(\n\t//\t\t\treserveContract,\n\t//\t\t\tERC20(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy)),\n\t//\t\t\tavailableFees,\n\t//\t\t\taddress(this)\n\t//\t\t);\n\t//\t\tresetFeesCounterOnKyberContract(pricingContract);\n\t//\t\tenableTradeInKyberInternal(reserveContract);\n\t//\t\taddFeesCollectedFromKyber(availableFees);\n\t//\t}\n\n\n\t/**\n\t * @notice \t\t\tFunction to withdraw DAI we have on TwoKeyUpgradableExchange contract\n\t *\n\t * @param\t\t\t_amountOfTokens is the amount of the tokens we're willing to withdraw\n\t *\n\t * @dev \t\t\tRestricted only to TwoKeyCongress contract\n\t */\n\tfunction withdrawDAIAvailableToFillReserveFromUpgradableExchange(\n\t\tuint _amountOfTokens\n\t)\n\texternal\n\tonlyTwoKeyCongress\n\t{\n\t\taddress twoKeyUpgradableExchange = getAddressFromTwoKeySingletonRegistry(_twoKeyUpgradableExchange);\n\t\tuint collectedDAI = IUpgradableExchange(twoKeyUpgradableExchange).withdrawDAIAvailableToFill2KEYReserve(_amountOfTokens);\n\n\t\tbytes32 key = keccak256(_daiCollectedFromUpgradableExchange);\n\t\tuint _amountWithdrawnCurrently = PROXY_STORAGE_CONTRACT.getUint(key);\n\t\tPROXY_STORAGE_CONTRACT.setUint(key, _amountWithdrawnCurrently.add(collectedDAI));\n\t}\n\n\t/**\n\t * @notice\t\t\tFunction to withdraw moderator earnings from TwoKeyAdmin contract\n\t * \t\t\t\t\tIf 0 is passed as amountToBeWithdrawn, everything available will\n\t *\t\t\t\t\tbe withdrawn\n\t *\n\t * @param\t\t\tbeneficiary is the address which is receiving tokens\n\t * @param\t\t\tamountToBeWithdrawn is the amount of tokens which will be withdrawn\n\t */\n\tfunction withdrawModeratorEarningsFromAdmin(\n\t\taddress beneficiary,\n\t\tuint amountToBeWithdrawn\n\t)\n\tpublic\n\tonlyTwoKeyCongress\n\t{\n\t\tuint moderatorEarningsReceived = getAmountOfTokensReceivedAsModerator();\n\t\tuint moderatorEarningsWithdrawn = getAmountOfTokensWithdrawnFromModeratorEarnings();\n\n\t\tif(amountToBeWithdrawn == 0) {\n\t\t\tamountToBeWithdrawn = moderatorEarningsReceived.sub(moderatorEarningsWithdrawn);\n\t\t} else {\n\t\t\trequire(amountToBeWithdrawn <= moderatorEarningsReceived.sub(moderatorEarningsWithdrawn));\n\t\t}\n\n\t\ttransferTokens(_twoKeyEconomy, beneficiary, amountToBeWithdrawn);\n\n\t\tbytes32 keyHash = keccak256(_amountWithdrawnFromModeratorEarningsPool);\n\t\tPROXY_STORAGE_CONTRACT.setUint(keyHash, moderatorEarningsWithdrawn.add(amountToBeWithdrawn));\n\t}\n\n//\tfunction burnModeratorEarnings()\n\t//TODO: Add function to BURN moderator earnings from Admin (send to 0x0)\n\t//TODO: For all WITHDRAW funnels if amountToBeWithdrawn = 0 then withdraw/burn everything which is there\n\tfunction withdrawFeeManagerEarningsFromAdmin(\n\t\taddress beneficiary,\n\t\tstring currency,\n\t\tuint amountToBeWithdrawn\n\t)\n\tpublic\n\tonlyTwoKeyCongress\n\t{\n\n\t\tuint feeManagerEarningsInCurrency = getAmountCollectedFromFeeManagerInCurrency(currency);\n\t\tuint feeManagerEarningsWithdrawn = getAmountWithdrawnFromFeeManagerEarningsInCurrency(currency);\n\n\t\tif(amountToBeWithdrawn == 0) {\n\t\t\tamountToBeWithdrawn = feeManagerEarningsInCurrency.sub(feeManagerEarningsWithdrawn);\n\t\t} else {\n\t\t\trequire(feeManagerEarningsInCurrency.sub(feeManagerEarningsWithdrawn) >= amountToBeWithdrawn);\n\t\t}\n\n\t\tif(keccak256(currency) == keccak256(\"ETH\")) {\n\t\t\tbeneficiary.transfer(amountToBeWithdrawn);\n\t\t} else {\n\t\t\ttransferTokens(currency, beneficiary, amountToBeWithdrawn);\n\t\t}\n\t\tPROXY_STORAGE_CONTRACT.setUint(keccak256(_amountWithdrawnFromFeeManagerPoolInCurrency,currency), feeManagerEarningsWithdrawn.add(amountToBeWithdrawn));\n\t}\n\n\t/**\n\t * @notice\t\t\tFunction to withdraw earnings collected from Kyber fees from Admin contract\n\t *\n\t * @param\t\t\tbeneficiary is the address which is receiving tokens\n\t * @param\t\t\tamountToBeWithdrawn is the amount of tokens to be withdrawn\n\t */\n\tfunction withdrawKyberFeesEarningsFromAdmin(\n\t\taddress beneficiary,\n\t\tuint amountToBeWithdrawn\n\t)\n\tpublic\n\tonlyTwoKeyCongress\n\t{\n\t\tuint kyberTotalReceived = getAmountCollectedFromKyber();\n\t\tuint kyberTotalWithdrawn = getAmountWithdrawnFromKyberEarnings();\n\n\t\tif(amountToBeWithdrawn == 0) {\n\t\t\tamountToBeWithdrawn = kyberTotalReceived.sub(kyberTotalWithdrawn);\n\t\t} else {\n\t\t\trequire(amountToBeWithdrawn <= kyberTotalReceived.sub(kyberTotalWithdrawn));\n\t\t}\n\n\t\ttransferTokens(_twoKeyEconomy, beneficiary, amountToBeWithdrawn);\n\n\t\tPROXY_STORAGE_CONTRACT.setUint(\n\t\t\tkeccak256(_amountWithdrawnFromKyberFeesPool),\n\t\t\tkyberTotalWithdrawn.add(amountToBeWithdrawn)\n\t\t);\n\t}\n\n\t/**\n\t * @notice \t\t\tFunction to withdraw DAI collected from UpgradableExchange from Admin\n\t *\n\t * @param\t\t\tbeneficiary is the address which is receiving tokens\n\t * @param\t\t\tamountToBeWithdrawn is the amount of tokens to be withdrawns\n\t */\n\tfunction withdrawUpgradableExchangeDaiCollectedFromAdmin(\n\t\taddress beneficiary,\n\t\tuint amountToBeWithdrawn\n\t)\n\tpublic\n\tonlyTwoKeyCongress\n\t{\n\t\tuint totalDAICollectedFromPool = getAmountCollectedInDAIFromUpgradableExchange();\n\t\tuint totalDAIWithdrawnFromPool = getAmountWithdrawnFromCollectedDAIUpgradableExchangeEarnings();\n\n\t\tif (amountToBeWithdrawn == 0) {\n\t\t\tamountToBeWithdrawn = totalDAICollectedFromPool.sub(totalDAIWithdrawnFromPool);\n\t\t} else {\n\t\t\trequire(totalDAIWithdrawnFromPool.add(amountToBeWithdrawn) <= totalDAICollectedFromPool);\n\t\t}\n\n\t\ttransferTokens(_DAI_TOKEN, beneficiary, amountToBeWithdrawn);\n\n\t\tPROXY_STORAGE_CONTRACT.setUint(keccak256(_amountWithdrawnFromCollectedDaiFromUpgradableExchange), totalDAIWithdrawnFromPool.add(amountToBeWithdrawn));\n\t}\n\n\tfunction withdrawFeesCollectedFromDistributionRewards(\n\t\taddress beneficiary,\n\t\tuint amountToWithdraw\n\t)\n\tpublic\n\tonlyTwoKeyCongress\n\t{\n\t\tuint totalFeesCollected = getAmountOfTokensReceivedFromDistributionFees();\n\t\tuint totalFeesWithdrawn = getAmountOfTokensWithdrawnFromDistributionFees();\n\n\t\tif (amountToWithdraw == 0) {\n\t\t\tamountToWithdraw = totalFeesCollected.sub(totalFeesWithdrawn);\n\t\t} else {\n\t\t\trequire(totalFeesWithdrawn.add(amountToWithdraw) <= totalFeesCollected);\n\t\t}\n\n\t\ttransferTokens(_twoKeyEconomy, beneficiary, amountToWithdraw);\n\t\tPROXY_STORAGE_CONTRACT.setUint(keccak256(_amountWithdrawnFromCollectedDistributionRewards), totalFeesWithdrawn.add(amountToWithdraw));\n\t}\n\n\t/**\n\t * @notice\t\t\tFunction for PPC campaigns to update received tokens\n\t */\n\tfunction updateReceivedTokensAsModeratorPPC(\n\t\tuint amountOfTokens,\n\t\taddress campaignPlasma\n\t)\n\tpublic\n\tonlyTwoKeyBudgetCampaignsPaymentsHandler\n\t{\n\t\tupdateTokensReceivedAsModeratorInternal(amountOfTokens, campaignPlasma);\n\t}\n\n\t/**\n\t * @notice\t\t\tFunction to update tokens received from distribution fees\n\t * @param\t\t\tamountOfTokens is the amount of tokens to be sent to admin\n\t */\n\tfunction updateTokensReceivedFromDistributionFees(\n\t\tuint amountOfTokens\n\t)\n\tpublic\n\tonlyTwoKeyBudgetCampaignsPaymentsHandler\n\t{\n\t\tuint amountCollected = getAmountOfTokensReceivedFromDistributionFees();\n\n        PROXY_STORAGE_CONTRACT.setUint(\n            keccak256(_feesCollectedFromDistributionRewards),\n            amountCollected.add(amountOfTokens)\n        );\n    }\n\n\n    /**\n     * @notice \t\t\tFunction which will be used take the tokens from the campaign and distribute\n     * \t\t\t\t\tthem between itself and TwoKeyDeepFreezeTokenPool\n     *\n     * @param\t\t\tamountOfTokens is the amount of the tokens which are for moderator rewards\n      */\n    function updateReceivedTokensAsModerator(\n        uint amountOfTokens\n    )\n\tpublic\n\tonlyAllowedContracts\n\t{\n\t\tuint moderatorTokens = updateTokensReceivedAsModeratorInternal(amountOfTokens, msg.sender);\n\t\t//Update moderator earnings to campaign\n\t\tITwoKeyCampaign(msg.sender).updateModeratorRewards(moderatorTokens);\n\t}\n\n\tfunction updateTokensReceivedAsModeratorInternal(\n\t\tuint amountOfTokens,\n\t\taddress campaignAddress\n\t)\n\tinternal\n\treturns (uint)\n\t{\n\t\t// Network fee which will be taken from moderator\n\t\tuint networkFee = getDefaultNetworkTaxPercent();\n\n\t\tuint moderatorTokens = amountOfTokens.mul(100 - networkFee).div(100);\n\n\t\tbytes32 keyHashTotalRewards = keccak256(_rewardsReceivedAsModeratorTotal);\n\t\tPROXY_STORAGE_CONTRACT.setUint(keyHashTotalRewards, moderatorTokens.add((PROXY_STORAGE_CONTRACT.getUint(keyHashTotalRewards))));\n\n\t\t//Emit event through TwoKeyEventSource for the campaign\n\t\tITwoKeyEventSource(getAddressFromTwoKeySingletonRegistry(_twoKeyEventSource)).emitReceivedTokensAsModerator(campaignAddress, moderatorTokens);\n\n\t\t//Now update twoKeyDeepFreezeTokenPool\n\t\taddress twoKeyEconomy = getNonUpgradableContractAddressFromTwoKeySingletonRegistry(_twoKeyEconomy);\n\t\taddress deepFreezeTokenPool = getAddressFromTwoKeySingletonRegistry(\"TwoKeyDeepFreezeTokenPool\");\n\n\t\tuint tokensForDeepFreezeTokenPool = amountOfTokens.sub(moderatorTokens);\n\n\t\t//Transfer tokens to deep freeze token pool\n\t\ttransferTokens(_twoKeyEconomy, deepFreezeTokenPool, tokensForDeepFreezeTokenPool);\n\n\t\t//Update contract on receiving tokens\n\t\tITwoKeyDeepFreezeTokenPool(deepFreezeTokenPool).updateReceivedTokensForSuccessfulConversions(tokensForDeepFreezeTokenPool, campaignAddress);\n\n\t\t// Compute the hash for the storage for moderator earnings per campaign\n\t\tbytes32 keyHashEarningsPerCampaign = keccak256(_moderatorEarningsPerCampaign, campaignAddress);\n\t\t// Take the current earnings\n\t\tuint currentEarningsForThisCampaign = PROXY_STORAGE_CONTRACT.getUint(keyHashEarningsPerCampaign);\n\t\t// Increase them by earnings added now and store\n\t\tPROXY_STORAGE_CONTRACT.setUint(keyHashEarningsPerCampaign, currentEarningsForThisCampaign.add(moderatorTokens));\n\n\t\treturn moderatorTokens;\n\t}\n\n\n\t//    /**\n\t//     * @notice          Function to call setLiquidityParams on LiquidityConversionRates.sol\n\t//     *                  contract, it can be called only by TwoKeyAdmin.sol contract\n\t//     *\n\t//     * @param           liquidityConversionRatesContractAddress is the address of liquidity conversion rates contract\n\t//                        the right address depending on environment can be found in configurationFiles/kyberAddresses.json\n\t//                        It's named \"pricing\" in the json object\n\t//     */\n\t//\tfunction setLiquidityParametersInKyber(\n\t//        address liquidityConversionRatesContractAddress,\n\t//        uint _rInFp,\n\t//        uint _pMinInFp,\n\t//        uint _numFpBits,\n\t//        uint _maxCapBuyInWei,\n\t//        uint _maxCapSellInWei,\n\t//        uint _feeInBps,\n\t//        uint _maxTokenToEthRateInPrecision,\n\t//        uint _minTokenToEthRateInPrecision\n\t//\t)\n\t//\tpublic\n\t//\tonlyTwoKeyCongress\n\t//\t{\n\t//        // Call on the contract set liquidity params\n\t//        IKyberReserveInterface(liquidityConversionRatesContractAddress).setLiquidityParams(\n\t//            _rInFp,\n\t//            _pMinInFp,\n\t//            _numFpBits,\n\t//            _maxCapBuyInWei,\n\t//            _maxCapSellInWei,\n\t//            _feeInBps,\n\t//            _maxTokenToEthRateInPrecision,\n\t//            _minTokenToEthRateInPrecision\n\t//        );\n\t//\t}\n\t//\n\t//\n\t//\t/**\n\t//\t * @notice\t\t\tContract to disable trade through Kyber\n\t//\t *\n\t//\t * @param\t\t\treserveContract is the address of reserve contract\n\t//\t */\n\t//\tfunction disableTradeInKyber(\n\t//\t\taddress reserveContract\n\t//\t)\n\t//\texternal\n\t//\tonlyTwoKeyCongress\n\t//\t{\n\t//\t\tdisableTradeInKyberInternal(reserveContract);\n\t//\t}\n\t//\n\t//\tfunction disableTradeInKyberInternal(\n\t//\t\taddress reserveContract\n\t//\t)\n\t//\tinternal\n\t//\t{\n\t//\t\tIKyberReserveInterface(reserveContract).disableTrade();\n\t//\t}\n\t//\n\t//\n\t//\t/**\n\t//\t * @notice\t\t\tContract to enable trade through Kyber\n\t//\t *\n\t//\t * @param\t\t\treserveContract is the address of reserve contract\n\t//\t */\n\t//\tfunction enableTradeInKyber(\n\t//\t\taddress reserveContract\n\t//\t)\n\t//\texternal\n\t//\tonlyTwoKeyCongress\n\t//\t{\n\t//\t\tenableTradeInKyberInternal(reserveContract);\n\t//\t}\n\t//\n\t//\tfunction enableTradeInKyberInternal(\n\t//\t\taddress reserveContract\n\t//\t)\n\t//\tinternal\n\t//\t{\n\t//\t\tIKyberReserveInterface(reserveContract).enableTrade();\n\t//\t}\n\t//\n\t//\tfunction getKyberAvailableFeesOnReserve(\n\t//\t\taddress pricingContract\n\t//\t)\n\t//\tinternal\n\t//\tview\n\t//\treturns (uint)\n\t//\t{\n\t//\t\treturn IKyberReserveInterface(pricingContract).collectedFeesInTwei();\n\t//\t}\n\t//\n\t//\n\t//\tfunction resetFeesCounterOnKyberContract(\n\t//\t\taddress pricingContract\n\t//\t)\n\t//\tinternal\n\t//\t{\n\t//\t\tIKyberReserveInterface(pricingContract).resetCollectedFees();\n\t//\t}\n\t//\n\t//\n\t//    /**\n\t//     * @notice          Function to call withdraw on KyberReserve.sol contract\n\t//     *                  It can be only called by TwoKeyAdmin.sol contract\n\t//     *\n\t//     * @param           kyberReserveContractAddress is the address of kyber reserve contract\n\t//     *                  right address depending on environment can be found in configurationFiles/kyberAddresses.json\n\t//                        It's named \"reserve\" in the json object.\n\t//     */\n\t//    function withdrawTokensFromKyberReserve(\n\t//        address kyberReserveContractAddress,\n\t//        ERC20 tokenToWithdraw,\n\t//        uint amountToBeWithdrawn,\n\t//        address receiverAddress\n\t//    )\n\t//    external\n\t//    onlyTwoKeyCongress\n\t//    {\n\t//\t\twithdrawTokensFromKyberReserveInternal(\n\t//\t\t\tkyberReserveContractAddress,\n\t//\t\t\ttokenToWithdraw,\n\t//\t\t\tamountToBeWithdrawn,\n\t//\t\t\treceiverAddress\n\t//\t\t);\n\t//    }\n\n\t//\t/**\n\t//\t * @notice\t\t\tFunction to set contracts on Kyber, mostly used to swap from their\n\t//\t *\t\t\t\t\tstaging and production environments\n\t//\t *\n\t//\t * @param\t\t\tkyberReserveContractAddress is our reserve contract address\n\t//\t * @param\t\t\tkyberNetworkAddress is the address of kyber network\n\t//\t * @param\t\t\tconversionRatesContractAddress is the address of conversion rates contract\n\t//\t * @param\t\t\tsanityRatesContractAddress is the address of sanity rates contract\n\t//\t */\n\t//\tfunction setContractsKyber(\n\t//\t\taddress kyberReserveContractAddress,\n\t//\t\taddress kyberNetworkAddress,\n\t//\t\taddress conversionRatesContractAddress,\n\t//\t\taddress sanityRatesContractAddress\n\t//\t)\n\t//\texternal\n\t//\tonlyTwoKeyCongress\n\t//\t{\n\t//\t\tIKyberReserveInterface(kyberReserveContractAddress).setContracts(\n\t//\t\t\tkyberNetworkAddress,\n\t//\t\t\tconversionRatesContractAddress,\n\t//\t\t\tsanityRatesContractAddress\n\t//\t\t);\n\t//\t}\n\n\t//\n\t//\tfunction withdrawTokensFromKyberReserveInternal(\n\t//\t\taddress kyberReserveContractAddress,\n\t//\t\tERC20 tokenToWithdraw,\n\t//\t\tuint amountToBeWithdrawn,\n\t//\t\taddress receiverAddress\n\t//\t)\n\t//\tinternal\n\t//\t{\n\t//\t\tIKyberReserveInterface(kyberReserveContractAddress).withdrawToken(\n\t//\t\t\ttokenToWithdraw,\n\t//\t\t\tamountToBeWithdrawn,\n\t//\t\t\treceiverAddress\n\t//\t\t);\n\t//\t}\n\n\n\t/**\n\t * @notice \t\t\tFunction to get uint from the storage\n\t *\n\t * @param \t\t\tkey is the name of the key in the storages\n\t */\n\tfunction getUint(\n\t\tstring key\n\t)\n\tinternal\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(key));\n\t}\n\n\n\t/**\n\t * @notice \t\t\tSetter for all integers we'd like to store\n\t *\n\t * @param \t\t\tkey is the key (var name)\n\t * @param \t\t\tvalue is the value of integer we'd like to store\n\t */\n\tfunction setUint(\n\t\tstring key,\n\t\tuint value\n\t)\n\tinternal\n\t{\n\t\tPROXY_STORAGE_CONTRACT.setUint(keccak256(key), value);\n\t}\n\n\n\t/**\n\t * @notice \t\t\tGetter for moderator earnings per campaign\n\t *\n\t * @param \t\t\t_campaignAddress is the address of the campaign we're searching for moderator earnings\n \t */\n\tfunction getModeratorEarningsPerCampaign(\n\t\taddress _campaignAddress\n\t)\n\tpublic\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_moderatorEarningsPerCampaign, _campaignAddress));\n\t}\n\n\n\t/**\n\t * @notice \t\t\tFunction to return the release date when 2KEY token can be withdrawn from the\n\t * \t\t\t\t\tnetwork\n\t */\n\tfunction getTwoKeyRewardsReleaseDate()\n\texternal\n\tview\n\treturns(uint)\n\t{\n\t\treturn getUint(_rewardReleaseAfter);\n\t}\n\n\n\t/**\n\t * @notice\t\t\tGetter for default moderator percent he takes\n \t */\n\tfunction getDefaultIntegratorFeePercent()\n\tpublic\n\tview\n\treturns (uint)\n\t{\n\t\treturn getUint(_twoKeyIntegratorDefaultFeePercent);\n\t}\n\n\n\n\t/**\n\t * @notice \t\t\tGetter for network tax percent which is taken from moderator\n\t */\n\tfunction getDefaultNetworkTaxPercent()\n\tpublic\n\tview\n\treturns (uint)\n\t{\n\t\treturn getUint(_twoKeyNetworkTaxPercent);\n\t}\n\n\n\n\t/**\n\t * @notice\t\t\tSetter in case TwoKeyCongress decides to change integrator fee percent\n\t */\n\tfunction setDefaultIntegratorFeePercent(\n\t\tuint newFeePercent\n\t)\n\texternal\n\tonlyTwoKeyCongress\n\t{\n\t\tPROXY_STORAGE_CONTRACT.setUint(keccak256(_twoKeyIntegratorDefaultFeePercent),newFeePercent);\n\t}\n\n\n\t/**\n\t * @notice \t\t\tGetter to check how many total tokens TwoKeyAdmin received as a moderator from\n\t *\t\t\t\t\tvarious campaign contracts running on 2key.network\n\t */\n    function getAmountOfTokensReceivedAsModerator()\n    public\n    view\n    returns (uint)\n    {\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_rewardsReceivedAsModeratorTotal));\n\t}\n\n\tfunction getAmountOfTokensReceivedFromDistributionFees()\n\tpublic\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_feesCollectedFromDistributionRewards));\n\t}\n\n\tfunction getAmountOfTokensWithdrawnFromDistributionFees()\n\tpublic\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_amountWithdrawnFromCollectedDistributionRewards));\n\t}\n\n\tfunction getAmountCollectedFromFeeManagerInCurrency(\n\t\tstring currency\n\t)\n\tinternal\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_feesFromFeeManagerCollectedInCurrency, currency));\n\t}\n\n\tfunction getAmountCollectedFromKyber()\n\tinternal\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_feesCollectedFromKyber));\n\t}\n\n\n\tfunction getAmountCollectedInDAIFromUpgradableExchange()\n\tinternal\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_daiCollectedFromUpgradableExchange));\n\t}\n\n\n\tfunction getAmountOfTokensWithdrawnFromModeratorEarnings()\n\tinternal\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_amountWithdrawnFromModeratorEarningsPool));\n\t}\n\n\tfunction getAmountWithdrawnFromFeeManagerEarningsInCurrency(\n\t\tstring currency\n\t)\n\tinternal\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_amountWithdrawnFromFeeManagerPoolInCurrency,currency));\n\t}\n\n\tfunction getAmountWithdrawnFromKyberEarnings()\n\tinternal\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_amountWithdrawnFromKyberFeesPool));\n\t}\n\n\tfunction getAmountWithdrawnFromCollectedDAIUpgradableExchangeEarnings()\n\tinternal\n\tview\n\treturns (uint)\n\t{\n\t\treturn PROXY_STORAGE_CONTRACT.getUint(keccak256(_amountWithdrawnFromCollectedDaiFromUpgradableExchange));\n\t}\n\n\tfunction transferTokens(\n\t\tstring token,\n\t\taddress beneficiary,\n\t\tuint amount\n\t)\n\tinternal\n\t{\n\t\tIERC20(getNonUpgradableContractAddressFromTwoKeySingletonRegistry(token)).transfer(\n\t\t\tbeneficiary,\n\t\t\tamount\n\t\t);\n\t}\n\n\tfunction getAccountingReport()\n\tpublic\n\tview\n\treturns (bytes)\n\t{\n\t\treturn (\n\t\t\tabi.encodePacked(\n\t\t\t\tgetAmountOfTokensReceivedAsModerator(),\n\t\t\t\tgetAmountCollectedFromFeeManagerInCurrency(\"DAI\"),\n\t\t\t\tgetAmountCollectedFromFeeManagerInCurrency(\"ETH\"),\n\t\t\t\tgetAmountCollectedFromFeeManagerInCurrency(\"2KEY\"),\n\t\t\t\tgetAmountCollectedFromKyber(),\n\t\t\t\tgetAmountCollectedInDAIFromUpgradableExchange(),\n\t\t\t\tgetAmountOfTokensReceivedFromDistributionFees(),\n\t\t\t\tgetAmountOfTokensWithdrawnFromModeratorEarnings(),\n\t\t\t\tgetAmountWithdrawnFromKyberEarnings(),\n\t\t\t\tgetAmountWithdrawnFromCollectedDAIUpgradableExchangeEarnings(),\n\t\t\t\tgetAmountWithdrawnFromFeeManagerEarningsInCurrency(\"DAI\"),\n\t\t\t\tgetAmountWithdrawnFromFeeManagerEarningsInCurrency(\"ETH\"),\n\t\t\t\tgetAmountWithdrawnFromFeeManagerEarningsInCurrency(\"2KEY\"),\n\t\t\t\tgetAmountOfTokensWithdrawnFromDistributionFees()\n\t\t\t)\n\t\t);\n\t}\n\n\n\t/**\n\t * @notice Free ether is always accepted :)\n \t */\n\tfunction()\n\texternal\n\tpayable\n\t{\n\n\t}\n\n}\n\n","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"freezeTransfersInEconomy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfTokens\",\"type\":\"uint256\"},{\"name\":\"campaignPlasma\",\"type\":\"address\"}],\"name\":\"updateReceivedTokensAsModeratorPPC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROXY_STORAGE_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coreDevs\",\"type\":\"address[]\"}],\"name\":\"removeCoreDevsFromMaintainersRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coreDevs\",\"type\":\"address[]\"}],\"name\":\"addCoreDevsToMaintainerRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreezeTransfersInEconomy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultIntegratorFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAmountOfTokensWithdrawnFromDistributionFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAmountOfTokensReceivedAsModerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maintainers\",\"type\":\"address[]\"}],\"name\":\"addMaintainersToMaintainersRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultNetworkTaxPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"updateReceivedTokensAsModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_twoKeySingletonRegistry\",\"type\":\"address\"},{\"name\":\"_proxyStorageContract\",\"type\":\"address\"},{\"name\":\"_twoKeyTokenReleaseDate\",\"type\":\"uint256\"}],\"name\":\"setInitialParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_campaignAddress\",\"type\":\"address\"}],\"name\":\"getModeratorEarningsPerCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"updateTokensReceivedFromDistributionFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amountToBeWithdrawn\",\"type\":\"uint256\"}],\"name\":\"withdrawKyberFeesEarningsFromAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"currency\",\"type\":\"string\"},{\"name\":\"amountToBeWithdrawn\",\"type\":\"uint256\"}],\"name\":\"withdrawFeeManagerEarningsFromAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_KEY_SINGLETON_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAmountOfTokensReceivedFromDistributionFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amountToBeWithdrawn\",\"type\":\"uint256\"}],\"name\":\"withdrawModeratorEarningsFromAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currency\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addFeesCollectedInCurrency\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer2KeyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferEtherByAdmins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccountingReport\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maintainers\",\"type\":\"address[]\"}],\"name\":\"removeMaintainersFromMaintainersRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amountToBeWithdrawn\",\"type\":\"uint256\"}],\"name\":\"withdrawUpgradableExchangeDaiCollectedFromAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTwoKeyRewardsReleaseDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdrawFeesCollectedFromDistributionRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawDAIAvailableToFillReserveFromUpgradableExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFeePercent\",\"type\":\"uint256\"}],\"name\":\"setDefaultIntegratorFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"TwoKeyAdmin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}