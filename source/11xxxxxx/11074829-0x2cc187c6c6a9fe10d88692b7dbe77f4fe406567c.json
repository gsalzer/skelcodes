{"status":"1","message":"OK","result":[{"SourceCode":"{\"Dex.sol\":{\"content\":\"pragma solidity ^0.4.18;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n// ----------------------------------------------------------------------------------------------\\r\\n// Sample fixed supply token contract\\r\\n// Enjoy. (c) BokkyPooBah 2017. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------------------------\\r\\n\\r\\nimport \\u0027./FixedSupplyToken.sol\\u0027;\\r\\n\\r\\ncontract TokenSale {\\r\\n    \\r\\n    uint256 fee = 0.01 ether;\\r\\n    \\r\\n    uint256 symbolNameIndex;\\r\\n    \\r\\n    uint256 historyIndex;\\r\\n    \\r\\n    \\r\\n    //it will divide on 1000\\r\\n    uint256 siteShareRatio = 1;\\r\\n    \\r\\n    address manager;\\r\\n    \\r\\n    enum State {Waiting , Selling , Ended , Checkedout}\\r\\n\\r\\n    mapping (uint256 =\\u003e uint) tokenBalanceForAddress;\\r\\n\\r\\n    mapping (address =\\u003e uint256) refAccount;\\r\\n\\r\\n    mapping (address =\\u003e mapping(uint256 =\\u003e uint)) balanceEthForAddress;\\r\\n    \\r\\n    mapping (uint256 =\\u003e Token) tokens;\\r\\n\\r\\n    struct Token {\\r\\n        address tokenContract;\\r\\n        address owner;\\r\\n        string symbolName;\\r\\n        string symbol;\\r\\n        string link;\\r\\n        uint256 amount;\\r\\n        uint256 leftover;\\r\\n        uint256 priceInWie;\\r\\n        uint256 deadline;\\r\\n        uint decimals;\\r\\n        State state;\\r\\n        uint256 referral;\\r\\n    }\\r\\n    \\r\\n    mapping (uint256 =\\u003e History) histories;\\r\\n    \\r\\n    struct History{\\r\\n        address owner;\\r\\n        string title;\\r\\n        uint256 amount;\\r\\n        uint256 decimals;\\r\\n        uint256 time;\\r\\n        string symbol;\\r\\n    }\\r\\n    \\r\\n    event TokenAdded(address erc20TokenAddress);\\r\\n    event TokenDeposited(address erc20TokenAddress , uint256 amount);\\r\\n    event DexCheckouted(address erc20TokenAddress , uint256 amount);\\r\\n    event RefCheckouted(address ownerAddress , uint256 amount);\\r\\n    event TokenBuyed(address erc20TokenAddress , uint256 amount , address buyer);\\r\\n\\r\\n\\r\\n    function TokenSale() public{\\r\\n        manager = msg.sender;\\r\\n    }\\r\\n\\r\\n    ///////////////////////\\r\\n    // TOKEN MANAGEMENT //\\r\\n    //////////////////////\\r\\n\\r\\n    function addToken(address erc20TokenAddress , string symbolName , string symbol , string link , uint256 priceInWie , uint decimals , uint256 referral) public payable {\\r\\n        require(!hasToken(erc20TokenAddress) , \\u0027Token Is Already Added\\u0027);\\r\\n        require(msg.value == fee , \\u0027Add Token Fee Is Invalid\\u0027);\\r\\n        require(referral \\u003e= 0 \\u0026\\u0026 referral \\u003c= 100);\\r\\n        \\r\\n        manager.transfer(msg.value);\\r\\n        \\r\\n        symbolNameIndex++;\\r\\n        tokens[symbolNameIndex].symbolName = symbolName;\\r\\n        tokens[symbolNameIndex].tokenContract = erc20TokenAddress;\\r\\n        tokens[symbolNameIndex].symbol = symbol;\\r\\n        tokens[symbolNameIndex].link = link;\\r\\n        tokens[symbolNameIndex].amount = 0;\\r\\n        tokens[symbolNameIndex].deadline = now;\\r\\n        tokens[symbolNameIndex].leftover = 0;\\r\\n        tokens[symbolNameIndex].state = State.Waiting;\\r\\n        tokens[symbolNameIndex].priceInWie = priceInWie;\\r\\n        tokens[symbolNameIndex].decimals = decimals;\\r\\n        tokens[symbolNameIndex].referral = referral;\\r\\n        tokens[symbolNameIndex].owner = msg.sender;\\r\\n        \\r\\n        setHistory(msg.sender , fee , \\u0027Fee For Add Token\\u0027 , \\u0027ETH\\u0027 , 18);\\r\\n        setHistory(manager , fee , \\u0027(Manager) Fee For Add Token\\u0027 , \\u0027ETH\\u0027 , 18);\\r\\n        \\r\\n        TokenAdded(erc20TokenAddress);\\r\\n\\r\\n    }\\r\\n\\r\\n    function hasToken(address erc20TokenAddress) public constant returns (bool) {\\r\\n        uint256 index = getSymbolIndexByAddress(erc20TokenAddress);\\r\\n        if (index == 0) {\\r\\n            return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getSymbolIndexByAddress(address erc20TokenAddress) internal returns (uint256) {\\r\\n        for (uint256 i = 1; i \\u003c= symbolNameIndex; i++) {\\r\\n            if (tokens[i].tokenContract == erc20TokenAddress) {\\r\\n                return i;\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    function getSymbolIndexByAddressOrThrow(address erc20TokenAddress) returns (uint256) {\\r\\n        uint256 index = getSymbolIndexByAddress(erc20TokenAddress);\\r\\n        require(index \\u003e 0);\\r\\n        return index;\\r\\n    }\\r\\n    \\r\\n    function getAllDex() public view returns(address[] memory , string[] memory , uint256[] memory , uint[] memory , uint256[] memory , string[] memory){\\r\\n        \\r\\n        address[] memory tokenAdderss = new address[](symbolNameIndex+1);\\r\\n        string[] memory tokenName = new string[](symbolNameIndex+1);\\r\\n        string[] memory tokenLink = new string[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenPrice = new uint256[](symbolNameIndex+1);\\r\\n        uint[] memory decimal = new uint256[](symbolNameIndex+1);\\r\\n        uint256[] memory leftover = new uint256[](symbolNameIndex+1);\\r\\n\\r\\n\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c= symbolNameIndex; i++) {\\r\\n            if(checkDeadLine(tokens[i]) \\u0026\\u0026 tokens[i].leftover != 0){\\r\\n                tokenAdderss[i] = tokens[i].tokenContract;\\r\\n                tokenName[i] = tokens[i].symbol;\\r\\n                tokenLink[i] = tokens[i].link;\\r\\n                tokenPrice[i] = tokens[i].priceInWie;\\r\\n                decimal[i] = tokens[i].decimals;\\r\\n                leftover[i] = tokens[i].leftover;\\r\\n            }\\r\\n        }\\r\\n        return (tokenAdderss , tokenName , tokenPrice , decimal , leftover , tokenLink);\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////\\r\\n    // DEPOSIT / WITHDRAWAL TOKEN //\\r\\n    ////////////////////////////////\\r\\n    \\r\\n    function depositToken(address erc20TokenAddress, uint256 amountTokens , uint256 deadline) public payable {\\r\\n        uint256 symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        require(tokens[symbolNameIndex].tokenContract != address(0) , \\u0027Token is Invalid\\u0027);\\r\\n        require(tokens[symbolNameIndex].state == State.Waiting , \\u0027Token Cannot be deposited\\u0027);\\r\\n        require(tokens[symbolNameIndex].owner == msg.sender , \\u0027You are not owner of this coin\\u0027);\\r\\n\\r\\n        ERC20Interface token = ERC20Interface(tokens[symbolNameIndex].tokenContract);\\r\\n        \\r\\n        require(token.transferFrom(msg.sender, address(this), amountTokens) == true);\\r\\n        \\r\\n        tokens[symbolNameIndex].amount = amountTokens;\\r\\n        tokens[symbolNameIndex].leftover = amountTokens;\\r\\n        \\r\\n        require(tokenBalanceForAddress[symbolNameIndex] + amountTokens \\u003e= tokenBalanceForAddress[symbolNameIndex]);\\r\\n        tokenBalanceForAddress[symbolNameIndex] += amountTokens;\\r\\n        tokens[symbolNameIndex].state = State.Selling;\\r\\n        tokens[symbolNameIndex].deadline = deadline;\\r\\n        \\r\\n        Token tokenRes = tokens[symbolNameIndex];\\r\\n        \\r\\n        setHistory(msg.sender , amountTokens , \\u0027Deposit Token\\u0027 , tokenRes.symbol , tokenRes.decimals);\\r\\n        \\r\\n        TokenDeposited(erc20TokenAddress , amountTokens);\\r\\n        \\r\\n    }\\r\\n\\r\\n    function checkoutDex(address erc20TokenAddress) public payable {\\r\\n        \\r\\n        uint256 symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        \\r\\n        ERC20Interface token = ERC20Interface(tokens[symbolNameIndex].tokenContract);\\r\\n\\r\\n        uint256 _amountTokens = tokens[symbolNameIndex].leftover;\\r\\n        \\r\\n        require(tokens[symbolNameIndex].tokenContract != address(0), \\u0027Token is Invalid\\u0027);\\r\\n        require(tokens[symbolNameIndex].owner == msg.sender , \\u0027You are not owner of this coin\\u0027);\\r\\n        require(!checkDeadLine(tokens[symbolNameIndex]) || tokens[symbolNameIndex].leftover == 0 , \\u0027Token Cannot be withdrawn\\u0027);\\r\\n\\r\\n\\r\\n        require(tokenBalanceForAddress[symbolNameIndex] - _amountTokens \\u003e= 0 , \\\"overflow error\\\");\\r\\n        require(tokenBalanceForAddress[symbolNameIndex] - _amountTokens \\u003c= tokenBalanceForAddress[symbolNameIndex] , \\\"Insufficient amount of token\\\");\\r\\n        \\r\\n        tokenBalanceForAddress[symbolNameIndex] -= _amountTokens;\\r\\n        tokens[symbolNameIndex].leftover = 0;\\r\\n        tokens[symbolNameIndex].state = State.Checkedout;\\r\\n        \\r\\n        if(_amountTokens \\u003e 0){\\r\\n            require(token.transfer(msg.sender, _amountTokens) == true , \\\"transfer failed\\\"); \\r\\n            setHistory(msg.sender , _amountTokens , \\u0027Check Out Token\\u0027 , tokens[symbolNameIndex].symbol , tokens[symbolNameIndex].decimals);\\r\\n        }\\r\\n\\r\\n        uint256 _siteShare = balanceEthForAddress[msg.sender][symbolNameIndex] * siteShareRatio / 1000;\\r\\n        uint256 _ownerShare = balanceEthForAddress[msg.sender][symbolNameIndex] - _siteShare;\\r\\n        \\r\\n        setHistory(msg.sender , _ownerShare , \\u0027Check Out ETH\\u0027 , \\u0027ETH\\u0027 , 18 );\\r\\n        setHistory(manager , _siteShare , \\u0027(Manager) Site Share For Deposite Token\\u0027 , \\u0027ETH\\u0027 , 18);\\r\\n\\r\\n        \\r\\n        msg.sender.transfer(_ownerShare);\\r\\n        \\r\\n        DexCheckouted(erc20TokenAddress , _ownerShare);\\r\\n\\r\\n    }\\r\\n\\r\\n    function getBalance(address erc20TokenAddress) public constant returns (uint256) {\\r\\n        uint256 symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        return tokenBalanceForAddress[symbolNameIndex];\\r\\n    }\\r\\n    \\r\\n    function checkoutRef(uint256 amount) public payable {\\r\\n        \\r\\n        amount = amount;\\r\\n        \\r\\n        require(refAccount[msg.sender] \\u003e= amount , \\u0027Insufficient amount of ETH\\u0027);\\r\\n\\r\\n        refAccount[msg.sender] -= amount;\\r\\n        \\r\\n        setHistory(msg.sender , amount , \\u0027Check Out Referral\\u0027 , \\u0027ETH\\u0027 , 18 );\\r\\n\\r\\n        msg.sender.transfer(amount);\\r\\n        \\r\\n        RefCheckouted(msg.sender , amount);\\r\\n    }\\r\\n    \\r\\n    function getRefBalance(address _ownerAddress) view returns(uint256){\\r\\n        return refAccount[_ownerAddress];\\r\\n    }\\r\\n\\r\\n    \\r\\n    ///////////////\\r\\n    // Buy Token //\\r\\n    ///////////////\\r\\n    \\r\\n    function buyToken(address erc20TokenAddress , address refAddress , uint256 _amount) payable returns(bool){\\r\\n        \\r\\n        uint256 symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        Token token = tokens[symbolNameIndex];\\r\\n\\r\\n        require(token.state == State.Selling , \\u0027You Can not Buy This Token\\u0027);\\r\\n        require((_amount * token.priceInWie) / (10 ** token.decimals)  == msg.value , \\\"Incorrect Eth Amount\\\");\\r\\n        require(checkDeadLine(token) , \\u0027Deadline Passed\\u0027);\\r\\n        require(token.leftover \\u003e= _amount , \\u0027Insufficient Token Amount\\u0027);\\r\\n        \\r\\n        if(erc20TokenAddress != refAddress){\\r\\n            uint256 ref = msg.value * token.referral / 100;\\r\\n            balanceEthForAddress[token.owner][symbolNameIndex] += msg.value - ref;\\r\\n            refAccount[refAddress] += ref;\\r\\n        }else{\\r\\n            balanceEthForAddress[token.owner][symbolNameIndex] += msg.value;\\r\\n        }    \\r\\n        \\r\\n        ERC20Interface ERC20token = ERC20Interface(tokens[symbolNameIndex].tokenContract);\\r\\n        \\r\\n        \\r\\n        ERC20token.approve(address(this) , _amount);\\r\\n\\r\\n        require(ERC20token.transferFrom(address(this) , msg.sender , _amount) == true , \\u0027Insufficient Token Amount\\u0027);\\r\\n        \\r\\n        setHistory(msg.sender , _amount , \\u0027Buy Token\\u0027 , token.symbol , token.decimals);\\r\\n\\r\\n        \\r\\n        token.leftover -= _amount;\\r\\n        tokenBalanceForAddress[symbolNameIndex] -= _amount;\\r\\n        \\r\\n        if(token.leftover == 0){\\r\\n            token.state = State.Ended;\\r\\n        }\\r\\n        \\r\\n        TokenBuyed(erc20TokenAddress , _amount , msg.sender);\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function leftover(address erc20TokenAddress , uint256 _amount) public view returns(uint256){\\r\\n        uint256 symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        return tokens[symbolNameIndex].leftover;\\r\\n    }\\r\\n    \\r\\n    function checkDeadLine(Token token) internal returns(bool){\\r\\n        return (now \\u003c token.deadline); \\r\\n    }\\r\\n    \\r\\n    function getOwnerTokens(address owner) public view returns(address[] memory , string[] memory , uint256[] memory , uint256[] memory , uint256[] memory , uint256[] memory , uint[] memory ){\\r\\n        \\r\\n        address[] memory tokenAdderss = new address[](symbolNameIndex+1);\\r\\n        string[] memory tokenName = new string[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenAmount = new uint256[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenLeftover = new uint256[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenPrice = new uint256[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenDeadline = new uint256[](symbolNameIndex+1);\\r\\n        uint[] memory status = new uint[](symbolNameIndex+1);\\r\\n\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c= symbolNameIndex; i++) {\\r\\n            if (tokens[i].owner == owner) {\\r\\n                tokenAdderss[i] = tokens[i].tokenContract;\\r\\n                tokenName[i] = tokens[i].symbol;\\r\\n                tokenAmount[i] = tokens[i].amount;\\r\\n                tokenLeftover[i] = tokens[i].leftover;\\r\\n                tokenPrice[i] = tokens[i].priceInWie;\\r\\n                tokenDeadline[i] = tokens[i].deadline;\\r\\n\\r\\n                if(tokens[i].state == State.Waiting)\\r\\n                    status[i] = 1;\\r\\n                else{    \\r\\n                    if(tokens[i].state == State.Selling)\\r\\n                        status[i] = 2;\\r\\n                    if(!checkDeadLine(tokens[i]) || tokens[i].leftover == 0)\\r\\n                        status[i] = 3;\\r\\n                    if(tokens[i].state == State.Checkedout)\\r\\n                        status[i] = 4;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return (tokenAdderss , tokenName , tokenLeftover , tokenAmount , tokenPrice , tokenDeadline , status);\\r\\n    }\\r\\n    \\r\\n    function getDecimal(address erc20TokenAddress) public view returns(uint256){\\r\\n        uint256 symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        return tokens[symbolNameIndex].decimals;\\r\\n    }\\r\\n    \\r\\n    function getOwnerTokenDetails(address erc20TokenAddress) public view returns(Token){\\r\\n        uint256 symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        Token token = tokens[symbolNameIndex];\\r\\n        require(token.owner == msg.sender);\\r\\n        \\r\\n        return token;\\r\\n    }\\r\\n    \\r\\n    function setHistory(address _owner , uint256 _amount , string _name , string _symbol , uint256 _decimals) public {\\r\\n        histories[historyIndex].amount = _amount;\\r\\n        histories[historyIndex].title = _name;\\r\\n        histories[historyIndex].owner = _owner;\\r\\n        histories[historyIndex].symbol = _symbol;\\r\\n        histories[historyIndex].time = now;\\r\\n        histories[historyIndex].decimals = _decimals;\\r\\n        \\r\\n        historyIndex++;\\r\\n    }\\r\\n    \\r\\n    function getHistory(address _owner) public view returns(string[] , string[] , uint256[] , uint256[] , uint256[]){\\r\\n        \\r\\n        string[] memory title = new string[](historyIndex+1);\\r\\n        string[] memory symbol = new string[](historyIndex+1);\\r\\n        uint256[] memory time = new uint256[](historyIndex+1);\\r\\n        uint256[] memory amount = new uint256[](historyIndex+1);\\r\\n        uint256[] memory decimals = new uint256[](historyIndex+1);\\r\\n\\r\\n\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c= historyIndex; i++) {\\r\\n            if (histories[i].owner == _owner) {\\r\\n                title[i] = histories[i].title;\\r\\n                symbol[i] = histories[i].symbol;\\r\\n                time[i] = histories[i].time;\\r\\n                amount[i] = histories[i].amount;\\r\\n                decimals[i] = histories[i].decimals;\\r\\n            }\\r\\n        }\\r\\n        return (title , symbol , time , amount , decimals);\\r\\n    }\\r\\n}\"},\"FixedSupplyToken.sol\":{\"content\":\"pragma solidity ^0.4.18;\\r\\n\\r\\n// ----------------------------------------------------------------------------------------------\\r\\n// Sample fixed supply token contract\\r\\n// Enjoy. (c) BokkyPooBah 2017. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------------------------\\r\\n\\r\\n// ERC Token Standard #20 Interface\\r\\n// https://github.com/ethereum/EIPs/issues/20\\r\\ncontract ERC20Interface {\\r\\n    // Get the total token supply\\r\\n    function totalSupply() public constant returns (uint256);\\r\\n\\r\\n    // Get the account balance of another account with address _owner\\r\\n    function balanceOf(address _owner) public constant returns (uint256 balance);\\r\\n\\r\\n    // Send _value amount of tokens to address _to\\r\\n    function transfer(address _to, uint256 _value) public returns (bool success);\\r\\n\\r\\n    // Send _value amount of tokens from address _from to address _to\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\r\\n\\r\\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\\r\\n    // If this function is called again it overwrites the current allowance with _value.\\r\\n    // this function is required for some DEX functionality\\r\\n    function approve(address _spender, uint256 _value) public returns (bool success);\\r\\n\\r\\n    // Returns the amount which _spender is still allowed to withdraw from _owner\\r\\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\\r\\n\\r\\n    // Triggered when tokens are transferred.\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n\\r\\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\\r\\n\\r\\ncontract FixedSupplyToken is ERC20Interface {\\r\\n    string public constant symbol = \\\"FIXED\\\";\\r\\n    string public constant name = \\\"Example Fixed Supply Token\\\";\\r\\n    uint8 public constant decimals = 0;\\r\\n    uint256 _totalSupply = 1000000;\\r\\n\\r\\n    // Owner of this contract\\r\\n    address public owner;\\r\\n\\r\\n    // Balances for each account\\r\\n    mapping (address =\\u003e uint256) balances;\\r\\n\\r\\n    // Owner of account approves the transfer of an amount to another account\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\r\\n\\r\\n    // Functions with this modifier can only be executed by the owner\\r\\n    modifier onlyOwner() {\\r\\n        if (msg.sender != owner) {\\r\\n            revert();\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Constructor\\r\\n    function FixedSupplyToken() public {\\r\\n        owner = msg.sender;\\r\\n        balances[owner] = _totalSupply;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public constant returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    // What is the balance of a particular account?\\r\\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\\r\\n        return balances[_owner];\\r\\n    }\\r\\n\\r\\n    // Transfer the balance from owner\\u0027s account to another account\\r\\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\\r\\n        if (balances[msg.sender] \\u003e= _amount\\r\\n        \\u0026\\u0026 _amount \\u003e 0\\r\\n        \\u0026\\u0026 balances[_to] + _amount \\u003e balances[_to]) {\\r\\n            balances[msg.sender] -= _amount;\\r\\n            balances[_to] += _amount;\\r\\n            Transfer(msg.sender, _to, _amount);\\r\\n            return true;\\r\\n        }\\r\\n        else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Send _value amount of tokens from address _from to address _to\\r\\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\\r\\n    // tokens on your behalf, for example to \\\"deposit\\\" to a contract address and/or to charge\\r\\n    // fees in sub-currencies; the command should fail unless the _from account has\\r\\n    // deliberately authorized the sender of the message via some mechanism; we propose\\r\\n    // these standardized APIs for approval:\\r\\n    function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _amount\\r\\n    ) public returns (bool success) {\\r\\n        if (balances[_from] \\u003e= _amount\\r\\n        \\u0026\\u0026 allowed[_from][msg.sender] \\u003e= _amount\\r\\n        \\u0026\\u0026 _amount \\u003e 0\\r\\n        \\u0026\\u0026 balances[_to] + _amount \\u003e balances[_to]) {\\r\\n            balances[_from] -= _amount;\\r\\n            allowed[_from][msg.sender] -= _amount;\\r\\n            balances[_to] += _amount;\\r\\n            Transfer(_from, _to, _amount);\\r\\n            return true;\\r\\n        }\\r\\n        else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\\r\\n    // If this function is called again it overwrites the current allowance with _value.\\r\\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\\r\\n        allowed[msg.sender][_spender] = _amount;\\r\\n        Approval(msg.sender, _spender, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\\r\\n        return allowed[_owner][_spender];\\r\\n    }\\r\\n\\r\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"getOwnerTokenDetails\",\"outputs\":[{\"components\":[{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"symbolName\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"link\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"leftover\",\"type\":\"uint256\"},{\"name\":\"priceInWie\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"referral\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"checkoutRef\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"checkoutDex\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"symbolName\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"link\",\"type\":\"string\"},{\"name\":\"priceInWie\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint256\"},{\"name\":\"referral\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"string[]\"},{\"name\":\"\",\"type\":\"string[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"getDecimal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"hasToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"leftover\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"refAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"getRefBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllDex\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"string[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"string[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getOwnerTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"string[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"getSymbolIndexByAddressOrThrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"setHistory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DexCheckouted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ownerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefCheckouted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"TokenBuyed\",\"type\":\"event\"}]","ContractName":"TokenSale","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://83923e05ba54ddf94e2d7dd633cc6c71bbd7dcab7d0ee3635fd5a6901bf89a52"}]}