{"status":"1","message":"OK","result":[{"SourceCode":"{\"checkPrice.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\n//import \\\"/github/CryptoManiacsZone/1inchProtocol/contracts/IOneSplit.sol\\\";\\n//import \\\"/github/OpenZeppelin/openzeppelin-contracts/contracts/ownership/Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n//import \\\"./IChi.sol\\\";\\nimport \\\"IUniswapV2Pair.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\n//import \\\"/github/ampleforth/uFragments/contracts/lib/SafeMathInt.sol\\\";\\nimport \\\"IOneSplit.sol\\\";\\n\\ncontract CheckPrice{\\n    // is Ownable\\n    //IOneSplit public oneSplit;\\n    address[] public uniPools = [0x3041CbD36888bECc7bbCBc0045E3B1f144466f5f, 0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852];\\n    mapping (address=\\u003eaddress) public uniGeysers;\\n    //address public chi = 0x0000000000004946c0e9F43F4Dee607b0eF1fA1c;\\n    address public denominateTo = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\\n    address public holderAddress = 0x8c545be506a335e24145EdD6e01D2754296ff018;\\n    address public OneSplitAddress = 0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E;\\n    \\n    uint fpNumbers = 1e8;\\n    \\n    using SafeMath for uint256;\\n    \\n    \\n    constructor() public {\\n      \\n        uniGeysers[0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852] = 0x6C3e4cb2E96B01F4b866965A91ed4437839A121a;\\n\\n    }\\n    \\n    function setOneSplit (address inch_address) external returns (bool){\\n        \\n        OneSplitAddress = inch_address;\\n        return true;\\n\\n    }\\n    \\n    \\n    /*\\n    modifier discountCHI() {\\n        \\n    uint256 gasStart = gasleft();\\n    address gasUser;\\n    \\n    _;\\n    \\n    if (IERC20(chi).balanceOf(msg.sender) \\u003e 0) {\\n       if (IERC20(chi).allowance(msg.sender,address(this))!= uint256(-1)) {\\n            IERC20(chi).approve(address(this), uint(-1));\\n        }\\n        gasUser = msg.sender;\\n    } else {\\n        gasUser = address(this);\\n    }\\n    \\n    uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\\n    \\n    ICHI(chi).freeFromUpTo(gasUser, (gasSpent + 14154) / 41947);\\n    \\n    }\\n    \\n    function transferTokenToOwner(address TokenAddress) external onlyOwner returns (uint256){\\n        IERC20 Token = IERC20(TokenAddress);\\n        uint256 balance = Token.balanceOf(address(this));\\n        bool result = Token.transfer(owner(), balance);\\n        \\n        if (!result) { \\n            balance = 0;\\n        }\\n        \\n        return balance;\\n    }\\n    \\n    \\n    \\n    \\n    //onlyOwner\\n    \\n    /*\\n        \\n    function addUniPool (address pool_address) external returns (bool){\\n        uniPools.push(pool_address);\\n        return true;\\n    }\\n    \\n    \\n    function delUniPool (address pool_address) external returns (bool) {\\n\\n        uint i = 0;\\n        while (uniPools[i] != pool_address) {\\n            require(i \\u003c uniPools.length);\\n            i++;\\n        }\\n        \\n        while (i\\u003cuniPools.length-1) {\\n            uniPools[i] = uniPools[i+1];\\n            i++;\\n        }\\n        uniPools.length--;\\n        return true;\\n    }\\n    */\\n     \\n    function getUniPools() public view returns (address[] memory) {\\n        return uniPools;\\n    }\\n    \\n    function getTotalPrice() public view returns (uint) {\\n        \\n        uint totalReserve = 0;\\n        \\n        for (uint i=0; i\\u003cuniPools.length; i++) {\\n            \\n            IUniswapV2Pair uniPool = IUniswapV2Pair(uniPools[i]);\\n            \\n            uint totalSupply = uniPool.totalSupply();\\n            uint holderBalanceOf = uniPool.balanceOf(holderAddress);\\n            \\n            if (uniGeysers[uniPools[i]] != address(0)) {\\n                uint geyserBalance = IERC20(uniGeysers[uniPools[i]]).balanceOf(holderAddress);\\n                holderBalanceOf += geyserBalance;\\n            }\\n            \\n            uint holderPc = (holderBalanceOf.mul(fpNumbers)).div(totalSupply);\\n            \\n            (uint112 reserve0, uint112 reserve1,) = uniPool.getReserves();\\n            \\n            uint myreserve0 = (uint(reserve0).mul(holderPc)).div(fpNumbers);\\n            uint myreserve1 = (uint(reserve1).mul(holderPc)).div(fpNumbers);\\n            \\n            if (uniPool.token0() != denominateTo) {\\n                //get amount and convert to denominate addr;\\n\\n                IERC20 fromIERC20 = IERC20(uniPool.token0());\\n                IERC20 toIERC20 = IERC20(denominateTo);\\n\\n                (uint256 returnAmount0,) = IOneSplit(\\n                    OneSplitAddress\\n                ).getExpectedReturn(\\n                    fromIERC20,\\n                    toIERC20,\\n                    myreserve0,\\n                    100,\\n                    0\\n                );\\n                \\n                myreserve0 = returnAmount0;\\n            }\\n            totalReserve = totalReserve.add(myreserve0);\\n            \\n            if (uniPool.token1() != denominateTo) {\\n                //get amount and convert to denominate addr;\\n                IERC20 fromIERC20 = IERC20(uniPool.token1());\\n                IERC20 toIERC20 = IERC20(denominateTo);\\n\\n                (uint256 returnAmount1,) = IOneSplit(\\n                    OneSplitAddress\\n                ).getExpectedReturn(\\n                    fromIERC20,\\n                    toIERC20,\\n                    myreserve1,\\n                    100,\\n                    0\\n                );\\n                \\n                myreserve1 = returnAmount1;\\n            }\\n            \\n            totalReserve = totalReserve.add(myreserve1);\\n        }\\n        \\n        return totalReserve;\\n    }\\n   \\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IOneSplit.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\n//\\n//  [ msg.sender ]\\n//       | |\\n//       | |\\n//       \\\\_/\\n// +---------------+ ________________________________\\n// | OneSplitAudit | _______________________________  \\\\\\n// +---------------+                                 \\\\ \\\\\\n//       | |                      ______________      | | (staticcall)\\n//       | |                    /  ____________  \\\\    | |\\n//       | | (call)            / /              \\\\ \\\\   | |\\n//       | |                  / /               | |   | |\\n//       \\\\_/                  | |               \\\\_/   \\\\_/\\n// +--------------+           | |           +----------------------+\\n// | OneSplitWrap |           | |           |   OneSplitViewWrap   |\\n// +--------------+           | |           +----------------------+\\n//       | |                  | |                     | |\\n//       | | (delegatecall)   | | (staticcall)        | | (staticcall)\\n//       \\\\_/                  | |                     \\\\_/\\n// +--------------+           | |             +------------------+\\n// |   OneSplit   |           | |             |   OneSplitView   |\\n// +--------------+           | |             +------------------+\\n//       | |                  / /\\n//        \\\\ \\\\________________/ /\\n//         \\\\__________________/\\n//\\n\\n\\ncontract IOneSplitConsts {\\n    // flags = FLAG_DISABLE_UNISWAP + FLAG_DISABLE_BANCOR + ...\\n    uint256 internal constant FLAG_DISABLE_UNISWAP = 0x01;\\n    uint256 internal constant DEPRECATED_FLAG_DISABLE_KYBER = 0x02; // Deprecated\\n    uint256 internal constant FLAG_DISABLE_BANCOR = 0x04;\\n    uint256 internal constant FLAG_DISABLE_OASIS = 0x08;\\n    uint256 internal constant FLAG_DISABLE_COMPOUND = 0x10;\\n    uint256 internal constant FLAG_DISABLE_FULCRUM = 0x20;\\n    uint256 internal constant FLAG_DISABLE_CHAI = 0x40;\\n    uint256 internal constant FLAG_DISABLE_AAVE = 0x80;\\n    uint256 internal constant FLAG_DISABLE_SMART_TOKEN = 0x100;\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_ETH = 0x200; // Deprecated, Turned off by default\\n    uint256 internal constant FLAG_DISABLE_BDAI = 0x400;\\n    uint256 internal constant FLAG_DISABLE_IEARN = 0x800;\\n    uint256 internal constant FLAG_DISABLE_CURVE_COMPOUND = 0x1000;\\n    uint256 internal constant FLAG_DISABLE_CURVE_USDT = 0x2000;\\n    uint256 internal constant FLAG_DISABLE_CURVE_Y = 0x4000;\\n    uint256 internal constant FLAG_DISABLE_CURVE_BINANCE = 0x8000;\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_DAI = 0x10000; // Deprecated, Turned off by default\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_USDC = 0x20000; // Deprecated, Turned off by default\\n    uint256 internal constant FLAG_DISABLE_CURVE_SYNTHETIX = 0x40000;\\n    uint256 internal constant FLAG_DISABLE_WETH = 0x80000;\\n    uint256 internal constant FLAG_DISABLE_UNISWAP_COMPOUND = 0x100000; // Works only when one of assets is ETH or FLAG_ENABLE_MULTI_PATH_ETH\\n    uint256 internal constant FLAG_DISABLE_UNISWAP_CHAI = 0x200000; // Works only when ETH\\u003c\\u003eDAI or FLAG_ENABLE_MULTI_PATH_ETH\\n    uint256 internal constant FLAG_DISABLE_UNISWAP_AAVE = 0x400000; // Works only when one of assets is ETH or FLAG_ENABLE_MULTI_PATH_ETH\\n    uint256 internal constant FLAG_DISABLE_IDLE = 0x800000;\\n    uint256 internal constant FLAG_DISABLE_MOONISWAP = 0x1000000;\\n    uint256 internal constant FLAG_DISABLE_UNISWAP_V2 = 0x2000000;\\n    uint256 internal constant FLAG_DISABLE_UNISWAP_V2_ETH = 0x4000000;\\n    uint256 internal constant FLAG_DISABLE_UNISWAP_V2_DAI = 0x8000000;\\n    uint256 internal constant FLAG_DISABLE_UNISWAP_V2_USDC = 0x10000000;\\n    uint256 internal constant FLAG_DISABLE_ALL_SPLIT_SOURCES = 0x20000000;\\n    uint256 internal constant FLAG_DISABLE_ALL_WRAP_SOURCES = 0x40000000;\\n    uint256 internal constant FLAG_DISABLE_CURVE_PAX = 0x80000000;\\n    uint256 internal constant FLAG_DISABLE_CURVE_RENBTC = 0x100000000;\\n    uint256 internal constant FLAG_DISABLE_CURVE_TBTC = 0x200000000;\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_USDT = 0x400000000; // Deprecated, Turned off by default\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_WBTC = 0x800000000; // Deprecated, Turned off by default\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_TBTC = 0x1000000000; // Deprecated, Turned off by default\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_RENBTC = 0x2000000000; // Deprecated, Turned off by default\\n    uint256 internal constant FLAG_DISABLE_DFORCE_SWAP = 0x4000000000;\\n    uint256 internal constant FLAG_DISABLE_SHELL = 0x8000000000;\\n    uint256 internal constant FLAG_ENABLE_CHI_BURN = 0x10000000000;\\n    uint256 internal constant FLAG_DISABLE_MSTABLE_MUSD = 0x20000000000;\\n    uint256 internal constant FLAG_DISABLE_CURVE_SBTC = 0x40000000000;\\n    uint256 internal constant FLAG_DISABLE_DMM = 0x80000000000;\\n    uint256 internal constant FLAG_DISABLE_UNISWAP_ALL = 0x100000000000;\\n    uint256 internal constant FLAG_DISABLE_CURVE_ALL = 0x200000000000;\\n    uint256 internal constant FLAG_DISABLE_UNISWAP_V2_ALL = 0x400000000000;\\n    uint256 internal constant FLAG_DISABLE_SPLIT_RECALCULATION = 0x800000000000;\\n    uint256 internal constant FLAG_DISABLE_BALANCER_ALL = 0x1000000000000;\\n    uint256 internal constant FLAG_DISABLE_BALANCER_1 = 0x2000000000000;\\n    uint256 internal constant FLAG_DISABLE_BALANCER_2 = 0x4000000000000;\\n    uint256 internal constant FLAG_DISABLE_BALANCER_3 = 0x8000000000000;\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_KYBER_UNISWAP_RESERVE = 0x10000000000000; // Deprecated, Turned off by default\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_KYBER_OASIS_RESERVE = 0x20000000000000; // Deprecated, Turned off by default\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_KYBER_BANCOR_RESERVE = 0x40000000000000; // Deprecated, Turned off by default\\n    uint256 internal constant FLAG_ENABLE_REFERRAL_GAS_SPONSORSHIP = 0x80000000000000; // Turned off by default\\n    uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_COMP = 0x100000000000000; // Deprecated, Turned off by default\\n    uint256 internal constant FLAG_DISABLE_KYBER_ALL = 0x200000000000000;\\n    uint256 internal constant FLAG_DISABLE_KYBER_1 = 0x400000000000000;\\n    uint256 internal constant FLAG_DISABLE_KYBER_2 = 0x800000000000000;\\n    uint256 internal constant FLAG_DISABLE_KYBER_3 = 0x1000000000000000;\\n    uint256 internal constant FLAG_DISABLE_KYBER_4 = 0x2000000000000000;\\n    uint256 internal constant FLAG_ENABLE_CHI_BURN_BY_ORIGIN = 0x4000000000000000;\\n    uint256 internal constant FLAG_DISABLE_MOONISWAP_ALL = 0x8000000000000000;\\n    uint256 internal constant FLAG_DISABLE_MOONISWAP_ETH = 0x10000000000000000;\\n    uint256 internal constant FLAG_DISABLE_MOONISWAP_DAI = 0x20000000000000000;\\n    uint256 internal constant FLAG_DISABLE_MOONISWAP_USDC = 0x40000000000000000;\\n    uint256 internal constant FLAG_DISABLE_MOONISWAP_POOL_TOKEN = 0x80000000000000000;\\n}\\n\\n\\ncontract IOneSplit is IOneSplitConsts {\\n    function getExpectedReturn(\\n        IERC20 fromToken,\\n        IERC20 destToken,\\n        //address fromToken,\\n        //address destToken,\\n        uint256 amount,\\n        uint256 parts,\\n        uint256 flags // See constants in IOneSplit.sol\\n    )\\n        public\\n        view\\n        returns(\\n            uint256 returnAmount,\\n            uint256[] memory distribution\\n        );\\n\\n    function getExpectedReturnWithGas(\\n        IERC20 fromToken,\\n        IERC20 destToken,\\n        uint256 amount,\\n        uint256 parts,\\n        uint256 flags, // See constants in IOneSplit.sol\\n        uint256 destTokenEthPriceTimesGasPrice\\n    )\\n        public\\n        view\\n        returns(\\n            uint256 returnAmount,\\n            uint256 estimateGasAmount,\\n            uint256[] memory distribution\\n        );\\n\\n    function swap(\\n        IERC20 fromToken,\\n        IERC20 destToken,\\n        uint256 amount,\\n        uint256 minReturn,\\n        uint256[] memory distribution,\\n        uint256 flags\\n    )\\n        public\\n        payable\\n        returns(uint256 returnAmount);\\n}\\n\\n\\ncontract IOneSplitMulti is IOneSplit {\\n    function getExpectedReturnWithGasMulti(\\n        IERC20[] memory tokens,\\n        uint256 amount,\\n        uint256[] memory parts,\\n        uint256[] memory flags,\\n        uint256[] memory destTokenEthPriceTimesGasPrices\\n    )\\n        public\\n        view\\n        returns(\\n            uint256[] memory returnAmounts,\\n            uint256 estimateGasAmount,\\n            uint256[] memory distribution\\n        );\\n\\n    function swapMulti(\\n        IERC20[] memory tokens,\\n        uint256 amount,\\n        uint256 minReturn,\\n        uint256[] memory distribution,\\n        uint256[] memory flags\\n    )\\n        public\\n        payable\\n        returns(uint256 returnAmount);\\n}\\n\"},\"IUniswapV2Pair.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    \\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    \\n    \\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address); \\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    \\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uniPools\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"denominateTo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OneSplitAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"uniGeysers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniPools\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inch_address\",\"type\":\"address\"}],\"name\":\"setOneSplit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holderAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"CheckPrice","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6e626b39e665e13a4ba221b21d18347a0ebd1666e46dee68a7740109d9b5d84a"}]}