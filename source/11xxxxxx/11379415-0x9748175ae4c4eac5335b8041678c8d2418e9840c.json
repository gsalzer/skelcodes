{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/debt/mozart/MozartV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {ISyntheticToken} from \\\"../../token/ISyntheticToken.sol\\\";\\nimport {IMintableToken} from \\\"../../token/IMintableToken.sol\\\";\\nimport {IERC20} from \\\"../../token/IERC20.sol\\\";\\n\\nimport {IOracle} from \\\"../../oracle/IOracle.sol\\\";\\n\\nimport {Adminable} from \\\"../../lib/Adminable.sol\\\";\\nimport {Decimal} from \\\"../../lib/Decimal.sol\\\";\\nimport {Math} from \\\"../../lib/Math.sol\\\";\\nimport {Amount} from \\\"../../lib/Amount.sol\\\";\\nimport {SafeMath} from \\\"../../lib/SafeMath.sol\\\";\\nimport {SafeERC20} from \\\"../../lib/SafeERC20.sol\\\";\\n\\nimport {MozartStorage} from \\\"./MozartStorage.sol\\\";\\nimport {MozartTypes} from  \\\"./MozartTypes.sol\\\";\\n\\n/**\\n * @title MoazartV1\\n * @author Kerman Kohli\\n * @notice This contract holds both the implementation logic and storage (indirectly).\\n *         The key optimization of this contract is around simplicity and the actions\\n *         a user can call. In addition, the architecture is designed for safety around upgrades\\n *         where new storage variables are introduced through the inherited storage contract pattern.\\n */\\ncontract MozartV1 is Adminable, MozartStorage {\\n\\n    /* ========== Libraries ========== */\\n\\n    using SafeMath for uint256;\\n    using Math for uint256;\\n    using Amount for Amount.Principal;\\n\\n    /* ========== Constants ========== */\\n\\n    uint256 constant BASE = 10**18;\\n\\n    /* ========== Types ========== */\\n\\n    enum Operation {\\n        Open,\\n        Borrow,\\n        Repay,\\n        Liquidate,\\n        TransferOwnership\\n    }\\n\\n    struct OperationParams {\\n        uint256 id;\\n        uint256 amountOne;\\n        uint256 amountTwo;\\n        address addressOne;\\n    }\\n\\n    /* ========== Events ========== */\\n\\n    event ActionOperated(\\n        uint8 operation,\\n        OperationParams params,\\n        MozartTypes.Position updatedPosition\\n    );\\n\\n    event ExcessTokensWithdrawn(\\n        address token,\\n        uint256 amount,\\n        address destination\\n    );\\n\\n    event FeesUpdated(\\n        Decimal.D256 _liquidationUserFee,\\n        Decimal.D256 _liquidationArcRatio\\n    );\\n\\n    event LimitsUpdated(\\n        uint256 _collateralLimit,\\n        uint256 _positionCollateralMinimum\\n    );\\n\\n    event GlobalOperatorSet(\\n        address _operator,\\n        bool _status\\n    );\\n\\n    event PositionOperatorSet(\\n        uint256 _positionId,\\n        address _operator,\\n        bool _status\\n    );\\n\\n    event IndexUpdated(\\n        uint256 newIndex,\\n        uint256 lastUpdateTime\\n    );\\n\\n    event RateUpdated(uint256 value);\\n\\n    event OracleUpdated(address value);\\n\\n    event CollateralRatioUpdated(Decimal.D256 value);\\n\\n    event PrinterUpdated(address value);\\n\\n    event PauseStatusUpdated(bool value);\\n\\n    event InterestSetterUpdated(address value);\\n\\n    /* ========== Modifiers ========== */\\n\\n    /**\\n     * @dev Check if a user is authorized to act on behalf of another user's position.\\n     *      Main checks are if:\\n     *      - The address is the actual owner of the position\\n     *      - The address is a valid global operator\\n     *      - The address is a valid operator for that particular position\\n     *\\n     * @param _positionId The position in question here\\n     */\\n    modifier isAuthorized(uint256 _positionId) {\\n        MozartTypes.Position memory position = positions[_positionId];\\n\\n        require(\\n            position.owner == msg.sender ||\\n            isGlobalOperator(msg.sender) ||\\n            isPositionOperator(_positionId, msg.sender),\\n            \\\"D2Core: msg.sender is not the owner or position/global operator\\\"\\n        );\\n        _;\\n    }\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor()\\n        public\\n    {\\n        paused = true;\\n    }\\n\\n    /* ========== Admin Setters ========== */\\n\\n    /**\\n     * @dev Intitialise the protocol with the appropriate parameters. Can only be called once.\\n     *\\n     * @param _collateralDecimals  How many decimals does the collateral contain\\n     * @param _collateralAddress   The address of the collateral to be used\\n     * @param _syntheticAddress    The address of the synthetic token proxy\\n     * @param _oracleAddress       Address of the IOracle conforming contract\\n     * @param _interestSetter      Address which can update interest rates\\n     * @param _collateralRatio     How much colalteral is needed to borrow\\n     * @param _liquidationUserFee  How much is a user penalised if they go below their c-ratio\\n     * @param _liquidationArcRatio How much of the liquidation profit should ARC take\\n     */\\n    function init(\\n        uint8   _collateralDecimals,\\n        address _collateralAddress,\\n        address _syntheticAddress,\\n        address _oracleAddress,\\n        address _interestSetter,\\n        Decimal.D256 memory _collateralRatio,\\n        Decimal.D256 memory _liquidationUserFee,\\n        Decimal.D256 memory _liquidationArcRatio\\n    )\\n        public\\n    {\\n        require(\\n            collateralAsset == address(0),\\n            \\\"MozartV1: cannot re-call init()\\\"\\n        );\\n\\n        precisionScalar = 10 ** (18 - uint256(_collateralDecimals));\\n        collateralAsset = _collateralAddress;\\n        syntheticAsset = _syntheticAddress;\\n\\n        borrowIndex = uint256(10**18);\\n        indexLastUpdate = currentTimestamp();\\n\\n        setOracle(_oracleAddress);\\n        setCollateralRatio(_collateralRatio);\\n        setInterestSetter(_interestSetter);\\n\\n        setFees(\\n            _liquidationUserFee,\\n            _liquidationArcRatio\\n        );\\n    }\\n\\n    /**\\n     * @dev Update the interest rate of the protocol. Since this rate is compounded\\n     *      every second rather than being purely linear, the calculate for r is expressed\\n     *      as the following (assuming you want 5% APY):\\n     *\\n     *      r^N = 1.005\\n     *      since N = 364 * 24 * 60 * 60 (number of seconds in a year)\\n     *      r = 1.000000000158153903837946258002097\\n     *      rate = 1000000000158153903 (18 decimal places solidity value)\\n     *\\n     * @notice Can only be called by the interest setter of the protocol and the maximum\\n     *         rate settable by the admin is 99% (21820606489)\\n     *\\n     * @param _rate The interest rate expressed per second\\n     */\\n    function setInterestRate(\\n        uint256 _rate\\n    )\\n        public\\n    {\\n        require(\\n            msg.sender == interestSetter,\\n            \\\"MozartV1: only callable by interest setter\\\"\\n        );\\n\\n        require(\\n            _rate <= 21820606489,\\n            \\\"MozartV1: interest rate cannot be set to over 99%\\\"\\n        );\\n\\n        interestRate = _rate;\\n        emit RateUpdated(_rate);\\n    }\\n\\n    /**\\n     * @dev Set the instance of the oracle to report prices from. Must conform to IOracle.sol\\n     *\\n     * @notice Can only be called by the admin of the proxy.\\n     *\\n     * @param _oracle The address of the IOracle instance\\n     */\\n    function setOracle(\\n        address _oracle\\n    )\\n        public\\n        onlyAdmin\\n    {\\n        oracle = IOracle(_oracle);\\n        emit OracleUpdated(_oracle);\\n    }\\n\\n    /**\\n     * @dev Set the collateral ratio of value to debt.\\n     *\\n     * @notice Can only be called by the admin of the proxy.\\n     *\\n     * @param _collateralRatio The ratio expressed up to 18 decimal places\\n     */\\n    function setCollateralRatio(\\n        Decimal.D256 memory _collateralRatio\\n    )\\n        public\\n        onlyAdmin\\n    {\\n        require(\\n            _collateralRatio.value < BASE.mul(10) &&\\n            _collateralRatio.value > BASE,\\n            \\\"setCollateralRatio(): must be between 100% and 1000%\\\"\\n        );\\n\\n        collateralRatio = _collateralRatio;\\n        emit CollateralRatioUpdated(_collateralRatio);\\n    }\\n\\n    /**\\n     * @dev Set the fees in the system.\\n     *\\n     * @notice Can only be called by the admin of the proxy.\\n     *\\n     * @param _liquidationUserFee Determines the penalty a user must pay by discounting\\n     *                            their collateral to provide a profit incentive for liquidators\\n     * @param _liquidationArcRatio The amount ARC earns from the profit earned from the liquidation.\\n     */\\n    function setFees(\\n        Decimal.D256 memory _liquidationUserFee,\\n        Decimal.D256 memory _liquidationArcRatio\\n    )\\n        public\\n        onlyAdmin\\n    {\\n        liquidationUserFee = _liquidationUserFee;\\n        liquidationArcRatio = _liquidationArcRatio;\\n\\n        emit FeesUpdated(\\n            liquidationUserFee,\\n            liquidationArcRatio\\n        );\\n    }\\n\\n    /**\\n     * @dev Set the limits of the system to ensure value can be capped.\\n     *\\n     * @notice Can only be called by the admin of the proxy\\n     *\\n     * @param _collateralLimit Maximum amount of collateral that can be held in the system.\\n     *                         This should be expressed as 18 decimal places since the precision\\n     *                         scalar will handle the rest.\\n     * @param _positionCollateralMinimum The minimum of collateral per position\\n     */\\n    function setLimits(\\n        uint256 _collateralLimit,\\n        uint256 _positionCollateralMinimum\\n    )\\n        public\\n        onlyAdmin\\n    {\\n        collateralLimit = _collateralLimit;\\n        positionCollateralMinimum = _positionCollateralMinimum;\\n\\n        emit LimitsUpdated(\\n            collateralLimit,\\n            positionCollateralMinimum\\n        );\\n    }\\n\\n    /**\\n     * @dev Set the address which can set interest rates\\n     *\\n     * @notice Can only be called by the admin of the proxy\\n     *\\n     * @param _setter The address of the new interest rate setter\\n     */\\n    function setInterestSetter(\\n        address _setter\\n    )\\n        public\\n        onlyAdmin\\n    {\\n        interestSetter = _setter;\\n\\n        emit InterestSetterUpdated(_setter);\\n    }\\n\\n    /**\\n     * @dev Set an address to be able to manage any user's position.\\n     *\\n     * @notice Can only be called by the admin of the proxy\\n     *\\n     * @param _operator Address of the new operator\\n     * @param _status True indicates they are a valid address, false means they are not\\n     */\\n    function setGlobalOperatorStatus(\\n        address _operator,\\n        bool    _status\\n    )\\n        public\\n        onlyAdmin\\n    {\\n        globalOperators[_operator] = _status;\\n\\n        emit GlobalOperatorSet(_operator, _status);\\n    }\\n\\n    /* ========== Public Functions ========== */\\n\\n    /**\\n     * @dev Add/remove an address to operate a position on the owner's behalf. This will include\\n     *      the ability to borrow and repay on their behalf as well.\\n     *\\n     * @param _positionId The position to become an operator for\\n     * @param _operator The address set to become the operator\\n     * @param _status The ability to s\\n     */\\n    function setPositionOperatorStatus(\\n        uint256 _positionId,\\n        address _operator,\\n        bool    _status\\n    )\\n        public\\n    {\\n        MozartTypes.Position memory position = positions[_positionId];\\n\\n        require(\\n            position.owner == msg.sender || isGlobalOperator(msg.sender),\\n            \\\"setPositionOperatorStatus(): must be owner or global operator\\\"\\n        );\\n\\n        positionOperators[_positionId][_operator] = _status;\\n\\n        emit PositionOperatorSet(\\n            _positionId,\\n            _operator,\\n            _status\\n        );\\n    }\\n\\n    /**\\n     * @dev This is the only function that can be called by user's of the system\\n     *      and uses an enum and struct to parse the args. This structure guarantees\\n     *      the state machine will always meet certain properties\\n     *\\n     * @param operation An enum of the operation to execute\\n     * @param params Parameters to exceute the operation against\\n     */\\n    function operateAction(\\n        Operation operation,\\n        OperationParams memory params\\n    )\\n        public\\n    {\\n        require(\\n            paused == false,\\n            \\\"operateAction(): contracts cannot be paused\\\"\\n        );\\n\\n        MozartTypes.Position memory operatedPosition;\\n\\n        // Update the index to calculate how much interest has accrued\\n        // And then subsequently mint more of the synth to the printer\\n        updateIndex();\\n\\n        if (operation == Operation.Open) {\\n            (operatedPosition, params.id) = openPosition(\\n                params.amountOne,\\n                params.amountTwo\\n            );\\n\\n            require(\\n                params.amountOne >= positionCollateralMinimum,\\n                \\\"operateAction(): must exceed minimum collateral amount\\\"\\n            );\\n        } else if (operation == Operation.Borrow) {\\n            operatedPosition = borrow(\\n                params.id,\\n                params.amountOne,\\n                params.amountTwo\\n            );\\n        } else if (operation == Operation.Repay) {\\n            operatedPosition = repay(\\n                params.id,\\n                params.amountOne,\\n                params.amountTwo\\n            );\\n        } else if (operation == Operation.Liquidate) {\\n            operatedPosition = liquidate(\\n                params.id\\n            );\\n        } else if (operation == Operation.TransferOwnership) {\\n            operatedPosition = transferOwnership(\\n                params.id,\\n                params.addressOne\\n            );\\n        } else {\\n            revert(\\\"operateAction(): invalid action\\\");\\n        }\\n\\n        // Ensure that the operated action is collateralised again, unless a liquidation\\n        // has occured in which case the position might be under-collataralised\\n        require(\\n            isCollateralized(operatedPosition) == true || operation == Operation.Liquidate,\\n            \\\"operateAction(): the operated position is undercollateralised\\\"\\n        );\\n\\n        // Ensure the amount supplied is less than the collateral limit of the system\\n        require(\\n            totalSupplied <= collateralLimit || collateralLimit == 0,\\n            \\\"operateAction(): collateral locked cannot be greater than limit\\\"\\n        );\\n\\n        // Collateral should never be expressed as negative since it means value has been drained\\n        assert(operatedPosition.collateralAmount.sign == true);\\n\\n        // Debt should never be expressed as positive since it means the protocol is in debt to the user\\n        assert(operatedPosition.borrowedAmount.sign == false);\\n\\n        emit ActionOperated(\\n            uint8(operation),\\n            params,\\n            operatedPosition\\n        );\\n    }\\n\\n    /**\\n     * @dev Update the index of the contracts to compute the current interest rate.\\n     *      This function simply calculates the last time this function was called\\n     *      (in seconds) then multiplied by the interest rate. The result is then\\n     *      multiplied by the totalBorrowed amount.\\n    */\\n    function updateIndex()\\n        public\\n    {\\n        if (currentTimestamp() == indexLastUpdate) {\\n            return;\\n        }\\n\\n        if (totalBorrowed == 0 || interestRate == 0) {\\n            indexLastUpdate = currentTimestamp();\\n            emit IndexUpdated(borrowIndex, indexLastUpdate);\\n            return;\\n        }\\n\\n        // First we multiply the interest rate (expressed in rate/sec) by the time since\\n        // the last update. This result represents the proportional amount of interest to\\n        // apply to the system at a whole\\n        uint256 interestAccumulated = interestRate.mul(currentTimestamp().sub(indexLastUpdate));\\n\\n        // Then we multiply the existing index by the newly generated rate so that we can\\n        // get a compounded interest rate.\\n        // ie. interestAccumulated = 0.1, borrowIndex = 1.1, new borrowIndex = 0.1 + 1.1 = 1.2\\n        borrowIndex = borrowIndex.add(interestAccumulated);\\n\\n        // Update the total borrows based on the proportional rate of interest applied\\n        // to the entire system\\n        totalBorrowed = totalBorrowed.mul(borrowIndex).div(BASE);\\n\\n        // Set the last time the index was updated to now\\n        indexLastUpdate = currentTimestamp();\\n\\n        emit IndexUpdated(\\n            borrowIndex,\\n            indexLastUpdate\\n        );\\n    }\\n\\n    /* ========== Admin Functions ========== */\\n\\n    /**\\n     * @dev Withdraw tokens owned by the proxy. This will never include depositor funds\\n     *      since all the collateral is held by the synthetic token itself. The only funds\\n     *      that will accrue based on CoreV1 & StateV1 is the liquidation fees.\\n     *\\n     * @param token Address of the token to withdraw\\n     * @param destination Destination to withdraw to\\n     * @param amount The total amount of tokens withdraw\\n     */\\n    function withdrawTokens(\\n        address token,\\n        address destination,\\n        uint256 amount\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        SafeERC20.safeTransfer(\\n            IERC20(token),\\n            destination,\\n            amount\\n        );\\n    }\\n\\n    function setPause(bool value)\\n        external\\n        onlyAdmin\\n    {\\n        paused = value;\\n\\n        emit PauseStatusUpdated(value);\\n    }\\n\\n    /* ========== Internal Functions ========== */\\n\\n    /**\\n     * @dev Open a new position.\\n     *\\n     * @return The new position and the ID of the opened position\\n     */\\n    function openPosition(\\n        uint256 collateralAmount,\\n        uint256 borrowAmount\\n    )\\n        internal\\n        returns (MozartTypes.Position memory, uint256)\\n    {\\n        // CHECKS:\\n        // 1. No checks required as it's all processed in borrow()\\n\\n        // EFFECTS:\\n        // 1. Create a new Position struct with the basic fields filled out and save it to storage\\n        // 2. Call `borrow()`\\n\\n        MozartTypes.Position memory newPosition = MozartTypes.Position({\\n            owner: msg.sender,\\n            collateralAmount: Amount.zero(),\\n            borrowedAmount: Amount.zero()\\n        });\\n\\n        // This position is saved to storage to make the logic around borrowing\\n        // uniform. This is slightly gas inefficient but ok given the ability to\\n        // ensure no diverging logic.\\n\\n        uint256 positionId = positionCount;\\n        positions[positionCount] = newPosition;\\n        positionCount = positionCount.add(1);\\n\\n        newPosition = borrow(\\n            positionId,\\n            collateralAmount,\\n            borrowAmount\\n        );\\n\\n        return (\\n            newPosition,\\n            positionId\\n        );\\n    }\\n\\n    /**\\n     * @dev Borrow against an existing position.\\n     *\\n     * @param positionId ID of the position you'd like to borrow against\\n     * @param collateralAmount Collateral deposit amount\\n     * @param borrowAmount How much would you'd like to borrow/mint\\n     */\\n    function borrow(\\n        uint256 positionId,\\n        uint256 collateralAmount,\\n        uint256 borrowAmount\\n    )\\n        private\\n        isAuthorized(positionId)\\n        returns (MozartTypes.Position memory)\\n    {\\n        // CHECKS:\\n        // 1. Ensure that the position actually exists\\n        // 2. Convert the borrow amount to a Principal value\\n        // 3. Ensure the position is collateralised before borrowing against it\\n        // 4. Ensure that msg.sender == owner of position (done in the modifier)\\n        // 5. Determine if there's enough liquidity of the `borrowAsset`\\n        // 6. Calculate the amount of collateral actually needed given the `collateralRatio`\\n        // 7. Ensure the user has provided enough of the collateral asset\\n\\n        // EFFECTS:\\n        // 1. Increase the collateral amount to calculate the maximum the amount the user can borrow\\n        // 2. Calculate the proportional new par value based on the borrow amount\\n        // 3. Update the total supplied collateral amount\\n        // 4. Calculate the collateral needed and ensuring the position has that much\\n\\n        // INTERACTIONS:\\n        // 1. Mint the synthetic asset\\n        // 2. Transfer the collateral to the synthetic token itself.\\n        //    This ensures on Etherscan people can see how much collateral is backing\\n        //    the synthetic\\n\\n        // Get the current position\\n        MozartTypes.Position storage position = positions[positionId];\\n\\n        Decimal.D256 memory currentPrice = oracle.fetchCurrentPrice();\\n        // Increase the user's collateral amount & increase the global supplied amount\\n        position = setCollateralAmount(\\n            positionId,\\n            position.collateralAmount.add(\\n                Amount.Principal({\\n                    sign: true,\\n                    value: collateralAmount.mul(precisionScalar)\\n                })\\n            )\\n        );\\n\\n        // Sometimes a user may want to only deposit more collateral and not borrow more\\n        // so in that case we don't need to recheck any borrowing requirements\\n        if (borrowAmount > 0) {\\n            // Calculate the principal amount based on the current index of the market\\n            Amount.Principal memory convertedPrincipal = Amount.calculatePrincipal(\\n                borrowAmount,\\n                borrowIndex,\\n                false\\n            );\\n\\n            // Set the total new borrowed amount. We need to use this function\\n            // in order to adjust the total borrowed amount proportionally as well.\\n            position = setBorrowAmount(\\n                positionId,\\n                position.borrowedAmount.add(convertedPrincipal)\\n            );\\n\\n            // Check how much collateral they need based on their new position details\\n            Amount.Principal memory collateralRequired = calculateCollateralRequired(\\n                position.borrowedAmount.calculateAdjusted(borrowIndex),\\n                currentPrice\\n            );\\n\\n            // Ensure the user's collateral amount is greater than the collateral needed\\n            require(\\n                position.collateralAmount.value >= collateralRequired.value,\\n                \\\"borrowPosition(): not enough collateral provided\\\"\\n            );\\n        }\\n\\n        IERC20 syntheticAsset = IERC20(syntheticAsset);\\n        IERC20 collateralAsset = IERC20(collateralAsset);\\n\\n        // Transfer the collateral asset to the synthetic contract\\n        SafeERC20.safeTransferFrom(\\n            collateralAsset,\\n            msg.sender,\\n            address(syntheticAsset),\\n            collateralAmount\\n        );\\n\\n        ISyntheticToken(address(syntheticAsset)).mint(\\n            msg.sender,\\n            borrowAmount\\n        );\\n\\n        return position;\\n    }\\n\\n    /**\\n     * @dev Repay money against a borrowed position. When this process occurs the position's\\n     *      debt will be reduced and in turn will allow them to withdraw their collateral should they choose.\\n     *\\n     * @param positionId ID of the position to repay\\n     * @param repayAmount Amount of debt to repay\\n     * @param withdrawAmount Amount of collateral to withdraw\\n     */\\n    function repay(\\n        uint256 positionId,\\n        uint256 repayAmount,\\n        uint256 withdrawAmount\\n    )\\n        private\\n        isAuthorized(positionId)\\n        returns (MozartTypes.Position memory)\\n    {\\n        // CHECKS:\\n        // 1. Ensure the position actually exists by ensuring the owner == msg.sender (done in the modifier)\\n        // 2. The position does not have to be collateralised since we want people to repay\\n        //    before a liquidator does if they do actually have a chance\\n\\n        // EFFECTS:\\n        // 1. Calculate the new par value of the position based on the amount they're going to repay\\n        // 2. Update the user's borrow amount by calling the setBorrowAmount() function\\n        // 3. Calculate how much collateral they can withdraw based on their new borrow amount\\n        // 4. Check if the amount being withdrawn is enough given their borrowing requirement\\n        // 5. Update the user's collateral amount by calling the setCollateralAmount() function\\n\\n        // INTERACTIONS:\\n        // 1. Burn the synths being repaid directly from their wallet\\n        // 2. Transfer the collateral back to the user\\n\\n        MozartTypes.Position storage position = positions[positionId];\\n\\n        Decimal.D256 memory currentPrice = oracle.fetchCurrentPrice();\\n\\n        uint256 scaledWithdrawAmount = withdrawAmount.mul(precisionScalar);\\n\\n        // Calculate the principal amount based on the current index of the market\\n        Amount.Principal memory convertedPrincipal = Amount.calculatePrincipal(\\n            repayAmount,\\n            borrowIndex,\\n            true\\n        );\\n\\n        // Set the user's new borrow amount by decreasing their debt amount.\\n        // A positive par value will increase a negative par value.\\n        position = setBorrowAmount(\\n            positionId,\\n            position.borrowedAmount.add(convertedPrincipal)\\n        );\\n\\n        // Calculate how much the user is allowed to withdraw given their debt was repaid\\n        Amount.Principal memory collateralDelta = calculateCollateralDelta(\\n            position.collateralAmount,\\n            position.borrowedAmount.calculateAdjusted(borrowIndex),\\n            currentPrice\\n        );\\n\\n        // Ensure that the amount they are trying to withdraw is less than their limit\\n        // Also, make sure that the delta is positive (aka collateralized).\\n        require(\\n            collateralDelta.sign == true && scaledWithdrawAmount <= collateralDelta.value,\\n            \\\"repay(): cannot withdraw more than allowed\\\"\\n        );\\n\\n        // Decrease the user's collateral amount by adding a negative principal amount\\n        position = setCollateralAmount(\\n            positionId,\\n            position.collateralAmount.add(\\n                Amount.Principal({\\n                    sign: false,\\n                    value: scaledWithdrawAmount\\n                })\\n            )\\n        );\\n\\n        ISyntheticToken synthetic = ISyntheticToken(syntheticAsset);\\n        IERC20 collateralAsset = IERC20(collateralAsset);\\n\\n        synthetic.burn(\\n            msg.sender,\\n            repayAmount\\n        );\\n\\n        // Transfer collateral back to the user\\n        bool transferResult = synthetic.transferCollateral(\\n            address(collateralAsset),\\n            msg.sender,\\n            withdrawAmount\\n        );\\n\\n        require(\\n            transferResult == true,\\n            \\\"repay(): collateral failed to transfer\\\"\\n        );\\n\\n        return position;\\n    }\\n\\n    /**\\n     * @dev Liquidate a user's position. When this process occurs you're essentially\\n     *      purchasing the users's debt at a discount (liquidation spread) in exchange\\n     *      for the collateral they have deposited inside their position.\\n     *\\n     * @param positionId ID of the position to liquidate\\n     */\\n    function liquidate(\\n        uint256 positionId\\n    )\\n        private\\n        returns (MozartTypes.Position memory)\\n    {\\n        // CHECKS:\\n        // 1. Ensure that the position is valid (check if there is a non-0x0 owner)\\n        // 2. Ensure that the position is indeed undercollateralized\\n\\n        // EFFECTS:\\n        // 1. Calculate the liquidation price based on the liquidation penalty\\n        // 2. Calculate how much the user is in debt by\\n        // 3. Add the liquidation penalty to the liquidation amount so there's\\n        //    a buffer that exists to ensure they can't get liquidated again\\n        // 4. If the collateral to liquidate is greater than the collateral, bound it.\\n        // 5. Calculate how much of the borrowed asset is to be liquidated\\n        // 5. Decrease the user's debt obligation\\n        // 6. Decrease the user's collateral amount\\n\\n        // INTERACTIONS:\\n        // 1. Burn the synthetic from the liquidator\\n        // 2. Tranfer the collateral from the synthetic token to the liquidator\\n        // 3. Transfer a portion to the ARC Core contract as a fee\\n\\n        MozartTypes.Position storage position = positions[positionId];\\n\\n        require(\\n            position.owner != address(0),\\n            \\\"liquidatePosition(): must be a valid position\\\"\\n        );\\n\\n        // Ensure that the position is not collateralized\\n        require(\\n            isCollateralized(position) == false,\\n            \\\"liquidatePosition(): position is collateralised\\\"\\n        );\\n\\n        // Get the liquidation price of the asset (discount for liquidator)\\n        Decimal.D256 memory liquidationPrice = calculateLiquidationPrice();\\n\\n        // Calculate how much the user is in debt by to be whole again at a discounted price\\n        (Amount.Principal memory liquidationCollateralDelta) = calculateCollateralDelta(\\n            position.collateralAmount,\\n            position.borrowedAmount.calculateAdjusted(borrowIndex),\\n            liquidationPrice\\n        );\\n\\n        // Liquidate a slight bit more to ensure the user is guarded against futher price drops\\n        liquidationCollateralDelta.value = Decimal.mul(\\n            liquidationCollateralDelta.value,\\n            Decimal.add(\\n                liquidationUserFee,\\n                Decimal.one().value\\n            )\\n        );\\n\\n        // Calculate how much collateral this is going to cost the liquidator\\n        // The sign is negative since we need to subtract from the liquidation delta\\n        // which is a negative sign and subtracting a negative will actually add it\\n\\n        // Calculate the amount of collateral actually needed in order to perform this liquidation.\\n        // Since the liquidationUserFee is the penalty, by multiplying (1-fee) we can get the\\n        // actual collateral amount needed. We'll ultimately be adding this amount to the\\n        // liquidation delta (which is negative) to give us the profit amount.\\n        (Amount.Principal memory liquidatorCollateralCost) = Amount.Principal({\\n            sign: true,\\n            value: Decimal.mul(\\n                liquidationCollateralDelta.value,\\n                Decimal.sub(\\n                    Decimal.one(),\\n                    liquidationUserFee.value\\n                )\\n            )\\n        });\\n\\n        // If the maximum they're down by is greater than their collateral, bound to the maximum\\n        // This case will only arise if the position has truly become under-collateralized.\\n\\n        // This check also ensures that no one can create a position which can drain the system\\n        // for more collateral than the position itself has.\\n        if (liquidationCollateralDelta.value > position.collateralAmount.value) {\\n            liquidationCollateralDelta.value = position.collateralAmount.value;\\n\\n            // If the the original collateral delta is to be the same as the\\n            // collateral amount. What this does is that the profit calculated\\n            // will be 0 since the liquidationCollateralDelta less the\\n            // originalCollateralDelta will be the same.\\n            liquidatorCollateralCost.value = position.collateralAmount.value;\\n        }\\n\\n        // Calculate how much borrowed assets to liquidate (at a discounted price)\\n        // We can use the liquidationCollateralDelta.value since it's already using\\n        // interest-adjusted values rather than principal values\\n        uint256 borrowToLiquidate = Decimal.mul(\\n            liquidationCollateralDelta.value,\\n            liquidationPrice\\n        );\\n\\n        // Decrease the user's debt amout by the principal amount\\n        position = setBorrowAmount(\\n            positionId,\\n            position.borrowedAmount.add(\\n                Amount.calculatePrincipal(\\n                    borrowToLiquidate,\\n                    borrowIndex,\\n                    true\\n                )\\n            )\\n        );\\n\\n        // Decrease the user's collateral amount by adding the collateral delta (which is negative)\\n        position = setCollateralAmount(\\n            positionId,\\n            position.collateralAmount.add(liquidationCollateralDelta)\\n        );\\n\\n        require(\\n            IERC20(collateralAsset).balanceOf(msg.sender) >= borrowToLiquidate,\\n            \\\"liquidatePosition(): msg.sender not enough of borrowed asset to liquidate\\\"\\n        );\\n\\n        _settleLiquidation(\\n            borrowToLiquidate,\\n            liquidationCollateralDelta,\\n            liquidatorCollateralCost\\n        );\\n\\n        return position;\\n    }\\n\\n    function _settleLiquidation(\\n        uint256 borrowToLiquidate,\\n        Amount.Principal memory liquidationCollateralDelta,\\n        Amount.Principal memory liquidatorCollateralCost\\n    )\\n        private\\n    {\\n        ISyntheticToken synthetic = ISyntheticToken(syntheticAsset);\\n        IERC20 collateralAsset = IERC20(collateralAsset);\\n\\n        synthetic.burn(\\n            msg.sender,\\n            borrowToLiquidate\\n        );\\n\\n        // This is the actual profit collected from the liquidation\\n        // Since the liquidationCollateralDelta is negative and liquidationCollateralCost\\n        // is a positive value, by adding them the result gives us the profit\\n        Amount.Principal memory collateralProfit = liquidationCollateralDelta.add(\\n            liquidatorCollateralCost\\n        );\\n\\n        // ARC's profit is simple a percentage of the profit, not net total\\n        uint256 arcProfit = Decimal.mul(\\n            collateralProfit.value,\\n            liquidationArcRatio\\n        );\\n\\n        // Transfer them the collateral assets they acquired at a discount\\n        bool userTransferResult = synthetic.transferCollateral(\\n            address(collateralAsset),\\n            msg.sender,\\n            uint256(liquidationCollateralDelta.value).sub(arcProfit).div(precisionScalar)\\n        );\\n\\n        require(\\n            userTransferResult == true,\\n            \\\"liquidate(): collateral failed to transfer to user\\\"\\n        );\\n\\n        // Transfer ARC the collateral asset acquired at a discount\\n        bool arcTransferResult = synthetic.transferCollateral(\\n            address(collateralAsset),\\n            address(this),\\n            arcProfit.div(precisionScalar)\\n        );\\n\\n        require(\\n            arcTransferResult == true,\\n            \\\"liquidate(): collateral failed to transfer to arc\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Update a position's collateral amount. This function is used to ensure\\n     *      consistency in the total supplied amount as a user's collateral balance changes.\\n     *\\n     * @param positionId The id of the position to update the collateral amount for\\n     * @param newSupplyAmount How much to set their new supply values to\\n     */\\n    function setCollateralAmount(\\n        uint256 positionId,\\n        Amount.Principal memory newSupplyAmount\\n    )\\n        private\\n        returns (MozartTypes.Position storage)\\n    {\\n        MozartTypes.Position storage position = positions[positionId];\\n\\n        if (position.collateralAmount.equals(newSupplyAmount)) {\\n            return position;\\n        }\\n\\n        uint256 newTotalSupplied = totalSupplied;\\n\\n        // Roll back the old amount\\n        newTotalSupplied = newTotalSupplied.sub(position.collateralAmount.value);\\n\\n        // Roll forward the new amount\\n        newTotalSupplied = newTotalSupplied.add(newSupplyAmount.value);\\n\\n        // Update the total borrowed storage value to the final result\\n        totalSupplied = newTotalSupplied;\\n\\n        // Update the actual position's supplied amount\\n        position.collateralAmount = newSupplyAmount;\\n\\n        // Prevent having collateral represented by negative values\\n        if (position.collateralAmount.value == 0) {\\n            position.collateralAmount.sign = true;\\n        }\\n\\n        return position;\\n    }\\n\\n    /**\\n     * @dev Update a position's borrow amount. This function is used to ensure consistency in the\\n     *      total borrowed amount as the user's borrowed amount changes.\\n     *\\n     * @param positionId The id of the position to update the borrow amount for\\n     * @param newBorrowAmount The new borrow amount for the position\\n     */\\n    function setBorrowAmount(\\n        uint256 positionId,\\n        Amount.Principal memory newBorrowAmount\\n    )\\n        private\\n        returns (MozartTypes.Position storage)\\n    {\\n        MozartTypes.Position storage position = positions[positionId];\\n        Amount.Principal memory existingAmount = position.borrowedAmount;\\n\\n        if (position.borrowedAmount.equals(newBorrowAmount)) {\\n            return position;\\n        }\\n\\n        uint256 newTotalBorrowed = totalBorrowed;\\n\\n        // Roll back the old amount\\n        newTotalBorrowed = newTotalBorrowed.sub(existingAmount.value);\\n\\n        // Roll forward the new amount\\n        newTotalBorrowed = newTotalBorrowed.add(newBorrowAmount.value);\\n\\n        // Update the total borrowed storage value to the final result\\n        totalBorrowed = newTotalBorrowed;\\n\\n        // Update the actual position's borrowed amount\\n        position.borrowedAmount = newBorrowAmount;\\n\\n        // Prevent having debt represented by positive values\\n        if (position.borrowedAmount.value == 0) {\\n            position.borrowedAmount.sign = false;\\n        }\\n\\n        return position;\\n    }\\n\\n    /**\\n     * @dev This should allow a user to transfer ownership of a position to a\\n     *      a different address to operate their position.\\n     *\\n     * @param positionId ID of the position to transfer ownership to\\n     * @param newOwner New owner of the position to set\\n     */\\n    function transferOwnership(\\n        uint256 positionId,\\n        address newOwner\\n    )\\n        private\\n        returns (MozartTypes.Position storage)\\n    {\\n        MozartTypes.Position storage position = positions[positionId];\\n\\n        require(\\n            msg.sender == position.owner,\\n            \\\"transferOwnership(): must be the owner of the position\\\"\\n        );\\n\\n        position.owner = newOwner;\\n\\n        return position;\\n    }\\n\\n    /* ========== Public Getters ========== */\\n\\n    function getPosition(\\n        uint256 id\\n    )\\n        external\\n        view\\n        returns (MozartTypes.Position memory)\\n    {\\n        return positions[id];\\n    }\\n\\n    function getCurrentPrice()\\n        external\\n        view\\n        returns (Decimal.D256 memory)\\n    {\\n        return oracle.fetchCurrentPrice();\\n    }\\n\\n    function getSyntheticAsset()\\n        external\\n        view\\n        returns (address)\\n    {\\n        return address(syntheticAsset);\\n    }\\n\\n    function getCollateralAsset()\\n        external\\n        view\\n        returns (address)\\n    {\\n        return address(collateralAsset);\\n    }\\n\\n    function getCurrentOracle()\\n        external\\n        view\\n        returns (address)\\n    {\\n        return address(oracle);\\n    }\\n\\n    function getInterestSetter()\\n        external\\n        view\\n        returns (address)\\n    {\\n        return interestSetter;\\n    }\\n\\n    function getBorrowIndex()\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return (borrowIndex, indexLastUpdate);\\n    }\\n\\n    function getCollateralRatio()\\n        external\\n        view\\n        returns (Decimal.D256 memory)\\n    {\\n        return collateralRatio;\\n    }\\n\\n    function getTotals()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return (\\n            totalSupplied,\\n            totalBorrowed\\n        );\\n    }\\n\\n    function getLimits()\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return (collateralLimit, positionCollateralMinimum);\\n    }\\n\\n    function getInterestRate()\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return interestRate;\\n    }\\n\\n    function getFees()\\n        external\\n        view\\n        returns (\\n            Decimal.D256 memory _liquidationUserFee,\\n            Decimal.D256 memory _liquidationArcRatio\\n        )\\n    {\\n        return (\\n            liquidationUserFee,\\n            liquidationArcRatio\\n        );\\n    }\\n\\n    function isPositionOperator(\\n        uint256 _positionId,\\n        address _operator\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return positionOperators[_positionId][_operator];\\n    }\\n\\n    function isGlobalOperator(\\n        address _operator\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return globalOperators[_operator];\\n    }\\n\\n    /* ========== Developer Functions ========== */\\n\\n    function currentTimestamp()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Check if a position is collateralised or not\\n     *\\n     * @param position The struct of a position to validate if it's underwater or not\\n     */\\n    function isCollateralized(\\n        MozartTypes.Position memory position\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        if (position.borrowedAmount.value == 0) {\\n            return true;\\n        }\\n\\n        Decimal.D256 memory currentPrice = oracle.fetchCurrentPrice();\\n\\n        (Amount.Principal memory collateralDelta) = calculateCollateralDelta(\\n            position.collateralAmount,\\n            position.borrowedAmount.calculateAdjusted(borrowIndex),\\n            currentPrice\\n        );\\n\\n        if (collateralDelta.value == 0) {\\n            collateralDelta.sign = true;\\n        }\\n\\n        return collateralDelta.sign;\\n    }\\n\\n    /**\\n     * @dev Calculate how much collateral you need given a certain borrow amount\\n     *\\n     * @param borrowedAmount The borrowed amount expressed as a uint256 (NOT principal)\\n     * @param price What price do you want to calculate the inverse at\\n     */\\n    function calculateCollateralRequired(\\n        uint256 borrowedAmount,\\n        Decimal.D256 memory price\\n    )\\n        public\\n        view\\n        returns (Amount.Principal memory)\\n    {\\n\\n        uint256 inverseRequired = Decimal.div(\\n            borrowedAmount,\\n            price\\n        );\\n\\n        inverseRequired = Decimal.mul(\\n            inverseRequired,\\n            collateralRatio\\n        );\\n\\n        return Amount.Principal({\\n            sign: true,\\n            value: inverseRequired\\n        });\\n    }\\n\\n    /**\\n     * @dev Given an asset being borrowed, figure out how much collateral can this still borrow or\\n     *      is in the red by. This function is used to check if a position is undercolalteralised and\\n     *      also to calculate how much can a position be liquidated by.\\n     *\\n     * @param parSupply The amount being supplied\\n     * @param borrowedAmount The non-par amount being borrowed\\n     * @param price The price to calculate this difference by\\n     */\\n    function calculateCollateralDelta(\\n        Amount.Principal memory parSupply,\\n        uint256 borrowedAmount,\\n        Decimal.D256 memory price\\n    )\\n        public\\n        view\\n        returns (Amount.Principal memory)\\n    {\\n        Amount.Principal memory collateralDelta;\\n        Amount.Principal memory collateralRequired;\\n\\n        collateralRequired = calculateCollateralRequired(\\n            borrowedAmount,\\n            price\\n        );\\n\\n        // If the amount of collateral needed exceeds the par supply amount\\n        // then the result will be negative indicating the position is undercollateralised.\\n        collateralDelta = parSupply.sub(collateralRequired);\\n\\n        return collateralDelta;\\n    }\\n\\n    /**\\n     * @dev When executing a liqudation, the price of the asset has to be calculated\\n     *      at a discount in order for it to be profitable for the liquidator. This function\\n     *      will get the current oracle price for the asset and find the discounted price.\\n     *\\n     */\\n    function calculateLiquidationPrice()\\n        public\\n        view\\n        returns (Decimal.D256 memory)\\n    {\\n        Decimal.D256 memory result;\\n        Decimal.D256 memory currentPrice = oracle.fetchCurrentPrice();\\n\\n        result = Decimal.sub(\\n            Decimal.one(),\\n            liquidationUserFee.value\\n        );\\n\\n        result = Decimal.mul(\\n            currentPrice,\\n            result\\n        );\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/token/ISyntheticToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {Amount} from \\\"../lib/Amount.sol\\\";\\n\\ninterface ISyntheticToken {\\n\\n    function symbolKey()\\n        external\\n        view\\n        returns (bytes32);\\n\\n    function mint(\\n        address to,\\n        uint256 value\\n    )\\n        external;\\n\\n    function burn(\\n        address to,\\n        uint256 value\\n    )\\n        external;\\n\\n    function transferCollateral(\\n        address token,\\n        address to,\\n        uint256 value\\n    )\\n        external\\n        returns (bool);\\n\\n    function getMinterIssued(\\n        address _minter\\n    )\\n        external\\n        view\\n        returns (Amount.Principal memory);\\n\\n    function getMinterLimit(\\n        address _minter\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"./contracts/lib/Amount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from \\\"../lib/SafeMath.sol\\\";\\nimport {Math} from \\\"../lib/Math.sol\\\";\\n\\nlibrary Amount {\\n\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n\\n    // ============ Constants ============\\n\\n    uint256 constant BASE = 10**18;\\n\\n    // A Principal Amount is an amount that's been adjusted by an index\\n\\n    struct Principal {\\n        bool sign; // true if positive\\n        uint256 value;\\n    }\\n\\n    function zero()\\n        internal\\n        pure\\n        returns (Principal memory)\\n    {\\n        return Principal({\\n            sign: false,\\n            value: 0\\n        });\\n    }\\n\\n    function sub(\\n        Principal memory a,\\n        Principal memory b\\n    )\\n        internal\\n        pure\\n        returns (Principal memory)\\n    {\\n        return add(a, negative(b));\\n    }\\n\\n    function add(\\n        Principal memory a,\\n        Principal memory b\\n    )\\n        internal\\n        pure\\n        returns (Principal memory)\\n    {\\n        Principal memory result;\\n\\n        if (a.sign == b.sign) {\\n            result.sign = a.sign;\\n            result.value = SafeMath.add(a.value, b.value);\\n        } else {\\n            if (a.value >= b.value) {\\n                result.sign = a.sign;\\n                result.value = SafeMath.sub(a.value, b.value);\\n            } else {\\n                result.sign = b.sign;\\n                result.value = SafeMath.sub(b.value, a.value);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    function equals(\\n        Principal memory a,\\n        Principal memory b\\n    )\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (a.value == b.value) {\\n            if (a.value == 0) {\\n                return true;\\n            }\\n            return a.sign == b.sign;\\n        }\\n        return false;\\n    }\\n\\n    function negative(\\n        Principal memory a\\n    )\\n        internal\\n        pure\\n        returns (Principal memory)\\n    {\\n        return Principal({\\n            sign: !a.sign,\\n            value: a.value\\n        });\\n    }\\n\\n    function calculateAdjusted(\\n        Principal memory a,\\n        uint256 index\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return Math.getPartial(a.value, index, BASE);\\n    }\\n\\n    function calculatePrincipal(\\n        uint256 value,\\n        uint256 index,\\n        bool sign\\n    )\\n        internal\\n        pure\\n        returns (Principal memory)\\n    {\\n        return Principal({\\n            sign: sign,\\n            value: Math.getPartial(value, BASE, index)\\n        });\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"./contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.5.16;\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/lib/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title Math\\n *\\n * Library for non-standard Math functions\\n */\\nlibrary Math {\\n    using SafeMath for uint256;\\n\\n    // ============ Library Functions ============\\n\\n    /*\\n     * Return target * (numerator / denominator).\\n     */\\n    function getPartial(\\n        uint256 target,\\n        uint256 numerator,\\n        uint256 denominator\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return target.mul(numerator).div(denominator);\\n    }\\n\\n    function to128(\\n        uint256 number\\n    )\\n        internal\\n        pure\\n        returns (uint128)\\n    {\\n        uint128 result = uint128(number);\\n        require(\\n            result == number,\\n            \\\"Math: Unsafe cast to uint128\\\"\\n        );\\n        return result;\\n    }\\n\\n    function min(\\n        uint256 a,\\n        uint256 b\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return a < b ? a : b;\\n    }\\n\\n    function max(\\n        uint256 a,\\n        uint256 b\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return a > b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/token/IMintableToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\ninterface IMintableToken {\\n\\n    function mint(\\n        address to,\\n        uint256 value\\n    )\\n        external;\\n\\n    function burn(\\n        address to,\\n        uint256 value\\n    )\\n        external;\\n\\n}\"\r\n    },\r\n    \"./contracts/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    )\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    )\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    )\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {Decimal} from \\\"../lib/Decimal.sol\\\";\\n\\ninterface IOracle {\\n\\n    function fetchCurrentPrice()\\n        external\\n        view\\n        returns (Decimal.D256 memory);\\n\\n}\"\r\n    },\r\n    \"./contracts/lib/Decimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from \\\"../lib/SafeMath.sol\\\";\\nimport {Math} from \\\"./Math.sol\\\";\\n\\n/**\\n * @title Decimal\\n *\\n * Library that defines a fixed-point number with 18 decimal places.\\n */\\nlibrary Decimal {\\n    using SafeMath for uint256;\\n\\n    // ============ Constants ============\\n\\n    uint256 constant BASE = 10**18;\\n\\n    // ============ Structs ============\\n\\n    struct D256 {\\n        uint256 value;\\n    }\\n\\n    // ============ Functions ============\\n\\n    function one()\\n        internal\\n        pure\\n        returns (D256 memory)\\n    {\\n        return D256({ value: BASE });\\n    }\\n\\n    function onePlus(\\n        D256 memory d\\n    )\\n        internal\\n        pure\\n        returns (D256 memory)\\n    {\\n        return D256({ value: d.value.add(BASE) });\\n    }\\n\\n    function mul(\\n        uint256 target,\\n        D256 memory d\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return Math.getPartial(target, d.value, BASE);\\n    }\\n\\n    function mul(\\n        D256 memory d1,\\n        D256 memory d2\\n    )\\n        internal\\n        pure\\n        returns (D256 memory)\\n    {\\n        return Decimal.D256({ value: Math.getPartial(d1.value, d2.value, BASE) });\\n    }\\n\\n    function div(\\n        uint256 target,\\n        D256 memory d\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return Math.getPartial(target, BASE, d.value);\\n    }\\n\\n    function add(\\n        D256 memory d,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (D256 memory)\\n    {\\n        return D256({ value: d.value.add(amount) });\\n    }\\n\\n    function sub(\\n        D256 memory d,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (D256 memory)\\n    {\\n        return D256({ value: d.value.sub(amount) });\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"./contracts/lib/Adminable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport { Storage } from \\\"./Storage.sol\\\";\\n\\n/**\\n * @title Adminable\\n * @author dYdX\\n *\\n * @dev EIP-1967 Proxy Admin contract.\\n */\\ncontract Adminable {\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     *  This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    bytes32 internal constant ADMIN_SLOT =\\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n    * @dev Modifier to check whether the `msg.sender` is the admin.\\n    *  If it is, it will run the function. Otherwise, it will revert.\\n    */\\n    modifier onlyAdmin() {\\n        require(\\n            msg.sender == getAdmin(),\\n            \\\"Adminable: caller is not admin\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @return The EIP-1967 proxy admin\\n     */\\n    function getAdmin()\\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(Storage.load(ADMIN_SLOT))));\\n    }\\n}\"\r\n    },\r\n    \"./contracts/lib/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Storage {\\n\\n    /**\\n     * @dev Performs an SLOAD and returns the data in the slot.\\n     */\\n    function load(\\n        bytes32 slot\\n    )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32 result;\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            result := sload(slot)\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Performs an SSTORE to save the value to the slot.\\n     */\\n    function store(\\n        bytes32 slot,\\n        bytes32 value\\n    )\\n        internal\\n    {\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n}\"\r\n    },\r\n    \"./contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.5.16;\\n\\nimport {IERC20} from \\\"../token/IERC20.sol\\\";\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary SafeERC20 {\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        /* solium-disable-next-line */\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\n        );\\n\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"SafeERC20: APPROVE_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        /* solium-disable-next-line */\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\n        );\\n\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"SafeERC20: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        /* solium-disable-next-line */\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(\\n                0x23b872dd,\\n                from,\\n                to,\\n                value\\n            )\\n        );\\n\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"SafeERC20: TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/debt/mozart/MozartStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {IOracle} from \\\"../../oracle/IOracle.sol\\\";\\n\\nimport {Decimal} from \\\"../../lib/Decimal.sol\\\";\\nimport {Amount} from \\\"../../lib/Amount.sol\\\";\\n\\nimport {MozartTypes} from \\\"./MozartTypes.sol\\\";\\n\\n/**\\n * @title MoazartStorage\\n * @author Kerman Kohli\\n * @notice The storage contract that gets used inside MozartV1.\\n *         IMPORTANT:\\n *         - DO NOT change the order of ANY variables\\n *         - If you would like to add more variables, create a a new\\n *           versioned contract (MozartStorageV99) and inherit from\\n *           it via MozartStorage\\n */\\ncontract MozartStorageV1 {\\n\\n    /**\\n     * @notice Determines whether the contract is paused or not\\n     */\\n    bool public paused;\\n\\n    /**\\n     * @notice An active counter oall the number of positions in the protocol\\n     */\\n    uint256 public positionCount;\\n\\n    /**\\n     * @dev The details about a vault, identified by a unint256\\n     */\\n    mapping (uint256 => MozartTypes.Position) internal positions;\\n\\n    /**\\n     * @dev Allow a position have multiple addresses act on it's behalf\\n     */\\n    mapping (uint256 => mapping (address => bool)) internal positionOperators;\\n\\n    /**\\n     * @dev Allow an address to act on behalf of any position.\\n     */\\n    mapping (address => bool) internal globalOperators;\\n\\n    /**\\n     * @dev The instance of the oracle that reports prices for this synth\\n     */\\n    IOracle internal oracle;\\n\\n    /**\\n     * @dev If a colalteral asset is used that has less than 18 decimal places\\n     *      a precision scalar is required to calcualte the corect values.\\n     */\\n    uint256 internal precisionScalar;\\n\\n    /**\\n     * @dev The actual address of the collateral used for this core system.\\n     */\\n    address internal collateralAsset;\\n\\n    /**\\n     * @dev The address of the synthetic token where this core is approved to mint from\\n     */\\n    address internal syntheticAsset;\\n\\n    /**\\n     * @dev The actual amount of collateral provided to the protocol. This amount\\n     *      will be multiplied by the precision scalar if the token has less than 18 d.p\\n     */\\n    uint256 internal totalSupplied;\\n\\n    /**\\n     * @dev An account of the total amount being borrowed by all depositors. This includes\\n     *      the amount of interest accrued.\\n     */\\n    uint256 internal totalBorrowed;\\n\\n    /**\\n     * @dev The accumulated borrow index. Each time a borrows, their borrow amount is expressed\\n     *      in relation to the borrow index.\\n     */\\n    uint256 internal borrowIndex;\\n\\n    /**\\n     * @dev The last time the updateIndex() function was called. This helps to determine how much\\n     *      interest has accrued in the contract since a user interacted with the protocol.\\n     */\\n    uint256 internal indexLastUpdate;\\n\\n    /**\\n     * @dev The interest rate charged to borrowers. Expressed as the interest rate per second and 18 d.p\\n     */\\n    uint256 internal interestRate;\\n\\n    /**\\n     * @dev The ratio of how much collateral should have relative to it's debt\\n     */\\n    Decimal.D256 internal collateralRatio;\\n\\n    /**\\n     * @dev How much should the liquidation penalty be, expressed as a decimal.\\n     */\\n    Decimal.D256 internal liquidationUserFee;\\n\\n    /**\\n     * @dev How much of the profit acquired from a liquidation should ARC receive\\n     */\\n    Decimal.D256 internal liquidationArcRatio;\\n\\n    /**\\n     * @notice Which address can set interest rates for this contract\\n     */\\n    address public interestSetter;\\n\\n    /**\\n     * @dev The limit of how much collateral can be deposited from this contract.\\n     */\\n    uint256 internal collateralLimit;\\n\\n    /**\\n     * @dev The amount of collateral a new position should hvae at the minimum\\n     */\\n    uint256 internal positionCollateralMinimum;\\n}\\n\\ncontract MozartStorage is MozartStorageV1 { /* solium-disable-line no-empty-blocks */ }\\n\"\r\n    },\r\n    \"./contracts/debt/mozart/MozartTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from \\\"../../lib/SafeMath.sol\\\";\\nimport {Math} from \\\"../../lib/Math.sol\\\";\\nimport {Amount} from \\\"../../lib/Amount.sol\\\";\\n\\nlibrary MozartTypes {\\n\\n    /* ========== Structs ========== */\\n\\n    struct Position {\\n        address owner;\\n        Amount.Principal collateralAmount;\\n        Amount.Principal borrowedAmount;\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"operation\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOne\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTwo\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addressOne\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct MozartV1.OperationParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Amount.Principal\",\"name\":\"collateralAmount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Amount.Principal\",\"name\":\"borrowedAmount\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct MozartTypes.Position\",\"name\":\"updatedPosition\",\"type\":\"tuple\"}],\"name\":\"ActionOperated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Decimal.D256\",\"name\":\"value\",\"type\":\"tuple\"}],\"name\":\"CollateralRatioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"ExcessTokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Decimal.D256\",\"name\":\"_liquidationUserFee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Decimal.D256\",\"name\":\"_liquidationArcRatio\",\"type\":\"tuple\"}],\"name\":\"FeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"GlobalOperatorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"}],\"name\":\"IndexUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"InterestSetterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_collateralLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_positionCollateralMinimum\",\"type\":\"uint256\"}],\"name\":\"LimitsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"OracleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"PauseStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"PositionOperatorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"PrinterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RateUpdated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Amount.Principal\",\"name\":\"parSupply\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"borrowedAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"calculateCollateralDelta\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Amount.Principal\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowedAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"price\",\"type\":\"tuple\"}],\"name\":\"calculateCollateralRequired\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Amount.Principal\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateLiquidationPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBorrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateralAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateralRatio\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"_liquidationUserFee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"_liquidationArcRatio\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInterestSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Amount.Principal\",\"name\":\"collateralAmount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Amount.Principal\",\"name\":\"borrowedAmount\",\"type\":\"tuple\"}],\"internalType\":\"struct MozartTypes.Position\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSyntheticAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_collateralDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_collateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_syntheticAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_interestSetter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"_collateralRatio\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"_liquidationUserFee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"_liquidationArcRatio\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Amount.Principal\",\"name\":\"collateralAmount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Amount.Principal\",\"name\":\"borrowedAmount\",\"type\":\"tuple\"}],\"internalType\":\"struct MozartTypes.Position\",\"name\":\"position\",\"type\":\"tuple\"}],\"name\":\"isCollateralized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isGlobalOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isPositionOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum MozartV1.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOne\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTwo\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addressOne\",\"type\":\"address\"}],\"internalType\":\"struct MozartV1.OperationParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"operateAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"positionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"_collateralRatio\",\"type\":\"tuple\"}],\"name\":\"setCollateralRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"_liquidationUserFee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Decimal.D256\",\"name\":\"_liquidationArcRatio\",\"type\":\"tuple\"}],\"name\":\"setFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setGlobalOperatorStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setInterestRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_setter\",\"type\":\"address\"}],\"name\":\"setInterestSetter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_positionCollateralMinimum\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setPositionOperatorStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MozartV1","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}