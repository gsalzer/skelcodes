{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Arbrito.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\nimport \\\"./external/IBalancer.sol\\\";\\nimport \\\"./external/IUniswap.sol\\\";\\nimport \\\"./external/IERC20.sol\\\";\\n\\ncontract Arbrito is IUniswapPairCallee {\\n  enum Borrow { Token0, Token1 }\\n\\n  function perform(\\n    Borrow borrow,\\n    uint256 amount,\\n    address uniswapPair,\\n    address balancerPool,\\n    address uniswapToken0,\\n    address uniswapToken1,\\n    uint256 uniswapReserve0,\\n    uint256 uniswapReserve1,\\n    uint256 blockNumber\\n  ) external {\\n    require(block.number == blockNumber, \\\"Delayed execution\\\");\\n\\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapPair(uniswapPair).getReserves();\\n    require(reserve0 == uniswapReserve0, \\\"Reserve0 mismatch\\\");\\n    require(reserve1 == uniswapReserve1, \\\"Reserve1 mismatch\\\");\\n\\n    bytes memory payload =\\n      abi.encode(\\n        balancerPool,\\n        msg.sender,\\n        uniswapToken0,\\n        uniswapToken1,\\n        uniswapReserve0,\\n        uniswapReserve1\\n      );\\n\\n    if (borrow == Borrow.Token0) {\\n      IUniswapPair(uniswapPair).swap(amount, 0, address(this), payload);\\n    } else {\\n      IUniswapPair(uniswapPair).swap(0, amount, address(this), payload);\\n    }\\n  }\\n\\n  function uniswapV2Call(\\n    address, // sender\\n    uint256 amount0,\\n    uint256 amount1,\\n    bytes calldata data\\n  ) external override {\\n    (\\n      address balancerPoolAddress,\\n      address ownerAddress,\\n      address token0,\\n      address token1,\\n      uint256 reserve0,\\n      uint256 reserve1\\n    ) = abi.decode(data, (address, address, address, address, uint256, uint256));\\n\\n    uint256 amountTrade;\\n    uint256 amountPayback;\\n\\n    address tokenPayback;\\n    address tokenTrade;\\n\\n    if (amount0 != 0) {\\n      amountTrade = amount0;\\n      (tokenTrade, tokenPayback) = (token0, token1);\\n      amountPayback = calculateUniswapPayback(amountTrade, reserve1, reserve0);\\n    } else {\\n      amountTrade = amount1;\\n      (tokenPayback, tokenTrade) = (token0, token1);\\n      amountPayback = calculateUniswapPayback(amountTrade, reserve0, reserve1);\\n    }\\n\\n    IERC20(tokenTrade).approve(balancerPoolAddress, amountTrade);\\n\\n    (uint256 balancerAmountOut, ) =\\n      IBalancerPool(balancerPoolAddress).swapExactAmountIn(\\n        tokenTrade,\\n        amountTrade,\\n        tokenPayback,\\n        amountPayback,\\n        uint256(-1)\\n      );\\n\\n    require(IERC20(tokenPayback).transfer(msg.sender, amountPayback), \\\"Payback failed\\\");\\n\\n    require(\\n      IERC20(tokenPayback).transfer(ownerAddress, balancerAmountOut - amountPayback),\\n      \\\"Sender transfer failed\\\"\\n    );\\n  }\\n\\n  function calculateUniswapPayback(\\n    uint256 amountOut,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) internal pure returns (uint256) {\\n    uint256 numerator = reserveIn * amountOut * 1000;\\n    uint256 denominator = (reserveOut - amountOut) * 997;\\n    return numerator / denominator + 1;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external/IBalancer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\ninterface IBalancerPool {\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n}\\n\"\r\n    },\r\n    \"contracts/external/IUniswap.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\ninterface IUniswapPairCallee {\\n  function uniswapV2Call(\\n    address sender,\\n    uint256 amount0,\\n    uint256 amount1,\\n    bytes calldata data\\n  ) external;\\n}\\n\\ninterface IUniswapPair {\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function swap(\\n    uint256 amount0Out,\\n    uint256 amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/external/IERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\ninterface IERC20 {\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"test/external/Uniswap.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../contracts/external/IUniswap.sol\\\";\\n\\ncontract Uniswap is IUniswapPair {\\n  address token0address;\\n  address token1address;\\n  uint112 reserve0;\\n  uint112 reserve1;\\n\\n  constructor(address _token0, address _token1) {\\n    token0address = _token0;\\n    token1address = _token1;\\n  }\\n\\n  function getReserves()\\n    external\\n    view\\n    override\\n    returns (\\n      uint112,\\n      uint112,\\n      uint32\\n    )\\n  {\\n    return (reserve0, reserve1, 0);\\n  }\\n\\n  function refreshReserves() external {\\n    address me = address(this);\\n    reserve0 = uint112(IERC20(token0address).balanceOf(me));\\n    reserve1 = uint112(IERC20(token1address).balanceOf(me));\\n  }\\n\\n  function swap(\\n    uint256 amount0,\\n    uint256 amount1,\\n    address receiver,\\n    bytes calldata payload\\n  ) external override {\\n    require(payload.length != 0, \\\"Unsupported payload\\\");\\n    require(\\n      (amount0 == 0 && amount1 != 0) || (amount0 != 0 && amount1 == 0),\\n      \\\"Unsupported amounts\\\"\\n    );\\n\\n    IERC20 tokenLent;\\n    IERC20 tokenPayback;\\n    uint256 amountLent;\\n\\n    if (amount0 != 0) {\\n      tokenLent = IERC20(token0address);\\n      tokenPayback = IERC20(token1address);\\n      amountLent = amount0;\\n      require(IERC20(token0address).transfer(receiver, amount0), \\\"loan failed\\\");\\n    } else {\\n      tokenLent = IERC20(token1address);\\n      tokenPayback = IERC20(token0address);\\n      amountLent = amount1;\\n      require(IERC20(token1address).transfer(receiver, amount1), \\\"loan failed\\\");\\n    }\\n\\n    address me = address(this);\\n    uint256 tokenLentBalance = tokenLent.balanceOf(me);\\n    uint256 tokenPaybackBalance = tokenPayback.balanceOf(me);\\n\\n    IUniswapPairCallee(msg.sender).uniswapV2Call(msg.sender, amount0, amount1, payload);\\n\\n    reserve0 -= uint112(amount0);\\n    reserve1 -= uint112(amount1);\\n\\n    require(tokenLent.balanceOf(me) == tokenLentBalance, \\\"unsupported payback\\\");\\n\\n    uint256 tokenPaybackBalanceAfter = tokenPayback.balanceOf(me);\\n    require(tokenPaybackBalanceAfter > tokenPaybackBalance, \\\"missing payback\\\");\\n\\n    uint256 amountPaidBack = tokenPaybackBalanceAfter - tokenPaybackBalance;\\n    uint256 balance0Adjusted = tokenPaybackBalanceAfter * 1000 - amountPaidBack * 3;\\n    uint256 balance1Adjusted = tokenLentBalance;\\n    require(\\n      balance0Adjusted * balance1Adjusted >=\\n        (tokenLentBalance + amountLent) * tokenPaybackBalance * 1000,\\n      \\\"payback mismatch\\\"\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"test/external/IERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\ninterface IERC20 {\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\\ncontract ERC20 is IERC20 {\\n  mapping(address => uint256) balances;\\n  mapping(address => mapping(address => uint256)) allowances;\\n\\n  function balanceOf(address account) external view override returns (uint256) {\\n    return balances[account];\\n  }\\n\\n  function transfer(address recipient, uint256 amount) external override returns (bool) {\\n    if (balances[msg.sender] < amount) {\\n      return false;\\n    }\\n\\n    balances[msg.sender] -= amount;\\n    balances[recipient] += amount;\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external override returns (bool) {\\n    require(allowances[sender][msg.sender] >= amount, \\\"No allowance\\\");\\n    allowances[sender][msg.sender] -= amount;\\n\\n    if (balances[sender] < amount) {\\n      return false;\\n    }\\n\\n    balances[sender] -= amount;\\n    balances[recipient] += amount;\\n    return true;\\n  }\\n\\n  function allowance(address owner, address spender) external view override returns (uint256) {\\n    return allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount) external override returns (bool) {\\n    allowances[msg.sender][spender] = amount;\\n    return true;\\n  }\\n}\\n\\ncontract ERC20Mintable is ERC20 {\\n  function mint(address account, uint256 amount) external {\\n    balances[account] += amount;\\n  }\\n}\\n\"\r\n    },\r\n    \"test/external/Balancer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../contracts/external/IBalancer.sol\\\";\\n\\ncontract Balancer is IBalancerPool {\\n  function swapExactAmountIn(\\n    address _tokenIn,\\n    uint256 _tokenAmountIn,\\n    address _tokenOut,\\n    uint256 _minAmountOut,\\n    uint256 _maxPrice\\n  ) external override returns (uint256, uint256) {\\n    require(_maxPrice == uint256(-1), \\\"Unsupported maxPrice\\\");\\n\\n    address me = address(this);\\n    IERC20 tokenIn = IERC20(_tokenIn);\\n    IERC20 tokenOut = IERC20(_tokenOut);\\n\\n    uint256 tokenAmountOut = (10**18 * tokenOut.balanceOf(me) * _tokenAmountIn);\\n    tokenAmountOut /= (10**18 * tokenIn.balanceOf(me));\\n\\n    require(tokenAmountOut > _minAmountOut, \\\"Insufficient amount out\\\");\\n\\n    require(tokenIn.transferFrom(msg.sender, me, _tokenAmountIn), \\\"Transfer in failed\\\");\\n\\n    require(tokenOut.transfer(msg.sender, tokenAmountOut), \\\"Transfer out failed\\\");\\n\\n    return (tokenAmountOut, 0);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"enum Arbrito.Borrow\",\"name\":\"borrow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapPair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balancerPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapToken0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapToken1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uniswapReserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uniswapReserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"perform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Arbrito","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}