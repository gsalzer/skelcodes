{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualPoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport './PerpetualLiquidatablePoolParty.sol';\\n\\ncontract PerpetualPoolParty is PerpetualLiquidatablePoolParty {\\n  constructor(ConstructorParams memory params)\\n    public\\n    PerpetualLiquidatablePoolParty(params)\\n  {}\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualLiquidatablePoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport './PerpetualPositionManagerPoolParty.sol';\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './PerpetualPositionManagerPoolPartyLib.sol';\\nimport './PerpetualLiquidatablePoolPartyLib.sol';\\n\\ncontract PerpetualLiquidatablePoolParty is PerpetualPositionManagerPoolParty {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using PerpetualLiquidatablePoolPartyLib for PerpetualPositionManagerPoolParty.PositionData;\\n  using PerpetualLiquidatablePoolPartyLib for LiquidationData;\\n\\n  enum Status {\\n    Uninitialized,\\n    PreDispute,\\n    PendingDispute,\\n    DisputeSucceeded,\\n    DisputeFailed\\n  }\\n\\n  struct LiquidatableParams {\\n    uint256 liquidationLiveness;\\n    FixedPoint.Unsigned collateralRequirement;\\n    FixedPoint.Unsigned disputeBondPct;\\n    FixedPoint.Unsigned sponsorDisputeRewardPct;\\n    FixedPoint.Unsigned disputerDisputeRewardPct;\\n  }\\n\\n  struct LiquidationData {\\n    address sponsor;\\n    address liquidator;\\n    Status state;\\n    uint256 liquidationTime;\\n    FixedPoint.Unsigned tokensOutstanding;\\n    FixedPoint.Unsigned lockedCollateral;\\n    FixedPoint.Unsigned liquidatedCollateral;\\n    FixedPoint.Unsigned rawUnitCollateral;\\n    address disputer;\\n    FixedPoint.Unsigned settlementPrice;\\n    FixedPoint.Unsigned finalFee;\\n  }\\n\\n  struct ConstructorParams {\\n    PerpetualPositionManagerPoolParty.PositionManagerParams positionManagerParams;\\n    PerpetualPositionManagerPoolParty.Roles roles;\\n    LiquidatableParams liquidatableParams;\\n  }\\n\\n  struct LiquidatableData {\\n    FixedPoint.Unsigned rawLiquidationCollateral;\\n    uint256 liquidationLiveness;\\n    FixedPoint.Unsigned collateralRequirement;\\n    FixedPoint.Unsigned disputeBondPct;\\n    FixedPoint.Unsigned sponsorDisputeRewardPct;\\n    FixedPoint.Unsigned disputerDisputeRewardPct;\\n  }\\n\\n  struct RewardsData {\\n    FixedPoint.Unsigned payToSponsor;\\n    FixedPoint.Unsigned payToLiquidator;\\n    FixedPoint.Unsigned payToDisputer;\\n    FixedPoint.Unsigned paidToSponsor;\\n    FixedPoint.Unsigned paidToLiquidator;\\n    FixedPoint.Unsigned paidToDisputer;\\n  }\\n\\n  mapping(address => LiquidationData[]) public liquidations;\\n\\n  LiquidatableData public liquidatableData;\\n\\n  event LiquidationCreated(\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    uint256 indexed liquidationId,\\n    uint256 tokensOutstanding,\\n    uint256 lockedCollateral,\\n    uint256 liquidatedCollateral,\\n    uint256 liquidationTime\\n  );\\n  event LiquidationDisputed(\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    address indexed disputer,\\n    uint256 liquidationId,\\n    uint256 disputeBondAmount\\n  );\\n  event DisputeSettled(\\n    address indexed caller,\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    address disputer,\\n    uint256 liquidationId,\\n    bool disputeSucceeded\\n  );\\n  event LiquidationWithdrawn(\\n    address indexed caller,\\n    uint256 paidToLiquidator,\\n    uint256 paidToDisputer,\\n    uint256 paidToSponsor,\\n    Status indexed liquidationStatus,\\n    uint256 settlementPrice\\n  );\\n\\n  modifier disputable(uint256 liquidationId, address sponsor) {\\n    _disputable(liquidationId, sponsor);\\n    _;\\n  }\\n\\n  modifier withdrawable(uint256 liquidationId, address sponsor) {\\n    _withdrawable(liquidationId, sponsor);\\n    _;\\n  }\\n\\n  constructor(ConstructorParams memory params)\\n    public\\n    PerpetualPositionManagerPoolParty(\\n      params.positionManagerParams,\\n      params.roles\\n    )\\n  {\\n    require(\\n      params.liquidatableParams.collateralRequirement.isGreaterThan(1),\\n      'CR is more than 100%'\\n    );\\n    require(\\n      params\\n        .liquidatableParams\\n        .sponsorDisputeRewardPct\\n        .add(params.liquidatableParams.disputerDisputeRewardPct)\\n        .isLessThan(1),\\n      'Rewards are more than 100%'\\n    );\\n\\n    liquidatableData.liquidationLiveness = params\\n      .liquidatableParams\\n      .liquidationLiveness;\\n    liquidatableData.collateralRequirement = params\\n      .liquidatableParams\\n      .collateralRequirement;\\n    liquidatableData.disputeBondPct = params.liquidatableParams.disputeBondPct;\\n    liquidatableData.sponsorDisputeRewardPct = params\\n      .liquidatableParams\\n      .sponsorDisputeRewardPct;\\n    liquidatableData.disputerDisputeRewardPct = params\\n      .liquidatableParams\\n      .disputerDisputeRewardPct;\\n  }\\n\\n  function createLiquidation(\\n    address sponsor,\\n    FixedPoint.Unsigned calldata minCollateralPerToken,\\n    FixedPoint.Unsigned calldata maxCollateralPerToken,\\n    FixedPoint.Unsigned calldata maxTokensToLiquidate,\\n    uint256 deadline\\n  )\\n    external\\n    fees()\\n    notEmergencyShutdown()\\n    nonReentrant()\\n    returns (\\n      uint256 liquidationId,\\n      FixedPoint.Unsigned memory tokensLiquidated,\\n      FixedPoint.Unsigned memory finalFeeBond\\n    )\\n  {\\n    PositionData storage positionToLiquidate = _getPositionData(sponsor);\\n\\n    LiquidationData[] storage TokenSponsorLiquidations = liquidations[sponsor];\\n\\n    FixedPoint.Unsigned memory finalFee = _computeFinalFees();\\n\\n    uint256 actualTime = getCurrentTime();\\n\\n    PerpetualLiquidatablePoolPartyLib.CreateLiquidationParams memory params =\\n      PerpetualLiquidatablePoolPartyLib.CreateLiquidationParams(\\n        minCollateralPerToken,\\n        maxCollateralPerToken,\\n        maxTokensToLiquidate,\\n        actualTime,\\n        deadline,\\n        finalFee,\\n        sponsor\\n      );\\n\\n\\n      PerpetualLiquidatablePoolPartyLib.CreateLiquidationReturnParams\\n        memory returnValues\\n    ;\\n\\n    returnValues = positionToLiquidate.createLiquidation(\\n      globalPositionData,\\n      positionManagerData,\\n      liquidatableData,\\n      TokenSponsorLiquidations,\\n      params,\\n      feePayerData\\n    );\\n\\n    return (\\n      returnValues.liquidationId,\\n      returnValues.tokensLiquidated,\\n      returnValues.finalFeeBond\\n    );\\n  }\\n\\n  function dispute(uint256 liquidationId, address sponsor)\\n    external\\n    disputable(liquidationId, sponsor)\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory totalPaid)\\n  {\\n    LiquidationData storage disputedLiquidation =\\n      _getLiquidationData(sponsor, liquidationId);\\n\\n    totalPaid = disputedLiquidation.dispute(\\n      liquidatableData,\\n      positionManagerData,\\n      feePayerData,\\n      liquidationId,\\n      sponsor\\n    );\\n  }\\n\\n  function withdrawLiquidation(uint256 liquidationId, address sponsor)\\n    public\\n    withdrawable(liquidationId, sponsor)\\n    fees()\\n    nonReentrant()\\n    returns (RewardsData memory)\\n  {\\n    LiquidationData storage liquidation =\\n      _getLiquidationData(sponsor, liquidationId);\\n\\n    RewardsData memory rewardsData =\\n      liquidation.withdrawLiquidation(\\n        liquidatableData,\\n        positionManagerData,\\n        feePayerData,\\n        liquidationId,\\n        sponsor\\n      );\\n\\n    return rewardsData;\\n  }\\n\\n  function deleteLiquidation(uint256 liquidationId, address sponsor)\\n    external\\n    onlyThisContract\\n  {\\n    delete liquidations[sponsor][liquidationId];\\n  }\\n\\n  function _pfc() internal view override returns (FixedPoint.Unsigned memory) {\\n    return\\n      super._pfc().add(\\n        liquidatableData.rawLiquidationCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      );\\n  }\\n\\n  function _getLiquidationData(address sponsor, uint256 liquidationId)\\n    internal\\n    view\\n    returns (LiquidationData storage liquidation)\\n  {\\n    LiquidationData[] storage liquidationArray = liquidations[sponsor];\\n\\n    require(\\n      liquidationId < liquidationArray.length &&\\n        liquidationArray[liquidationId].state != Status.Uninitialized,\\n      'Invalid liquidation ID'\\n    );\\n    return liquidationArray[liquidationId];\\n  }\\n\\n  function _getLiquidationExpiry(LiquidationData storage liquidation)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return\\n      liquidation.liquidationTime.add(liquidatableData.liquidationLiveness);\\n  }\\n\\n  function _disputable(uint256 liquidationId, address sponsor) internal view {\\n    LiquidationData storage liquidation =\\n      _getLiquidationData(sponsor, liquidationId);\\n    require(\\n      (getCurrentTime() < _getLiquidationExpiry(liquidation)) &&\\n        (liquidation.state == Status.PreDispute),\\n      'Liquidation not disputable'\\n    );\\n  }\\n\\n  function _withdrawable(uint256 liquidationId, address sponsor) internal view {\\n    LiquidationData storage liquidation =\\n      _getLiquidationData(sponsor, liquidationId);\\n    Status state = liquidation.state;\\n\\n    require(\\n      (state > Status.PreDispute) ||\\n        ((_getLiquidationExpiry(liquidation) <= getCurrentTime()) &&\\n          (state == Status.PreDispute)),\\n      'Liquidation not withdrawable'\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport './IERC20.sol';\\nimport '../../math/SafeMath.sol';\\nimport '../../utils/Address.sol';\\n\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n    );\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, value)\\n    );\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance =\\n      token.allowance(address(this), spender).sub(\\n        value,\\n        'SafeERC20: decreased allowance below zero'\\n      );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    bytes memory returndata =\\n      address(token).functionCall(data, 'SafeERC20: low-level call failed');\\n    if (returndata.length > 0) {\\n      require(\\n        abi.decode(returndata, (bool)),\\n        'SafeERC20: ERC20 operation did not succeed'\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualPositionManagerPoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/interfaces/MintableBurnableIERC20.sol';\\nimport './PerpetualPositionManagerPoolPartyLib.sol';\\n\\nimport '../../oracle/interfaces/OracleInterface.sol';\\nimport '../../oracle/interfaces/IdentifierWhitelistInterface.sol';\\nimport '../../oracle/interfaces/AdministrateeInterface.sol';\\nimport '../../oracle/implementation/Constants.sol';\\n\\nimport '../common/FeePayerPoolParty.sol';\\nimport '../../../../../@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract PerpetualPositionManagerPoolParty is AccessControl, FeePayerPoolParty {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for MintableBurnableIERC20;\\n  using PerpetualPositionManagerPoolPartyLib for PositionData;\\n  using PerpetualPositionManagerPoolPartyLib for PositionManagerData;\\n\\n  bytes32 public constant POOL_ROLE = keccak256('Pool');\\n\\n  struct Roles {\\n    address[] admins;\\n    address[] pools;\\n  }\\n\\n  struct PositionManagerParams {\\n    uint256 withdrawalLiveness;\\n    address collateralAddress;\\n    address tokenAddress;\\n    address finderAddress;\\n    bytes32 priceFeedIdentifier;\\n    FixedPoint.Unsigned minSponsorTokens;\\n    address timerAddress;\\n    address excessTokenBeneficiary;\\n  }\\n\\n  struct PositionData {\\n    FixedPoint.Unsigned tokensOutstanding;\\n    uint256 withdrawalRequestPassTimestamp;\\n    FixedPoint.Unsigned withdrawalRequestAmount;\\n    FixedPoint.Unsigned rawCollateral;\\n  }\\n\\n  struct GlobalPositionData {\\n    FixedPoint.Unsigned totalTokensOutstanding;\\n    FixedPoint.Unsigned rawTotalPositionCollateral;\\n  }\\n\\n  struct PositionManagerData {\\n    MintableBurnableIERC20 tokenCurrency;\\n    bytes32 priceIdentifier;\\n    uint256 withdrawalLiveness;\\n    FixedPoint.Unsigned minSponsorTokens;\\n    FixedPoint.Unsigned emergencyShutdownPrice;\\n    uint256 emergencyShutdownTimestamp;\\n    address excessTokenBeneficiary;\\n  }\\n\\n  mapping(address => PositionData) public positions;\\n\\n  GlobalPositionData public globalPositionData;\\n\\n  PositionManagerData public positionManagerData;\\n\\n  event Deposit(address indexed sponsor, uint256 indexed collateralAmount);\\n  event Withdrawal(address indexed sponsor, uint256 indexed collateralAmount);\\n  event RequestWithdrawal(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalExecuted(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalCanceled(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event PositionCreated(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event NewSponsor(address indexed sponsor);\\n  event EndedSponsorPosition(address indexed sponsor);\\n  event Redeem(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event Repay(\\n    address indexed sponsor,\\n    uint256 indexed numTokensRepaid,\\n    uint256 indexed newTokenCount\\n  );\\n  event EmergencyShutdown(address indexed caller, uint256 shutdownTimestamp);\\n  event SettleEmergencyShutdown(\\n    address indexed caller,\\n    uint256 indexed collateralReturned,\\n    uint256 indexed tokensBurned\\n  );\\n\\n  modifier onlyPool() {\\n    require(hasRole(POOL_ROLE, msg.sender), 'Sender must be a pool');\\n    _;\\n  }\\n\\n  modifier onlyCollateralizedPosition(address sponsor) {\\n    _onlyCollateralizedPosition(sponsor);\\n    _;\\n  }\\n\\n  modifier notEmergencyShutdown() {\\n    _notEmergencyShutdown();\\n    _;\\n  }\\n\\n  modifier isEmergencyShutdown() {\\n    _isEmergencyShutdown();\\n    _;\\n  }\\n\\n  modifier noPendingWithdrawal(address sponsor) {\\n    _positionHasNoPendingWithdrawal(sponsor);\\n    _;\\n  }\\n\\n  constructor(\\n    PositionManagerParams memory _positionManagerData,\\n    Roles memory _roles\\n  )\\n    public\\n    FeePayerPoolParty(\\n      _positionManagerData.collateralAddress,\\n      _positionManagerData.finderAddress,\\n      _positionManagerData.timerAddress\\n    )\\n    nonReentrant()\\n  {\\n    require(\\n      _getIdentifierWhitelist().isIdentifierSupported(\\n        _positionManagerData.priceFeedIdentifier\\n      ),\\n      'Unsupported price identifier'\\n    );\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(POOL_ROLE, DEFAULT_ADMIN_ROLE);\\n    for (uint256 j = 0; j < _roles.admins.length; j++) {\\n      _setupRole(DEFAULT_ADMIN_ROLE, _roles.admins[j]);\\n    }\\n    for (uint256 j = 0; j < _roles.pools.length; j++) {\\n      _setupRole(POOL_ROLE, _roles.pools[j]);\\n    }\\n    positionManagerData.withdrawalLiveness = _positionManagerData\\n      .withdrawalLiveness;\\n    positionManagerData.tokenCurrency = MintableBurnableIERC20(\\n      _positionManagerData.tokenAddress\\n    );\\n    positionManagerData.minSponsorTokens = _positionManagerData\\n      .minSponsorTokens;\\n    positionManagerData.priceIdentifier = _positionManagerData\\n      .priceFeedIdentifier;\\n    positionManagerData.excessTokenBeneficiary = _positionManagerData\\n      .excessTokenBeneficiary;\\n  }\\n\\n  function depositTo(\\n    address sponsor,\\n    FixedPoint.Unsigned memory collateralAmount\\n  )\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(sponsor)\\n    fees()\\n    nonReentrant()\\n  {\\n    PositionData storage positionData = _getPositionData(sponsor);\\n\\n    positionData.depositTo(\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData,\\n      sponsor\\n    );\\n  }\\n\\n  function deposit(FixedPoint.Unsigned memory collateralAmount) public {\\n    depositTo(msg.sender, collateralAmount);\\n  }\\n\\n  function withdraw(FixedPoint.Unsigned memory collateralAmount)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n\\n    amountWithdrawn = positionData.withdraw(\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n  }\\n\\n  function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    nonReentrant()\\n  {\\n    uint256 actualTime = getCurrentTime();\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    positionData.requestWithdrawal(\\n      positionManagerData,\\n      collateralAmount,\\n      actualTime,\\n      feePayerData\\n    );\\n  }\\n\\n  function withdrawPassedRequest()\\n    external\\n    onlyPool()\\n    notEmergencyShutdown()\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    uint256 actualTime = getCurrentTime();\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    amountWithdrawn = positionData.withdrawPassedRequest(\\n      globalPositionData,\\n      actualTime,\\n      feePayerData\\n    );\\n  }\\n\\n  function cancelWithdrawal()\\n    external\\n    onlyPool()\\n    notEmergencyShutdown()\\n    nonReentrant()\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    positionData.cancelWithdrawal();\\n  }\\n\\n  function create(\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) public onlyPool() notEmergencyShutdown() fees() nonReentrant() {\\n    PositionData storage positionData = positions[msg.sender];\\n\\n    positionData.create(\\n      globalPositionData,\\n      positionManagerData,\\n      collateralAmount,\\n      numTokens,\\n      feePayerData\\n    );\\n  }\\n\\n  function redeem(FixedPoint.Unsigned memory numTokens)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n\\n    amountWithdrawn = positionData.redeeem(\\n      globalPositionData,\\n      positionManagerData,\\n      numTokens,\\n      feePayerData,\\n      msg.sender\\n    );\\n  }\\n\\n  function repay(FixedPoint.Unsigned memory numTokens)\\n    public\\n    onlyPool()\\n    notEmergencyShutdown()\\n    noPendingWithdrawal(msg.sender)\\n    fees()\\n    nonReentrant()\\n  {\\n    PositionData storage positionData = _getPositionData(msg.sender);\\n    positionData.repay(globalPositionData, positionManagerData, numTokens);\\n  }\\n\\n  function settleEmergencyShutdown()\\n    external\\n    onlyPool()\\n    isEmergencyShutdown()\\n    fees()\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\\n  {\\n    PositionData storage positionData = positions[msg.sender];\\n    amountWithdrawn = positionData.settleEmergencyShutdown(\\n      globalPositionData,\\n      positionManagerData,\\n      feePayerData\\n    );\\n  }\\n\\n  function emergencyShutdown()\\n    external\\n    override\\n    notEmergencyShutdown()\\n    nonReentrant()\\n  {\\n    require(\\n      hasRole(POOL_ROLE, msg.sender) ||\\n        msg.sender == _getFinancialContractsAdminAddress(),\\n      'Caller must be a pool or the UMA governor'\\n    );\\n    positionManagerData.emergencyShutdownTimestamp = getCurrentTime();\\n    positionManagerData.requestOraclePrice(\\n      positionManagerData.emergencyShutdownTimestamp,\\n      feePayerData\\n    );\\n    emit EmergencyShutdown(\\n      msg.sender,\\n      positionManagerData.emergencyShutdownTimestamp\\n    );\\n  }\\n\\n  function remargin() external override {\\n    return;\\n  }\\n\\n  function trimExcess(IERC20 token)\\n    external\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory amount)\\n  {\\n    FixedPoint.Unsigned memory pfcAmount = _pfc();\\n    amount = positionManagerData.trimExcess(token, pfcAmount, feePayerData);\\n  }\\n\\n  function deleteSponsorPosition(address sponsor) external onlyThisContract {\\n    delete positions[sponsor];\\n  }\\n\\n  function addPool(address pool) external {\\n    grantRole(POOL_ROLE, pool);\\n  }\\n\\n  function addAdmin(address admin) external {\\n    grantRole(DEFAULT_ADMIN_ROLE, admin);\\n  }\\n\\n  function addAdminAndPool(address adminAndPool) external {\\n    grantRole(DEFAULT_ADMIN_ROLE, adminAndPool);\\n    grantRole(POOL_ROLE, adminAndPool);\\n  }\\n\\n  function renouncePool() external {\\n    renounceRole(POOL_ROLE, msg.sender);\\n  }\\n\\n  function renounceAdmin() external {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n  }\\n\\n  function renounceAdminAndPool() external {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    renounceRole(POOL_ROLE, msg.sender);\\n  }\\n\\n  function addSyntheticTokenMinter(address derivative) external onlyPool() {\\n    positionManagerData.tokenCurrency.addMinter(derivative);\\n  }\\n\\n  function addSyntheticTokenBurner(address derivative) external onlyPool() {\\n    positionManagerData.tokenCurrency.addBurner(derivative);\\n  }\\n\\n  function addSyntheticTokenAdmin(address derivative) external onlyPool() {\\n    positionManagerData.tokenCurrency.addAdmin(derivative);\\n  }\\n\\n  function addSyntheticTokenAdminAndMinterAndBurner(address derivative)\\n    external\\n    onlyPool()\\n  {\\n    positionManagerData.tokenCurrency.addAdminAndMinterAndBurner(derivative);\\n  }\\n\\n  function renounceSyntheticTokenMinter() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceMinter();\\n  }\\n\\n  function renounceSyntheticTokenBurner() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceBurner();\\n  }\\n\\n  function renounceSyntheticTokenAdmin() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceAdmin();\\n  }\\n\\n  function renounceSyntheticTokenAdminAndMinterAndBurner() external onlyPool() {\\n    positionManagerData.tokenCurrency.renounceAdminAndMinterAndBurner();\\n  }\\n\\n  function getCollateral(address sponsor)\\n    external\\n    view\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory collateralAmount)\\n  {\\n    return\\n      positions[sponsor].rawCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function tokenCurrency() external view nonReentrantView() returns (IERC20) {\\n    return positionManagerData.tokenCurrency;\\n  }\\n\\n  function totalPositionCollateral()\\n    external\\n    view\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory totalCollateral)\\n  {\\n    return\\n      globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function emergencyShutdownPrice()\\n    external\\n    view\\n    isEmergencyShutdown()\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return positionManagerData.emergencyShutdownPrice;\\n  }\\n\\n  function getAdminMembers() external view returns (address[] memory) {\\n    uint256 numberOfMembers = getRoleMemberCount(DEFAULT_ADMIN_ROLE);\\n    address[] memory members = new address[](numberOfMembers);\\n    for (uint256 j = 0; j < numberOfMembers; j++) {\\n      address newMember = getRoleMember(DEFAULT_ADMIN_ROLE, j);\\n      members[j] = newMember;\\n    }\\n    return members;\\n  }\\n\\n  function getPoolMembers() external view returns (address[] memory) {\\n    uint256 numberOfMembers = getRoleMemberCount(POOL_ROLE);\\n    address[] memory members = new address[](numberOfMembers);\\n    for (uint256 j = 0; j < numberOfMembers; j++) {\\n      address newMember = getRoleMember(POOL_ROLE, j);\\n      members[j] = newMember;\\n    }\\n    return members;\\n  }\\n\\n  function _pfc()\\n    internal\\n    view\\n    virtual\\n    override\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return\\n      globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _getPositionData(address sponsor)\\n    internal\\n    view\\n    onlyCollateralizedPosition(sponsor)\\n    returns (PositionData storage)\\n  {\\n    return positions[sponsor];\\n  }\\n\\n  function _getIdentifierWhitelist()\\n    internal\\n    view\\n    returns (IdentifierWhitelistInterface)\\n  {\\n    return\\n      IdentifierWhitelistInterface(\\n        feePayerData.finder.getImplementationAddress(\\n          OracleInterfaces.IdentifierWhitelist\\n        )\\n      );\\n  }\\n\\n  function _onlyCollateralizedPosition(address sponsor) internal view {\\n    require(\\n      positions[sponsor]\\n        .rawCollateral\\n        .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n        .isGreaterThan(0),\\n      'Position has no collateral'\\n    );\\n  }\\n\\n  function _notEmergencyShutdown() internal view {\\n    require(\\n      positionManagerData.emergencyShutdownTimestamp == 0,\\n      'Contract emergency shutdown'\\n    );\\n  }\\n\\n  function _isEmergencyShutdown() internal view {\\n    require(\\n      positionManagerData.emergencyShutdownTimestamp != 0,\\n      'Contract not emergency shutdown'\\n    );\\n  }\\n\\n  function _positionHasNoPendingWithdrawal(address sponsor) internal view {\\n    require(\\n      _getPositionData(sponsor).withdrawalRequestPassTimestamp == 0,\\n      'Pending withdrawal'\\n    );\\n  }\\n\\n  function _getFinancialContractsAdminAddress()\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return\\n      feePayerData.finder.getImplementationAddress(\\n        OracleInterfaces.FinancialContractsAdmin\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/math/SignedSafeMath.sol';\\n\\nlibrary FixedPoint {\\n  using SafeMath for uint256;\\n  using SignedSafeMath for int256;\\n\\n  uint256 private constant FP_SCALING_FACTOR = 10**18;\\n\\n  struct Unsigned {\\n    uint256 rawValue;\\n  }\\n\\n  function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.mul(FP_SCALING_FACTOR));\\n  }\\n\\n  function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  function isGreaterThan(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThan(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isGreaterThan(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue >= b.rawValue;\\n  }\\n\\n  function isLessThan(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  function isLessThan(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isLessThan(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue < b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isLessThanOrEqual(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue <= b.rawValue;\\n  }\\n\\n  function min(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  function max(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  function add(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.add(b.rawValue));\\n  }\\n\\n  function add(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return add(a, fromUnscaledUint(b));\\n  }\\n\\n  function sub(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  function sub(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return sub(a, fromUnscaledUint(b));\\n  }\\n\\n  function sub(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return sub(fromUnscaledUint(a), b);\\n  }\\n\\n  function mul(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\n  }\\n\\n  function mul(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  function mulCeil(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    uint256 mulRaw = a.rawValue.mul(b.rawValue);\\n    uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\n    uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\n    if (mod != 0) {\\n      return Unsigned(mulFloor.add(1));\\n    } else {\\n      return Unsigned(mulFloor);\\n    }\\n  }\\n\\n  function mulCeil(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  function div(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  function div(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.div(b));\\n  }\\n\\n  function div(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return div(fromUnscaledUint(a), b);\\n  }\\n\\n  function divCeil(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\n    uint256 divFloor = aScaled.div(b.rawValue);\\n    uint256 mod = aScaled.mod(b.rawValue);\\n    if (mod != 0) {\\n      return Unsigned(divFloor.add(1));\\n    } else {\\n      return Unsigned(divFloor);\\n    }\\n  }\\n\\n  function divCeil(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return divCeil(a, fromUnscaledUint(b));\\n  }\\n\\n  function pow(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory output)\\n  {\\n    output = fromUnscaledUint(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n\\n  int256 private constant SFP_SCALING_FACTOR = 10**18;\\n\\n  struct Signed {\\n    int256 rawValue;\\n  }\\n\\n  function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\n    require(a.rawValue >= 0, 'Negative value provided');\\n    return Unsigned(uint256(a.rawValue));\\n  }\\n\\n  function fromUnsigned(Unsigned memory a)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    require(a.rawValue <= uint256(type(int256).max), 'Unsigned too large');\\n    return Signed(int256(a.rawValue));\\n  }\\n\\n  function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\n    return Signed(a.mul(SFP_SCALING_FACTOR));\\n  }\\n\\n  function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  function isGreaterThan(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThan(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isGreaterThan(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue >= b.rawValue;\\n  }\\n\\n  function isLessThan(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue < fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue < b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isLessThanOrEqual(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue <= b.rawValue;\\n  }\\n\\n  function min(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  function max(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  function add(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.add(b.rawValue));\\n  }\\n\\n  function add(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return add(a, fromUnscaledInt(b));\\n  }\\n\\n  function sub(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  function sub(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return sub(a, fromUnscaledInt(b));\\n  }\\n\\n  function sub(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return sub(fromUnscaledInt(a), b);\\n  }\\n\\n  function mul(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\n  }\\n\\n  function mul(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  function mulAwayFromZero(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    int256 mulRaw = a.rawValue.mul(b.rawValue);\\n    int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\n\\n    int256 mod = mulRaw % SFP_SCALING_FACTOR;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(mulTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(mulTowardsZero);\\n    }\\n  }\\n\\n  function mulAwayFromZero(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  function div(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  function div(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.div(b));\\n  }\\n\\n  function div(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return div(fromUnscaledInt(a), b);\\n  }\\n\\n  function divAwayFromZero(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\n    int256 divTowardsZero = aScaled.div(b.rawValue);\\n\\n    int256 mod = aScaled % b.rawValue;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(divTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(divTowardsZero);\\n    }\\n  }\\n\\n  function divAwayFromZero(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return divAwayFromZero(a, fromUnscaledInt(b));\\n  }\\n\\n  function pow(Signed memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Signed memory output)\\n  {\\n    output = fromUnscaledInt(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualPositionManagerPoolPartyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '../../common/interfaces/IERC20Standard.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\nimport '../../common/interfaces/MintableBurnableIERC20.sol';\\nimport '../../oracle/interfaces/OracleInterface.sol';\\nimport '../../oracle/implementation/Constants.sol';\\nimport './PerpetualPositionManagerPoolParty.sol';\\nimport '../common/FeePayerPoolPartyLib.sol';\\n\\nlibrary PerpetualPositionManagerPoolPartyLib {\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for MintableBurnableIERC20;\\n  using PerpetualPositionManagerPoolPartyLib for PerpetualPositionManagerPoolParty.PositionData;\\n  using PerpetualPositionManagerPoolPartyLib for PerpetualPositionManagerPoolParty.PositionManagerData;\\n  using PerpetualPositionManagerPoolPartyLib for FeePayerPoolParty.FeePayerData;\\n  using PerpetualPositionManagerPoolPartyLib for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n\\n  event Deposit(address indexed sponsor, uint256 indexed collateralAmount);\\n  event Withdrawal(address indexed sponsor, uint256 indexed collateralAmount);\\n  event RequestWithdrawal(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalExecuted(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event RequestWithdrawalCanceled(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount\\n  );\\n  event PositionCreated(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event NewSponsor(address indexed sponsor);\\n  event EndedSponsorPosition(address indexed sponsor);\\n  event Redeem(\\n    address indexed sponsor,\\n    uint256 indexed collateralAmount,\\n    uint256 indexed tokenAmount\\n  );\\n  event Repay(\\n    address indexed sponsor,\\n    uint256 indexed numTokensRepaid,\\n    uint256 indexed newTokenCount\\n  );\\n  event EmergencyShutdown(address indexed caller, uint256 shutdownTimestamp);\\n  event SettleEmergencyShutdown(\\n    address indexed caller,\\n    uint256 indexed collateralReturned,\\n    uint256 indexed tokensBurned\\n  );\\n\\n  function depositTo(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) external {\\n    require(collateralAmount.isGreaterThan(0), 'Invalid collateral amount');\\n\\n    positionData._incrementCollateralBalances(\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n\\n    emit Deposit(sponsor, collateralAmount.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      collateralAmount.rawValue\\n    );\\n  }\\n\\n  function withdraw(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    require(collateralAmount.isGreaterThan(0), 'Invalid collateral amount');\\n\\n    amountWithdrawn = _decrementCollateralBalancesCheckGCR(\\n      positionData,\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n\\n    emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n  }\\n\\n  function requestWithdrawal(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    uint256 actualTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external {\\n    require(\\n      collateralAmount.isGreaterThan(0) &&\\n        collateralAmount.isLessThanOrEqual(\\n          positionData.rawCollateral.getFeeAdjustedCollateral(\\n            feePayerData.cumulativeFeeMultiplier\\n          )\\n        ),\\n      'Invalid collateral amount'\\n    );\\n\\n    positionData.withdrawalRequestPassTimestamp = actualTime.add(\\n      positionManagerData.withdrawalLiveness\\n    );\\n    positionData.withdrawalRequestAmount = collateralAmount;\\n\\n    emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\\n  }\\n\\n  function withdrawPassedRequest(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    uint256 actualTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    require(\\n      positionData.withdrawalRequestPassTimestamp != 0 &&\\n        positionData.withdrawalRequestPassTimestamp <= actualTime,\\n      'Invalid withdraw request'\\n    );\\n\\n    FixedPoint.Unsigned memory amountToWithdraw =\\n      positionData.withdrawalRequestAmount;\\n    if (\\n      positionData.withdrawalRequestAmount.isGreaterThan(\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      )\\n    ) {\\n      amountToWithdraw = positionData.rawCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n    }\\n\\n    amountWithdrawn = positionData._decrementCollateralBalances(\\n      globalPositionData,\\n      amountToWithdraw,\\n      feePayerData\\n    );\\n\\n    positionData._resetWithdrawalRequest();\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n\\n    emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\\n  }\\n\\n  function cancelWithdrawal(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData\\n  ) external {\\n    require(\\n      positionData.withdrawalRequestPassTimestamp != 0,\\n      'No pending withdrawal'\\n    );\\n\\n    emit RequestWithdrawalCanceled(\\n      msg.sender,\\n      positionData.withdrawalRequestAmount.rawValue\\n    );\\n\\n    _resetWithdrawalRequest(positionData);\\n  }\\n\\n  function create(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external {\\n    require(\\n      (_checkCollateralization(\\n        globalPositionData,\\n        positionData\\n          .rawCollateral\\n          .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n          .add(collateralAmount),\\n        positionData.tokensOutstanding.add(numTokens),\\n        feePayerData\\n      ) ||\\n        _checkCollateralization(\\n          globalPositionData,\\n          collateralAmount,\\n          numTokens,\\n          feePayerData\\n        )),\\n      'Insufficient collateral'\\n    );\\n\\n    require(\\n      positionData.withdrawalRequestPassTimestamp == 0,\\n      'Pending withdrawal'\\n    );\\n    if (positionData.tokensOutstanding.isEqual(0)) {\\n      require(\\n        numTokens.isGreaterThanOrEqual(positionManagerData.minSponsorTokens),\\n        'Below minimum sponsor position'\\n      );\\n      emit NewSponsor(msg.sender);\\n    }\\n\\n    _incrementCollateralBalances(\\n      positionData,\\n      globalPositionData,\\n      collateralAmount,\\n      feePayerData\\n    );\\n\\n    positionData.tokensOutstanding = positionData.tokensOutstanding.add(\\n      numTokens\\n    );\\n\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .add(numTokens);\\n\\n    emit PositionCreated(\\n      msg.sender,\\n      collateralAmount.rawValue,\\n      numTokens.rawValue\\n    );\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      collateralAmount.rawValue\\n    );\\n    require(\\n      positionManagerData.tokenCurrency.mint(msg.sender, numTokens.rawValue),\\n      'Minting synthetic tokens failed'\\n    );\\n  }\\n\\n  function redeeem(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory numTokens,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    require(\\n      numTokens.isLessThanOrEqual(positionData.tokensOutstanding),\\n      'Invalid token amount'\\n    );\\n\\n    FixedPoint.Unsigned memory fractionRedeemed =\\n      numTokens.div(positionData.tokensOutstanding);\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      fractionRedeemed.mul(\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      );\\n\\n    if (positionData.tokensOutstanding.isEqual(numTokens)) {\\n      amountWithdrawn = positionData._deleteSponsorPosition(\\n        globalPositionData,\\n        feePayerData,\\n        sponsor\\n      );\\n    } else {\\n      amountWithdrawn = positionData._decrementCollateralBalances(\\n        globalPositionData,\\n        collateralRedeemed,\\n        feePayerData\\n      );\\n\\n      FixedPoint.Unsigned memory newTokenCount =\\n        positionData.tokensOutstanding.sub(numTokens);\\n      require(\\n        newTokenCount.isGreaterThanOrEqual(\\n          positionManagerData.minSponsorTokens\\n        ),\\n        'Below minimum sponsor position'\\n      );\\n      positionData.tokensOutstanding = newTokenCount;\\n\\n      globalPositionData.totalTokensOutstanding = globalPositionData\\n        .totalTokensOutstanding\\n        .sub(numTokens);\\n    }\\n\\n    emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      numTokens.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(numTokens.rawValue);\\n  }\\n\\n  function repay(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory numTokens\\n  ) external {\\n    require(\\n      numTokens.isLessThanOrEqual(positionData.tokensOutstanding),\\n      'Invalid token amount'\\n    );\\n\\n    FixedPoint.Unsigned memory newTokenCount =\\n      positionData.tokensOutstanding.sub(numTokens);\\n    require(\\n      newTokenCount.isGreaterThanOrEqual(positionManagerData.minSponsorTokens),\\n      'Below minimum sponsor position'\\n    );\\n    positionData.tokensOutstanding = newTokenCount;\\n\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(numTokens);\\n\\n    emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\\n\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      numTokens.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(numTokens.rawValue);\\n  }\\n\\n  function settleEmergencyShutdown(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amountWithdrawn) {\\n    if (\\n      positionManagerData.emergencyShutdownPrice.isEqual(\\n        FixedPoint.fromUnscaledUint(0)\\n      )\\n    ) {\\n      FixedPoint.Unsigned memory oraclePrice =\\n        positionManagerData._getOracleEmergencyShutdownPrice(feePayerData);\\n      positionManagerData.emergencyShutdownPrice = oraclePrice\\n        ._decimalsScalingFactor(feePayerData);\\n    }\\n\\n    FixedPoint.Unsigned memory tokensToRedeem =\\n      FixedPoint.Unsigned(\\n        positionManagerData.tokenCurrency.balanceOf(msg.sender)\\n      );\\n\\n    FixedPoint.Unsigned memory totalRedeemableCollateral =\\n      tokensToRedeem.mul(positionManagerData.emergencyShutdownPrice);\\n\\n    if (\\n      positionData\\n        .rawCollateral\\n        .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n        .isGreaterThan(0)\\n    ) {\\n      FixedPoint.Unsigned memory tokenDebtValueInCollateral =\\n        positionData.tokensOutstanding.mul(\\n          positionManagerData.emergencyShutdownPrice\\n        );\\n      FixedPoint.Unsigned memory positionCollateral =\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        );\\n\\n      FixedPoint.Unsigned memory positionRedeemableCollateral =\\n        tokenDebtValueInCollateral.isLessThan(positionCollateral)\\n          ? positionCollateral.sub(tokenDebtValueInCollateral)\\n          : FixedPoint.Unsigned(0);\\n\\n      totalRedeemableCollateral = totalRedeemableCollateral.add(\\n        positionRedeemableCollateral\\n      );\\n\\n      PerpetualPositionManagerPoolParty(address(this)).deleteSponsorPosition(\\n        msg.sender\\n      );\\n      emit EndedSponsorPosition(msg.sender);\\n    }\\n\\n    FixedPoint.Unsigned memory payout =\\n      FixedPoint.min(\\n        globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        ),\\n        totalRedeemableCollateral\\n      );\\n\\n    amountWithdrawn = globalPositionData\\n      .rawTotalPositionCollateral\\n      .removeCollateral(payout, feePayerData.cumulativeFeeMultiplier);\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(tokensToRedeem);\\n\\n    emit SettleEmergencyShutdown(\\n      msg.sender,\\n      amountWithdrawn.rawValue,\\n      tokensToRedeem.rawValue\\n    );\\n\\n    feePayerData.collateralCurrency.safeTransfer(\\n      msg.sender,\\n      amountWithdrawn.rawValue\\n    );\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      tokensToRedeem.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(tokensToRedeem.rawValue);\\n  }\\n\\n  function trimExcess(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    IERC20 token,\\n    FixedPoint.Unsigned memory pfcAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (FixedPoint.Unsigned memory amount) {\\n    FixedPoint.Unsigned memory balance =\\n      FixedPoint.Unsigned(token.balanceOf(address(this)));\\n    if (address(token) == address(feePayerData.collateralCurrency)) {\\n      amount = balance.sub(pfcAmount);\\n    } else {\\n      amount = balance;\\n    }\\n    token.safeTransfer(\\n      positionManagerData.excessTokenBeneficiary,\\n      amount.rawValue\\n    );\\n  }\\n\\n  function requestOraclePrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    uint256 requestedTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external {\\n    feePayerData._getOracle().requestPrice(\\n      positionManagerData.priceIdentifier,\\n      requestedTime\\n    );\\n  }\\n\\n  function reduceSponsorPosition(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FixedPoint.Unsigned memory tokensToRemove,\\n    FixedPoint.Unsigned memory collateralToRemove,\\n    FixedPoint.Unsigned memory withdrawalAmountToRemove,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) external {\\n    if (\\n      tokensToRemove.isEqual(positionData.tokensOutstanding) &&\\n      positionData\\n        .rawCollateral\\n        .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier)\\n        .isEqual(collateralToRemove)\\n    ) {\\n      positionData._deleteSponsorPosition(\\n        globalPositionData,\\n        feePayerData,\\n        sponsor\\n      );\\n      return;\\n    }\\n\\n    positionData._decrementCollateralBalances(\\n      globalPositionData,\\n      collateralToRemove,\\n      feePayerData\\n    );\\n\\n    positionData.tokensOutstanding = positionData.tokensOutstanding.sub(\\n      tokensToRemove\\n    );\\n    require(\\n      positionData.tokensOutstanding.isGreaterThanOrEqual(\\n        positionManagerData.minSponsorTokens\\n      ),\\n      'Below minimum sponsor position'\\n    );\\n\\n    positionData.withdrawalRequestAmount = positionData\\n      .withdrawalRequestAmount\\n      .sub(withdrawalAmountToRemove);\\n\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(tokensToRemove);\\n  }\\n\\n  function getOraclePrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    uint256 requestedTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external view returns (FixedPoint.Unsigned memory price) {\\n    return _getOraclePrice(positionManagerData, requestedTime, feePayerData);\\n  }\\n\\n  function decimalsScalingFactor(\\n    FixedPoint.Unsigned memory oraclePrice,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external view returns (FixedPoint.Unsigned memory scaledPrice) {\\n    return _decimalsScalingFactor(oraclePrice, feePayerData);\\n  }\\n\\n  function _incrementCollateralBalances(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData memory feePayerData\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    positionData.rawCollateral.addCollateral(\\n      collateralAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n    return\\n      globalPositionData.rawTotalPositionCollateral.addCollateral(\\n        collateralAmount,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _decrementCollateralBalances(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    positionData.rawCollateral.removeCollateral(\\n      collateralAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n    return\\n      globalPositionData.rawTotalPositionCollateral.removeCollateral(\\n        collateralAmount,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _decrementCollateralBalancesCheckGCR(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    positionData.rawCollateral.removeCollateral(\\n      collateralAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n    require(\\n      _checkPositionCollateralization(\\n        positionData,\\n        globalPositionData,\\n        feePayerData\\n      ),\\n      'CR below GCR'\\n    );\\n    return\\n      globalPositionData.rawTotalPositionCollateral.removeCollateral(\\n        collateralAmount,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n  }\\n\\n  function _checkPositionCollateralization(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (bool) {\\n    return\\n      _checkCollateralization(\\n        globalPositionData,\\n        positionData.rawCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        ),\\n        positionData.tokensOutstanding,\\n        feePayerData\\n      );\\n  }\\n\\n  function _checkCollateralization(\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory numTokens,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (bool) {\\n    FixedPoint.Unsigned memory global =\\n      _getCollateralizationRatio(\\n        globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        ),\\n        globalPositionData.totalTokensOutstanding\\n      );\\n    FixedPoint.Unsigned memory thisChange =\\n      _getCollateralizationRatio(collateral, numTokens);\\n    return !global.isGreaterThan(thisChange);\\n  }\\n\\n  function _getCollateralizationRatio(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal pure returns (FixedPoint.Unsigned memory ratio) {\\n    return\\n      numTokens.isLessThanOrEqual(0)\\n        ? FixedPoint.fromUnscaledUint(0)\\n        : collateral.div(numTokens);\\n  }\\n\\n  function _resetWithdrawalRequest(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionData\\n  ) internal {\\n    positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\\n    positionData.withdrawalRequestPassTimestamp = 0;\\n  }\\n\\n  function _deleteSponsorPosition(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionToLiquidate,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    address sponsor\\n  ) internal returns (FixedPoint.Unsigned memory) {\\n    FixedPoint.Unsigned memory startingGlobalCollateral =\\n      globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n\\n    globalPositionData.rawTotalPositionCollateral = globalPositionData\\n      .rawTotalPositionCollateral\\n      .sub(positionToLiquidate.rawCollateral);\\n    globalPositionData.totalTokensOutstanding = globalPositionData\\n      .totalTokensOutstanding\\n      .sub(positionToLiquidate.tokensOutstanding);\\n\\n    PerpetualPositionManagerPoolParty(address(this)).deleteSponsorPosition(\\n      sponsor\\n    );\\n\\n    emit EndedSponsorPosition(sponsor);\\n\\n    return\\n      startingGlobalCollateral.sub(\\n        globalPositionData.rawTotalPositionCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      );\\n  }\\n\\n  function _getOracleEmergencyShutdownPrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (FixedPoint.Unsigned memory) {\\n    return\\n      positionManagerData._getOraclePrice(\\n        positionManagerData.emergencyShutdownTimestamp,\\n        feePayerData\\n      );\\n  }\\n\\n  function _getOraclePrice(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    uint256 requestedTime,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (FixedPoint.Unsigned memory price) {\\n    OracleInterface oracle = feePayerData._getOracle();\\n    require(\\n      oracle.hasPrice(positionManagerData.priceIdentifier, requestedTime),\\n      'Unresolved oracle price'\\n    );\\n    int256 oraclePrice =\\n      oracle.getPrice(positionManagerData.priceIdentifier, requestedTime);\\n\\n    if (oraclePrice < 0) {\\n      oraclePrice = 0;\\n    }\\n    return FixedPoint.Unsigned(uint256(oraclePrice));\\n  }\\n\\n  function _getOracle(FeePayerPoolParty.FeePayerData storage feePayerData)\\n    internal\\n    view\\n    returns (OracleInterface)\\n  {\\n    return\\n      OracleInterface(\\n        feePayerData.finder.getImplementationAddress(OracleInterfaces.Oracle)\\n      );\\n  }\\n\\n  function _decimalsScalingFactor(\\n    FixedPoint.Unsigned memory oraclePrice,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) internal view returns (FixedPoint.Unsigned memory scaledPrice) {\\n    uint8 collateralDecimalsNumber =\\n      IERC20Standard(address(feePayerData.collateralCurrency)).decimals();\\n    scaledPrice = oraclePrice.div(\\n      (10**(uint256(18)).sub(collateralDecimalsNumber))\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualLiquidatablePoolPartyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './PerpetualPositionManagerPoolPartyLib.sol';\\nimport './PerpetualLiquidatablePoolParty.sol';\\nimport '../common/FeePayerPoolPartyLib.sol';\\nimport '../../common/interfaces/MintableBurnableIERC20.sol';\\n\\nlibrary PerpetualLiquidatablePoolPartyLib {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for MintableBurnableIERC20;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using PerpetualPositionManagerPoolPartyLib for PerpetualPositionManagerPoolParty.PositionData;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using PerpetualPositionManagerPoolPartyLib for PerpetualPositionManagerPoolParty.PositionManagerData;\\n  using PerpetualLiquidatablePoolPartyLib for PerpetualLiquidatablePoolParty.LiquidationData;\\n  using PerpetualPositionManagerPoolPartyLib for FixedPoint.Unsigned;\\n\\n  struct CreateLiquidationParams {\\n    FixedPoint.Unsigned minCollateralPerToken;\\n    FixedPoint.Unsigned maxCollateralPerToken;\\n    FixedPoint.Unsigned maxTokensToLiquidate;\\n    uint256 actualTime;\\n    uint256 deadline;\\n    FixedPoint.Unsigned finalFee;\\n    address sponsor;\\n  }\\n\\n  struct CreateLiquidationCollateral {\\n    FixedPoint.Unsigned startCollateral;\\n    FixedPoint.Unsigned startCollateralNetOfWithdrawal;\\n    FixedPoint.Unsigned tokensLiquidated;\\n    FixedPoint.Unsigned finalFeeBond;\\n    address sponsor;\\n  }\\n\\n  struct CreateLiquidationReturnParams {\\n    uint256 liquidationId;\\n    FixedPoint.Unsigned lockedCollateral;\\n    FixedPoint.Unsigned liquidatedCollateral;\\n    FixedPoint.Unsigned tokensLiquidated;\\n    FixedPoint.Unsigned finalFeeBond;\\n  }\\n\\n  struct SettleParams {\\n    FixedPoint.Unsigned feeAttenuation;\\n    FixedPoint.Unsigned settlementPrice;\\n    FixedPoint.Unsigned tokenRedemptionValue;\\n    FixedPoint.Unsigned collateral;\\n    FixedPoint.Unsigned disputerDisputeReward;\\n    FixedPoint.Unsigned sponsorDisputeReward;\\n    FixedPoint.Unsigned disputeBondAmount;\\n    FixedPoint.Unsigned finalFee;\\n    FixedPoint.Unsigned withdrawalAmount;\\n  }\\n\\n  event LiquidationCreated(\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    uint256 indexed liquidationId,\\n    uint256 tokensOutstanding,\\n    uint256 lockedCollateral,\\n    uint256 liquidatedCollateral,\\n    uint256 liquidationTime\\n  );\\n  event LiquidationDisputed(\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    address indexed disputer,\\n    uint256 liquidationId,\\n    uint256 disputeBondAmount\\n  );\\n\\n  event DisputeSettled(\\n    address indexed caller,\\n    address indexed sponsor,\\n    address indexed liquidator,\\n    address disputer,\\n    uint256 liquidationId,\\n    bool disputeSucceeded\\n  );\\n\\n  event LiquidationWithdrawn(\\n    address indexed caller,\\n    uint256 paidToLiquidator,\\n    uint256 paidToDisputer,\\n    uint256 paidToSponsor,\\n    PerpetualLiquidatablePoolParty.Status indexed liquidationStatus,\\n    uint256 settlementPrice\\n  );\\n\\n  function createLiquidation(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionToLiquidate,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    PerpetualLiquidatablePoolParty.LiquidatableData storage liquidatableData,\\n    PerpetualLiquidatablePoolParty.LiquidationData[] storage liquidations,\\n    CreateLiquidationParams memory params,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  ) external returns (CreateLiquidationReturnParams memory returnValues) {\\n    FixedPoint.Unsigned memory startCollateral;\\n    FixedPoint.Unsigned memory startCollateralNetOfWithdrawal;\\n\\n    (\\n      startCollateral,\\n      startCollateralNetOfWithdrawal,\\n      returnValues.tokensLiquidated\\n    ) = calculateNetLiquidation(positionToLiquidate, params, feePayerData);\\n\\n    {\\n      FixedPoint.Unsigned memory startTokens =\\n        positionToLiquidate.tokensOutstanding;\\n\\n      require(\\n        params.maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(\\n          startCollateralNetOfWithdrawal\\n        ),\\n        'CR is more than max liq. price'\\n      );\\n\\n      require(\\n        params.minCollateralPerToken.mul(startTokens).isLessThanOrEqual(\\n          startCollateralNetOfWithdrawal\\n        ),\\n        'CR is less than min liq. price'\\n      );\\n    }\\n    {\\n      returnValues.finalFeeBond = params.finalFee;\\n\\n      CreateLiquidationCollateral memory liquidationCollateral =\\n        CreateLiquidationCollateral(\\n          startCollateral,\\n          startCollateralNetOfWithdrawal,\\n          returnValues.tokensLiquidated,\\n          returnValues.finalFeeBond,\\n          params.sponsor\\n        );\\n\\n      (\\n        returnValues.lockedCollateral,\\n        returnValues.liquidatedCollateral\\n      ) = liquidateCollateral(\\n        positionToLiquidate,\\n        globalPositionData,\\n        positionManagerData,\\n        liquidatableData,\\n        feePayerData,\\n        liquidationCollateral\\n      );\\n\\n      returnValues.liquidationId = liquidations.length;\\n      liquidations.push(\\n        PerpetualLiquidatablePoolParty.LiquidationData({\\n          sponsor: params.sponsor,\\n          liquidator: msg.sender,\\n          state: PerpetualLiquidatablePoolParty.Status.PreDispute,\\n          liquidationTime: params.actualTime,\\n          tokensOutstanding: returnValues.tokensLiquidated,\\n          lockedCollateral: returnValues.lockedCollateral,\\n          liquidatedCollateral: returnValues.liquidatedCollateral,\\n          rawUnitCollateral: FixedPoint\\n            .fromUnscaledUint(1)\\n            .convertToRawCollateral(feePayerData.cumulativeFeeMultiplier),\\n          disputer: address(0),\\n          settlementPrice: FixedPoint.fromUnscaledUint(0),\\n          finalFee: returnValues.finalFeeBond\\n        })\\n      );\\n    }\\n\\n    {\\n      FixedPoint.Unsigned memory griefingThreshold =\\n        positionManagerData.minSponsorTokens;\\n      if (\\n        positionToLiquidate.withdrawalRequestPassTimestamp > 0 &&\\n        positionToLiquidate.withdrawalRequestPassTimestamp >\\n        params.actualTime &&\\n        returnValues.tokensLiquidated.isGreaterThanOrEqual(griefingThreshold)\\n      ) {\\n        positionToLiquidate.withdrawalRequestPassTimestamp = params\\n          .actualTime\\n          .add(positionManagerData.withdrawalLiveness);\\n      }\\n    }\\n    emit LiquidationCreated(\\n      params.sponsor,\\n      msg.sender,\\n      returnValues.liquidationId,\\n      returnValues.tokensLiquidated.rawValue,\\n      returnValues.lockedCollateral.rawValue,\\n      returnValues.liquidatedCollateral.rawValue,\\n      params.actualTime\\n    );\\n\\n    burnAndLiquidateFee(\\n      positionManagerData,\\n      feePayerData,\\n      returnValues.tokensLiquidated,\\n      returnValues.finalFeeBond\\n    );\\n  }\\n\\n  function dispute(\\n    PerpetualLiquidatablePoolParty.LiquidationData storage disputedLiquidation,\\n    PerpetualLiquidatablePoolParty.LiquidatableData storage liquidatableData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    uint256 liquidationId,\\n    address sponsor\\n  ) external returns (FixedPoint.Unsigned memory totalPaid) {\\n    FixedPoint.Unsigned memory disputeBondAmount =\\n      disputedLiquidation\\n        .lockedCollateral\\n        .mul(liquidatableData.disputeBondPct)\\n        .mul(\\n        disputedLiquidation.rawUnitCollateral.getFeeAdjustedCollateral(\\n          feePayerData.cumulativeFeeMultiplier\\n        )\\n      );\\n    liquidatableData.rawLiquidationCollateral.addCollateral(\\n      disputeBondAmount,\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n\\n    disputedLiquidation.state = PerpetualLiquidatablePoolParty\\n      .Status\\n      .PendingDispute;\\n    disputedLiquidation.disputer = msg.sender;\\n\\n    positionManagerData.requestOraclePrice(\\n      disputedLiquidation.liquidationTime,\\n      feePayerData\\n    );\\n\\n    emit LiquidationDisputed(\\n      sponsor,\\n      disputedLiquidation.liquidator,\\n      msg.sender,\\n      liquidationId,\\n      disputeBondAmount.rawValue\\n    );\\n\\n    totalPaid = disputeBondAmount.add(disputedLiquidation.finalFee);\\n\\n    FeePayerPoolParty(address(this)).payFinalFees(\\n      msg.sender,\\n      disputedLiquidation.finalFee\\n    );\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      disputeBondAmount.rawValue\\n    );\\n  }\\n\\n  function withdrawLiquidation(\\n    PerpetualLiquidatablePoolParty.LiquidationData storage liquidation,\\n    PerpetualLiquidatablePoolParty.LiquidatableData storage liquidatableData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    uint256 liquidationId,\\n    address sponsor\\n  )\\n    external\\n    returns (PerpetualLiquidatablePoolParty.RewardsData memory rewards)\\n  {\\n    liquidation._settle(\\n      positionManagerData,\\n      liquidatableData,\\n      feePayerData,\\n      liquidationId,\\n      sponsor\\n    );\\n\\n    SettleParams memory settleParams;\\n\\n    settleParams.feeAttenuation = liquidation\\n      .rawUnitCollateral\\n      .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier);\\n    settleParams.settlementPrice = liquidation.settlementPrice;\\n    settleParams.tokenRedemptionValue = liquidation\\n      .tokensOutstanding\\n      .mul(settleParams.settlementPrice)\\n      .mul(settleParams.feeAttenuation);\\n    settleParams.collateral = liquidation.lockedCollateral.mul(\\n      settleParams.feeAttenuation\\n    );\\n    settleParams.disputerDisputeReward = liquidatableData\\n      .disputerDisputeRewardPct\\n      .mul(settleParams.tokenRedemptionValue);\\n    settleParams.sponsorDisputeReward = liquidatableData\\n      .sponsorDisputeRewardPct\\n      .mul(settleParams.tokenRedemptionValue);\\n    settleParams.disputeBondAmount = settleParams.collateral.mul(\\n      liquidatableData.disputeBondPct\\n    );\\n    settleParams.finalFee = liquidation.finalFee.mul(\\n      settleParams.feeAttenuation\\n    );\\n\\n    if (\\n      liquidation.state ==\\n      PerpetualLiquidatablePoolParty.Status.DisputeSucceeded\\n    ) {\\n      rewards.payToDisputer = settleParams\\n        .disputerDisputeReward\\n        .add(settleParams.disputeBondAmount)\\n        .add(settleParams.finalFee);\\n\\n      rewards.payToSponsor = settleParams.sponsorDisputeReward.add(\\n        settleParams.collateral.sub(settleParams.tokenRedemptionValue)\\n      );\\n\\n      rewards.payToLiquidator = settleParams\\n        .tokenRedemptionValue\\n        .sub(settleParams.sponsorDisputeReward)\\n        .sub(settleParams.disputerDisputeReward);\\n\\n      rewards.paidToLiquidator = liquidatableData\\n        .rawLiquidationCollateral\\n        .removeCollateral(\\n        rewards.payToLiquidator,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n      rewards.paidToSponsor = liquidatableData\\n        .rawLiquidationCollateral\\n        .removeCollateral(\\n        rewards.payToSponsor,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n      rewards.paidToDisputer = liquidatableData\\n        .rawLiquidationCollateral\\n        .removeCollateral(\\n        rewards.payToDisputer,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n\\n      feePayerData.collateralCurrency.safeTransfer(\\n        liquidation.disputer,\\n        rewards.paidToDisputer.rawValue\\n      );\\n      feePayerData.collateralCurrency.safeTransfer(\\n        liquidation.liquidator,\\n        rewards.paidToLiquidator.rawValue\\n      );\\n      feePayerData.collateralCurrency.safeTransfer(\\n        liquidation.sponsor,\\n        rewards.paidToSponsor.rawValue\\n      );\\n    } else if (\\n      liquidation.state == PerpetualLiquidatablePoolParty.Status.DisputeFailed\\n    ) {\\n      rewards.payToLiquidator = settleParams\\n        .collateral\\n        .add(settleParams.disputeBondAmount)\\n        .add(settleParams.finalFee);\\n\\n      rewards.paidToLiquidator = liquidatableData\\n        .rawLiquidationCollateral\\n        .removeCollateral(\\n        rewards.payToLiquidator,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n\\n      feePayerData.collateralCurrency.safeTransfer(\\n        liquidation.liquidator,\\n        rewards.paidToLiquidator.rawValue\\n      );\\n    } else if (\\n      liquidation.state == PerpetualLiquidatablePoolParty.Status.PreDispute\\n    ) {\\n      rewards.payToLiquidator = settleParams.collateral.add(\\n        settleParams.finalFee\\n      );\\n\\n      rewards.paidToLiquidator = liquidatableData\\n        .rawLiquidationCollateral\\n        .removeCollateral(\\n        rewards.payToLiquidator,\\n        feePayerData.cumulativeFeeMultiplier\\n      );\\n\\n      feePayerData.collateralCurrency.safeTransfer(\\n        liquidation.liquidator,\\n        rewards.paidToLiquidator.rawValue\\n      );\\n    }\\n\\n    emit LiquidationWithdrawn(\\n      msg.sender,\\n      rewards.paidToLiquidator.rawValue,\\n      rewards.paidToDisputer.rawValue,\\n      rewards.paidToSponsor.rawValue,\\n      liquidation.state,\\n      settleParams.settlementPrice.rawValue\\n    );\\n\\n    PerpetualLiquidatablePoolParty(address(this)).deleteLiquidation(\\n      liquidationId,\\n      sponsor\\n    );\\n\\n    return rewards;\\n  }\\n\\n  function calculateNetLiquidation(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionToLiquidate,\\n    CreateLiquidationParams memory params,\\n    FeePayerPoolParty.FeePayerData storage feePayerData\\n  )\\n    internal\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory startCollateral,\\n      FixedPoint.Unsigned memory startCollateralNetOfWithdrawal,\\n      FixedPoint.Unsigned memory tokensLiquidated\\n    )\\n  {\\n    tokensLiquidated = FixedPoint.min(\\n      params.maxTokensToLiquidate,\\n      positionToLiquidate.tokensOutstanding\\n    );\\n    require(tokensLiquidated.isGreaterThan(0), 'Liquidating 0 tokens');\\n\\n    require(params.actualTime <= params.deadline, 'Mined after deadline');\\n\\n    startCollateral = positionToLiquidate\\n      .rawCollateral\\n      .getFeeAdjustedCollateral(feePayerData.cumulativeFeeMultiplier);\\n    startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\\n\\n    if (\\n      positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(\\n        startCollateral\\n      )\\n    ) {\\n      startCollateralNetOfWithdrawal = startCollateral.sub(\\n        positionToLiquidate.withdrawalRequestAmount\\n      );\\n    }\\n  }\\n\\n  function liquidateCollateral(\\n    PerpetualPositionManagerPoolParty.PositionData storage positionToLiquidate,\\n    PerpetualPositionManagerPoolParty.GlobalPositionData\\n      storage globalPositionData,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    PerpetualLiquidatablePoolParty.LiquidatableData storage liquidatableData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    CreateLiquidationCollateral memory liquidationCollateralParams\\n  )\\n    internal\\n    returns (\\n      FixedPoint.Unsigned memory lockedCollateral,\\n      FixedPoint.Unsigned memory liquidatedCollateral\\n    )\\n  {\\n    {\\n      FixedPoint.Unsigned memory ratio =\\n        liquidationCollateralParams.tokensLiquidated.div(\\n          positionToLiquidate.tokensOutstanding\\n        );\\n\\n      lockedCollateral = liquidationCollateralParams.startCollateral.mul(ratio);\\n\\n      liquidatedCollateral = liquidationCollateralParams\\n        .startCollateralNetOfWithdrawal\\n        .mul(ratio);\\n\\n      FixedPoint.Unsigned memory withdrawalAmountToRemove =\\n        positionToLiquidate.withdrawalRequestAmount.mul(ratio);\\n\\n      positionToLiquidate.reduceSponsorPosition(\\n        globalPositionData,\\n        positionManagerData,\\n        liquidationCollateralParams.tokensLiquidated,\\n        lockedCollateral,\\n        withdrawalAmountToRemove,\\n        feePayerData,\\n        liquidationCollateralParams.sponsor\\n      );\\n    }\\n\\n    liquidatableData.rawLiquidationCollateral.addCollateral(\\n      lockedCollateral.add(liquidationCollateralParams.finalFeeBond),\\n      feePayerData.cumulativeFeeMultiplier\\n    );\\n  }\\n\\n  function burnAndLiquidateFee(\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    FixedPoint.Unsigned memory tokensLiquidated,\\n    FixedPoint.Unsigned memory finalFeeBond\\n  ) internal {\\n    positionManagerData.tokenCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      tokensLiquidated.rawValue\\n    );\\n    positionManagerData.tokenCurrency.burn(tokensLiquidated.rawValue);\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      finalFeeBond.rawValue\\n    );\\n  }\\n\\n  function _settle(\\n    PerpetualLiquidatablePoolParty.LiquidationData storage liquidation,\\n    PerpetualPositionManagerPoolParty.PositionManagerData\\n      storage positionManagerData,\\n    PerpetualLiquidatablePoolParty.LiquidatableData storage liquidatableData,\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    uint256 liquidationId,\\n    address sponsor\\n  ) internal {\\n    if (\\n      liquidation.state != PerpetualLiquidatablePoolParty.Status.PendingDispute\\n    ) {\\n      return;\\n    }\\n\\n    FixedPoint.Unsigned memory oraclePrice =\\n      positionManagerData.getOraclePrice(\\n        liquidation.liquidationTime,\\n        feePayerData\\n      );\\n\\n    liquidation.settlementPrice = oraclePrice.decimalsScalingFactor(\\n      feePayerData\\n    );\\n\\n    FixedPoint.Unsigned memory tokenRedemptionValue =\\n      liquidation.tokensOutstanding.mul(liquidation.settlementPrice);\\n\\n    FixedPoint.Unsigned memory requiredCollateral =\\n      tokenRedemptionValue.mul(liquidatableData.collateralRequirement);\\n\\n    bool disputeSucceeded =\\n      liquidation.liquidatedCollateral.isGreaterThanOrEqual(requiredCollateral);\\n    liquidation.state = disputeSucceeded\\n      ? PerpetualLiquidatablePoolParty.Status.DisputeSucceeded\\n      : PerpetualLiquidatablePoolParty.Status.DisputeFailed;\\n\\n    emit DisputeSettled(\\n      msg.sender,\\n      sponsor,\\n      liquidation.liquidator,\\n      liquidation.disputer,\\n      liquidationId,\\n      disputeSucceeded\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.8.0;\\n\\nlibrary Address {\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(\\n      success,\\n      'Address: unable to send value, recipient may have reverted'\\n    );\\n  }\\n\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return functionCall(target, data, 'Address: low-level call failed');\\n  }\\n\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        'Address: low-level call with value failed'\\n      );\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance >= value,\\n      'Address: insufficient balance for call'\\n    );\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(target, data, 'Address: low-level static call failed');\\n  }\\n\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), 'Address: static call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      if (returndata.length > 0) {\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/interfaces/MintableBurnableIERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\nabstract contract MintableBurnableIERC20 is ERC20 {\\n  function burn(uint256 value) external virtual;\\n\\n  function mint(address to, uint256 value) external virtual returns (bool);\\n\\n  function addMinter(address account) external virtual;\\n\\n  function addBurner(address account) external virtual;\\n\\n  function addAdmin(address account) external virtual;\\n\\n  function addAdminAndMinterAndBurner(address account) external virtual;\\n\\n  function renounceMinter() external virtual;\\n\\n  function renounceBurner() external virtual;\\n\\n  function renounceAdmin() external virtual;\\n\\n  function renounceAdminAndMinterAndBurner() external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nabstract contract OracleInterface {\\n  function requestPrice(bytes32 identifier, uint256 time) public virtual;\\n\\n  function hasPrice(bytes32 identifier, uint256 time)\\n    public\\n    view\\n    virtual\\n    returns (bool);\\n\\n  function getPrice(bytes32 identifier, uint256 time)\\n    public\\n    view\\n    virtual\\n    returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/IdentifierWhitelistInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface IdentifierWhitelistInterface {\\n  function addSupportedIdentifier(bytes32 identifier) external;\\n\\n  function removeSupportedIdentifier(bytes32 identifier) external;\\n\\n  function isIdentifierSupported(bytes32 identifier)\\n    external\\n    view\\n    returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/AdministrateeInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\n\\ninterface AdministrateeInterface {\\n  function emergencyShutdown() external;\\n\\n  function remargin() external;\\n\\n  function pfc() external view returns (FixedPoint.Unsigned memory);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/implementation/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nlibrary OracleInterfaces {\\n  bytes32 public constant Oracle = 'Oracle';\\n  bytes32 public constant IdentifierWhitelist = 'IdentifierWhitelist';\\n  bytes32 public constant Store = 'Store';\\n  bytes32 public constant FinancialContractsAdmin = 'FinancialContractsAdmin';\\n  bytes32 public constant Registry = 'Registry';\\n  bytes32 public constant CollateralWhitelist = 'CollateralWhitelist';\\n  bytes32 public constant OptimisticOracle = 'OptimisticOracle';\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/FeePayerPoolParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport '../../common/implementation/Lockable.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './FeePayerPoolPartyLib.sol';\\nimport '../../common/implementation/Testable.sol';\\n\\nimport '../../oracle/interfaces/StoreInterface.sol';\\nimport '../../oracle/interfaces/FinderInterface.sol';\\nimport '../../oracle/interfaces/AdministrateeInterface.sol';\\nimport '../../oracle/implementation/Constants.sol';\\n\\nabstract contract FeePayerPoolParty is\\n  AdministrateeInterface,\\n  Testable,\\n  Lockable\\n{\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FeePayerData;\\n  using SafeERC20 for IERC20;\\n\\n  struct FeePayerData {\\n    IERC20 collateralCurrency;\\n    FinderInterface finder;\\n    uint256 lastPaymentTime;\\n    FixedPoint.Unsigned cumulativeFeeMultiplier;\\n  }\\n\\n  FeePayerData public feePayerData;\\n\\n  event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\\n  event FinalFeesPaid(uint256 indexed amount);\\n\\n  modifier fees {\\n    payRegularFees();\\n    _;\\n  }\\n  modifier onlyThisContract {\\n    require(msg.sender == address(this), 'Caller is not this contract');\\n    _;\\n  }\\n\\n  constructor(\\n    address _collateralAddress,\\n    address _finderAddress,\\n    address _timerAddress\\n  ) public Testable(_timerAddress) {\\n    feePayerData.collateralCurrency = IERC20(_collateralAddress);\\n    feePayerData.finder = FinderInterface(_finderAddress);\\n    feePayerData.lastPaymentTime = getCurrentTime();\\n    feePayerData.cumulativeFeeMultiplier = FixedPoint.fromUnscaledUint(1);\\n  }\\n\\n  function payRegularFees()\\n    public\\n    nonReentrant()\\n    returns (FixedPoint.Unsigned memory totalPaid)\\n  {\\n    StoreInterface store = _getStore();\\n    uint256 time = getCurrentTime();\\n    FixedPoint.Unsigned memory collateralPool = _pfc();\\n    totalPaid = feePayerData.payRegularFees(store, time, collateralPool);\\n    return totalPaid;\\n  }\\n\\n  function payFinalFees(address payer, FixedPoint.Unsigned memory amount)\\n    external\\n    onlyThisContract\\n  {\\n    _payFinalFees(payer, amount);\\n  }\\n\\n  function pfc()\\n    public\\n    view\\n    override\\n    nonReentrantView()\\n    returns (FixedPoint.Unsigned memory)\\n  {\\n    return _pfc();\\n  }\\n\\n  function collateralCurrency()\\n    public\\n    view\\n    nonReentrantView()\\n    returns (IERC20)\\n  {\\n    return feePayerData.collateralCurrency;\\n  }\\n\\n  function _payFinalFees(address payer, FixedPoint.Unsigned memory amount)\\n    internal\\n  {\\n    StoreInterface store = _getStore();\\n    feePayerData.payFinalFees(store, payer, amount);\\n  }\\n\\n  function _pfc() internal view virtual returns (FixedPoint.Unsigned memory);\\n\\n  function _getStore() internal view returns (StoreInterface) {\\n    return\\n      StoreInterface(\\n        feePayerData.finder.getImplementationAddress(OracleInterfaces.Store)\\n      );\\n  }\\n\\n  function _computeFinalFees()\\n    internal\\n    view\\n    returns (FixedPoint.Unsigned memory finalFees)\\n  {\\n    StoreInterface store = _getStore();\\n    return store.computeFinalFee(address(feePayerData.collateralCurrency));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../utils/EnumerableSet.sol';\\nimport '../utils/Address.sol';\\nimport '../GSN/Context.sol';\\n\\nabstract contract AccessControl is Context {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using Address for address;\\n\\n  struct RoleData {\\n    EnumerableSet.AddressSet members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  event RoleGranted(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  event RoleRevoked(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  function hasRole(bytes32 role, address account) public view returns (bool) {\\n    return _roles[role].members.contains(account);\\n  }\\n\\n  function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n    return _roles[role].members.length();\\n  }\\n\\n  function getRoleMember(bytes32 role, uint256 index)\\n    public\\n    view\\n    returns (address)\\n  {\\n    return _roles[role].members.at(index);\\n  }\\n\\n  function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  function grantRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to grant'\\n    );\\n\\n    _grantRole(role, account);\\n  }\\n\\n  function revokeRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to revoke'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function renounceRole(bytes32 role, address account) public virtual {\\n    require(\\n      account == _msgSender(),\\n      'AccessControl: can only renounce roles for self'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (_roles[role].members.add(account)) {\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (_roles[role].members.remove(account)) {\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SignedSafeMath {\\n  int256 private constant _INT256_MIN = -2**255;\\n\\n  function mul(int256 a, int256 b) internal pure returns (int256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    require(\\n      !(a == -1 && b == _INT256_MIN),\\n      'SignedSafeMath: multiplication overflow'\\n    );\\n\\n    int256 c = a * b;\\n    require(c / a == b, 'SignedSafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(int256 a, int256 b) internal pure returns (int256) {\\n    require(b != 0, 'SignedSafeMath: division by zero');\\n    require(\\n      !(b == -1 && a == _INT256_MIN),\\n      'SignedSafeMath: division overflow'\\n    );\\n\\n    int256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function sub(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a - b;\\n    require(\\n      (b >= 0 && c <= a) || (b < 0 && c > a),\\n      'SignedSafeMath: subtraction overflow'\\n    );\\n\\n    return c;\\n  }\\n\\n  function add(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a + b;\\n    require(\\n      (b >= 0 && c >= a) || (b < 0 && c < a),\\n      'SignedSafeMath: addition overflow'\\n    );\\n\\n    return c;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../../GSN/Context.sol';\\nimport './IERC20.sol';\\nimport '../../math/SafeMath.sol';\\n\\ncontract ERC20 is Context, IERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  constructor(string memory name_, string memory symbol_) public {\\n    _name = name_;\\n    _symbol = symbol_;\\n    _decimals = 18;\\n  }\\n\\n  function name() public view returns (string memory) {\\n    return _name;\\n  }\\n\\n  function symbol() public view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  function decimals() public view returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  function totalSupply() public view override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address account) public view override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  function transfer(address recipient, uint256 amount)\\n    public\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  function allowance(address owner, address spender)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    return _allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount)\\n    public\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    _approve(_msgSender(), spender, amount);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n    _approve(\\n      sender,\\n      _msgSender(),\\n      _allowances[sender][_msgSender()].sub(\\n        amount,\\n        'ERC20: transfer amount exceeds allowance'\\n      )\\n    );\\n    return true;\\n  }\\n\\n  function increaseAllowance(address spender, uint256 addedValue)\\n    public\\n    virtual\\n    returns (bool)\\n  {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].add(addedValue)\\n    );\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender, uint256 subtractedValue)\\n    public\\n    virtual\\n    returns (bool)\\n  {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].sub(\\n        subtractedValue,\\n        'ERC20: decreased allowance below zero'\\n      )\\n    );\\n    return true;\\n  }\\n\\n  function _transfer(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) internal virtual {\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    _beforeTokenTransfer(sender, recipient, amount);\\n\\n    _balances[sender] = _balances[sender].sub(\\n      amount,\\n      'ERC20: transfer amount exceeds balance'\\n    );\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    _balances[account] = _balances[account].sub(\\n      amount,\\n      'ERC20: burn amount exceeds balance'\\n    );\\n    _totalSupply = _totalSupply.sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    require(owner != address(0), 'ERC20: approve from the zero address');\\n    require(spender != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  function _setupDecimals(uint8 decimals_) internal {\\n    _decimals = decimals_;\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this;\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/interfaces/IERC20Standard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IERC20Standard is IERC20 {\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/FeePayerPoolPartyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../common/implementation/FixedPoint.sol';\\nimport './FeePayerPoolParty.sol';\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '../../oracle/interfaces/StoreInterface.sol';\\n\\nlibrary FeePayerPoolPartyLib {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FeePayerPoolPartyLib for FixedPoint.Unsigned;\\n  using SafeERC20 for IERC20;\\n\\n  event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\\n  event FinalFeesPaid(uint256 indexed amount);\\n\\n  function payRegularFees(\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    StoreInterface store,\\n    uint256 time,\\n    FixedPoint.Unsigned memory collateralPool\\n  ) external returns (FixedPoint.Unsigned memory totalPaid) {\\n    if (collateralPool.isEqual(0)) {\\n      feePayerData.lastPaymentTime = time;\\n      return totalPaid;\\n    }\\n\\n    if (feePayerData.lastPaymentTime == time) {\\n      return totalPaid;\\n    }\\n\\n    FixedPoint.Unsigned memory regularFee;\\n    FixedPoint.Unsigned memory latePenalty;\\n\\n    (regularFee, latePenalty) = store.computeRegularFee(\\n      feePayerData.lastPaymentTime,\\n      time,\\n      collateralPool\\n    );\\n    feePayerData.lastPaymentTime = time;\\n\\n    totalPaid = regularFee.add(latePenalty);\\n    if (totalPaid.isEqual(0)) {\\n      return totalPaid;\\n    }\\n\\n    if (totalPaid.isGreaterThan(collateralPool)) {\\n      FixedPoint.Unsigned memory deficit = totalPaid.sub(collateralPool);\\n      FixedPoint.Unsigned memory latePenaltyReduction =\\n        FixedPoint.min(latePenalty, deficit);\\n      latePenalty = latePenalty.sub(latePenaltyReduction);\\n      deficit = deficit.sub(latePenaltyReduction);\\n      regularFee = regularFee.sub(FixedPoint.min(regularFee, deficit));\\n      totalPaid = collateralPool;\\n    }\\n\\n    emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\\n\\n    feePayerData.cumulativeFeeMultiplier._adjustCumulativeFeeMultiplier(\\n      totalPaid,\\n      collateralPool\\n    );\\n\\n    if (regularFee.isGreaterThan(0)) {\\n      feePayerData.collateralCurrency.safeIncreaseAllowance(\\n        address(store),\\n        regularFee.rawValue\\n      );\\n      store.payOracleFeesErc20(\\n        address(feePayerData.collateralCurrency),\\n        regularFee\\n      );\\n    }\\n\\n    if (latePenalty.isGreaterThan(0)) {\\n      feePayerData.collateralCurrency.safeTransfer(\\n        msg.sender,\\n        latePenalty.rawValue\\n      );\\n    }\\n    return totalPaid;\\n  }\\n\\n  function payFinalFees(\\n    FeePayerPoolParty.FeePayerData storage feePayerData,\\n    StoreInterface store,\\n    address payer,\\n    FixedPoint.Unsigned memory amount\\n  ) external {\\n    if (amount.isEqual(0)) {\\n      return;\\n    }\\n\\n    feePayerData.collateralCurrency.safeTransferFrom(\\n      payer,\\n      address(this),\\n      amount.rawValue\\n    );\\n\\n    emit FinalFeesPaid(amount.rawValue);\\n\\n    feePayerData.collateralCurrency.safeIncreaseAllowance(\\n      address(store),\\n      amount.rawValue\\n    );\\n    store.payOracleFeesErc20(address(feePayerData.collateralCurrency), amount);\\n  }\\n\\n  function getFeeAdjustedCollateral(\\n    FixedPoint.Unsigned memory rawCollateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external pure returns (FixedPoint.Unsigned memory collateral) {\\n    return rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n  }\\n\\n  function convertToRawCollateral(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external pure returns (FixedPoint.Unsigned memory rawCollateral) {\\n    return collateral._convertToRawCollateral(cumulativeFeeMultiplier);\\n  }\\n\\n  function removeCollateral(\\n    FixedPoint.Unsigned storage rawCollateral,\\n    FixedPoint.Unsigned memory collateralToRemove,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external returns (FixedPoint.Unsigned memory removedCollateral) {\\n    FixedPoint.Unsigned memory initialBalance =\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n    FixedPoint.Unsigned memory adjustedCollateral =\\n      collateralToRemove._convertToRawCollateral(cumulativeFeeMultiplier);\\n    rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\\n    removedCollateral = initialBalance.sub(\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\\n    );\\n  }\\n\\n  function addCollateral(\\n    FixedPoint.Unsigned storage rawCollateral,\\n    FixedPoint.Unsigned memory collateralToAdd,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) external returns (FixedPoint.Unsigned memory addedCollateral) {\\n    FixedPoint.Unsigned memory initialBalance =\\n      rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\\n    FixedPoint.Unsigned memory adjustedCollateral =\\n      collateralToAdd._convertToRawCollateral(cumulativeFeeMultiplier);\\n    rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\\n    addedCollateral = rawCollateral\\n      ._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\\n      .sub(initialBalance);\\n  }\\n\\n  function _adjustCumulativeFeeMultiplier(\\n    FixedPoint.Unsigned storage cumulativeFeeMultiplier,\\n    FixedPoint.Unsigned memory amount,\\n    FixedPoint.Unsigned memory currentPfc\\n  ) internal {\\n    FixedPoint.Unsigned memory effectiveFee = amount.divCeil(currentPfc);\\n    cumulativeFeeMultiplier.rawValue = cumulativeFeeMultiplier\\n      .mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee))\\n      .rawValue;\\n  }\\n\\n  function _getFeeAdjustedCollateral(\\n    FixedPoint.Unsigned memory rawCollateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) internal pure returns (FixedPoint.Unsigned memory collateral) {\\n    return rawCollateral.mul(cumulativeFeeMultiplier);\\n  }\\n\\n  function _convertToRawCollateral(\\n    FixedPoint.Unsigned memory collateral,\\n    FixedPoint.Unsigned memory cumulativeFeeMultiplier\\n  ) internal pure returns (FixedPoint.Unsigned memory rawCollateral) {\\n    return collateral.div(cumulativeFeeMultiplier);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ncontract Lockable {\\n  bool private _notEntered;\\n\\n  constructor() internal {\\n    _notEntered = true;\\n  }\\n\\n  modifier nonReentrant() {\\n    _preEntranceCheck();\\n    _preEntranceSet();\\n    _;\\n    _postEntranceReset();\\n  }\\n\\n  modifier nonReentrantView() {\\n    _preEntranceCheck();\\n    _;\\n  }\\n\\n  function _preEntranceCheck() internal view {\\n    require(_notEntered, 'ReentrancyGuard: reentrant call');\\n  }\\n\\n  function _preEntranceSet() internal {\\n    _notEntered = false;\\n  }\\n\\n  function _postEntranceReset() internal {\\n    _notEntered = true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Testable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport './Timer.sol';\\n\\nabstract contract Testable {\\n  address public timerAddress;\\n\\n  constructor(address _timerAddress) internal {\\n    timerAddress = _timerAddress;\\n  }\\n\\n  modifier onlyIfTest {\\n    require(timerAddress != address(0x0));\\n    _;\\n  }\\n\\n  function setCurrentTime(uint256 time) external onlyIfTest {\\n    Timer(timerAddress).setCurrentTime(time);\\n  }\\n\\n  function getCurrentTime() public view returns (uint256) {\\n    if (timerAddress != address(0x0)) {\\n      return Timer(timerAddress).getCurrentTime();\\n    } else {\\n      return now;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/StoreInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport '../../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../../common/implementation/FixedPoint.sol';\\n\\ninterface StoreInterface {\\n  function payOracleFees() external payable;\\n\\n  function payOracleFeesErc20(\\n    address erc20Address,\\n    FixedPoint.Unsigned calldata amount\\n  ) external;\\n\\n  function computeRegularFee(\\n    uint256 startTime,\\n    uint256 endTime,\\n    FixedPoint.Unsigned calldata pfc\\n  )\\n    external\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory regularFee,\\n      FixedPoint.Unsigned memory latePenalty\\n    );\\n\\n  function computeFinalFee(address currency)\\n    external\\n    view\\n    returns (FixedPoint.Unsigned memory);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/FinderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ninterface FinderInterface {\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Timer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ncontract Timer {\\n  uint256 private currentTime;\\n\\n  constructor() public {\\n    currentTime = now;\\n  }\\n\\n  function setCurrentTime(uint256 time) external {\\n    currentTime = time;\\n  }\\n\\n  function getCurrentTime() public view returns (uint256) {\\n    return currentTime;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary EnumerableSet {\\n  struct Set {\\n    bytes32[] _values;\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      bytes32 lastvalue = set._values[lastIndex];\\n\\n      set._values[toDeleteIndex] = lastvalue;\\n\\n      set._indexes[lastvalue] = toDeleteIndex + 1;\\n\\n      set._values.pop();\\n\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _contains(Set storage set, bytes32 value)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    require(set._values.length > index, 'EnumerableSet: index out of bounds');\\n    return set._values[index];\\n  }\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  function remove(Bytes32Set storage set, bytes32 value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, value);\\n  }\\n\\n  function contains(Bytes32Set storage set, bytes32 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, value);\\n  }\\n\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(Bytes32Set storage set, uint256 index)\\n    internal\\n    view\\n    returns (bytes32)\\n  {\\n    return _at(set._inner, index);\\n  }\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function remove(AddressSet storage set, address value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function contains(AddressSet storage set, address value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(AddressSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return address(uint256(_at(set._inner, index)));\\n  }\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  function contains(UintSet storage set, uint256 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(UintSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return uint256(_at(set._inner, index));\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/@jarvis-network/uma-core/contracts/financial-templates/common/FeePayerPoolPartyLib.sol\": {\r\n        \"FeePayerPoolPartyLib\": \"0xb0d0a057060c266b76b110c762471c91a80ed292\"\r\n      },\r\n      \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualLiquidatablePoolPartyLib.sol\": {\r\n        \"PerpetualLiquidatablePoolPartyLib\": \"0xa758f41c32db16bf9354ca230a9ec73edd0ad4c0\"\r\n      },\r\n      \"contracts/@jarvis-network/uma-core/contracts/financial-templates/perpetual-poolParty/PerpetualPositionManagerPoolPartyLib.sol\": {\r\n        \"PerpetualPositionManagerPoolPartyLib\": \"0xf953f99f6e3907d14658f906988eacdc08387aad\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"withdrawalLiveness\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"finderAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"priceFeedIdentifier\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"minSponsorTokens\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"timerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"excessTokenBeneficiary\",\"type\":\"address\"}],\"internalType\":\"struct PerpetualPositionManagerPoolParty.PositionManagerParams\",\"name\":\"positionManagerParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"admins\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"internalType\":\"struct PerpetualPositionManagerPoolParty.Roles\",\"name\":\"roles\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"liquidationLiveness\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"collateralRequirement\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"disputeBondPct\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"sponsorDisputeRewardPct\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"disputerDisputeRewardPct\",\"type\":\"tuple\"}],\"internalType\":\"struct PerpetualLiquidatablePoolParty.LiquidatableParams\",\"name\":\"liquidatableParams\",\"type\":\"tuple\"}],\"internalType\":\"struct PerpetualLiquidatablePoolParty.ConstructorParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"disputer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidationId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disputeSucceeded\",\"type\":\"bool\"}],\"name\":\"DisputeSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shutdownTimestamp\",\"type\":\"uint256\"}],\"name\":\"EmergencyShutdown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"EndedSponsorPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FinalFeesPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liquidationId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensOutstanding\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedCollateral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidatedCollateral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidationTime\",\"type\":\"uint256\"}],\"name\":\"LiquidationCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"disputer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidationId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"disputeBondAmount\",\"type\":\"uint256\"}],\"name\":\"LiquidationDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidToLiquidator\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidToDisputer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidToSponsor\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum PerpetualLiquidatablePoolParty.Status\",\"name\":\"liquidationStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"settlementPrice\",\"type\":\"uint256\"}],\"name\":\"LiquidationWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"NewSponsor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"PositionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"regularFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lateFee\",\"type\":\"uint256\"}],\"name\":\"RegularFeesPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"numTokensRepaid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newTokenCount\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"RequestWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"RequestWithdrawalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"RequestWithdrawalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralReturned\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokensBurned\",\"type\":\"uint256\"}],\"name\":\"SettleEmergencyShutdown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminAndPool\",\"type\":\"address\"}],\"name\":\"addAdminAndPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"addSyntheticTokenAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"addSyntheticTokenAdminAndMinterAndBurner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"addSyntheticTokenBurner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"addSyntheticTokenMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralCurrency\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"collateralAmount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"numTokens\",\"type\":\"tuple\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"minCollateralPerToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"maxCollateralPerToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"maxTokensToLiquidate\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"createLiquidation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidationId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"tokensLiquidated\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"finalFeeBond\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidationId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"deleteLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"deleteSponsorPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"collateralAmount\",\"type\":\"tuple\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"collateralAmount\",\"type\":\"tuple\"}],\"name\":\"depositTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidationId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"dispute\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"totalPaid\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyShutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyShutdownPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePayerData\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"collateralCurrency\",\"type\":\"address\"},{\"internalType\":\"contract FinderInterface\",\"name\":\"finder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastPaymentTime\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"cumulativeFeeMultiplier\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdminMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"getCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"collateralAmount\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalPositionData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"totalTokensOutstanding\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"rawTotalPositionCollateral\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidatableData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"rawLiquidationCollateral\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"liquidationLiveness\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"collateralRequirement\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"disputeBondPct\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"sponsorDisputeRewardPct\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"disputerDisputeRewardPct\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"enum PerpetualLiquidatablePoolParty.Status\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"liquidationTime\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"tokensOutstanding\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"lockedCollateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"liquidatedCollateral\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"rawUnitCollateral\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"disputer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"settlementPrice\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"finalFee\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"amount\",\"type\":\"tuple\"}],\"name\":\"payFinalFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payRegularFees\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"totalPaid\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pfc\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positionManagerData\",\"outputs\":[{\"internalType\":\"contract MintableBurnableIERC20\",\"name\":\"tokenCurrency\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalLiveness\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"minSponsorTokens\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"emergencyShutdownPrice\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"emergencyShutdownTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessTokenBeneficiary\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"positions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"tokensOutstanding\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalRequestPassTimestamp\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"withdrawalRequestAmount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"rawCollateral\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"numTokens\",\"type\":\"tuple\"}],\"name\":\"redeem\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"amountWithdrawn\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remargin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceAdminAndPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceSyntheticTokenAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceSyntheticTokenAdminAndMinterAndBurner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceSyntheticTokenBurner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceSyntheticTokenMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"numTokens\",\"type\":\"tuple\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"collateralAmount\",\"type\":\"tuple\"}],\"name\":\"requestWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setCurrentTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settleEmergencyShutdown\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"amountWithdrawn\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCurrency\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPositionCollateral\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"totalCollateral\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"trimExcess\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"amount\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"collateralAmount\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"amountWithdrawn\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidationId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"withdrawLiquidation\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"payToSponsor\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"payToLiquidator\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"payToDisputer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"paidToSponsor\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"paidToLiquidator\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"paidToDisputer\",\"type\":\"tuple\"}],\"internalType\":\"struct PerpetualLiquidatablePoolParty.RewardsData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawPassedRequest\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"amountWithdrawn\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PerpetualPoolParty","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000001c20000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000f17bc9a994b87b5225cfb6a2cd4d667adb4f20b00000000000000000000000040f941e48a552bf496b154af6bf55725f18d77c3455552555344000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000535ac9f9b46e515a3af364434061181a504d5bfb00000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000001c200000000000000000000000000000000000000000000000000f43fc2c04ee000000000000000000000000000000000000000000000000000000b1a2bc2ec5000000000000000000000000000000000000000000000000000006f05b59d3b2000000000000000000000000000000000000000000000000000002c68af0bb140000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000001000000000000000000000000592108f92f6e570f1a47f32c459a03c90ace05a70000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}