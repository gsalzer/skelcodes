{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/guillesalazar/Repos/PolyientGames/pgswap/core/contracts/PGTSnapshotVotesProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\n\\ncontract PGTSnapshotVotesProxy is WhitelistAdminRole {\\n    using SafeMath for uint256;\\n\\n    string public constant NAME_SYMBOL = \\\"PGT\\\";\\n    bytes32 public constant LP_TOKEN_RATIO_KEY = \\\"LpTokenRatio\\\";\\n    bytes32 public constant TOKEN_RATIO_KEY = \\\"TokenRatio\\\";\\n    uint8 public constant RATIO_MULTIPLIER = 100;\\n\\n    /**\\n        @notice This event is emitted when the lp token addresses are updated.\\n        @param sender the account which initialized the transaction.\\n        @param oldLpTokens the old lp token addresses.\\n        @param newLpTokens the new lp token addresses.\\n     */\\n    event LpTokensUpdated(\\n        address indexed sender,\\n        address[] indexed oldLpTokens,\\n        address[] indexed newLpTokens\\n    );\\n\\n    /**\\n        @notice This event is emitted when a ratio is updated.\\n        @param sender the account which initialized the transaction.\\n        @param oldRatio the old ratio.\\n        @param newRatio the new ratio\\n        @param key the field ratio key.\\n     */\\n    event RatioUpdated(\\n        address indexed sender,\\n        uint256 indexed oldRatio,\\n        uint256 indexed newRatio,\\n        bytes32 key\\n    );\\n\\n    /**\\n        @notice This event is emitted when the StakeToken reference is updated.\\n        @param sender The account which initialized the transaction.\\n        @param oldStakeToken the old stake token address.\\n        @param newStakeToken the new stake token address.\\n     */\\n    event StakeTokenUpdated(\\n        address indexed sender,\\n        address indexed oldStakeToken,\\n        address indexed newStakeToken\\n    );\\n\\n    IERC20 public token;\\n    address[] public lpTokens;\\n\\n    uint256 public tokenRatio;\\n    uint256 public lpTokenRatio;\\n\\n    constructor(\\n        address _tokenAddress,\\n        address[] memory _lpAddresses,\\n        uint256 _tokenRatio,\\n        uint256 _lpTokenRatio\\n    ) public {\\n        token = IERC20(_tokenAddress);\\n        lpTokens = _lpAddresses;\\n        tokenRatio = _tokenRatio;\\n        lpTokenRatio = _lpTokenRatio;\\n    }\\n\\n    /**\\n        @notice Gets the current LP tokens list.\\n        @return the current LP tokens list.\\n     */\\n    function getLpTokens() external view returns (address[] memory) {\\n        return lpTokens;\\n    }\\n\\n    /**\\n        @notice Sets the token ratio\\n        @param newTokenRatio the new token ratio.\\n     */\\n    function setTokenRatio(uint256 newTokenRatio) external onlyWhitelistAdmin() {\\n        require(tokenRatio != newTokenRatio, \\\"NEW_TOKEN_RATIO_REQUIRED\\\");\\n        uint256 oldTokenRatio = tokenRatio;\\n\\n        tokenRatio = newTokenRatio;\\n\\n        emit RatioUpdated(\\n            msg.sender,\\n            oldTokenRatio,\\n            newTokenRatio,\\n            TOKEN_RATIO_KEY\\n        );\\n    }\\n\\n    /**\\n        @notice Sets the LpToken ratio\\n        @param newLpTokenRatio the new lp token ratio.\\n     */\\n    function setLpTokenRatio(uint256 newLpTokenRatio) external onlyWhitelistAdmin() {\\n        require(lpTokenRatio != newLpTokenRatio, \\\"NEW_LP_TOKEN_RATIO_REQUIRED\\\");\\n        uint256 oldLpTokenRatio = lpTokenRatio;\\n\\n        lpTokenRatio = newLpTokenRatio;\\n\\n        emit RatioUpdated(\\n            msg.sender,\\n            oldLpTokenRatio,\\n            newLpTokenRatio,\\n            LP_TOKEN_RATIO_KEY\\n        );\\n    }\\n\\n    /**\\n        @notice Replaces the current lp token addresses with a new list of lp token addresses.\\n        @notice If you only need to add a new lp token address to the list, you need to:\\n            - Get the current list (calling the lpTokens() function).\\n            - Add the new lp address to your list.\\n            - And call this function again using the updated list.\\n        @param newLpTokens the new list of lp token addresses.\\n     */\\n    function setLpTokens(address[] calldata newLpTokens) external onlyWhitelistAdmin() {\\n        address[] memory oldLpTokens = newLpTokens;\\n\\n        lpTokens = newLpTokens;\\n\\n        emit LpTokensUpdated(\\n            msg.sender,\\n            oldLpTokens,\\n            newLpTokens\\n        );\\n    }\\n\\n    function decimals() external view returns (uint8) {\\n        return token.decimals();\\n    }\\n\\n    function name() external pure returns (string memory) {\\n        return NAME_SYMBOL;\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return NAME_SYMBOL;\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return token.totalSupply();\\n    }\\n\\n    /**\\n        @notice Gets the current ratios for the token and lp token.\\n        @return the current ratios for the token and lp token.\\n     */\\n    function getRatios() external view returns (uint256 currentTokenRatio, uint256 currentLpTokenRatio) {\\n        return (\\n            tokenRatio,\\n            lpTokenRatio\\n        );\\n    }\\n\\n    /**\\n        @notice Get the current balance (votes) for a given account.\\n        @dev Total Balance = Token Balance + Token Balance from Provided Liquidity\\n        @return the total token balance for a given account.\\n     */\\n    function balanceOf(address _voter) external view returns (uint256) {\\n        uint256 _votes = 0;\\n        // Count the balanceOf the TOKEN.\\n        _votes = token\\n                    .balanceOf(_voter)\\n                    .mul(tokenRatio)\\n                    .div(RATIO_MULTIPLIER);\\n\\n        // Counting the TOKEN balances from the provided liquidity.\\n        for(uint256 index = 0; index < lpTokens.length; index = index.add(1)) {\\n            address lpToken = lpTokens[index];\\n            _votes = _votes.add(\\n                    _getTokenBalanceFromProvidedLiquidity(lpToken, _voter)\\n                    .mul(lpTokenRatio)\\n                    .div(RATIO_MULTIPLIER)\\n                );\\n        }\\n\\n        return _votes;\\n    }\\n\\n    /**\\n        @notice Gets the token balances for a given account based on the LP token balance.\\n        @param lpToken address in order to calculate the token balances.\\n        @param account address to get the balances.\\n        @return token0 token 0 address.\\n        @return balance0 token 0 balance for the given account.\\n        @return token1 token 1 address.\\n        @return balance1 token 1 balance for the given account.\\n     */\\n    function getTokenBalancesFromProvidedLiquidity(address lpToken,  address account) external view returns (address token0, uint256 balance0, address token1, uint256 balance1) {\\n        return _getTokenBalancesFromProvidedLiquidity(IUniswapV2Pair(lpToken), account);\\n    }\\n\\n    /**\\n        @notice It gets the token balance based on the provided liquidity (LP tokens) for a given account.\\n        @param account address to get the token balance.\\n        @return the current token balance based on the LP tokens on the market/pair.\\n     */\\n    function _getTokenBalanceFromProvidedLiquidity(address lpToken, address account) internal view returns (uint256) {\\n        (\\n            address token0,\\n            uint256 balance0,\\n            address token1,\\n            uint256 balance1\\n        ) = _getTokenBalancesFromProvidedLiquidity(\\n            IUniswapV2Pair(lpToken),\\n            account\\n        );\\n\\n        if(address(token) == token0) {\\n            return balance0;\\n        }\\n        if(address(token) == token1) {\\n            return balance1;\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n        @notice Gets the token balances for a given account based on the LP token balance.\\n        @param account address to get the balances.\\n        @return token0 token 0 address.\\n        @return balance0 token 0 balance for the given account.\\n        @return token1 token 1 address.\\n        @return balance1 token 1 balance for the given account.\\n     */\\n    function _getTokenBalancesFromProvidedLiquidity(IUniswapV2Pair lpToken, address account) internal view returns (address token0, uint256 balance0, address token1, uint256 balance1) {\\n        uint256 lpTotalSupply = lpToken.totalSupply();\\n        (uint112 reserve0, uint112 reserve1,) = lpToken.getReserves();\\n        uint256 accountLpBalance = lpToken.balanceOf(account);\\n\\n        token0 = lpToken.token0();\\n        token1 = lpToken.token1();\\n        if(lpTotalSupply == 0) {\\n            balance0 = 0;\\n            balance1 = 0;\\n        } else {\\n            balance0 = accountLpBalance\\n                .mul(uint256(reserve0))\\n                .div(lpTotalSupply);\\n            balance1 = accountLpBalance\\n                .mul(uint256(reserve1))\\n                .div(lpTotalSupply);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/guillesalazar/Repos/PolyientGames/pgswap/core/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/Users/guillesalazar/Repos/PolyientGames/pgswap/core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"/Users/guillesalazar/Repos/PolyientGames/pgswap/core/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Roles.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"../Roles.sol\\\";\\n\\n/**\\n * @title WhitelistAdminRole\\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\\n */\\ncontract WhitelistAdminRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event WhitelistAdminAdded(address indexed account);\\n    event WhitelistAdminRemoved(address indexed account);\\n\\n    Roles.Role private _whitelistAdmins;\\n\\n    constructor () internal {\\n        _addWhitelistAdmin(_msgSender());\\n    }\\n\\n    modifier onlyWhitelistAdmin() {\\n        require(isWhitelistAdmin(_msgSender()), \\\"WhitelistAdminRole: caller does not have the WhitelistAdmin role\\\");\\n        _;\\n    }\\n\\n    function isWhitelistAdmin(address account) public view returns (bool) {\\n        return _whitelistAdmins.has(account);\\n    }\\n\\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\\n        _addWhitelistAdmin(account);\\n    }\\n\\n    function renounceWhitelistAdmin() public {\\n        _removeWhitelistAdmin(_msgSender());\\n    }\\n\\n    function _addWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.add(account);\\n        emit WhitelistAdminAdded(account);\\n    }\\n\\n    function _removeWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.remove(account);\\n        emit WhitelistAdminRemoved(account);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_lpAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_tokenRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpTokenRatio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"oldLpTokens\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"newLpTokens\",\"type\":\"address[]\"}],\"name\":\"LpTokensUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldRatio\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"RatioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldStakeToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newStakeToken\",\"type\":\"address\"}],\"name\":\"StakeTokenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"LP_TOKEN_RATIO_KEY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME_SYMBOL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATIO_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_RATIO_KEY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLpTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRatios\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTokenRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLpTokenRatio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTokenBalancesFromProvidedLiquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance0\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lpTokenRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lpTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLpTokenRatio\",\"type\":\"uint256\"}],\"name\":\"setLpTokenRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newLpTokens\",\"type\":\"address[]\"}],\"name\":\"setLpTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenRatio\",\"type\":\"uint256\"}],\"name\":\"setTokenRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PGTSnapshotVotesProxy","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000eaccb6e0f24d66cf4aa6cbda33971b9231d332a10000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000cebeca2f22080a7eb1c810e8a3ed42bbcff233c6","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}