{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/components/Owned.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\r\n///  later changed\r\ncontract Owned {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    function transferOwner(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"New owner is the zero address\");\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    ///  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/components/Admin.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\ncontract Admin is Owned {\r\n    mapping(address => bool) public mapAdmin;\r\n\r\n    event AddAdmin(address admin);\r\n    event RemoveAdmin(address admin);\r\n\r\n    modifier onlyAdmin() {\r\n        require(mapAdmin[msg.sender], \"not admin\");\r\n        _;\r\n    }\r\n\r\n    function addAdmin(\r\n        address admin\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        mapAdmin[admin] = true;\r\n\r\n        emit AddAdmin(admin);\r\n    }\r\n\r\n    function removeAdmin(\r\n        address admin\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        delete mapAdmin[admin];\r\n\r\n        emit RemoveAdmin(admin);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/BasicStorageLib.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary BasicStorageLib {\r\n\r\n    struct UintData {\r\n        mapping(bytes => mapping(bytes => uint))           _storage;\r\n    }\r\n\r\n    struct BoolData {\r\n        mapping(bytes => mapping(bytes => bool))           _storage;\r\n    }\r\n\r\n    struct AddressData {\r\n        mapping(bytes => mapping(bytes => address))        _storage;\r\n    }\r\n\r\n    struct BytesData {\r\n        mapping(bytes => mapping(bytes => bytes))          _storage;\r\n    }\r\n\r\n    struct StringData {\r\n        mapping(bytes => mapping(bytes => string))         _storage;\r\n    }\r\n\r\n    /* uintStorage */\r\n\r\n    function setStorage(UintData storage self, bytes memory key, bytes memory innerKey, uint value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(UintData storage self, bytes memory key, bytes memory innerKey) internal view returns (uint) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(UintData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* boolStorage */\r\n\r\n    function setStorage(BoolData storage self, bytes memory key, bytes memory innerKey, bool value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(BoolData storage self, bytes memory key, bytes memory innerKey) internal view returns (bool) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(BoolData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* addressStorage */\r\n\r\n    function setStorage(AddressData storage self, bytes memory key, bytes memory innerKey, address value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(AddressData storage self, bytes memory key, bytes memory innerKey) internal view returns (address) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(AddressData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* bytesStorage */\r\n\r\n    function setStorage(BytesData storage self, bytes memory key, bytes memory innerKey, bytes memory value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(BytesData storage self, bytes memory key, bytes memory innerKey) internal view returns (bytes memory) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(BytesData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* stringStorage */\r\n\r\n    function setStorage(StringData storage self, bytes memory key, bytes memory innerKey, string memory value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(StringData storage self, bytes memory key, bytes memory innerKey) internal view returns (string memory) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(StringData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/components/BasicStorage.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract BasicStorage {\r\n    /************************************************************\r\n     **\r\n     ** VARIABLES\r\n     **\r\n     ************************************************************/\r\n\r\n    //// basic variables\r\n    using BasicStorageLib for BasicStorageLib.UintData;\r\n    using BasicStorageLib for BasicStorageLib.BoolData;\r\n    using BasicStorageLib for BasicStorageLib.AddressData;\r\n    using BasicStorageLib for BasicStorageLib.BytesData;\r\n    using BasicStorageLib for BasicStorageLib.StringData;\r\n\r\n    BasicStorageLib.UintData    internal uintData;\r\n    BasicStorageLib.BoolData    internal boolData;\r\n    BasicStorageLib.AddressData internal addressData;\r\n    BasicStorageLib.BytesData   internal bytesData;\r\n    BasicStorageLib.StringData  internal stringData;\r\n}\r\n\r\n// File: contracts/tokenManager/TokenManagerStorage.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\ncontract TokenManagerStorage is BasicStorage {\r\n    /************************************************************\r\n     **\r\n     ** STRUCTURE DEFINATIONS\r\n     **\r\n     ************************************************************/\r\n\r\n    struct AncestorInfo {\r\n      bytes   account;\r\n      string  name;\r\n      string  symbol;\r\n      uint8   decimals;\r\n      uint    chainID;\r\n    }\r\n\r\n    struct TokenPairInfo {\r\n      AncestorInfo aInfo;               /// TODO:\r\n      uint      fromChainID;            /// index in coinType.txt; e.g. eth=60, etc=61, wan=5718350\r\n      bytes     fromAccount;            /// from address\r\n      uint      toChainID;              ///\r\n      bytes     toAccount;              /// to token address\r\n    }\r\n    \r\n    struct TokenPairInfoFull {\r\n      uint      id;\r\n      AncestorInfo aInfo;\r\n      uint      fromChainID;\r\n      bytes     fromAccount;\r\n      uint      toChainID;\r\n      bytes     toAccount;\r\n    }\r\n\r\n\r\n    /************************************************************\r\n     **\r\n     ** VARIABLES\r\n     **\r\n     ************************************************************/\r\n\r\n    /// total amount of TokenPair instance\r\n    uint public totalTokenPairs = 0;\r\n\r\n    /// a map from a sequence ID to token pair\r\n    mapping(uint => TokenPairInfo) public mapTokenPairInfo;\r\n    // index -> tokenPairId\r\n    mapping(uint => uint) public mapTokenPairIndex;\r\n}\r\n\r\n// File: contracts/components/WRC20Protocol.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\ncontract WRC20Protocol {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint supply);\r\n    is replaced with:\r\n    uint public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n\r\n    /**************************************\r\n     **\r\n     ** VARIABLES\r\n     **\r\n     **************************************/\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    /// total amount of tokens\r\n    uint public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath mul overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath div 0\"); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath sub b > a\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath add overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath mod 0\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/components/StandardToken.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\ncontract StandardToken is WRC20Protocol {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n    * @dev Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4, \"Payload size is incorrect\");\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) returns (bool success) {\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) returns (bool success) {\r\n        //  To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0), \"Not permitted\");\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n// File: contracts/tokenManager/MappingToken.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\ncontract MappingToken is StandardToken, Owned {\r\n    using SafeMath for uint;\r\n    /****************************************************************************\r\n     **\r\n     ** MODIFIERS\r\n     **\r\n     ****************************************************************************/\r\n    modifier onlyMeaningfulValue(uint value) {\r\n        require(value > 0, \"Value is null\");\r\n        _;\r\n    }\r\n\r\n    /****************************************************************************\r\n     **\r\n     ** EVENTS\r\n     **\r\n     ****************************************************************************/\r\n\r\n    ///@notice Initialize the TokenManager address\r\n    ///@dev Initialize the TokenManager address\r\n    ///@param tokenName The token name to be used\r\n    ///@param tokenSymbol The token symbol to be used\r\n    ///@param tokenDecimal The token decimals to be used\r\n    constructor(string tokenName, string tokenSymbol, uint8 tokenDecimal)\r\n        public\r\n    {\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = tokenDecimal;\r\n    }\r\n\r\n    /****************************************************************************\r\n     **\r\n     ** MANIPULATIONS\r\n     **\r\n     ****************************************************************************/\r\n\r\n    /// @notice Create token\r\n    /// @dev Create token\r\n    /// @param account Address will receive token\r\n    /// @param value Amount of token to be minted\r\n    function mint(address account, uint value)\r\n        external\r\n        onlyOwner\r\n        onlyMeaningfulValue(value)\r\n    {\r\n        balances[account] = balances[account].add(value);\r\n        totalSupply = totalSupply.add(value);\r\n\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /// @notice Burn token\r\n    /// @dev Burn token\r\n    /// @param account Address of whose token will be burnt\r\n    /// @param value Amount of token to be burnt\r\n    function burn(address account, uint value)\r\n        external\r\n        onlyOwner\r\n        onlyMeaningfulValue(value)\r\n    {\r\n        balances[account] = balances[account].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /// @notice update token name, symbol\r\n    /// @dev update token name, symbol\r\n    /// @param _name token new name\r\n    /// @param _symbol token new symbol\r\n    function update(string _name, string _symbol)\r\n        external\r\n        onlyOwner\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n}\r\n\r\n// File: contracts/tokenManager/IMappingToken.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\ninterface IMappingToken {\r\n    function changeOwner(address _newOwner) external;\r\n    function acceptOwnership() external;\r\n    function transferOwner(address) external;\r\n    function name() external view returns (string);\r\n    function symbol() external view returns (string);\r\n    function decimals() external view returns (uint8);\r\n    function mint(address, uint) external;\r\n    function burn(address, uint) external;\r\n    function update(string, string) external;\r\n}\r\n\r\n// File: contracts/tokenManager/TokenManagerDelegate.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity 0.4.26;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenManagerDelegate is TokenManagerStorage, Admin {\r\n    using SafeMath for uint;\r\n    /************************************************************\r\n     **\r\n     ** EVENTS\r\n     **\r\n     ************************************************************/\r\n\r\n     event AddToken(address tokenAddress, string name, string symbol, uint8 decimals);\r\n     event AddTokenPair(uint indexed id, uint fromChainID, bytes fromAccount, uint toChainID, bytes toAccount);\r\n     event UpdateTokenPair(uint indexed id, AncestorInfo aInfo, uint fromChainID, bytes fromAccount, uint toChainID, bytes toAccount);\r\n     event RemoveTokenPair(uint indexed id);\r\n     event UpdateToken(address tokenAddress, string name, string symbol);\r\n\r\n    /**\r\n     *\r\n     * MODIFIERS\r\n     *\r\n     */\r\n\r\n    modifier onlyNotExistID(uint id) {\r\n        require(mapTokenPairInfo[id].fromChainID == 0, \"token exist\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyExistID(uint id) {\r\n        require(mapTokenPairInfo[id].fromChainID > 0, \"token not exist\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *\r\n    * MANIPULATIONS\r\n    *\r\n    */\r\n    \r\n    function bytesToAddress(bytes b) internal pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(b,20))\r\n        }\r\n    }\r\n\r\n    function mintToken(\r\n        address tokenAddress,\r\n        address to,\r\n        uint    value\r\n    )\r\n        external\r\n        onlyAdmin\r\n    {\r\n        IMappingToken(tokenAddress).mint(to, value);\r\n    }\r\n\r\n    function burnToken(\r\n        address tokenAddress,\r\n        address from,\r\n        uint    value\r\n    )\r\n        external\r\n        onlyAdmin\r\n    {\r\n        IMappingToken(tokenAddress).burn(from, value);\r\n    }\r\n\r\n    function addToken(\r\n        string name,\r\n        string symbol,\r\n        uint8 decimals\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        address tokenAddress = new MappingToken(name, symbol, decimals);\r\n        \r\n        emit AddToken(tokenAddress, name, symbol, decimals);\r\n    }\r\n\r\n    function addTokenPair(\r\n        uint    id,\r\n\r\n        AncestorInfo aInfo,\r\n\r\n        uint    fromChainID,\r\n        bytes   fromAccount,\r\n        uint    toChainID,\r\n        bytes   toAccount\r\n    )\r\n        public\r\n        onlyOwner\r\n        onlyNotExistID(id)\r\n    {\r\n        // create a new record\r\n        mapTokenPairInfo[id].fromChainID = fromChainID;\r\n        mapTokenPairInfo[id].fromAccount = fromAccount;\r\n        mapTokenPairInfo[id].toChainID = toChainID;\r\n        mapTokenPairInfo[id].toAccount = toAccount;\r\n\r\n        mapTokenPairInfo[id].aInfo.account = aInfo.account;\r\n        mapTokenPairInfo[id].aInfo.name = aInfo.name;\r\n        mapTokenPairInfo[id].aInfo.symbol = aInfo.symbol;\r\n        mapTokenPairInfo[id].aInfo.decimals = aInfo.decimals;\r\n        mapTokenPairInfo[id].aInfo.chainID = aInfo.chainID;\r\n\r\n        mapTokenPairIndex[totalTokenPairs] = id;\r\n        totalTokenPairs = totalTokenPairs.add(1);\r\n\r\n        // fire event\r\n        emit AddTokenPair(id, fromChainID, fromAccount, toChainID, toAccount);\r\n    }\r\n\r\n    function updateTokenPair(\r\n        uint    id,\r\n\r\n        AncestorInfo aInfo,\r\n\r\n        uint    fromChainID,\r\n        bytes   fromAccount,\r\n        uint    toChainID,\r\n        bytes   toAccount\r\n    )\r\n        public\r\n        onlyOwner\r\n        onlyExistID(id)\r\n    {\r\n        mapTokenPairInfo[id].aInfo.account = aInfo.account;\r\n        mapTokenPairInfo[id].aInfo.name = aInfo.name;\r\n        mapTokenPairInfo[id].aInfo.symbol = aInfo.symbol;\r\n        mapTokenPairInfo[id].aInfo.decimals = aInfo.decimals;\r\n        mapTokenPairInfo[id].aInfo.chainID = aInfo.chainID;\r\n\r\n        mapTokenPairInfo[id].fromChainID = fromChainID;\r\n        mapTokenPairInfo[id].fromAccount = fromAccount;\r\n        mapTokenPairInfo[id].toChainID = toChainID;\r\n        mapTokenPairInfo[id].toAccount = toAccount;\r\n\r\n        emit UpdateTokenPair(id, aInfo, fromChainID, fromAccount, toChainID, toAccount);\r\n    }\r\n\r\n    function removeTokenPair(\r\n        uint id\r\n    )\r\n        external\r\n        onlyOwner\r\n        onlyExistID(id)\r\n    {\r\n        for(uint i=0; i<totalTokenPairs; i++) {\r\n            if (id == mapTokenPairIndex[i]) {\r\n                if (i != totalTokenPairs - 1) {\r\n                    mapTokenPairIndex[i] = mapTokenPairIndex[totalTokenPairs - 1];\r\n                }\r\n \r\n                delete mapTokenPairIndex[totalTokenPairs - 1];\r\n                totalTokenPairs--;\r\n                delete mapTokenPairInfo[id];\r\n                emit RemoveTokenPair(id);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateToken(address tokenAddress, string name, string symbol)\r\n        external\r\n        onlyOwner\r\n    {\r\n        IMappingToken(tokenAddress).update(name, symbol);\r\n\r\n        emit UpdateToken(tokenAddress, name, symbol);\r\n    }\r\n\r\n    function changeTokenOwner(address tokenAddress, address _newOwner) external onlyOwner {\r\n        IMappingToken(tokenAddress).changeOwner(_newOwner);\r\n    }\r\n\r\n    function acceptTokenOwnership(address tokenAddress) external {\r\n        IMappingToken(tokenAddress).acceptOwnership();\r\n    }\r\n\r\n    function transferTokenOwner(address tokenAddress, address _newOwner) external onlyOwner {\r\n        IMappingToken(tokenAddress).transferOwner(_newOwner);\r\n    }\r\n\r\n    function getTokenPairInfo(\r\n        uint id\r\n    )\r\n        external\r\n        view\r\n        returns (uint fromChainID, bytes fromAccount, uint toChainID, bytes toAccount)\r\n    {\r\n        fromChainID = mapTokenPairInfo[id].fromChainID;\r\n        fromAccount = mapTokenPairInfo[id].fromAccount;\r\n        toChainID = mapTokenPairInfo[id].toChainID;\r\n        toAccount = mapTokenPairInfo[id].toAccount;\r\n    }\r\n\r\n    function getTokenPairInfoSlim(\r\n        uint id\r\n    )\r\n        external\r\n        view\r\n        returns (uint fromChainID, bytes fromAccount, uint toChainID)\r\n    {\r\n        fromChainID = mapTokenPairInfo[id].fromChainID;\r\n        fromAccount = mapTokenPairInfo[id].fromAccount;\r\n        toChainID = mapTokenPairInfo[id].toChainID;\r\n    }\r\n\r\n    function getTokenInfo(uint id) external view returns (address addr, string name, string symbol, uint8 decimals) {\r\n        if (mapTokenPairInfo[id].fromChainID == 0) {\r\n            name = '';\r\n            symbol = '';\r\n            decimals = 0;\r\n            addr = address(0);\r\n        } else {\r\n            address instance = bytesToAddress(mapTokenPairInfo[id].toAccount);\r\n            name = IMappingToken(instance).name();\r\n            symbol = IMappingToken(instance).symbol();\r\n            decimals = IMappingToken(instance).decimals();\r\n            addr = instance;\r\n        }\r\n    }\r\n\r\n    function getAncestorInfo(uint id) external view returns (bytes account, string name, string symbol, uint8 decimals, uint chainId) {\r\n        account = mapTokenPairInfo[id].aInfo.account;\r\n        name = mapTokenPairInfo[id].aInfo.name;\r\n        symbol = mapTokenPairInfo[id].aInfo.symbol;\r\n        decimals = mapTokenPairInfo[id].aInfo.decimals;\r\n        chainId = mapTokenPairInfo[id].aInfo.chainID;\r\n    }\r\n\r\n    function getAncestorSymbol(uint id) external view returns (string symbol, uint8 decimals) {\r\n        symbol = mapTokenPairInfo[id].aInfo.symbol;\r\n        decimals = mapTokenPairInfo[id].aInfo.decimals;\r\n    }\r\n\r\n    function getAncestorChainID(uint id) external view returns (uint chainID) {\r\n        chainID = mapTokenPairInfo[id].aInfo.chainID;\r\n    }\r\n\r\n    // function getTokenPairsFullFields()\r\n    //     external\r\n    //     view\r\n    //     returns (TokenPairInfoFull[] tokenPairs)\r\n    // {\r\n    //     tokenPairs = new TokenPairInfoFull[](totalTokenPairs);\r\n    //     for (uint i = 0; i < totalTokenPairs; i++) {\r\n    //         uint theId = mapTokenPairIndex[i];\r\n    //         tokenPairs[i].aInfo = mapTokenPairInfo[theId].aInfo;\r\n    //         tokenPairs[i].fromChainID = mapTokenPairInfo[theId].fromChainID;\r\n    //         tokenPairs[i].fromAccount = mapTokenPairInfo[theId].fromAccount;\r\n    //         tokenPairs[i].toChainID = mapTokenPairInfo[theId].toChainID;\r\n    //         tokenPairs[i].toAccount = mapTokenPairInfo[theId].toAccount;\r\n    //         tokenPairs[i].id = theId;\r\n    //     }\r\n    //     return tokenPairs;\r\n    // }\r\n\r\n    // function getTokenPairsByChainID2(uint chainID1, uint chainID2)\r\n    //     external\r\n    //     view\r\n    //     returns (TokenPairInfoFull[] tokenPairs)\r\n    // {\r\n    //     uint cnt = 0;\r\n    //     uint i = 0;\r\n    //     uint theId = 0;\r\n    //     uint[] memory id_valid = new uint[](totalTokenPairs);\r\n    //     for (; i < totalTokenPairs; i++ ) {\r\n    //         theId = mapTokenPairIndex[i];\r\n    //         if ((mapTokenPairInfo[theId].fromChainID == chainID1) && (mapTokenPairInfo[theId].toChainID == chainID2) ||\r\n    //         (mapTokenPairInfo[theId].toChainID == chainID1) && (mapTokenPairInfo[theId].fromChainID == chainID2)) {\r\n    //             id_valid[cnt] = theId;\r\n    //             cnt ++;\r\n    //         }\r\n    //     }\r\n\r\n    //     tokenPairs = new TokenPairInfoFull[](cnt);\r\n    //     for (i = 0; i < cnt; i++) {\r\n    //         theId = id_valid[i];\r\n    //         tokenPairs[i].aInfo = mapTokenPairInfo[theId].aInfo;\r\n    //         tokenPairs[i].fromChainID = mapTokenPairInfo[theId].fromChainID;\r\n    //         tokenPairs[i].fromAccount = mapTokenPairInfo[theId].fromAccount;\r\n    //         tokenPairs[i].toChainID = mapTokenPairInfo[theId].toChainID;\r\n    //         tokenPairs[i].toAccount = mapTokenPairInfo[theId].toAccount;\r\n    //         tokenPairs[i].id = theId;\r\n    //     }\r\n    // }\r\n\r\n    function getTokenPairs()\r\n        external\r\n        view\r\n        returns (uint[] id, uint[] fromChainID, bytes[] fromAccount, uint[] toChainID, bytes[] toAccount,\r\n          string[] ancestorSymbol, uint8[] ancestorDecimals, bytes[] ancestorAccount, string[] ancestorName, uint[] ancestorChainID)\r\n    {\r\n        uint cnt = totalTokenPairs;\r\n        uint theId = 0;\r\n        uint i = 0;\r\n\r\n        id = new uint[](cnt);\r\n        fromChainID = new uint[](cnt);\r\n        fromAccount = new bytes[](cnt);\r\n        toChainID = new uint[](cnt);\r\n        toAccount = new bytes[](cnt);\r\n\r\n        ancestorSymbol = new string[](cnt);\r\n        ancestorDecimals = new uint8[](cnt);\r\n\r\n        ancestorAccount = new bytes[](cnt);\r\n        ancestorName = new string[](cnt);\r\n        ancestorChainID = new uint[](cnt);\r\n\r\n        i = 0;\r\n        theId = 0;\r\n        uint j = 0;\r\n        for (; j < totalTokenPairs; j++) {\r\n            theId = mapTokenPairIndex[j];\r\n            id[i] = theId;\r\n            fromChainID[i] = mapTokenPairInfo[theId].fromChainID;\r\n            fromAccount[i] = mapTokenPairInfo[theId].fromAccount;\r\n            toChainID[i] = mapTokenPairInfo[theId].toChainID;\r\n            toAccount[i] = mapTokenPairInfo[theId].toAccount;\r\n\r\n            ancestorSymbol[i] = mapTokenPairInfo[theId].aInfo.symbol;\r\n            ancestorDecimals[i] = mapTokenPairInfo[theId].aInfo.decimals;\r\n\r\n            ancestorAccount[i] = mapTokenPairInfo[theId].aInfo.account;\r\n            ancestorName[i] = mapTokenPairInfo[theId].aInfo.name;\r\n            ancestorChainID[i] = mapTokenPairInfo[theId].aInfo.chainID;\r\n            i ++;\r\n        }\r\n    }\r\n\r\n    function getTokenPairsByChainID(uint chainID1, uint chainID2)\r\n        external\r\n        view\r\n        returns (uint[] id, uint[] fromChainID, bytes[] fromAccount, uint[] toChainID, bytes[] toAccount,\r\n          string[] ancestorSymbol, uint8[] ancestorDecimals, bytes[] ancestorAccount, string[] ancestorName, uint[] ancestorChainID)\r\n    {\r\n        uint cnt = 0;\r\n        uint i = 0;\r\n        uint theId = 0;\r\n        uint[] memory id_valid = new uint[](totalTokenPairs);\r\n        for (; i < totalTokenPairs; i++ ) {\r\n            theId = mapTokenPairIndex[i];\r\n            if ((mapTokenPairInfo[theId].fromChainID == chainID1) && (mapTokenPairInfo[theId].toChainID == chainID2) ||\r\n            (mapTokenPairInfo[theId].toChainID == chainID1) && (mapTokenPairInfo[theId].fromChainID == chainID2)) {\r\n                id_valid[cnt] = theId;\r\n                cnt ++;\r\n            }\r\n        }\r\n\r\n        id = new uint[](cnt);\r\n        fromChainID = new uint[](cnt);\r\n        fromAccount = new bytes[](cnt);\r\n        toChainID = new uint[](cnt);\r\n        toAccount = new bytes[](cnt);\r\n\r\n        ancestorSymbol = new string[](cnt);\r\n        ancestorDecimals = new uint8[](cnt);\r\n\r\n        ancestorAccount = new bytes[](cnt);\r\n        ancestorName = new string[](cnt);\r\n        ancestorChainID = new uint[](cnt);\r\n\r\n        for (i = 0; i < cnt; i++) {\r\n            theId = id_valid[i];\r\n\r\n            id[i] = theId;\r\n            fromChainID[i] = mapTokenPairInfo[theId].fromChainID;\r\n            fromAccount[i] = mapTokenPairInfo[theId].fromAccount;\r\n            toChainID[i] = mapTokenPairInfo[theId].toChainID;\r\n            toAccount[i] = mapTokenPairInfo[theId].toAccount;\r\n\r\n            ancestorSymbol[i] = mapTokenPairInfo[theId].aInfo.symbol;\r\n            ancestorDecimals[i] = mapTokenPairInfo[theId].aInfo.decimals;\r\n            \r\n            ancestorAccount[i] = mapTokenPairInfo[theId].aInfo.account;\r\n            ancestorName[i] = mapTokenPairInfo[theId].aInfo.name;\r\n            ancestorChainID[i] = mapTokenPairInfo[theId].aInfo.chainID;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"removeTokenPair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenPairInfoSlim\",\"outputs\":[{\"name\":\"fromChainID\",\"type\":\"uint256\"},{\"name\":\"fromAccount\",\"type\":\"bytes\"},{\"name\":\"toChainID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"acceptTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferTokenOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeTokenOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"account\",\"type\":\"bytes\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"chainID\",\"type\":\"uint256\"}],\"name\":\"aInfo\",\"type\":\"tuple\"},{\"name\":\"fromChainID\",\"type\":\"uint256\"},{\"name\":\"fromAccount\",\"type\":\"bytes\"},{\"name\":\"toChainID\",\"type\":\"uint256\"},{\"name\":\"toAccount\",\"type\":\"bytes\"}],\"name\":\"addTokenPair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"chainID1\",\"type\":\"uint256\"},{\"name\":\"chainID2\",\"type\":\"uint256\"}],\"name\":\"getTokenPairsByChainID\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256[]\"},{\"name\":\"fromChainID\",\"type\":\"uint256[]\"},{\"name\":\"fromAccount\",\"type\":\"bytes[]\"},{\"name\":\"toChainID\",\"type\":\"uint256[]\"},{\"name\":\"toAccount\",\"type\":\"bytes[]\"},{\"name\":\"ancestorSymbol\",\"type\":\"string[]\"},{\"name\":\"ancestorDecimals\",\"type\":\"uint8[]\"},{\"name\":\"ancestorAccount\",\"type\":\"bytes[]\"},{\"name\":\"ancestorName\",\"type\":\"string[]\"},{\"name\":\"ancestorChainID\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapTokenPairIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapTokenPairInfo\",\"outputs\":[{\"components\":[{\"name\":\"account\",\"type\":\"bytes\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"chainID\",\"type\":\"uint256\"}],\"name\":\"aInfo\",\"type\":\"tuple\"},{\"name\":\"fromChainID\",\"type\":\"uint256\"},{\"name\":\"fromAccount\",\"type\":\"bytes\"},{\"name\":\"toChainID\",\"type\":\"uint256\"},{\"name\":\"toAccount\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"account\",\"type\":\"bytes\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"chainID\",\"type\":\"uint256\"}],\"name\":\"aInfo\",\"type\":\"tuple\"},{\"name\":\"fromChainID\",\"type\":\"uint256\"},{\"name\":\"fromAccount\",\"type\":\"bytes\"},{\"name\":\"toChainID\",\"type\":\"uint256\"},{\"name\":\"toAccount\",\"type\":\"bytes\"}],\"name\":\"updateTokenPair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAncestorInfo\",\"outputs\":[{\"name\":\"account\",\"type\":\"bytes\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"chainId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"updateToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenPairInfo\",\"outputs\":[{\"name\":\"fromChainID\",\"type\":\"uint256\"},{\"name\":\"fromAccount\",\"type\":\"bytes\"},{\"name\":\"toChainID\",\"type\":\"uint256\"},{\"name\":\"toAccount\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenPairs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAncestorSymbol\",\"outputs\":[{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenPairs\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256[]\"},{\"name\":\"fromChainID\",\"type\":\"uint256[]\"},{\"name\":\"fromAccount\",\"type\":\"bytes[]\"},{\"name\":\"toChainID\",\"type\":\"uint256[]\"},{\"name\":\"toAccount\",\"type\":\"bytes[]\"},{\"name\":\"ancestorSymbol\",\"type\":\"string[]\"},{\"name\":\"ancestorDecimals\",\"type\":\"uint8[]\"},{\"name\":\"ancestorAccount\",\"type\":\"bytes[]\"},{\"name\":\"ancestorName\",\"type\":\"string[]\"},{\"name\":\"ancestorChainID\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAncestorChainID\",\"outputs\":[{\"name\":\"chainID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"AddToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fromChainID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fromAccount\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"toChainID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toAccount\",\"type\":\"bytes\"}],\"name\":\"AddTokenPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"account\",\"type\":\"bytes\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"chainID\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"aInfo\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"fromChainID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fromAccount\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"toChainID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toAccount\",\"type\":\"bytes\"}],\"name\":\"UpdateTokenPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"RemoveTokenPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"UpdateToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AddAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"RemoveAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenManagerDelegate","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5928ff7306265bf144556be7dbf86563ab3ba908580420d043fa8791bb2da553"}]}