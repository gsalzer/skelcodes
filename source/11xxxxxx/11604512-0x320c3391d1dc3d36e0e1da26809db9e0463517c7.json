{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/SIInterface.sol\r\n\r\ninterface SIInterface  {\r\n\tfunction setCircuitBreakWithOwner(bool emergency) external returns (bool);\r\n\tfunction setCircuitBreaker(bool emergency) external returns (bool);\r\n\r\n\tfunction updateRewardPerBlockLogic(uint256 _rewardPerBlock) external returns (bool);\r\n\tfunction updateRewardLane(address payable userAddr) external returns (bool);\r\n\r\n\tfunction getBetaRateBaseTotalAmount() external view returns (uint256);\r\n\tfunction getBetaRateBaseUserAmount(address payable userAddr) external view returns (uint256);\r\n\r\n\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\r\n\r\n\tfunction getUserRewardInfo(address payable userAddr) external view returns (uint256, uint256, uint256);\r\n}\r\n\r\n// File: contracts/interfaces/marketHandlerDataStorageInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface marketHandlerDataStorageInterface  {\r\n\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\r\n\r\n\tfunction setNewCustomer(address payable userAddr) external returns (bool);\r\n\r\n\tfunction getUserAccessed(address payable userAddr) external view returns (bool);\r\n\tfunction setUserAccessed(address payable userAddr, bool _accessed) external returns (bool);\r\n\r\n\tfunction getReservedAddr() external view returns (address payable);\r\n\tfunction setReservedAddr(address payable reservedAddress) external returns (bool);\r\n\r\n\tfunction getReservedAmount() external view returns (int256);\r\n\tfunction addReservedAmount(uint256 amount) external returns (int256);\r\n\tfunction subReservedAmount(uint256 amount) external returns (int256);\r\n\tfunction updateSignedReservedAmount(int256 amount) external returns (int256);\r\n\r\n\tfunction setTokenHandler(address _marketHandlerAddr, address _interestModelAddr) external returns (bool);\r\n\tfunction setCoinHandler(address _marketHandlerAddr, address _interestModelAddr) external returns (bool);\r\n\r\n\tfunction getDepositTotalAmount() external view returns (uint256);\r\n\tfunction addDepositTotalAmount(uint256 amount) external returns (uint256);\r\n\tfunction subDepositTotalAmount(uint256 amount) external returns (uint256);\r\n\r\n\tfunction getBorrowTotalAmount() external view returns (uint256);\r\n\tfunction addBorrowTotalAmount(uint256 amount) external returns (uint256);\r\n\tfunction subBorrowTotalAmount(uint256 amount) external returns (uint256);\r\n\r\n\tfunction getUserIntraDepositAmount(address payable userAddr) external view returns (uint256);\r\n\tfunction addUserIntraDepositAmount(address payable userAddr, uint256 amount) external returns (uint256);\r\n\tfunction subUserIntraDepositAmount(address payable userAddr, uint256 amount) external returns (uint256);\r\n\r\n\tfunction getUserIntraBorrowAmount(address payable userAddr) external view returns (uint256);\r\n\tfunction addUserIntraBorrowAmount(address payable userAddr, uint256 amount) external returns (uint256);\r\n\tfunction subUserIntraBorrowAmount(address payable userAddr, uint256 amount) external returns (uint256);\r\n\r\n\tfunction addDepositAmount(address payable userAddr, uint256 amount) external returns (bool);\r\n\tfunction subDepositAmount(address payable userAddr, uint256 amount) external returns (bool);\r\n\r\n\tfunction addBorrowAmount(address payable userAddr, uint256 amount) external returns (bool);\r\n\tfunction subBorrowAmount(address payable userAddr, uint256 amount) external returns (bool);\r\n\r\n\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\r\n\tfunction getHandlerAmount() external view returns (uint256, uint256);\r\n\r\n\tfunction getAmount(address payable userAddr) external view returns (uint256, uint256, uint256, uint256);\r\n\tfunction setAmount(address payable userAddr, uint256 depositTotalAmount, uint256 borrowTotalAmount, uint256 depositAmount, uint256 borrowAmount) external returns (uint256);\r\n\r\n\tfunction setBlocks(uint256 lastUpdatedBlock, uint256 inactiveActionDelta) external returns (bool);\r\n\r\n\tfunction getLastUpdatedBlock() external view returns (uint256);\r\n\tfunction setLastUpdatedBlock(uint256 _lastUpdatedBlock) external returns (bool);\r\n\r\n\tfunction getInactiveActionDelta() external view returns (uint256);\r\n\tfunction setInactiveActionDelta(uint256 inactiveActionDelta) external returns (bool);\r\n\r\n\tfunction syncActionEXR() external returns (bool);\r\n\r\n\tfunction getActionEXR() external view returns (uint256, uint256);\r\n\tfunction setActionEXR(uint256 actionDepositExRate, uint256 actionBorrowExRate) external returns (bool);\r\n\r\n\tfunction getGlobalDepositEXR() external view returns (uint256);\r\n\tfunction getGlobalBorrowEXR() external view returns (uint256);\r\n\r\n\tfunction setEXR(address payable userAddr, uint256 globalDepositEXR, uint256 globalBorrowEXR) external returns (bool);\r\n\r\n\tfunction getUserEXR(address payable userAddr) external view returns (uint256, uint256);\r\n\tfunction setUserEXR(address payable userAddr, uint256 depositEXR, uint256 borrowEXR) external returns (bool);\r\n\r\n\tfunction getGlobalEXR() external view returns (uint256, uint256);\r\n\r\n\tfunction getMarketHandlerAddr() external view returns (address);\r\n\tfunction setMarketHandlerAddr(address marketHandlerAddr) external returns (bool);\r\n\r\n\tfunction getInterestModelAddr() external view returns (address);\r\n\tfunction setInterestModelAddr(address interestModelAddr) external returns (bool);\r\n\r\n\r\n\tfunction getMinimumInterestRate() external view returns (uint256);\r\n\tfunction setMinimumInterestRate(uint256 _minimumInterestRate) external returns (bool);\r\n\r\n\tfunction getLiquiditySensitivity() external view returns (uint256);\r\n\tfunction setLiquiditySensitivity(uint256 _liquiditySensitivity) external returns (bool);\r\n\r\n\tfunction getLimit() external view returns (uint256, uint256);\r\n\r\n\tfunction getBorrowLimit() external view returns (uint256);\r\n\tfunction setBorrowLimit(uint256 _borrowLimit) external returns (bool);\r\n\r\n\tfunction getMarginCallLimit() external view returns (uint256);\r\n\tfunction setMarginCallLimit(uint256 _marginCallLimit) external returns (bool);\r\n\r\n\tfunction getLimitOfAction() external view returns (uint256);\r\n\tfunction setLimitOfAction(uint256 limitOfAction) external returns (bool);\r\n\r\n\tfunction getLiquidityLimit() external view returns (uint256);\r\n\tfunction setLiquidityLimit(uint256 liquidityLimit) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/marketManagerInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface marketManagerInterface  {\r\n\tfunction setBreakerTable(address _target, bool _status) external returns (bool);\r\n\r\n\tfunction getCircuitBreaker() external view returns (bool);\r\n\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\r\n\r\n\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address, string memory);\r\n\r\n\tfunction handlerRegister(uint256 handlerID, address tokenHandlerAddr) external returns (bool);\r\n\r\n\tfunction applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external returns (uint256, uint256, uint256);\r\n\tfunction liquidationApplyInterestHandlers(address payable userAddr, uint256 callerID) external returns (uint256, uint256, uint256, uint256, uint256);\r\n\r\n\tfunction getTokenHandlerPrice(uint256 handlerID) external view returns (uint256);\r\n\tfunction getTokenHandlerBorrowLimit(uint256 handlerID) external view returns (uint256);\r\n\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\r\n\r\n\tfunction getTokenHandlersLength() external view returns (uint256);\r\n\tfunction setTokenHandlersLength(uint256 _tokenHandlerLength) external returns (bool);\r\n\r\n\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\r\n\tfunction getTokenHandlerMarginCallLimit(uint256 handlerID) external view returns (uint256);\r\n\r\n\tfunction getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserTotalIntraCreditAsset(address payable userAddr) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserLimitIntraAsset(address payable userAddr) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserCollateralizableAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\r\n\r\n\tfunction getUserExtraLiquidityAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\r\n\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 liquidateHandlerID, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\r\n\r\n\tfunction getMaxLiquidationReward(address payable delinquentBorrower, uint256 liquidateHandlerID, uint256 liquidateAmount, uint256 rewardHandlerID, uint256 rewardRatio) external view returns (uint256);\r\n\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 rewardAmount, address payable liquidator, uint256 handlerID) external returns (uint256);\r\n\r\n\tfunction setLiquidationManager(address liquidationManagerAddr) external returns (bool);\r\n\r\n\tfunction rewardClaimAll(address payable userAddr) external returns (bool);\r\n\r\n\tfunction updateRewardParams(address payable userAddr) external returns (bool);\r\n\tfunction interestUpdateReward() external returns (bool);\r\n\tfunction getGlobalRewardInfo() external view returns (uint256, uint256, uint256);\r\n\r\n\tfunction setOracleProxy(address oracleProxyAddr) external returns (bool);\r\n\r\n\tfunction rewardUpdateOfInAction(address payable userAddr, uint256 callerID) external returns (bool);\r\n\tfunction ownerRewardTransfer(uint256 _amount) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/interestModelInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface interestModelInterface {\r\n\tfunction getInterestAmount(address handlerDataStorageAddr, address payable userAddr, bool isView) external view returns (bool, uint256, uint256, bool, uint256, uint256);\r\n\tfunction viewInterestAmount(address handlerDataStorageAddr, address payable userAddr) external view returns (bool, uint256, uint256, bool, uint256, uint256);\r\n\tfunction getSIRandBIR(address handlerDataStorageAddr, uint256 depositTotalAmount, uint256 borrowTotalAmount) external view returns (uint256, uint256);\r\n}\r\n\r\n// File: contracts/interfaces/marketSIHandlerDataStorageInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface marketSIHandlerDataStorageInterface  {\r\n\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\r\n\r\n\tfunction updateRewardPerBlockStorage(uint256 _rewardPerBlock) external returns (bool);\r\n\r\n\tfunction getRewardInfo(address userAddr) external view returns (uint256, uint256, uint256, uint256, uint256, uint256);\r\n\r\n\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\r\n\tfunction setMarketRewardInfo(uint256 _rewardLane, uint256 _rewardLaneUpdateAt, uint256 _rewardPerBlock) external returns (bool);\r\n\r\n\tfunction getUserRewardInfo(address userAddr) external view returns (uint256, uint256, uint256);\r\n\tfunction setUserRewardInfo(address userAddr, uint256 _rewardLane, uint256 _rewardLaneUpdateAt, uint256 _rewardAmount) external returns (bool);\r\n\r\n\tfunction getBetaRate() external view returns (uint256);\r\n\tfunction setBetaRate(uint256 _betaRate) external returns (bool);\r\n}\r\n\r\n// File: contracts/marketHandler/coinSI.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title Bifi's coinSI Contract\r\n * @notice Contract of coinSI, where users can action with reward logic\r\n * @author Bifi\r\n */\r\ncontract coinSI is SIInterface {\r\n\tevent CircuitBreaked(bool breaked, uint256 blockNumber, uint256 handlerID);\r\n\r\n\taddress payable owner;\r\n\r\n\tuint256 handlerID;\r\n\r\n\tstring tokenName;\r\n\r\n\tuint256 constant unifiedPoint = 10 ** 18;\r\n\r\n\tmarketManagerInterface marketManager;\r\n\r\n\tinterestModelInterface interestModelInstance;\r\n\r\n\tmarketHandlerDataStorageInterface handlerDataStorage;\r\n\r\n\tmarketSIHandlerDataStorageInterface SIHandlerDataStorage;\r\n\r\n\tstruct MarketRewardInfo {\r\n\t\tuint256 rewardLane;\r\n\t\tuint256 rewardLaneUpdateAt;\r\n\t\tuint256 rewardPerBlock;\r\n\t}\r\n\r\n\tstruct UserRewardInfo {\r\n\t\tuint256 rewardLane;\r\n\t\tuint256 rewardLaneUpdateAt;\r\n\t\tuint256 rewardAmount;\r\n\t}\r\n\r\n\tmodifier onlyMarketManager {\r\n\t\taddress msgSender = msg.sender;\r\n\t\trequire((msgSender == address(marketManager)) || (msgSender == owner), \"onlyMarketManager function\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == address(owner), \"onlyOwner function\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Replace the owner of the handler\r\n\t* @param _owner the address of the owner to be replaced\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction ownershipTransfer(address _owner) onlyOwner external returns (bool)\r\n\t{\r\n\t\towner = address(uint160(_owner));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Set circuitBreak which freeze all of handlers with owner\r\n\t* @param _emergency The status on whether to use circuitBreak\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setCircuitBreakWithOwner(bool _emergency) onlyOwner external override returns (bool)\r\n\t{\r\n\t\tSIHandlerDataStorage.setCircuitBreaker(_emergency);\r\n\t\temit CircuitBreaked(_emergency, block.number, handlerID);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Set circuitBreak which freeze all of handlers with marketManager\r\n\t* @param _emergency The status on whether to use circuitBreak\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setCircuitBreaker(bool _emergency) onlyMarketManager external override returns (bool)\r\n\t{\r\n\t\tSIHandlerDataStorage.setCircuitBreaker(_emergency);\r\n\t\temit CircuitBreaked(_emergency, block.number, handlerID);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Update the amount of rewards per block\r\n\t* @param _rewardPerBlock The amount of rewards per block\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction updateRewardPerBlockLogic(uint256 _rewardPerBlock) onlyMarketManager external override returns (bool)\r\n\t{\r\n\t\treturn SIHandlerDataStorage.updateRewardPerBlockStorage(_rewardPerBlock);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Calculates the number of rewards given according to the gap of block number\r\n\t* @param userAddr The address of user\r\n\t* @return Whether or not updateRewardLane succeed\r\n\t*/\r\n\tfunction updateRewardLane(address payable userAddr) external override returns (bool)\r\n\t{\r\n\t\tMarketRewardInfo memory market;\r\n\t\tUserRewardInfo memory user;\r\n\t\tmarketSIHandlerDataStorageInterface _SIHandlerDataStorage = SIHandlerDataStorage;\r\n\t\t(market.rewardLane, market.rewardLaneUpdateAt, market.rewardPerBlock, user.rewardLane, user.rewardLaneUpdateAt, user.rewardAmount) = _SIHandlerDataStorage.getRewardInfo(userAddr);\r\n\r\n\t\t/* To calculate the amount of rewards that change as the block flows, bring in the user's deposit, borrow, and total deposit, total borrow of the market */\r\n\t\tuint256 currentBlockNum = block.number;\r\n\t\tuint256 depositTotalAmount;\r\n\t\tuint256 borrowTotalAmount;\r\n\t\tuint256 depositUserAmount;\r\n\t\tuint256 borrowUserAmount;\r\n\t\t(depositTotalAmount, borrowTotalAmount, depositUserAmount, borrowUserAmount) = handlerDataStorage.getAmount(userAddr);\r\n\r\n\t\t/* Update the market's reward parameter value according to the rate of beta(the rate of weight) if the time of call is later than when the reward was updated */\r\n\t\tif (market.rewardLaneUpdateAt < currentBlockNum)\r\n\t\t{\r\n\t\t\tuint256 _delta = sub(currentBlockNum, market.rewardLaneUpdateAt);\r\n\t\t\tuint256 betaRateBaseTotalAmount = _calcBetaBaseAmount(_SIHandlerDataStorage.getBetaRate(), depositTotalAmount, borrowTotalAmount);\r\n\t\t\tif (betaRateBaseTotalAmount != 0)\r\n\t\t\t{\r\n\t\t\t\tmarket.rewardLane = add(market.rewardLane, _calcRewardLaneDistance(_delta, market.rewardPerBlock, betaRateBaseTotalAmount));\r\n\t\t\t}\r\n\r\n\t\t\t_SIHandlerDataStorage.setMarketRewardInfo(market.rewardLane, currentBlockNum, market.rewardPerBlock);\r\n\t\t}\r\n\r\n\t\t/* Update the user's reward parameter value according to the rate of beta(the rate of weight) if the time of call is later than when the reward was updated */\r\n\t\tif (user.rewardLaneUpdateAt < currentBlockNum)\r\n\t\t{\r\n\t\t\tuint256 betaRateBaseUserAmount = _calcBetaBaseAmount(_SIHandlerDataStorage.getBetaRate(), depositUserAmount, borrowUserAmount);\r\n\t\t\tif (betaRateBaseUserAmount != 0)\r\n\t\t\t{\r\n\t\t\t\tuser.rewardAmount = add(user.rewardAmount, unifiedMul(betaRateBaseUserAmount, sub(market.rewardLane, user.rewardLane)));\r\n\t\t\t}\r\n\r\n\t\t\t_SIHandlerDataStorage.setUserRewardInfo(userAddr, market.rewardLane, currentBlockNum, user.rewardAmount);\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Calculates the number of rewards given according to the gap of block number\r\n\t* @param _delta The amount of blockNumber's gap\r\n\t* @param _rewardPerBlock The amount of reward per block\r\n\t* @param _total The total amount of betaRate\r\n\t* @return The result of reward given according to the block number gap\r\n\t*/\r\n\tfunction _calcRewardLaneDistance(uint256 _delta, uint256 _rewardPerBlock, uint256 _total) internal pure returns (uint256)\r\n\t{\r\n\t\treturn mul(_delta, unifiedDiv(_rewardPerBlock, _total));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the total amount of betaRate\r\n\t* @return The total amount of betaRate\r\n\t*/\r\n\tfunction getBetaRateBaseTotalAmount() external view override returns (uint256)\r\n\t{\r\n\t\treturn _getBetaRateBaseTotalAmount();\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the total amount of betaRate\r\n\t* @return The total amount of betaRate\r\n\t*/\r\n\tfunction _getBetaRateBaseTotalAmount() internal view returns (uint256)\r\n\t{\r\n\t\tuint256 depositTotalAmount;\r\n\t\tuint256 borrowTotalAmount;\r\n\t\t(depositTotalAmount, borrowTotalAmount) = handlerDataStorage.getHandlerAmount();\r\n\t\treturn _calcBetaBaseAmount(SIHandlerDataStorage.getBetaRate(), depositTotalAmount, borrowTotalAmount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Calculate the rewards given to the user through calculation, Based on the data rate\r\n\t* betaRateBaseAmount = (depositAmount * betaRate) + ((1 - betaRate) * borrowAmount)\r\n\t* @param userAddr The address of user\r\n\t* @return The amount of user's betaRate\r\n\t*/\r\n\tfunction getBetaRateBaseUserAmount(address payable userAddr) external view override returns (uint256)\r\n\t{\r\n\t\treturn _getBetaRateBaseUserAmount(userAddr);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Calculate the rewards given to the user through calculation, Based on the data rate\r\n\t* betaRateBaseAmount = (depositAmount * betaRate) + ((1 - betaRate) * borrowAmount)\r\n\t* @param userAddr The address of user\r\n\t* @return The amount of user's betaRate\r\n\t*/\r\n\tfunction _getBetaRateBaseUserAmount(address payable userAddr) internal view returns (uint256)\r\n\t{\r\n\t\tuint256 depositUserAmount;\r\n\t\tuint256 borrowUserAmount;\r\n\t\t(depositUserAmount, borrowUserAmount) = handlerDataStorage.getUserAmount(userAddr);\r\n\t\treturn _calcBetaBaseAmount(SIHandlerDataStorage.getBetaRate(), depositUserAmount, borrowUserAmount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the amount of user's accumulated rewards as tokens\r\n\t* and initialize user reward amount\r\n\t* @param userAddr The address of user who claimed\r\n\t* @return The amount of user's reward\r\n\t*/\r\n\tfunction claimRewardAmountUser(address payable userAddr) onlyMarketManager external returns (uint256)\r\n\t{\r\n\t\treturn _claimRewardAmountUser(userAddr);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the amount of user's accumulated rewards as tokens\r\n\t* and initialize user reward amount\r\n\t* @param userAddr The address of user who claimed\r\n\t* @return The amount of user's reward\r\n\t*/\r\n\tfunction _claimRewardAmountUser(address payable userAddr) internal returns (uint256)\r\n\t{\r\n\t\tUserRewardInfo memory user;\r\n\t\tuint256 currentBlockNum = block.number;\r\n\t\t(user.rewardLane, user.rewardLaneUpdateAt, user.rewardAmount) = SIHandlerDataStorage.getUserRewardInfo(userAddr);\r\n\t\tSIHandlerDataStorage.setUserRewardInfo(userAddr, user.rewardLane, currentBlockNum, 0);\r\n\t\treturn user.rewardAmount;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Calculate the rewards given to the user through calculation, Based on the data rate\r\n\t* betaRateBaseAmount = (depositAmount * betaRate) + ((1 - betaRate) * borrowAmount)\r\n\t* @param _beta The rate of beta\r\n\t* @param _depositAmount The amount of user's deposit\r\n\t* @param _borrowAmount The amount of user's borrow\r\n\t* @return The amount of user's betaRate\r\n\t*/\r\n\tfunction _calcBetaBaseAmount(uint256 _beta, uint256 _depositAmount, uint256 _borrowAmount) internal pure returns (uint256)\r\n\t{\r\n\t\treturn add(unifiedMul(_depositAmount, _beta), unifiedMul(_borrowAmount, sub(unifiedPoint, _beta)));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get reward parameters related the market\r\n\t* @return (uint256,uint256,uint256) (rewardLane, rewardLaneUpdateAt, rewardPerBlock)\r\n\t*/\r\n\tfunction getMarketRewardInfo() external view override returns (uint256, uint256, uint256)\r\n\t{\r\n\t\treturn SIHandlerDataStorage.getMarketRewardInfo();\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get reward parameters related the user\r\n\t* @return (uint256,uint256,uint256) (rewardLane, rewardLaneUpdateAt, rewardAmount)\r\n\t*/\r\n\tfunction getUserRewardInfo(address payable userAddr) external view override returns (uint256, uint256, uint256)\r\n\t{\r\n\t\treturn SIHandlerDataStorage.getUserRewardInfo(userAddr);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the rate of beta\r\n\t* @return The rate of beta\r\n\t*/\r\n\tfunction getBetaRate() external view returns (uint256)\r\n\t{\r\n\t\treturn SIHandlerDataStorage.getBetaRate();\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"add overflow\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _sub(a, b, \"sub overflow\");\r\n\t}\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _mul(a, b);\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(a, b, \"div by zero\");\r\n\t}\r\n\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _mod(a, b, \"mod by zero\");\r\n\t}\r\n\r\n\tfunction _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b <= a, errorMessage);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction _mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tif (a == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire((c / a) == b, \"mul overflow\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b > 0, errorMessage);\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\tfunction _mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b != 0, errorMessage);\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\tfunction unifiedDiv(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(_mul(a, unifiedPoint), b, \"unified div by zero\");\r\n\t}\r\n\r\n\tfunction unifiedMul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(_mul(a, b), unifiedPoint, \"unified mul by zero\");\r\n\t}\r\n\r\n\tfunction signedAdd(int256 a, int256 b) internal pure returns (int256)\r\n\t{\r\n\t\tint256 c = a + b;\r\n\t\trequire(((b >= 0) && (c >= a)) || ((b < 0) && (c < a)), \"SignedSafeMath: addition overflow\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction signedSub(int256 a, int256 b) internal pure returns (int256)\r\n\t{\r\n\t\tint256 c = a - b;\r\n\t\trequire(((b >= 0) && (c <= a)) || ((b < 0) && (c > a)), \"SignedSafeMath: subtraction overflow\");\r\n\t\treturn c;\r\n\t}\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"breaked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"CircuitBreaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"claimRewardAmountUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBetaRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBetaRateBaseTotalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"getBetaRateBaseUserAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketRewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"getUserRewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ownershipTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_emergency\",\"type\":\"bool\"}],\"name\":\"setCircuitBreakWithOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_emergency\",\"type\":\"bool\"}],\"name\":\"setCircuitBreaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"updateRewardLane\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"updateRewardPerBlockLogic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"coinSI","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8d47b1a17554eb856f888ee6f9a9cfb3a03c0e3e2c78474c6dc3758ec5d3ac0f"}]}