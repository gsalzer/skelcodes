{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.0;\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/Initializable.sol\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.24 <0.7.0;\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n * \r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n * \r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { cs := extcodesize(self) }\r\n        return cs == 0;\r\n    }\r\n}\r\n// File: @openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\r\n// SPDX-License-Identifier: MIT\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n    function __Context_init_unchained() internal initializer {\r\n    }\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n    uint256[50] private __gap;\r\n}\r\n// File: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\r\n// SPDX-License-Identifier: MIT\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n    }\r\n    function __Ownable_init_unchained() internal initializer {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n    uint256[49] private __gap;\r\n}\r\n// File: contracts/ENSRegistrar.sol\r\n// SPDX-License-Identifier: UNLICENSED\r\ninterface ENS {\r\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n}\r\ninterface Resolver{\r\n    function setAddr(bytes32 node, address addr) external;\r\n    function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\r\n}\r\n/**\r\n * A registrar that allocates subdomains to the first person to claim them.\r\n */\r\ncontract ENSRegistrar is Initializable, OwnableUpgradeable {\r\n    event NameClaimed(address indexed series, string value);\r\n    // Master ENS registry\r\n    ENS ens;\r\n    // The otoco.eth node reference\r\n    bytes32 rootNode;\r\n    // Default resolver to deal with data storage\r\n    Resolver defaultResolver;\r\n    // Mapping of Company address => Domains\r\n    mapping(address => string[]) internal seriesDomains;\r\n    modifier only_owner(bytes32 label) {\r\n        address currentOwner = ens.owner(keccak256(abi.encodePacked(rootNode, label)));\r\n        require(currentOwner == address(0x0) || currentOwner == msg.sender);\r\n        _;\r\n    }\r\n    modifier only_series_manager(OwnableUpgradeable series) {\r\n        require(series.owner() == msg.sender, 'Not the series manager.');\r\n        _;\r\n    }\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The address of the ENS registry.\r\n     * @param resolverAddr The resolver where domains will use to register.\r\n     * @param node The node that this registrar administers.\r\n     * @param previousSeries Previous series to be migrated.\r\n     * @param previousDomains Previous domains to be migrated.\r\n     */\r\n    function initialize(ENS ensAddr, Resolver resolverAddr, bytes32 node, address[] calldata previousSeries, bytes32[] calldata previousDomains) external {\r\n        require(previousSeries.length == previousDomains.length, 'Previous series size different than previous tokens size.');\r\n        __Ownable_init();\r\n        ens = ensAddr;\r\n        rootNode = node;\r\n        defaultResolver = resolverAddr;\r\n        for (uint i = 0; i < previousSeries.length; i++ ) {\r\n            emit NameClaimed(previousSeries[i], bytes32ToString(previousDomains[i]));\r\n            seriesDomains[previousSeries[i]].push(bytes32ToString(previousDomains[i]));\r\n        }\r\n    }\r\n    /**\r\n     * Register a name, or change the owner of an existing registration.\r\n     * @param label The hash of the label to register.\r\n     * @param owner The address of the new owner(Series Manager).\r\n     * @param addr Address to redirect domain\r\n     */\r\n    function register(bytes32 label, address owner, address addr) public only_owner(label) {\r\n        bytes32 node = keccak256(abi.encodePacked(rootNode, label));\r\n        ens.setSubnodeRecord(rootNode, label, address(this), address(defaultResolver) ,63072000);\r\n        defaultResolver.setAddr(node, addr);\r\n        ens.setOwner(node, owner);\r\n    }\r\n    /**\r\n     * Register a name, and store the domain to reverse lookup.\r\n     * @param domain The string containing the domain.\r\n     * @param target Series contract that registry will point.\r\n     * @param addr Address to redirect domain\r\n     */\r\n    function registerAndStore(string memory domain, OwnableUpgradeable target, address addr) public only_series_manager(target) {\r\n        bytes32 label = keccak256(abi.encodePacked(domain));\r\n        register(label, msg.sender, addr);\r\n        seriesDomains[address(target)].push(domain);\r\n        emit NameClaimed(address(target), domain);\r\n    }\r\n    /**\r\n     * Return some domain from a series. As a single series could claim multiple domains, \r\n     * the resolve function here has a index parameter to point a specific domain to be retrieved.\r\n     * @param addr The string containing the addr.\r\n     * @param index Domain index to be retrieved.\r\n     */\r\n    function resolve(address addr, uint8 index) public view returns(string memory) {\r\n        return seriesDomains[addr][index];\r\n    }\r\n    /**\r\n     * Return how much domains the Series has registered using this Registrar.\r\n     * @param addr The string containing the series address.\r\n     */\r\n    function ownedDomains(address addr) public view returns(uint) {\r\n        return seriesDomains[addr].length;\r\n    }\r\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\r\n        uint8 i = 0;\r\n        while(i < 32 && _bytes32[i] != 0) {\r\n            i++;\r\n        }\r\n        bytes memory bytesArray = new bytes(i);\r\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n            bytesArray[i] = _bytes32[i];\r\n        }\r\n        return string(bytesArray);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"series\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"NameClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"ensAddr\",\"type\":\"address\"},{\"internalType\":\"contract Resolver\",\"name\":\"resolverAddr\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"previousSeries\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"previousDomains\",\"type\":\"bytes32[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ownedDomains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"},{\"internalType\":\"contract OwnableUpgradeable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"registerAndStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ENSRegistrar","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://188e758577050ad639537722362b37bdd148c30ee7a0f33a85aa36fa55032668"}]}