{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n// UniPower.Network - PowerDAO beta\r\n\r\ncontract PowerDAOBeta {\r\n    \r\n    ERC20 constant power = ERC20(0xF2f9A7e93f845b3ce154EfbeB64fB9346FCCE509);\r\n    ERC20 constant liquidity = ERC20(0x49F9316EB22de90d9343C573fbD7Cc0B5ec6e19f);\r\n    PowerLock constant powerLock = PowerLock(0xAE7B530Be880457523Eb46d8ec6484e067c018B4);\r\n    StaticPower constant staticPower = StaticPower(0xBaB61589f963534460E2764A1C0d840B745A9140);\r\n    \r\n    address blobby = msg.sender; // For beta (updating proposal cost)\r\n    uint256 proposalDeposit = 50 * (10 ** 18); // 50 POWER\r\n    uint256 proposalExpiration = 7 days;\r\n    //uint256 removalCap = 5; // No cap for beta\r\n    uint256 removalCooldown = 24 hours;\r\n    uint256 nextRemoval;\r\n    \r\n    Proposal[] public proposals;\r\n    \r\n    struct Proposal {\r\n        address creator;\r\n        uint200 liquidityRemoved;\r\n        uint40 expiration;\r\n        bool executed;\r\n        address recipient;\r\n        string title;\r\n        string message;\r\n    }\r\n    \r\n    function startProposal(uint200 liquidityRemoved, address recipient, string title, string message) external {\r\n        //uint256 maxRemoval = (removalCap * liquidity.balanceOf(this)) / 100; TODO No cap for beta\r\n        //require(liquidityRemoved <= maxRemoval);\r\n        power.transferFrom(msg.sender, this, proposalDeposit);\r\n        proposals.push(Proposal(msg.sender, liquidityRemoved, uint40(now + proposalExpiration), false, recipient, title, message));\r\n    }\r\n    \r\n    function updateProposalDeposit(uint256 newCost) external {\r\n        require(msg.sender == blobby);\r\n        require(newCost <= 500 * (10 ** 18)); // upto 500 POWER\r\n        proposalDeposit = newCost;\r\n    }\r\n    \r\n    function updateProposalExpiration(uint256 newTime) external {\r\n        require(msg.sender == blobby);\r\n        require(newTime > 3 days && newTime < 31 days);\r\n        proposalExpiration = newTime;\r\n    }\r\n    \r\n    /*function updateProposalCap(uint256 newCap) external {\r\n        require(msg.sender == blobby);\r\n        require(newCap <= 10);\r\n        removalCap = newCap;\r\n    }*/\r\n    \r\n    function updateRemovalFrequency(uint256 newLimit) external {\r\n        require(msg.sender == blobby);\r\n        require(newLimit > 12 hours && newLimit < 7 days);\r\n        removalCooldown = newLimit;\r\n    }\r\n    \r\n    function removeExpiredDeposits(address recipient, uint256 amount) external {\r\n        require(msg.sender == blobby);\r\n        power.transfer(recipient, amount);\r\n    }\r\n    \r\n    function executeProposal(uint256 proposalId, bytes signatures) external {\r\n        Proposal memory proposal = proposals[proposalId];\r\n        require(proposal.creator != 0);\r\n        require(!proposal.executed);\r\n        \r\n        // Check signatures add up to required 50%\r\n        uint256 tally;\r\n        bytes32 hashedTx = recoverPreSignedHash(proposalId);\r\n        address previousAddress;\r\n        for (uint256 i = 0; (i * 65) < signatures.length; i++) {\r\n            address user = recover(hashedTx, slice(signatures, i * 65, 65));\r\n            require(user > previousAddress);\r\n            previousAddress = user;\r\n            if (user != 0) {\r\n                tally += powerLock.playersStakePower(user);\r\n                tally += staticPower.balanceOf(user);\r\n            }\r\n        }\r\n        \r\n        if (proposalId > 0) { // 0 is test proposal\r\n            require(tally >= ((powerLock.totalStakePower() + staticPower.totalSupply()) * 50) / 100); // 50% in PowerLock & StaticPower\r\n        }\r\n        \r\n        if (proposal.liquidityRemoved > 0) {\r\n            require(nextRemoval < now);\r\n            liquidity.transfer(proposal.recipient, proposal.liquidityRemoved);\r\n            nextRemoval = now + removalCooldown;\r\n        }\r\n        \r\n        proposal.executed = true;\r\n        proposal.expiration = uint40(now);\r\n        proposals[proposalId] = proposal;\r\n        power.transfer(proposal.creator, proposalDeposit);\r\n    }\r\n    \r\n    function numProposals() view external returns(uint256) {\r\n        return proposals.length;\r\n    }\r\n    \r\n    function recoverPreSignedHash(uint256 proposalId) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"powerdao\", proposalId));\r\n    }\r\n    \r\n    function signaturesAddress(bytes signature, uint256 proposalId) external pure returns (address) {\r\n        bytes32 hashedTx = recoverPreSignedHash(proposalId);\r\n        return recover(hashedTx, signature);\r\n    }\r\n\r\n    function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        \r\n        // Check the signature length\r\n        if (sig.length != 65) {\r\n            return address(0);\r\n        }\r\n        \r\n        // Divide the signature in r, s and v variables\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        \r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        \r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n            bytes32 prefixedHash = keccak256(prefix, hash);\r\n            return ecrecover(prefixedHash, v, r, s);\r\n        }\r\n    }\r\n    \r\n    function getTally(bytes signatures, uint256 proposalId) external view returns (uint256, uint256) {\r\n        uint256 tally;\r\n        bytes32 hashedTx = recoverPreSignedHash(proposalId);\r\n        address previousAddress;\r\n        \r\n        for (uint256 i = 0; (i * 65) < signatures.length; i++) {\r\n            address user = recover(hashedTx, slice(signatures, i * 65, 65));\r\n            require(user > previousAddress);\r\n            previousAddress = user;\r\n            if (user != 0) {\r\n                tally += powerLock.playersStakePower(user);\r\n                tally += staticPower.balanceOf(user);\r\n            }\r\n        }\r\n        \r\n        uint256 required = ((powerLock.totalStakePower() + staticPower.totalSupply()) * 50) / 100;\r\n        return (tally, required);\r\n    }\r\n    \r\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_start + _length >= _start, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                //zero out the 32 bytes slice we are about to return\r\n                //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract PowerLock {\r\n    uint256 public totalStakePower;\r\n    mapping(address => uint256) public playersStakePower;\r\n    function distributeDivs(uint256 amount) external;\r\n}\r\n\r\ncontract StaticPower {\r\n    function distribute(uint256 _amount) public returns(uint256);\r\n    function balanceOf(address _customerAddress) public view returns(uint256);\r\n    function totalSupply() public view returns(uint256);\r\n}\r\n\r\ncontract Uniswap {\r\n    function removeLiquidityETH(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) public;\r\n    function swapExactETHForTokens(uint amountOutMin, address[] path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() external constant returns (uint);\r\n    function balanceOf(address tokenOwner) external constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function approveAndCall(address spender, uint tokens, bytes data) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"liquidityRemoved\",\"type\":\"uint200\"},{\"name\":\"expiration\",\"type\":\"uint40\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"message\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"recoverPreSignedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"updateProposalDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"},{\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"updateProposalExpiration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeExpiredDeposits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"updateRemovalFrequency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"signatures\",\"type\":\"bytes\"},{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getTally\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"liquidityRemoved\",\"type\":\"uint200\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"message\",\"type\":\"string\"}],\"name\":\"startProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"signaturesAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"PowerDAOBeta","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://899d75a1e8b716092076e82f54ab8ab51e4e7ddf2a967d9c3257c69b8908f312"}]}