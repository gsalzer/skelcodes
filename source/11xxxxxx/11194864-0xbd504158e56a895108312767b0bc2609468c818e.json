{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IERC1155.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\n\\r\\ninterface IERC1155 {\\r\\n\\r\\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\r\\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\r\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n  event URI(string _amount, uint256 indexed _id);\\r\\n\\r\\n\\r\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\\r\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\\r\\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\r\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\\r\\n  function setApprovalForAll(address _operator, bool _approved) external;\\r\\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\\r\\n  \\r\\n}\"\r\n    },\r\n    \"contracts/MonetExchange.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport './libraries/SafeMath.sol';\\r\\nimport './interfaces/IERC20.sol';\\r\\nimport './interfaces/IERC1155.sol';\\r\\n\\r\\ncontract MonetExchange {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public tokenCard;\\r\\n    address public tokenMonet;\\r\\n    \\r\\n    bytes4 private constant ERC1155_RECEIVED_VALUE = 0xf23a6e61;\\r\\n    bytes4 private constant ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\\r\\n\\r\\n    uint256 public fee = 2;  // 0.2%\\r\\n    address public feeTo;\\r\\n    address public feeToSetter;\\r\\n    \\r\\n    uint256 private _nextId;\\r\\n    mapping(uint256 => Order) internal _orders;\\r\\n\\r\\n    struct Order {\\r\\n        uint256 id;\\r\\n        uint256 num;\\r\\n        uint256 price;\\r\\n        address owner;\\r\\n        uint256 status;\\r\\n        uint256 direction;\\r\\n    }\\r\\n\\r\\n    constructor(address card, address monet) public {\\r\\n        tokenCard = card;\\r\\n        tokenMonet = monet;\\r\\n        feeTo = msg.sender;\\r\\n        feeToSetter = msg.sender;\\r\\n    }\\r\\n\\r\\n    // VIEW\\r\\n\\r\\n    // PRIVATE\\r\\n    function _transferFromCards(address _from, address _to, uint256 _id, uint256 _value) private {\\r\\n        IERC1155(tokenCard).safeTransferFrom(_from, _to, _id, _value, bytes(''));\\r\\n    }\\r\\n\\r\\n    function _transferFromMonet(address _from, address _to, uint256 _value) private {\\r\\n        require(IERC20(tokenMonet).transferFrom(_from, _to, _value), 'transferFrom fail');\\r\\n    }\\r\\n\\r\\n    function _transfer(address _to, uint256 _value) private {\\r\\n        require(IERC20(tokenMonet).transfer(_to, _value), 'transfer fail');\\r\\n    }\\r\\n\\r\\n    // EXTERNAL\\r\\n    function trade(uint256 orderId, uint256 num) external {\\r\\n        Order storage order = _orders[orderId];\\r\\n        require(order.id != 0 && order.status == 0, 'order is empty');\\r\\n        require(order.owner != msg.sender, 'order owner is caller');\\r\\n        require(order.num >= num, 'order num is less');\\r\\n        if (order.direction == 0) {\\r\\n            uint256 feeAmount = num.mul(order.price).mul(2).div(1000);\\r\\n            if (feeAmount > 0 && feeTo != address(0)) _transfer(feeTo, feeAmount);\\r\\n            _transfer(msg.sender, num.mul(order.price));\\r\\n            _transferFromCards(msg.sender, order.owner, order.id, num);\\r\\n        } else {\\r\\n            uint256 feeAmount = num.mul(order.price).mul(2).div(1000);\\r\\n            if (feeAmount > 0 && feeTo != address(0)) _transferFromMonet(msg.sender, feeTo, feeAmount);\\r\\n            _transferFromCards(address(this), msg.sender, order.id, num);\\r\\n            _transferFromMonet(msg.sender, order.owner, num.mul(order.price));\\r\\n        }\\r\\n        order.num = order.num.sub(num);\\r\\n        if (order.num == 0) {\\r\\n            order.status = 1;\\r\\n        }\\r\\n        emit Trade(msg.sender, orderId, num);\\r\\n    }\\r\\n\\r\\n    function revoke(uint256 orderId) external {\\r\\n        Order storage order = _orders[orderId];\\r\\n        require(order.id != 0 && order.status == 0, 'order is empty');\\r\\n        require(order.owner == msg.sender, 'caller is not the order owner');\\r\\n        if (order.direction == 0) {\\r\\n            uint256 amount = order.num.mul(order.price).mul(1002).div(1000);\\r\\n            _transfer(msg.sender, amount);\\r\\n        } else {\\r\\n            _transferFromCards(address(this), msg.sender, order.id, order.num);\\r\\n        }\\r\\n        order.status = 2;\\r\\n        emit Revoke(msg.sender, orderId);\\r\\n    }\\r\\n\\r\\n    function placeOrder(uint256 id, uint256 num, uint256 price, uint256 direction) external generateId {\\r\\n        require(_nextId > 0, 'order id generate fail');\\r\\n        require(direction < 2, 'direction is error');\\r\\n        if (direction == 0) {\\r\\n            uint256 amount = num.mul(price).mul(1002).div(1000);\\r\\n            _transferFromMonet(msg.sender, address(this), amount);\\r\\n        } else {\\r\\n            _transferFromCards(msg.sender, address(this), id, num);\\r\\n        }\\r\\n        _orders[_nextId] = Order(id, num, price, msg.sender, 0, direction);\\r\\n        emit PlaceOrder(msg.sender, _nextId, id, num, price, direction);\\r\\n    }\\r\\n\\r\\n    function setFeeTo(address _feeTo) external {\\r\\n        require(msg.sender == feeToSetter, 'FORBIDDEN');\\r\\n        feeTo = _feeTo;\\r\\n    }\\r\\n\\r\\n    function setFeeToSetter(address _feeToSetter) external {\\r\\n        require(msg.sender == feeToSetter, 'FORBIDDEN');\\r\\n        feeToSetter = _feeToSetter;\\r\\n    }\\r\\n    \\r\\n    // IERC1155TokenReceiver\\r\\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns(bytes4){\\r\\n        return ERC1155_RECEIVED_VALUE;\\r\\n    }\\r\\n\\r\\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external pure returns(bytes4){\\r\\n        return ERC1155_BATCH_RECEIVED_VALUE;\\r\\n    }\\r\\n\\r\\n    // MODIFIER\\r\\n    modifier generateId() {\\r\\n        _nextId = _nextId.add(1);\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // EVENT\\r\\n    event Trade(address indexed sender, uint256 indexed orderId, uint256 num);\\r\\n    event Revoke(address indexed sender, uint256 indexed orderId);\\r\\n    event PlaceOrder(address indexed sender, uint256 orderId, uint256 id, uint256 num, uint256 price, uint256 direction);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\r\\n    }\\r\\n\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\r\\n    }\\r\\n\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\r\\n    }\\r\\n    \\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0);\\r\\n        return a / b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/StakingRewardsFactory.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport './Ownable.sol';\\r\\nimport './StakingRewards.sol';\\r\\nimport './interfaces/IERC20.sol';\\r\\n\\r\\ncontract StakingRewardsFactory is Ownable {\\r\\n    // immutables\\r\\n    address public rewardsToken;\\r\\n    uint public stakingRewardsGenesis;\\r\\n\\r\\n    // the staking tokens for which the rewards contract has been deployed\\r\\n    address[] public stakingTokens;\\r\\n\\r\\n    // info about rewards for a particular staking token\\r\\n    struct StakingRewardsInfo {\\r\\n        address stakingRewards;\\r\\n        uint rewardAmount;\\r\\n    }\\r\\n\\r\\n    // rewards info by staking token\\r\\n    mapping(address => StakingRewardsInfo) public stakingRewardsInfoByStakingToken;\\r\\n\\r\\n    constructor(\\r\\n        address _rewardsToken,\\r\\n        uint _stakingRewardsGenesis\\r\\n    ) Ownable() public {\\r\\n        require(_stakingRewardsGenesis >= block.timestamp, 'StakingRewardsFactory::constructor: genesis too soon');\\r\\n\\r\\n        rewardsToken = _rewardsToken;\\r\\n        stakingRewardsGenesis = _stakingRewardsGenesis;\\r\\n    }\\r\\n\\r\\n    ///// permissioned functions\\r\\n\\r\\n    // deploy a staking reward contract for the staking token, and store the reward amount\\r\\n    // the reward will be distributed to the staking reward contract no sooner than the genesis\\r\\n    function deploy(address stakingToken, uint rewardAmount) public onlyOwner {\\r\\n        StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingToken];\\r\\n        require(info.stakingRewards == address(0), 'StakingRewardsFactory::deploy: already deployed');\\r\\n\\r\\n        info.stakingRewards = address(new StakingRewards(/*_rewardsDistribution=*/ address(this), rewardsToken, stakingToken));\\r\\n        info.rewardAmount = rewardAmount;\\r\\n        stakingTokens.push(stakingToken);\\r\\n    }\\r\\n\\r\\n    ///// permissionless functions\\r\\n\\r\\n    // call notifyRewardAmount for all staking tokens.\\r\\n    function notifyRewardAmounts() public {\\r\\n        require(stakingTokens.length > 0, 'StakingRewardsFactory::notifyRewardAmounts: called before any deploys');\\r\\n        for (uint i = 0; i < stakingTokens.length; i++) {\\r\\n            notifyRewardAmount(stakingTokens[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // notify reward amount for an individual staking token.\\r\\n    // this is a fallback in case the notifyRewardAmounts costs too much gas to call for all contracts\\r\\n    function notifyRewardAmount(address stakingToken) public {\\r\\n        require(block.timestamp >= stakingRewardsGenesis, 'StakingRewardsFactory::notifyRewardAmount: not ready');\\r\\n\\r\\n        StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingToken];\\r\\n        require(info.stakingRewards != address(0), 'StakingRewardsFactory::notifyRewardAmount: not deployed');\\r\\n\\r\\n        if (info.rewardAmount > 0) {\\r\\n            uint rewardAmount = info.rewardAmount;\\r\\n            info.rewardAmount = 0;\\r\\n\\r\\n            require(\\r\\n                IERC20(rewardsToken).transfer(info.stakingRewards, rewardAmount),\\r\\n                'StakingRewardsFactory::notifyRewardAmount: transfer failed'\\r\\n            );\\r\\n            StakingRewards(info.stakingRewards).notifyRewardAmount(rewardAmount);\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    constructor() internal {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/StakingRewards.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\n// Inheritance\\r\\nimport './libraries/Math.sol';\\r\\nimport './libraries/SafeMath.sol';\\r\\nimport './libraries/SafeERC20.sol';\\r\\nimport \\\"./interfaces/IStakingRewards.sol\\\";\\r\\nimport './ReentrancyGuard.sol';\\r\\nimport \\\"./RewardsDistributionRecipient.sol\\\";\\r\\n\\r\\ncontract StakingRewards is IStakingRewards, RewardsDistributionRecipient, ReentrancyGuard {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    IERC20 public rewardsToken;\\r\\n    IERC20 public stakingToken;\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;\\r\\n    uint256 public rewardsDuration = 60 days;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n\\r\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address => uint256) public rewards;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    constructor(\\r\\n        address _rewardsDistribution,\\r\\n        address _rewardsToken,\\r\\n        address _stakingToken\\r\\n    ) public {\\r\\n        rewardsToken = IERC20(_rewardsToken);\\r\\n        stakingToken = IERC20(_stakingToken);\\r\\n        rewardsDistribution = _rewardsDistribution;\\r\\n    }\\r\\n\\r\\n    /* ========== VIEWS ========== */\\r\\n\\r\\n    function totalSupply() external view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() public view returns (uint256) {\\r\\n        if (_totalSupply == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) public view returns (uint256) {\\r\\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    function getRewardForDuration() external view returns (uint256) {\\r\\n        return rewardRate.mul(rewardsDuration);\\r\\n    }\\r\\n\\r\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\r\\n\\r\\n    function stakeWithPermit(uint256 amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external nonReentrant updateReward(msg.sender) {\\r\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n\\r\\n        // permit\\r\\n        IUniswapV2ERC20(address(stakingToken)).permit(msg.sender, address(this), amount, deadline, v, r, s);\\r\\n\\r\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) external nonReentrant updateReward(msg.sender) {\\r\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\\r\\n        require(amount > 0, \\\"Cannot withdraw 0\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n        stakingToken.safeTransfer(msg.sender, amount);\\r\\n        emit Withdrawn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function getReward() public nonReentrant updateReward(msg.sender) {\\r\\n        uint256 reward = rewards[msg.sender];\\r\\n        if (reward > 0) {\\r\\n            rewards[msg.sender] = 0;\\r\\n            rewardsToken.safeTransfer(msg.sender, reward);\\r\\n            emit RewardPaid(msg.sender, reward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function exit() external {\\r\\n        withdraw(_balances[msg.sender]);\\r\\n        getReward();\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {\\r\\n        if (block.timestamp >= periodFinish) {\\r\\n            rewardRate = reward.div(rewardsDuration);\\r\\n        } else {\\r\\n            uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n            uint256 leftover = remaining.mul(rewardRate);\\r\\n            rewardRate = reward.add(leftover).div(rewardsDuration);\\r\\n        }\\r\\n\\r\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\r\\n        // This keeps the reward rate in the right range, preventing overflows due to\\r\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\r\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\r\\n        uint balance = rewardsToken.balanceOf(address(this));\\r\\n        require(rewardRate <= balance.div(rewardsDuration), \\\"Provided reward too high\\\");\\r\\n\\r\\n        lastUpdateTime = block.timestamp;\\r\\n        periodFinish = block.timestamp.add(rewardsDuration);\\r\\n        emit RewardAdded(reward);\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    modifier updateReward(address account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event RewardAdded(uint256 reward);\\r\\n    event Staked(address indexed user, uint256 amount);\\r\\n    event Withdrawn(address indexed user, uint256 amount);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2ERC20 {\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\n// a library for performing various math operations\\r\\n\\r\\nlibrary Math {\\r\\n    function min(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = x < y ? x : y;\\r\\n    }\\r\\n\\r\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y > 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x < z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IStakingRewards.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\n\\r\\ninterface IStakingRewards {\\r\\n    // Views\\r\\n    function lastTimeRewardApplicable() external view returns (uint256);\\r\\n\\r\\n    function rewardPerToken() external view returns (uint256);\\r\\n\\r\\n    function earned(address account) external view returns (uint256);\\r\\n\\r\\n    function getRewardForDuration() external view returns (uint256);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    // Mutative\\r\\n\\r\\n    function stake(uint256 amount) external;\\r\\n\\r\\n    function withdraw(uint256 amount) external;\\r\\n\\r\\n    function getReward() external;\\r\\n\\r\\n    function exit() external;\\r\\n}\"\r\n    },\r\n    \"contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\\n * available, which can be aplied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n */\\ncontract ReentrancyGuard {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor () internal {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/RewardsDistributionRecipient.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\ncontract RewardsDistributionRecipient {\\r\\n    address public rewardsDistribution;\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) external;\\r\\n\\r\\n    modifier onlyRewardsDistribution() {\\r\\n        require(msg.sender == rewardsDistribution, \\\"Caller is not RewardsDistribution contract\\\");\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nlibrary Address {\\r\\n\\r\\n    /**\\r\\n     * Returns whether the target address is a contract\\r\\n     * @dev This function will return false if invoked during the constructor of a contract,\\r\\n     * as the code is not actually created until after the constructor finishes.\\r\\n     * @param account address of the account to check\\r\\n     * @return whether the target address is a contract\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        // XXX Currently there is no better way to check if there is a contract in an address\\r\\n        // than to check the size of the code at that address.\\r\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\r\\n        // for more details about how this works.\\r\\n        // TODO Check this again before the Serenity release, because all addresses will be\\r\\n        // contracts then.\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/MonetCardToken.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./libraries/Address.sol\\\";\\r\\nimport \\\"./libraries/SafeMath.sol\\\";\\r\\nimport \\\"./interfaces/IERC1155TokenReceiver.sol\\\";\\r\\nimport \\\"./Minter.sol\\\";\\r\\n\\r\\ncontract MonetCardToken is Minter {\\r\\n    using Address for address;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    bytes4 private constant ERC1155_RECEIVED_VALUE = 0xf23a6e61;\\r\\n    bytes4 private constant ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\\r\\n    bytes4 private constant ERC1155_INTERFACE_ID = 0xd9b67a26;\\r\\n\\r\\n    mapping(address => mapping(uint256 => uint256)) internal _balances;\\r\\n    mapping(address => mapping(address => bool)) internal _operators;\\r\\n    mapping(uint256 => uint256) internal _totalSupplies;\\r\\n\\r\\n    // VIEW\\r\\n\\r\\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\\r\\n        return _operators[_owner][_operator];\\r\\n    }\\r\\n\\r\\n    function totalSupply(uint256 _id) public view returns (uint256) {\\r\\n        return _totalSupplies[_id];\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\\r\\n        return _balances[_owner][_id];\\r\\n    }\\r\\n\\r\\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) {\\r\\n        require(_owners.length == _ids.length, \\\"INVALID_ARRAY_LENGTH\\\");\\r\\n\\r\\n        uint256[] memory batchBalances = new uint256[](_owners.length);\\r\\n        for (uint256 i = 0; i < _owners.length; i++) {\\r\\n            batchBalances[i] = _balances[_owners[i]][_ids[i]];\\r\\n        }\\r\\n        return batchBalances;\\r\\n    }\\r\\n\\r\\n    function cardsNumOf(address _owner, uint256 _level,uint256 _carry) public view returns (uint256 nums) {\\r\\n        for (uint256 i = 0; i < 4; i++) {\\r\\n            uint256 num = _balances[_owner][_level.mul(10).add(i)];\\r\\n            nums = nums.add((_carry**(3 - i)).mul(num));\\r\\n        }\\r\\n        return nums;\\r\\n    }\\r\\n\\r\\n    function cardsNumOfAll(address _owner, uint256 _carry) public view returns (uint256[10] memory nums) {\\r\\n        uint256 levelMax = 10;\\r\\n        for (uint256 i = 0; i < levelMax; i++) {\\r\\n            nums[i] = cardsNumOf(_owner, levelMax.sub(i), _carry);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function cardsTotalSupply() public view returns (uint256[40] memory nums) {\\r\\n        uint256 idx;\\r\\n        for (uint256 i = 10; i > 0; i--) {\\r\\n            for (uint256 j = 0; j < 4; j++) {\\r\\n                nums[idx++] = _totalSupplies[i.mul(10).add(j)];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\\r\\n        return _interfaceID == ERC1155_INTERFACE_ID;\\r\\n    }\\r\\n\\r\\n    // PRIVATE\\r\\n    function _mintBatch(address _to, uint256[] memory _ids, uint256[] memory _values) private {\\r\\n        require(_to != address(0), \\\"INVALID_RECIPIENT\\\");\\r\\n\\r\\n        uint256 size = _ids.length;\\r\\n        for (uint256 i = 0; i < size; i++) {\\r\\n            _totalSupplies[_ids[i]] = _totalSupplies[_ids[i]].add(_values[i]);\\r\\n            _balances[_to][_ids[i]] = _balances[_to][_ids[i]].add(_values[i]);\\r\\n        }\\r\\n        emit TransferBatch(msg.sender, address(0), _to, _ids, _values);\\r\\n    }\\r\\n\\r\\n    function _safeBatchBurnFrom(address _from, uint256[] memory _ids, uint256[] memory _values ) private {\\r\\n        require(_ids.length == _values.length, \\\"INVALID_ARRAYS_LENGTH\\\");\\r\\n\\r\\n        uint256 size = _ids.length;\\r\\n        for (uint256 i = 0; i < size; i++) {\\r\\n            _balances[_from][_ids[i]] = _balances[_from][_ids[i]].sub(\\r\\n                _values[i]\\r\\n            );\\r\\n            _totalSupplies[_ids[i]] = _totalSupplies[_ids[i]].sub(_values[i]);\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(msg.sender, _from, address(0), _ids, _values);\\r\\n    }\\r\\n\\r\\n    function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount) private {\\r\\n        _balances[_from][_id] = _balances[_from][_id].sub(_amount); // Subtract amount\\r\\n        _balances[_to][_id] = _balances[_to][_id].add(_amount); // Add amount\\r\\n\\r\\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\\r\\n    }\\r\\n\\r\\n    function _safeBatchTransferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256[] memory _ids,\\r\\n        uint256[] memory _amounts\\r\\n    ) private {\\r\\n        require(_ids.length == _amounts.length, \\\"INVALID_ARRAYS_LENGTH\\\");\\r\\n\\r\\n        uint256 size = _ids.length;\\r\\n        for (uint256 i = 0; i < size; i++) {\\r\\n            _balances[_from][_ids[i]] = _balances[_from][_ids[i]].sub(\\r\\n                _amounts[i]\\r\\n            );\\r\\n            _balances[_to][_ids[i]] = _balances[_to][_ids[i]].add(_amounts[i]);\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\\r\\n    }\\r\\n\\r\\n    function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data) private {\\r\\n        if (_to.isContract()) {\\r\\n            bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\\r\\n            require(retval == ERC1155_RECEIVED_VALUE, \\\"INVALID_ON_RECEIVE_MESSAGE\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) private {\\r\\n        if (_to.isContract()) {\\r\\n            bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data );\\r\\n            require(retval == ERC1155_BATCH_RECEIVED_VALUE, \\\"INVALID_ON_RECEIVE_MESSAGE\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // EXTERNAL\\r\\n    function safeBatchMint(address _to, uint256[] calldata _ids, uint256[] calldata _values) external onlyMinter {\\r\\n        require(_ids.length == _values.length, \\\"INVALID_ARRAYS_LENGTH\\\");\\r\\n        _mintBatch(_to, _ids, _values);\\r\\n    }\\r\\n\\r\\n    function safeBatchBurnFrom(address _from, uint256[] calldata _ids, uint256[] calldata _amounts) external {\\r\\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\\r\\n\\r\\n        _safeBatchBurnFrom(_from, _ids, _amounts);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external {\\r\\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\\r\\n        require(_to != address(0), \\\"INVALID_RECIPIENT\\\");\\r\\n\\r\\n        _safeTransferFrom(_from, _to, _id, _amount);\\r\\n        _callonERC1155Received(_from, _to, _id, _amount, _data);\\r\\n    }\\r\\n\\r\\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external {\\r\\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\\r\\n        require(_to != address(0), \\\"INVALID_RECIPIENT\\\");\\r\\n\\r\\n        _safeBatchTransferFrom(_from, _to, _ids, _amounts);\\r\\n        _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\\r\\n    }\\r\\n\\r\\n    function cardsBatchMint(address _to, uint256[] calldata _cards) external onlyMinter {\\r\\n        uint256[] memory _ids = new uint256[](_cards.length);\\r\\n        uint256[] memory _values = new uint256[](_cards.length);\\r\\n        for (uint256 i = 0; i < _cards.length; i++) {\\r\\n            _ids[i] = _cards[i] % 1000;\\r\\n            _values[i] = _cards[i] / 1000;\\r\\n        }\\r\\n        _mintBatch(_to, _ids, _values);\\r\\n    }\\r\\n\\r\\n    function cardsBatchBurnFrom(address _from, uint256[] calldata _cards) external {\\r\\n        require((msg.sender == _from) || isApprovedForAll(_from, msg.sender));\\r\\n\\r\\n        uint256[] memory _ids = new uint256[](_cards.length);\\r\\n        uint256[] memory _values = new uint256[](_cards.length);\\r\\n        for (uint256 i = 0; i < _cards.length; i++) {\\r\\n            _ids[i] = _cards[i] % 1000;\\r\\n            _values[i] = _cards[i] / 1000;\\r\\n        }\\r\\n\\r\\n        _safeBatchBurnFrom(_from, _ids, _values);\\r\\n    }\\r\\n\\r\\n    function setApprovalForAll(address _operator, bool _approved) external {\\r\\n        _operators[msg.sender][_operator] = _approved;\\r\\n        emit ApprovalForAll(msg.sender, _operator, _approved);\\r\\n    }\\r\\n\\r\\n    // EVENT\\r\\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\r\\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\r\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n    event URI(string _amount, uint256 indexed _id);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\n\\r\\ninterface IERC1155TokenReceiver {\\r\\n\\r\\n  /**\\r\\n   * @notice Handle the receipt of a single ERC1155 token type\\r\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\\r\\n   * This function MAY throw to revert and reject the transfer\\r\\n   * Return of other amount than the magic value MUST result in the transaction being reverted\\r\\n   * Note: The token contract address is always the message sender\\r\\n   * @param _operator  The address which called the `safeTransferFrom` function\\r\\n   * @param _from      The address which previously owned the token\\r\\n   * @param _id        The id of the token being transferred\\r\\n   * @param _amount    The amount of tokens being transferred\\r\\n   * @param _data      Additional data with no specified format\\r\\n   * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n   */\\r\\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\\r\\n\\r\\n  /**\\r\\n   * @notice Handle the receipt of multiple ERC1155 token types\\r\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\\r\\n   * This function MAY throw to revert and reject the transfer\\r\\n   * Return of other amount than the magic value WILL result in the transaction being reverted\\r\\n   * Note: The token contract address is always the message sender\\r\\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\\r\\n   * @param _from      The address which previously owned the token\\r\\n   * @param _ids       An array containing ids of each token being transferred\\r\\n   * @param _amounts   An array containing amounts of each token being transferred\\r\\n   * @param _data      Additional data with no specified format\\r\\n   * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n   */\\r\\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\\r\\n}\"\r\n    },\r\n    \"contracts/Minter.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport './Ownable.sol';\\n\\ncontract Minter is Ownable {\\n    \\n    mapping(address => bool) private _minters;\\n    \\n    event MinterChanged(address indexed minter, bool approved);\\n\\n\\n    modifier onlyMinter {\\n        require(isMinter(), \\\"Minter: caller is not the minter\\\");\\n        _;\\n    }\\n\\n    function isMinter() public view returns (bool){\\n        return _minters[msg.sender];\\n    }\\n    \\n    function setMinter(address _minter,bool _approved) external onlyOwner {\\n        _minters[_minter] = _approved;\\n        emit MinterChanged(_minter,_approved);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/MonetLuckyToken.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport './Minter.sol';\\r\\nimport './MonetTokenERC20.sol';\\r\\n\\r\\ncontract MonetLuckyToken is MonetTokenERC20 , Minter{\\r\\n    string public constant name = 'Monet Lucky';\\r\\n    string public constant symbol = 'L-MNT';\\r\\n    uint8 public constant decimals = 18;\\r\\n\\r\\n    \\r\\n    function mint(uint value) external onlyMinter returns (bool){\\r\\n        _mint(msg.sender,value);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function mintFrom(address from,uint value) external returns(bool){\\r\\n        _mint(from,value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function burn(uint value) external returns (bool) {\\r\\n        _burn(msg.sender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function burnFrom(address from, uint value) external returns (bool) {\\r\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\r\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\r\\n        }\\r\\n        _burn(from, value);\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/MonetTokenERC20.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport './interfaces/IERC20.sol';\\r\\nimport './libraries/SafeMath.sol';\\r\\n\\r\\ncontract MonetTokenERC20 is IERC20 {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    uint public totalSupply;\\r\\n    mapping(address => uint) public balanceOf;\\r\\n    mapping(address => mapping(address => uint)) public allowance;\\r\\n\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function _mint(address to, uint value) internal {\\r\\n        totalSupply = totalSupply.add(value);\\r\\n        balanceOf[to] = balanceOf[to].add(value);\\r\\n        emit Transfer(address(0), to, value);\\r\\n    }\\r\\n\\r\\n    function _burn(address from, uint256 value) internal {\\r\\n        balanceOf[from] = balanceOf[from].sub(value);\\r\\n        totalSupply = totalSupply.sub(value);\\r\\n        emit Transfer(from, address(0), value);\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint value) private {\\r\\n        allowance[owner][spender] = value;\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint value) private {\\r\\n        balanceOf[from] = balanceOf[from].sub(value);\\r\\n        balanceOf[to] = balanceOf[to].add(value);\\r\\n        emit Transfer(from, to, value);\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool) {\\r\\n        _approve(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint value) external returns (bool) {\\r\\n        _transfer(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool) {\\r\\n        if (allowance[from][msg.sender] != uint(-1)) {\\r\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\r\\n        }\\r\\n        _transfer(from, to, value);\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/test/ERC20.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport '../MonetTokenERC20.sol';\\r\\n\\r\\ncontract ERC20 is MonetTokenERC20 {\\r\\n    constructor(uint _totalSupply) public {\\r\\n        _mint(msg.sender, _totalSupply);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/MonetToken.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport './MonetTokenERC20.sol';\\r\\n\\r\\ncontract MonetToken is MonetTokenERC20 {\\r\\n    \\r\\n    string public constant name = \\\"Monet\\\";\\r\\n    string public constant symbol = \\\"MNT\\\";\\r\\n    uint8 public constant decimals = 18;\\r\\n\\r\\n    constructor() public {\\r\\n        _mint(msg.sender,21000e18);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/MonetV1Router.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./libraries/SafeMath.sol\\\";\\r\\nimport \\\"./libraries/Math.sol\\\";\\r\\nimport \\\"./libraries/Card.sol\\\";\\r\\n\\r\\ncontract MonetV1Router {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public tokenCard;\\r\\n    address public tokenLucky;\\r\\n    address public tokenMonet;\\r\\n\\r\\n    uint256 public cardsReward = 1575e18;\\r\\n\\r\\n    uint256 public startTime;\\r\\n    uint256 public lotteryPrice = 1e18;\\r\\n\\r\\n    uint256 public rate = 8;\\r\\n    uint256 public ratePeriodFinish;\\r\\n\\r\\n    uint256 public laveCards = 8e3;\\r\\n    uint256 public lavePeriodFinish;\\r\\n    \\r\\n    uint256 public unit = 1e4;\\r\\n\\r\\n    constructor(address lucky, address card, address monet) public {\\r\\n        tokenCard = card;\\r\\n        tokenLucky = lucky;\\r\\n        tokenMonet = monet;\\r\\n        startTime = block.timestamp;\\r\\n        lavePeriodFinish = block.timestamp.add(1 days);\\r\\n        ratePeriodFinish = block.timestamp.add(30 days);\\r\\n    }\\r\\n\\r\\n\\r\\n    // VIEW\\r\\n    function cardsNumOf(address from, uint256 level) public view returns (uint256) {\\r\\n        return ICardERC(tokenCard).cardsNumOf(from, level, unit);\\r\\n    }\\r\\n\\r\\n    function cardsNumOfAll(address from) public view returns (uint256[10] memory) {\\r\\n        return ICardERC(tokenCard).cardsNumOfAll(from, unit);\\r\\n    }\\r\\n\\r\\n    // PRIVATE\\r\\n    function _pkgCards( uint256 umax, uint256 mmax, uint256[] memory unums, uint256[] memory mnums, uint256 level ) private view returns (uint256[] memory ucards, uint256[] memory mcards) {\\r\\n        require( unums.length == mnums.length, \\\"nnums size not equal to mnums\\\");\\r\\n        ucards = new uint256[](umax);\\r\\n        mcards = new uint256[](mmax);\\r\\n        uint256 upos;\\r\\n        uint256 mpos;\\r\\n        for (uint256 i = 0; i < unums.length; i++) {\\r\\n            if (unums[i] > 0) (upos, ) = _makeCards(level.sub(i), unums[i], upos, ucards);\\r\\n            if (mnums[i] > 0) (mpos, ) = _makeCards(level.sub(i).sub(1), mnums[i], mpos, mcards);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _calcLevelCardsMerge( address from, uint256 level, uint256 num ) private view returns (uint256[] memory, uint256[] memory) {\\r\\n        uint256 nums = cardsNumOf(from, level);\\r\\n        uint256 min = Card.min(nums, unit);\\r\\n        require(num <= min, \\\"insufficient card resources\\\");\\r\\n\\r\\n        uint256[] memory unums = new uint256[](1);\\r\\n        uint256[] memory mnums = new uint256[](1);\\r\\n        (uint256 mmax, uint256 merge) = _randCards(0, num);\\r\\n        unums[0] = Card.make(num, num, num, num, unit);\\r\\n        mnums[0] = merge;\\r\\n        return _pkgCards(4, mmax, unums, mnums, level);\\r\\n    }\\r\\n\\r\\n    function _calcCardsMerge(address from) private view returns (uint256[] memory, uint256[] memory) {\\r\\n        uint256 colorMax = 4;\\r\\n        uint256[10] memory nums = cardsNumOfAll(from);\\r\\n        uint256[] memory mnums = new uint256[](10);\\r\\n        uint256[] memory unums = new uint256[](10);\\r\\n        uint256 umax;\\r\\n        uint256 mmax;\\r\\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.difficulty, now)));\\r\\n        for (uint256 i = 0; i < 9; i++) {\\r\\n            uint256 _num = nums[i];\\r\\n            if (i > 0 && mnums[i.sub(1)] > 0) _num = Card.merge(_num, mnums[i.sub(1)], unit);\\r\\n            uint256 min = Card.min(_num, unit);\\r\\n            if (min == 0) continue;\\r\\n            (uint256 num, uint256 merge) = _randCards((seed = seed >> 1), min);\\r\\n            mnums[i] = merge;\\r\\n            mmax = mmax.add(num);\\r\\n            umax = umax.add(colorMax);\\r\\n\\r\\n            uint256 ucard = Card.make(min, min, min, min, unit);\\r\\n            if (i > 0 && mnums[i.sub(1)] > 0) {\\r\\n                uint256 cards = mnums[i.sub(1)];\\r\\n                if (cards == 0) {\\r\\n                    continue;\\r\\n                }\\r\\n                for (uint256 j = 0; j < colorMax; j++) {\\r\\n                    uint256 cnum = Card.num(cards, j, unit);\\r\\n                    uint256 mnum = Math.min(cnum, min);\\r\\n                    if (mnum > 0) {\\r\\n                        cards = Card.sub(cards, j, mnum, unit);\\r\\n                        ucard = Card.sub(ucard, j, mnum, unit);\\r\\n                        if (mnum == min) umax = umax.sub(1);\\r\\n                        if (mnum == cnum) mmax = mmax.sub(1);\\r\\n                    }\\r\\n                }\\r\\n                mnums[i.sub(1)] = cards;\\r\\n            }\\r\\n            unums[i] = ucard;\\r\\n        }\\r\\n        return _pkgCards(umax, mmax, unums, mnums, 10);\\r\\n    }\\r\\n\\r\\n    function _makeCards( uint256 level, uint256 nums, uint256 pos, uint256[] memory cards ) private view returns (uint256, uint256[] memory) {\\r\\n        for (uint256 i = 0; i < 4; i++) {\\r\\n            uint256 num = Card.num(nums, i, unit);\\r\\n            if (num > 0) {\\r\\n                require(pos < cards.length, \\\"pos gt array size\\\");\\r\\n                cards[pos] = num.mul(1000).add(level.mul(10)).add(i);\\r\\n                pos = pos.add(1);\\r\\n            }\\r\\n        }\\r\\n        return (pos, cards);\\r\\n    }\\r\\n\\r\\n    function _randCards(uint256 _seed, uint256 _num) private view returns (uint256 num, uint256) {\\r\\n        uint256[4] memory nums = [uint256(0), 0, 0, 0];\\r\\n        if (_seed == 0)\\r\\n            _seed = uint256(keccak256(abi.encodePacked(block.difficulty, now)));\\r\\n        for (uint256 i = 0; i < _num; i++) {\\r\\n            uint256 color = (_seed = _seed / 10 - _seed) % 4;\\r\\n            nums[color] = nums[color].add(1);\\r\\n            if (nums[color] == 1) num = num.add(1);\\r\\n        }\\r\\n        return (num, Card.make(nums[0], nums[1], nums[2], nums[3], unit));\\r\\n    }\\r\\n\\r\\n    function _transferCards( address from, uint256[] memory ucards, uint256[] memory mcards ) private {\\r\\n        require(ucards.length > 0 && mcards.length > 0, \\\"merge error\\\");\\r\\n\\r\\n        ICardERC(tokenCard).cardsBatchBurnFrom(from, ucards);\\r\\n        ICardERC(tokenCard).cardsBatchMint(from, mcards);\\r\\n        emit TransferCards(from, ucards, mcards);\\r\\n    }\\r\\n\\r\\n    function merge(uint256 level, uint256 num) external validateSender(msg.sender) {\\r\\n        require(level > 1 && level <= 10, \\\"illegal level\\\");\\r\\n\\r\\n        uint256[] memory ucards;\\r\\n        uint256[] memory mcards;\\r\\n        (ucards, mcards) = _calcLevelCardsMerge(msg.sender, level, num);\\r\\n        _transferCards(msg.sender, ucards, mcards);\\r\\n    }\\r\\n\\r\\n    function oneKeyMerge() external validateSender(msg.sender) {\\r\\n        uint256[] memory ucards;\\r\\n        uint256[] memory mcards;\\r\\n        (ucards, mcards) = _calcCardsMerge(msg.sender);\\r\\n        _transferCards(msg.sender, ucards, mcards);\\r\\n    }\\r\\n\\r\\n    function lottery(uint256 num) external validateSender(msg.sender) rateRevise laveCardsReset {\\r\\n        require(num > 0, \\\"num equals zero\\\");\\r\\n        require(IERC20(tokenLucky).burnFrom(msg.sender, num.mul(lotteryPrice)), \\\"lucky burn fail\\\");     \\r\\n\\r\\n        uint256 _rate = rate;\\r\\n        uint256 _laveCards = laveCards;\\r\\n        uint256 obtain;\\r\\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.difficulty, now)));\\r\\n        for (uint256 i = 0; i < num; i++) {\\r\\n            uint256 random = (seed = seed / 1000 - seed) % 1000;\\r\\n            if (random < _rate && _laveCards > 0) {\\r\\n                obtain = obtain.add(1);\\r\\n                _laveCards = _laveCards.sub(1);\\r\\n            }\\r\\n        }\\r\\n        laveCards = _laveCards;\\r\\n\\r\\n        uint256[] memory cards;\\r\\n        if (obtain > 0) {\\r\\n            (uint256 cnum, uint256 mnums) = _randCards(seed, obtain);\\r\\n            cards = new uint256[](cnum);\\r\\n            _makeCards(10, mnums, 0, cards);\\r\\n\\r\\n            ICardERC(tokenCard).cardsBatchMint(msg.sender, cards);\\r\\n        }\\r\\n        emit Lottery(msg.sender, cards);\\r\\n    }\\r\\n\\r\\n    function reward(uint256 color, uint256 num) external validateSender(msg.sender) {\\r\\n        require(color < 4 && num > 0, \\\"color gt 4\\\");\\r\\n\\r\\n        uint256[] memory cards = new uint256[](1);\\r\\n        cards[0] = color.add(10).add(num.mul(1000));\\r\\n\\r\\n        ICardERC(tokenCard).cardsBatchBurnFrom(msg.sender, cards);\\r\\n        IERC20(tokenMonet).transfer(msg.sender, num.mul(cardsReward));\\r\\n\\r\\n        emit Reward(msg.sender, cards);\\r\\n    }\\r\\n\\r\\n    // MODIFIER\\r\\n    modifier rateRevise(){\\r\\n        if (rate != 1 && block.timestamp > ratePeriodFinish) {\\r\\n            rate = rate.div(2);\\r\\n            ratePeriodFinish = ratePeriodFinish.add(30 days);\\r\\n        }\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier laveCardsReset() {\\r\\n        if (lavePeriodFinish <= block.timestamp) {\\r\\n            laveCards = rate.mul(1e3);\\r\\n            lavePeriodFinish = lavePeriodFinish.add(1 days);\\r\\n        }  \\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validateSender(address account) {\\r\\n        uint256 size;\\r\\n        assembly { size := extcodesize(account) }\\r\\n        require(size == 0, \\\"account is contract\\\");\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // EVENT\\r\\n    event Reward(address indexed sender, uint256[] cards);\\r\\n    event Lottery(address indexed sender, uint256[] cards);\\r\\n    event TransferCards(address indexed sender, uint256[] burnCards, uint256[] issueCards);\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n    function burnFrom(address from, uint256 value) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface ICardERC {\\r\\n    function cardsBatchMint(address _to, uint256[] calldata _cards) external;\\r\\n    function cardsBatchBurnFrom(address _from, uint256[] calldata _cards) external;\\r\\n    function cardsNumOf(address _owner, uint256 _level, uint256 _carry) external view returns (uint256);\\r\\n    function cardsNumOfAll(address _owner, uint256 _carry) external view returns (uint256[10] memory);\\r\\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\r\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/Card.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\nlibrary Card {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    function make(uint256 x, uint256 y, uint256 z, uint256 u, uint256 unit) internal pure returns (uint256) {\\r\\n        return x.mul(unit**3).add(y.mul(unit**2)).add(z.mul(unit)).add(u);\\r\\n    }\\r\\n\\r\\n    function num(uint256 x, uint256 y, uint256 unit) internal pure returns (uint256) {\\r\\n        return x.div(unit**(uint256(3).sub(y))) % unit;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 x, uint256 y, uint256 z, uint256 unit) internal pure returns (uint256) {\\r\\n        return x.sub(z.mul(unit**(uint256(3).sub(y))));\\r\\n    }\\r\\n\\r\\n    function merge(uint256 x, uint256 y, uint256 unit) internal pure returns (uint256) {\\r\\n        uint256 a = num(x, 0, unit).add(num(y, 0, unit));\\r\\n        uint256 b = num(x, 1, unit).add(num(y, 1, unit));\\r\\n        uint256 c = num(x, 2, unit).add(num(y, 2, unit));\\r\\n        uint256 d = num(x, 3, unit).add(num(y, 3, unit));\\r\\n        return make(a, b, c, d, unit);\\r\\n    }\\r\\n\\r\\n    function min(uint256 x, uint256 unit) internal pure returns (uint256) {\\r\\n        uint256 _min = num(x, 0, unit);\\r\\n        for (uint256 i = 1; i < 4; i++) {\\r\\n            uint256 _num = num(x, i, unit);\\r\\n            if (_num < _min) _min = _num;\\r\\n        }\\r\\n        return _min;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/MonetAirdrop.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./libraries/SafeMath.sol\\\";\\r\\n\\r\\ncontract MonetAirdrop is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public tokenCards;\\r\\n    uint256 public laveCards;\\r\\n    mapping(uint256 => uint256) cardNums;\\r\\n    mapping(address => bool) public partner;\\r\\n\\r\\n    constructor(address cards) public {\\r\\n        tokenCards = cards;\\r\\n    }\\r\\n\\r\\n    // EXTERNAL\\r\\n    function notify(address[] calldata accounts, uint256[] calldata cards) external onlyOwner {\\r\\n        setCards(cards);\\r\\n        setPartner(accounts);\\r\\n    }\\r\\n\\r\\n    function setPartner(address[] memory accounts) public onlyOwner {\\r\\n        for (uint256 i = 0; i < accounts.length; i++) {\\r\\n            partner[accounts[i]] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setCards(uint256[] memory cards) public onlyOwner {\\r\\n        require(cards.length > 0, \\\"cards is empty\\\");\\r\\n\\r\\n        uint256 levelMax = 10;\\r\\n        uint256 _laveCards = laveCards;\\r\\n        for (uint256 i = 0; i < cards.length; i++) {\\r\\n            cardNums[levelMax.sub(i)] = cards[i];\\r\\n            _laveCards = _laveCards.add(cards[i]);\\r\\n        }\\r\\n        laveCards = _laveCards;\\r\\n    }\\r\\n\\r\\n    function airdrop() external onlyCaller(msg.sender) {\\r\\n        require(laveCards > 0, \\\"lave cards is zero\\\");\\r\\n        require(partner[msg.sender], \\\"Caller is not partner\\\");\\r\\n\\r\\n        uint256 seed = uint256(\\r\\n            keccak256(abi.encodePacked(block.difficulty, now))\\r\\n        );\\r\\n        uint256 num = 0;\\r\\n        uint256 random = seed % laveCards;\\r\\n        for (uint256 i = 10; i > 4; i--) {\\r\\n            if (cardNums[i] == 0) continue;\\r\\n            num = num.add(cardNums[i]);\\r\\n            if (random <= num) {\\r\\n                partner[msg.sender] = false;\\r\\n                laveCards = laveCards.sub(1);\\r\\n                cardNums[i] = cardNums[i].sub(1);\\r\\n                uint256 color = (seed / 10 - seed) % 4;\\r\\n                uint256[] memory cards = new uint256[](1);\\r\\n                cards[0] = i.mul(10).add(color).add(1000);\\r\\n                ICardERC(tokenCards).cardsBatchMint(msg.sender, cards);\\r\\n                emit Airdrop(msg.sender, cards[0]);\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // MODIFIER\\r\\n    modifier onlyCaller(address account) {\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        require(size == 0, \\\"account is contract\\\");\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // EVENT\\r\\n    event Airdrop(address indexed sender, uint256 card);\\r\\n}\\r\\n\\r\\ninterface ICardERC {\\r\\n    function cardsBatchMint(address _to, uint256[] calldata _cards) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"MinterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mintFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MonetLuckyToken","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}