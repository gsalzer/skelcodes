{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/contracts/versioning/Deployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {ISynthereumFinder} from './interfaces/IFinder.sol';\\nimport {ISynthereumDeployer} from './interfaces/IDeployer.sol';\\nimport {\\n  ISynthereumFactoryVersioning\\n} from './interfaces/IFactoryVersioning.sol';\\nimport {ISynthereumPoolRegistry} from './interfaces/IPoolRegistry.sol';\\nimport {IERC20} from '../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IDeploymentSignature} from './interfaces/IDeploymentSignature.sol';\\nimport {\\n  ISynthereumPoolDeployment\\n} from '../synthereum-pool/common/interfaces/IPoolDeployment.sol';\\nimport {\\n  IDerivativeDeployment\\n} from '../derivative/common/interfaces/IDerivativeDeployment.sol';\\nimport {SynthereumInterfaces} from './Constants.sol';\\nimport {Address} from '../../@openzeppelin/contracts/utils/Address.sol';\\nimport {\\n  EnumerableSet\\n} from '../../@openzeppelin/contracts/utils/EnumerableSet.sol';\\nimport {\\n  Lockable\\n} from '../../@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol';\\nimport {\\n  AccessControl\\n} from '../../@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract SynthereumDeployer is ISynthereumDeployer, AccessControl, Lockable {\\n  using Address for address;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n  }\\n\\n  ISynthereumFinder public synthereumFinder;\\n\\n  event PoolDeployed(\\n    uint8 indexed poolVersion,\\n    address indexed derivative,\\n    address newPool\\n  );\\n  event DerivativeDeployed(\\n    uint8 indexed derivativeVersion,\\n    address indexed pool,\\n    address newDerivative\\n  );\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  constructor(ISynthereumFinder _synthereumFinder, Roles memory _roles) public {\\n    synthereumFinder = _synthereumFinder;\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, _roles.admin);\\n    _setupRole(MAINTAINER_ROLE, _roles.maintainer);\\n  }\\n\\n  function deployPoolAndDerivative(\\n    uint8 derivativeVersion,\\n    uint8 poolVersion,\\n    bytes calldata derivativeParamsData,\\n    bytes calldata poolParamsData\\n  )\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n    returns (IDerivativeDeployment derivative, ISynthereumPoolDeployment pool)\\n  {\\n    ISynthereumFactoryVersioning factoryVersioning = getFactoryVersioning();\\n    derivative = deployDerivative(\\n      factoryVersioning,\\n      derivativeVersion,\\n      derivativeParamsData\\n    );\\n    checkDerivativeRoles(derivative);\\n    pool = deployPool(\\n      factoryVersioning,\\n      poolVersion,\\n      derivative,\\n      poolParamsData\\n    );\\n    checkPoolDeployment(pool, poolVersion);\\n    checkPoolAndDerivativeMatching(pool, derivative);\\n    setDerivativeRoles(derivative, pool);\\n    ISynthereumPoolRegistry poolRegister = getPoolRegister();\\n    poolRegister.registerPool(\\n      pool.syntheticTokenSymbol(),\\n      pool.collateralToken(),\\n      poolVersion,\\n      address(pool)\\n    );\\n    emit PoolDeployed(poolVersion, address(derivative), address(pool));\\n    emit DerivativeDeployed(\\n      derivativeVersion,\\n      address(pool),\\n      address(derivative)\\n    );\\n  }\\n\\n  function deployOnlyPool(\\n    uint8 poolVersion,\\n    bytes calldata poolParamsData,\\n    IDerivativeDeployment derivative\\n  )\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n    returns (ISynthereumPoolDeployment pool)\\n  {\\n    ISynthereumFactoryVersioning factoryVersioning = getFactoryVersioning();\\n    pool = deployPool(\\n      factoryVersioning,\\n      poolVersion,\\n      derivative,\\n      poolParamsData\\n    );\\n    checkPoolDeployment(pool, poolVersion);\\n    checkPoolAndDerivativeMatching(pool, derivative);\\n    ISynthereumPoolRegistry poolRegister = getPoolRegister();\\n    poolRegister.registerPool(\\n      pool.syntheticTokenSymbol(),\\n      pool.collateralToken(),\\n      poolVersion,\\n      address(pool)\\n    );\\n    emit PoolDeployed(poolVersion, address(derivative), address(pool));\\n  }\\n\\n  function deployOnlyDerivative(\\n    uint8 derivativeVersion,\\n    bytes calldata derivativeParamsData,\\n    ISynthereumPoolDeployment pool\\n  )\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n    returns (IDerivativeDeployment derivative)\\n  {\\n    ISynthereumFactoryVersioning factoryVersioning = getFactoryVersioning();\\n    derivative = deployDerivative(\\n      factoryVersioning,\\n      derivativeVersion,\\n      derivativeParamsData\\n    );\\n    checkDerivativeRoles(derivative);\\n    checkPoolAndDerivativeMatching(pool, derivative);\\n    setDerivativeRoles(derivative, pool);\\n    emit DerivativeDeployed(\\n      derivativeVersion,\\n      address(pool),\\n      address(derivative)\\n    );\\n  }\\n\\n  function deployDerivative(\\n    ISynthereumFactoryVersioning factoryVersioning,\\n    uint8 derivativeVersion,\\n    bytes memory derivativeParamsData\\n  ) internal returns (IDerivativeDeployment derivative) {\\n    address derivativeFactory =\\n      factoryVersioning.getDerivativeFactoryVersion(derivativeVersion);\\n    bytes memory derivativeDeploymentResult =\\n      derivativeFactory.functionCall(\\n        abi.encodePacked(\\n          getDeploymentSignature(derivativeFactory),\\n          derivativeParamsData\\n        ),\\n        'Wrong derivative deployment'\\n      );\\n    derivative = IDerivativeDeployment(\\n      abi.decode(derivativeDeploymentResult, (address))\\n    );\\n  }\\n\\n  function deployPool(\\n    ISynthereumFactoryVersioning factoryVersioning,\\n    uint8 poolVersion,\\n    IDerivativeDeployment derivative,\\n    bytes memory poolParamsData\\n  ) internal returns (ISynthereumPoolDeployment pool) {\\n    address poolFactory = factoryVersioning.getPoolFactoryVersion(poolVersion);\\n    bytes memory poolDeploymentResult =\\n      poolFactory.functionCall(\\n        abi.encodePacked(\\n          getDeploymentSignature(poolFactory),\\n          bytes32(uint256(address(derivative))),\\n          poolParamsData\\n        ),\\n        'Wrong pool deployment'\\n      );\\n    pool = ISynthereumPoolDeployment(\\n      abi.decode(poolDeploymentResult, (address))\\n    );\\n  }\\n\\n  function setDerivativeRoles(\\n    IDerivativeDeployment derivative,\\n    ISynthereumPoolDeployment pool\\n  ) internal {\\n    address poolAddr = address(pool);\\n    derivative.addAdminAndPool(poolAddr);\\n    derivative.renounceAdmin();\\n  }\\n\\n  function getFactoryVersioning()\\n    internal\\n    view\\n    returns (ISynthereumFactoryVersioning factoryVersioning)\\n  {\\n    factoryVersioning = ISynthereumFactoryVersioning(\\n      synthereumFinder.getImplementationAddress(\\n        SynthereumInterfaces.FactoryVersioning\\n      )\\n    );\\n  }\\n\\n  function getPoolRegister()\\n    internal\\n    view\\n    returns (ISynthereumPoolRegistry poolRegister)\\n  {\\n    poolRegister = ISynthereumPoolRegistry(\\n      synthereumFinder.getImplementationAddress(\\n        SynthereumInterfaces.PoolRegistry\\n      )\\n    );\\n  }\\n\\n  function getDeploymentSignature(address deploymentContract)\\n    internal\\n    view\\n    returns (bytes4 signature)\\n  {\\n    signature = IDeploymentSignature(deploymentContract).deploymentSignature();\\n  }\\n\\n  function checkDerivativeRoles(IDerivativeDeployment derivative)\\n    internal\\n    view\\n  {\\n    address[] memory derivativeAdmins = derivative.getAdminMembers();\\n    require(derivativeAdmins.length == 1, 'The derivative must have one admin');\\n    require(\\n      derivativeAdmins[0] == address(this),\\n      'The derivative admin must be the deployer'\\n    );\\n    address[] memory derivativePools = derivative.getPoolMembers();\\n    require(derivativePools.length == 0, 'The derivative must have no pools');\\n  }\\n\\n  function checkPoolDeployment(ISynthereumPoolDeployment pool, uint8 version)\\n    internal\\n    view\\n  {\\n    require(\\n      pool.synthereumFinder() == synthereumFinder,\\n      'Wrong finder in pool deployment'\\n    );\\n    require(pool.version() == version, 'Wrong version in pool deployment');\\n  }\\n\\n  function checkPoolAndDerivativeMatching(\\n    ISynthereumPoolDeployment pool,\\n    IDerivativeDeployment derivative\\n  ) internal view {\\n    require(\\n      pool.collateralToken() == derivative.collateralCurrency(),\\n      'Wrong collateral matching'\\n    );\\n    require(\\n      pool.syntheticToken() == derivative.tokenCurrency(),\\n      'Wrong synthetic token matching'\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IFinder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface ISynthereumFinder {\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {\\n  ISynthereumPoolDeployment\\n} from '../../synthereum-pool/common/interfaces/IPoolDeployment.sol';\\nimport {\\n  IDerivativeDeployment\\n} from '../../derivative/common/interfaces/IDerivativeDeployment.sol';\\nimport {\\n  EnumerableSet\\n} from '../../../@openzeppelin/contracts/utils/EnumerableSet.sol';\\n\\ninterface ISynthereumDeployer {\\n  function deployPoolAndDerivative(\\n    uint8 derivativeVersion,\\n    uint8 poolVersion,\\n    bytes calldata derivativeParamsData,\\n    bytes calldata poolParamsData\\n  )\\n    external\\n    returns (IDerivativeDeployment derivative, ISynthereumPoolDeployment pool);\\n\\n  function deployOnlyPool(\\n    uint8 poolVersion,\\n    bytes calldata poolParamsData,\\n    IDerivativeDeployment derivative\\n  ) external returns (ISynthereumPoolDeployment pool);\\n\\n  function deployOnlyDerivative(\\n    uint8 derivativeVersion,\\n    bytes calldata derivativeParamsData,\\n    ISynthereumPoolDeployment pool\\n  ) external returns (IDerivativeDeployment derivative);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IFactoryVersioning.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface ISynthereumFactoryVersioning {\\n  function setPoolFactory(uint8 version, address poolFactory) external;\\n\\n  function removePoolFactory(uint8 version) external;\\n\\n  function setDerivativeFactory(uint8 version, address derivativeFactory)\\n    external;\\n\\n  function removeDerivativeFactory(uint8 version) external;\\n\\n  function getPoolFactoryVersion(uint8 version) external view returns (address);\\n\\n  function numberOfVerisonsOfPoolFactory() external view returns (uint256);\\n\\n  function getDerivativeFactoryVersion(uint8 version)\\n    external\\n    view\\n    returns (address);\\n\\n  function numberOfVerisonsOfDerivativeFactory()\\n    external\\n    view\\n    returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IPoolRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface ISynthereumPoolRegistry {\\n  function registerPool(\\n    string calldata syntheticTokenSymbol,\\n    IERC20 collateralToken,\\n    uint8 poolVersion,\\n    address pool\\n  ) external;\\n\\n  function isPoolDeployed(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion,\\n    address pool\\n  ) external view returns (bool isDeployed);\\n\\n  function getPools(\\n    string calldata poolSymbol,\\n    IERC20 collateral,\\n    uint8 poolVersion\\n  ) external view returns (address[] memory);\\n\\n  function getCollaterals() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/interfaces/IDeploymentSignature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface IDeploymentSignature {\\n  function deploymentSignature() external view returns (bytes4 signature);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/synthereum-pool/common/interfaces/IPoolDeployment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {ISynthereumFinder} from '../../../versioning/interfaces/IFinder.sol';\\n\\ninterface ISynthereumPoolDeployment {\\n  function synthereumFinder() external view returns (ISynthereumFinder finder);\\n\\n  function version() external view returns (uint8 poolVersion);\\n\\n  function collateralToken() external view returns (IERC20 collateralCurrency);\\n\\n  function syntheticToken() external view returns (IERC20 syntheticCurrency);\\n\\n  function syntheticTokenSymbol() external view returns (string memory symbol);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/derivative/common/interfaces/IDerivativeDeployment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IDerivativeDeployment {\\n  function addAdminAndPool(address adminAndPool) external;\\n\\n  function renounceAdmin() external;\\n\\n  function collateralCurrency() external view returns (IERC20 collateral);\\n\\n  function tokenCurrency() external view returns (IERC20 syntheticCurrency);\\n\\n  function getAdminMembers() external view returns (address[] memory);\\n\\n  function getPoolMembers() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/versioning/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nlibrary SynthereumInterfaces {\\n  bytes32 public constant Deployer = 'Deployer';\\n  bytes32 public constant FactoryVersioning = 'FactoryVersioning';\\n  bytes32 public constant PoolRegistry = 'PoolRegistry';\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.8.0;\\n\\nlibrary Address {\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(\\n      success,\\n      'Address: unable to send value, recipient may have reverted'\\n    );\\n  }\\n\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return functionCall(target, data, 'Address: low-level call failed');\\n  }\\n\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        'Address: low-level call with value failed'\\n      );\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance >= value,\\n      'Address: insufficient balance for call'\\n    );\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(target, data, 'Address: low-level static call failed');\\n  }\\n\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), 'Address: static call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      if (returndata.length > 0) {\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary EnumerableSet {\\n  struct Set {\\n    bytes32[] _values;\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      bytes32 lastvalue = set._values[lastIndex];\\n\\n      set._values[toDeleteIndex] = lastvalue;\\n\\n      set._indexes[lastvalue] = toDeleteIndex + 1;\\n\\n      set._values.pop();\\n\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _contains(Set storage set, bytes32 value)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    require(set._values.length > index, 'EnumerableSet: index out of bounds');\\n    return set._values[index];\\n  }\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  function remove(Bytes32Set storage set, bytes32 value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, value);\\n  }\\n\\n  function contains(Bytes32Set storage set, bytes32 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, value);\\n  }\\n\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(Bytes32Set storage set, uint256 index)\\n    internal\\n    view\\n    returns (bytes32)\\n  {\\n    return _at(set._inner, index);\\n  }\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function remove(AddressSet storage set, address value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function contains(AddressSet storage set, address value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(AddressSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return address(uint256(_at(set._inner, index)));\\n  }\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  function contains(UintSet storage set, uint256 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(UintSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return uint256(_at(set._inner, index));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ncontract Lockable {\\n  bool private _notEntered;\\n\\n  constructor() internal {\\n    _notEntered = true;\\n  }\\n\\n  modifier nonReentrant() {\\n    _preEntranceCheck();\\n    _preEntranceSet();\\n    _;\\n    _postEntranceReset();\\n  }\\n\\n  modifier nonReentrantView() {\\n    _preEntranceCheck();\\n    _;\\n  }\\n\\n  function _preEntranceCheck() internal view {\\n    require(_notEntered, 'ReentrancyGuard: reentrant call');\\n  }\\n\\n  function _preEntranceSet() internal {\\n    _notEntered = false;\\n  }\\n\\n  function _postEntranceReset() internal {\\n    _notEntered = true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../utils/EnumerableSet.sol';\\nimport '../utils/Address.sol';\\nimport '../GSN/Context.sol';\\n\\nabstract contract AccessControl is Context {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using Address for address;\\n\\n  struct RoleData {\\n    EnumerableSet.AddressSet members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  event RoleGranted(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  event RoleRevoked(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  function hasRole(bytes32 role, address account) public view returns (bool) {\\n    return _roles[role].members.contains(account);\\n  }\\n\\n  function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n    return _roles[role].members.length();\\n  }\\n\\n  function getRoleMember(bytes32 role, uint256 index)\\n    public\\n    view\\n    returns (address)\\n  {\\n    return _roles[role].members.at(index);\\n  }\\n\\n  function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  function grantRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to grant'\\n    );\\n\\n    _grantRole(role, account);\\n  }\\n\\n  function revokeRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to revoke'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function renounceRole(bytes32 role, address account) public virtual {\\n    require(\\n      account == _msgSender(),\\n      'AccessControl: can only renounce roles for self'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (_roles[role].members.add(account)) {\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (_roles[role].members.remove(account)) {\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this;\\n    return msg.data;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"_synthereumFinder\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maintainer\",\"type\":\"address\"}],\"internalType\":\"struct SynthereumDeployer.Roles\",\"name\":\"_roles\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"derivativeVersion\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDerivative\",\"type\":\"address\"}],\"name\":\"DerivativeDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"poolVersion\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"derivative\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPool\",\"type\":\"address\"}],\"name\":\"PoolDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAINTAINER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"derivativeVersion\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"derivativeParamsData\",\"type\":\"bytes\"},{\"internalType\":\"contract ISynthereumPoolDeployment\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"deployOnlyDerivative\",\"outputs\":[{\"internalType\":\"contract IDerivativeDeployment\",\"name\":\"derivative\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"poolVersion\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"poolParamsData\",\"type\":\"bytes\"},{\"internalType\":\"contract IDerivativeDeployment\",\"name\":\"derivative\",\"type\":\"address\"}],\"name\":\"deployOnlyPool\",\"outputs\":[{\"internalType\":\"contract ISynthereumPoolDeployment\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"derivativeVersion\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"poolVersion\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"derivativeParamsData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"poolParamsData\",\"type\":\"bytes\"}],\"name\":\"deployPoolAndDerivative\",\"outputs\":[{\"internalType\":\"contract IDerivativeDeployment\",\"name\":\"derivative\",\"type\":\"address\"},{\"internalType\":\"contract ISynthereumPoolDeployment\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synthereumFinder\",\"outputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SynthereumDeployer","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d451de78e297b496ee8a4f06dcf991c17580b452000000000000000000000000128c8e20dd4f2d8519dd605632660686ba35d21200000000000000000000000001160b02645727d09493d14a39ede6ec749a6555","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}