{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AutoRewardToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.7.0;\\n\\nimport '@solidstate/contracts/contracts/token/ERC20/ERC20.sol';\\nimport '@solidstate/contracts/contracts/token/ERC20/ERC20MetadataStorage.sol';\\n\\nimport './AutoRewardTokenStorage.sol';\\n\\n/**\\n * @title Fee-on-transfer token with frictionless distribution to holders\\n * @author Nick Barry\\n */\\ncontract AutoRewardToken is ERC20 {\\n  using ERC20MetadataStorage for ERC20MetadataStorage.Layout;\\n\\n  uint private constant BP_DIVISOR = 10000;\\n  uint private constant REWARD_SCALAR = 1e36;\\n\\n  constructor (\\n    string memory name,\\n    string memory symbol,\\n    uint supply,\\n    uint fee\\n  ) {\\n    require(fee <= BP_DIVISOR, 'AutoRewardToken: fee must not exceed 10000 bp');\\n\\n    {\\n      ERC20MetadataStorage.Layout storage l = ERC20MetadataStorage.layout();\\n      l.setName(name);\\n      l.setSymbol(symbol);\\n      l.setDecimals(18);\\n    }\\n\\n    AutoRewardTokenStorage.layout().fee = fee;\\n\\n    _mint(msg.sender, supply);\\n  }\\n\\n  /**\\n   * @notice return network fee\\n   * @return fee in basis points\\n   */\\n  function getFee () external view returns (uint) {\\n    return AutoRewardTokenStorage.layout().fee;\\n  }\\n\\n  /**\\n   * @inheritdoc ERC20Base\\n   */\\n  function balanceOf (\\n    address account\\n  ) override public view returns (uint) {\\n    return super.balanceOf(account) + rewardsOf(account);\\n  }\\n\\n  /**\\n   * @notice get pending rewards pending distribution to given account\\n   * @param account owner of rewards\\n   * @return quantity of rewards\\n   */\\n  function rewardsOf (\\n    address account\\n  ) public view returns (uint) {\\n    AutoRewardTokenStorage.Layout storage l = AutoRewardTokenStorage.layout();\\n    return (\\n      super.balanceOf(account) * l.cumulativeRewardPerToken\\n      + l.rewardsReserved[account]\\n      - l.rewardsExcluded[account]\\n    ) / REWARD_SCALAR;\\n  }\\n\\n  /**\\n   * @inheritdoc ERC20Base\\n   * @notice override of _transfer function to include call to _afterTokenTransfer\\n   */\\n  function _transfer (\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) override internal {\\n    super._transfer(sender, recipient, amount);\\n    _afterTokenTransfer(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @notice ERC20 hook: apply fees and distribute rewards on transfer\\n   * @inheritdoc ERC20Base\\n   */\\n  function _beforeTokenTransfer (\\n    address from,\\n    address to,\\n    uint amount\\n  ) override internal {\\n    super._beforeTokenTransfer(from, to, amount);\\n\\n    if (from == address(0) || to == address(0)) {\\n      return;\\n    }\\n\\n    AutoRewardTokenStorage.Layout storage l = AutoRewardTokenStorage.layout();\\n\\n    uint fee = amount * l.fee / BP_DIVISOR;\\n\\n    // update internal balances to include rewards\\n\\n    uint rewardsFrom = rewardsOf(from);\\n    ERC20BaseStorage.layout().balances[from] += rewardsFrom;\\n    delete l.rewardsReserved[from];\\n\\n    uint rewardsTo = rewardsOf(to);    \\n    ERC20BaseStorage.layout().balances[to] += rewardsTo;\\n    \\n    delete l.rewardsReserved[to];\\n\\n    // track exclusions from future rewards\\n\\n    l.rewardsExcluded[from] = (super.balanceOf(from) - amount) * l.cumulativeRewardPerToken;\\n    l.rewardsExcluded[to] = (super.balanceOf(to) + amount - fee) * l.cumulativeRewardPerToken;\\n    \\n    // distribute rewards globally\\n\\n    l.cumulativeRewardPerToken += (fee * REWARD_SCALAR) / (totalSupply() - fee);\\n\\n    // simulate transfers\\n    emit Transfer(from, address(0), fee);\\n    emit Transfer(address(0), from, rewardsFrom);\\n    emit Transfer(address(0), to, rewardsTo);\\n  }\\n\\n  /**\\n   * @notice ERC20 hook: remove fee from recipient\\n   * @param to recipient address\\n   * @param amount quantity transferred\\n   */\\n  function _afterTokenTransfer (\\n    address,\\n    address to,\\n    uint amount\\n  ) private {\\n    _burnFee(to, amount * AutoRewardTokenStorage.layout().fee / BP_DIVISOR);\\n\\n  }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport './ERC20Base.sol';\\r\\nimport './ERC20Extended.sol';\\r\\nimport './ERC20Metadata.sol';\\r\\n\\r\\nabstract contract ERC20 is ERC20Base, ERC20Extended, ERC20Metadata {}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/contracts/token/ERC20/ERC20MetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nlibrary ERC20MetadataStorage {\\r\\n  bytes32 internal constant STORAGE_SLOT = keccak256(\\r\\n    'solidstate.contracts.storage.ERC20Metadata'\\r\\n  );\\r\\n\\r\\n  struct Layout {\\r\\n    string name;\\r\\n    string symbol;\\r\\n    uint8 decimals;\\r\\n  }\\r\\n\\r\\n  function layout () internal pure returns (Layout storage l) {\\r\\n    bytes32 slot = STORAGE_SLOT;\\r\\n    assembly { l.slot := slot }\\r\\n  }\\r\\n\\r\\n  function setName (\\r\\n    Layout storage l,\\r\\n    string memory name\\r\\n  ) internal {\\r\\n    l.name = name;\\r\\n  }\\r\\n\\r\\n  function setSymbol (\\r\\n    Layout storage l,\\r\\n    string memory symbol\\r\\n  ) internal {\\r\\n    l.symbol = symbol;\\r\\n  }\\r\\n\\r\\n  function setDecimals (\\r\\n    Layout storage l,\\r\\n    uint8 decimals\\r\\n  ) internal {\\r\\n    l.decimals = decimals;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/AutoRewardTokenStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.7.0;\\n\\nlibrary AutoRewardTokenStorage {\\n  bytes32 internal constant STORAGE_SLOT = keccak256(\\n    'solidstate.contracts.storage.AutoRewardToken'\\n  );\\n\\n  struct Layout {\\n    uint fee;\\n    uint cumulativeRewardPerToken;\\n    mapping (address => uint) rewardsExcluded;\\n    mapping (address => uint) rewardsReserved;\\n  }\\n\\n  function layout () internal pure returns (Layout storage l) {\\n    bytes32 slot = STORAGE_SLOT;\\n    assembly { l.slot := slot }\\n  }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/contracts/token/ERC20/ERC20Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport '../../utils/SafeMath.sol';\\r\\nimport './IERC20.sol';\\r\\nimport './ERC20BaseStorage.sol';\\r\\n\\r\\nabstract contract ERC20Base is IERC20 {\\r\\n  using SafeMath for uint;\\r\\n\\r\\n  function totalSupply () override virtual public view returns (uint) {\\r\\n    return ERC20BaseStorage.layout().totalSupply;\\r\\n  }\\r\\n\\r\\n  function balanceOf (\\r\\n    address account\\r\\n  ) override virtual public view returns (uint) {\\r\\n    return ERC20BaseStorage.layout().balances[account];\\r\\n  }\\r\\n\\r\\n  function allowance (\\r\\n    address holder,\\r\\n    address spender\\r\\n  ) override virtual public view returns (uint) {\\r\\n    return ERC20BaseStorage.layout().allowances[holder][spender];\\r\\n  }\\r\\n\\r\\n  function transfer (\\r\\n    address recipient,\\r\\n    uint amount\\r\\n  ) override virtual public returns (bool) {\\r\\n    _transfer(msg.sender, recipient, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function transferFrom (\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint amount\\r\\n  ) override virtual public returns (bool) {\\r\\n    _approve(sender, msg.sender, ERC20BaseStorage.layout().allowances[sender][msg.sender].sub(amount, 'ERC20: transfer amount exceeds allowance'));\\r\\n    _transfer(sender, recipient, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function approve (\\r\\n    address spender,\\r\\n    uint amount\\r\\n  ) override virtual public returns (bool) {\\r\\n    _approve(msg.sender, spender, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function _mint (\\r\\n    address account,\\r\\n    uint amount\\r\\n  ) virtual internal {\\r\\n    require(account != address(0), 'ERC20: mint to the zero address');\\r\\n\\r\\n    _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\r\\n    l.totalSupply = l.totalSupply.add(amount);\\r\\n    l.balances[account] = l.balances[account].add(amount);\\r\\n\\r\\n    emit Transfer(address(0), account, amount);\\r\\n  }\\r\\n\\r\\n  function _burn (\\r\\n    address account,\\r\\n    uint amount\\r\\n  ) virtual internal {\\r\\n    require(account != address(0), 'ERC20: burn from the zero address');\\r\\n\\r\\n    _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\r\\n    l.balances[account] = l.balances[account].sub(amount);\\r\\n    l.totalSupply = l.totalSupply.sub(amount);\\r\\n\\r\\n    emit Transfer(account, address(0), amount);\\r\\n  }\\r\\n\\r\\n   function _burnFee (\\r\\n    address account,\\r\\n    uint amount\\r\\n  ) virtual internal {\\r\\n    require(account != address(0), 'ERC20: burn from the zero address');\\r\\n\\r\\n    _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\r\\n    l.balances[account] = l.balances[account].sub(amount);\\r\\n    //l.totalSupply = l.totalSupply.sub(amount);\\r\\n\\r\\n    //emit Transfer(account, address(0), amount);\\r\\n  }\\r\\n\\r\\n  function _transfer (\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint amount\\r\\n  ) virtual internal {\\r\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\r\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\r\\n\\r\\n    _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\r\\n    l.balances[sender] = l.balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\\r\\n    l.balances[recipient] = l.balances[recipient].add(amount);\\r\\n\\r\\n    emit Transfer(sender, recipient, amount);\\r\\n  }\\r\\n\\r\\n  function _approve (\\r\\n    address holder,\\r\\n    address spender,\\r\\n    uint amount\\r\\n  ) virtual internal {\\r\\n    require(holder != address(0), 'ERC20: approve from the zero address');\\r\\n    require(spender != address(0), 'ERC20: approve to the zero address');\\r\\n\\r\\n    ERC20BaseStorage.layout().allowances[holder][spender] = amount;\\r\\n\\r\\n    emit Approval(holder, spender, amount);\\r\\n  }\\r\\n\\r\\n  function _beforeTokenTransfer (\\r\\n    address from,\\r\\n    address to,\\r\\n    uint amount\\r\\n  ) virtual internal {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/contracts/token/ERC20/ERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport '../../utils/SafeMath.sol';\\r\\nimport './ERC20Base.sol';\\r\\n\\r\\nabstract contract ERC20Extended is ERC20Base {\\r\\n  using SafeMath for uint;\\r\\n\\r\\n  function increaseAllowance (address spender, uint amount) virtual public returns (bool) {\\r\\n    _approve(msg.sender, spender, ERC20BaseStorage.layout().allowances[msg.sender][spender].add(amount));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function decreaseAllowance (address spender, uint amount) virtual public returns (bool) {\\r\\n    _approve(msg.sender, spender, ERC20BaseStorage.layout().allowances[msg.sender][spender].sub(amount));\\r\\n    return true;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/contracts/token/ERC20/ERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport './ERC20Base.sol';\\r\\nimport './ERC20MetadataStorage.sol';\\r\\n\\r\\nabstract contract ERC20Metadata is ERC20Base {\\r\\n  function name () virtual public view returns (string memory) {\\r\\n    return ERC20MetadataStorage.layout().name;\\r\\n  }\\r\\n\\r\\n  function symbol () virtual public view returns (string memory) {\\r\\n    return ERC20MetadataStorage.layout().symbol;\\r\\n  }\\r\\n\\r\\n  function decimals () virtual public view returns (uint8) {\\r\\n    return ERC20MetadataStorage.layout().decimals;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.0 <0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\r\\n */\\r\\nlibrary SafeMath {\\r\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n    uint256 c = a + b;\\r\\n    if (c < a) return (false, 0);\\r\\n    return (true, c);\\r\\n  }\\r\\n\\r\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n    if (b > a) return (false, 0);\\r\\n    return (true, a - b);\\r\\n  }\\r\\n\\r\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n    if (a == 0) return (true, 0);\\r\\n    uint256 c = a * b;\\r\\n    if (c / a != b) return (false, 0);\\r\\n    return (true, c);\\r\\n  }\\r\\n\\r\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n    if (b == 0) return (false, 0);\\r\\n    return (true, a / b);\\r\\n  }\\r\\n\\r\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n    if (b == 0) return (false, 0);\\r\\n    return (true, a % b);\\r\\n  }\\r\\n\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    if (a == 0) return 0;\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n    return a / b;\\r\\n  }\\r\\n\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n      require(b > 0, \\\"SafeMath: modulo by zero\\\");\\r\\n    return a % b;\\r\\n  }\\r\\n\\r\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n      require(b <= a, errorMessage);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n      require(b > 0, errorMessage);\\r\\n    return a / b;\\r\\n  }\\r\\n\\r\\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n      require(b > 0, errorMessage);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n  event Transfer(\\r\\n    address indexed from,\\r\\n    address indexed to,\\r\\n    uint256 value\\r\\n  );\\r\\n\\r\\n  event Approval(\\r\\n    address indexed owner,\\r\\n    address indexed spender,\\r\\n    uint256 value\\r\\n  );\\r\\n\\r\\n  function totalSupply () external view returns (uint256);\\r\\n\\r\\n  function balanceOf (\\r\\n    address account\\r\\n  ) external view returns (uint256);\\r\\n\\r\\n  function transfer (\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n\\r\\n  function allowance (\\r\\n    address owner,\\r\\n    address spender\\r\\n  ) external view returns (uint256);\\r\\n\\r\\n  function approve (\\r\\n    address spender,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n\\r\\n  function transferFrom (\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/contracts/token/ERC20/ERC20BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nlibrary ERC20BaseStorage {\\r\\n  bytes32 internal constant STORAGE_SLOT = keccak256(\\r\\n    'solidstate.contracts.storage.ERC20Base'\\r\\n  );\\r\\n\\r\\n  struct Layout {\\r\\n    mapping (address => uint) balances;\\r\\n    mapping (address => mapping (address => uint)) allowances;\\r\\n    uint totalSupply;\\r\\n  }\\r\\n\\r\\n  function layout () internal pure returns (Layout storage l) {\\r\\n    bytes32 slot = STORAGE_SLOT;\\r\\n    assembly { l.slot := slot }\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewardsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AutoRewardToken","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000084595161401484a000000000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000000000f534849524c45592054484520524f5400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007534849524c455900000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}