{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\n\nlibrary SafeMath {\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) \n            return 0;\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        uint256 z = add(x >> 1, 1);\n        uint256 y = x;\n        while (z < y)\n        {\n            y = z;\n            z = ((add((x / z), z)) / 2);\n        }\n        return y;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) internal _balances;\n    mapping (address => mapping (address => uint256)) internal _allowed;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    uint256 internal _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return A uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param owner address The address which owns the funds.\n    * @param spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token to a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param spender The address which will spend the funds.\n    * @param value The amount of tokens to be spent.\n    */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n    * @dev Transfer tokens from one address to another.\n    * Note that while this function emits an Approval event, this is not required as per the specification,\n    * and other compliant implementations may not emit the event.\n    * @param from address The address which you want to send tokens from\n    * @param to address The address which you want to transfer to\n    * @param value uint256 the amount of tokens to be transferred\n    */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n}\n\ncontract ERC20Mintable is ERC20 {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    function _mint(address to, uint256 amount) internal {\n        _balances[to] = _balances[to].add(amount);\n        _totalSupply = _totalSupply.add(amount);\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal {\n        _balances[from] = _balances[from].sub(amount);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(from, address(0), amount);\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract blackholeswap is ERC20Mintable {\n    using SafeMath for *;\n    using SafeERC20 for IERC20;\n\n    /***********************************|\n    |        Variables && Events        |\n    |__________________________________*/\n    IERC20 constant token0 = ERC20(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51); //sUSD\n    IERC20 constant token1 = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); //DAI\n\n    event Purchases(address indexed buyer, address indexed sell_token, uint256 inputs, address indexed buy_token, uint256 outputs);\n    event AddLiquidity(address indexed provider, uint256 share, uint256 token0Amount, uint256 token1Amount);\n    event RemoveLiquidity(address indexed provider, uint256 share, uint256 token0Amount, uint256 token1Amount);\n\n    /***********************************|\n    |            Constsructor           |\n    |__________________________________*/\n\n    constructor() public {\n        symbol = \"BHS sUSD/DAI\";\n        name = \"BlackHoleSwap sUSD/DAI\";\n        decimals = 18;\n        admin = msg.sender;\n        vault = msg.sender;\n    }\n\n    /***********************************|\n    |        Governmence & Params       |\n    |__________________________________*/\n\n    uint256 public fee = 0.99985e18; // 1 - swap fee (numerator, in 1e18 format)\n    uint256 public protocolFee = 5;\n    uint256 public constant A = 0.75e18;\n    uint256 constant BASE = 1e18;\n\n    address private admin;\n    address private vault;\n\n    uint256 public kLast;\n\n    function setAdmin(address _admin) external {\n        require(msg.sender == admin);\n        admin = _admin;\n    }\n\n    function setParams(uint256 _fee, uint256 _protocolFee) external {\n        require(msg.sender == admin);\n        require(_fee < 1e18 && _fee >= 0.99e18); //0 < fee <= 1%\n        require(_protocolFee > 0); //protocolFee <= 50% fee\n        uint256 token0Reserve = getToken0Balance();\n        uint256 token1Reserve = getToken1Balance();\n        if(_totalSupply > 0) _mintFee(k(token0Reserve, token1Reserve));\n        fee = _fee;\n        protocolFee = _protocolFee;\n        kLast = k(token0Reserve, token1Reserve);\n    }\n\n    function setVault(address _vault) external {\n        require(msg.sender == admin);\n        vault = _vault;\n    }\n\n    /***********************************|\n    |         Getter Functions          |\n    |__________________________________*/\n\n    function getToken0Balance() public view returns (uint256) {\n        return token0.balanceOf(address(this));\n    }\n\n    function getToken1Balance() public view returns (uint256) {\n        return token1.balanceOf(address(this));\n    }\n\n    function k(uint256 x, uint256 y) internal pure returns (uint256 _k) {\n        uint256 u = x.add(y.mul(A).div(BASE));\n        uint256 v = y.add(x.mul(A).div(BASE));\n        _k = u.mul(v);\n    }\n\n    function f(uint256 _x, uint256 x, uint256 y) internal pure returns (uint256 _y) {\n        uint256 c = k(x, y).mul(BASE).div(A).sub(_x.mul(_x), \"INSUFFICIENT_LIQUIDITY\");\n\n        uint256 cst = A.add(uint256(1e36).div(A));\n        uint256 _b = _x.mul(cst).div(BASE);\n\n        uint256 D = _b.mul(_b).add(c.mul(4)); // b^2 - 4c\n\n        _y = D.sqrt().sub(_b).div(2);\n    }\n\n    // Calculate output given exact input\n    function getOutExactIn(uint256 input, uint256 x, uint256 y) public view returns (uint256 output) {\n        uint256 _x = x.add(input.mul(fee).div(BASE));\n        uint256 _y = f(_x, x, y);\n        output = y.sub(_y);\n    }\n\n    // Calculate input given exact output\n    function getInExactOut(uint256 output, uint256 x, uint256 y) public view returns (uint256 input) {\n        uint256 _y = y.sub(output);\n        uint256 _x = f(_y, y, x);\n        input = _x.sub(x).mul(BASE).div(fee);\n    }\n\n    /***********************************|\n    |        Exchange Functions         |\n    |__________________________________*/\n    \n    function _mintFee(uint256 _k) private {\n        uint _kLast = kLast; // gas savings\n\n        if (_kLast != 0) {\n            uint rootK = _k.sqrt();\n            uint rootKLast = _kLast.sqrt();\n            if (rootK > rootKLast) {\n                uint numerator = _totalSupply.mul(rootK.sub(rootKLast));\n                uint denominator = rootK.mul(protocolFee).add(rootKLast);\n                uint liquidity = numerator / denominator;\n                if (liquidity > 0) _mint(vault, liquidity);\n            }\n        }\n\n    }\n\n    function token0In(uint256 input, uint256 min_output, uint256 deadline) external returns (uint256 output) {\n        require(block.timestamp <= deadline, \"EXPIRED\");\n        uint256 fromReserve = getToken0Balance();\n        uint256 toReserve = getToken1Balance();\n\n        output = getOutExactIn(input, fromReserve, toReserve);\n        require(output >= min_output, \"SLIPPAGE_DETECTED\");\n        doTransferIn(token0, msg.sender, input);\n        doTransferOut(token1, msg.sender, output);\n\n        emit Purchases(msg.sender, address(token0), input, address(token1), output);\n    }\n    \n    function token1In(uint256 input, uint256 min_output, uint256 deadline) external returns (uint256 output) {\n        require(block.timestamp <= deadline, \"EXPIRED\");\n        uint256 fromReserve = getToken1Balance();\n        uint256 toReserve = getToken0Balance();\n\n        output = getOutExactIn(input, fromReserve, toReserve);\n        require(output >= min_output, \"SLIPPAGE_DETECTED\");\n        doTransferIn(token1, msg.sender, input);\n        doTransferOut(token0, msg.sender, output);\n\n        emit Purchases(msg.sender, address(token1), input, address(token0), output);\n    }\n\n    function token0Out(uint256 max_input, uint256 output, uint256 deadline) external returns (uint256 input) {\n        require(block.timestamp <= deadline, \"EXPIRED\");\n        uint256 fromReserve = getToken0Balance();\n        uint256 toReserve = getToken1Balance();\n\n        input = getInExactOut(output, fromReserve, toReserve);\n        require(input <= max_input, \"SLIPPAGE_DETECTED\");\n        doTransferIn(token1, msg.sender, input);\n        doTransferOut(token0, msg.sender, output);\n\n        emit Purchases(msg.sender, address(token1), input, address(token0), output);\n    }\n    \n    function token1Out(uint256 max_input, uint256 output, uint256 deadline) external returns (uint256 input) {\n        require(block.timestamp <= deadline, \"EXPIRED\");\n        uint256 fromReserve = getToken1Balance();\n        uint256 toReserve = getToken0Balance();\n\n        input = getInExactOut(output, fromReserve, toReserve);\n        require(input <= max_input, \"SLIPPAGE_DETECTED\");\n        doTransferIn(token0, msg.sender, input);\n        doTransferOut(token1, msg.sender, output);\n\n        emit Purchases(msg.sender, address(token1), input, address(token0), output);\n    }\n    \n    function doTransferIn(IERC20 token, address from, uint256 amount) internal {\n        token.safeTransferFrom(from, address(this), amount);\n    }\n\n    function doTransferOut(IERC20 token, address to, uint256 amount) internal {\n        token.safeTransfer(to, amount);\n    }\n\n\n    /***********************************|\n    |        Liquidity Functions        |\n    |__________________________________*/\n\n    function addLiquidity(uint256 share, uint256 token0_max, uint256 token1_max) external returns (uint256 token0_in, uint256 token1_in) {\n        require(share >= 1e15, 'INVALID_ARGUMENT'); // 0.001\n\n        if (_totalSupply > 0) {\n            uint256 token0Reserve = getToken0Balance();\n            uint256 token1Reserve = getToken1Balance();\n            _mintFee(k(token0Reserve, token1Reserve));\n            token0_in = share.mul(token0Reserve).div(_totalSupply);\n            token1_in = share.mul(token1Reserve).div(_totalSupply);\n            require(token0_in <= token0_max && token1_in <= token1_max, \"SLIPPAGE_DETECTED\");\n            _mint(msg.sender, share);\n            kLast = k(token0Reserve.add(token0_in), token1Reserve.add(token1_in));\n        }\n        else {\n            token0_in = share.div(2);\n            token1_in = share.div(2);\n            _mint(msg.sender, share);\n            kLast = k(token0_in, token1_in);\n        }\n\n        doTransferIn(token0, msg.sender, token0_in);\n        doTransferIn(token1, msg.sender, token1_in);\n        emit AddLiquidity(msg.sender, share, token0_in, token1_in);\n    }\n\n    function addLiquidityImbalanced(uint256 token0_in, uint256 token1_in, uint256 share_min) external returns (uint256 share) {\n        require(_totalSupply > 0, \"INSUFFICIENT_LIQUIDITY\");\n        uint256 token0Reserve = getToken0Balance();\n        uint256 token1Reserve = getToken1Balance();\n        uint256 kBefore = k(token0Reserve, token1Reserve);\n        // charge fee for imbalanced deposit\n        uint256 kAfter = k(token0Reserve.add(token0_in.mul(fee).div(BASE)), token1Reserve.add(token1_in.mul(fee).div(BASE)));\n        _mintFee(kBefore);\n        // ( sqrt(_k) * totalSupply / sqrt(k) - totalSupply )\n        share = kAfter.sqrt().mul(_totalSupply).div(kBefore.sqrt()).sub(_totalSupply);\n        require(share >= share_min, \"SLIPPAGE_DETECTED\");\n        _mint(msg.sender, share);\n\n        kLast = kAfter;\n        doTransferIn(token0, msg.sender, token0_in);\n        doTransferIn(token1, msg.sender, token1_in);\n        emit AddLiquidity(msg.sender, share, token0_in, token1_in);\n    }\n\n    function removeLiquidity(uint256 share, uint256 token0_min, uint256 token1_min) external returns (uint256 token0_out, uint256 token1_out) {\n        require(share > 0, 'INVALID_ARGUMENT');\n\n        uint256 token0Reserve = getToken0Balance();\n        uint256 token1Reserve = getToken1Balance();\n        _mintFee(k(token0Reserve, token1Reserve));\n\n        token0_out = share.mul(token0Reserve).div(_totalSupply);\n        token1_out = share.mul(token1Reserve).div(_totalSupply);\n        require(token0_out >= token0_min && token1_out >= token1_min, \"SLIPPAGE_DETECTED\");\n\n        _burn(msg.sender, share);\n\n        kLast = k(token0Reserve.sub(token0_out), token1Reserve.sub(token1_out));\n        doTransferOut(token0, msg.sender, token0_out);\n        doTransferOut(token1, msg.sender, token1_out);\n        emit RemoveLiquidity(msg.sender, share, token0_out, token1_out);\n    }\n\n}\n","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token1Amount\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sell_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputs\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputs\",\"type\":\"uint256\"}],\"name\":\"Purchases\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token1Amount\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"A\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0_max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1_max\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token0_in\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1_in\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token0_in\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1_in\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"share_min\",\"type\":\"uint256\"}],\"name\":\"addLiquidityImbalanced\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"getInExactOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"getOutExactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getToken0Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getToken1Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0_min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1_min\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token0_out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1_out\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"}],\"name\":\"setParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"token0In\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max_input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"token0Out\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"token1In\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max_input\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"token1Out\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"blackholeswap","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"54088","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}