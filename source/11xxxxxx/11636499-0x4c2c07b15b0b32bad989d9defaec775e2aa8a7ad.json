{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/utils/IMigratableVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IMigratableVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @dev DO NOT EDIT CONTRACT\\ninterface IMigratableVault {\\n    function canMigrate(address _who) external view returns (bool canMigrate_);\\n\\n    function init(\\n        address _owner,\\n        address _accessor,\\n        string calldata _fundName\\n    ) external;\\n\\n    function setAccessor(address _nextAccessor) external;\\n\\n    function setVaultLib(address _nextVaultLib) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund-deployer/IFundDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IFundDeployer Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IFundDeployer {\\n    enum ReleaseStatus {PreLaunch, Live, Paused}\\n\\n    function getOwner() external view returns (address);\\n\\n    function getReleaseStatus() external view returns (ReleaseStatus);\\n\\n    function isRegisteredVaultCall(address, bytes4) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund/comptroller/IComptroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IComptroller Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IComptroller {\\n    enum VaultAction {\\n        None,\\n        BurnShares,\\n        MintShares,\\n        TransferShares,\\n        ApproveAssetSpender,\\n        WithdrawAssetTo,\\n        AddTrackedAsset,\\n        RemoveTrackedAsset\\n    }\\n\\n    function activate(address, bool) external;\\n\\n    function calcGav(bool) external returns (uint256, bool);\\n\\n    function calcGrossShareValue(bool) external returns (uint256, bool);\\n\\n    function callOnExtension(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external;\\n\\n    function configureExtensions(bytes calldata, bytes calldata) external;\\n\\n    function destruct() external;\\n\\n    function getDenominationAsset() external view returns (address);\\n\\n    function getVaultProxy() external view returns (address);\\n\\n    function init(address, uint256) external;\\n\\n    function permissionedVaultAction(VaultAction, bytes calldata) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund/vault/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../../../persistent/utils/IMigratableVault.sol\\\";\\n\\n/// @title IVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IVault is IMigratableVault {\\n    function addTrackedAsset(address) external;\\n\\n    function approveAssetSpender(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function burnShares(address, uint256) external;\\n\\n    function callOnContract(address, bytes calldata) external;\\n\\n    function getAccessor() external view returns (address);\\n\\n    function getOwner() external view returns (address);\\n\\n    function getTrackedAssets() external view returns (address[] memory);\\n\\n    function isTrackedAsset(address) external view returns (bool);\\n\\n    function mintShares(address, uint256) external;\\n\\n    function removeTrackedAsset(address) external;\\n\\n    function transferShares(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function withdrawAssetTo(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/IExtension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExtension Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for all extensions\\ninterface IExtension {\\n    function activateForFund(bool _isMigration) external;\\n\\n    function deactivateForFund() external;\\n\\n    function receiveCallFromComptroller(\\n        address _comptrollerProxy,\\n        uint256 _actionId,\\n        bytes calldata _callArgs\\n    ) external;\\n\\n    function setConfigForFund(bytes calldata _configData) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/policy-manager/IPolicy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IPolicyManager.sol\\\";\\n\\n/// @title Policy Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IPolicy {\\n    function activateForFund(address _comptrollerProxy, address _vaultProxy) external;\\n\\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings) external;\\n\\n    function identifier() external pure returns (string memory identifier_);\\n\\n    function implementedHooks()\\n        external\\n        view\\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_);\\n\\n    function updateFundSettings(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes calldata _encodedSettings\\n    ) external;\\n\\n    function validateRule(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        IPolicyManager.PolicyHook _hook,\\n        bytes calldata _encodedArgs\\n    ) external returns (bool isValid_);\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/policy-manager/IPolicyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/// @title PolicyManager Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for the PolicyManager\\ninterface IPolicyManager {\\n    enum PolicyHook {\\n        BuySharesSetup,\\n        PreBuyShares,\\n        PostBuyShares,\\n        BuySharesCompleted,\\n        PreCallOnIntegration,\\n        PostCallOnIntegration\\n    }\\n\\n    function validatePolicies(\\n        address,\\n        PolicyHook,\\n        bytes calldata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/policy-manager/PolicyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"../../core/fund/vault/IVault.sol\\\";\\nimport \\\"../utils/ExtensionBase.sol\\\";\\nimport \\\"../utils/FundDeployerOwnerMixin.sol\\\";\\nimport \\\"./IPolicy.sol\\\";\\nimport \\\"./IPolicyManager.sol\\\";\\n\\n/// @title PolicyManager Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Manages policies for funds\\ncontract PolicyManager is IPolicyManager, ExtensionBase, FundDeployerOwnerMixin {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    event PolicyDeregistered(address indexed policy, string indexed identifier);\\n\\n    event PolicyDisabledForFund(address indexed comptrollerProxy, address indexed policy);\\n\\n    event PolicyEnabledForFund(\\n        address indexed comptrollerProxy,\\n        address indexed policy,\\n        bytes settingsData\\n    );\\n\\n    event PolicyRegistered(\\n        address indexed policy,\\n        string indexed identifier,\\n        PolicyHook[] implementedHooks\\n    );\\n\\n    EnumerableSet.AddressSet private registeredPolicies;\\n    mapping(address => mapping(PolicyHook => bool)) private policyToHookToIsImplemented;\\n    mapping(address => EnumerableSet.AddressSet) private comptrollerProxyToPolicies;\\n\\n    modifier onlyBuySharesHooks(address _policy) {\\n        require(\\n            !policyImplementsHook(_policy, PolicyHook.PreCallOnIntegration) &&\\n                !policyImplementsHook(_policy, PolicyHook.PostCallOnIntegration),\\n            \\\"onlyBuySharesHooks: Disallowed hook\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyEnabledPolicyForFund(address _comptrollerProxy, address _policy) {\\n        require(\\n            policyIsEnabledForFund(_comptrollerProxy, _policy),\\n            \\\"onlyEnabledPolicyForFund: Policy not enabled\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\\n\\n    // EXTERNAL FUNCTIONS\\n\\n    /// @notice Validates and initializes policies as necessary prior to fund activation\\n    /// @param _isMigratedFund True if the fund is migrating to this release\\n    /// @dev Caller is expected to be a valid ComptrollerProxy, but there isn't a need to validate.\\n    function activateForFund(bool _isMigratedFund) external override {\\n        address vaultProxy = __setValidatedVaultProxy(msg.sender);\\n\\n        // Policies must assert that they are congruent with migrated vault state\\n        if (_isMigratedFund) {\\n            address[] memory enabledPolicies = getEnabledPoliciesForFund(msg.sender);\\n            for (uint256 i; i < enabledPolicies.length; i++) {\\n                __activatePolicyForFund(msg.sender, vaultProxy, enabledPolicies[i]);\\n            }\\n        }\\n    }\\n\\n    /// @notice Deactivates policies for a fund by destroying storage\\n    function deactivateForFund() external override {\\n        delete comptrollerProxyToVaultProxy[msg.sender];\\n\\n        for (uint256 i = comptrollerProxyToPolicies[msg.sender].length(); i > 0; i--) {\\n            comptrollerProxyToPolicies[msg.sender].remove(\\n                comptrollerProxyToPolicies[msg.sender].at(i - 1)\\n            );\\n        }\\n    }\\n\\n    /// @notice Disables a policy for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _policy The policy address to disable\\n    function disablePolicyForFund(address _comptrollerProxy, address _policy)\\n        external\\n        onlyBuySharesHooks(_policy)\\n        onlyEnabledPolicyForFund(_comptrollerProxy, _policy)\\n    {\\n        __validateIsFundOwner(getVaultProxyForFund(_comptrollerProxy), msg.sender);\\n\\n        comptrollerProxyToPolicies[_comptrollerProxy].remove(_policy);\\n\\n        emit PolicyDisabledForFund(_comptrollerProxy, _policy);\\n    }\\n\\n    /// @notice Enables a policy for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _policy The policy address to enable\\n    /// @param _settingsData The encoded settings data with which to configure the policy\\n    /// @dev Disabling a policy does not delete fund config on the policy, so if a policy is\\n    /// disabled and then enabled again, its initial state will be the previous config. It is the\\n    /// policy's job to determine how to merge that config with the _settingsData param in this function.\\n    function enablePolicyForFund(\\n        address _comptrollerProxy,\\n        address _policy,\\n        bytes calldata _settingsData\\n    ) external onlyBuySharesHooks(_policy) {\\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\\n        __validateIsFundOwner(vaultProxy, msg.sender);\\n\\n        __enablePolicyForFund(_comptrollerProxy, _policy, _settingsData);\\n\\n        __activatePolicyForFund(_comptrollerProxy, vaultProxy, _policy);\\n    }\\n\\n    /// @notice Enable policies for use in a fund\\n    /// @param _configData Encoded config data\\n    /// @dev Only called during init() on ComptrollerProxy deployment\\n    function setConfigForFund(bytes calldata _configData) external override {\\n        (address[] memory policies, bytes[] memory settingsData) = abi.decode(\\n            _configData,\\n            (address[], bytes[])\\n        );\\n\\n        // Sanity check\\n        require(\\n            policies.length == settingsData.length,\\n            \\\"setConfigForFund: policies and settingsData array lengths unequal\\\"\\n        );\\n\\n        // Enable each policy with settings\\n        for (uint256 i; i < policies.length; i++) {\\n            __enablePolicyForFund(msg.sender, policies[i], settingsData[i]);\\n        }\\n    }\\n\\n    /// @notice Updates policy settings for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _policy The Policy contract to update\\n    /// @param _settingsData The encoded settings data with which to update the policy config\\n    function updatePolicySettingsForFund(\\n        address _comptrollerProxy,\\n        address _policy,\\n        bytes calldata _settingsData\\n    ) external onlyBuySharesHooks(_policy) onlyEnabledPolicyForFund(_comptrollerProxy, _policy) {\\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\\n        __validateIsFundOwner(vaultProxy, msg.sender);\\n\\n        IPolicy(_policy).updateFundSettings(_comptrollerProxy, vaultProxy, _settingsData);\\n    }\\n\\n    /// @notice Validates all policies that apply to a given hook for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _hook The PolicyHook for which to validate policies\\n    /// @param _validationData The encoded data with which to validate the filtered policies\\n    function validatePolicies(\\n        address _comptrollerProxy,\\n        PolicyHook _hook,\\n        bytes calldata _validationData\\n    ) external override {\\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\\n        address[] memory policies = getEnabledPoliciesForFund(_comptrollerProxy);\\n        for (uint256 i; i < policies.length; i++) {\\n            if (!policyImplementsHook(policies[i], _hook)) {\\n                continue;\\n            }\\n\\n            require(\\n                IPolicy(policies[i]).validateRule(\\n                    _comptrollerProxy,\\n                    vaultProxy,\\n                    _hook,\\n                    _validationData\\n                ),\\n                string(\\n                    abi.encodePacked(\\n                        \\\"Rule evaluated to false: \\\",\\n                        IPolicy(policies[i]).identifier()\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    // PRIVATE FUNCTIONS\\n\\n    /// @dev Helper to activate a policy for a fund\\n    function __activatePolicyForFund(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        address _policy\\n    ) private {\\n        IPolicy(_policy).activateForFund(_comptrollerProxy, _vaultProxy);\\n    }\\n\\n    /// @dev Helper to set config and enable policies for a fund\\n    function __enablePolicyForFund(\\n        address _comptrollerProxy,\\n        address _policy,\\n        bytes memory _settingsData\\n    ) private {\\n        require(\\n            !policyIsEnabledForFund(_comptrollerProxy, _policy),\\n            \\\"__enablePolicyForFund: policy already enabled\\\"\\n        );\\n        require(policyIsRegistered(_policy), \\\"__enablePolicyForFund: Policy is not registered\\\");\\n\\n        // Set fund config on policy\\n        if (_settingsData.length > 0) {\\n            IPolicy(_policy).addFundSettings(_comptrollerProxy, _settingsData);\\n        }\\n\\n        // Add policy\\n        comptrollerProxyToPolicies[_comptrollerProxy].add(_policy);\\n\\n        emit PolicyEnabledForFund(_comptrollerProxy, _policy, _settingsData);\\n    }\\n\\n    /// @dev Helper to validate fund owner.\\n    /// Preferred to a modifier because allows gas savings if re-using _vaultProxy.\\n    function __validateIsFundOwner(address _vaultProxy, address _who) private view {\\n        require(\\n            _who == IVault(_vaultProxy).getOwner(),\\n            \\\"Only the fund owner can call this function\\\"\\n        );\\n    }\\n\\n    ///////////////////////\\n    // POLICIES REGISTRY //\\n    ///////////////////////\\n\\n    /// @notice Remove policies from the list of registered policies\\n    /// @param _policies Addresses of policies to be registered\\n    function deregisterPolicies(address[] calldata _policies) external onlyFundDeployerOwner {\\n        require(_policies.length > 0, \\\"deregisterPolicies: _policies cannot be empty\\\");\\n\\n        for (uint256 i; i < _policies.length; i++) {\\n            require(\\n                policyIsRegistered(_policies[i]),\\n                \\\"deregisterPolicies: policy is not registered\\\"\\n            );\\n\\n            registeredPolicies.remove(_policies[i]);\\n\\n            emit PolicyDeregistered(_policies[i], IPolicy(_policies[i]).identifier());\\n        }\\n    }\\n\\n    /// @notice Add policies to the list of registered policies\\n    /// @param _policies Addresses of policies to be registered\\n    function registerPolicies(address[] calldata _policies) external onlyFundDeployerOwner {\\n        require(_policies.length > 0, \\\"registerPolicies: _policies cannot be empty\\\");\\n\\n        for (uint256 i; i < _policies.length; i++) {\\n            require(\\n                !policyIsRegistered(_policies[i]),\\n                \\\"registerPolicies: policy already registered\\\"\\n            );\\n\\n            registeredPolicies.add(_policies[i]);\\n\\n            // Store the hooks that a policy implements for later use.\\n            // Fronts the gas for calls to check if a hook is implemented, and guarantees\\n            // that the implementsHooks return value does not change post-registration.\\n            IPolicy policyContract = IPolicy(_policies[i]);\\n            PolicyHook[] memory implementedHooks = policyContract.implementedHooks();\\n            for (uint256 j; j < implementedHooks.length; j++) {\\n                policyToHookToIsImplemented[_policies[i]][implementedHooks[j]] = true;\\n            }\\n\\n            emit PolicyRegistered(_policies[i], policyContract.identifier(), implementedHooks);\\n        }\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Get all registered policies\\n    /// @return registeredPoliciesArray_ A list of all registered policy addresses\\n    function getRegisteredPolicies()\\n        external\\n        view\\n        returns (address[] memory registeredPoliciesArray_)\\n    {\\n        registeredPoliciesArray_ = new address[](registeredPolicies.length());\\n        for (uint256 i; i < registeredPoliciesArray_.length; i++) {\\n            registeredPoliciesArray_[i] = registeredPolicies.at(i);\\n        }\\n    }\\n\\n    /// @notice Get a list of enabled policies for a given fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @return enabledPolicies_ An array of enabled policy addresses\\n    function getEnabledPoliciesForFund(address _comptrollerProxy)\\n        public\\n        view\\n        returns (address[] memory enabledPolicies_)\\n    {\\n        enabledPolicies_ = new address[](comptrollerProxyToPolicies[_comptrollerProxy].length());\\n        for (uint256 i; i < enabledPolicies_.length; i++) {\\n            enabledPolicies_[i] = comptrollerProxyToPolicies[_comptrollerProxy].at(i);\\n        }\\n    }\\n\\n    /// @notice Checks if a policy implements a particular hook\\n    /// @param _policy The address of the policy to check\\n    /// @param _hook The PolicyHook to check\\n    /// @return implementsHook_ True if the policy implements the hook\\n    function policyImplementsHook(address _policy, PolicyHook _hook)\\n        public\\n        view\\n        returns (bool implementsHook_)\\n    {\\n        return policyToHookToIsImplemented[_policy][_hook];\\n    }\\n\\n    /// @notice Check if a policy is enabled for the fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund to check\\n    /// @param _policy The address of the policy to check\\n    /// @return isEnabled_ True if the policy is enabled for the fund\\n    function policyIsEnabledForFund(address _comptrollerProxy, address _policy)\\n        public\\n        view\\n        returns (bool isEnabled_)\\n    {\\n        return comptrollerProxyToPolicies[_comptrollerProxy].contains(_policy);\\n    }\\n\\n    /// @notice Check whether a policy is registered\\n    /// @param _policy The address of the policy to check\\n    /// @return isRegistered_ True if the policy is registered\\n    function policyIsRegistered(address _policy) public view returns (bool isRegistered_) {\\n        return registeredPolicies.contains(_policy);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/utils/ExtensionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../core/fund/comptroller/IComptroller.sol\\\";\\nimport \\\"../../core/fund/vault/IVault.sol\\\";\\nimport \\\"../IExtension.sol\\\";\\n\\n/// @title ExtensionBase Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Base class for an extension\\nabstract contract ExtensionBase is IExtension {\\n    mapping(address => address) internal comptrollerProxyToVaultProxy;\\n\\n    /// @notice Allows extension to run logic during fund activation\\n    /// @dev Unimplemented by default, may be overridden.\\n    function activateForFund(bool) external virtual override {\\n        return;\\n    }\\n\\n    /// @notice Allows extension to run logic during fund deactivation (destruct)\\n    /// @dev Unimplemented by default, may be overridden.\\n    function deactivateForFund() external virtual override {\\n        return;\\n    }\\n\\n    /// @notice Receives calls from ComptrollerLib.callOnExtension()\\n    /// and dispatches the appropriate action\\n    /// @dev Unimplemented by default, may be overridden.\\n    function receiveCallFromComptroller(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual override {\\n        revert(\\\"receiveCallFromComptroller: Unimplemented for Extension\\\");\\n    }\\n\\n    /// @notice Allows extension to run logic during fund configuration\\n    /// @dev Unimplemented by default, may be overridden.\\n    function setConfigForFund(bytes calldata) external virtual override {\\n        return;\\n    }\\n\\n    /// @dev Helper to validate a ComptrollerProxy-VaultProxy relation, which we store for both\\n    /// gas savings and to guarantee a spoofed ComptrollerProxy does not change getVaultProxy().\\n    /// Will revert without reason if the expected interfaces do not exist.\\n    function __setValidatedVaultProxy(address _comptrollerProxy)\\n        internal\\n        returns (address vaultProxy_)\\n    {\\n        require(\\n            comptrollerProxyToVaultProxy[_comptrollerProxy] == address(0),\\n            \\\"__setValidatedVaultProxy: Already set\\\"\\n        );\\n\\n        vaultProxy_ = IComptroller(_comptrollerProxy).getVaultProxy();\\n        require(vaultProxy_ != address(0), \\\"__setValidatedVaultProxy: Missing vaultProxy\\\");\\n\\n        require(\\n            _comptrollerProxy == IVault(vaultProxy_).getAccessor(),\\n            \\\"__setValidatedVaultProxy: Not the VaultProxy accessor\\\"\\n        );\\n\\n        comptrollerProxyToVaultProxy[_comptrollerProxy] = vaultProxy_;\\n\\n        return vaultProxy_;\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the verified VaultProxy for a given ComptrollerProxy\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @return vaultProxy_ The VaultProxy of the fund\\n    function getVaultProxyForFund(address _comptrollerProxy)\\n        public\\n        view\\n        returns (address vaultProxy_)\\n    {\\n        return comptrollerProxyToVaultProxy[_comptrollerProxy];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/utils/FundDeployerOwnerMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../core/fund-deployer/IFundDeployer.sol\\\";\\n\\n/// @title FundDeployerOwnerMixin Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A mixin contract that defers ownership to the owner of FundDeployer\\nabstract contract FundDeployerOwnerMixin {\\n    address internal immutable FUND_DEPLOYER;\\n\\n    modifier onlyFundDeployerOwner() {\\n        require(\\n            msg.sender == getOwner(),\\n            \\\"onlyFundDeployerOwner: Only the FundDeployer owner can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address _fundDeployer) public {\\n        FUND_DEPLOYER = _fundDeployer;\\n    }\\n\\n    /// @notice Gets the owner of this contract\\n    /// @return owner_ The owner\\n    /// @dev Ownership is deferred to the owner of the FundDeployer contract\\n    function getOwner() public view returns (address owner_) {\\n        return IFundDeployer(FUND_DEPLOYER).getOwner();\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `FUND_DEPLOYER` variable\\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\\n    function getFundDeployer() external view returns (address fundDeployer_) {\\n        return FUND_DEPLOYER;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundDeployer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"policy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"identifier\",\"type\":\"string\"}],\"name\":\"PolicyDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"policy\",\"type\":\"address\"}],\"name\":\"PolicyDisabledForFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"policy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"settingsData\",\"type\":\"bytes\"}],\"name\":\"PolicyEnabledForFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"policy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"identifier\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"enum IPolicyManager.PolicyHook[]\",\"name\":\"implementedHooks\",\"type\":\"uint8[]\"}],\"name\":\"PolicyRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isMigratedFund\",\"type\":\"bool\"}],\"name\":\"activateForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivateForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_policies\",\"type\":\"address[]\"}],\"name\":\"deregisterPolicies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"}],\"name\":\"disablePolicyForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_settingsData\",\"type\":\"bytes\"}],\"name\":\"enablePolicyForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"}],\"name\":\"getEnabledPoliciesForFund\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"enabledPolicies_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFundDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fundDeployer_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredPolicies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"registeredPoliciesArray_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"}],\"name\":\"getVaultProxyForFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vaultProxy_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyManager.PolicyHook\",\"name\":\"_hook\",\"type\":\"uint8\"}],\"name\":\"policyImplementsHook\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"implementsHook_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"}],\"name\":\"policyIsEnabledForFund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEnabled_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"}],\"name\":\"policyIsRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isRegistered_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"receiveCallFromComptroller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_policies\",\"type\":\"address[]\"}],\"name\":\"registerPolicies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_configData\",\"type\":\"bytes\"}],\"name\":\"setConfigForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_settingsData\",\"type\":\"bytes\"}],\"name\":\"updatePolicySettingsForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyManager.PolicyHook\",\"name\":\"_hook\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_validationData\",\"type\":\"bytes\"}],\"name\":\"validatePolicies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PolicyManager","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009134c9975244b46692ad9a7da36dba8734ec6da3","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}