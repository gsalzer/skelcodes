{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/root/new/xusd/contracts/Common/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\nimport \\\"../Common/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../Math/SafeMath.sol\\\";\\nimport \\\"../Utils/Address.sol\\\";\\n\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\n \\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n    \\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for `accounts`'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal virtual {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of `from`'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/ERC20/ERC20Custom.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\nimport \\\"../Common/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../Math/SafeMath.sol\\\";\\nimport \\\"../Utils/Address.sol\\\";\\n\\n// Due to compiling issues, _name, _symbol, and _decimals were removed\\n\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Custom is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) internal _balances;\\n\\n    mapping (address => mapping (address => uint256)) internal _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for `accounts`'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal virtual {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of `from`'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\nimport \\\"../Common/Context.sol\\\";\\nimport \\\"../Math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Math/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\n// computes square roots using the babylonian method\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\nlibrary Babylonian {\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n        // else z = 0\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Math/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\nimport './Babylonian.sol';\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint private constant Q112 = uint(1) << RESOLUTION;\\n    uint private constant Q224 = Q112 << RESOLUTION;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // take the reciprocal of a UQ112x112\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\\n        return uq112x112(uint224(Q224 / self._x));\\n    }\\n\\n    // square root of a UQ112x112\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Oracle/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Oracle/ChainlinkETHUSDPriceConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ncontract ChainlinkETHUSDPriceConsumer {\\n\\n    AggregatorV3Interface internal priceFeed;\\n\\n\\n    constructor() public {\\n        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\\n    }\\n\\n    /**\\n     * Returns the latest price\\n     */\\n    function getLatestPrice() public view returns (int) {\\n        (\\n            , \\n            int price,\\n            ,\\n            ,\\n            \\n        ) = priceFeed.latestRoundData();\\n        return price;\\n    }\\n\\n    function getDecimals() public view returns (uint8) {\\n        return priceFeed.decimals();\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Oracle/UniswapPairOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\nimport '../Uniswap/Interfaces/IUniswapV2Factory.sol';\\nimport '../Uniswap/Interfaces/IUniswapV2Pair.sol';\\nimport '../Math/FixedPoint.sol';\\n\\nimport '../Uniswap/UniswapV2OracleLibrary.sol';\\nimport '../Uniswap/UniswapV2Library.sol';\\n\\n// Fixed window oracle that recomputes the average price for the entire period once every period\\n// Note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\\ncontract UniswapPairOracle {\\n    using FixedPoint for *;\\n    \\n    address owner_address;\\n    address timelock_address;\\n\\n    uint public PERIOD = 3600; // 1 hour TWAP (time-weighted average price)\\n\\n    IUniswapV2Pair public immutable pair;\\n    address public immutable token0;\\n    address public immutable token1;\\n\\n    uint    public price0CumulativeLast;\\n    uint    public price1CumulativeLast;\\n    uint32  public blockTimestampLast;\\n    FixedPoint.uq112x112 public price0Average;\\n    FixedPoint.uq112x112 public price1Average;\\n\\n    modifier onlyByOwnerOrGovernance() {\\n        require(msg.sender == owner_address || msg.sender == timelock_address, \\\"You are not an owner or the governance timelock\\\");\\n        _;\\n    }\\n\\n    constructor(address factory, address tokenA, address tokenB, address _owner_address, address _timelock_address) public {\\n        IUniswapV2Pair _pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\\n        pair = _pair;\\n        token0 = _pair.token0();\\n        token1 = _pair.token1();\\n        price0CumulativeLast = _pair.price0CumulativeLast(); // Fetch the current accumulated price value (1 / 0)\\n        price1CumulativeLast = _pair.price1CumulativeLast(); // Fetch the current accumulated price value (0 / 1)\\n        uint112 reserve0;\\n        uint112 reserve1;\\n        (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\\n        require(reserve0 != 0 && reserve1 != 0, 'UniswapPairOracle: NO_RESERVES'); // Ensure that there's liquidity in the pair\\n\\n        owner_address = _owner_address;\\n        timelock_address = _timelock_address;\\n    }\\n\\n    function setOwner(address _owner_address) external onlyByOwnerOrGovernance {\\n        owner_address = _owner_address;\\n    }\\n\\n    function setTimelock(address _timelock_address) external onlyByOwnerOrGovernance {\\n        timelock_address = _timelock_address;\\n    }\\n\\n    function setPeriod(uint _period) external onlyByOwnerOrGovernance {\\n        PERIOD = _period;\\n    }\\n\\n    function update() external {\\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\\n\\n        // Ensure that at least one full period has passed since the last update\\n        require(timeElapsed >= PERIOD, 'UniswapPairOracle: PERIOD_NOT_ELAPSED');\\n\\n        // Overflow is desired, casting never truncates\\n        // Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\n        price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\\n        price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\\n\\n        price0CumulativeLast = price0Cumulative;\\n        price1CumulativeLast = price1Cumulative;\\n        blockTimestampLast = blockTimestamp;\\n    }\\n\\n    // Note this will always return 0 before update has been called successfully for the first time.\\n    function consult(address token, uint amountIn) external view returns (uint amountOut) {\\n        if (token == token0) {\\n            amountOut = price0Average.mul(amountIn).decode144();\\n        } else {\\n            require(token == token1, 'UniswapPairOracle: INVALID_TOKEN');\\n            amountOut = price1Average.mul(amountIn).decode144();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Uniswap/Interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Uniswap/Interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    \\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Uniswap/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\nimport './Interfaces/IUniswapV2Pair.sol';\\nimport './Interfaces/IUniswapV2Factory.sol';\\n\\nimport \\\"../Math/SafeMath.sol\\\";\\n\\nlibrary UniswapV2Library {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // Less efficient than the CREATE2 method below\\n    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = IUniswapV2Factory(factory).getPair(token0, token1);\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairForCreate2(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n            )))); // this matches the CREATE2 in UniswapV2Factory.createPair\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint amountInWithFee = amountIn.mul(997);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint i; i < path.length - 1; i++) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint i = path.length - 1; i > 0; i--) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Uniswap/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\nimport '../Uniswap/Interfaces/IUniswapV2Pair.sol';\\nimport '../Math/FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/Utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/XUS/XUS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../Common/Context.sol\\\";\\nimport \\\"../ERC20/ERC20Custom.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../XUSD/XUSD.sol\\\";\\nimport \\\"../Math/SafeMath.sol\\\";\\n\\ncontract XUSDShares is ERC20Custom {\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    string public symbol;\\n    string public name;\\n    uint8 public constant decimals = 18;\\n    \\n    uint256 public constant genesis_supply = 500e18; // 500 is printed to bootstrap uniswap pool\\n\\n    address public owner_address;\\n    address public oracle_address;\\n    address public timelock_address; // Governance timelock address\\n    XUSDStablecoin private XUSD;\\n\\n\\n    // LP staking reward pools\\n    mapping (address => bool) public rewardPools;\\n    // LP staking pool max reward\\n    mapping (address => uint256) public rewardCapOf;\\n    mapping (address => uint256) public rewardedAmountOf;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyPools() {\\n       require(XUSD.xusd_pools(msg.sender) == true, \\\"Only xusd pools can mint new XUS\\\");\\n        _;\\n    }\\n\\n    modifier onlyRewardPools() {\\n        require(rewardPools[msg.sender] == true, \\\"Only staking reward pools can mint new XUS\\\");\\n        _;\\n    }\\n    \\n    modifier onlyByOwnerOrGovernance() {\\n        require(msg.sender == owner_address || msg.sender == timelock_address, \\\"You are not an owner or the governance timelock\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol, \\n        address _oracle_address,\\n        address _timelock_address\\n    ) public {\\n        name = _name;\\n        symbol = _symbol;\\n        owner_address = msg.sender;\\n        oracle_address = _oracle_address;\\n        timelock_address = _timelock_address;\\n        _mint(owner_address, genesis_supply);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setOracle(address new_oracle) external onlyByOwnerOrGovernance {\\n        oracle_address = new_oracle;\\n    }\\n\\n    function setTimelock(address new_timelock) external onlyByOwnerOrGovernance {\\n        timelock_address = new_timelock;\\n    }\\n    \\n    function setXUSDAddress(address xusd_contract_address) external onlyByOwnerOrGovernance {\\n        XUSD = XUSDStablecoin(xusd_contract_address);\\n    }\\n\\n    function setOwner(address _owner_address) external onlyByOwnerOrGovernance {\\n        owner_address = _owner_address;\\n    }\\n\\n    function addRewardPool(address pool_address, uint256 reward_cap) external onlyByOwnerOrGovernance {\\n        require(rewardPools[pool_address] == false, \\\"address already exists\\\");\\n        rewardPools[pool_address] = true;\\n        rewardCapOf[pool_address] = reward_cap;\\n        rewardedAmountOf[pool_address] = 0;\\n    }\\n\\n    function setRewardCap(address pool_address, uint256 reward_cap) external onlyByOwnerOrGovernance {\\n        require(rewardPools[pool_address] == true, \\\"address not exist\\\");\\n        rewardCapOf[pool_address] = reward_cap;\\n    }\\n\\n    function removeRewardPool(address pool_address) external onlyByOwnerOrGovernance {\\n        require(rewardPools[pool_address] == true, \\\"address not exist\\\");\\n        rewardPools[pool_address] = false;\\n        rewardCapOf[pool_address] = 0;\\n    }\\n\\n    function mint_reward(address to, uint256 amount) public onlyRewardPools {\\n        require(rewardedAmountOf[msg.sender].add(amount) < rewardCapOf[msg.sender]);\\n        rewardedAmountOf[msg.sender] = rewardedAmountOf[msg.sender].add(amount);\\n        _mint(to, amount);\\n    }\\n\\n    function mint(address to, uint256 amount) public onlyPools {\\n        _mint(to, amount);\\n    }\\n    \\n    // This function is what other xusd pools will call to mint new XUS (similar to the XUSD mint) \\n    function pool_mint(address m_address, uint256 m_amount) external onlyPools {        \\n        super._mint(m_address, m_amount);\\n        emit XUSMinted(address(this), m_address, m_amount);\\n    }\\n\\n    // This function is what other xusd pools will call to burn XUS \\n    function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {\\n        super._burnFrom(b_address, b_amount);\\n        emit XUSBurned(b_address, address(this), b_amount);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n\\n        return true;\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint256 chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n\\n    // Track XUS burned\\n    event XUSBurned(address indexed from, address indexed to, uint256 amount);\\n\\n    // Track XUS minted\\n    event XUSMinted(address indexed from, address indexed to, uint256 amount);\\n\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/XUSD/Pools/IXUSDPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\ninterface IXUSDPool {\\n    function collatDollarBalance() external view returns (uint256);\\n    function availableExcessCollatDV() external view returns (uint256);\\n    function getCollateralPrice() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/XUSD/Pools/Pool_USDC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\nimport \\\"./XUSDPool.sol\\\";\\n\\ncontract Pool_USDC is XUSDPool {\\n    address public USDC_address;\\n    constructor(\\n        address _xusd_contract_address,\\n        address _xus_contract_address,\\n        address _collateral_address,\\n        address _timelock_address,\\n        uint256 _pool_ceiling\\n    ) \\n    XUSDPool(_xusd_contract_address, _xus_contract_address, _collateral_address, _timelock_address, _pool_ceiling)\\n    public {\\n        USDC_address = _collateral_address;\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/XUSD/Pools/XUSDPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../Math/SafeMath.sol\\\";\\nimport \\\"../../XUS/XUS.sol\\\";\\nimport \\\"../../XUSD/XUSD.sol\\\";\\nimport \\\"../../ERC20/ERC20.sol\\\";\\nimport \\\"../../Oracle/UniswapPairOracle.sol\\\";\\nimport \\\"./XUSDPoolLibrary.sol\\\";\\n\\ncontract XUSDPool {\\n    using SafeMath for uint256;\\n\\n    ERC20 private collateral_token;\\n    address private collateral_address;\\n    address private owner_address;\\n    address private xusd_contract_address;\\n    address private xus_contract_address;\\n    address private timelock_address; // Timelock address for the governance contract\\n    XUSDShares private XUS;\\n    XUSDStablecoin private XUSD;\\n    UniswapPairOracle private collatEthOracle;\\n    address private collat_eth_oracle_address;\\n    address private weth_address;\\n\\n    mapping (address => uint256) public redeemXUSBalances;\\n    mapping (address => uint256) public redeemCollateralBalances;\\n    uint256 public unclaimedPoolCollateral;\\n    uint256 public unclaimedPoolXUS;\\n    mapping (address => uint256) public lastRedeemed;\\n\\n    // Constants for various precisions\\n    uint256 private constant PRICE_PRECISION = 1e6;\\n    uint256 private constant COLLATERAL_RATIO_PRECISION = 1e6;\\n    uint256 private constant COLLATERAL_RATIO_MAX = 1e6;\\n\\n    // Number of decimals needed to get to 18\\n    uint256 private missing_decimals;\\n    \\n    // Pool_ceiling is the total units of collateral that a pool contract can hold\\n    uint256 public pool_ceiling = 0;\\n\\n    // Stores price of the collateral, if price is paused\\n    uint256 public pausedPrice = 0;\\n\\n    // Bonus rate on XUS minted during recollateralizeXUSD(); 6 decimals of precision, set to 0.75% on genesis\\n    uint256 public bonus_rate = 7500;\\n\\n    // Number of blocks to wait before being able to collectRedemption()\\n    uint256 public redemption_delay = 1;\\n    \\n    // AccessControl state variables\\n    bool private mintPaused = false;\\n    bool private redeemPaused = false;\\n    bool private recollateralizePaused = false;\\n    bool private buyBackPaused = false;\\n    bool private collateralPricePaused = false;\\n\\n    address feepool_address;\\n\\n    ChainlinkETHUSDPriceConsumer private collat_usd_pricer;\\n    uint8 private collat_usd_pricer_decimals;\\n    address public collat_usd_consumer_address;\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyByOwnerOrGovernance() {\\n        require(msg.sender == timelock_address || msg.sender == owner_address, \\\"unauthorized\\\");\\n        _;\\n    }\\n\\n    modifier notRedeemPaused() {\\n        require(redeemPaused == false, \\\"redeem paused\\\");\\n        _;\\n    }\\n\\n    modifier notMintPaused() {\\n        require(mintPaused == false, \\\"mint paused\\\");\\n        _;\\n    }\\n\\n    modifier checkContract() {\\n        require(msg.sender == tx.origin, \\\"contract not support\\\");\\n        _;\\n    }\\n \\n    /* ========== CONSTRUCTOR ========== */\\n    \\n    constructor(\\n        address _xusd_contract_address,\\n        address _xus_contract_address,\\n        address _collateral_address,\\n        address _timelock_address,\\n        uint256 _pool_ceiling\\n    ) public {\\n        XUSD = XUSDStablecoin(_xusd_contract_address);\\n        XUS = XUSDShares(_xus_contract_address);\\n        xusd_contract_address = _xusd_contract_address;\\n        xus_contract_address = _xus_contract_address;\\n        collateral_address = _collateral_address;\\n        timelock_address = _timelock_address;\\n        owner_address = msg.sender;\\n        collateral_token = ERC20(_collateral_address);\\n        pool_ceiling = _pool_ceiling;\\n        missing_decimals = uint(18).sub(collateral_token.decimals());\\n    }\\n\\n    function setCollatUSDOracle(address _collat_usd_consumer_address) public onlyByOwnerOrGovernance {\\n        collat_usd_consumer_address = _collat_usd_consumer_address;\\n        collat_usd_pricer = ChainlinkETHUSDPriceConsumer(collat_usd_consumer_address);\\n        collat_usd_pricer_decimals = collat_usd_pricer.getDecimals();\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    // Returns dollar value of collateral held in this XUSD pool\\n    function collatDollarBalance() public view returns (uint256) {\\n        // uint256 eth_usd_price = XUSD.eth_usd_price();\\n        // uint256 eth_collat_price = collatEthOracle.consult(weth_address, (PRICE_PRECISION * (10 ** missing_decimals)));\\n\\n        // uint256 collat_usd_price = eth_usd_price.mul(PRICE_PRECISION).div(eth_collat_price);\\n        uint256 collat_usd_price = uint256(collat_usd_pricer.getLatestPrice()).mul(1e6).div(uint256(10) ** collat_usd_pricer_decimals);\\n        return (collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral)).mul(10 ** missing_decimals).mul(collat_usd_price).div(PRICE_PRECISION); //.mul(getCollateralPrice()).div(1e6);    \\n    }\\n\\n    // Returns the value of excess collateral held in this XUSD pool, compared to what is needed to maintain the global collateral ratio\\n    function availableExcessCollatDV() public view returns (uint256) {\\n        ( , , uint256 total_supply, uint256 global_collateral_ratio, uint256 global_collat_value, , ,) = XUSD.xusd_info();\\n        if (global_collateral_ratio > COLLATERAL_RATIO_PRECISION) global_collateral_ratio = COLLATERAL_RATIO_PRECISION; // Handles an overcollateralized contract with CR > 1\\n        uint256 required_collat_dollar_value_d18 = (total_supply.mul(global_collateral_ratio)).div(COLLATERAL_RATIO_PRECISION); // Calculates collateral needed to back each 1 XUSD with $1 of collateral at current collat ratio\\n        if (global_collat_value > required_collat_dollar_value_d18) return global_collat_value.sub(required_collat_dollar_value_d18);\\n        else return 0;\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n    \\n    // Returns the price of the pool collateral in USD\\n    function getCollateralPrice() public view returns (uint256) {\\n        if(collateralPricePaused == true) {\\n            return pausedPrice;\\n        } else {\\n            // ( , , , , , , , uint256 eth_usd_price) = XUSD.xusd_info();\\n            // return eth_usd_price.mul(PRICE_PRECISION).div(collatEthOracle.consult(weth_address, PRICE_PRECISION * (10 ** missing_decimals)));\\n            return uint256(collat_usd_pricer.getLatestPrice()).mul(1e6).div(uint256(10) ** collat_usd_pricer_decimals); //collat_usd_price\\n        }\\n    }\\n\\n    function setFeePool(address _feepool) external onlyByOwnerOrGovernance {\\n        feepool_address = _feepool;\\n    }\\n\\n    function getMint1t1Out(uint256 collat_amount) public view returns (uint256, uint256) {\\n        uint256 collateral_amount_d18 = collat_amount * (10 ** missing_decimals);\\n        ( , , , uint256 global_collateral_ratio, , uint256 minting_fee, ,) = XUSD.xusd_info();\\n        require(global_collateral_ratio >= COLLATERAL_RATIO_MAX, \\\"CR must >= 1\\\");\\n        require((collateral_token.balanceOf(address(this))).sub(unclaimedPoolCollateral).add(collat_amount) <= pool_ceiling, \\\"ceiling reached\\\");\\n        (uint256 xusd_amount_d18, uint256 fee) = XUSDPoolLibrary.calcMint1t1XUSD(\\n            getCollateralPrice(),\\n            minting_fee,\\n            collateral_amount_d18\\n        );\\n        return (xusd_amount_d18, fee);\\n    }\\n\\n    // We separate out the 1t1, fractional and algorithmic minting functions for gas efficiency \\n    function mint1t1XUSD(uint256 collateral_amount, uint256 XUSD_out_min) external notMintPaused {\\n        (uint256 xusd_amount_d18, uint256 fee) = getMint1t1Out(collateral_amount);\\n\\n        require(XUSD_out_min <= xusd_amount_d18, \\\"slippage\\\");\\n        collateral_token.transferFrom(msg.sender, address(this), collateral_amount);\\n        XUSD.pool_mint(msg.sender, xusd_amount_d18);\\n        XUSD.pool_mint(feepool_address, fee);\\n    }\\n\\n    function getMintAlgoOut(uint256 xus_amount) public view returns (uint256, uint256) {\\n        ( , uint256 xus_price, , uint256 global_collateral_ratio, , uint256 minting_fee, ,) = XUSD.xusd_info();\\n        require(global_collateral_ratio == 0, \\\"CR != 0\\\");\\n\\n        (uint256 xusd_amount_d18, uint256 fee) = XUSDPoolLibrary.calcMintAlgorithmicXUSD(\\n            minting_fee, \\n            xus_price, // X XUS / 1 USD\\n            xus_amount\\n        );\\n        return (xusd_amount_d18, fee);\\n    }\\n\\n    // 0% collateral-backed\\n    function mintAlgorithmicXUSD(uint256 xus_amount_d18, uint256 XUSD_out_min) external notMintPaused {\\n        (uint256 xusd_amount_d18, uint256 fee) = getMintAlgoOut(xus_amount_d18);\\n\\n        require(XUSD_out_min <= xusd_amount_d18, \\\"slippage\\\");\\n        XUS.pool_burn_from(msg.sender, xus_amount_d18);\\n        XUSD.pool_mint(msg.sender, xusd_amount_d18);\\n        XUSD.pool_mint(feepool_address, fee);\\n    }\\n\\n    function getMintFracOut(uint256 collat_amount) public view returns (uint256, uint256, uint256) {\\n        (, uint256 xus_price, , uint256 global_collateral_ratio, , uint256 minting_fee, ,) = XUSD.xusd_info();\\n        require(global_collateral_ratio < COLLATERAL_RATIO_MAX && global_collateral_ratio > 0, \\\"CR not in range\\\");\\n        require(collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral).add(collat_amount) <= pool_ceiling, \\\"pool ceiling reached\\\");\\n        \\n        uint256 collateral_amount_d18 = collat_amount * (10 ** missing_decimals);\\n        (uint256 mint_amount, uint256 xus_needed, uint256 fee) = XUSDPoolLibrary.calcMintFractionalXUSD(collateral_amount_d18, getCollateralPrice(), xus_price, global_collateral_ratio, minting_fee);\\n        return (mint_amount, xus_needed, fee);\\n    }\\n\\n    // Will fail if fully collateralized or fully algorithmic\\n    // > 0% and < 100% collateral-backed\\n    function mintFractionalXUSD(uint256 collateral_amount, uint256 XUSD_out_min) external notMintPaused {\\n        (uint256 mint_amount, uint256 xus_needed, uint256 fee) = getMintFracOut(collateral_amount);\\n\\n        require(XUSD_out_min <= mint_amount, \\\"slippage\\\");\\n        XUS.pool_burn_from(msg.sender, xus_needed);\\n        collateral_token.transferFrom(msg.sender, address(this), collateral_amount);\\n        XUSD.pool_mint(msg.sender, mint_amount);\\n        XUSD.pool_mint(feepool_address, fee);\\n    }\\n\\n    function getRedeem1t1Out(uint256 xusd_amount) public view returns (uint256, uint256) {\\n        (, , , uint256 global_collateral_ratio, , , uint256 redemption_fee,) = XUSD.xusd_info();\\n        require(global_collateral_ratio == COLLATERAL_RATIO_MAX, \\\"CR != 1\\\");\\n\\n        // Need to adjust for decimals of collateral\\n        uint256 XUSD_amount_precision = xusd_amount.div(10 ** missing_decimals);\\n        (uint256 collateral_needed, uint256 fee) = XUSDPoolLibrary.calcRedeem1t1XUSD(\\n            getCollateralPrice(),\\n            XUSD_amount_precision,\\n            redemption_fee\\n        );\\n        return (collateral_needed, fee);\\n    }\\n\\n    // Redeem collateral. 100% collateral-backed\\n    function redeem1t1XUSD(uint256 XUSD_amount, uint256 COLLATERAL_out_min) external notRedeemPaused {\\n       \\n        (uint256 collateral_needed, uint256 fee) = getRedeem1t1Out(XUSD_amount);\\n        require(collateral_needed <= collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral), \\\"Not enough collateral in pool\\\");\\n\\n        redeemCollateralBalances[msg.sender] = redeemCollateralBalances[msg.sender].add(collateral_needed);\\n        unclaimedPoolCollateral = unclaimedPoolCollateral.add(collateral_needed);\\n        lastRedeemed[msg.sender] = block.number;\\n\\n        require(COLLATERAL_out_min <= collateral_needed, \\\"slippage\\\");\\n        \\n        // Move all external functions to the end\\n        XUSD.pool_burn_from(msg.sender, XUSD_amount);\\n        XUSD.pool_mint(feepool_address, fee);\\n    }\\n\\n    function getRedeemFracOut(uint256 XUSD_amount) public view returns (uint256, uint256, uint256) {\\n        (, uint256 xus_price, , uint256 global_collateral_ratio, , , uint256 redemption_fee,) = XUSD.xusd_info();\\n        require(global_collateral_ratio < COLLATERAL_RATIO_MAX && global_collateral_ratio > 0, \\\"CR not in range\\\");\\n        uint256 col_price_usd = getCollateralPrice();\\n\\n        uint256 fee = (XUSD_amount.mul(redemption_fee)).div(PRICE_PRECISION);\\n        uint256 XUSD_amount_post_fee = XUSD_amount.sub(fee);\\n        uint256 xus_dollar_value_d18 = XUSD_amount_post_fee.sub(XUSD_amount_post_fee.mul(global_collateral_ratio).div(PRICE_PRECISION));\\n        uint256 xus_amount = xus_dollar_value_d18.mul(PRICE_PRECISION).div(xus_price);\\n\\n        // Need to adjust for decimals of collateral\\n        uint256 XUSD_amount_precision = XUSD_amount_post_fee.div(10 ** missing_decimals);\\n        uint256 collateral_dollar_value = XUSD_amount_precision.mul(global_collateral_ratio).div(PRICE_PRECISION);\\n        uint256 collateral_amount = collateral_dollar_value.mul(PRICE_PRECISION).div(col_price_usd);\\n\\n        return (xus_amount, collateral_amount, fee);\\n    }\\n\\n    // Will fail if fully collateralized or algorithmic\\n    // Redeem XUSD for collateral and XUS. > 0% and < 100% collateral-backed\\n    function redeemFractionalXUSD(uint256 XUSD_amount, uint256 XUS_out_min, uint256 COLLATERAL_out_min) external notRedeemPaused {\\n        (uint256 xus_amount, uint256 collateral_amount, uint256 fee) = getRedeemFracOut(XUSD_amount);\\n\\n        redeemCollateralBalances[msg.sender] = redeemCollateralBalances[msg.sender].add(collateral_amount);\\n        unclaimedPoolCollateral = unclaimedPoolCollateral.add(collateral_amount);\\n\\n        redeemXUSBalances[msg.sender] = redeemXUSBalances[msg.sender].add(xus_amount);\\n        unclaimedPoolXUS = unclaimedPoolXUS.add(xus_amount);\\n\\n        lastRedeemed[msg.sender] = block.number;\\n\\n        require(collateral_amount <= collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral), \\\"not enough collateral\\\");\\n        require(COLLATERAL_out_min <= collateral_amount && XUS_out_min <= xus_amount, \\\"slippage\\\");\\n        \\n        // Move all external functions to the end\\n        XUSD.pool_burn_from(msg.sender, XUSD_amount);\\n        XUS.pool_mint(address(this), xus_amount);\\n        XUSD.pool_mint(feepool_address, fee);\\n    }\\n\\n    function getRedeemAlgoOut(uint256 XUSD_amount) public view returns (uint256, uint256) {\\n        (, uint256 xus_price, , uint256 global_collateral_ratio, , , uint256 redemption_fee,) = XUSD.xusd_info();\\n        require(global_collateral_ratio == 0, \\\"CR != 0\\\"); \\n        uint256 fee = XUSD_amount.mul(redemption_fee).div(1e6);\\n        uint256 xus_dollar_value_d18 = XUSD_amount.sub(fee);\\n\\n        uint256 xus_amount = xus_dollar_value_d18.mul(PRICE_PRECISION).div(xus_price);\\n        return (xus_amount, fee);\\n    }\\n\\n    // Redeem XUSD for XUS. 0% collateral-backed\\n    function redeemAlgorithmicXUSD(uint256 XUSD_amount, uint256 XUS_out_min) external notRedeemPaused {\\n\\n        (uint256 xus_amount, uint256 fee) = getRedeemAlgoOut(XUSD_amount);\\n        \\n        redeemXUSBalances[msg.sender] = redeemXUSBalances[msg.sender].add(xus_amount);\\n        unclaimedPoolXUS = unclaimedPoolXUS.add(xus_amount);\\n        \\n        lastRedeemed[msg.sender] = block.number;\\n        \\n        require(XUS_out_min <= xus_amount, \\\"slippage\\\");\\n        // Move all external functions to the end\\n        XUSD.pool_burn_from(msg.sender, XUSD_amount);\\n        XUS.pool_mint(address(this), xus_amount);\\n        XUSD.pool_mint(feepool_address, fee);\\n    }\\n\\n    // After a redemption happens, transfer the newly minted XUS and owed collateral from this pool\\n    // contract to the user. Redemption is split into two functions to prevent flash loans from being able\\n    // to take out XUSD/collateral from the system, use an AMM to trade the new price, and then mint back into the system.\\n    function collectRedemption() external {\\n        require((lastRedeemed[msg.sender].add(redemption_delay)) <= block.number, \\\"wait 1 block\\\");\\n        bool sendXUS = false;\\n        bool sendCollateral = false;\\n        uint XUSAmount;\\n        uint CollateralAmount;\\n\\n        // Use Checks-Effects-Interactions pattern\\n        if(redeemXUSBalances[msg.sender] > 0){\\n            XUSAmount = redeemXUSBalances[msg.sender];\\n            redeemXUSBalances[msg.sender] = 0;\\n            unclaimedPoolXUS = unclaimedPoolXUS.sub(XUSAmount);\\n\\n            sendXUS = true;\\n        }\\n        \\n        if(redeemCollateralBalances[msg.sender] > 0){\\n            CollateralAmount = redeemCollateralBalances[msg.sender];\\n            redeemCollateralBalances[msg.sender] = 0;\\n            unclaimedPoolCollateral = unclaimedPoolCollateral.sub(CollateralAmount);\\n\\n            sendCollateral = true;\\n        }\\n\\n        if(sendXUS == true){\\n            XUS.transfer(msg.sender, XUSAmount);\\n        }\\n        if(sendCollateral == true){\\n            collateral_token.transfer(msg.sender, CollateralAmount);\\n        }\\n    }\\n\\n    function getRecollatOut(uint256 collateral_amount) public view returns (uint256, uint256) {\\n        require(recollateralizePaused == false, \\\"recollat paused\\\");\\n        uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);\\n        ( , uint256 xus_price, uint256 xusd_total_supply , uint256 global_collateral_ratio, uint256 global_collat_value, , , ) = XUSD.xusd_info();\\n        (uint256 collateral_units, uint256 amount_to_recollat) = XUSDPoolLibrary.calcRecollateralizeXUSDInner(\\n            collateral_amount_d18,\\n            getCollateralPrice(),\\n            global_collat_value,\\n            xusd_total_supply,\\n            global_collateral_ratio\\n        ); \\n\\n        uint256 xus_paid_back = amount_to_recollat.mul(uint(1e6).add(bonus_rate)).div(xus_price);\\n        uint256 collateral_units_precision = collateral_units.div(10 ** missing_decimals);\\n        return (collateral_units_precision, xus_paid_back);\\n    }\\n\\n    // When the protocol is recollateralizing, we need to give a discount of XUS to hit the new CR target\\n    // Thus, if the target collateral ratio is higher than the actual value of collateral, minters get XUS for adding collateral\\n    // This function simply rewards anyone that sends collateral to a pool with the same amount of XUS + the bonus rate\\n    // Anyone can call this function to recollateralize the protocol and take the extra XUS value from the bonus rate as an arb opportunity\\n    function recollateralizeXUSD(uint256 collateral_amount, uint256 XUS_out_min) external { \\n\\n        (uint256 collateral_units_precision, uint256 xus_paid_back) = getRecollatOut(collateral_amount);\\n\\n        require(XUS_out_min <= xus_paid_back, \\\"slippage\\\");\\n        collateral_token.transferFrom(msg.sender, address(this), collateral_units_precision);\\n        XUS.pool_mint(msg.sender, xus_paid_back);\\n    }\\n\\n    function getBuybackOut(uint256 XUS_amount) public view returns (uint256) {\\n        require(buyBackPaused == false, \\\"buyback paused\\\");\\n        (, uint256 xus_price, , , , , ,) = XUSD.xusd_info();\\n\\n        (uint256 collateral_equivalent_d18) = XUSDPoolLibrary.calcBuyBackXUS(XUS_amount, xus_price, availableExcessCollatDV(), getCollateralPrice());\\n        return collateral_equivalent_d18.div(10 ** missing_decimals);\\n    }\\n\\n    // Function can be called by an XUS holder to have the protocol buy back XUS with excess collateral value from a desired collateral pool\\n    // This can also happen if the collateral ratio > 1\\n    function buyBackXUS(uint256 XUS_amount, uint256 COLLATERAL_out_min) external {\\n        uint256 collateral_precision = getBuybackOut(XUS_amount);\\n\\n        require(COLLATERAL_out_min <= collateral_precision, \\\"slippage\\\");\\n        // Give the sender their desired collateral and burn the XUS\\n        XUS.pool_burn_from(msg.sender, XUS_amount);\\n        collateral_token.transfer(msg.sender, collateral_precision);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function toggleMinting() external onlyByOwnerOrGovernance {\\n        mintPaused = !mintPaused;\\n    }\\n    \\n    function toggleRedeeming() external onlyByOwnerOrGovernance {\\n        redeemPaused = !redeemPaused;\\n    }\\n\\n    function toggleRecollateralize() external onlyByOwnerOrGovernance {\\n        recollateralizePaused = !recollateralizePaused;\\n    }\\n    \\n    function toggleBuyBack() external onlyByOwnerOrGovernance {\\n        buyBackPaused = !buyBackPaused;\\n    }\\n\\n    function toggleCollateralPrice() external onlyByOwnerOrGovernance {\\n        // If pausing, set paused price; else if unpausing, clear pausedPrice\\n        if(collateralPricePaused == false){\\n            pausedPrice = getCollateralPrice();\\n        } else {\\n            pausedPrice = 0;\\n        }\\n        collateralPricePaused = !collateralPricePaused;\\n    }\\n\\n    // Combined into one function due to 24KiB contract memory limit\\n    function setPoolParameters(uint256 new_ceiling, uint256 new_bonus_rate, uint256 new_redemption_delay) external onlyByOwnerOrGovernance {\\n        pool_ceiling = new_ceiling;\\n        bonus_rate = new_bonus_rate;\\n        redemption_delay = new_redemption_delay;\\n    }\\n\\n    function setTimelock(address new_timelock) external onlyByOwnerOrGovernance {\\n        timelock_address = new_timelock;\\n    }\\n\\n    function setOwner(address _owner_address) external onlyByOwnerOrGovernance {\\n        owner_address = _owner_address;\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/XUSD/Pools/XUSDPoolLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../Math/SafeMath.sol\\\";\\n\\n\\n\\nlibrary XUSDPoolLibrary {\\n    using SafeMath for uint256;\\n\\n    // ================ Functions ================\\n\\n    function calcMint1t1XUSD(uint256 col_price, uint256 mint_fee, uint256 collateral_amount_d18) public pure returns (uint256, uint256) {\\n        uint256 col_price_usd = col_price;\\n        uint256 c_dollar_value_d18 = (collateral_amount_d18.mul(col_price_usd)).div(1e6);\\n        uint256 fee = (c_dollar_value_d18.mul(mint_fee)).div(1e6);\\n        uint256 out = c_dollar_value_d18.sub(fee);\\n        return (out, fee);\\n    }\\n\\n    function calcMintAlgorithmicXUSD(uint256 mint_fee, uint256 xus_price_usd, uint256 xus_amount_d18) public pure returns (uint256, uint256) {\\n        uint256 xus_dollar_value_d18 = xus_amount_d18.mul(xus_price_usd).div(1e6);\\n        uint256 fee = (xus_dollar_value_d18.mul(mint_fee)).div(1e6);\\n        uint256 out = xus_dollar_value_d18.sub(fee);\\n        return (out, fee);\\n    }\\n    \\n    // Must be internal because of the struct\\n    function calcMintFractionalXUSD(uint256 collat_amount, uint256 collat_price, uint256 xus_price, uint256 col_ratio, uint256 mint_fee) internal pure returns (uint256, uint256, uint256) {\\n        uint256 c_dollar_value_d18 = collat_amount.mul(collat_price).div(1e6);\\n        \\n        uint calculated_xus_dollar_value_d18 = \\n                    (c_dollar_value_d18.mul(1e6).div(col_ratio))\\n                    .sub(c_dollar_value_d18);\\n\\n        uint calculated_xus_needed = calculated_xus_dollar_value_d18.mul(1e6).div(xus_price);\\n        uint fee = ((c_dollar_value_d18.add(calculated_xus_dollar_value_d18)).mul(mint_fee)).div(1e6);\\n        uint out = (c_dollar_value_d18.add(calculated_xus_dollar_value_d18)).sub(fee);\\n        return (\\n            out,\\n            calculated_xus_needed,\\n            fee\\n        );\\n    }\\n\\n    function calcRedeem1t1XUSD(uint256 col_price_usd, uint256 XUSD_amount, uint256 redemption_fee) public pure returns (uint256, uint256) {\\n        uint256 fee = XUSD_amount.mul(redemption_fee).div(1e6);\\n        uint256 left = XUSD_amount.sub(fee);\\n        uint256 collateral_needed_d18 = left.mul(1e6).div(col_price_usd);\\n        return (collateral_needed_d18, fee);\\n    }\\n\\n    // Must be internal because of the struct\\n    function calcBuyBackXUS(uint256 XUS_amount, uint256 xus_price, uint256 excess_dv, uint256 col_price) internal pure returns (uint256) {\\n        // If the total collateral value is higher than the amount required at the current collateral ratio then buy back up to the possible XUS with the desired collateral\\n        require(excess_dv > 0, \\\"no excess collateral\\\");\\n\\n        // Make sure not to take more than is available\\n        uint256 xus_dollar_value_d18 = XUS_amount.mul(xus_price).div(1e6);\\n        require(xus_dollar_value_d18 <= excess_dv, \\\"excess collateral not enough\\\");\\n\\n        // Get the equivalent amount of collateral based on the market value of XUS provided \\n        uint256 collateral_equivalent_d18 = xus_dollar_value_d18.mul(1e6).div(col_price);\\n        //collateral_equivalent_d18 = collateral_equivalent_d18.sub((collateral_equivalent_d18.mul(params.buyback_fee)).div(1e6));\\n\\n        return (\\n            collateral_equivalent_d18\\n        );\\n\\n    }\\n\\n    // Returns value of collateral that must increase to reach recollateralization target (if 0 means no recollateralization)\\n    function recollateralizeAmount(uint256 total_supply, uint256 global_collateral_ratio, uint256 global_collat_value) public pure returns (uint256) {\\n        uint256 target_collat_value = total_supply.mul(global_collateral_ratio).div(1e6); // We want 18 decimals of precision so divide by 1e6; total_supply is 1e18 and global_collateral_ratio is 1e6\\n        // Subtract the current value of collateral from the target value needed, if higher than 0 then system needs to recollateralize\\n        uint256 recollateralization_left = target_collat_value.sub(global_collat_value); // If recollateralization is not needed, throws a subtraction underflow\\n        return(recollateralization_left);\\n    }\\n\\n    function calcRecollateralizeXUSDInner(\\n        uint256 collateral_amount, \\n        uint256 col_price,\\n        uint256 global_collat_value,\\n        uint256 xusd_total_supply,\\n        uint256 global_collateral_ratio\\n    ) public pure returns (uint256, uint256) {\\n        uint256 collat_value_attempted = collateral_amount.mul(col_price).div(1e6);\\n        uint256 effective_collateral_ratio = global_collat_value.mul(1e6).div(xusd_total_supply); //returns it in 1e6\\n        uint256 recollat_possible = (global_collateral_ratio.mul(xusd_total_supply).sub(xusd_total_supply.mul(effective_collateral_ratio))).div(1e6);\\n\\n        uint256 amount_to_recollat;\\n        if(collat_value_attempted <= recollat_possible){\\n            amount_to_recollat = collat_value_attempted;\\n        } else {\\n            amount_to_recollat = recollat_possible;\\n        }\\n\\n        return (amount_to_recollat.mul(1e6).div(col_price), amount_to_recollat);\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/new/xusd/contracts/XUSD/XUSD.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../Common/Context.sol\\\";\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/ERC20Custom.sol\\\";\\nimport \\\"../ERC20/ERC20.sol\\\";\\nimport \\\"../Math/SafeMath.sol\\\";\\nimport \\\"./Pools/IXUSDPool.sol\\\";\\nimport \\\"../Oracle/UniswapPairOracle.sol\\\";\\nimport \\\"../Oracle/ChainlinkETHUSDPriceConsumer.sol\\\";\\n\\n/**\\n    TODO: set XUSETH oracle to XUS_WETH_NEW\\n */\\ncontract XUSDStablecoin is ERC20Custom {\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE VARIABLES ========== */\\n    enum PriceChoice { XUSD, XUS }\\n    ChainlinkETHUSDPriceConsumer private eth_usd_pricer;\\n    uint8 private eth_usd_pricer_decimals;\\n    UniswapPairOracle private xusdEthOracle;\\n    UniswapPairOracle private xusEthOracle;\\n    string public symbol;\\n    string public name;\\n    uint8 public constant decimals = 18;\\n    address public owner_address;\\n    address public timelock_address; // Governance timelock address\\n    address public controller_address; // Controller contract to dynamically adjust system parameters automatically\\n    address public xus_address;\\n    address public xusd_eth_oracle_address;\\n    address public xus_eth_oracle_address;\\n    address public weth_address;\\n    address public eth_usd_consumer_address;\\n\\n    // mint 500 at genesis to bootstrap liquidity\\n    uint256 public constant genesis_supply = 500e18;\\n\\n    // The addresses in this array are added by the oracle and these contracts are able to mint xusd\\n    address[] public xusd_pools_array;\\n\\n    // Mapping is also used for faster verification\\n    mapping(address => bool) public xusd_pools; \\n\\n    // Constants for various precisions\\n    uint256 private constant PRICE_PRECISION = 1e6;\\n    \\n    uint256 public global_collateral_ratio; // 6 decimals of precision, e.g. 924102 = 0.924102\\n    uint256 public redemption_fee = 3000; // 6 decimals of precision, divide by 1000000 in calculations for fee\\n    uint256 public minting_fee = 7000; // 6 decimals of precision, divide by 1000000 in calculations for fee\\n    uint256 public xusd_step; // Amount to change the collateralization ratio by upon refreshCollateralRatio()\\n    uint256 public refresh_cooldown; // Seconds to wait before being able to run refreshCollateralRatio() again\\n    uint256 public price_target; // The price of XUSD at which the collateral ratio will respond to; this value is only used for the collateral ratio mechanism and not for minting and redeeming which are hardcoded at $1\\n    uint256 public price_band; // The bound above and below the price target at which the refreshCollateralRatio() will not change the collateral ratio\\n\\n    bool public collateral_ratio_paused = false;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyPools() {\\n       require(xusd_pools[msg.sender] == true, \\\"Only xusd pools can call this function\\\");\\n        _;\\n    } \\n    \\n    modifier onlyByOwnerOrGovernance() {\\n        require(msg.sender == owner_address || msg.sender == timelock_address || msg.sender == controller_address, \\\"You are not the owner, controller, or the governance timelock\\\");\\n        _;\\n    }\\n\\n    modifier onlyByOwnerGovernanceOrPool() {\\n        require(\\n            msg.sender == owner_address \\n            || msg.sender == timelock_address \\n            || xusd_pools[msg.sender] == true, \\n            \\\"You are not the owner, the governance timelock, or a pool\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _timelock_address\\n    ) public {\\n        name = _name;\\n        symbol = _symbol;\\n        timelock_address = _timelock_address;\\n        owner_address = msg.sender;\\n        _mint(owner_address, genesis_supply);\\n        xusd_step = 2500; // 6 decimals of precision, equal to 0.25%\\n        global_collateral_ratio = 1000000; // XUSD system starts off fully collateralized (6 decimals of precision)\\n        refresh_cooldown = 3600; // Refresh cooldown period is set to 1 hour (3600 seconds) at genesis\\n        price_target = 1000000; // Collateral ratio will adjust according to the $1 price target at genesis\\n        price_band = 5000; // Collateral ratio will not adjust if between $0.995 and $1.005 at genesis\\n    }\\n\\n    // FOR TEST ONLY! REMOVE WHEN MAINNET!!!\\n    // function setCR(uint256 _cr) external onlyByOwnerOrGovernance {\\n    //     global_collateral_ratio = _cr;\\n    // }\\n\\n    /* ========== VIEWS ========== */\\n\\n    // Choice = 'XUSD' or 'XUS' for now\\n    function oracle_price(PriceChoice choice) internal view returns (uint256) {\\n        // Get the ETH / USD price first, and cut it down to 1e6 precision\\n        uint256 eth_usd_price = uint256(eth_usd_pricer.getLatestPrice()).mul(PRICE_PRECISION).div(uint256(10) ** eth_usd_pricer_decimals);\\n        uint256 price_vs_eth;\\n\\n        if (choice == PriceChoice.XUSD) {\\n            price_vs_eth = uint256(xusdEthOracle.consult(weth_address, PRICE_PRECISION)); // How much XUSD if you put in PRICE_PRECISION WETH\\n        }\\n        else if (choice == PriceChoice.XUS) {\\n            price_vs_eth = uint256(xusEthOracle.consult(weth_address, PRICE_PRECISION)); // How much XUS if you put in PRICE_PRECISION WETH\\n        }\\n        else revert(\\\"INVALID PRICE CHOICE. Needs to be either 0 (XUSD) or 1 (XUS)\\\");\\n\\n        // Will be in 1e6 format\\n        return eth_usd_price.mul(PRICE_PRECISION).div(price_vs_eth);\\n    }\\n\\n    // Returns X XUSD = 1 USD\\n    function xusd_price() public view returns (uint256) {\\n        return oracle_price(PriceChoice.XUSD);\\n    }\\n\\n    // Returns X XUS = 1 USD\\n    function xus_price()  public view returns (uint256) {\\n        return oracle_price(PriceChoice.XUS);\\n    }\\n\\n    function eth_usd_price() public view returns (uint256) {\\n        return uint256(eth_usd_pricer.getLatestPrice()).mul(PRICE_PRECISION).div(uint256(10) ** eth_usd_pricer_decimals);\\n    }\\n\\n    // This is needed to avoid costly repeat calls to different getter functions\\n    // It is cheaper gas-wise to just dump everything and only use some of the info\\n    function xusd_info() public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\\n        return (\\n            oracle_price(PriceChoice.XUSD), // xusd_price()\\n            oracle_price(PriceChoice.XUS), // xus_price()\\n            totalSupply(), // totalSupply()\\n            global_collateral_ratio, // global_collateral_ratio()\\n            globalCollateralValue(), // globalCollateralValue\\n            minting_fee, // minting_fee()\\n            redemption_fee, // redemption_fee()\\n            uint256(eth_usd_pricer.getLatestPrice()).mul(PRICE_PRECISION).div(uint256(10) ** eth_usd_pricer_decimals) //eth_usd_price\\n        );\\n    }\\n\\n    // Iterate through all xusd pools and calculate all value of collateral in all pools globally \\n    function globalCollateralValue() public view returns (uint256) {\\n        uint256 total_collateral_value_d18 = 0; \\n\\n        for (uint i = 0; i < xusd_pools_array.length; i++){ \\n            // Exclude null addresses\\n            if (xusd_pools_array[i] != address(0)){\\n                total_collateral_value_d18 = total_collateral_value_d18.add(IXUSDPool(xusd_pools_array[i]).collatDollarBalance());\\n            }\\n\\n        }\\n        return total_collateral_value_d18;\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n    \\n    // There needs to be a time interval that this can be called. Otherwise it can be called multiple times per expansion.\\n    uint256 public last_call_time; // Last time the refreshCollateralRatio function was called\\n    function refreshCollateralRatio() public {\\n        require(collateral_ratio_paused == false, \\\"Collateral Ratio has been paused\\\");\\n        uint256 xusd_price_cur = xusd_price();\\n        require(block.timestamp - last_call_time >= refresh_cooldown, \\\"Must wait for the refresh cooldown since last refresh\\\");\\n\\n        // Step increments are 0.25% (upon genesis, changable by setXUSDStep()) \\n        \\n        if (xusd_price_cur > price_target.add(price_band)) { //decrease collateral ratio\\n            if(global_collateral_ratio <= xusd_step){ //if within a step of 0, go to 0\\n                global_collateral_ratio = 0;\\n            } else {\\n                global_collateral_ratio = global_collateral_ratio.sub(xusd_step);\\n            }\\n        } else if (xusd_price_cur < price_target.sub(price_band)) { //increase collateral ratio\\n            if(global_collateral_ratio.add(xusd_step) >= 1000000){\\n                global_collateral_ratio = 1000000; // cap collateral ratio at 1.000000\\n            } else {\\n                global_collateral_ratio = global_collateral_ratio.add(xusd_step);\\n            }\\n        }\\n\\n        last_call_time = block.timestamp; // Set the time of the last expansion\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    // Used by pools when user redeems\\n    function pool_burn_from(address b_address, uint256 b_amount) public onlyPools {\\n        super._burnFrom(b_address, b_amount);\\n        emit XUSDBurned(b_address, msg.sender, b_amount);\\n    }\\n\\n    // This function is what other xusd pools will call to mint new XUSD \\n    function pool_mint(address m_address, uint256 m_amount) public onlyPools {\\n        super._mint(m_address, m_amount);\\n        emit XUSDMinted(msg.sender, m_address, m_amount);\\n    }\\n\\n    // Adds collateral addresses supported, such as tether and busd, must be ERC20 \\n    function addPool(address pool_address) public onlyByOwnerOrGovernance {\\n        require(xusd_pools[pool_address] == false, \\\"address already exists\\\");\\n        xusd_pools[pool_address] = true; \\n        xusd_pools_array.push(pool_address);\\n    }\\n\\n    // Remove a pool \\n    function removePool(address pool_address) public onlyByOwnerOrGovernance {\\n        require(xusd_pools[pool_address] == true, \\\"address doesn't exist already\\\");\\n        \\n        // Delete from the mapping\\n        delete xusd_pools[pool_address];\\n\\n        // 'Delete' from the array by setting the address to 0x0\\n        for (uint i = 0; i < xusd_pools_array.length; i++){ \\n            if (xusd_pools_array[i] == pool_address) {\\n                xusd_pools_array[i] = address(0); // This will leave a null in the array and keep the indices the same\\n                break;\\n            }\\n        }\\n    }\\n\\n    function setOwner(address _owner_address) external onlyByOwnerOrGovernance {\\n        owner_address = _owner_address;\\n    }\\n\\n    function setRedemptionFee(uint256 red_fee) public onlyByOwnerOrGovernance {\\n        redemption_fee = red_fee;\\n    }\\n\\n    function setMintingFee(uint256 min_fee) public onlyByOwnerOrGovernance {\\n        minting_fee = min_fee;\\n    }  \\n\\n    function setXUSDStep(uint256 _new_step) public onlyByOwnerOrGovernance {\\n        xusd_step = _new_step;\\n    }  \\n\\n    function setPriceTarget (uint256 _new_price_target) public onlyByOwnerOrGovernance {\\n        price_target = _new_price_target;\\n    }\\n\\n    function setRefreshCooldown(uint256 _new_cooldown) public onlyByOwnerOrGovernance {\\n    \\trefresh_cooldown = _new_cooldown;\\n    }\\n\\n    function setXUSAddress(address _xus_address) public onlyByOwnerOrGovernance {\\n        xus_address = _xus_address;\\n    }\\n\\n    function setETHUSDOracle(address _eth_usd_consumer_address) public onlyByOwnerOrGovernance {\\n        eth_usd_consumer_address = _eth_usd_consumer_address;\\n        eth_usd_pricer = ChainlinkETHUSDPriceConsumer(eth_usd_consumer_address);\\n        eth_usd_pricer_decimals = eth_usd_pricer.getDecimals();\\n    }\\n\\n    function setTimelock(address new_timelock) external onlyByOwnerOrGovernance {\\n        timelock_address = new_timelock;\\n    }\\n\\n    function setController(address _controller_address) external onlyByOwnerOrGovernance {\\n        controller_address = _controller_address;\\n    }\\n\\n    function setPriceBand(uint256 _price_band) external onlyByOwnerOrGovernance {\\n        price_band = _price_band;\\n    }\\n\\n    // Sets the XUSD_ETH Uniswap oracle address \\n    function setXUSDEthOracle(address _xusd_oracle_addr, address _weth_address) public onlyByOwnerOrGovernance {\\n        xusd_eth_oracle_address = _xusd_oracle_addr;\\n        xusdEthOracle = UniswapPairOracle(_xusd_oracle_addr); \\n        weth_address = _weth_address;\\n    }\\n\\n    // Sets the XUS_ETH Uniswap oracle address \\n    function setXUSEthOracle(address _xus_oracle_addr, address _weth_address) public onlyByOwnerOrGovernance {\\n        xus_eth_oracle_address = _xus_oracle_addr;\\n        xusEthOracle = UniswapPairOracle(_xus_oracle_addr);\\n        weth_address = _weth_address;\\n    }\\n\\n    function toggleCollateralRatio() public onlyByOwnerOrGovernance {\\n        collateral_ratio_paused = !collateral_ratio_paused;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    // Track XUSD burned\\n    event XUSDBurned(address indexed from, address indexed to, uint256 amount);\\n\\n    // Track XUSD minted\\n    event XUSDMinted(address indexed from, address indexed to, uint256 amount);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/root/new/xusd/contracts/XUSD/Pools/XUSDPoolLibrary.sol\": {\r\n        \"XUSDPoolLibrary\": \"0xb8825e9b4E7A277e3de253f9F5455a153d1cda6a\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_xusd_contract_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xus_contract_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateral_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timelock_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool_ceiling\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"USDC_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableExcessCollatDV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonus_rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"XUS_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"COLLATERAL_out_min\",\"type\":\"uint256\"}],\"name\":\"buyBackXUS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collatDollarBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collat_usd_consumer_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectRedemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"XUS_amount\",\"type\":\"uint256\"}],\"name\":\"getBuybackOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollateralPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collat_amount\",\"type\":\"uint256\"}],\"name\":\"getMint1t1Out\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"xus_amount\",\"type\":\"uint256\"}],\"name\":\"getMintAlgoOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collat_amount\",\"type\":\"uint256\"}],\"name\":\"getMintFracOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral_amount\",\"type\":\"uint256\"}],\"name\":\"getRecollatOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"xusd_amount\",\"type\":\"uint256\"}],\"name\":\"getRedeem1t1Out\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"XUSD_amount\",\"type\":\"uint256\"}],\"name\":\"getRedeemAlgoOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"XUSD_amount\",\"type\":\"uint256\"}],\"name\":\"getRedeemFracOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastRedeemed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"XUSD_out_min\",\"type\":\"uint256\"}],\"name\":\"mint1t1XUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"xus_amount_d18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"XUSD_out_min\",\"type\":\"uint256\"}],\"name\":\"mintAlgorithmicXUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"XUSD_out_min\",\"type\":\"uint256\"}],\"name\":\"mintFractionalXUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausedPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool_ceiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"XUS_out_min\",\"type\":\"uint256\"}],\"name\":\"recollateralizeXUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"XUSD_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"COLLATERAL_out_min\",\"type\":\"uint256\"}],\"name\":\"redeem1t1XUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"XUSD_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"XUS_out_min\",\"type\":\"uint256\"}],\"name\":\"redeemAlgorithmicXUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redeemCollateralBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"XUSD_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"XUS_out_min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"COLLATERAL_out_min\",\"type\":\"uint256\"}],\"name\":\"redeemFractionalXUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redeemXUSBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redemption_delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collat_usd_consumer_address\",\"type\":\"address\"}],\"name\":\"setCollatUSDOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feepool\",\"type\":\"address\"}],\"name\":\"setFeePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner_address\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_ceiling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_bonus_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_redemption_delay\",\"type\":\"uint256\"}],\"name\":\"setPoolParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_timelock\",\"type\":\"address\"}],\"name\":\"setTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleBuyBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleCollateralPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleRecollateralize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleRedeeming\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unclaimedPoolCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unclaimedPoolXUS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Pool_USDC","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001c9ba9144505aaba12f4b126fda9807150b88f80000000000000000000000000875650dd46b60c592d5a69a6719e4e4187a3ca81000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000075061b5c168477499b3e297ada97a1d22b72a26400000000000000000000000000000000000000000000000000005af3107a4000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}