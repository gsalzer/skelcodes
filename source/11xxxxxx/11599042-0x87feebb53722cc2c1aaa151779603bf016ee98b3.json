{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/connectors/GasTokenUser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\nimport { GasTokenInterface } from \\\"../interfaces/GasTokenInterface.sol\\\";\\n\\ncontract GasTokenUser {\\n    GasTokenInterface constant public GAS_TOKEN = GasTokenInterface(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\\n\\n    /**\\n     * @dev It's expected that frontend checks the CHI balance, so we don't check it here.\\n     */\\n    modifier usesGasToken(address holder) {\\n        uint256 gasCalcValue = gasleft();\\n\\n        _;\\n\\n        gasCalcValue = (_gasUsed(gasCalcValue) + 14154) / 41947;\\n\\n        GAS_TOKEN.freeFromUpTo(\\n            holder,\\n            gasCalcValue\\n        );\\n    }\\n\\n    function _gasUsed(uint256 startingGas) internal view returns (uint256) {\\n        return 21000 + startingGas - gasleft() + 16 * msg.data.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/games/LotteryDoubleEth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport { LotteryHistoryInterface } from \\\"../interfaces/LotteryHistoryInterface.sol\\\";\\nimport { BootyInterface } from \\\"../interfaces/BootyInterface.sol\\\";\\nimport { TreasuryInterface } from \\\"../interfaces/TreasuryInterface.sol\\\";\\nimport { RandomnessInterface } from \\\"../interfaces/RandomnessInterface.sol\\\";\\nimport { GovernanceInterface } from \\\"../interfaces/GovernanceInterface.sol\\\";\\nimport { ResolutionAlarmInterface } from \\\"../interfaces/ResolutionAlarmInterface.sol\\\";\\n\\nimport { GasTokenUser } from \\\"../connectors/GasTokenUser.sol\\\";\\n\\n/** \\n * @title Lottery with 50% winning chance to ~double the bet\\n * @dev Implements betting process\\n */\\ncontract LotteryDoubleEth is GasTokenUser {\\n    using SafeMath for uint256;\\n\\n    GovernanceInterface public immutable TrustedGovernance;\\n    RandomnessInterface public immutable TrustedRandomness;\\n    LotteryHistoryInterface public immutable TrustedHistory;\\n    TreasuryInterface public TrustedTreasury;\\n    ResolutionAlarmInterface internal TrustedAlarm;\\n\\n    // We use LOTTERY_STATE instead of Pausable abstraction\\n    // to save gas fees, as we need more states in lottery state machine.\\n    enum LOTTERY_STATE { OPENED, PAUSED, RESOLUTION, RESOLVED }\\n    LOTTERY_STATE public state = LOTTERY_STATE.OPENED;\\n\\n    address internal constant ZERO_ADDRESS = address(0);\\n    uint256 internal constant MAX_BLOCKS_TO_RESOLVE = 300; // ~60-80 minutes\\n\\n    mapping(uint32 => BootyInterface) public TrustedBooties;\\n    BootyInterface[] public TrustedAvailableBooties;\\n    mapping(address => uint32) public lastRoundPlayed;\\n    mapping(address => uint256) public influencers;\\n    \\n    uint32 public lotteryPeriod = 1440 minutes;\\n    uint32 public currentRound = 0;\\n    uint256 public casinoFee = 10000;       // in percents * 10000, 10000 means 1%\\n    uint256 public rewardCof = 140;         // send x140 L7L for ETH betted\\n    uint256 public refRewardCof = 10;       // send x10 L7L for ETH betted to referrer \\n    uint256 public loserRewardCof = 141;    // compensate casino fee\\n    uint256 public minimalBetAmount = 0.01 ether;\\n    bytes32 public lastSeed;\\n    uint public endsAfter;\\n    uint public maxBlockToResolve;\\n\\n    modifier onlyDAO() {\\n        require(msg.sender == TrustedGovernance.owner(), \\\"Only owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyManagement() {\\n        require(TrustedGovernance.isManagement(msg.sender), \\\"Only management\\\");\\n        _;\\n    }\\n\\n    modifier onlyResolvers() {\\n        require(msg.sender == address(TrustedAlarm)\\n            || TrustedGovernance.isManagement(msg.sender), \\\"Only resolvers\\\");\\n        _;\\n    }\\n\\n    modifier onlyOpenedCasino() {\\n        require(state == LOTTERY_STATE.OPENED, \\\"LE7EL Random is temporary closed\\\");\\n        _;\\n    }\\n\\n    modifier notInResolution() {\\n        LOTTERY_STATE _state = state;\\n        require(_state != LOTTERY_STATE.RESOLUTION && _state != LOTTERY_STATE.RESOLVED, \\\"LE7EL Random is in resolution\\\");\\n        _;\\n    }\\n\\n    modifier onlyValidBets() {\\n        require(msg.value >= minimalBetAmount, \\\"Your bet is too small\\\");\\n        _;\\n    }\\n\\n    /** \\n     * @dev L7L DAO should be in charge of lottery smart-contract.\\n     *\\n     * @param _governance Orchestration contract.\\n     * @param _treasury Escrow contract where user winnings are kept.\\n     * @param _resolution_alarm Chainlink alarm contact proxy.\\n     * @param _randomness Chainlink randomness contract proxy.\\n     * @param _history History of games contract.\\n     */\\n    constructor(address _governance, address _treasury, address _resolution_alarm, address _randomness, address _history) public {\\n        TrustedGovernance = GovernanceInterface(_governance);\\n        TrustedTreasury = TreasuryInterface(_treasury);\\n        TrustedAlarm = ResolutionAlarmInterface(_resolution_alarm);\\n        TrustedRandomness = RandomnessInterface(_randomness);\\n        TrustedHistory = LotteryHistoryInterface(_history);\\n    }\\n\\n    /**\\n     * @dev Start the first round.\\n     */\\n    function initialize(uint32 _currentRound) public {\\n        require(currentRound == 0, \\\"Already initialized\\\");\\n        currentRound = _currentRound;\\n\\n        address bootyAddr = TrustedTreasury.createBooty();\\n        BootyInterface TrustedBooty = BootyInterface(bootyAddr);\\n        TrustedBooty.useForRound(_currentRound);\\n        TrustedBooties[_currentRound] = TrustedBooty;\\n\\n        endsAfter = now + lotteryPeriod;\\n        TrustedHistory.roundStarted(_currentRound, endsAfter);\\n    }\\n\\n    /**\\n     * @dev Helper to fetch current Booty address.\\n     */\\n    function currentBooty() public view returns(address) {\\n        return address(TrustedBooties[currentRound]);\\n    }\\n\\n    /**\\n     * @dev Checks if game is ready for resolution by 3rd party alarm resolvers.\\n     */\\n    function canResolve() public view returns (bool) {\\n        return state == LOTTERY_STATE.OPENED && now > endsAfter;\\n    }\\n\\n    /** \\n     * @dev Requests Chainlink randomness.\\n     *\\n     * In case one side doesn't have bets, declare draw.\\n     *\\n     * In case there are no bets at all - recycle to save gas.\\n     */\\n    function results() public onlyOpenedCasino onlyResolvers {\\n        if (msg.sender == address(TrustedAlarm)) require(now > endsAfter, \\\"Not ready for results\\\");\\n\\n        uint32 _currentRound = currentRound;\\n        BootyInterface TrustedBooty = TrustedBooties[_currentRound];\\n        uint8 bootyReadiness = TrustedBooty.readiness();\\n\\n        if (bootyReadiness == 2) {\\n            uint256 seed = uint256(keccak256(abi.encodePacked(block.difficulty, _currentRound)));\\n\\n            maxBlockToResolve = block.number + MAX_BLOCKS_TO_RESOLVE;\\n            state = LOTTERY_STATE.RESOLUTION;\\n            setAlarm(lotteryPeriod);\\n\\n            TrustedRandomness.getRandom(seed, _currentRound);\\n            lastSeed = bytes32(seed);\\n        } else if (bootyReadiness == 1) {\\n            TrustedBooty.declareDraw();\\n\\n            LotteryHistoryInterface _TrustedHistory = TrustedHistory;\\n            _TrustedHistory.roundEnded(_currentRound, 0, 0, 0);\\n\\n            reset();\\n\\n            uint256 _endsAfter = setAlarm(lotteryPeriod);\\n            _TrustedHistory.roundStarted(_currentRound + 1, _endsAfter);\\n        } else {\\n            LotteryHistoryInterface _TrustedHistory = TrustedHistory;\\n            _TrustedHistory.roundEnded(_currentRound, 0, 0, 0);\\n\\n            currentRound++;\\n\\n            address mmBlue;\\n            uint256 amBlue;\\n            address mmGreen;\\n            uint256 amGreen;\\n            uint32 _newRound = _currentRound + 1;\\n            (mmBlue, amBlue, mmGreen, amGreen) = TrustedBooty.recycleForRound(_newRound);\\n\\n            if (mmBlue != ZERO_ADDRESS) _TrustedHistory.newBet(_newRound, 0, mmBlue, amBlue, ZERO_ADDRESS);\\n            if (mmGreen != ZERO_ADDRESS) _TrustedHistory.newBet(_newRound, 1, mmGreen, amGreen, ZERO_ADDRESS);\\n\\n            state = LOTTERY_STATE.OPENED;\\n            TrustedBooties[_newRound] = TrustedBooty;\\n\\n            uint256 _endsAfter = setAlarm(lotteryPeriod);\\n            _TrustedHistory.roundStarted(_newRound, _endsAfter);\\n        }\\n    }\\n\\n    /**\\n     * @dev Callback function used by VRF Coordinator, pay the winners and reset the lottery.\\n     *\\n     * Presence of bets was checked in results() query.\\n     *\\n     * @param randomness Random result from Oracle.\\n     */\\n    function fulfillRandom(uint256 randomness) external {\\n        require(msg.sender == address(TrustedRandomness), \\\"Only randomness\\\");\\n        require(state == LOTTERY_STATE.RESOLUTION, \\\"Not ready\\\");\\n\\n        BootyInterface TrustedBooty = TrustedBooties[currentRound];\\n        LotteryHistoryInterface _TrustedHistory = TrustedHistory;\\n\\n        // Even result makes Blue betters a winner\\n        // Odd result makes Green betters a winners\\n        if (randomness % 2 == 0) {\\n            TrustedBooty.declareBlueWin();\\n            _TrustedHistory.roundEnded(currentRound, randomness, address(TrustedBooty).balance, TrustedBooty.totalBlue());\\n        } else {\\n            TrustedBooty.declareGreenWin();\\n            _TrustedHistory.roundEnded(currentRound, randomness, address(TrustedBooty).balance, TrustedBooty.totalGreen());\\n        }\\n\\n        state = LOTTERY_STATE.RESOLVED;\\n    }\\n\\n    /**\\n     * @dev Checks if game is ready for a new round after successful resolution.\\n     */\\n    function canContinue() public view returns (bool) {\\n        return state == LOTTERY_STATE.RESOLVED;\\n    }\\n\\n    /** \\n     * @dev Continue game after the round was resolved.\\n     */\\n    function continueGame() public onlyResolvers {\\n        require(canContinue(), \\\"Not resolved\\\");\\n\\n        reset();\\n\\n        TrustedHistory.roundStarted(currentRound, endsAfter);\\n    }\\n\\n    /**\\n     * @dev Set alarm clock which should trigger Chainlink oracle\\n     * resolution for the current lottery round\\n     *\\n     *  @param _lotteryPeriod Minutes until lottery resolution.\\n     */\\n    function setAlarm(uint32 _lotteryPeriod) private returns(uint256) {\\n        uint256 _endsAfter = now + _lotteryPeriod;\\n        endsAfter = _endsAfter;\\n        TrustedAlarm.setAlarm(_lotteryPeriod);\\n        return _endsAfter;\\n    }\\n\\n    /**\\n     * @dev Claim pending booty for the sender account.\\n     */\\n    function claimBooty() external {\\n        TrustedTreasury.withdrawPayments(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Claim pending booty for the sender account, burning the gas token.\\n     */\\n    function claimBootyWithGasToken() external usesGasToken(msg.sender) {\\n        TrustedTreasury.withdrawPayments(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Prepare lottery for the next round.\\n     */\\n    function reset() private {\\n        currentRound++;\\n\\n        require(TrustedAvailableBooties.length > 0, \\\"No free booty contracts\\\");\\n        BootyInterface TrustedBooty = TrustedAvailableBooties[TrustedAvailableBooties.length - 1];\\n        TrustedBooty.useForRound(currentRound);\\n        TrustedBooties[currentRound] = TrustedBooty;\\n        TrustedAvailableBooties.pop();\\n\\n        state = LOTTERY_STATE.OPENED;\\n    }\\n\\n    /**\\n     * @dev Put bet to a Blue side, interface to optimise gas usage.\\n     *\\n     * @param _referrer Address of referrer for extra L7L rewards, pass 0 if none.\\n     */\\n    function betBlue(address _referrer) external payable onlyOpenedCasino onlyValidBets {\\n        commitBlueBet(msg.sender, msg.value, currentRound, _referrer);\\n    }\\n\\n    /**\\n     * @dev Put bet to a Blue side, burning the gas token.\\n     *\\n     * @param _referrer Address of referrer for extra L7L rewards, pass 0 if none.\\n     */\\n    function betBlueWithGasToken(address _referrer) external payable onlyOpenedCasino onlyValidBets usesGasToken(msg.sender) {\\n        commitBlueBet(msg.sender, msg.value, currentRound, _referrer);\\n    }\\n\\n    /**\\n     * @dev Put bet to a Green side, interface to optimise gas usage.\\n     *\\n     * @param _referrer Address of referrer for extra L7L rewards, pass 0 if none.\\n     */\\n    function betGreen(address _referrer) external payable onlyOpenedCasino onlyValidBets {\\n        commitGreenBet(msg.sender, msg.value, currentRound, _referrer);\\n    }\\n\\n    /**\\n     * @dev Put bet to a Green side, burning the gas token.\\n     *\\n     * @param _referrer Address of referrer for extra L7L rewards, pass 0 if none.\\n     */\\n    function betGreenWithGasToken(address _referrer) external payable onlyOpenedCasino onlyValidBets usesGasToken(msg.sender) {\\n        commitGreenBet(msg.sender, msg.value, currentRound, _referrer);\\n    }\\n\\n    /**\\n     * @dev By default do market making with equal bets to both sides.\\n     */\\n    receive() external payable onlyOpenedCasino onlyValidBets {\\n        uint256 greenValue = msg.value.div(2);\\n        uint256 blueValue = msg.value.sub(greenValue);\\n\\n        commitGreenBet(msg.sender, greenValue, currentRound, ZERO_ADDRESS);\\n        commitBlueBet(msg.sender, blueValue, currentRound, ZERO_ADDRESS);\\n    }\\n\\n    /**\\n     * @dev Put bet to a Blue side.\\n     *\\n     * @param sender Address of better.\\n     * @param value Bet size in wei.\\n     * @param _round Current round.\\n     * @param _referrer Referral ticket.\\n     */\\n    function commitBlueBet(address payable sender, uint256 value, uint32 _round, address _referrer) private {\\n        uint256 _cleanBet = cleanValue(value);\\n        BootyInterface TrustedBooty = TrustedBooties[_round];\\n        TrustedBooty.blueBet{value: _cleanBet}(sender);\\n        commitBet(sender, value, TrustedBooty, _round, _referrer);\\n        TrustedHistory.newBet(_round, 0, sender, _cleanBet, _referrer);\\n    }\\n\\n    /**\\n     * @dev Put bet to a Green side.\\n     *\\n     * @param sender Address of better.\\n     * @param value Bet size in wei.\\n     * @param _round Current round.\\n     * @param _referrer Referral ticket.\\n     */\\n    function commitGreenBet(address payable sender, uint256 value, uint32 _round, address _referrer) private {\\n        uint256 _cleanBet = cleanValue(value);\\n        BootyInterface TrustedBooty = TrustedBooties[_round];\\n        TrustedBooty.greenBet{value: _cleanBet}(sender);\\n        commitBet(sender, value, TrustedBooty, _round, _referrer);\\n        TrustedHistory.newBet(_round, 1, sender, _cleanBet, _referrer);\\n    }\\n\\n    /**\\n     * @dev Shared betting business logic\\n     *\\n     * We don't use pendingL7lRewards to optimise reads from storage \\n     * as this function is used a lot.\\n     *\\n     * @param sender Address of better.\\n     * @param value Bet size in wei.\\n     * @param TrustedBooty Contract to interact with current round Booty.\\n     * @param _round Current round.\\n     */\\n    function commitBet(address payable sender, uint256 value, BootyInterface TrustedBooty, uint32 _round, address _referrer) private {\\n        address _senderAddr = address(sender);\\n        uint32 _lastPlayerRound = lastRoundPlayed[_senderAddr];\\n        uint256 _pendingReward = 0;\\n        uint256 _rewardCof = rewardCof;\\n        uint256 _refRewardCof = refRewardCof;\\n\\n        if (_lastPlayerRound != _round) {\\n            TrustedTreasury.registerPlayerBooty(sender, address(TrustedBooty));\\n            lastRoundPlayed[_senderAddr] = _round;\\n\\n            if (_lastPlayerRound > 0 && _rewardCof > 0) {\\n                _pendingReward = TrustedBooties[_lastPlayerRound].losesOf(_senderAddr).mul(loserRewardCof);\\n            }\\n        }\\n\\n        if (_referrer != ZERO_ADDRESS && _referrer != _senderAddr && _refRewardCof > 0) {\\n            _pendingReward = _pendingReward.add(value.mul(_refRewardCof));\\n\\n            uint256 _refCof = _refRewardCof;\\n            uint256 _customCof = influencers[_referrer];\\n            if (_customCof > 0) _refCof = _customCof;\\n            TrustedTreasury.rewardL7l(_referrer, value.mul(_refCof));\\n        }\\n\\n        if (_rewardCof > 0) TrustedTreasury.rewardL7l(_senderAddr, _pendingReward.add(value.mul(_rewardCof)));\\n    }\\n\\n    /**\\n     * @dev Get pending L7L reward from previous loses.\\n     */\\n    function pendingL7lRewards(address player) public view returns(uint256) {\\n        uint32 lastPlayerRound = lastRoundPlayed[player];\\n        if (lastPlayerRound != currentRound && lastPlayerRound > 0 && rewardCof > 0) {\\n            return TrustedBooties[lastPlayerRound].losesOf(player).mul(loserRewardCof);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to calculate value without casino share.\\n     *\\n     * @param _value Original amount to deduct from.\\n     */\\n    function cleanValue(uint256 _value) private view returns (uint256) {\\n        return _value.sub(_value.mul(casinoFee).div(1000000));\\n    }\\n\\n    /**\\n     * @dev Helper to create and register new Booty contracts.\\n     */\\n    function createBooty() public {\\n        address bootyAddr = TrustedTreasury.createBooty();\\n        TrustedAvailableBooties.push(BootyInterface(bootyAddr));\\n    }\\n\\n    /**\\n     * @dev Helper to create and register new Booty contracts.\\n     */\\n    function createBootyWithGasToken() public usesGasToken(msg.sender) {\\n        createBooty();\\n    }\\n\\n    /**\\n     * @dev Manual lottery reset in case it stuck, refund players if there are bets.\\n     * In case resolution has stucked, it's possible to hard reset in 300 blocks (~60-80 minutes)\\n     *\\n     * Use continueGame is it was resolved.\\n     *\\n     * @param _lotteryPeriod Minutes until lottery resolution.\\n     */\\n    function daoReset(uint32 _lotteryPeriod) external onlyManagement {\\n        require(state != LOTTERY_STATE.RESOLVED || block.number > maxBlockToResolve, \\\"Wait 300 blocks to refund\\\");\\n\\n        TrustedBooties[currentRound].declareDraw();\\n        LotteryHistoryInterface _TrustedHistory = TrustedHistory;\\n\\n        _TrustedHistory.roundEnded(currentRound, 0, 0, 0);\\n\\n        reset();\\n\\n        uint256 _endsAfter = endsAfter;\\n        if (_lotteryPeriod > 0) {\\n            _endsAfter = setAlarm(_lotteryPeriod);\\n        }\\n\\n        _TrustedHistory.roundStarted(currentRound, _endsAfter);\\n    }\\n\\n    /** \\n     * @dev Change lottery period from default 24 hours.\\n     * \\n     * @param _lotteryPeriod Minutes until lottery resolution.\\n     */\\n    function daoChangePeriod(uint32 _lotteryPeriod) external onlyManagement {\\n        lotteryPeriod = _lotteryPeriod;\\n    }\\n\\n    /** \\n     * @dev Temporary game suspention for quick reaction against hacks\\n     * L7L DAO can revoke suspention and revoke manager rights \\n     */\\n    function daoToggleLock() external notInResolution onlyManagement {\\n        if (state == LOTTERY_STATE.OPENED) {\\n            state = LOTTERY_STATE.PAUSED;\\n        } else {\\n            state = LOTTERY_STATE.OPENED;\\n\\n            if (now > endsAfter) {\\n                setAlarm(lotteryPeriod);\\n            }\\n        }\\n    }\\n    \\n    /** \\n     * @dev Used to update LE7EL fee.\\n     *\\n     * @param _casinoFee Casino share in hundreds of percents (10000 is 1%, 10000 is 10% etc)\\n     */\\n    function daoSetCasinoFee(uint256 _casinoFee) external notInResolution onlyDAO {\\n        casinoFee = _casinoFee;\\n        loserRewardCof = rewardCof.add(_casinoFee.div(10000));\\n    }\\n\\n    /** \\n     * @dev Used to update Chainlink oracle fee.\\n     *\\n     * @param _rewardCof How much L7L is rewarded for 1 ETH in bets.\\n     */\\n    function daoSetL7lReward(uint256 _rewardCof) external onlyDAO {\\n        rewardCof = _rewardCof;\\n        loserRewardCof = _rewardCof.add(casinoFee.div(10000));\\n    }\\n\\n    /** \\n     * @dev Used to update default referral and referee rewards.\\n     *\\n     * @param _refRewardCof How much extra L7L is rewarded for 1 ETH in bets.\\n     */\\n    function daoDefaultRefReward(uint256 _refRewardCof) external onlyDAO {\\n        refRewardCof = _refRewardCof;\\n    }\\n\\n    /** \\n     * @dev Change custom referral reward.\\n     *\\n     * @param _referrer Address of influencer to recieve custom reward.\\n     * @param _rewardCof Custom ref reward amount in L7L per ETH bet.\\n     */\\n    function daoInfluencerReward(address _referrer, uint256 _rewardCof) external onlyManagement {\\n        require(_rewardCof < 100, \\\"Too high reward\\\");\\n        influencers[_referrer] = _rewardCof;\\n    }\\n    \\n    /** \\n     * @dev Used to update minimal bet amount.\\n     *\\n     * @param _minimalBetAmount Minimal amount in wei.\\n     */\\n    function daoSetMinimalBet(uint256 _minimalBetAmount) external onlyDAO {\\n        minimalBetAmount = _minimalBetAmount;\\n    }\\n\\n    /** \\n     * @dev Used to withdraw earned comission.\\n     */\\n    function daoWithdraw() external onlyManagement {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = TrustedGovernance.beneficiary().call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"unable to withdraw casino share\\\");\\n    }\\n\\n    /** \\n     * @dev All payouts should be cleared before contract can be recycled.\\n     */\\n    function daoRecycleBooty(uint32 round) external onlyManagement {\\n        BootyInterface TrustedBooty = TrustedBooties[round];\\n        TrustedBooty.forceRecycle();\\n        TrustedAvailableBooties.push(TrustedBooty);\\n    }\\n\\n    /** \\n     * @dev Used to upgrade to a new contract version.\\n     *\\n     * @param _resolution_alarm Change smart contract for periodic alarms, can be a casual wallet as well.\\n     */\\n    function daoChangeAlarmClock(address _resolution_alarm) external onlyDAO {\\n        TrustedAlarm = ResolutionAlarmInterface(_resolution_alarm);\\n    }\\n\\n    /** \\n     * @dev Used to upgrade to a new contract version.\\n     */\\n    function daoDie() external onlyDAO {\\n        require(TrustedBooties[currentRound].readiness() == 0, \\\"Game is in process\\\");\\n        selfdestruct(TrustedGovernance.beneficiary());\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/interfaces/BootyInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\ninterface BootyInterface {\\n    function greenBet(address payable sender) external payable;\\n    function blueBet(address payable sender) external payable;\\n\\n    function declareBlueWin() external;\\n    function declareGreenWin() external;\\n    function declareDraw() external;\\n    function useForRound(uint32) external;\\n    function recycleForRound(uint32) external returns (address, uint256, address, uint256);\\n    function forceRecycle() external;\\n\\n    function readiness() external view returns(uint8);\\n    function totalShares() external view returns(uint256);\\n    function totalBlue() external view returns(uint256);\\n    function totalGreen() external view returns(uint256);\\n\\n    function losesOf(address) external view returns(uint256);\\n    function lockedBalanceOf(address) external view returns(uint256);\\n    function unlockedBalanceOf(address) external view returns(uint256);\\n\\n    function release(address payable) external;\\n}\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/interfaces/GasTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\ninterface GasTokenInterface {\\n    function balanceOf(address _who) external view returns (uint256);\\n    function freeUpTo(uint256 value) external returns (uint256);\\n    function freeFromUpTo(address from, uint256 value) external returns (uint256);\\n}\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/interfaces/GovernanceInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\ninterface GovernanceInterface {\\n    function owner() external view returns (address);\\n    function manager() external view returns (address);\\n    function isManagement(address) external view returns (bool);\\n    function beneficiary() external view returns (address payable);\\n    function treasuryContract() external view returns (address);\\n    function lotteryContracts(address) external view returns (bool);\\n    function timeToClaimBooty() external view returns (uint);\\n}\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/interfaces/LotteryHistoryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\ninterface LotteryHistoryInterface {\\n    function newBet(uint32, uint8, address, uint256, address) external;\\n    function roundStarted(uint32, uint) external;\\n    function roundEnded(uint32, uint256, uint256, uint256) external;\\n}\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/interfaces/RandomnessInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\ninterface RandomnessInterface {\\n    function randomNumbers(address, uint32) external view returns (uint);\\n    function getRandom(uint256, uint32) external;\\n}\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/interfaces/ResolutionAlarmInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\ninterface ResolutionAlarmInterface {\\n    function setAlarm(uint32) external;\\n}\"\r\n    },\r\n    \"/Users/wz/c_r_y_p_t_o/l7l/contracts/interfaces/TreasuryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.6.0;\\n\\ninterface TreasuryInterface {\\n    function createBooty() external returns(address);\\n    function registerPlayerBooty(address payable dest, address bootyContract) external;\\n\\n    function payments(address dest) external view returns (uint256);\\n    function withdrawPayments(address payable payee) external;\\n\\n    function balanceOfL7l(address dest) external view returns (uint256);\\n    function rewardL7l(address dest, uint256 amount) external;\\n    function withdrawL7l(address dest) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolution_alarm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_randomness\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_history\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"GAS_TOKEN\",\"outputs\":[{\"internalType\":\"contract GasTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TrustedAvailableBooties\",\"outputs\":[{\"internalType\":\"contract BootyInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"TrustedBooties\",\"outputs\":[{\"internalType\":\"contract BootyInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TrustedGovernance\",\"outputs\":[{\"internalType\":\"contract GovernanceInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TrustedHistory\",\"outputs\":[{\"internalType\":\"contract LotteryHistoryInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TrustedRandomness\",\"outputs\":[{\"internalType\":\"contract RandomnessInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TrustedTreasury\",\"outputs\":[{\"internalType\":\"contract TreasuryInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"betBlue\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"betBlueWithGasToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"betGreen\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"betGreenWithGasToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canContinue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canResolve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"casinoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBooty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBootyWithGasToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"continueGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createBooty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createBootyWithGasToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentBooty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_resolution_alarm\",\"type\":\"address\"}],\"name\":\"daoChangeAlarmClock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_lotteryPeriod\",\"type\":\"uint32\"}],\"name\":\"daoChangePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refRewardCof\",\"type\":\"uint256\"}],\"name\":\"daoDefaultRefReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoDie\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardCof\",\"type\":\"uint256\"}],\"name\":\"daoInfluencerReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"round\",\"type\":\"uint32\"}],\"name\":\"daoRecycleBooty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_lotteryPeriod\",\"type\":\"uint32\"}],\"name\":\"daoReset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_casinoFee\",\"type\":\"uint256\"}],\"name\":\"daoSetCasinoFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardCof\",\"type\":\"uint256\"}],\"name\":\"daoSetL7lReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimalBetAmount\",\"type\":\"uint256\"}],\"name\":\"daoSetMinimalBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoToggleLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endsAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"fulfillRandom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"influencers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_currentRound\",\"type\":\"uint32\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastRoundPlayed\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSeed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loserRewardCof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryPeriod\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBlockToResolve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimalBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"pendingL7lRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refRewardCof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"results\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardCof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum LotteryDoubleEth.LOTTERY_STATE\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LotteryDoubleEth","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e60fb30a5988495789281dafd8ab47f62af0fee300000000000000000000000052ddeb52a755cea4b62d1bad072cc2627e15bbdb000000000000000000000000a505dcf86fc5dc44cb75fc519fafb6de7402238e000000000000000000000000b8525c186c95f572b63f571bd44f87c006507492000000000000000000000000f2dd1c6cde60f0ecb465418d678a1f15f74dbd61","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}