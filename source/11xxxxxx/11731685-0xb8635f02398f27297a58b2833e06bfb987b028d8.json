{"status":"1","message":"OK","result":[{"SourceCode":"{\"AABBGoldToken.sol\":{\"content\":\"pragma solidity ^0.7.0;\\n\\nimport \\\"./AbstractToken.sol\\\";\\n\\n/**\\n * AABB Gold token smart contract.\\n */\\ncontract AABBGoldToken is AbstractToken {\\n  uint256 tokenCount;\\n\\n  /**\\n   * Create new AABB Gold token smart contract, with given number of tokens issued\\n   * and given to msg.sender.\\n   *\\n   * @param _tokenCount number of tokens to issue and give to msg.sender\\n   */\\n  constructor (uint256 _tokenCount) {\\n    accounts [msg.sender] = _tokenCount;\\n    tokenCount = _tokenCount;\\n  }\\n\\n  /**\\n   * Get total number of tokens in circulation.\\n   *\\n   * @return supply total number of tokens in circulation\\n   */\\n  function totalSupply () override public view returns (uint256 supply) {\\n    return tokenCount;\\n  }\\n\\n  /**\\n   * Get name of this token.\\n   *\\n   * @return result name of this token\\n   */\\n  function name () public pure returns (string memory result) {\\n    return \\\"AABB Gold\\\";\\n  }\\n\\n  /**\\n   * Get symbol of this token.\\n   *\\n   * @return result symbol of this token\\n   */\\n  function symbol () public pure returns (string memory result) {\\n    return \\\"AABBG\\\";\\n  }\\n\\n  /**\\n   * Get number of decimals for this token.\\n   *\\n   * @return result number of decimals for this token\\n   */\\n  function decimals () public pure returns (uint8 result) {\\n    return 8;\\n  }\\n\\n  /**\\n   * Change how many tokens given spender is allowed to transfer from message\\n   * spender.  In order to prevent double spending of allowance, this method\\n   * receives assumed current allowance value as an argument.  If actual\\n   * allowance differs from an assumed one, this method just returns false.\\n   *\\n   * @param _spender address to allow the owner of to transfer tokens from\\n   *        message sender\\n   * @param _currentValue assumed number of tokens currently allowed to be\\n   *        transferred\\n   * @param _newValue number of tokens to allow to transfer\\n   * @return success true if token transfer was successfully approved, false otherwise\\n   */\\n  function approve (address _spender, uint256 _currentValue, uint256 _newValue)\\n    public returns (bool success) {\\n    if (allowance (msg.sender, _spender) == _currentValue)\\n      return approve (_spender, _newValue);\\n    else return false;\\n  }\\n}\\n\\n\"},\"AbstractToken.sol\":{\"content\":\"/*\\r\\n * Abstract Token Smart Contract.  Copyright © 2017 by Core State Holdings Corp.\\r\\n */\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./Token.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * Abstract Token Smart Contract that could be used as a base contract for\\r\\n * ERC-20 token contracts.\\r\\n */\\r\\nabstract contract AbstractToken is Token, SafeMath {\\r\\n  /**\\r\\n   * Create new Abstract Token contract.\\r\\n   */\\r\\n  constructor () {\\r\\n    // Do nothing\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get number of tokens currently belonging to given owner.\\r\\n   *\\r\\n   * @param _owner address to get number of tokens currently belonging to the\\r\\n   *        owner of\\r\\n   * @return balance number of tokens currently belonging to the owner of given address\\r\\n   */\\r\\n  function balanceOf (address _owner) override public view returns (uint256 balance) {\\r\\n    return accounts [_owner];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Transfer given number of tokens from message sender to given recipient.\\r\\n   *\\r\\n   * @param _to address to transfer tokens to the owner of\\r\\n   * @param _value number of tokens to transfer to the owner of given address\\r\\n   * @return success true if tokens were transferred successfully, false otherwise\\r\\n   */\\r\\n  function transfer (address _to, uint256 _value)\\r\\n  override public returns (bool success) {\\r\\n    uint256 fromBalance = accounts [msg.sender];\\r\\n    if (fromBalance \\u003c _value) return false;\\r\\n    if (_value \\u003e 0 \\u0026\\u0026 msg.sender != _to) {\\r\\n      accounts [msg.sender] = safeSub (fromBalance, _value);\\r\\n      accounts [_to] = safeAdd (accounts [_to], _value);\\r\\n    }\\r\\n    emit Transfer (msg.sender, _to, _value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Transfer given number of tokens from given owner to given recipient.\\r\\n   *\\r\\n   * @param _from address to transfer tokens from the owner of\\r\\n   * @param _to address to transfer tokens to the owner of\\r\\n   * @param _value number of tokens to transfer from given owner to given\\r\\n   *        recipient\\r\\n   * @return success true if tokens were transferred successfully, false otherwise\\r\\n   */\\r\\n  function transferFrom (address _from, address _to, uint256 _value)\\r\\n  override public returns (bool success) {\\r\\n    uint256 spenderAllowance = allowances [_from][msg.sender];\\r\\n    if (spenderAllowance \\u003c _value) return false;\\r\\n    uint256 fromBalance = accounts [_from];\\r\\n    if (fromBalance \\u003c _value) return false;\\r\\n\\r\\n    allowances [_from][msg.sender] =\\r\\n      safeSub (spenderAllowance, _value);\\r\\n\\r\\n    if (_value \\u003e 0 \\u0026\\u0026 _from != _to) {\\r\\n      accounts [_from] = safeSub (fromBalance, _value);\\r\\n      accounts [_to] = safeAdd (accounts [_to], _value);\\r\\n    }\\r\\n    emit Transfer (_from, _to, _value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Allow given spender to transfer given number of tokens from message sender.\\r\\n   *\\r\\n   * @param _spender address to allow the owner of to transfer tokens from\\r\\n   *        message sender\\r\\n   * @param _value number of tokens to allow to transfer\\r\\n   * @return success true if token transfer was successfully approved, false otherwise\\r\\n   */\\r\\n  function approve (address _spender, uint256 _value)\\r\\n  override public returns (bool success) {\\r\\n    allowances [msg.sender][_spender] = _value;\\r\\n    emit Approval (msg.sender, _spender, _value);\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Tell how many tokens given spender is currently allowed to transfer from\\r\\n   * given owner.\\r\\n   *\\r\\n   * @param _owner address to get number of tokens allowed to be transferred\\r\\n   *        from the owner of\\r\\n   * @param _spender address to get number of tokens allowed to be transferred\\r\\n   *        by the owner of\\r\\n   * @return remaining number of tokens given spender is currently allowed to transfer\\r\\n   *         from given owner\\r\\n   */\\r\\n  function allowance (address _owner, address _spender)\\r\\n  override public view returns (uint256 remaining) {\\r\\n    return allowances [_owner][_spender];\\r\\n  }\\r\\n\\r\\n  mapping (address =\\u003e uint256) internal accounts;\\r\\n\\r\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowances;\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"/*\\n * Safe Math Smart Contract.  Copyright © 2016–2017 by Core State Holdings Corp.\\n */\\npragma solidity ^0.7.0;\\n\\n/**\\n * Provides methods to safely add, subtract and multiply uint256 numbers.\\n */\\ncontract SafeMath {\\n  uint256 constant private MAX_UINT256 =\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Add two uint256 values, throw in case of overflow.\\n   *\\n   * @param x first value to add\\n   * @param y second value to add\\n   * @return z x + y\\n   */\\n  function safeAdd (uint256 x, uint256 y)\\n  pure internal\\n  returns (uint256 z) {\\n    assert (x \\u003c= MAX_UINT256 - y);\\n    return x + y;\\n  }\\n\\n  /**\\n   * Subtract one uint256 value from another, throw in case of underflow.\\n   *\\n   * @param x value to subtract from\\n   * @param y value to subtract\\n   * @return z x - y\\n   */\\n  function safeSub (uint256 x, uint256 y)\\n  pure internal\\n  returns (uint256 z) {\\n    assert (x \\u003e= y);\\n    return x - y;\\n  }\\n\\n  /**\\n   * Multiply two uint256 values, throw in case of overflow.\\n   *\\n   * @param x first value to multiply\\n   * @param y second value to multiply\\n   * @return z x * y\\n   */\\n  function safeMul (uint256 x, uint256 y)\\n  pure internal\\n  returns (uint256 z) {\\n    if (y == 0) return 0; // Prevent division by zero at the next line\\n    assert (x \\u003c= MAX_UINT256 / y);\\n    return x * y;\\n  }\\n}\\n\"},\"Token.sol\":{\"content\":\"/*\\n * EIP-20 Standard Token Smart Contract Interface.\\n * Copyright © 2014–2021 by Core State Holdings Corp.\\n */\\npragma solidity ^0.7.0;\\n\\n/**\\n * ERC-20 standard token interface, as defined\\n * \\u003ca href=\\\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\\"\\u003ehere\\u003c/a\\u003e.\\n */\\ninterface Token {\\n  /**\\n   * Get total number of tokens in circulation.\\n   *\\n   * @return supply total number of tokens in circulation\\n   */\\n  function totalSupply () external view returns (uint256 supply);\\n\\n  /**\\n   * Get number of tokens currently belonging to given owner.\\n   *\\n   * @param _owner address to get number of tokens currently belonging to the\\n   *        owner of\\n   * @return balance number of tokens currently belonging to the owner of given address\\n   */\\n  function balanceOf (address _owner) external view returns (uint256 balance);\\n\\n  /**\\n   * Transfer given number of tokens from message sender to given recipient.\\n   *\\n   * @param _to address to transfer tokens to the owner of\\n   * @param _value number of tokens to transfer to the owner of given address\\n   * @return success true if tokens were transferred successfully, false otherwise\\n   */\\n  function transfer (address _to, uint256 _value)\\n  external returns (bool success);\\n\\n  /**\\n   * Transfer given number of tokens from given owner to given recipient.\\n   *\\n   * @param _from address to transfer tokens from the owner of\\n   * @param _to address to transfer tokens to the owner of\\n   * @param _value number of tokens to transfer from given owner to given\\n   *        recipient\\n   * @return success true if tokens were transferred successfully, false otherwise\\n   */\\n  function transferFrom (address _from, address _to, uint256 _value)\\n  external returns (bool success);\\n\\n  /**\\n   * Allow given spender to transfer given number of tokens from message sender.\\n   *\\n   * @param _spender address to allow the owner of to transfer tokens from\\n   *        message sender\\n   * @param _value number of tokens to allow to transfer\\n   * @return success true if token transfer was successfully approved, false otherwise\\n   */\\n  function approve (address _spender, uint256 _value)\\n  external returns (bool success);\\n\\n  /**\\n   * Tell how many tokens given spender is currently allowed to transfer from\\n   * given owner.\\n   *\\n   * @param _owner address to get number of tokens allowed to be transferred\\n   *        from the owner of\\n   * @param _spender address to get number of tokens allowed to be transferred\\n   *        by the owner of\\n   * @return remaining number of tokens given spender is currently allowed to transfer\\n   *         from given owner\\n   */\\n  function allowance (address _owner, address _spender)\\n  external view returns (uint256 remaining);\\n\\n  /**\\n   * Logged when tokens were transferred from one owner to another.\\n   *\\n   * @param _from address of the owner, tokens were transferred from\\n   * @param _to address of the owner, tokens were transferred to\\n   * @param _value number of tokens transferred\\n   */\\n  event Transfer (address indexed _from, address indexed _to, uint256 _value);\\n\\n  /**\\n   * Logged when owner approved his tokens to be transferred by some spender.\\n   *\\n   * @param _owner owner who approved his tokens to be transferred\\n   * @param _spender spender who were allowed to transfer the tokens belonging\\n   *        to the owner\\n   * @param _value number of tokens belonging to the owner, approved to be\\n   *        transferred by the spender\\n   */\\n  event Approval (\\n    address indexed _owner, address indexed _spender, uint256 _value);\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenCount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currentValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"result\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AABBGoldToken","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000b1a2bc2ec50000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://79bd5e4e33e0513d09996cee587a7c799e78ee632d2248d8d82b642a4fe95068"}]}