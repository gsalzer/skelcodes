{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/persistent/dispatcher/Dispatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../utils/IMigrationHookHandler.sol\\\";\\nimport \\\"../utils/IMigratableVault.sol\\\";\\nimport \\\"../vault/VaultProxy.sol\\\";\\nimport \\\"./IDispatcher.sol\\\";\\n\\n/// @title Dispatcher Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice The top-level contract linking multiple releases.\\n/// It handles the deployment of new VaultProxy instances,\\n/// and the regulation of fund migration from a previous release to the current one.\\n/// It can also be referred to for access-control based on this contract's owner.\\n/// @dev DO NOT EDIT CONTRACT\\ncontract Dispatcher is IDispatcher {\\n    event CurrentFundDeployerSet(address prevFundDeployer, address nextFundDeployer);\\n\\n    event MigrationCancelled(\\n        address indexed vaultProxy,\\n        address indexed prevFundDeployer,\\n        address indexed nextFundDeployer,\\n        address nextVaultAccessor,\\n        address nextVaultLib,\\n        uint256 executableTimestamp\\n    );\\n\\n    event MigrationExecuted(\\n        address indexed vaultProxy,\\n        address indexed prevFundDeployer,\\n        address indexed nextFundDeployer,\\n        address nextVaultAccessor,\\n        address nextVaultLib,\\n        uint256 executableTimestamp\\n    );\\n\\n    event MigrationSignaled(\\n        address indexed vaultProxy,\\n        address indexed prevFundDeployer,\\n        address indexed nextFundDeployer,\\n        address nextVaultAccessor,\\n        address nextVaultLib,\\n        uint256 executableTimestamp\\n    );\\n\\n    event MigrationTimelockSet(uint256 prevTimelock, uint256 nextTimelock);\\n\\n    event NominatedOwnerSet(address indexed nominatedOwner);\\n\\n    event NominatedOwnerRemoved(address indexed nominatedOwner);\\n\\n    event OwnershipTransferred(address indexed prevOwner, address indexed nextOwner);\\n\\n    event MigrationInCancelHookFailed(\\n        bytes failureReturnData,\\n        address indexed vaultProxy,\\n        address indexed prevFundDeployer,\\n        address indexed nextFundDeployer,\\n        address nextVaultAccessor,\\n        address nextVaultLib\\n    );\\n\\n    event MigrationOutHookFailed(\\n        bytes failureReturnData,\\n        IMigrationHookHandler.MigrationOutHook hook,\\n        address indexed vaultProxy,\\n        address indexed prevFundDeployer,\\n        address indexed nextFundDeployer,\\n        address nextVaultAccessor,\\n        address nextVaultLib\\n    );\\n\\n    event SharesTokenSymbolSet(string _nextSymbol);\\n\\n    event VaultProxyDeployed(\\n        address indexed fundDeployer,\\n        address indexed owner,\\n        address vaultProxy,\\n        address indexed vaultLib,\\n        address vaultAccessor,\\n        string fundName\\n    );\\n\\n    struct MigrationRequest {\\n        address nextFundDeployer;\\n        address nextVaultAccessor;\\n        address nextVaultLib;\\n        uint256 executableTimestamp;\\n    }\\n\\n    address private currentFundDeployer;\\n    address private nominatedOwner;\\n    address private owner;\\n    uint256 private migrationTimelock;\\n    string private sharesTokenSymbol;\\n    mapping(address => address) private vaultProxyToFundDeployer;\\n    mapping(address => MigrationRequest) private vaultProxyToMigrationRequest;\\n\\n    modifier onlyCurrentFundDeployer() {\\n        require(\\n            msg.sender == currentFundDeployer,\\n            \\\"Only the current FundDeployer can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only the contract owner can call this function\\\");\\n        _;\\n    }\\n\\n    constructor() public {\\n        migrationTimelock = 2 days;\\n        owner = msg.sender;\\n        sharesTokenSymbol = \\\"ENZF\\\";\\n    }\\n\\n    /////////////\\n    // GENERAL //\\n    /////////////\\n\\n    /// @notice Sets a new `symbol` value for VaultProxy instances\\n    /// @param _nextSymbol The symbol value to set\\n    function setSharesTokenSymbol(string calldata _nextSymbol) external override onlyOwner {\\n        sharesTokenSymbol = _nextSymbol;\\n\\n        emit SharesTokenSymbolSet(_nextSymbol);\\n    }\\n\\n    ////////////////////\\n    // ACCESS CONTROL //\\n    ////////////////////\\n\\n    /// @notice Claim ownership of the contract\\n    function claimOwnership() external override {\\n        address nextOwner = nominatedOwner;\\n        require(\\n            msg.sender == nextOwner,\\n            \\\"claimOwnership: Only the nominatedOwner can call this function\\\"\\n        );\\n\\n        delete nominatedOwner;\\n\\n        address prevOwner = owner;\\n        owner = nextOwner;\\n\\n        emit OwnershipTransferred(prevOwner, nextOwner);\\n    }\\n\\n    /// @notice Revoke the nomination of a new contract owner\\n    function removeNominatedOwner() external override onlyOwner {\\n        address removedNominatedOwner = nominatedOwner;\\n        require(\\n            removedNominatedOwner != address(0),\\n            \\\"removeNominatedOwner: There is no nominated owner\\\"\\n        );\\n\\n        delete nominatedOwner;\\n\\n        emit NominatedOwnerRemoved(removedNominatedOwner);\\n    }\\n\\n    /// @notice Set a new FundDeployer for use within the contract\\n    /// @param _nextFundDeployer The address of the FundDeployer contract\\n    function setCurrentFundDeployer(address _nextFundDeployer) external override onlyOwner {\\n        require(\\n            _nextFundDeployer != address(0),\\n            \\\"setCurrentFundDeployer: _nextFundDeployer cannot be empty\\\"\\n        );\\n        require(\\n            __isContract(_nextFundDeployer),\\n            \\\"setCurrentFundDeployer: Non-contract _nextFundDeployer\\\"\\n        );\\n\\n        address prevFundDeployer = currentFundDeployer;\\n        require(\\n            _nextFundDeployer != prevFundDeployer,\\n            \\\"setCurrentFundDeployer: _nextFundDeployer is already currentFundDeployer\\\"\\n        );\\n\\n        currentFundDeployer = _nextFundDeployer;\\n\\n        emit CurrentFundDeployerSet(prevFundDeployer, _nextFundDeployer);\\n    }\\n\\n    /// @notice Nominate a new contract owner\\n    /// @param _nextNominatedOwner The account to nominate\\n    /// @dev Does not prohibit overwriting the current nominatedOwner\\n    function setNominatedOwner(address _nextNominatedOwner) external override onlyOwner {\\n        require(\\n            _nextNominatedOwner != address(0),\\n            \\\"setNominatedOwner: _nextNominatedOwner cannot be empty\\\"\\n        );\\n        require(\\n            _nextNominatedOwner != owner,\\n            \\\"setNominatedOwner: _nextNominatedOwner is already the owner\\\"\\n        );\\n        require(\\n            _nextNominatedOwner != nominatedOwner,\\n            \\\"setNominatedOwner: _nextNominatedOwner is already nominated\\\"\\n        );\\n\\n        nominatedOwner = _nextNominatedOwner;\\n\\n        emit NominatedOwnerSet(_nextNominatedOwner);\\n    }\\n\\n    /// @dev Helper to check whether an address is a deployed contract\\n    function __isContract(address _who) private view returns (bool isContract_) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(_who)\\n        }\\n\\n        return size > 0;\\n    }\\n\\n    ////////////////\\n    // DEPLOYMENT //\\n    ////////////////\\n\\n    /// @notice Deploys a VaultProxy\\n    /// @param _vaultLib The VaultLib library with which to instantiate the VaultProxy\\n    /// @param _owner The account to set as the VaultProxy's owner\\n    /// @param _vaultAccessor The account to set as the VaultProxy's permissioned accessor\\n    /// @param _fundName The name of the fund\\n    /// @dev Input validation should be handled by the VaultProxy during deployment\\n    function deployVaultProxy(\\n        address _vaultLib,\\n        address _owner,\\n        address _vaultAccessor,\\n        string calldata _fundName\\n    ) external override onlyCurrentFundDeployer returns (address vaultProxy_) {\\n        require(__isContract(_vaultAccessor), \\\"deployVaultProxy: Non-contract _vaultAccessor\\\");\\n\\n        bytes memory constructData = abi.encodeWithSelector(\\n            IMigratableVault.init.selector,\\n            _owner,\\n            _vaultAccessor,\\n            _fundName\\n        );\\n        vaultProxy_ = address(new VaultProxy(constructData, _vaultLib));\\n\\n        address fundDeployer = msg.sender;\\n        vaultProxyToFundDeployer[vaultProxy_] = fundDeployer;\\n\\n        emit VaultProxyDeployed(\\n            fundDeployer,\\n            _owner,\\n            vaultProxy_,\\n            _vaultLib,\\n            _vaultAccessor,\\n            _fundName\\n        );\\n\\n        return vaultProxy_;\\n    }\\n\\n    ////////////////\\n    // MIGRATIONS //\\n    ////////////////\\n\\n    /// @notice Cancels a pending migration request\\n    /// @param _vaultProxy The VaultProxy contract for which to cancel the migration request\\n    /// @param _bypassFailure True if a failure in either migration hook should be ignored\\n    /// @dev Because this function must also be callable by a permissioned migrator, it has an\\n    /// extra migration hook to the nextFundDeployer for the case where cancelMigration()\\n    /// is called directly (rather than via the nextFundDeployer).\\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external override {\\n        MigrationRequest memory request = vaultProxyToMigrationRequest[_vaultProxy];\\n        address nextFundDeployer = request.nextFundDeployer;\\n        require(nextFundDeployer != address(0), \\\"cancelMigration: No migration request exists\\\");\\n\\n        // TODO: confirm that if canMigrate() does not exist but the caller is a valid FundDeployer, this still works.\\n        require(\\n            msg.sender == nextFundDeployer || IMigratableVault(_vaultProxy).canMigrate(msg.sender),\\n            \\\"cancelMigration: Not an allowed caller\\\"\\n        );\\n\\n        address prevFundDeployer = vaultProxyToFundDeployer[_vaultProxy];\\n        address nextVaultAccessor = request.nextVaultAccessor;\\n        address nextVaultLib = request.nextVaultLib;\\n        uint256 executableTimestamp = request.executableTimestamp;\\n\\n        delete vaultProxyToMigrationRequest[_vaultProxy];\\n\\n        __invokeMigrationOutHook(\\n            IMigrationHookHandler.MigrationOutHook.PostCancel,\\n            _vaultProxy,\\n            prevFundDeployer,\\n            nextFundDeployer,\\n            nextVaultAccessor,\\n            nextVaultLib,\\n            _bypassFailure\\n        );\\n        __invokeMigrationInCancelHook(\\n            _vaultProxy,\\n            prevFundDeployer,\\n            nextFundDeployer,\\n            nextVaultAccessor,\\n            nextVaultLib,\\n            _bypassFailure\\n        );\\n\\n        emit MigrationCancelled(\\n            _vaultProxy,\\n            prevFundDeployer,\\n            nextFundDeployer,\\n            nextVaultAccessor,\\n            nextVaultLib,\\n            executableTimestamp\\n        );\\n    }\\n\\n    /// @notice Executes a pending migration request\\n    /// @param _vaultProxy The VaultProxy contract for which to execute the migration request\\n    /// @param _bypassFailure True if a failure in either migration hook should be ignored\\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external override {\\n        MigrationRequest memory request = vaultProxyToMigrationRequest[_vaultProxy];\\n        address nextFundDeployer = request.nextFundDeployer;\\n        require(\\n            nextFundDeployer != address(0),\\n            \\\"executeMigration: No migration request exists for _vaultProxy\\\"\\n        );\\n        require(\\n            msg.sender == nextFundDeployer,\\n            \\\"executeMigration: Only the target FundDeployer can call this function\\\"\\n        );\\n        require(\\n            nextFundDeployer == currentFundDeployer,\\n            \\\"executeMigration: The target FundDeployer is no longer the current FundDeployer\\\"\\n        );\\n        uint256 executableTimestamp = request.executableTimestamp;\\n        require(\\n            block.timestamp >= executableTimestamp,\\n            \\\"executeMigration: The migration timelock has not elapsed\\\"\\n        );\\n\\n        address prevFundDeployer = vaultProxyToFundDeployer[_vaultProxy];\\n        address nextVaultAccessor = request.nextVaultAccessor;\\n        address nextVaultLib = request.nextVaultLib;\\n\\n        __invokeMigrationOutHook(\\n            IMigrationHookHandler.MigrationOutHook.PreMigrate,\\n            _vaultProxy,\\n            prevFundDeployer,\\n            nextFundDeployer,\\n            nextVaultAccessor,\\n            nextVaultLib,\\n            _bypassFailure\\n        );\\n\\n        // Upgrade the VaultProxy to a new VaultLib and update the accessor via the new VaultLib\\n        IMigratableVault(_vaultProxy).setVaultLib(nextVaultLib);\\n        IMigratableVault(_vaultProxy).setAccessor(nextVaultAccessor);\\n\\n        // Update the FundDeployer that migrated the VaultProxy\\n        vaultProxyToFundDeployer[_vaultProxy] = nextFundDeployer;\\n\\n        // Remove the migration request\\n        delete vaultProxyToMigrationRequest[_vaultProxy];\\n\\n        __invokeMigrationOutHook(\\n            IMigrationHookHandler.MigrationOutHook.PostMigrate,\\n            _vaultProxy,\\n            prevFundDeployer,\\n            nextFundDeployer,\\n            nextVaultAccessor,\\n            nextVaultLib,\\n            _bypassFailure\\n        );\\n\\n        emit MigrationExecuted(\\n            _vaultProxy,\\n            prevFundDeployer,\\n            nextFundDeployer,\\n            nextVaultAccessor,\\n            nextVaultLib,\\n            executableTimestamp\\n        );\\n    }\\n\\n    /// @notice Sets a new migration timelock\\n    /// @param _nextTimelock The number of seconds for the new timelock\\n    function setMigrationTimelock(uint256 _nextTimelock) external override onlyOwner {\\n        uint256 prevTimelock = migrationTimelock;\\n        require(\\n            _nextTimelock != prevTimelock,\\n            \\\"setMigrationTimelock: _nextTimelock is the current timelock\\\"\\n        );\\n\\n        migrationTimelock = _nextTimelock;\\n\\n        emit MigrationTimelockSet(prevTimelock, _nextTimelock);\\n    }\\n\\n    /// @notice Signals a migration by creating a migration request\\n    /// @param _vaultProxy The VaultProxy contract for which to signal migration\\n    /// @param _nextVaultAccessor The account that will be the next `accessor` on the VaultProxy\\n    /// @param _nextVaultLib The next VaultLib library contract address to set on the VaultProxy\\n    /// @param _bypassFailure True if a failure in either migration hook should be ignored\\n    function signalMigration(\\n        address _vaultProxy,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib,\\n        bool _bypassFailure\\n    ) external override onlyCurrentFundDeployer {\\n        require(\\n            __isContract(_nextVaultAccessor),\\n            \\\"signalMigration: Non-contract _nextVaultAccessor\\\"\\n        );\\n\\n        address prevFundDeployer = vaultProxyToFundDeployer[_vaultProxy];\\n        require(prevFundDeployer != address(0), \\\"signalMigration: _vaultProxy does not exist\\\");\\n\\n        address nextFundDeployer = msg.sender;\\n        require(\\n            nextFundDeployer != prevFundDeployer,\\n            \\\"signalMigration: Can only migrate to a new FundDeployer\\\"\\n        );\\n\\n        __invokeMigrationOutHook(\\n            IMigrationHookHandler.MigrationOutHook.PreSignal,\\n            _vaultProxy,\\n            prevFundDeployer,\\n            nextFundDeployer,\\n            _nextVaultAccessor,\\n            _nextVaultLib,\\n            _bypassFailure\\n        );\\n\\n        uint256 executableTimestamp = block.timestamp + migrationTimelock;\\n        vaultProxyToMigrationRequest[_vaultProxy] = MigrationRequest({\\n            nextFundDeployer: nextFundDeployer,\\n            nextVaultAccessor: _nextVaultAccessor,\\n            nextVaultLib: _nextVaultLib,\\n            executableTimestamp: executableTimestamp\\n        });\\n\\n        __invokeMigrationOutHook(\\n            IMigrationHookHandler.MigrationOutHook.PostSignal,\\n            _vaultProxy,\\n            prevFundDeployer,\\n            nextFundDeployer,\\n            _nextVaultAccessor,\\n            _nextVaultLib,\\n            _bypassFailure\\n        );\\n\\n        emit MigrationSignaled(\\n            _vaultProxy,\\n            prevFundDeployer,\\n            nextFundDeployer,\\n            _nextVaultAccessor,\\n            _nextVaultLib,\\n            executableTimestamp\\n        );\\n    }\\n\\n    /// @dev Helper to invoke a MigrationInCancelHook on the next FundDeployer being \\\"migrated in\\\" to,\\n    /// which can optionally be implemented on the FundDeployer\\n    function __invokeMigrationInCancelHook(\\n        address _vaultProxy,\\n        address _prevFundDeployer,\\n        address _nextFundDeployer,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib,\\n        bool _bypassFailure\\n    ) private {\\n        (bool success, bytes memory returnData) = _nextFundDeployer.call(\\n            abi.encodeWithSelector(\\n                IMigrationHookHandler.invokeMigrationInCancelHook.selector,\\n                _vaultProxy,\\n                _prevFundDeployer,\\n                _nextVaultAccessor,\\n                _nextVaultLib\\n            )\\n        );\\n        if (!success) {\\n            require(\\n                _bypassFailure,\\n                string(abi.encodePacked(\\\"MigrationOutCancelHook: \\\", returnData))\\n            );\\n\\n            emit MigrationInCancelHookFailed(\\n                returnData,\\n                _vaultProxy,\\n                _prevFundDeployer,\\n                _nextFundDeployer,\\n                _nextVaultAccessor,\\n                _nextVaultLib\\n            );\\n        }\\n    }\\n\\n    /// @dev Helper to invoke a IMigrationHookHandler.MigrationOutHook on the previous FundDeployer being \\\"migrated out\\\" of,\\n    /// which can optionally be implemented on the FundDeployer\\n    function __invokeMigrationOutHook(\\n        IMigrationHookHandler.MigrationOutHook _hook,\\n        address _vaultProxy,\\n        address _prevFundDeployer,\\n        address _nextFundDeployer,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib,\\n        bool _bypassFailure\\n    ) private {\\n        (bool success, bytes memory returnData) = _prevFundDeployer.call(\\n            abi.encodeWithSelector(\\n                IMigrationHookHandler.invokeMigrationOutHook.selector,\\n                _hook,\\n                _vaultProxy,\\n                _nextFundDeployer,\\n                _nextVaultAccessor,\\n                _nextVaultLib\\n            )\\n        );\\n        if (!success) {\\n            require(\\n                _bypassFailure,\\n                string(abi.encodePacked(__migrationOutHookFailureReasonPrefix(_hook), returnData))\\n            );\\n\\n            emit MigrationOutHookFailed(\\n                returnData,\\n                _hook,\\n                _vaultProxy,\\n                _prevFundDeployer,\\n                _nextFundDeployer,\\n                _nextVaultAccessor,\\n                _nextVaultLib\\n            );\\n        }\\n    }\\n\\n    /// @dev Helper to return a revert reason string prefix for a given MigrationOutHook\\n    function __migrationOutHookFailureReasonPrefix(IMigrationHookHandler.MigrationOutHook _hook)\\n        private\\n        pure\\n        returns (string memory failureReasonPrefix_)\\n    {\\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PreSignal) {\\n            return \\\"MigrationOutHook.PreSignal: \\\";\\n        }\\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PostSignal) {\\n            return \\\"MigrationOutHook.PostSignal: \\\";\\n        }\\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PreMigrate) {\\n            return \\\"MigrationOutHook.PreMigrate: \\\";\\n        }\\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PostMigrate) {\\n            return \\\"MigrationOutHook.PostMigrate: \\\";\\n        }\\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PostCancel) {\\n            return \\\"MigrationOutHook.PostCancel: \\\";\\n        }\\n\\n        return \\\"\\\";\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    // Provides several potentially helpful getters that are not strictly necessary\\n\\n    /// @notice Gets the current FundDeployer that is allowed to deploy and migrate funds\\n    /// @return currentFundDeployer_ The current FundDeployer contract address\\n    function getCurrentFundDeployer()\\n        external\\n        view\\n        override\\n        returns (address currentFundDeployer_)\\n    {\\n        return currentFundDeployer;\\n    }\\n\\n    /// @notice Gets the FundDeployer with which a given VaultProxy is associated\\n    /// @param _vaultProxy The VaultProxy instance\\n    /// @return fundDeployer_ The FundDeployer contract address\\n    function getFundDeployerForVaultProxy(address _vaultProxy)\\n        external\\n        view\\n        override\\n        returns (address fundDeployer_)\\n    {\\n        return vaultProxyToFundDeployer[_vaultProxy];\\n    }\\n\\n    /// @notice Gets the details of a pending migration request for a given VaultProxy\\n    /// @param _vaultProxy The VaultProxy instance\\n    /// @return nextFundDeployer_ The FundDeployer contract address from which the migration\\n    /// request was made\\n    /// @return nextVaultAccessor_ The account that will be the next `accessor` on the VaultProxy\\n    /// @return nextVaultLib_ The next VaultLib library contract address to set on the VaultProxy\\n    /// @return executableTimestamp_ The timestamp at which the migration request can be executed\\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\\n        external\\n        view\\n        override\\n        returns (\\n            address nextFundDeployer_,\\n            address nextVaultAccessor_,\\n            address nextVaultLib_,\\n            uint256 executableTimestamp_\\n        )\\n    {\\n        MigrationRequest memory r = vaultProxyToMigrationRequest[_vaultProxy];\\n        if (r.executableTimestamp > 0) {\\n            return (\\n                r.nextFundDeployer,\\n                r.nextVaultAccessor,\\n                r.nextVaultLib,\\n                r.executableTimestamp\\n            );\\n        }\\n    }\\n\\n    /// @notice Gets the amount of time that must pass between signaling and executing a migration\\n    /// @return migrationTimelock_ The timelock value (in seconds)\\n    function getMigrationTimelock() external view override returns (uint256 migrationTimelock_) {\\n        return migrationTimelock;\\n    }\\n\\n    /// @notice Gets the account that is nominated to be the next owner of this contract\\n    /// @return nominatedOwner_ The account that is nominated to be the owner\\n    function getNominatedOwner() external view override returns (address nominatedOwner_) {\\n        return nominatedOwner;\\n    }\\n\\n    /// @notice Gets the owner of this contract\\n    /// @return owner_ The account that is the owner\\n    function getOwner() external view override returns (address owner_) {\\n        return owner;\\n    }\\n\\n    /// @notice Gets the shares token `symbol` value for use in VaultProxy instances\\n    /// @return sharesTokenSymbol_ The `symbol` value\\n    function getSharesTokenSymbol()\\n        external\\n        view\\n        override\\n        returns (string memory sharesTokenSymbol_)\\n    {\\n        return sharesTokenSymbol;\\n    }\\n\\n    /// @notice Gets the time remaining until the migration request of a given VaultProxy can be executed\\n    /// @param _vaultProxy The VaultProxy instance\\n    /// @return secondsRemaining_ The number of seconds remaining on the timelock\\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        override\\n        returns (uint256 secondsRemaining_)\\n    {\\n        uint256 executableTimestamp = vaultProxyToMigrationRequest[_vaultProxy]\\n            .executableTimestamp;\\n        if (executableTimestamp == 0) {\\n            return 0;\\n        }\\n\\n        if (block.timestamp >= executableTimestamp) {\\n            return 0;\\n        }\\n\\n        return executableTimestamp - block.timestamp;\\n    }\\n\\n    /// @notice Checks whether a migration request that is executable exists for a given VaultProxy\\n    /// @param _vaultProxy The VaultProxy instance\\n    /// @return hasExecutableRequest_ True if a migration request exists and is executable\\n    function hasExecutableMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        override\\n        returns (bool hasExecutableRequest_)\\n    {\\n        uint256 executableTimestamp = vaultProxyToMigrationRequest[_vaultProxy]\\n            .executableTimestamp;\\n\\n        return executableTimestamp > 0 && block.timestamp >= executableTimestamp;\\n    }\\n\\n    /// @notice Checks whether a migration request exists for a given VaultProxy\\n    /// @param _vaultProxy The VaultProxy instance\\n    /// @return hasMigrationRequest_ True if a migration request exists\\n    function hasMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        override\\n        returns (bool hasMigrationRequest_)\\n    {\\n        return vaultProxyToMigrationRequest[_vaultProxy].executableTimestamp > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/dispatcher/IDispatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IDispatcher Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IDispatcher {\\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external;\\n\\n    function claimOwnership() external;\\n\\n    function deployVaultProxy(\\n        address _vaultLib,\\n        address _owner,\\n        address _vaultAccessor,\\n        string calldata _fundName\\n    ) external returns (address vaultProxy_);\\n\\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external;\\n\\n    function getCurrentFundDeployer() external view returns (address currentFundDeployer_);\\n\\n    function getFundDeployerForVaultProxy(address _vaultProxy)\\n        external\\n        view\\n        returns (address fundDeployer_);\\n\\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\\n        external\\n        view\\n        returns (\\n            address nextFundDeployer_,\\n            address nextVaultAccessor_,\\n            address nextVaultLib_,\\n            uint256 executableTimestamp_\\n        );\\n\\n    function getMigrationTimelock() external view returns (uint256 migrationTimelock_);\\n\\n    function getNominatedOwner() external view returns (address nominatedOwner_);\\n\\n    function getOwner() external view returns (address owner_);\\n\\n    function getSharesTokenSymbol() external view returns (string memory sharesTokenSymbol_);\\n\\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (uint256 secondsRemaining_);\\n\\n    function hasExecutableMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (bool hasExecutableRequest_);\\n\\n    function hasMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (bool hasMigrationRequest_);\\n\\n    function removeNominatedOwner() external;\\n\\n    function setCurrentFundDeployer(address _nextFundDeployer) external;\\n\\n    function setMigrationTimelock(uint256 _nextTimelock) external;\\n\\n    function setNominatedOwner(address _nextNominatedOwner) external;\\n\\n    function setSharesTokenSymbol(string calldata _nextSymbol) external;\\n\\n    function signalMigration(\\n        address _vaultProxy,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib,\\n        bool _bypassFailure\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/utils/IMigratableVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IMigratableVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @dev DO NOT EDIT CONTRACT\\ninterface IMigratableVault {\\n    function canMigrate(address _who) external view returns (bool canMigrate_);\\n\\n    function init(\\n        address _owner,\\n        address _accessor,\\n        string calldata _fundName\\n    ) external;\\n\\n    function setAccessor(address _nextAccessor) external;\\n\\n    function setVaultLib(address _nextVaultLib) external;\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/utils/IMigrationHookHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IMigrationHookHandler Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IMigrationHookHandler {\\n    enum MigrationOutHook {PreSignal, PostSignal, PreMigrate, PostMigrate, PostCancel}\\n\\n    function invokeMigrationInCancelHook(\\n        address _vaultProxy,\\n        address _prevFundDeployer,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib\\n    ) external;\\n\\n    function invokeMigrationOutHook(\\n        MigrationOutHook _hook,\\n        address _vaultProxy,\\n        address _nextFundDeployer,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/vault/VaultProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./utils/ProxiableVaultLib.sol\\\";\\n\\n/// @title VaultProxy Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A proxy contract for all VaultProxy instances, slightly modified from EIP-1822\\n/// @dev Adapted from the recommended implementation of a Proxy in EIP-1822, updated for solc 0.6.12,\\n/// and using the EIP-1967 storage slot for the proxiable implementation.\\n/// i.e., `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`, which is\\n/// \\\"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\\\"\\n/// See: https://eips.ethereum.org/EIPS/eip-1822\\ncontract VaultProxy {\\n    constructor(bytes memory _constructData, address _vaultLib) public {\\n        // \\\"0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5\\\" corresponds to\\n        // `bytes32(keccak256('mln.proxiable.vaultlib'))`\\n        require(\\n            bytes32(0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5) ==\\n                ProxiableVaultLib(_vaultLib).proxiableUUID(),\\n            \\\"constructor: _vaultLib not compatible\\\"\\n        );\\n\\n        assembly {\\n            // solium-disable-line\\n            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _vaultLib)\\n        }\\n\\n        (bool success, bytes memory returnData) = _vaultLib.delegatecall(_constructData); // solium-disable-line\\n        require(success, string(returnData));\\n    }\\n\\n    fallback() external payable {\\n        assembly {\\n            // solium-disable-line\\n            let contractLogic := sload(\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\\n            )\\n            calldatacopy(0x0, 0x0, calldatasize())\\n            let success := delegatecall(\\n                sub(gas(), 10000),\\n                contractLogic,\\n                0x0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            let retSz := returndatasize()\\n            returndatacopy(0, 0, retSz)\\n            switch success\\n                case 0 {\\n                    revert(0, retSz)\\n                }\\n                default {\\n                    return(0, retSz)\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/vault/utils/ProxiableVaultLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title ProxiableVaultLib Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A contract that defines the upgrade behavior for VaultLib instances\\n/// @dev The recommended implementation of the target of a proxy according to EIP-1822 and EIP-1967\\n/// Code position in storage is `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`,\\n/// which is \\\"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\\\".\\nabstract contract ProxiableVaultLib {\\n    /// @dev Updates the target of the proxy to be the contract at _nextVaultLib\\n    function __updateCodeAddress(address _nextVaultLib) internal {\\n        require(\\n            bytes32(0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5) ==\\n                ProxiableVaultLib(_nextVaultLib).proxiableUUID(),\\n            \\\"__updateCodeAddress: _nextVaultLib not compatible\\\"\\n        );\\n        assembly {\\n            // solium-disable-line\\n            sstore(\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\\n                _nextVaultLib\\n            )\\n        }\\n    }\\n\\n    /// @notice Returns a unique bytes32 hash for VaultLib instances\\n    /// @return uuid_ The bytes32 hash representing the UUID\\n    /// @dev The UUID is `bytes32(keccak256('mln.proxiable.vaultlib'))`\\n    function proxiableUUID() public pure returns (bytes32 uuid_) {\\n        return 0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevFundDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextFundDeployer\",\"type\":\"address\"}],\"name\":\"CurrentFundDeployerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevFundDeployer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nextFundDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextVaultAccessor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextVaultLib\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executableTimestamp\",\"type\":\"uint256\"}],\"name\":\"MigrationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevFundDeployer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nextFundDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextVaultAccessor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextVaultLib\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executableTimestamp\",\"type\":\"uint256\"}],\"name\":\"MigrationExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"failureReturnData\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevFundDeployer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nextFundDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextVaultAccessor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextVaultLib\",\"type\":\"address\"}],\"name\":\"MigrationInCancelHookFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"failureReturnData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"enum IMigrationHookHandler.MigrationOutHook\",\"name\":\"hook\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevFundDeployer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nextFundDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextVaultAccessor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextVaultLib\",\"type\":\"address\"}],\"name\":\"MigrationOutHookFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevFundDeployer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nextFundDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextVaultAccessor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nextVaultLib\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executableTimestamp\",\"type\":\"uint256\"}],\"name\":\"MigrationSignaled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevTimelock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextTimelock\",\"type\":\"uint256\"}],\"name\":\"MigrationTimelockSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nominatedOwner\",\"type\":\"address\"}],\"name\":\"NominatedOwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nominatedOwner\",\"type\":\"address\"}],\"name\":\"NominatedOwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nextOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_nextSymbol\",\"type\":\"string\"}],\"name\":\"SharesTokenSymbolSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fundDeployer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultLib\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultAccessor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"fundName\",\"type\":\"string\"}],\"name\":\"VaultProxyDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bypassFailure\",\"type\":\"bool\"}],\"name\":\"cancelMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultLib\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultAccessor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_fundName\",\"type\":\"string\"}],\"name\":\"deployVaultProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vaultProxy_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bypassFailure\",\"type\":\"bool\"}],\"name\":\"executeMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentFundDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"currentFundDeployer_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"}],\"name\":\"getFundDeployerForVaultProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fundDeployer_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"}],\"name\":\"getMigrationRequestDetailsForVaultProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"nextFundDeployer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nextVaultAccessor_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nextVaultLib_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"executableTimestamp_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMigrationTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"migrationTimelock_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"nominatedOwner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSharesTokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sharesTokenSymbol_\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"}],\"name\":\"getTimelockRemainingForMigrationRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsRemaining_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"}],\"name\":\"hasExecutableMigrationRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasExecutableRequest_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"}],\"name\":\"hasMigrationRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasMigrationRequest_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeNominatedOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nextFundDeployer\",\"type\":\"address\"}],\"name\":\"setCurrentFundDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextTimelock\",\"type\":\"uint256\"}],\"name\":\"setMigrationTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nextNominatedOwner\",\"type\":\"address\"}],\"name\":\"setNominatedOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_nextSymbol\",\"type\":\"string\"}],\"name\":\"setSharesTokenSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nextVaultAccessor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nextVaultLib\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bypassFailure\",\"type\":\"bool\"}],\"name\":\"signalMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Dispatcher","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}