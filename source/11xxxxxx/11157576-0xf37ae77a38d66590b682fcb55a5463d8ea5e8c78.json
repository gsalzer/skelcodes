{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 50000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/lib/SafeMath.sol\": {\r\n      \"keccak256\": \"0xfb72ae2642cad8f5da1644433dbcc12681f8064335dff144623f0514dc7922c6\",\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.17;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/lib/Address.sol\": {\r\n      \"keccak256\": \"0xfcf985fe775d3891eb6f1df2b0926b13392f7411550fbddbb2a51e2dfb4c328f\",\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call.value(weiValue)(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/lib/IUniswapV2Pair.sol\": {\r\n      \"keccak256\": \"0x311645a7312f2ef6eaf48ef2837e7f0cf9310ecb99d6400a1a31021c44e0f027\",\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface UniswapPair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/lib/UniswapV2OracleLibrary.sol\": {\r\n      \"keccak256\": \"0xc484f02c9ebf2e587fa620e7bfb13aa7e9e3fa423e49960a1ab8d59027439ded\",\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport './IUniswapV2Pair.sol';\\nimport './FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair,\\n        bool isToken0\\n    ) internal view returns (uint priceCumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = UniswapPair(pair).getReserves();\\n        if (isToken0) {\\n          priceCumulative = UniswapPair(pair).price0CumulativeLast();\\n\\n          // if time has elapsed since the last update on the pair, mock the accumulated price values\\n          if (blockTimestampLast != blockTimestamp) {\\n              // subtraction overflow is desired\\n              uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n              // addition overflow is desired\\n              // counterfactual\\n              priceCumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n          }\\n        } else {\\n          priceCumulative = UniswapPair(pair).price1CumulativeLast();\\n          // if time has elapsed since the last update on the pair, mock the accumulated price values\\n          if (blockTimestampLast != blockTimestamp) {\\n              // subtraction overflow is desired\\n              uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n              // addition overflow is desired\\n              // counterfactual\\n              priceCumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n          }\\n        }\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/token/GAMER.sol\": {\r\n      \"keccak256\": \"0x3d64887ada4c394c5309e365ec68652ccea2dea6641662e808be3c48cf9b2d2e\",\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n/* import \\\"./GAMERTokenInterface.sol\\\"; */\\nimport \\\"./GAMERGovernance.sol\\\";\\n\\ncontract GAMERToken is GAMERGovernanceToken {\\n    // Modifiers\\n    modifier onlyGov() {\\n        require(msg.sender == gov, 'not gov');\\n        _;\\n    }\\n\\n    modifier onlyRebaser() {\\n        require(msg.sender == rebaser);\\n        _;\\n    }\\n\\n    modifier onlyMinter() {\\n        require(msg.sender == rebaser || msg.sender == incentivizer || msg.sender == stakingPool || msg.sender == teamPool || msg.sender == dev || msg.sender == gov, \\\"not minter\\\");\\n        _;\\n    }\\n\\n    modifier validRecipient(address to) {\\n        require(to != address(0x0));\\n        require(to != address(this));\\n        _;\\n    }\\n\\n    function initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    )\\n        public\\n    {\\n        require(gamersScalingFactor == 0, \\\"already initialized\\\");\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n    }\\n\\n    /**\\n    * @notice Computes the current totalSupply\\n    */\\n    function totalSupply()\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _totalSupply.div(10**24/ (BASE));\\n    }\\n    \\n    /**\\n    * @notice Computes the current max scaling factor\\n    */\\n    function maxScalingFactor()\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _maxScalingFactor();\\n    }\\n\\n    function _maxScalingFactor()\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // scaling factor can only go up to 2**256-1 = initSupply * gamersScalingFactor\\n        // this is used to check if gamersScalingFactor will be too high to compute balances when rebasing.\\n        return uint256(-1) / initSupply;\\n    }\\n\\n    /**\\n    * @notice Mints new tokens, increasing totalSupply, initSupply, and a users balance.\\n    * @dev Limited to onlyMinter modifier\\n    */\\n    function mint(address to, uint256 amount)\\n        external\\n        onlyMinter\\n        returns (bool)\\n    {\\n        _mint(to, amount);\\n        return true;\\n    }\\n\\n    function _mint(address to, uint256 amount)\\n        internal\\n    {\\n      // increase totalSupply\\n      _totalSupply = _totalSupply.add(amount.mul(10**24/ (BASE)));\\n\\n      // get underlying value\\n      uint256 gamerValue = amount.mul(internalDecimals).div(gamersScalingFactor);\\n\\n      // increase initSupply\\n      initSupply = initSupply.add(gamerValue);\\n\\n      // make sure the mint didnt push maxScalingFactor too low\\n      require(gamersScalingFactor <= _maxScalingFactor(), \\\"max scaling factor too low\\\");\\n\\n      // add balance\\n      _gamerBalances[to] = _gamerBalances[to].add(gamerValue);\\n      emit Transfer(address(0), to, amount);\\n    \\n      // add delegates to the minter\\n      _moveDelegates(address(0), _delegates[to], gamerValue);\\n      emit Mint(to, amount);\\n    }\\n\\n    /* - ERC20 functionality - */\\n\\n    /**\\n    * @dev Transfer tokens to a specified address.\\n    * @param to The address to transfer to.\\n    * @param value The amount to be transferred.\\n    * @return True on success, false otherwise.\\n    */\\n    function transfer(address to, uint256 value)\\n        external\\n        validRecipient(to)\\n        returns (bool)\\n    {\\n        // underlying balance is stored in gamers, so divide by current scaling factor\\n\\n        // note, this means as scaling factor grows, dust will be untransferrable.\\n        // minimum transfer value == gamersScalingFactor / 1e24;\\n\\n        // get amount in underlying\\n        uint256 gamerValue = value.mul(internalDecimals).div(gamersScalingFactor);\\n\\n        // sub from balance of sender\\n        _gamerBalances[msg.sender] = _gamerBalances[msg.sender].sub(gamerValue);\\n\\n        // add to balance of receiver\\n        _gamerBalances[to] = _gamerBalances[to].add(gamerValue);\\n        emit Transfer(msg.sender, to, value);\\n\\n        _moveDelegates(_delegates[msg.sender], _delegates[to], gamerValue);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Transfer tokens from one address to another.\\n    * @param from The address you want to send tokens from.\\n    * @param to The address you want to transfer to.\\n    * @param value The amount of tokens to be transferred.\\n    */\\n    function transferFrom(address from, address to, uint256 value)\\n        external\\n        validRecipient(to)\\n        returns (bool)\\n    {\\n        // decrease allowance\\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);\\n\\n        // get value in gamers\\n        uint256 gamerValue = value.mul(internalDecimals).div(gamersScalingFactor);\\n\\n        // sub from from\\n        _gamerBalances[from] = _gamerBalances[from].sub(gamerValue);\\n        _gamerBalances[to] = _gamerBalances[to].add(gamerValue);\\n        emit Transfer(from, to, value);\\n\\n        _moveDelegates(_delegates[from], _delegates[to], gamerValue);\\n        return true;\\n    }\\n\\n    /**\\n    * @param who The address to query.\\n    * @return The balance of the specified address.\\n    */\\n    function balanceOf(address who)\\n      external\\n      view\\n      returns (uint256)\\n    {\\n      return _gamerBalances[who].mul(gamersScalingFactor).div(internalDecimals);\\n    }\\n\\n    /** @notice Currently returns the internal storage amount\\n    * @param who The address to query.\\n    * @return The underlying balance of the specified address.\\n    */\\n    function balanceOfUnderlying(address who)\\n      external\\n      view\\n      returns (uint256)\\n    {\\n      return _gamerBalances[who];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner has allowed to a spender.\\n     * @param owner_ The address which owns the funds.\\n     * @param spender The address which will spend the funds.\\n     * @return The number of tokens still available for the spender.\\n     */\\n    function allowance(address owner_, address spender)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _allowedFragments[owner_][spender];\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\\n     * msg.sender. This method is included for ERC20 compatibility.\\n     * increaseAllowance and decreaseAllowance should be used instead.\\n     * Changing an allowance with this method brings the risk that someone may transfer both\\n     * the old and the new allowance - if they are both greater than zero - if a transfer\\n     * transaction is mined before the later approve() call is mined.\\n     *\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value)\\n        external\\n        returns (bool)\\n    {\\n        _allowedFragments[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner has allowed to a spender.\\n     * This method should be used instead of approve() to avoid the double approval vulnerability\\n     * described above.\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        external\\n        returns (bool)\\n    {\\n        _allowedFragments[msg.sender][spender] =\\n            _allowedFragments[msg.sender][spender].add(addedValue);\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\\n     *\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        external\\n        returns (bool)\\n    {\\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\\n        if (subtractedValue >= oldValue) {\\n            _allowedFragments[msg.sender][spender] = 0;\\n        } else {\\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\\n        }\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    /* - Governance Functions - */\\n\\n    /** @notice sets the rebaser\\n     * @param rebaser_ The address of the rebaser contract to use for authentication.\\n     */\\n    function _setRebaser(address rebaser_)\\n        external\\n        onlyGov\\n    {\\n        address oldRebaser = rebaser;\\n        rebaser = rebaser_;\\n        emit NewRebaser(oldRebaser, rebaser_);\\n    }\\n\\n    /** @notice sets the incentivizer\\n     * @param incentivizer_ The address of the incentivizer contract to use for authentication.\\n     */\\n    function _setIncentivizer(address incentivizer_)\\n        external\\n        onlyGov\\n    {\\n        address oldIncentivizer = incentivizer;\\n        incentivizer = incentivizer_;\\n        emit NewIncentivizer(oldIncentivizer, incentivizer_);\\n    }\\n\\n    /** @notice sets the stakingPool\\n     * @param stakingPool_ The address of the stakingPool contract to use for authentication.\\n     */\\n    function _setStakingPool(address stakingPool_)\\n        external\\n        onlyGov\\n    {\\n        address oldStakingPool = stakingPool;\\n        stakingPool = stakingPool_;\\n        emit NewStakingPool(oldStakingPool, stakingPool_);\\n    }\\n\\n    /** @notice sets the teamPool\\n     * @param teamPool_ The address of the teamPool contract to use for authentication.\\n     */\\n    function _setTeamPool(address teamPool_)\\n        external\\n        onlyGov\\n    {\\n        address oldTeamPool = teamPool;\\n        teamPool = teamPool_;\\n        emit NewTeamPool(oldTeamPool, teamPool_);\\n    }\\n\\n    /** @notice sets the dev\\n     * @param dev_ The address of the dev contract to use for authentication.\\n     */\\n    function _setDev(address dev_)\\n        external\\n        onlyGov\\n    {\\n        address oldDev = dev;\\n        dev = dev_;\\n        emit NewDev(oldDev, dev_);\\n    }\\n\\n    /** @notice sets the pendingGov\\n     * @param pendingGov_ The address of the rebaser contract to use for authentication.\\n     */\\n    function _setPendingGov(address pendingGov_)\\n        external\\n        onlyGov\\n    {\\n        address oldPendingGov = pendingGov;\\n        pendingGov = pendingGov_;\\n        emit NewPendingGov(oldPendingGov, pendingGov_);\\n    }\\n\\n    /** @notice lets msg.sender accept governance\\n     *\\n     */\\n    function _acceptGov()\\n        external\\n    {\\n        require(msg.sender == pendingGov, \\\"!pending\\\");\\n        address oldGov = gov;\\n        gov = pendingGov;\\n        pendingGov = address(0);\\n        emit NewGov(oldGov, gov);\\n    }\\n\\n    /* - Extras - */\\n\\n    /**\\n    * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\\n    *\\n    * @dev The supply adjustment equals (totalSupply * DeviationFromTargetRate) / rebaseLag\\n    *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\\n    *      and targetRate is CpiOracleRate / baseCpi\\n    */\\n    function rebase(\\n        uint256 epoch,\\n        uint256 indexDelta,\\n        bool positive\\n    )\\n        external\\n        onlyRebaser\\n        returns (uint256)\\n    {\\n        if (indexDelta == 0) {\\n          emit Rebase(epoch, gamersScalingFactor, gamersScalingFactor);\\n          return _totalSupply;\\n        }\\n\\n        uint256 prevGrapsScalingFactor = gamersScalingFactor;\\n\\n        if (!positive) {\\n           gamersScalingFactor = gamersScalingFactor.mul(BASE.sub(indexDelta)).div(BASE);\\n        } else {\\n            uint256 newScalingFactor = gamersScalingFactor.mul(BASE.add(indexDelta)).div(BASE);\\n            if (newScalingFactor < _maxScalingFactor()) {\\n                gamersScalingFactor = newScalingFactor;\\n            } else {\\n              gamersScalingFactor = _maxScalingFactor();\\n            }\\n        }\\n\\n        _totalSupply = initSupply.mul(gamersScalingFactor).div(BASE);\\n        emit Rebase(epoch, prevGrapsScalingFactor, gamersScalingFactor);\\n        return _totalSupply;\\n    }\\n}\\n\\ncontract GAMER is GAMERToken {\\n    /**\\n     * @notice Initialize the new money market\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     */\\n    function initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        address initial_owner,\\n        uint256 initSupply_\\n    )\\n        public\\n    {\\n        require(initSupply_ > 0, \\\"0 init supply\\\");\\n\\n        super.initialize(name_, symbol_, decimals_);\\n\\n        initSupply = initSupply_.mul(10**24/ (BASE));\\n        _totalSupply = initSupply;\\n        gamersScalingFactor = BASE;\\n        _gamerBalances[initial_owner] = initSupply_.mul(10**24 / (BASE));\\n\\n        // owner renounces ownership after deployment as they need to set\\n        // rebaser and incentivizer\\n        // gov = gov_;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/lib/IERC20.sol\": {\r\n      \"keccak256\": \"0xb654abe85060b241b440e22ead01dabb724dda69034d49b483e5e3e55ee64400\",\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/rebaser/GAMERRebaser.sol\": {\r\n      \"keccak256\": \"0xfff1030d791e23f076c55d99c30b15610fc194218b8b298d79ff94d242aaafad\",\r\n      \"content\": \"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\nimport \\\"../lib/SafeMath.sol\\\";\\nimport '../lib/IUniswapV2Pair.sol';\\nimport \\\"../lib/UniswapV2OracleLibrary.sol\\\";\\nimport \\\"../token/GAMERTokenInterface.sol\\\";\\n\\ninterface Reserves {\\n    function distributeTreasuryReward(uint256 amount) external;\\n}\\n\\ncontract GAMERRebaser {\\n\\n    using SafeMath for uint256;\\n\\n    modifier onlyGov() {\\n        require(msg.sender == gov);\\n        _;\\n    }\\n\\n    struct Transaction {\\n        bool enabled;\\n        address destination;\\n        bytes data;\\n    }\\n\\n    struct UniVars {\\n      uint256 gamersToUni;\\n      uint256 amountFromReserves;\\n      uint256 mintToReserves;\\n    }\\n\\n    /// @notice an event emitted when a transaction fails\\n    event TransactionFailed(address indexed destination, uint index, bytes data);\\n\\n    /// @notice an event emitted when maxSlippageFactor is changed\\n    event NewMaxSlippageFactor(uint256 oldSlippageFactor, uint256 newSlippageFactor);\\n\\n    /// @notice an event emitted when deviationThreshold is changed\\n    event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\\n\\n    /**\\n     * @notice Sets the treasury mint percentage of rebase\\n     */\\n    event NewRebaseMintPercent(uint256 oldRebaseMintPerc, uint256 newRebaseMintPerc);\\n\\n\\n    /**\\n     * @notice Sets the reserve contract\\n     */\\n    event NewReserveContract(address oldReserveContract, address newReserveContract);\\n\\n    /**\\n     * @notice Sets the treasury reward ratio\\n     */\\n    event NewTreasuryRewardRatio(uint256 oldTreasuryRewardRatio, uint256 newTreasuryRewardRatio);\\n\\n    /**\\n     * @notice Sets the reserve contract\\n     */\\n    event TreasuryIncreased(uint256 reservesAdded, uint256 gamersSold, uint256 gamersFromReserves, uint256 gamersToReserves);\\n\\n\\n    /**\\n     * @notice Event emitted when pendingGov is changed\\n     */\\n    event NewPendingGov(address oldPendingGov, address newPendingGov);\\n\\n    /**\\n     * @notice Event emitted when gov is changed\\n     */\\n    event NewGov(address oldGov, address newGov);\\n\\n    // Stable ordering is not guaranteed.\\n    Transaction[] public transactions;\\n\\n\\n    /// @notice Governance address\\n    address public gov;\\n\\n    /// @notice Pending Governance address\\n    address public pendingGov;\\n\\n    /// @notice Spreads out getting to the target price\\n    uint256 public rebaseLag;\\n\\n    /// @notice Peg target\\n    uint256 public targetRate;\\n\\n    /// @notice Percent of rebase that goes to minting for treasury building\\n    uint256 public rebaseMintPerc;\\n\\n    // If the current exchange rate is within this fractional distance from the target, no supply\\n    // update is performed. Fixed point number--same format as the rate.\\n    // (ie) abs(rate - targetRate) / targetRate < deviationThreshold, then no supply change.\\n    uint256 public deviationThreshold;\\n\\n    /// @notice More than this much time must pass between rebase operations.\\n    uint256 public minRebaseTimeIntervalSec;\\n\\n    /// @notice Block timestamp of last rebase operation\\n    uint256 public lastRebaseTimestampSec;\\n\\n    /// @notice The rebase window begins this many seconds into the minRebaseTimeInterval period.\\n    // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\\n    uint256 public rebaseWindowOffsetSec;\\n\\n    /// @notice The length of the time window where a rebase operation is allowed to execute, in seconds.\\n    uint256 public rebaseWindowLengthSec;\\n\\n    /// @notice The number of rebase cycles since inception\\n    uint256 public epoch;\\n\\n    // rebasing is not active initially. It can be activated at T+12 hours from\\n    // deployment time\\n    ///@notice boolean showing rebase activation status\\n    bool public rebasingActive;\\n\\n    /// @notice delays rebasing activation to facilitate liquidity\\n    // uint256 public constant rebaseDelay = 24 hours;\\n    uint256 public constant rebaseDelay = 24 hours;\\n\\n    /// @notice Time of TWAP initialization\\n    uint256 public timeOfTWAPInit;\\n\\n    /// @notice GAMER token address\\n    address public gamerAddress;\\n\\n    /// @notice reserve token\\n    address public reserveToken;\\n\\n    /// @notice Reserves vault contract\\n    address public reservesContract;\\n\\n    /// @notice Reserves treasury reward ratio\\n    uint256 public treasuryRewardRatio;\\n\\n    /// @notice pair for reserveToken <> GAMER\\n    address public uniswap_pair;\\n\\n    /// @notice last TWAP update time\\n    uint32 public blockTimestampLast;\\n\\n    /// @notice last TWAP cumulative price;\\n    uint256 public priceCumulativeLast;\\n\\n    // Max slippage factor when buying reserve token. Magic number based on\\n    // the fact that uniswap is a constant product. Therefore,\\n    // targeting a % max slippage can be achieved by using a single precomputed\\n    // number. i.e. 2.5% slippage is always equal to some f(maxSlippageFactor, reserves)\\n    /// @notice the maximum slippage factor when buying reserve token\\n    uint256 public maxSlippageFactor;\\n\\n    /// @notice Whether or not this token is first in uniswap GAMER<>Reserve pair\\n    bool public isToken0;\\n\\n    constructor(\\n        address gamerAddress_,\\n        address reserveToken_,\\n        address uniswap_factory,\\n        address reservesContract_\\n    )\\n        public\\n    {\\n          minRebaseTimeIntervalSec = 24 hours;\\n          rebaseWindowOffsetSec = 4 hours; // 4AM UTC rebases\\n          reservesContract = reservesContract_;\\n          (address token0, address token1) = sortTokens(gamerAddress_, reserveToken_);\\n\\n          // used for interacting with uniswap\\n          if (token0 == gamerAddress_) {\\n              isToken0 = true;\\n          } else {\\n              isToken0 = false;\\n          }\\n          // uniswap GAMER<>Reserve pair\\n          uniswap_pair = pairFor(uniswap_factory, token0, token1);\\n\\n          // Reserves contract is mutable\\n          reservesContract = reservesContract_;\\n\\n          // Reserve token is not mutable. Must deploy a new rebaser to update it\\n          reserveToken = reserveToken_;\\n\\n          gamerAddress = gamerAddress_;\\n\\n          // target 10% slippage\\n          // 5.4%\\n          maxSlippageFactor = 5409258 * 10**10;\\n\\n          // 1 DAI\\n          targetRate = 10**18;\\n\\n          // once daily rebase, with targeting reaching peg in 20 days\\n          rebaseLag = 20;\\n\\n          // 5%\\n          rebaseMintPerc = 5 * 10**16;\\n\\n          // 5%\\n          deviationThreshold = 5 * 10**16;\\n\\n          // 60 minutes\\n          rebaseWindowLengthSec = 60 * 60;\\n\\n          // 10%\\n          treasuryRewardRatio = 10**17;\\n\\n          // Changed in deployment scripts to facilitate protocol initiation\\n          gov = msg.sender;\\n\\n    }\\n\\n    /**\\n    @notice Updates slippage factor\\n    @param maxSlippageFactor_ the new slippage factor\\n    *\\n    */\\n    function setMaxSlippageFactor(uint256 maxSlippageFactor_)\\n        public\\n        onlyGov\\n    {\\n        uint256 oldSlippageFactor = maxSlippageFactor;\\n        maxSlippageFactor = maxSlippageFactor_;\\n        emit NewMaxSlippageFactor(oldSlippageFactor, maxSlippageFactor_);\\n    }\\n\\n    /**\\n    @notice Updates rebase mint percentage\\n    @param rebaseMintPerc_ the new rebase mint percentage\\n    *\\n    */\\n    function setRebaseMintPerc(uint256 rebaseMintPerc_)\\n        public\\n        onlyGov\\n    {\\n        uint256 oldPerc = rebaseMintPerc;\\n        rebaseMintPerc = rebaseMintPerc_;\\n        emit NewRebaseMintPercent(oldPerc, rebaseMintPerc_);\\n    }\\n\\n\\n    /**\\n    @notice Updates reserve contract\\n    @param reservesContract_ the new reserve contract\\n    *\\n    */\\n    function setReserveContract(address reservesContract_)\\n        public\\n        onlyGov\\n    {\\n        address oldReservesContract = reservesContract;\\n        reservesContract = reservesContract_;\\n        emit NewReserveContract(oldReservesContract, reservesContract_);\\n    }\\n\\n    /** @notice sets the pendingGov\\n     * @param treasuryRewardRatio_ The treasury reward ratio of the treasury pool.\\n     */\\n    function setTreasuryRewardRatio(uint256 treasuryRewardRatio_)\\n        external\\n        onlyGov\\n    {\\n        uint256 oldTreasuryRewardRatio = treasuryRewardRatio;\\n        treasuryRewardRatio = treasuryRewardRatio_;\\n        emit NewTreasuryRewardRatio(oldTreasuryRewardRatio, treasuryRewardRatio_);\\n    }\\n    \\n    /** @notice sets the pendingGov\\n     * @param pendingGov_ The address of the rebaser contract to use for authentication.\\n     */\\n    function _setPendingGov(address pendingGov_)\\n        external\\n        onlyGov\\n    {\\n        address oldPendingGov = pendingGov;\\n        pendingGov = pendingGov_;\\n        emit NewPendingGov(oldPendingGov, pendingGov_);\\n    }\\n\\n    /** @notice lets msg.sender accept governance\\n     *\\n     */\\n    function _acceptGov()\\n        external\\n    {\\n        require(msg.sender == pendingGov, \\\"!pending\\\");\\n        address oldGov = gov;\\n        gov = pendingGov;\\n        pendingGov = address(0);\\n        emit NewGov(oldGov, gov);\\n    }\\n\\n    /** @notice Initializes TWAP start point, starts countdown to first rebase\\n    *\\n    */\\n    function init_twap()\\n        public\\n    {\\n        require(timeOfTWAPInit == 0, \\\"already activated\\\");\\n        (uint priceCumulative, uint32 blockTimestamp) =\\n           UniswapV2OracleLibrary.currentCumulativePrices(uniswap_pair, isToken0);\\n        require(blockTimestamp > 0, \\\"no trades\\\");\\n        blockTimestampLast = blockTimestamp;\\n        priceCumulativeLast = priceCumulative;\\n        timeOfTWAPInit = blockTimestamp;\\n    }\\n\\n    /** @notice Activates rebasing\\n    *   @dev One way function, cannot be undone, callable by anyone\\n    */\\n    function activate_rebasing()\\n        public\\n    {\\n        require(timeOfTWAPInit > 0, \\\"twap wasnt intitiated, call init_twap()\\\");\\n        // cannot enable prior to end of rebaseDelay\\n        require(now >= timeOfTWAPInit + rebaseDelay, \\\"!end_delay\\\");\\n\\n        rebasingActive = true;\\n    }\\n\\n    /**\\n     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\\n     *\\n     * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\\n     *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\\n     *      and targetRate is 1e18\\n     */\\n    function rebase()\\n        public\\n    {\\n        // EOA only\\n        require(msg.sender == tx.origin);\\n        // ensure rebasing at correct time\\n        _inRebaseWindow();\\n\\n        // This comparison also ensures there is no reentrancy.\\n        require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) < now);\\n\\n        // Snap the rebase time to the start of this window.\\n        lastRebaseTimestampSec = now.sub(\\n            now.mod(minRebaseTimeIntervalSec)).add(rebaseWindowOffsetSec);\\n\\n        epoch = epoch.add(1);\\n\\n        // get twap from uniswap v2;\\n        uint256 exchangeRate = getTWAP();\\n\\n        // calculates % change to supply\\n        (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate);\\n\\n        uint256 indexDelta = offPegPerc;\\n\\n        // Apply the Dampening factor.\\n        indexDelta = indexDelta.div(rebaseLag);\\n\\n        GAMERTokenInterface gamer = GAMERTokenInterface(gamerAddress);\\n\\n        if (positive) {\\n            require(gamer.gamersScalingFactor().mul(uint256(10**18).add(indexDelta)).div(10**18) < gamer.maxScalingFactor(), \\\"new scaling factor will be too big\\\");\\n        }\\n\\n\\n        uint256 currSupply = gamer.totalSupply();\\n\\n        uint256 mintAmount;\\n        // reduce indexDelta to account for minting\\n        if (positive) {\\n            uint256 mintPerc = indexDelta.mul(rebaseMintPerc).div(10**18);\\n            indexDelta = indexDelta.sub(mintPerc);\\n            mintAmount = currSupply.mul(mintPerc).div(10**18);\\n        } else if (offPegPerc > uint256(0)) {\\n            uint256 totalTreasury = IERC20(reserveToken).balanceOf(reservesContract);\\n            if (totalTreasury > 0 && treasuryRewardRatio > 0) {\\n                uint256 treasuryReward = totalTreasury.mul(treasuryRewardRatio).div(10**18);\\n                Reserves(reservesContract).distributeTreasuryReward(treasuryReward);\\n            }\\n        }\\n\\n        // rebase\\n        uint256 supplyAfterRebase = gamer.rebase(epoch, indexDelta, positive);\\n        assert(gamer.gamersScalingFactor() <= gamer.maxScalingFactor());\\n\\n        // perform actions after rebase\\n        afterRebase(mintAmount, offPegPerc);\\n    }\\n\\n\\n    function uniswapV2Call(\\n        address sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes memory data\\n    )\\n        public\\n    {\\n        // enforce that it is coming from uniswap\\n        require(msg.sender == uniswap_pair, \\\"bad msg.sender\\\");\\n        // enforce that this contract called uniswap\\n        require(sender == address(this), \\\"bad origin\\\");\\n        (UniVars memory uniVars) = abi.decode(data, (UniVars));\\n\\n        GAMERTokenInterface gamer = GAMERTokenInterface(gamerAddress);\\n\\n        if (uniVars.amountFromReserves > 0) {\\n            // transfer from reserves and mint to uniswap\\n            gamer.transferFrom(reservesContract, uniswap_pair, uniVars.amountFromReserves);\\n            if (uniVars.amountFromReserves < uniVars.gamersToUni) {\\n                // if the amount from reserves > gamersToUni, we have fully paid for the DAI tokens\\n                // thus this number would be 0 so no need to mint\\n                gamer.mint(uniswap_pair, uniVars.gamersToUni.sub(uniVars.amountFromReserves));\\n            }\\n        } else {\\n            // mint to uniswap\\n            gamer.mint(uniswap_pair, uniVars.gamersToUni);\\n        }\\n\\n        // mint unsold to mintAmount\\n        if (uniVars.mintToReserves > 0) {\\n            gamer.mint(reservesContract, uniVars.mintToReserves);\\n        }\\n\\n        // transfer reserve token to reserves\\n        if (isToken0) {\\n            SafeERC20.safeTransfer(IERC20(reserveToken), reservesContract, amount1);\\n            emit TreasuryIncreased(amount1, uniVars.gamersToUni, uniVars.amountFromReserves, uniVars.mintToReserves);\\n        } else {\\n            SafeERC20.safeTransfer(IERC20(reserveToken), reservesContract, amount0);\\n            emit TreasuryIncreased(amount0, uniVars.gamersToUni, uniVars.amountFromReserves, uniVars.mintToReserves);\\n        }\\n    }\\n\\n    function buyReserveAndTransfer(\\n        uint256 mintAmount,\\n        uint256 offPegPerc\\n    )\\n        internal\\n    {\\n        UniswapPair pair = UniswapPair(uniswap_pair);\\n\\n        GAMERTokenInterface gamer = GAMERTokenInterface(gamerAddress);\\n\\n        // get reserves\\n        (uint256 token0Reserves, uint256 token1Reserves, ) = pair.getReserves();\\n\\n        // check if protocol has excess gamer in the reserve\\n        uint256 excess = gamer.balanceOf(reservesContract);\\n\\n\\n        uint256 tokens_to_max_slippage = uniswapMaxSlippage(token0Reserves, token1Reserves, offPegPerc);\\n\\n        UniVars memory uniVars = UniVars({\\n          gamersToUni: tokens_to_max_slippage, // how many gamers uniswap needs\\n          amountFromReserves: excess, // how much of gamersToUni comes from reserves\\n          mintToReserves: 0 // how much gamers protocol mints to reserves\\n        });\\n\\n        // tries to sell all mint + excess\\n        // falls back to selling some of mint and all of excess\\n        // if all else fails, sells portion of excess\\n        // upon pair.swap, `uniswapV2Call` is called by the uniswap pair contract\\n        if (isToken0) {\\n            if (tokens_to_max_slippage > mintAmount.add(excess)) {\\n                // we already have performed a safemath check on mintAmount+excess\\n                // so we dont need to continue using it in this code path\\n\\n                // can handle selling all of reserves and mint\\n                uint256 buyTokens = getAmountOut(mintAmount + excess, token0Reserves, token1Reserves);\\n                uniVars.gamersToUni = mintAmount + excess;\\n                uniVars.amountFromReserves = excess;\\n                // call swap using entire mint amount and excess; mint 0 to reserves\\n                pair.swap(0, buyTokens, address(this), abi.encode(uniVars));\\n            } else {\\n                if (tokens_to_max_slippage > excess) {\\n                    // uniswap can handle entire reserves\\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token0Reserves, token1Reserves);\\n\\n                    // swap up to slippage limit, taking entire gamer reserves, and minting part of total\\n                    uniVars.mintToReserves = mintAmount.sub((tokens_to_max_slippage - excess));\\n                    pair.swap(0, buyTokens, address(this), abi.encode(uniVars));\\n                } else {\\n                    // uniswap cant handle all of excess\\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token0Reserves, token1Reserves);\\n                    uniVars.amountFromReserves = tokens_to_max_slippage;\\n                    uniVars.mintToReserves = mintAmount;\\n                    // swap up to slippage limit, taking excess - remainingExcess from reserves, and minting full amount\\n                    // to reserves\\n                    pair.swap(0, buyTokens, address(this), abi.encode(uniVars));\\n                }\\n            }\\n        } else {\\n            if (tokens_to_max_slippage > mintAmount.add(excess)) {\\n                // can handle all of reserves and mint\\n                uint256 buyTokens = getAmountOut(mintAmount + excess, token1Reserves, token0Reserves);\\n                uniVars.gamersToUni = mintAmount + excess;\\n                uniVars.amountFromReserves = excess;\\n                // call swap using entire mint amount and excess; mint 0 to reserves\\n                pair.swap(buyTokens, 0, address(this), abi.encode(uniVars));\\n            } else {\\n                if (tokens_to_max_slippage > excess) {\\n                    // uniswap can handle entire reserves\\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token1Reserves, token0Reserves);\\n\\n                    // swap up to slippage limit, taking entire gamer reserves, and minting part of total\\n                    uniVars.mintToReserves = mintAmount.sub((tokens_to_max_slippage - excess));\\n                    // swap up to slippage limit, taking entire gamer reserves, and minting part of total\\n                    pair.swap(buyTokens, 0, address(this), abi.encode(uniVars));\\n                } else {\\n                    // uniswap cant handle all of excess\\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token1Reserves, token0Reserves);\\n                    uniVars.amountFromReserves = tokens_to_max_slippage;\\n                    uniVars.mintToReserves = mintAmount;\\n                    // swap up to slippage limit, taking excess - remainingExcess from reserves, and minting full amount\\n                    // to reserves\\n                    pair.swap(buyTokens, 0, address(this), abi.encode(uniVars));\\n                }\\n            }\\n        }\\n    }\\n\\n    function uniswapMaxSlippage(\\n        uint256 token0,\\n        uint256 token1,\\n        uint256 offPegPerc\\n    )\\n      internal\\n      view\\n      returns (uint256)\\n    {\\n        if (isToken0) {\\n          if (offPegPerc >= 10**17) {\\n              // cap slippage\\n              return token0.mul(maxSlippageFactor).div(10**18);\\n          } else {\\n              // in the 5-10% off peg range, slippage is essentially 2*x (where x is percentage of pool to buy).\\n              // all we care about is not pushing below the peg, so underestimate\\n              // the amount we can sell by dividing by 3. resulting price impact\\n              // should be ~= offPegPerc * 2 / 3, which will keep us above the peg\\n              //\\n              // this is a conservative heuristic\\n              return token0.mul(offPegPerc / 3).div(10**18);\\n          }\\n        } else {\\n            if (offPegPerc >= 10**17) {\\n                return token1.mul(maxSlippageFactor).div(10**18);\\n            } else {\\n                return token1.mul(offPegPerc / 3).div(10**18);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n     *\\n     * @param amountIn input amount of the asset\\n     * @param reserveIn reserves of the asset being sold\\n     * @param reserveOut reserves if the asset being purchased\\n     */\\n\\n   function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn,\\n        uint reserveOut\\n    )\\n        internal\\n        pure\\n        returns (uint amountOut)\\n    {\\n       require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\n       require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n       uint amountInWithFee = amountIn.mul(997);\\n       uint numerator = amountInWithFee.mul(reserveOut);\\n       uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n       amountOut = numerator / denominator;\\n   }\\n\\n\\n    function afterRebase(\\n        uint256 mintAmount,\\n        uint256 offPegPerc\\n    )\\n        internal\\n    {\\n        // update uniswap\\n        UniswapPair(uniswap_pair).sync();\\n\\n        if (mintAmount > 0) {\\n            buyReserveAndTransfer(\\n                mintAmount,\\n                offPegPerc\\n            );\\n        }\\n\\n        // call any extra functions\\n        for (uint i = 0; i < transactions.length; i++) {\\n            Transaction storage t = transactions[i];\\n            if (t.enabled) {\\n                bool result =\\n                    externalCall(t.destination, t.data);\\n                if (!result) {\\n                    emit TransactionFailed(t.destination, i, t.data);\\n                    revert(\\\"Transaction Failed\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    /**\\n     * @notice Calculates TWAP from uniswap\\n     *\\n     * @dev When liquidity is low, this can be manipulated by an end of block -> next block\\n     *      attack. We delay the activation of rebases 12 hours after liquidity incentives\\n     *      to reduce this attack vector. Additional there is very little supply\\n     *      to be able to manipulate this during that time period of highest vuln.\\n     */\\n    function getTWAP()\\n        internal\\n        returns (uint256)\\n    {\\n      (uint priceCumulative, uint32 blockTimestamp) =\\n         UniswapV2OracleLibrary.currentCumulativePrices(uniswap_pair, isToken0);\\n       uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n\\n       // no period check as is done in isRebaseWindow\\n\\n       // overflow is desired, casting never truncates\\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\\n\\n        priceCumulativeLast = priceCumulative;\\n        blockTimestampLast = blockTimestamp;\\n\\n        return FixedPoint.decode144(FixedPoint.mul(priceAverage, 10**18));\\n    }\\n\\n    /**\\n     * @notice Calculates current TWAP from uniswap\\n     *\\n     */\\n    function getCurrentTWAP()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n      (uint priceCumulative, uint32 blockTimestamp) =\\n         UniswapV2OracleLibrary.currentCumulativePrices(uniswap_pair, isToken0);\\n       uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n\\n       // no period check as is done in isRebaseWindow\\n\\n       // overflow is desired, casting never truncates\\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\\n\\n        return FixedPoint.decode144(FixedPoint.mul(priceAverage, 10**18));\\n    }\\n\\n    /**\\n     * @notice Sets the deviation threshold fraction. If the exchange rate given by the market\\n     *         oracle is within this fractional distance from the targetRate, then no supply\\n     *         modifications are made.\\n     * @param deviationThreshold_ The new exchange rate threshold fraction.\\n     */\\n    function setDeviationThreshold(uint256 deviationThreshold_)\\n        external\\n        onlyGov\\n    {\\n        require(deviationThreshold > 0);\\n        uint256 oldDeviationThreshold = deviationThreshold;\\n        deviationThreshold = deviationThreshold_;\\n        emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\\n    }\\n\\n    /**\\n     * @notice Sets the rebase lag parameter.\\n               It is used to dampen the applied supply adjustment by 1 / rebaseLag\\n               If the rebase lag R, equals 1, the smallest value for R, then the full supply\\n               correction is applied on each rebase cycle.\\n               If it is greater than 1, then a correction of 1/R of is applied on each rebase.\\n     * @param rebaseLag_ The new rebase lag parameter.\\n     */\\n    function setRebaseLag(uint256 rebaseLag_)\\n        external\\n        onlyGov\\n    {\\n        require(rebaseLag_ > 0);\\n        rebaseLag = rebaseLag_;\\n    }\\n\\n    /**\\n     * @notice Sets the targetRate parameter.\\n     * @param targetRate_ The new target rate parameter.\\n     */\\n    function setTargetRate(uint256 targetRate_)\\n        external\\n        onlyGov\\n    {\\n        require(targetRate_ > 0);\\n        targetRate = targetRate_;\\n    }\\n\\n    /**\\n     * @notice Sets the parameters which control the timing and frequency of\\n     *         rebase operations.\\n     *         a) the minimum time period that must elapse between rebase cycles.\\n     *         b) the rebase window offset parameter.\\n     *         c) the rebase window length parameter.\\n     * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\\n     *        operations, in seconds.\\n     * @param rebaseWindowOffsetSec_ The number of seconds from the beginning of\\n              the rebase interval, where the rebase window begins.\\n     * @param rebaseWindowLengthSec_ The length of the rebase window in seconds.\\n     */\\n    function setRebaseTimingParameters(\\n        uint256 minRebaseTimeIntervalSec_,\\n        uint256 rebaseWindowOffsetSec_,\\n        uint256 rebaseWindowLengthSec_)\\n        external\\n        onlyGov\\n    {\\n        require(minRebaseTimeIntervalSec_ > 0);\\n        require(rebaseWindowOffsetSec_ < minRebaseTimeIntervalSec_);\\n\\n        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\\n        rebaseWindowOffsetSec = rebaseWindowOffsetSec_;\\n        rebaseWindowLengthSec = rebaseWindowLengthSec_;\\n    }\\n\\n    /**\\n     * @return If the latest block timestamp is within the rebase time window it, returns true.\\n     *         Otherwise, returns false.\\n     */\\n    function inRebaseWindow() public view returns (bool) {\\n\\n        // rebasing is delayed until there is a liquid market\\n        _inRebaseWindow();\\n        return true;\\n    }\\n\\n    function _inRebaseWindow() internal view {\\n\\n        // rebasing is delayed until there is a liquid market\\n        require(rebasingActive, \\\"rebasing not active\\\");\\n\\n        require(now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec, \\\"too early\\\");\\n        require(now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)), \\\"too late\\\");\\n    }\\n\\n    /**\\n     * @return Computes in % how far off market is from peg\\n     */\\n    function computeOffPegPerc(uint256 rate)\\n        private\\n        view\\n        returns (uint256, bool)\\n    {\\n        if (withinDeviationThreshold(rate)) {\\n            return (0, false);\\n        }\\n\\n        // indexDelta =  (rate - targetRate) / targetRate\\n        if (rate > targetRate) {\\n            return (rate.sub(targetRate).mul(10**18).div(targetRate), true);\\n        } else {\\n            return (targetRate.sub(rate).mul(10**18).div(targetRate), false);\\n        }\\n    }\\n\\n    /**\\n     * @param rate The current exchange rate, an 18 decimal fixed point number.\\n     * @return If the rate is within the deviation threshold from the target rate, returns true.\\n     *         Otherwise, returns false.\\n     */\\n    function withinDeviationThreshold(uint256 rate)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold)\\n            .div(10 ** 18);\\n\\n        return (rate >= targetRate && rate.sub(targetRate) < absoluteDeviationThreshold)\\n            || (rate < targetRate && targetRate.sub(rate) < absoluteDeviationThreshold);\\n    }\\n\\n    /* - Constructor Helpers - */\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address factory,\\n        address token0,\\n        address token1\\n    )\\n        internal\\n        pure\\n        returns (address pair)\\n    {\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n            ))));\\n    }\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(\\n        address tokenA,\\n        address tokenB\\n    )\\n        internal\\n        pure\\n        returns (address token0, address token1)\\n    {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    /* -- Rebase helpers -- */\\n\\n    /**\\n     * @notice Adds a transaction that gets called for a downstream receiver of rebases\\n     * @param destination Address of contract destination\\n     * @param data Transaction data payload\\n     */\\n    function addTransaction(address destination, bytes calldata data)\\n        external\\n        onlyGov\\n    {\\n        transactions.push(Transaction({\\n            enabled: true,\\n            destination: destination,\\n            data: data\\n        }));\\n    }\\n\\n\\n    /**\\n     * @param index Index of transaction to remove.\\n     *              Transaction ordering may have changed since adding.\\n     */\\n    function removeTransaction(uint index)\\n        external\\n        onlyGov\\n    {\\n        require(index < transactions.length, \\\"index out of bounds\\\");\\n\\n        if (index < transactions.length - 1) {\\n            transactions[index] = transactions[transactions.length - 1];\\n        }\\n\\n        transactions.length--;\\n    }\\n\\n    /**\\n     * @param index Index of transaction. Transaction ordering may have changed since adding.\\n     * @param enabled True for enabled, false for disabled.\\n     */\\n    function setTransactionEnabled(uint index, bool enabled)\\n        external\\n        onlyGov\\n    {\\n        require(index < transactions.length, \\\"index must be in range of stored tx list\\\");\\n        transactions[index].enabled = enabled;\\n    }\\n\\n    /**\\n     * @dev wrapper to call the encoded transactions on downstream consumers.\\n     * @param destination Address of destination contract.\\n     * @param data The encoded data payload.\\n     * @return True on success\\n     */\\n    function externalCall(address destination, bytes memory data)\\n        internal\\n        returns (bool)\\n    {\\n        bool result;\\n        assembly {  // solhint-disable-line no-inline-assembly\\n            // \\\"Allocate\\\" memory for output\\n            // (0x40 is where \\\"free memory\\\" pointer is stored by convention)\\n            let outputAddress := mload(0x40)\\n\\n            // First 32 bytes are the padded length of data, so exclude that\\n            let dataAddress := add(data, 32)\\n\\n            result := call(\\n                // 34710 is the value that solidity is currently emitting\\n                // It includes callGas (700) + callVeryLow (3, to pay for SUB)\\n                // + callValueTransferGas (9000) + callNewAccountGas\\n                // (25000, in case the destination address does not exist and needs creating)\\n                sub(gas, 34710),\\n\\n\\n                destination,\\n                0, // transfer value in wei\\n                dataAddress,\\n                mload(data),  // Size of the input, in bytes. Stored in position 0 of the array.\\n                outputAddress,\\n                0  // Output is ignored, therefore the output size is zero\\n            )\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/lib/SafeERC20.sol\": {\r\n      \"keccak256\": \"0x00c7887d6e2af7d5971473efbd93d312374d6e8478a6f435d7ec3b62fe62a523\",\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.17;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/reserves/GAMERReserves.sol\": {\r\n      \"keccak256\": \"0x9734298f8b9cb24f8bf5950d0d24a8cda5d9d2a3575f63062f685b05797429c3\",\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"../lib/IERC20.sol\\\";\\nimport \\\"../lib/SafeERC20.sol\\\";\\nimport \\\"../token/GAMERTokenInterface.sol\\\";\\n\\ninterface TreasuryPool {\\n    function updateNextRewards(uint256 amount) external;\\n}\\n\\ncontract GAMERReserves {\\n\\n    // Token that serves as a reserve for GAMER\\n    address public reserveToken;\\n\\n    address public gov;\\n\\n    address public pendingGov;\\n\\n    address public rebaser;\\n\\n    address public gamerAddress;\\n\\n    address public treasuryPool;\\n\\n    /*** Gov Events ***/\\n\\n    /**\\n     * @notice Event emitted when pendingGov is changed\\n     */\\n    event NewPendingGov(address oldPendingGov, address newPendingGov);\\n\\n    /**\\n     * @notice Event emitted when gov is changed\\n     */\\n    event NewGov(address oldGov, address newGov);\\n\\n    /**\\n     * @notice Event emitted when TreasuryPool is changed\\n     */\\n    event NewTreasuryPool(address oldTreasuryPool, address newTreasuryPool);\\n\\n    /**\\n     * @notice Event emitted when rebaser is changed\\n     */\\n    event NewRebaser(address oldRebaser, address newRebaser);\\n\\n\\n    modifier onlyGov() {\\n        require(msg.sender == gov);\\n        _;\\n    }\\n\\n    modifier onlyRebaser() {\\n        require(msg.sender == rebaser);\\n        _;\\n    }\\n\\n    constructor(\\n        address reserveToken_,\\n        address gamerAddress_\\n    )\\n        public\\n    {\\n        reserveToken = reserveToken_;\\n        gamerAddress = gamerAddress_;\\n        gov = msg.sender;\\n    }\\n\\n    function _setRebaser(address rebaser_)\\n        external\\n        onlyGov\\n    {\\n        address oldRebaser = rebaser;\\n        GAMERTokenInterface(gamerAddress).decreaseAllowance(oldRebaser, uint256(-1));\\n        rebaser = rebaser_;\\n        GAMERTokenInterface(gamerAddress).approve(rebaser_, uint256(-1));\\n        emit NewRebaser(oldRebaser, rebaser_);\\n    }\\n\\n    /** @notice sets the pendingGov\\n     * @param pendingGov_ The address of the rebaser contract to use for authentication.\\n     */\\n    function _setPendingGov(address pendingGov_)\\n        external\\n        onlyGov\\n    {\\n        address oldPendingGov = pendingGov;\\n        pendingGov = pendingGov_;\\n        emit NewPendingGov(oldPendingGov, pendingGov_);\\n    }\\n\\n    /**\\n     * @notice lets msg.sender accept governance\\n     */\\n    function _acceptGov()\\n        external\\n    {\\n        require(msg.sender == pendingGov, \\\"!pending\\\");\\n        address oldGov = gov;\\n        gov = pendingGov;\\n        pendingGov = address(0);\\n        emit NewGov(oldGov, gov);\\n    }\\n\\n    /** @notice sets the treasuryPool\\n     * @param treasuryPool_ The address of the treasury pool contract.\\n     */\\n    function _setTreasuryPool(address treasuryPool_)\\n        external\\n        onlyGov\\n    {\\n        address oldTreasuryPool = treasuryPool;\\n        treasuryPool = treasuryPool_;\\n        emit NewTreasuryPool(oldTreasuryPool, treasuryPool_);\\n    }\\n\\n    /// @notice Moves all tokens to a new reserve contract\\n    function migrateReserves(\\n        address newReserve,\\n        address[] memory tokens\\n    )\\n        public\\n        onlyGov\\n    {\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            IERC20 token =  IERC20(tokens[i]);\\n            uint256 bal = token.balanceOf(address(this));\\n            SafeERC20.safeTransfer(token, newReserve, bal);\\n        }\\n    }\\n\\n    /// @notice Gets the current amount of reserves token held by this contract\\n    function reserves()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return IERC20(reserveToken).balanceOf(address(this));\\n    }\\n\\n        /// @notice Gets the current amount of reserves token held by this contract\\n    function distributeTreasuryReward(uint256 amount)\\n        public\\n        onlyRebaser\\n    {\\n        IERC20(reserveToken).transfer(treasuryPool, amount);\\n        TreasuryPool(treasuryPool).updateNextRewards(amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/token/GAMERTokenInterface.sol\": {\r\n      \"keccak256\": \"0x8e3184d2846846b29d5c622e2bbb0d2882e57adba6bec636346bcfeb77fcc5f1\",\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"./GAMERTokenStorage.sol\\\";\\nimport \\\"./GAMERGovernanceStorage.sol\\\";\\n\\ncontract GAMERTokenInterface is GAMERTokenStorage, GAMERGovernanceStorage {\\n\\n    /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /**\\n     * @notice Event emitted when tokens are rebased\\n     */\\n    event Rebase(uint256 epoch, uint256 prevGrapsScalingFactor, uint256 newGrapsScalingFactor);\\n\\n    /*** Gov Events ***/\\n\\n    /**\\n     * @notice Event emitted when pendingGov is changed\\n     */\\n    event NewPendingGov(address oldPendingGov, address newPendingGov);\\n\\n    /**\\n     * @notice Event emitted when gov is changed\\n     */\\n    event NewGov(address oldGov, address newGov);\\n\\n    /**\\n     * @notice Sets the rebaser contract\\n     */\\n    event NewRebaser(address oldRebaser, address newRebaser);\\n\\n    /**\\n     * @notice Sets the incentivizer contract\\n     */\\n    event NewIncentivizer(address oldIncentivizer, address newIncentivizer);\\n\\n    /**\\n     * @notice Sets the StakingPool contract\\n     */\\n    event NewStakingPool(address oldStakingPool, address newStakingPool);\\n\\n    /**\\n     * @notice Sets the TeamPool contract\\n     */\\n    event NewTeamPool(address oldTeamPool, address newTeamPool);\\n\\n    /**\\n     * @notice Sets the Dev contract\\n     */\\n    event NewDev(address oldDev, address newDev);\\n\\n    /* - ERC20 Events - */\\n\\n    /**\\n     * @notice EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n\\n    /**\\n     * @notice EIP20 Approval event\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n\\n    /* - Extra Events - */\\n    /**\\n     * @notice Tokens minted event\\n     */\\n    event Mint(address to, uint256 amount);\\n\\n    // Public functions\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns(bool);\\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\\n    function balanceOf(address who) external view returns(uint256);\\n    function balanceOfUnderlying(address who) external view returns(uint256);\\n    function allowance(address owner_, address spender) external view returns(uint256);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n    function maxScalingFactor() external view returns (uint256);\\n\\n    /* - Governance Functions - */\\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint256);\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\\n    function delegate(address delegatee) external;\\n    function delegates(address delegator) external view returns (address);\\n    function getCurrentVotes(address account) external view returns (uint256);\\n\\n    /* - Permissioned/Governance functions - */\\n    function mint(address to, uint256 amount) external returns (bool);\\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\\n    function _setRebaser(address rebaser_) external;\\n    function _setIncentivizer(address incentivizer_) external;\\n    function _setPendingGov(address pendingGov_) external;\\n    function _acceptGov() external;\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/token/GAMERGovernance.sol\": {\r\n      \"keccak256\": \"0x84add3c80d2f4b8d8844cabd8345ccff1a09cb225c197f3c464e5435c50b9a8c\",\r\n      \"content\": \"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./GAMERGovernanceStorage.sol\\\";\\nimport \\\"./GAMERTokenInterface.sol\\\";\\n\\ncontract GAMERGovernanceToken is GAMERTokenInterface {\\n\\n      /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegator The address to get delegatee for\\n     */\\n    function delegates(address delegator)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return _delegates[delegator];\\n    }\\n\\n   /**\\n    * @notice Delegate votes from `msg.sender` to `delegatee`\\n    * @param delegatee The address to delegate votes to\\n    */\\n    function delegate(address delegatee) external {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint nonce,\\n        uint expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n    {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                getChainId(),\\n                address(this)\\n            )\\n        );\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                DELEGATION_TYPEHASH,\\n                delegatee,\\n                nonce,\\n                expiry\\n            )\\n        );\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                domainSeparator,\\n                structHash\\n            )\\n        );\\n\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"GAMER::delegateBySig: invalid signature\\\");\\n        require(nonce == nonces[signatory]++, \\\"GAMER::delegateBySig: invalid nonce\\\");\\n        require(now <= expiry, \\\"GAMER::delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        require(blockNumber < block.number, \\\"GAMER::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    function _delegate(address delegator, address delegatee)\\n        internal\\n    {\\n        address currentDelegate = _delegates[delegator];\\n        uint256 delegatorBalance = _gamerBalances[delegator]; // balance of underlying GAMERs (not scaled);\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                // decrease old representative\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint256 srcRepNew = srcRepOld.sub(amount);\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                // increase new representative\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint256 dstRepNew = dstRepOld.add(amount);\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint32 nCheckpoints,\\n        uint256 oldVotes,\\n        uint256 newVotes\\n    )\\n        internal\\n    {\\n        uint32 blockNumber = safe32(block.number, \\\"GAMER::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n        } else {\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint256 chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/token/GAMERGovernanceStorage.sol\": {\r\n      \"keccak256\": \"0x6f165110763878776ada3d323b310c90ebda361db5a6d20096295b12831c1db9\",\r\n      \"content\": \"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\ncontract GAMERGovernanceStorage {\\n    /// @notice A record of each accounts delegate\\n    mapping (address => address) internal _delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint256 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping (address => uint) public nonces;\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/token/GAMERTokenStorage.sol\": {\r\n      \"keccak256\": \"0xb13c52f0e81bd4e9d279b4ba8c81bdf7a7ca144273c76a4fc692ae75876d08b8\",\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"../lib/SafeMath.sol\\\";\\n\\n// Storage for a GAMER token\\ncontract GAMERTokenStorage {\\n\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Guard variable for re-entrancy checks. Not currently used\\n     */\\n    bool internal _notEntered;\\n\\n    /**\\n     * @notice EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n     * @notice Governor for this contract\\n     */\\n    address public gov;\\n\\n    /**\\n     * @notice Pending governance for this contract\\n     */\\n    address public pendingGov;\\n\\n    /**\\n     * @notice Approved rebaser for this contract\\n     */\\n    address public rebaser;\\n\\n    /**\\n     * @notice Reserve address of GAMER protocol\\n     */\\n    address public incentivizer;\\n\\n    /**\\n     * @notice stakingPool address of GAMER protocol\\n     */\\n    address public stakingPool;\\n\\n    /**\\n     * @notice teamPool address of GAMER protocol\\n     */\\n    address public teamPool;\\n\\n    /**\\n     * @notice dev address of GAMER protocol\\n     */\\n    address public dev;\\n\\n    /**\\n     * @notice Total supply of GAMERs\\n     */\\n    uint256 internal _totalSupply;\\n\\n    /**\\n     * @notice Internal decimals used to handle scaling factor\\n     */\\n    uint256 public constant internalDecimals = 10**24;\\n\\n    /**\\n     * @notice Used for percentage maths\\n     */\\n    uint256 public constant BASE = 10**18;\\n\\n    /**\\n     * @notice Scaling factor that adjusts everyone's balances\\n     */\\n    uint256 public gamersScalingFactor;\\n\\n    mapping (address => uint256) internal _gamerBalances;\\n\\n    mapping (address => mapping (address => uint256)) internal _allowedFragments;\\n\\n    uint256 public initSupply;\\n\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/lib/FixedPoint.sol\": {\r\n      \"keccak256\": \"0x589aacdc69a24cc0500bc13581b34d4431ee972333fa288a9b42a4d14707e003\",\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.4.0;\\n\\nimport './Babylonian.sol';\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint private constant Q112 = uint(1) << RESOLUTION;\\n    uint private constant Q224 = Q112 << RESOLUTION;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // take the reciprocal of a UQ112x112\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\\n        return uq112x112(uint224(Q224 / self._x));\\n    }\\n\\n    // square root of a UQ112x112\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/qijunlin/MyWorkSpace/SolidityWorkSpace/gamer_truffle/contracts/lib/Babylonian.sol\": {\r\n      \"keccak256\": \"0xad37a774ad6a438432acb1a475b71b2991a41ba98f1cd814c6d78f9109370a38\",\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.4.0;\\n\\n// computes square roots using the babylonian method\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\nlibrary Babylonian {\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n        // else z = 0\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gamerAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reserveToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswap_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reservesContract_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDeviationThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeviationThreshold\",\"type\":\"uint256\"}],\"name\":\"NewDeviationThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGov\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGov\",\"type\":\"address\"}],\"name\":\"NewGov\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSlippageFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSlippageFactor\",\"type\":\"uint256\"}],\"name\":\"NewMaxSlippageFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingGov\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingGov\",\"type\":\"address\"}],\"name\":\"NewPendingGov\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRebaseMintPerc\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRebaseMintPerc\",\"type\":\"uint256\"}],\"name\":\"NewRebaseMintPercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldReserveContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReserveContract\",\"type\":\"address\"}],\"name\":\"NewReserveContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTreasuryRewardRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTreasuryRewardRatio\",\"type\":\"uint256\"}],\"name\":\"NewTreasuryRewardRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"TransactionFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservesAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gamersSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gamersFromReserves\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gamersToReserves\",\"type\":\"uint256\"}],\"name\":\"TreasuryIncreased\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptGov\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingGov_\",\"type\":\"address\"}],\"name\":\"_setPendingGov\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate_rebasing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"addTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockTimestampLast\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deviationThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTWAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inRebaseWindow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"init_twap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isToken0\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRebaseTimestampSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSlippageFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minRebaseTimeIntervalSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingGov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceCumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebaseDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebaseLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebaseMintPerc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebaseWindowLengthSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebaseWindowOffsetSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebasingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservesContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deviationThreshold_\",\"type\":\"uint256\"}],\"name\":\"setDeviationThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxSlippageFactor_\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippageFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rebaseLag_\",\"type\":\"uint256\"}],\"name\":\"setRebaseLag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rebaseMintPerc_\",\"type\":\"uint256\"}],\"name\":\"setRebaseMintPerc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minRebaseTimeIntervalSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebaseWindowOffsetSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebaseWindowLengthSec_\",\"type\":\"uint256\"}],\"name\":\"setRebaseTimingParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"reservesContract_\",\"type\":\"address\"}],\"name\":\"setReserveContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetRate_\",\"type\":\"uint256\"}],\"name\":\"setTargetRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setTransactionEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treasuryRewardRatio_\",\"type\":\"uint256\"}],\"name\":\"setTreasuryRewardRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeOfTWAPInit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasuryRewardRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswap_pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GAMERRebaser","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"50000","ConstructorArguments":"00000000000000000000000036f697f791a0c91d6f1bb166767d5d2d701b1d820000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f0000000000000000000000004533e685fe1441b09ff7d45397f8d777cef61561","EVMVersion":"istanbul","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f9de1938733ad92ccf443ea9510e0c1c9039e804eeac341b9a3f871f9539bab0"}]}