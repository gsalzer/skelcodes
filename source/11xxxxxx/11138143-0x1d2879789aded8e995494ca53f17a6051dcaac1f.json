{"status":"1","message":"OK","result":[{"SourceCode":"{\"Dex.sol\":{\"content\":\"pragma solidity ^0.4.18;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n// ----------------------------------------------------------------------------------------------\\r\\n// Sample fixed supply token contract\\r\\n// Enjoy. (c) BokkyPooBah 2017. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------------------------\\r\\n\\r\\nimport \\u0027./ERC20Interface.sol\\u0027;\\r\\n\\r\\ncontract TokenSale {\\r\\n    \\r\\n    uint256 fee = 0.01 ether;\\r\\n    \\r\\n    uint256 symbolNameIndex;\\r\\n    \\r\\n    uint256 historyIndex;\\r\\n    \\r\\n    //it will divide on 1000\\r\\n    uint256 siteShareRatio = 1;\\r\\n    \\r\\n    address manager;\\r\\n    \\r\\n    enum State {Waiting , Selling , Ended , Checkedout}\\r\\n\\r\\n    mapping (uint256 =\\u003e uint) tokenBalanceForAddress;\\r\\n\\r\\n    mapping (address =\\u003e uint256) refAccount;\\r\\n\\r\\n    mapping (address =\\u003e mapping(uint256 =\\u003e uint)) balanceEthForAddress;\\r\\n    \\r\\n    mapping (uint256 =\\u003e Token) tokens;\\r\\n\\r\\n    struct Token {\\r\\n        address tokenContract;\\r\\n        address owner;\\r\\n        string symbolName;\\r\\n        string symbol;\\r\\n        string link;\\r\\n        uint256 amount;\\r\\n        uint256 leftover;\\r\\n        uint256 priceInWie;\\r\\n        uint256 deadline;\\r\\n        uint decimals;\\r\\n        State state;\\r\\n        uint256 referral;\\r\\n    }\\r\\n    \\r\\n    mapping (uint256 =\\u003e History) histories;\\r\\n    \\r\\n    mapping (uint256 =\\u003e uint256) saleCount;\\r\\n    \\r\\n    struct History{\\r\\n        address owner;\\r\\n        string title;\\r\\n        uint256 amount;\\r\\n        uint256 decimals;\\r\\n        uint256 time;\\r\\n        string symbol;\\r\\n    }\\r\\n    \\r\\n    function TokenSale() public{\\r\\n        manager = msg.sender;\\r\\n    }\\r\\n\\r\\n    ///////////////////////\\r\\n    // TOKEN MANAGEMENT //\\r\\n    //////////////////////\\r\\n\\r\\n    function addToken(address erc20TokenAddress , string symbolName , string symbol , string link , uint256 priceInWie , uint decimals , uint256 referral , uint256 _amount) public payable {\\r\\n        require(!hasToken(erc20TokenAddress) , \\u0027Token Is Already Added\\u0027);\\r\\n        require(msg.value == fee , \\u0027Add Token Fee Is Invalid\\u0027);\\r\\n        require(referral \\u003e= 0 \\u0026\\u0026 referral \\u003c= 100);\\r\\n        \\r\\n        manager.transfer(msg.value);\\r\\n\\r\\n        uint256 index = getSymbolIndexByAddress(erc20TokenAddress);\\r\\n        uint256 _arrayIndex = 0;\\r\\n        \\r\\n        if(index != 0 \\u0026\\u0026 (!checkDeadLine(tokens[index]) || tokens[index].leftover == 0)){\\r\\n            require(tokens[index].state == State.Checkedout);\\r\\n            require(tokens[index].owner == msg.sender);\\r\\n            _arrayIndex = index;\\r\\n        }\\r\\n        else{\\r\\n            symbolNameIndex++;\\r\\n            _arrayIndex = symbolNameIndex;\\r\\n        }\\r\\n        \\r\\n        tokens[_arrayIndex].symbolName = symbolName;\\r\\n        tokens[_arrayIndex].tokenContract = erc20TokenAddress;\\r\\n        tokens[_arrayIndex].symbol = symbol;\\r\\n        tokens[_arrayIndex].link = link;\\r\\n        tokens[_arrayIndex].amount = _amount;\\r\\n        tokens[_arrayIndex].deadline = now;\\r\\n        tokens[_arrayIndex].leftover = 0;\\r\\n        tokens[_arrayIndex].state = State.Waiting;\\r\\n        tokens[_arrayIndex].priceInWie = priceInWie;\\r\\n        tokens[_arrayIndex].decimals = decimals;\\r\\n        tokens[_arrayIndex].referral = referral;\\r\\n        tokens[_arrayIndex].owner = msg.sender;\\r\\n        \\r\\n        setHistory(msg.sender , fee , \\u0027Fee For Add Token\\u0027 , \\u0027ETH\\u0027 , 18);\\r\\n        setHistory(manager , fee , \\u0027(Manager) Fee For Add Token\\u0027 , \\u0027ETH\\u0027 , 18);\\r\\n        \\r\\n    }\\r\\n\\r\\n    function hasToken(address erc20TokenAddress) public constant returns (bool) {\\r\\n        uint256 index = getSymbolIndexByAddress(erc20TokenAddress);\\r\\n\\r\\n        if (index == 0) {\\r\\n            return false;\\r\\n        }        \\r\\n        else if(!checkDeadLine(tokens[index]) || tokens[index].leftover == 0){\\r\\n            return false;\\r\\n        }\\r\\n        else\\r\\n            return true;\\r\\n    }\\r\\n\\r\\n    function getSymbolIndexByAddress(address erc20TokenAddress) internal returns (uint256) {\\r\\n        for (uint256 i = 1; i \\u003c= symbolNameIndex; i++) {\\r\\n            if (tokens[i].tokenContract == erc20TokenAddress) {\\r\\n                return i;\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    function getSymbolIndexByAddressOrThrow(address erc20TokenAddress) returns (uint256) {\\r\\n        uint256 index = getSymbolIndexByAddress(erc20TokenAddress);\\r\\n        require(index \\u003e 0);\\r\\n        return index;\\r\\n    }\\r\\n    \\r\\n    function getAllDex() public view returns(address[] memory , string[] memory , uint256[] memory , uint[] memory , uint256[] memory , string[] memory){\\r\\n        \\r\\n        address[] memory tokenAdderss = new address[](symbolNameIndex+1);\\r\\n        string[] memory tokenName = new string[](symbolNameIndex+1);\\r\\n        string[] memory tokenLink = new string[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenPrice = new uint256[](symbolNameIndex+1);\\r\\n        uint[] memory decimal = new uint256[](symbolNameIndex+1);\\r\\n        uint256[] memory leftover = new uint256[](symbolNameIndex+1);\\r\\n\\r\\n\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c= symbolNameIndex; i++) {\\r\\n            if(checkDeadLine(tokens[i]) \\u0026\\u0026 tokens[i].leftover != 0){\\r\\n                tokenAdderss[i] = tokens[i].tokenContract;\\r\\n                tokenName[i] = tokens[i].symbol;\\r\\n                tokenLink[i] = tokens[i].link;\\r\\n                tokenPrice[i] = tokens[i].priceInWie;\\r\\n                decimal[i] = tokens[i].decimals;\\r\\n                leftover[i] = tokens[i].leftover;\\r\\n            }\\r\\n        }\\r\\n        return (tokenAdderss , tokenName , tokenPrice , decimal , leftover , tokenLink);\\r\\n    }\\r\\n    \\r\\n    function getInitTokenInfo(address erc20TokenAddress) public returns(uint256  , uint256  , uint ){\\r\\n        uint256 _symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        Token token = tokens[_symbolNameIndex];\\r\\n        return (token.amount , token.priceInWie , token.decimals);\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////\\r\\n    // DEPOSIT / WITHDRAWAL TOKEN //\\r\\n    ////////////////////////////////\\r\\n    \\r\\n    function depositToken(address erc20TokenAddress, uint256 amountTokens , uint256 deadline) public payable {\\r\\n        uint256 _symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        require(tokens[_symbolNameIndex].tokenContract != address(0) , \\u0027Token is Invalid\\u0027);\\r\\n        require(tokens[_symbolNameIndex].state == State.Waiting , \\u0027Token Cannot be deposited\\u0027);\\r\\n        require(tokens[_symbolNameIndex].owner == msg.sender , \\u0027You are not owner of this coin\\u0027);\\r\\n\\r\\n        ERC20Interface token = ERC20Interface(tokens[_symbolNameIndex].tokenContract);\\r\\n        \\r\\n        require(token.transferFrom(msg.sender, address(this), amountTokens) == true);\\r\\n        \\r\\n        tokens[_symbolNameIndex].amount = amountTokens;\\r\\n        tokens[_symbolNameIndex].leftover = amountTokens;\\r\\n        \\r\\n        require(tokenBalanceForAddress[_symbolNameIndex] + amountTokens \\u003e= tokenBalanceForAddress[_symbolNameIndex]);\\r\\n        tokenBalanceForAddress[_symbolNameIndex] += amountTokens;\\r\\n        tokens[_symbolNameIndex].state = State.Selling;\\r\\n        tokens[_symbolNameIndex].deadline = deadline;\\r\\n        \\r\\n        Token tokenRes = tokens[_symbolNameIndex];\\r\\n        \\r\\n        setHistory(msg.sender , amountTokens , \\u0027Deposit Token\\u0027 , tokenRes.symbol , tokenRes.decimals);\\r\\n        \\r\\n    }\\r\\n\\r\\n    function checkoutDex(address erc20TokenAddress) public payable {\\r\\n        \\r\\n        uint256 symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        \\r\\n        ERC20Interface token = ERC20Interface(tokens[symbolNameIndex].tokenContract);\\r\\n\\r\\n        uint256 _amountTokens = tokens[symbolNameIndex].leftover;\\r\\n        \\r\\n        require(tokens[symbolNameIndex].tokenContract != address(0), \\u0027Token is Invalid\\u0027);\\r\\n        require(tokens[symbolNameIndex].owner == msg.sender , \\u0027You are not owner of this coin\\u0027);\\r\\n        require(!checkDeadLine(tokens[symbolNameIndex]) || tokens[symbolNameIndex].leftover == 0 , \\u0027Token Cannot be withdrawn\\u0027);\\r\\n\\r\\n        require(tokenBalanceForAddress[symbolNameIndex] - _amountTokens \\u003e= 0 , \\\"overflow error\\\");\\r\\n        // require(tokenBalanceForAddress[symbolNameIndex] - _amountTokens \\u003c= tokenBalanceForAddress[symbolNameIndex] , \\\"Insufficient amount of token\\\");\\r\\n        \\r\\n        tokenBalanceForAddress[symbolNameIndex] -= _amountTokens;\\r\\n        tokens[symbolNameIndex].leftover = 0;\\r\\n        tokens[symbolNameIndex].state = State.Checkedout;\\r\\n        \\r\\n        if(_amountTokens \\u003e 0){\\r\\n            require(token.transfer(msg.sender, _amountTokens) == true , \\\"transfer failed\\\"); \\r\\n            setHistory(msg.sender , _amountTokens , \\u0027Check Out Token\\u0027 , tokens[symbolNameIndex].symbol , tokens[symbolNameIndex].decimals);\\r\\n        }\\r\\n\\r\\n        uint256 _siteShare = balanceEthForAddress[msg.sender][symbolNameIndex] * siteShareRatio / 1000;\\r\\n        uint256 _ownerShare = balanceEthForAddress[msg.sender][symbolNameIndex] - _siteShare;\\r\\n        \\r\\n        setHistory(msg.sender , _ownerShare , \\u0027Check Out ETH\\u0027 , \\u0027ETH\\u0027 , 18 );\\r\\n        setHistory(manager , _siteShare , \\u0027(Manager) Site Share For Deposite Token\\u0027 , \\u0027ETH\\u0027 , 18);\\r\\n        \\r\\n        msg.sender.transfer(_ownerShare);\\r\\n        manager.transfer(_siteShare);\\r\\n        \\r\\n        balanceEthForAddress[msg.sender][symbolNameIndex] = 0;\\r\\n    }\\r\\n\\r\\n    function getBalance(address erc20TokenAddress) public constant returns (uint256) {\\r\\n        uint256 _symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        return tokenBalanceForAddress[_symbolNameIndex];\\r\\n    }\\r\\n    \\r\\n    function checkoutRef(uint256 amount) public payable {\\r\\n    \\r\\n        require(refAccount[msg.sender] \\u003e= amount , \\u0027Insufficient amount of ETH\\u0027);\\r\\n\\r\\n        refAccount[msg.sender] -= amount;\\r\\n        \\r\\n        setHistory(msg.sender , amount , \\u0027Check Out Referral\\u0027 , \\u0027ETH\\u0027 , 18 );\\r\\n\\r\\n        msg.sender.transfer(amount);\\r\\n    }\\r\\n    \\r\\n    function getRefBalance(address _ownerAddress) view returns(uint256){\\r\\n        return refAccount[_ownerAddress];\\r\\n    }\\r\\n    \\r\\n    ///////////////\\r\\n    // Buy Token //\\r\\n    ///////////////\\r\\n    \\r\\n    function buyToken(address erc20TokenAddress , address refAddress , uint256 _amount) payable returns(bool){\\r\\n        \\r\\n        uint256 _symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        Token token = tokens[_symbolNameIndex];\\r\\n\\r\\n        require(token.state == State.Selling , \\u0027You Can not Buy This Token\\u0027);\\r\\n        require((_amount * token.priceInWie) / (10 ** token.decimals)  == msg.value , \\\"Incorrect Eth Amount\\\");\\r\\n        require(checkDeadLine(token) , \\u0027Deadline Passed\\u0027);\\r\\n        require(token.leftover \\u003e= _amount , \\u0027Insufficient Token Amount\\u0027);\\r\\n        \\r\\n        if(erc20TokenAddress != refAddress){\\r\\n            uint256 ref = msg.value * token.referral / 100;\\r\\n            balanceEthForAddress[token.owner][_symbolNameIndex] += msg.value - ref;\\r\\n            refAccount[refAddress] += ref;\\r\\n        }else{\\r\\n            balanceEthForAddress[token.owner][_symbolNameIndex] += msg.value;\\r\\n        }    \\r\\n        \\r\\n        ERC20Interface ERC20token = ERC20Interface(tokens[_symbolNameIndex].tokenContract);\\r\\n        \\r\\n        \\r\\n        ERC20token.approve(address(this) , _amount);\\r\\n\\r\\n        require(ERC20token.transferFrom(address(this) , msg.sender , _amount) == true , \\u0027Insufficient Token Amount\\u0027);\\r\\n        \\r\\n        setHistory(msg.sender , _amount , \\u0027Buy Token\\u0027 , token.symbol , token.decimals);\\r\\n\\r\\n        \\r\\n        token.leftover -= _amount;\\r\\n        tokenBalanceForAddress[_symbolNameIndex] -= _amount;\\r\\n        \\r\\n        if(token.leftover == 0){\\r\\n            token.state = State.Ended;\\r\\n        }\\r\\n        \\r\\n        saleCount[convertTime(now)] = saleCount[convertTime(now)] + msg.value; \\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function leftover(address erc20TokenAddress , uint256 _amount) public view returns(uint256){\\r\\n        uint256 _symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        return tokens[_symbolNameIndex].leftover;\\r\\n    }\\r\\n    \\r\\n    function checkDeadLine(Token token) internal returns(bool){\\r\\n        return (now \\u003c token.deadline); \\r\\n    }\\r\\n    \\r\\n    function getOwnerTokens(address owner) public view returns(address[] memory , string[] memory , uint256[] memory , uint256[] memory , uint256[] memory , uint256[] memory , uint[] memory ){\\r\\n        \\r\\n        address[] memory tokenAdderss = new address[](symbolNameIndex+1);\\r\\n        string[] memory tokenName = new string[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenAmount = new uint256[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenLeftover = new uint256[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenPrice = new uint256[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenDeadline = new uint256[](symbolNameIndex+1);\\r\\n        uint[] memory status = new uint[](symbolNameIndex+1);\\r\\n\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c= symbolNameIndex; i++) {\\r\\n            if (tokens[i].owner == owner) {\\r\\n                tokenAdderss[i] = tokens[i].tokenContract;\\r\\n                tokenName[i] = tokens[i].symbol;\\r\\n                tokenAmount[i] = tokens[i].amount;\\r\\n                tokenLeftover[i] = tokens[i].leftover;\\r\\n                tokenPrice[i] = tokens[i].priceInWie;\\r\\n                tokenDeadline[i] = tokens[i].deadline;\\r\\n\\r\\n                if(tokens[i].state == State.Waiting)\\r\\n                    status[i] = 1;\\r\\n                else{    \\r\\n                    if(tokens[i].state == State.Selling)\\r\\n                        status[i] = 2;\\r\\n                    if(!checkDeadLine(tokens[i]) || tokens[i].leftover == 0)\\r\\n                        status[i] = 3;\\r\\n                    if(tokens[i].state == State.Checkedout)\\r\\n                        status[i] = 4;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return (tokenAdderss , tokenName , tokenLeftover , tokenAmount , tokenPrice , tokenDeadline , status);\\r\\n    }\\r\\n    \\r\\n    function getDecimal(address erc20TokenAddress) public view returns(uint256){\\r\\n        uint256 _symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        return tokens[_symbolNameIndex].decimals;\\r\\n    }\\r\\n    \\r\\n    function getOwnerTokenDetails(address erc20TokenAddress) public view returns(Token){\\r\\n        uint256 _symbolNameIndex = getSymbolIndexByAddressOrThrow(erc20TokenAddress);\\r\\n        Token token = tokens[_symbolNameIndex];\\r\\n        require(token.owner == msg.sender);\\r\\n        \\r\\n        return token;\\r\\n    }\\r\\n    \\r\\n    function setHistory(address _owner , uint256 _amount , string _name , string _symbol , uint256 _decimals) public {\\r\\n        histories[historyIndex].amount = _amount;\\r\\n        histories[historyIndex].title = _name;\\r\\n        histories[historyIndex].owner = _owner;\\r\\n        histories[historyIndex].symbol = _symbol;\\r\\n        histories[historyIndex].time = now;\\r\\n        histories[historyIndex].decimals = _decimals;\\r\\n        \\r\\n        historyIndex++;\\r\\n    }\\r\\n    \\r\\n    function getHistory(address _owner) public view returns(string[] , string[] , uint256[] , uint256[] , uint256[]){\\r\\n        \\r\\n        string[] memory title = new string[](historyIndex+1);\\r\\n        string[] memory symbol = new string[](historyIndex+1);\\r\\n        uint256[] memory time = new uint256[](historyIndex+1);\\r\\n        uint256[] memory amount = new uint256[](historyIndex+1);\\r\\n        uint256[] memory decimals = new uint256[](historyIndex+1);\\r\\n\\r\\n\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c= historyIndex; i++) {\\r\\n            if (histories[i].owner == _owner) {\\r\\n                title[i] = histories[i].title;\\r\\n                symbol[i] = histories[i].symbol;\\r\\n                time[i] = histories[i].time;\\r\\n                amount[i] = histories[i].amount;\\r\\n                decimals[i] = histories[i].decimals;\\r\\n            }\\r\\n        }\\r\\n        return (title , symbol , time , amount , decimals);\\r\\n    }\\r\\n    \\r\\n    ///////////////////\\r\\n    // Passed Token //\\r\\n    /////////////////\\r\\n    \\r\\n    function getAllPassedDex() public view returns(address[] memory , string[] memory , uint256[] memory , uint[] memory , uint256[] memory , string[] memory){\\r\\n        \\r\\n        address[] memory tokenAdderss = new address[](symbolNameIndex+1);\\r\\n        string[] memory tokenName = new string[](symbolNameIndex+1);\\r\\n        string[] memory tokenLink = new string[](symbolNameIndex+1);\\r\\n        uint256[] memory tokenPrice = new uint256[](symbolNameIndex+1);\\r\\n        uint[] memory decimal = new uint256[](symbolNameIndex+1);\\r\\n        uint256[] memory leftover = new uint256[](symbolNameIndex+1);\\r\\n\\r\\n\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c= symbolNameIndex; i++) {\\r\\n            if(!(checkDeadLine(tokens[i]) \\u0026\\u0026 tokens[i].leftover != 0)){\\r\\n                tokenAdderss[i] = tokens[i].tokenContract;\\r\\n                tokenName[i] = tokens[i].symbol;\\r\\n                tokenLink[i] = tokens[i].link;\\r\\n                tokenPrice[i] = tokens[i].priceInWie;\\r\\n                decimal[i] = tokens[i].decimals;\\r\\n                leftover[i] = tokens[i].leftover;\\r\\n            }\\r\\n        }\\r\\n        return (tokenAdderss , tokenName , tokenPrice , decimal , leftover , tokenLink);\\r\\n    }\\r\\n    \\r\\n    function convertTime(uint256 time) internal returns(uint256){\\r\\n            return (time - 1603584000) / 86400;\\r\\n    }\\r\\n    \\r\\n    function getChart() public view returns(uint256[]){\\r\\n\\r\\n        uint256[] memory tokenVal = new uint256[](convertTime(now) + 1);\\r\\n\\r\\n        for(uint i = 0 ; i \\u003c= convertTime(now); i++){\\r\\n            tokenVal[i] = saleCount[i];\\r\\n        }\\r\\n        \\r\\n        return tokenVal;\\r\\n    }\\r\\n}\"},\"ERC20Interface.sol\":{\"content\":\"  pragma solidity ^0.4.18;\\r\\n\\r\\n// ----------------------------------------------------------------------------------------------\\r\\n// Sample fixed supply token contract\\r\\n// Enjoy. (c) BokkyPooBah 2017. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------------------------\\r\\n\\r\\n// ERC Token Standard #20 Interface\\r\\n// https://github.com/ethereum/EIPs/issues/20\\r\\ncontract ERC20Interface {\\r\\n    // Get the total token supply\\r\\n    function totalSupply() public constant returns (uint256);\\r\\n\\r\\n    // Get the account balance of another account with address _owner\\r\\n    function balanceOf(address _owner) public constant returns (uint256 balance);\\r\\n\\r\\n    // Send _value amount of tokens to address _to\\r\\n    function transfer(address _to, uint256 _value) public returns (bool success);\\r\\n\\r\\n    // Send _value amount of tokens from address _from to address _to\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\r\\n\\r\\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\\r\\n    // If this function is called again it overwrites the current allowance with _value.\\r\\n    // this function is required for some DEX functionality\\r\\n    function approve(address _spender, uint256 _value) public returns (bool success);\\r\\n\\r\\n    // Returns the amount which _spender is still allowed to withdraw from _owner\\r\\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\\r\\n\\r\\n    // Triggered when tokens are transferred.\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n\\r\\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getAllPassedDex\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"string[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"string[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"getOwnerTokenDetails\",\"outputs\":[{\"components\":[{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"symbolName\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"link\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"leftover\",\"type\":\"uint256\"},{\"name\":\"priceInWie\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"referral\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"getInitTokenInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"checkoutRef\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"checkoutDex\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"string[]\"},{\"name\":\"\",\"type\":\"string[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"symbolName\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"link\",\"type\":\"string\"},{\"name\":\"priceInWie\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint256\"},{\"name\":\"referral\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"getDecimal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"hasToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"leftover\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"refAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"getRefBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllDex\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"string[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"string[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getOwnerTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"string[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"getSymbolIndexByAddressOrThrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"setHistory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"erc20TokenAddress\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"TokenSale","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a8b16d6edb3dec83620f88adda673a13814ca733c724c0c9bba643f481ee1fcf"}]}