{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/interfaces/ERC677.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\ncontract ERC677 is ERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\r\n\r\n    function transferAndCall(address, uint256, bytes) external returns (bool);\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IBurnableMintableERC677Token.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\ncontract IBurnableMintableERC677Token is ERC677 {\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n    function burn(uint256 _value) public;\r\n    function claimTokens(address _token, address _to) public;\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/Sacrifice.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract Sacrifice {\r\n    constructor(address _recipient) public payable {\r\n        selfdestruct(_recipient);\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/Address.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title Address\r\n * @dev Helper methods for Address type.\r\n */\r\nlibrary Address {\r\n    /**\r\n    * @dev Try to send native tokens to the address. If it fails, it will force the transfer by creating a selfdestruct contract\r\n    * @param _receiver address that will receive the native tokens\r\n    * @param _value the amount of native tokens to send\r\n    */\r\n    function safeSendValue(address _receiver, uint256 _value) internal {\r\n        if (!_receiver.send(_value)) {\r\n            (new Sacrifice).value(_value)(_receiver);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/EternalStorage.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title EternalStorage\r\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\r\n */\r\ncontract EternalStorage {\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/IRewardableValidators.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ninterface IRewardableValidators {\r\n    function isValidator(address _validator) external view returns (bool);\r\n    function requiredSignatures() external view returns (uint256);\r\n    function owner() external view returns (address);\r\n    function validatorList() external view returns (address[]);\r\n    function getValidatorRewardAddress(address _validator) external view returns (address);\r\n    function validatorCount() external view returns (uint256);\r\n    function getNextValidator(address _address) external view returns (address);\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/FeeTypes.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract FeeTypes {\r\n    bytes32 internal constant HOME_FEE = 0x89d93e5e92f7e37e490c25f0e50f7f4aad7cc94b308a566553280967be38bcf1; // keccak256(abi.encodePacked(\"home-fee\"))\r\n    bytes32 internal constant FOREIGN_FEE = 0xdeb7f3adca07d6d1f708c1774389db532a2b2f18fd05a62b957e4089f4696ed5; // keccak256(abi.encodePacked(\"foreign-fee\"))\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/BaseFeeManager.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\ncontract BaseFeeManager is EternalStorage, FeeTypes {\r\n    using SafeMath for uint256;\r\n\r\n    event HomeFeeUpdated(uint256 fee);\r\n    event ForeignFeeUpdated(uint256 fee);\r\n\r\n    // This is not a real fee value but a relative value used to calculate the fee percentage\r\n    uint256 internal constant MAX_FEE = 1 ether;\r\n    bytes32 internal constant HOME_FEE_STORAGE_KEY = 0xc3781f3cec62d28f56efe98358f59c2105504b194242dbcb2cc0806850c306e7; // keccak256(abi.encodePacked(\"homeFee\"))\r\n    bytes32 internal constant FOREIGN_FEE_STORAGE_KEY = 0x68c305f6c823f4d2fa4140f9cf28d32a1faccf9b8081ff1c2de11cf32c733efc; // keccak256(abi.encodePacked(\"foreignFee\"))\r\n\r\n    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) public view returns (uint256) {\r\n        uint256 fee = _feeType == HOME_FEE ? getHomeFee() : getForeignFee();\r\n        if (!_recover) {\r\n            return _value.mul(fee).div(MAX_FEE);\r\n        }\r\n        return _value.mul(fee).div(MAX_FEE.sub(fee));\r\n    }\r\n\r\n    modifier validFee(uint256 _fee) {\r\n        require(_fee < MAX_FEE);\r\n        /* solcov ignore next */\r\n        _;\r\n    }\r\n\r\n    function setHomeFee(uint256 _fee) external validFee(_fee) {\r\n        uintStorage[HOME_FEE_STORAGE_KEY] = _fee;\r\n        emit HomeFeeUpdated(_fee);\r\n    }\r\n\r\n    function getHomeFee() public view returns (uint256) {\r\n        return uintStorage[HOME_FEE_STORAGE_KEY];\r\n    }\r\n\r\n    function setForeignFee(uint256 _fee) external validFee(_fee) {\r\n        uintStorage[FOREIGN_FEE_STORAGE_KEY] = _fee;\r\n        emit ForeignFeeUpdated(_fee);\r\n    }\r\n\r\n    function getForeignFee() public view returns (uint256) {\r\n        return uintStorage[FOREIGN_FEE_STORAGE_KEY];\r\n    }\r\n\r\n    /* solcov ignore next */\r\n    function distributeFeeFromAffirmation(uint256 _fee) external;\r\n\r\n    /* solcov ignore next */\r\n    function distributeFeeFromSignatures(uint256 _fee) external;\r\n\r\n    /* solcov ignore next */\r\n    function getFeeManagerMode() external pure returns (bytes4);\r\n\r\n    function random(uint256 _count) internal view returns (uint256) {\r\n        return uint256(blockhash(block.number.sub(1))) % _count;\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/ValidatorStorage.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract ValidatorStorage {\r\n    bytes32 internal constant VALIDATOR_CONTRACT = 0x5a74bb7e202fb8e4bf311841c7d64ec19df195fee77d7e7ae749b27921b6ddfe; // keccak256(abi.encodePacked(\"validatorContract\"))\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/ValidatorsFeeManager.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\ncontract ValidatorsFeeManager is BaseFeeManager, ValidatorStorage {\r\n    bytes32 public constant REWARD_FOR_TRANSFERRING_FROM_HOME = 0x2a11db67c480122765825a7e4bc5428e8b7b9eca0d4e62b91aac194f99edd0d7; // keccak256(abi.encodePacked(\"reward-transferring-from-home\"))\r\n    bytes32 public constant REWARD_FOR_TRANSFERRING_FROM_FOREIGN = 0xb14796d751eb4f2570065a479f9e526eabeb2077c564c8a1c5ea559883ea2fab; // keccak256(abi.encodePacked(\"reward-transferring-from-foreign\"))\r\n\r\n    function distributeFeeFromAffirmation(uint256 _fee) external {\r\n        distributeFeeProportionally(_fee, REWARD_FOR_TRANSFERRING_FROM_FOREIGN);\r\n    }\r\n\r\n    function distributeFeeFromSignatures(uint256 _fee) external {\r\n        distributeFeeProportionally(_fee, REWARD_FOR_TRANSFERRING_FROM_HOME);\r\n    }\r\n\r\n    function rewardableValidatorContract() internal view returns (IRewardableValidators) {\r\n        return IRewardableValidators(addressStorage[VALIDATOR_CONTRACT]);\r\n    }\r\n\r\n    function distributeFeeProportionally(uint256 _fee, bytes32 _direction) internal {\r\n        IRewardableValidators validators = rewardableValidatorContract();\r\n        // solhint-disable-next-line var-name-mixedcase\r\n        address F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\r\n        uint256 numOfValidators = validators.validatorCount();\r\n\r\n        uint256 feePerValidator = _fee.div(numOfValidators);\r\n\r\n        uint256 randomValidatorIndex;\r\n        uint256 diff = _fee.sub(feePerValidator.mul(numOfValidators));\r\n        if (diff > 0) {\r\n            randomValidatorIndex = random(numOfValidators);\r\n        }\r\n\r\n        address nextValidator = validators.getNextValidator(F_ADDR);\r\n        require((nextValidator != F_ADDR) && (nextValidator != address(0)));\r\n\r\n        uint256 i = 0;\r\n        while (nextValidator != F_ADDR) {\r\n            uint256 feeToDistribute = feePerValidator;\r\n            if (diff > 0 && randomValidatorIndex == i) {\r\n                feeToDistribute = feeToDistribute.add(diff);\r\n            }\r\n\r\n            address rewardAddress = validators.getValidatorRewardAddress(nextValidator);\r\n            onFeeDistribution(rewardAddress, feeToDistribute, _direction);\r\n\r\n            nextValidator = validators.getNextValidator(nextValidator);\r\n            require(nextValidator != address(0));\r\n            i = i + 1;\r\n        }\r\n    }\r\n\r\n    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\r\n        if (_direction == REWARD_FOR_TRANSFERRING_FROM_FOREIGN) {\r\n            onAffirmationFeeDistribution(_rewardAddress, _fee);\r\n        } else {\r\n            onSignatureFeeDistribution(_rewardAddress, _fee);\r\n        }\r\n    }\r\n\r\n    /* solcov ignore next */\r\n    function onAffirmationFeeDistribution(address _rewardAddress, uint256 _fee) internal;\r\n\r\n    /* solcov ignore next */\r\n    function onSignatureFeeDistribution(address _rewardAddress, uint256 _fee) internal;\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/ERC677Storage.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract ERC677Storage {\r\n    bytes32 internal constant ERC677_TOKEN = 0xa8b0ade3e2b734f043ce298aca4cc8d19d74270223f34531d0988b7d00cba21d; // keccak256(abi.encodePacked(\"erc677token\"))\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/native_to_erc20/FeeManagerNativeToErc.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\ncontract FeeManagerNativeToErc is ValidatorsFeeManager, ERC677Storage {\r\n    function getFeeManagerMode() external pure returns (bytes4) {\r\n        return 0xf2aed8f7; // bytes4(keccak256(abi.encodePacked(\"manages-one-direction\")))\r\n    }\r\n\r\n    function erc677token() public view returns (IBurnableMintableERC677Token) {\r\n        return IBurnableMintableERC677Token(addressStorage[ERC677_TOKEN]);\r\n    }\r\n\r\n    function onAffirmationFeeDistribution(address _rewardAddress, uint256 _fee) internal {\r\n        Address.safeSendValue(_rewardAddress, _fee);\r\n    }\r\n\r\n    function onSignatureFeeDistribution(address _rewardAddress, uint256 _fee) internal {\r\n        erc677token().mint(_rewardAddress, _fee);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"distributeFeeFromAffirmation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc677token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setForeignFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setHomeFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"distributeFeeFromSignatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REWARD_FOR_TRANSFERRING_FROM_FOREIGN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REWARD_FOR_TRANSFERRING_FROM_HOME\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHomeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_recover\",\"type\":\"bool\"},{\"name\":\"_feeType\",\"type\":\"bytes32\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeManagerMode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getForeignFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"HomeFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ForeignFeeUpdated\",\"type\":\"event\"}]","ContractName":"FeeManagerNativeToErc","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f8c430f747f96df37f392aac48408aff032cafecb2b5ac200e3e2dabb5d7e091"}]}