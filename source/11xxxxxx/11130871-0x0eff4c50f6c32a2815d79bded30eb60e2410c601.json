{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/components/Owned.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\r\n///  later changed\r\ncontract Owned {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    function transferOwner(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"New owner is the zero address\");\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    ///  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/components/Halt.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract Halt is Owned {\r\n\r\n    bool public halted = false;\r\n\r\n    modifier notHalted() {\r\n        require(!halted, \"Smart contract is halted\");\r\n        _;\r\n    }\r\n\r\n    modifier isHalted() {\r\n        require(halted, \"Smart contract is not halted\");\r\n        _;\r\n    }\r\n\r\n    /// @notice function Emergency situation that requires\r\n    /// @notice contribution period to stop or not.\r\n    function setHalt(bool halt)\r\n        public\r\n        onlyOwner\r\n    {\r\n        halted = halt;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath mul overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath div 0\"); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath sub b > a\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath add overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath mod 0\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/BasicStorageLib.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary BasicStorageLib {\r\n\r\n    struct UintData {\r\n        mapping(bytes => mapping(bytes => uint))           _storage;\r\n    }\r\n\r\n    struct BoolData {\r\n        mapping(bytes => mapping(bytes => bool))           _storage;\r\n    }\r\n\r\n    struct AddressData {\r\n        mapping(bytes => mapping(bytes => address))        _storage;\r\n    }\r\n\r\n    struct BytesData {\r\n        mapping(bytes => mapping(bytes => bytes))          _storage;\r\n    }\r\n\r\n    struct StringData {\r\n        mapping(bytes => mapping(bytes => string))         _storage;\r\n    }\r\n\r\n    /* uintStorage */\r\n\r\n    function setStorage(UintData storage self, bytes memory key, bytes memory innerKey, uint value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(UintData storage self, bytes memory key, bytes memory innerKey) internal view returns (uint) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(UintData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* boolStorage */\r\n\r\n    function setStorage(BoolData storage self, bytes memory key, bytes memory innerKey, bool value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(BoolData storage self, bytes memory key, bytes memory innerKey) internal view returns (bool) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(BoolData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* addressStorage */\r\n\r\n    function setStorage(AddressData storage self, bytes memory key, bytes memory innerKey, address value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(AddressData storage self, bytes memory key, bytes memory innerKey) internal view returns (address) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(AddressData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* bytesStorage */\r\n\r\n    function setStorage(BytesData storage self, bytes memory key, bytes memory innerKey, bytes memory value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(BytesData storage self, bytes memory key, bytes memory innerKey) internal view returns (bytes memory) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(BytesData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* stringStorage */\r\n\r\n    function setStorage(StringData storage self, bytes memory key, bytes memory innerKey, string memory value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(StringData storage self, bytes memory key, bytes memory innerKey) internal view returns (string memory) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(StringData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/components/BasicStorage.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract BasicStorage {\r\n    /************************************************************\r\n     **\r\n     ** VARIABLES\r\n     **\r\n     ************************************************************/\r\n\r\n    //// basic variables\r\n    using BasicStorageLib for BasicStorageLib.UintData;\r\n    using BasicStorageLib for BasicStorageLib.BoolData;\r\n    using BasicStorageLib for BasicStorageLib.AddressData;\r\n    using BasicStorageLib for BasicStorageLib.BytesData;\r\n    using BasicStorageLib for BasicStorageLib.StringData;\r\n\r\n    BasicStorageLib.UintData    internal uintData;\r\n    BasicStorageLib.BoolData    internal boolData;\r\n    BasicStorageLib.AddressData internal addressData;\r\n    BasicStorageLib.BytesData   internal bytesData;\r\n    BasicStorageLib.StringData  internal stringData;\r\n}\r\n\r\n// File: contracts/quota/QuotaStorage.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\ncontract QuotaStorage is BasicStorage {\r\n    \r\n    /// @dev Math operations with safety checks\r\n    using SafeMath for uint;\r\n\r\n    struct Quota {\r\n        /// amount of original token to be received, equals to amount of WAN token to be minted\r\n        uint debt_receivable;\r\n        /// amount of WAN token to be burnt\r\n        uint debt_payable;\r\n        /// amount of original token has been exchanged to the wanchain\r\n        uint _debt;\r\n        /// amount of original token to be received, equals to amount of WAN token to be minted\r\n        uint asset_receivable;\r\n        /// amount of WAN token to be burnt\r\n        uint asset_payable;\r\n        /// amount of original token has been exchanged to the wanchain\r\n        uint _asset;\r\n        /// data is active\r\n        bool _active;\r\n    }\r\n\r\n    /// @dev the denominator of deposit rate value\r\n    uint public constant DENOMINATOR = 10000;\r\n\r\n    /// @dev mapping: tokenId => storemanPk => Quota\r\n    mapping(uint => mapping(bytes32 => Quota)) quotaMap;\r\n\r\n    /// @dev mapping: storemanPk => tokenIndex => tokenId, tokenIndex:0,1,2,3...\r\n    mapping(bytes32 => mapping(uint => uint)) storemanTokensMap;\r\n\r\n    /// @dev mapping: storemanPk => token count\r\n    mapping(bytes32 => uint) storemanTokenCountMap;\r\n\r\n    /// @dev mapping: htlcAddress => exist\r\n    mapping(address => bool) public htlcGroupMap;\r\n\r\n    /// @dev save deposit oracle address (storeman admin or oracle)\r\n    address public depositOracleAddress;\r\n\r\n    /// @dev save price oracle address\r\n    address public priceOracleAddress;\r\n\r\n    /// @dev deposit rate use for deposit amount calculate\r\n    uint public depositRate;\r\n\r\n    /// @dev deposit token's symbol\r\n    string public depositTokenSymbol;\r\n\r\n    /// @dev token manger contract address\r\n    address public tokenManagerAddress;\r\n\r\n    /// @dev oracle address for check other chain's debt clean\r\n    address public debtOracleAddress;\r\n\r\n    /// @dev limit the minimize value of fast cross chain\r\n    uint public fastCrossMinValue;\r\n\r\n    modifier onlyHtlc() {\r\n        require(htlcGroupMap[msg.sender], \"Not in HTLC group\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IOracle.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\ninterface IOracle {\r\n  function getDeposit(bytes32 smgID) external view returns (uint);\r\n  function getValue(bytes32 key) external view returns (uint);\r\n  function getValues(bytes32[] keys) external view returns (uint[] values);\r\n  function getStoremanGroupConfig(\r\n    bytes32 id\r\n  ) external view returns(bytes32 groupId, uint8 status, uint deposit, uint chain1, uint chain2, uint curve1, uint curve2, bytes gpk1, bytes gpk2, uint startTime, uint endTime);\r\n}\r\n\r\n// File: contracts/quota/QuotaDelegate.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\n\r\n\r\n\r\n\r\ninterface _ITokenManager {\r\n    function getAncestorSymbol(uint id) external view returns (string symbol, uint8 decimals);\r\n}\r\n\r\ninterface _IStoremanGroup {\r\n    function getDeposit(bytes32 id) external view returns(uint deposit);\r\n}\r\n\r\ninterface IDebtOracle {\r\n    function isDebtClean(bytes32 storemanGroupId) external view returns (bool);\r\n}\r\n\r\n\r\ncontract QuotaDelegate is QuotaStorage, Halt {\r\n\r\n    modifier checkMinValue(uint tokenId, uint value) {\r\n        if (fastCrossMinValue > 0) {\r\n            string memory symbol;\r\n            uint decimals;\r\n            (symbol, decimals) = getTokenAncestorInfo(tokenId);\r\n            uint price = getPrice(symbol);\r\n            require(price > 0, \"Price is zero\");\r\n            uint count = fastCrossMinValue.mul(10**decimals).div(price);\r\n            require(value >= count, \"value too small\");\r\n        }\r\n        _;\r\n    }\r\n    \r\n    /// @notice                         config params for owner\r\n    /// @param _priceOracleAddr         token price oracle contract address\r\n    /// @param _htlcAddr                HTLC contract address\r\n    /// @param _depositOracleAddr       deposit oracle address, storemanAdmin or oracle\r\n    /// @param _depositRate             deposit rate value, 15000 means 150%\r\n    /// @param _depositTokenSymbol      deposit token symbol, default is WAN\r\n    /// @param _tokenManagerAddress     token manager contract address\r\n    function config(\r\n        address _priceOracleAddr,\r\n        address _htlcAddr,\r\n        address _fastHtlcAddr,\r\n        address _depositOracleAddr,\r\n        address _tokenManagerAddress,\r\n        uint _depositRate,\r\n        string _depositTokenSymbol\r\n    ) external onlyOwner {\r\n        priceOracleAddress = _priceOracleAddr;\r\n        htlcGroupMap[_htlcAddr] = true;\r\n        htlcGroupMap[_fastHtlcAddr] = true;\r\n        depositOracleAddress = _depositOracleAddr;\r\n        depositRate = _depositRate;\r\n        depositTokenSymbol = _depositTokenSymbol;\r\n        tokenManagerAddress = _tokenManagerAddress;\r\n    }\r\n\r\n    function setDebtOracle(address oracle) external onlyOwner {\r\n        debtOracleAddress = oracle;\r\n    }\r\n\r\n    function setFastCrossMinValue(uint value) external onlyOwner {\r\n        fastCrossMinValue = value;\r\n    }\r\n\r\n    /// @notice                                 lock quota in mint direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function userMintLock(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        \r\n        uint mintQuota = getUserMintQuota(tokenId, storemanGroupId);\r\n        require(\r\n            mintQuota >= value,\r\n            \"Quota is not enough\"\r\n        );\r\n\r\n        if (!quota._active) {\r\n            quota._active = true;\r\n            storemanTokensMap[storemanGroupId][storemanTokenCountMap[storemanGroupId]] = tokenId;\r\n            storemanTokenCountMap[storemanGroupId] = storemanTokenCountMap[storemanGroupId]\r\n                .add(1);\r\n        }\r\n\r\n        quota.asset_receivable = quota.asset_receivable.add(value);\r\n    }\r\n\r\n    /// @notice                                 lock quota in mint direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function smgMintLock(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        \r\n        if (!quota._active) {\r\n            quota._active = true;\r\n            storemanTokensMap[storemanGroupId][storemanTokenCountMap[storemanGroupId]] = tokenId;\r\n            storemanTokenCountMap[storemanGroupId] = storemanTokenCountMap[storemanGroupId]\r\n                .add(1);\r\n        }\r\n\r\n        quota.debt_receivable = quota.debt_receivable.add(value);\r\n    }\r\n\r\n    /// @notice                                 revoke quota in mint direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function userMintRevoke(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        quota.asset_receivable = quota.asset_receivable.sub(value);\r\n    }\r\n\r\n    /// @notice                                 revoke quota in mint direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function smgMintRevoke(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        quota.debt_receivable = quota.debt_receivable.sub(value);\r\n    }\r\n\r\n    /// @notice                                 redeem quota in mint direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function userMintRedeem(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        quota.debt_receivable = quota.debt_receivable.sub(value);\r\n        quota._debt = quota._debt.add(value);\r\n    }\r\n\r\n    /// @notice                                 redeem quota in mint direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function smgMintRedeem(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        quota.asset_receivable = quota.asset_receivable.sub(value);\r\n        quota._asset = quota._asset.add(value);\r\n    }\r\n\r\n    /// @notice                                 perform a fast crosschain mint\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function userFastMint(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc checkMinValue(tokenId, value) {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        \r\n        uint mintQuota = getUserMintQuota(tokenId, storemanGroupId);\r\n        require(\r\n            mintQuota >= value,\r\n            \"Quota is not enough\"\r\n        );\r\n\r\n        if (!quota._active) {\r\n            quota._active = true;\r\n            storemanTokensMap[storemanGroupId][storemanTokenCountMap[storemanGroupId]] = tokenId;\r\n            storemanTokenCountMap[storemanGroupId] = storemanTokenCountMap[storemanGroupId]\r\n                .add(1);\r\n        }\r\n        quota._asset = quota._asset.add(value);\r\n    }\r\n\r\n    /// @notice                                 perform a fast crosschain mint\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function smgFastMint(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        \r\n        if (!quota._active) {\r\n            quota._active = true;\r\n            storemanTokensMap[storemanGroupId][storemanTokenCountMap[storemanGroupId]] = tokenId;\r\n            storemanTokenCountMap[storemanGroupId] = storemanTokenCountMap[storemanGroupId]\r\n                .add(1);\r\n        }\r\n        quota._debt = quota._debt.add(value);\r\n    }\r\n\r\n    /// @notice                                 perform a fast crosschain burn\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function userFastBurn(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc checkMinValue(tokenId, value) {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        require(quota._debt.sub(quota.debt_payable) >= value, \"Value is invalid\");\r\n        quota._debt = quota._debt.sub(value);\r\n    }\r\n\r\n    /// @notice                                 perform a fast crosschain burn\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function smgFastBurn(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        quota._asset = quota._asset.sub(value);\r\n    }\r\n\r\n    /// @notice                                 lock quota in burn direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function userBurnLock(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        require(quota._debt.sub(quota.debt_payable) >= value, \"Value is invalid\");\r\n        quota.debt_payable = quota.debt_payable.add(value);\r\n    }\r\n\r\n    /// @notice                                 lock quota in burn direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function smgBurnLock(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        quota.asset_payable = quota.asset_payable.add(value);\r\n    }\r\n\r\n    /// @notice                                 revoke quota in burn direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function userBurnRevoke(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        quota.debt_payable = quota.debt_payable.sub(value);\r\n    }\r\n\r\n    /// @notice                                 revoke quota in burn direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function smgBurnRevoke(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        quota.asset_payable = quota.asset_payable.sub(value);\r\n    }\r\n\r\n    /// @notice                                 redeem quota in burn direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function userBurnRedeem(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        quota._asset = quota._asset.sub(value);\r\n        quota.asset_payable = quota.asset_payable.sub(value);\r\n    }\r\n\r\n    /// @notice                                 redeem quota in burn direction\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    /// @param value                            amount of exchange token\r\n    function smgBurnRedeem(\r\n        uint tokenId,\r\n        bytes32 storemanGroupId,\r\n        uint value\r\n    ) external onlyHtlc {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        quota._debt = quota._debt.sub(value);\r\n        quota.debt_payable = quota.debt_payable.sub(value);\r\n    }\r\n\r\n    /// @notice                                 source storeman group lock the debt transaction,update the detailed quota info. of the storeman group\r\n    /// @param srcStoremanGroupId               PK of source storeman group\r\n    /// @param dstStoremanGroupId               PK of destination storeman group\r\n    function debtLock(\r\n        bytes32 srcStoremanGroupId,\r\n        bytes32 dstStoremanGroupId\r\n    ) external onlyHtlc {\r\n        uint tokenCount = storemanTokenCountMap[srcStoremanGroupId];\r\n        // TODO gas out of range\r\n        for (uint i = 0; i < tokenCount; i++) {\r\n            uint id = storemanTokensMap[srcStoremanGroupId][i];\r\n            Quota storage src = quotaMap[id][srcStoremanGroupId];\r\n\r\n            require( src.debt_receivable == uint(0) && src.debt_payable == uint(0),\r\n                \"There are debt_receivable or debt_payable in src storeman\"\r\n            );\r\n\r\n            if (src._debt == 0) {\r\n                continue;\r\n            }\r\n\r\n            Quota storage dst = quotaMap[id][dstStoremanGroupId];\r\n            if (!dst._active) {\r\n                dst._active = true;\r\n                storemanTokensMap[dstStoremanGroupId][storemanTokenCountMap[dstStoremanGroupId]] = id;\r\n                storemanTokenCountMap[dstStoremanGroupId] = storemanTokenCountMap[dstStoremanGroupId]\r\n                    .add(1);\r\n            }\r\n\r\n            dst.debt_receivable = dst.debt_receivable.add(src._debt);\r\n            src.debt_payable = src.debt_payable.add(src._debt);\r\n        }\r\n    }\r\n\r\n    /// @notice                                 destination storeman group redeem the debt transaction,update the detailed quota info. of the storeman group\r\n    /// @param srcStoremanGroupId               PK of source storeman group\r\n    /// @param dstStoremanGroupId               PK of destination storeman group\r\n    function debtRedeem(\r\n        bytes32 srcStoremanGroupId,\r\n        bytes32 dstStoremanGroupId\r\n    ) external onlyHtlc {\r\n        uint tokenCount = storemanTokenCountMap[srcStoremanGroupId];\r\n        for (uint i = 0; i < tokenCount; i++) {\r\n            uint id = storemanTokensMap[srcStoremanGroupId][i];\r\n            Quota storage src = quotaMap[id][srcStoremanGroupId];\r\n            if (src._debt == 0) {\r\n                continue;\r\n            }\r\n            Quota storage dst = quotaMap[id][dstStoremanGroupId];\r\n            /// Adjust quota record\r\n            dst.debt_receivable = dst.debt_receivable.sub(src.debt_payable);\r\n            dst._debt = dst._debt.add(src._debt);\r\n\r\n            src.debt_payable = 0;\r\n            src._debt = 0;\r\n        }\r\n    }\r\n\r\n    /// @notice                                 source storeman group revoke the debt transaction,update the detailed quota info. of the storeman group\r\n    /// @param srcStoremanGroupId               PK of source storeman group\r\n    /// @param dstStoremanGroupId               PK of destination storeman group\r\n    function debtRevoke(\r\n        bytes32 srcStoremanGroupId,\r\n        bytes32 dstStoremanGroupId\r\n    ) external onlyHtlc {\r\n        uint tokenCount = storemanTokenCountMap[srcStoremanGroupId];\r\n        for (uint i = 0; i < tokenCount; i++) {\r\n            uint id = storemanTokensMap[srcStoremanGroupId][i];\r\n            Quota storage src = quotaMap[id][srcStoremanGroupId];\r\n            if (src._debt == 0) {\r\n                continue;\r\n            }\r\n            Quota storage dst = quotaMap[id][dstStoremanGroupId];\r\n            \r\n            dst.debt_receivable = dst.debt_receivable.sub(src.debt_payable);\r\n            src.debt_payable = 0;\r\n        }\r\n    }\r\n\r\n    /// @notice                                 source storeman group lock the debt transaction,update the detailed quota info. of the storeman group\r\n    /// @param srcStoremanGroupId               PK of source storeman group\r\n    /// @param dstStoremanGroupId               PK of destination storeman group\r\n    function assetLock(\r\n        bytes32 srcStoremanGroupId,\r\n        bytes32 dstStoremanGroupId\r\n    ) external onlyHtlc {\r\n        uint tokenCount = storemanTokenCountMap[srcStoremanGroupId];\r\n        for (uint i = 0; i < tokenCount; i++) {\r\n            uint id = storemanTokensMap[srcStoremanGroupId][i];\r\n            Quota storage src = quotaMap[id][srcStoremanGroupId];\r\n\r\n            require( src.asset_receivable == uint(0) && src.asset_payable == uint(0),\r\n                \"There are asset_receivable or asset_payable in src storeman\"\r\n            );\r\n\r\n            if (src._asset == 0) {\r\n                continue;\r\n            }\r\n\r\n            Quota storage dst = quotaMap[id][dstStoremanGroupId];\r\n            if (!dst._active) {\r\n                dst._active = true;\r\n                storemanTokensMap[dstStoremanGroupId][storemanTokenCountMap[dstStoremanGroupId]] = id;\r\n                storemanTokenCountMap[dstStoremanGroupId] = storemanTokenCountMap[dstStoremanGroupId]\r\n                    .add(1);\r\n            }\r\n\r\n            dst.asset_receivable = dst.asset_receivable.add(src._asset);\r\n            src.asset_payable = src.asset_payable.add(src._asset);\r\n        }\r\n    }\r\n\r\n    /// @notice                                 destination storeman group redeem the debt transaction,update the detailed quota info. of the storeman group\r\n    /// @param srcStoremanGroupId               PK of source storeman group\r\n    /// @param dstStoremanGroupId               PK of destination storeman group\r\n    function assetRedeem(\r\n        bytes32 srcStoremanGroupId,\r\n        bytes32 dstStoremanGroupId\r\n    ) external onlyHtlc {\r\n        uint tokenCount = storemanTokenCountMap[srcStoremanGroupId];\r\n        for (uint i = 0; i < tokenCount; i++) {\r\n            uint id = storemanTokensMap[srcStoremanGroupId][i];\r\n            Quota storage src = quotaMap[id][srcStoremanGroupId];\r\n            if (src._asset == 0) {\r\n                continue;\r\n            }\r\n            Quota storage dst = quotaMap[id][dstStoremanGroupId];\r\n            /// Adjust quota record\r\n            dst.asset_receivable = dst.asset_receivable.sub(src.asset_payable);\r\n            dst._asset = dst._asset.add(src._asset);\r\n\r\n            src.asset_payable = 0;\r\n            src._asset = 0;\r\n        }\r\n    }\r\n\r\n    /// @notice                                 source storeman group revoke the debt transaction,update the detailed quota info. of the storeman group\r\n    /// @param srcStoremanGroupId               PK of source storeman group\r\n    /// @param dstStoremanGroupId               PK of destination storeman group\r\n    function assetRevoke(\r\n        bytes32 srcStoremanGroupId,\r\n        bytes32 dstStoremanGroupId\r\n    ) external onlyHtlc {\r\n        uint tokenCount = storemanTokenCountMap[srcStoremanGroupId];\r\n        for (uint i = 0; i < tokenCount; i++) {\r\n            uint id = storemanTokensMap[srcStoremanGroupId][i];\r\n            Quota storage src = quotaMap[id][srcStoremanGroupId];\r\n            if (src._asset == 0) {\r\n                continue;\r\n            }\r\n            Quota storage dst = quotaMap[id][dstStoremanGroupId];\r\n            \r\n            dst.asset_receivable = dst.asset_receivable.sub(src.asset_payable);\r\n            src.asset_payable = 0;\r\n        }\r\n    }\r\n\r\n    /// @notice                                 get user mint quota of storeman, tokenId\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    function getUserMintQuota(uint tokenId, bytes32 storemanGroupId)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        string memory symbol;\r\n        uint decimals;\r\n        uint tokenPrice;\r\n\r\n        (symbol, decimals) = getTokenAncestorInfo(tokenId);\r\n        tokenPrice = getPrice(symbol);\r\n        if (tokenPrice == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint fiatQuota = getUserFiatMintQuota(storemanGroupId, symbol);\r\n\r\n        return fiatQuota.div(tokenPrice).mul(10**decimals).div(1 ether);\r\n    }\r\n\r\n    /// @notice                                 get smg mint quota of storeman, tokenId\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    function getSmgMintQuota(uint tokenId, bytes32 storemanGroupId)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        string memory symbol;\r\n        uint decimals;\r\n        uint tokenPrice;\r\n\r\n        (symbol, decimals) = getTokenAncestorInfo(tokenId);\r\n        tokenPrice = getPrice(symbol);\r\n        if (tokenPrice == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint fiatQuota = getSmgFiatMintQuota(storemanGroupId, symbol);\r\n\r\n        return fiatQuota.div(tokenPrice).mul(10**decimals).div(1 ether);\r\n    }\r\n\r\n    /// @notice                                 get user burn quota of storeman, tokenId\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    function getUserBurnQuota(uint tokenId, bytes32 storemanGroupId)\r\n        public\r\n        view\r\n        returns (uint burnQuota)\r\n    {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        burnQuota = quota._debt.sub(quota.debt_payable);\r\n    }\r\n\r\n    /// @notice                                 get smg burn quota of storeman, tokenId\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    function getSmgBurnQuota(uint tokenId, bytes32 storemanGroupId)\r\n        public\r\n        view\r\n        returns (uint burnQuota)\r\n    {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        burnQuota = quota._asset.sub(quota.asset_payable);\r\n    }\r\n\r\n    /// @notice                                 get asset of storeman, tokenId\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    function getAsset(uint tokenId, bytes32 storemanGroupId)\r\n        public\r\n        view\r\n        returns (uint asset, uint asset_receivable, uint asset_payable)\r\n    {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        return (quota._asset, quota.asset_receivable, quota.asset_payable);\r\n    }\r\n\r\n    /// @notice                                 get debt of storeman, tokenId\r\n    /// @param tokenId                          tokenPairId of crosschain\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    function getDebt(uint tokenId, bytes32 storemanGroupId)\r\n        public\r\n        view\r\n        returns (uint debt, uint debt_receivable, uint debt_payable)\r\n    {\r\n        Quota storage quota = quotaMap[tokenId][storemanGroupId];\r\n        return (quota._debt, quota.debt_receivable, quota.debt_payable);\r\n    }\r\n\r\n    /// @notice                                 get debt clean state of storeman\r\n    /// @param storemanGroupId                  PK of source storeman group\r\n    function isDebtClean(bytes32 storemanGroupId) external view returns (bool) {\r\n        uint tokenCount = storemanTokenCountMap[storemanGroupId];\r\n        if (tokenCount == 0) {\r\n            if (debtOracleAddress == address(0)) {\r\n                return true;\r\n            } else {\r\n                IDebtOracle debtOracle = IDebtOracle(debtOracleAddress);\r\n                return debtOracle.isDebtClean(storemanGroupId);\r\n            }\r\n        }\r\n\r\n        for (uint i = 0; i < tokenCount; i++) {\r\n            uint id = storemanTokensMap[storemanGroupId][i];\r\n            Quota storage src = quotaMap[id][storemanGroupId];\r\n            if (src._debt > 0 || src.debt_payable > 0 || src.debt_receivable > 0) {\r\n                return false;\r\n            }\r\n\r\n            if (src._asset > 0 || src.asset_payable > 0 || src.asset_receivable > 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev get minimize token count for fast cross chain\r\n    function getFastMinCount(uint tokenId) public view returns (uint, string, uint, uint, uint) {\r\n        if (fastCrossMinValue == 0) {\r\n            return (0, \"\", 0, 0, 0);\r\n        }\r\n        string memory symbol;\r\n        uint decimals;\r\n        (symbol, decimals) = getTokenAncestorInfo(tokenId);\r\n        uint price = getPrice(symbol);\r\n        uint count = fastCrossMinValue.mul(10**decimals).div(price);\r\n        return (fastCrossMinValue, symbol, decimals, price, count);\r\n    }\r\n\r\n    // ----------- Private Functions ---------------\r\n\r\n\r\n\r\n    /// @notice                                 get storeman group's deposit value in USD\r\n    /// @param storemanGroupId                  storeman group ID\r\n    function getFiatDeposit(bytes32 storemanGroupId) private view returns (uint) {\r\n        uint deposit = getDepositAmount(storemanGroupId);\r\n        return deposit.mul(getPrice(depositTokenSymbol));\r\n    }\r\n\r\n    /// get mint quota in Fiat/USD decimals: 18\r\n    function getUserFiatMintQuota(bytes32 storemanGroupId, string rawSymbol) private view returns (uint) {\r\n        string memory symbol;\r\n        uint decimals;\r\n\r\n        uint totalTokenUsedValue = 0;\r\n        for (uint i = 0; i < storemanTokenCountMap[storemanGroupId]; i++) {\r\n            uint id = storemanTokensMap[storemanGroupId][i];\r\n            (symbol, decimals) = getTokenAncestorInfo(id);\r\n            Quota storage q = quotaMap[id][storemanGroupId];\r\n            uint tokenValue = q.asset_receivable.add(q._asset).mul(getPrice(symbol)).mul(1 ether).div(10**decimals); /// change Decimals to 18 digits\r\n            totalTokenUsedValue = totalTokenUsedValue.add(tokenValue);\r\n        }\r\n        \r\n        return getLastDeposit(storemanGroupId, rawSymbol, totalTokenUsedValue);\r\n    }\r\n\r\n    function getLastDeposit(bytes32 storemanGroupId, string rawSymbol, uint totalTokenUsedValue) private view returns (uint depositValue) {\r\n        // keccak256(\"WAN\") = 0x28ba6d5ac5913a399cc20b18c5316ad1459ae671dd23558d05943d54c61d0997\r\n        if (keccak256(rawSymbol) == bytes32(0x28ba6d5ac5913a399cc20b18c5316ad1459ae671dd23558d05943d54c61d0997)) {\r\n            depositValue = getFiatDeposit(storemanGroupId);\r\n        } else {\r\n            depositValue = getFiatDeposit(storemanGroupId).mul(DENOMINATOR).div(depositRate); // 15000 = 150%\r\n        }\r\n\r\n        if (depositValue <= totalTokenUsedValue) {\r\n            depositValue = 0;\r\n        } else {\r\n            depositValue = depositValue.sub(totalTokenUsedValue); /// decimals: 18\r\n        }\r\n    }\r\n\r\n    /// get mint quota in Fiat/USD decimals: 18\r\n    function getSmgFiatMintQuota(bytes32 storemanGroupId, string rawSymbol) private view returns (uint) {\r\n        string memory symbol;\r\n        uint decimals;\r\n\r\n        uint totalTokenUsedValue = 0;\r\n        for (uint i = 0; i < storemanTokenCountMap[storemanGroupId]; i++) {\r\n            uint id = storemanTokensMap[storemanGroupId][i];\r\n            (symbol, decimals) = getTokenAncestorInfo(id);\r\n            Quota storage q = quotaMap[id][storemanGroupId];\r\n            uint tokenValue = q.debt_receivable.add(q._debt).mul(getPrice(symbol)).mul(1 ether).div(10**decimals); /// change Decimals to 18 digits\r\n            totalTokenUsedValue = totalTokenUsedValue.add(tokenValue);\r\n        }\r\n\r\n        uint depositValue = 0;\r\n        if (keccak256(rawSymbol) == keccak256(\"WAN\")) {\r\n            depositValue = getFiatDeposit(storemanGroupId);\r\n        } else {\r\n            depositValue = getFiatDeposit(storemanGroupId).mul(DENOMINATOR).div(depositRate); // 15000 = 150%\r\n        }\r\n\r\n        if (depositValue <= totalTokenUsedValue) {\r\n            return 0;\r\n        }\r\n\r\n        return depositValue.sub(totalTokenUsedValue); /// decimals: 18\r\n    }\r\n\r\n    function getDepositAmount(bytes32 storemanGroupId)\r\n        private\r\n        view\r\n        returns (uint)\r\n    {\r\n        _IStoremanGroup smgAdmin = _IStoremanGroup(depositOracleAddress);\r\n        return smgAdmin.getDeposit(storemanGroupId);\r\n    }\r\n\r\n    function getTokenAncestorInfo(uint tokenId)\r\n        private\r\n        view\r\n        returns (string ancestorSymbol, uint decimals)\r\n    {\r\n        _ITokenManager tokenManager = _ITokenManager(tokenManagerAddress);\r\n        (ancestorSymbol,decimals) = tokenManager.getAncestorSymbol(tokenId);\r\n    }\r\n\r\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    function getPrice(string symbol) private view returns (uint price) {\r\n        IOracle oracle = IOracle(priceOracleAddress);\r\n        price = oracle.getValue(stringToBytes32(symbol));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"smgBurnRevoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcStoremanGroupId\",\"type\":\"bytes32\"},{\"name\":\"dstStoremanGroupId\",\"type\":\"bytes32\"}],\"name\":\"debtLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"smgFastMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"userMintRevoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"}],\"name\":\"getUserMintQuota\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"smgMintRevoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"smgBurnRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"}],\"name\":\"getSmgBurnQuota\",\"outputs\":[{\"name\":\"burnQuota\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"}],\"name\":\"getSmgMintQuota\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"}],\"name\":\"getDebt\",\"outputs\":[{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"debt_receivable\",\"type\":\"uint256\"},{\"name\":\"debt_payable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_priceOracleAddr\",\"type\":\"address\"},{\"name\":\"_htlcAddr\",\"type\":\"address\"},{\"name\":\"_fastHtlcAddr\",\"type\":\"address\"},{\"name\":\"_depositOracleAddr\",\"type\":\"address\"},{\"name\":\"_tokenManagerAddress\",\"type\":\"address\"},{\"name\":\"_depositRate\",\"type\":\"uint256\"},{\"name\":\"_depositTokenSymbol\",\"type\":\"string\"}],\"name\":\"config\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcStoremanGroupId\",\"type\":\"bytes32\"},{\"name\":\"dstStoremanGroupId\",\"type\":\"bytes32\"}],\"name\":\"assetLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"}],\"name\":\"isDebtClean\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcStoremanGroupId\",\"type\":\"bytes32\"},{\"name\":\"dstStoremanGroupId\",\"type\":\"bytes32\"}],\"name\":\"debtRevoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fastCrossMinValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"}],\"name\":\"getAsset\",\"outputs\":[{\"name\":\"asset\",\"type\":\"uint256\"},{\"name\":\"asset_receivable\",\"type\":\"uint256\"},{\"name\":\"asset_payable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"userMintRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"userFastMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcStoremanGroupId\",\"type\":\"bytes32\"},{\"name\":\"dstStoremanGroupId\",\"type\":\"bytes32\"}],\"name\":\"assetRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"userFastBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"smgFastBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"userMintLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"smgMintRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debtOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"userBurnRevoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcStoremanGroupId\",\"type\":\"bytes32\"},{\"name\":\"dstStoremanGroupId\",\"type\":\"bytes32\"}],\"name\":\"debtRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"userBurnLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setFastCrossMinValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"setDebtOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"smgMintLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcStoremanGroupId\",\"type\":\"bytes32\"},{\"name\":\"dstStoremanGroupId\",\"type\":\"bytes32\"}],\"name\":\"assetRevoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenManagerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"smgBurnLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"userBurnRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositTokenSymbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"storemanGroupId\",\"type\":\"bytes32\"}],\"name\":\"getUserBurnQuota\",\"outputs\":[{\"name\":\"burnQuota\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"htlcGroupMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"halt\",\"type\":\"bool\"}],\"name\":\"setHalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getFastMinCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"QuotaDelegate","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://308948335adde9f271af0cf3eac44d49691ae0f5cde8fbce7b9c5b42c0944920"}]}