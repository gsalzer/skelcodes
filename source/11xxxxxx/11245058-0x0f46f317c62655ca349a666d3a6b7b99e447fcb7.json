{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Arbrito.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.4;\\n\\nimport \\\"./external/IBalancer.sol\\\";\\nimport \\\"./external/IUniswap.sol\\\";\\nimport \\\"./external/IERC20.sol\\\";\\n\\ncontract Arbrito is IUniswapPairCallee {\\n  function perform(\\n    bool direction,\\n    uint256 amount,\\n    address uniswapPair,\\n    address balancerPool\\n  ) external {\\n    (uint256 amount0, uint256 amount1) = direction\\n      ? (amount, uint256(0))\\n      : (uint256(0), amount);\\n\\n    bytes memory payload = abi.encode(balancerPool, msg.sender);\\n    IUniswapPair(uniswapPair).swap(amount0, amount1, address(this), payload);\\n  }\\n\\n  function uniswapV2Call(\\n    address, // sender\\n    uint256 amount0,\\n    uint256 amount1,\\n    bytes calldata data\\n  ) external override {\\n    (address balancerPoolAddress, address ownerAddress) = abi.decode(\\n      data,\\n      (address, address)\\n    );\\n    IBalancerPool balancerPool = IBalancerPool(balancerPoolAddress);\\n    IUniswapPair uniswapPair = IUniswapPair(msg.sender);\\n\\n    uint256 amountTrade;\\n    uint256 amountPayback;\\n\\n    uint256 reservePayback;\\n    uint256 reserveTrade;\\n\\n    address tokenPayback;\\n    address tokenTrade;\\n\\n    if (amount0 != 0) {\\n      (reserveTrade, reservePayback, ) = uniswapPair.getReserves();\\n      tokenPayback = uniswapPair.token1();\\n      tokenTrade = uniswapPair.token0();\\n      amountTrade = amount0;\\n    } else {\\n      (reservePayback, reserveTrade, ) = uniswapPair.getReserves();\\n      tokenPayback = uniswapPair.token0();\\n      tokenTrade = uniswapPair.token1();\\n      amountTrade = amount1;\\n    }\\n\\n    amountPayback = calculateUniswapPayback(\\n      amountTrade,\\n      reservePayback,\\n      reserveTrade\\n    );\\n\\n    IERC20(tokenTrade).approve(balancerPoolAddress, amountTrade);\\n\\n    (uint256 balancerAmountOut, ) = balancerPool.swapExactAmountIn(\\n      tokenTrade,\\n      amountTrade,\\n      tokenPayback,\\n      amountPayback,\\n      uint256(-1)\\n    );\\n\\n    require(\\n      IERC20(tokenPayback).transfer(msg.sender, amountPayback),\\n      \\\"Payback failed\\\"\\n    );\\n\\n    require(\\n      IERC20(tokenPayback).transfer(\\n        ownerAddress,\\n        balancerAmountOut - amountPayback\\n      ),\\n      \\\"Sender transfer failed\\\"\\n    );\\n  }\\n\\n  function calculateUniswapPayback(\\n    uint256 amountOut,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) internal pure returns (uint256) {\\n    uint256 numerator = reserveIn * amountOut * 1000;\\n    uint256 denominator = (reserveOut - amountOut) * 997;\\n    return numerator / denominator + 1;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external/IBalancer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.4;\\n\\ninterface IBalancerPool {\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n}\\n\"\r\n    },\r\n    \"contracts/external/IUniswap.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.4;\\n\\ninterface IUniswapPairCallee {\\n  function uniswapV2Call(\\n    address sender,\\n    uint256 amount0,\\n    uint256 amount1,\\n    bytes calldata data\\n  ) external;\\n}\\n\\ninterface IUniswapPair {\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function swap(\\n    uint256 amount0Out,\\n    uint256 amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/external/IERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.4;\\n\\ninterface IERC20 {\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"test/external/Uniswap.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.4;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../contracts/external/IUniswap.sol\\\";\\n\\ncontract Uniswap is IUniswapPair {\\n  address token0address;\\n  address token1address;\\n  uint112 reserve0;\\n  uint112 reserve1;\\n\\n  constructor(address _token0, address _token1) {\\n    token0address = _token0;\\n    token1address = _token1;\\n  }\\n\\n  function token0() external view override returns (address) {\\n    return token0address;\\n  }\\n\\n  function token1() external view override returns (address) {\\n    return token1address;\\n  }\\n\\n  function getReserves()\\n    external\\n    view\\n    override\\n    returns (\\n      uint112,\\n      uint112,\\n      uint32\\n    )\\n  {\\n    return (reserve0, reserve1, 0);\\n  }\\n\\n  function refreshReserves() external {\\n    address me = address(this);\\n    reserve0 = uint112(IERC20(token0address).balanceOf(me));\\n    reserve1 = uint112(IERC20(token1address).balanceOf(me));\\n  }\\n\\n  function swap(\\n    uint256 amount0,\\n    uint256 amount1,\\n    address receiver,\\n    bytes calldata payload\\n  ) external override {\\n    require(payload.length != 0, \\\"Unsupported payload\\\");\\n    require(\\n      (amount0 == 0 && amount1 != 0) || (amount0 != 0 && amount1 == 0),\\n      \\\"Unsupported amounts\\\"\\n    );\\n\\n    IERC20 tokenLent;\\n    IERC20 tokenPayback;\\n    uint256 amountLent;\\n\\n    if (amount0 != 0) {\\n      tokenLent = IERC20(token0address);\\n      tokenPayback = IERC20(token1address);\\n      amountLent = amount0;\\n      require(IERC20(token0address).transfer(receiver, amount0), \\\"loan failed\\\");\\n    } else {\\n      tokenLent = IERC20(token1address);\\n      tokenPayback = IERC20(token0address);\\n      amountLent = amount1;\\n      require(IERC20(token1address).transfer(receiver, amount1), \\\"loan failed\\\");\\n    }\\n\\n    address me = address(this);\\n    uint256 tokenLentBalance = tokenLent.balanceOf(me);\\n    uint256 tokenPaybackBalance = tokenPayback.balanceOf(me);\\n\\n    IUniswapPairCallee(msg.sender).uniswapV2Call(\\n      msg.sender,\\n      amount0,\\n      amount1,\\n      payload\\n    );\\n\\n    reserve0 -= uint112(amount0);\\n    reserve1 -= uint112(amount1);\\n\\n    require(tokenLent.balanceOf(me) == tokenLentBalance, \\\"unsupported payback\\\");\\n\\n    uint256 tokenPaybackBalanceAfter = tokenPayback.balanceOf(me);\\n    require(tokenPaybackBalanceAfter > tokenPaybackBalance, \\\"missing payback\\\");\\n\\n    uint256 amountPaidBack = tokenPaybackBalanceAfter - tokenPaybackBalance;\\n    uint256 balance0Adjusted = tokenPaybackBalanceAfter *\\n      1000 -\\n      amountPaidBack *\\n      3;\\n    uint256 balance1Adjusted = tokenLentBalance;\\n    require(\\n      balance0Adjusted * balance1Adjusted >=\\n        (tokenLentBalance + amountLent) * tokenPaybackBalance * 1000,\\n      \\\"payback mismatch\\\"\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"test/external/IERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.4;\\n\\ninterface IERC20 {\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\\ncontract ERC20 is IERC20 {\\n  mapping(address => uint256) balances;\\n  mapping(address => mapping(address => uint256)) allowances;\\n\\n  function balanceOf(address account) external view override returns (uint256) {\\n    return balances[account];\\n  }\\n\\n  function transfer(address recipient, uint256 amount)\\n    external\\n    override\\n    returns (bool)\\n  {\\n    if (balances[msg.sender] < amount) {\\n      return false;\\n    }\\n\\n    balances[msg.sender] -= amount;\\n    balances[recipient] += amount;\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external override returns (bool) {\\n    require(allowances[sender][msg.sender] >= amount, \\\"No allowance\\\");\\n    allowances[sender][msg.sender] -= amount;\\n\\n    if (balances[sender] < amount) {\\n      return false;\\n    }\\n\\n    balances[sender] -= amount;\\n    balances[recipient] += amount;\\n    return true;\\n  }\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount)\\n    external\\n    override\\n    returns (bool)\\n  {\\n    allowances[msg.sender][spender] = amount;\\n    return true;\\n  }\\n}\\n\\ncontract ERC20Mintable is ERC20 {\\n  function mint(address account, uint256 amount) external {\\n    balances[account] += amount;\\n  }\\n}\\n\"\r\n    },\r\n    \"test/external/Balancer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.4;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../contracts/external/IBalancer.sol\\\";\\n\\ncontract Balancer is IBalancerPool {\\n  function swapExactAmountIn(\\n    address _tokenIn,\\n    uint256 _tokenAmountIn,\\n    address _tokenOut,\\n    uint256 _minAmountOut,\\n    uint256 _maxPrice\\n  ) external override returns (uint256, uint256) {\\n    require(_maxPrice == uint256(-1), \\\"Unsupported maxPrice\\\");\\n\\n    address me = address(this);\\n    IERC20 tokenIn = IERC20(_tokenIn);\\n    IERC20 tokenOut = IERC20(_tokenOut);\\n\\n    uint256 tokenAmountOut = (10**18 * tokenOut.balanceOf(me) * _tokenAmountIn);\\n    tokenAmountOut /= (10**18 * tokenIn.balanceOf(me));\\n\\n    require(tokenAmountOut > _minAmountOut, \\\"Insufficient amount out\\\");\\n\\n    require(\\n      tokenIn.transferFrom(msg.sender, me, _tokenAmountIn),\\n      \\\"Transfer in failed\\\"\\n    );\\n\\n    require(\\n      tokenOut.transfer(msg.sender, tokenAmountOut),\\n      \\\"Transfer out failed\\\"\\n    );\\n\\n    return (tokenAmountOut, 0);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"direction\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapPair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balancerPool\",\"type\":\"address\"}],\"name\":\"perform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Arbrito","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}