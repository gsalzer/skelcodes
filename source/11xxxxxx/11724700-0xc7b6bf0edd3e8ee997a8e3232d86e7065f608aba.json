{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/X2ETHMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./libraries/math/SafeMath.sol\\\";\\nimport \\\"./libraries/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./libraries/token/IERC20.sol\\\";\\n\\nimport \\\"./interfaces/IX2ETHFactory.sol\\\";\\nimport \\\"./interfaces/IX2PriceFeed.sol\\\";\\nimport \\\"./interfaces/IX2Token.sol\\\";\\nimport \\\"./interfaces/IX2Market.sol\\\";\\n\\ncontract X2ETHMarket is ReentrancyGuard, IX2Market {\\n    using SafeMath for uint256;\\n\\n    // use a single storage slot\\n    // max uint128 has 38 digits so it can support the INITIAL_REBASE_DIVISOR\\n    // increasing by 10^28 times\\n    uint128 public override cachedBullDivisor;\\n    uint128 public override cachedBearDivisor;\\n\\n    uint256 public constant FEE_BASIS_POINTS = 20; // 0.2% fee\\n    uint256 public constant MAX_APP_FEE_BASIS_POINTS = 20; // 0.2% max app fee\\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\\n    // X2Token.balance uses uint128, max uint128 has 38 digits\\n    // with an initial rebase divisor of 10^10\\n    // and 18 decimals for ETH, collateral of up to 10 billion ETH\\n    // can be supported\\n    uint128 public constant INITIAL_REBASE_DIVISOR = 10**10;\\n    uint256 public constant MAX_DIVISOR = uint128(-1);\\n\\n    uint256 public constant FUNDING_INTERVAL = 1 hours;\\n    uint256 public constant MIN_FUNDING_DIVISOR = 500;\\n    uint256 public constant MAX_FUNDING_DIVISOR = 1000000;\\n\\n    address public factory;\\n\\n    address public override bullToken;\\n    address public override bearToken;\\n    address public priceFeed;\\n    uint256 public multiplierBasisPoints;\\n    uint256 public maxProfitBasisPoints;\\n    uint256 public feeReserve;\\n\\n    uint256 public appFeeBasisPoints;\\n    uint256 public appFeeReserve;\\n\\n    uint256 public fundingDivisor;\\n    uint256 public lastFundingTime;\\n\\n    uint256 public override lastPrice;\\n\\n    bool public isInitialized;\\n\\n    mapping (address => uint256) public appFees;\\n\\n    event DistributeFees(address feeReceiver, uint256 amount);\\n    event DistributeInterest(address feeReceiver, uint256 amount);\\n    event Rebase(uint256 price, uint128 bullDivisor, uint128 bearDivisor);\\n\\n    modifier onlyFactory() {\\n        require(msg.sender == factory, \\\"X2ETHMarket: forbidden\\\");\\n        _;\\n    }\\n\\n    function initialize(\\n        address _factory,\\n        address _priceFeed,\\n        uint256 _multiplierBasisPoints,\\n        uint256 _maxProfitBasisPoints,\\n        uint256 _fundingDivisor,\\n        uint256 _appFeeBasisPoints\\n    ) public {\\n        require(!isInitialized, \\\"X2ETHMarket: already initialized\\\");\\n        require(_maxProfitBasisPoints <= BASIS_POINTS_DIVISOR, \\\"X2ETHMarket: maxProfitBasisPoints limit exceeded\\\");\\n        isInitialized = true;\\n\\n        factory = _factory;\\n        priceFeed = _priceFeed;\\n        multiplierBasisPoints = _multiplierBasisPoints;\\n        maxProfitBasisPoints = _maxProfitBasisPoints;\\n        setFunding(_fundingDivisor);\\n        setAppFee(_appFeeBasisPoints);\\n\\n        lastPrice = uint176(latestPrice());\\n        require(lastPrice != 0, \\\"X2ETHMarket: unsupported price feed\\\");\\n\\n        _updateLastFundingTime();\\n    }\\n\\n    function setAppFee(uint256 _appFeeBasisPoints) public override onlyFactory {\\n        require(_appFeeBasisPoints <= MAX_APP_FEE_BASIS_POINTS, \\\"X2ETHMarket: fee limit exceeded\\\");\\n        appFeeBasisPoints = _appFeeBasisPoints;\\n    }\\n\\n    function setFunding(uint256 _fundingDivisor) public override onlyFactory {\\n        require(_fundingDivisor >= MIN_FUNDING_DIVISOR && _fundingDivisor <= MAX_FUNDING_DIVISOR, \\\"X2ETHMarket: funding range exceeded\\\");\\n        fundingDivisor = _fundingDivisor;\\n    }\\n\\n    function setBullToken(address _bullToken) public onlyFactory {\\n        require(bullToken == address(0), \\\"X2ETHMarket: bullToken already set\\\");\\n        bullToken = _bullToken;\\n        cachedBullDivisor = INITIAL_REBASE_DIVISOR;\\n    }\\n\\n    function setBearToken(address _bearToken) public onlyFactory {\\n        require(bearToken == address(0), \\\"X2ETHMarket: bearToken already set\\\");\\n        bearToken = _bearToken;\\n        cachedBearDivisor = INITIAL_REBASE_DIVISOR;\\n    }\\n\\n    function buy(address _token, address _appFeeReceiver) public payable nonReentrant returns (uint256) {\\n        return _buy(_token, msg.sender, _appFeeReceiver);\\n    }\\n\\n    function sell(address _token, uint256 _sellPoints, address _receiver, address _appFeeReceiver) public nonReentrant returns (uint256) {\\n        return _sell(_token, _sellPoints, _receiver, true, _appFeeReceiver);\\n    }\\n\\n    // since an X2Token's distributor can be set by the factory's gov,\\n    // the market should allow an option to sell the token without invoking\\n    // the distributor\\n    // this ensures that tokens can always be sold even if the distributor\\n    // is set to an address that intentionally fails when `distribute` is called\\n    function sellWithoutDistribution(address _token, uint256 _sellPoints, address _receiver) public nonReentrant returns (uint256) {\\n        return _sell(_token, _sellPoints, _receiver, false, address(0));\\n    }\\n\\n    function flip(address _token, uint256 _flipPoints, address _appFeeReceiver) public nonReentrant returns (uint256) {\\n        return _flip(_token, _flipPoints, msg.sender, _appFeeReceiver);\\n    }\\n\\n    function rebase() public returns (bool) {\\n        uint256 _lastPrice = uint256(lastPrice);\\n        uint256 nextPrice = latestPrice();\\n        uint256 intervals = block.timestamp.sub(lastFundingTime).div(FUNDING_INTERVAL);\\n        if (_lastPrice == nextPrice && intervals == 0) { return false; }\\n\\n        (uint256 nextBullDivisor, uint256 nextBearDivisor) = getDivisors(_lastPrice, nextPrice);\\n\\n        lastPrice = nextPrice;\\n        cachedBullDivisor = uint128(nextBullDivisor);\\n        cachedBearDivisor = uint128(nextBearDivisor);\\n        if (intervals > 0) {\\n            _updateLastFundingTime();\\n        }\\n\\n        emit Rebase(nextPrice, uint128(nextBullDivisor), uint128(nextBearDivisor));\\n        return true;\\n    }\\n\\n    function distributeFees() public nonReentrant returns (uint256) {\\n        address feeReceiver = IX2ETHFactory(factory).feeReceiver();\\n        require(feeReceiver != address(0), \\\"X2Market: empty feeReceiver\\\");\\n\\n        uint256 fees = feeReserve;\\n        feeReserve = 0;\\n\\n        (bool success,) = feeReceiver.call{value: fees}(\\\"\\\");\\n        require(success, \\\"X2ETHMarket: transfer failed\\\");\\n\\n        emit DistributeFees(feeReceiver, fees);\\n\\n        return fees;\\n    }\\n\\n    function distributeAppFees(address _appFeeReceiver) public nonReentrant returns (uint256) {\\n        require(_appFeeReceiver != address(0), \\\"X2Market: empty feeReceiver\\\");\\n\\n        uint256 fees = appFees[_appFeeReceiver];\\n        if (fees == 0) { return 0; }\\n\\n        appFeeReserve = appFeeReserve.sub(fees);\\n        appFees[_appFeeReceiver] = 0;\\n\\n        (bool success,) = _appFeeReceiver.call{value: fees}(\\\"\\\");\\n        require(success, \\\"X2ETHMarket: transfer failed\\\");\\n\\n        emit DistributeFees(_appFeeReceiver, fees);\\n\\n        return fees;\\n    }\\n\\n    function distributeInterest() public nonReentrant returns (uint256) {\\n        address interestReceiver = IX2ETHFactory(factory).interestReceiver();\\n        require(interestReceiver != address(0), \\\"X2Market: empty interestReceiver\\\");\\n\\n        uint256 interest = interestReserve();\\n\\n        (bool success,) = interestReceiver.call{value: interest}(\\\"\\\");\\n        require(success, \\\"X2ETHMarket: transfer failed\\\");\\n\\n        emit DistributeInterest(interestReceiver, interest);\\n\\n        return interest;\\n    }\\n\\n    function interestReserve() public view returns (uint256) {\\n        uint256 bullRefSupply = IX2Token(bullToken)._totalSupply();\\n        uint256 bearRefSupply = IX2Token(bearToken)._totalSupply();\\n\\n        // the actual underlying supplies\\n        uint256 totalBulls = bullRefSupply.div(cachedBullDivisor);\\n        uint256 totalBears = bearRefSupply.div(cachedBearDivisor);\\n\\n        uint256 balance = address(this).balance;\\n        return balance.sub(totalBulls).sub(totalBears).sub(feeReserve).sub(appFeeReserve);\\n    }\\n\\n    function getDivisor(address _token) public override view returns (uint256) {\\n        bool isBull = _token == bullToken;\\n        uint256 _lastPrice = uint256(lastPrice);\\n        uint256 nextPrice = latestPrice();\\n        uint256 intervals = block.timestamp.sub(lastFundingTime).div(FUNDING_INTERVAL);\\n\\n        if (_lastPrice == nextPrice && intervals == 0) {\\n            return isBull ? cachedBullDivisor : cachedBearDivisor;\\n        }\\n\\n        (uint256 nextBullDivisor, uint256 nextBearDivisor) = getDivisors(_lastPrice, nextPrice);\\n        return isBull ? nextBullDivisor : nextBearDivisor;\\n    }\\n\\n    function latestPrice() public override view returns (uint256) {\\n        int256 answer = IX2PriceFeed(priceFeed).latestAnswer();\\n        // avoid negative or zero values being returned\\n        if (answer <= 0) {\\n            return uint256(lastPrice);\\n        }\\n        return uint256(answer);\\n    }\\n\\n    function getFunding() public override view returns (uint256, uint256) {\\n        uint256 _lastPrice = uint256(lastPrice);\\n        uint256 nextPrice = latestPrice();\\n        (uint256 nextBullDivisor, uint256 nextBearDivisor) = getDivisors(_lastPrice, nextPrice);\\n\\n        uint256 totalBulls = IX2Token(bullToken)._totalSupply().div(nextBullDivisor);\\n        uint256 totalBears = IX2Token(bearToken)._totalSupply().div(nextBearDivisor);\\n\\n        if (totalBulls > totalBears && totalBears > 0) {\\n            uint256 funding = totalBulls.sub(totalBears).div(fundingDivisor);\\n            return (funding, 0);\\n        }\\n\\n        if (totalBears > totalBulls && totalBulls > 0) {\\n            uint256 funding = totalBears.sub(totalBulls).div(fundingDivisor);\\n            return (0, funding);\\n        }\\n\\n        return (0, 0);\\n    }\\n\\n    function getDivisors(uint256 _lastPrice, uint256 _nextPrice) public override view returns (uint256, uint256) {\\n        uint256 bullRefSupply = IX2Token(bullToken)._totalSupply();\\n        uint256 bearRefSupply = IX2Token(bearToken)._totalSupply();\\n\\n        // the actual underlying supplies\\n        uint256 totalBulls = bullRefSupply.div(cachedBullDivisor);\\n        uint256 totalBears = bearRefSupply.div(cachedBearDivisor);\\n\\n        // scope variables to avoid stack too deep errors\\n        {\\n        // refSupply is the smaller of the two supplies\\n        uint256 refSupply = totalBulls < totalBears ? totalBulls : totalBears;\\n        uint256 delta = _nextPrice > _lastPrice ? _nextPrice.sub(_lastPrice) : _lastPrice.sub(_nextPrice);\\n        // profit is [(smaller supply) * (change in price) / (last price)] * multiplierBasisPoints\\n        uint256 profit = refSupply.mul(delta).div(_lastPrice).mul(multiplierBasisPoints).div(BASIS_POINTS_DIVISOR);\\n\\n        // cap the profit to the (max profit percentage) of the smaller supply\\n        uint256 maxProfit = refSupply.mul(maxProfitBasisPoints).div(BASIS_POINTS_DIVISOR);\\n        if (profit > maxProfit) { profit = maxProfit; }\\n\\n        totalBulls = _nextPrice > _lastPrice ? totalBulls.add(profit) : totalBulls.sub(profit);\\n        totalBears = _nextPrice > _lastPrice ? totalBears.sub(profit) : totalBears.add(profit);\\n        }\\n\\n        {\\n        uint256 intervals = block.timestamp.sub(lastFundingTime).div(FUNDING_INTERVAL);\\n        if (intervals > 0) {\\n            if (totalBulls > totalBears && totalBears > 0) {\\n                uint256 funding = totalBulls.sub(totalBears).div(fundingDivisor).mul(intervals);\\n                totalBulls = totalBulls.sub(funding);\\n                totalBears = totalBears.add(funding);\\n            }\\n            if (totalBears > totalBulls && totalBulls > 0) {\\n                uint256 funding = totalBears.sub(totalBulls).div(fundingDivisor).mul(intervals);\\n                totalBears = totalBears.sub(funding);\\n                totalBulls = totalBulls.add(funding);\\n            }\\n        }\\n        }\\n\\n        return (_getNextDivisor(bullRefSupply, totalBulls, cachedBullDivisor), _getNextDivisor(bearRefSupply, totalBears, cachedBearDivisor));\\n    }\\n\\n    function _updateLastFundingTime() private {\\n        lastFundingTime = block.timestamp;\\n    }\\n\\n    function _getNextDivisor(uint256 _refSupply, uint256 _nextSupply, uint256 _fallbackDivisor) private pure returns (uint256) {\\n        if (_nextSupply == 0) {\\n            return INITIAL_REBASE_DIVISOR;\\n        }\\n\\n        // round up the divisor\\n        uint256 divisor = _refSupply.mul(10).div(_nextSupply).add(9).div(10);\\n        // prevent the cachedDivisor from overflowing or being set to 0\\n        if (divisor == 0 || divisor > MAX_DIVISOR) { return _fallbackDivisor; }\\n\\n        return divisor;\\n    }\\n\\n    function _collectFees(uint256 _amount) private returns (uint256) {\\n        uint256 fee = _amount.mul(FEE_BASIS_POINTS).div(BASIS_POINTS_DIVISOR);\\n        feeReserve = feeReserve.add(fee);\\n        return fee;\\n    }\\n\\n    function _collectAppFees(uint256 _amount, address _appFeeReceiver) private returns (uint256) {\\n        if (appFeeBasisPoints == 0) {\\n            return 0;\\n        }\\n        uint256 fee = _amount.mul(appFeeBasisPoints).div(BASIS_POINTS_DIVISOR);\\n        appFees[_appFeeReceiver] = appFees[_appFeeReceiver].add(fee);\\n        appFeeReserve = appFeeReserve.add(fee);\\n        return fee;\\n    }\\n\\n    function _buy(address _token, address _receiver, address _appFeeReceiver) private returns (uint256) {\\n        bool isBull = _token == bullToken;\\n        require(isBull || _token == bearToken, \\\"X2ETHMarket: unsupported token\\\");\\n        uint256 amount = msg.value;\\n        require(amount > 0, \\\"X2ETHMarket: insufficient collateral sent\\\");\\n\\n        rebase();\\n\\n        uint256 fee = _collectFees(amount);\\n        uint256 appFee = _appFeeReceiver == address(0) ? 0 : _collectAppFees(amount, _appFeeReceiver);\\n        uint256 depositAmount = amount.sub(fee).sub(appFee);\\n\\n        IX2Token(_token).mint(_receiver, depositAmount, isBull ? cachedBullDivisor : cachedBearDivisor);\\n\\n        return depositAmount;\\n    }\\n\\n    function _sell(address _token, uint256 _sellPoints, address _receiver, bool _distribute, address _appFeeReceiver) private returns (uint256) {\\n        require(_sellPoints > 0, \\\"X2ETHMarket: insufficient amount\\\");\\n        require(_token == bullToken || _token == bearToken, \\\"X2ETHMarket: unsupported token\\\");\\n        rebase();\\n\\n        uint256 amount = IX2Token(_token).burn(msg.sender, _sellPoints, _distribute);\\n\\n        uint256 fee = _collectFees(amount);\\n        uint256 appFee = _appFeeReceiver == address(0) ? 0 : _collectAppFees(amount, _appFeeReceiver);\\n\\n        uint256 withdrawAmount = amount.sub(fee).sub(appFee);\\n        (bool success,) = _receiver.call{value: withdrawAmount}(\\\"\\\");\\n        require(success, \\\"X2ETHMarket: transfer failed\\\");\\n\\n        return withdrawAmount;\\n    }\\n\\n    function _flip(address _token, uint256 _flipPoints, address _receiver, address _appFeeReceiver) private returns (uint256) {\\n        require(_flipPoints > 0, \\\"X2ETHMarket: insufficient amount\\\");\\n\\n        bool sellBull = _token == bullToken;\\n        require(sellBull || _token == bearToken, \\\"X2ETHMarket: unsupported token\\\");\\n        rebase();\\n\\n        uint256 amount = IX2Token(_token).burn(msg.sender, _flipPoints, true);\\n\\n        uint256 fee = _collectFees(amount);\\n        uint256 appFee = _appFeeReceiver == address(0) ? 0 : _collectAppFees(amount, _appFeeReceiver);\\n        uint256 flipAmount = amount.sub(fee).sub(appFee);\\n\\n        // if bull tokens were burnt then mint bear tokens\\n        // if bear tokens were burnt then mint bull tokens\\n        IX2Token(sellBull ? bearToken : bullToken).mint(\\n            _receiver,\\n            flipAmount,\\n            sellBull ? cachedBearDivisor : cachedBullDivisor\\n        );\\n\\n        return flipAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IX2ETHFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IX2ETHFactory {\\n    function feeReceiver() external view returns (address);\\n    function interestReceiver() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IX2PriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IX2PriceFeed {\\n    function latestAnswer() external view returns (int256);\\n    function latestRound() external view returns (uint80);\\n    function getRoundData(uint80 roundId) external view returns (uint80, int256, uint256, uint256, uint80);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IX2Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IX2Token {\\n    function cumulativeRewardPerToken() external view returns (uint256);\\n    function lastBoughtAt(address account) external view returns (uint256);\\n    function getPendingProfit(address account) external view returns (uint256);\\n    function distributor() external view returns (address);\\n    function rewardToken() external view returns (address);\\n    function _totalSupply() external view returns (uint256);\\n    function _balanceOf(address account) external view returns (uint256);\\n    function market() external view returns (address);\\n    function getDivisor() external view returns (uint256);\\n    function getReward(address account) external view returns (uint256);\\n    function costOf(address account) external view returns (uint256);\\n    function mint(address account, uint256 amount, uint256 divisor) external;\\n    function burn(address account, uint256 amount, bool distribute) external returns (uint256);\\n    function setDistributor(address _distributor, address _rewardToken) external;\\n    function setInfo(string memory name, string memory symbol) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IX2Market.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IX2Market {\\n    function bullToken() external view returns (address);\\n    function bearToken() external view returns (address);\\n    function latestPrice() external view returns (uint256);\\n    function lastPrice() external view returns (uint256);\\n    function getFunding() external view returns (uint256, uint256);\\n    function getDivisor(address token) external view returns (uint256);\\n    function getDivisors(uint256 _lastPrice, uint256 _nextPrice) external view returns (uint256, uint256);\\n    function setAppFee(uint256 feeBasisPoints) external;\\n    function setFunding(uint256 divisor) external;\\n    function cachedBullDivisor() external view returns (uint128);\\n    function cachedBearDivisor() external view returns (uint128);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"bullDivisor\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"bearDivisor\",\"type\":\"uint128\"}],\"name\":\"Rebase\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASIS_POINTS_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_BASIS_POINTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUNDING_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_REBASE_DIVISOR\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_APP_FEE_BASIS_POINTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FUNDING_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FUNDING_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"appFeeBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"appFeeReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"appFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bearToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bullToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_appFeeReceiver\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cachedBearDivisor\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cachedBullDivisor\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_appFeeReceiver\",\"type\":\"address\"}],\"name\":\"distributeAppFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_flipPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_appFeeReceiver\",\"type\":\"address\"}],\"name\":\"flip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lastPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"name\":\"getDivisors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFunding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_multiplierBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxProfitBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fundingDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_appFeeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastFundingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProfitBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiplierBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sellPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_appFeeReceiver\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sellPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"sellWithoutDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_appFeeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setAppFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bearToken\",\"type\":\"address\"}],\"name\":\"setBearToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bullToken\",\"type\":\"address\"}],\"name\":\"setBullToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fundingDivisor\",\"type\":\"uint256\"}],\"name\":\"setFunding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"X2ETHMarket","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}