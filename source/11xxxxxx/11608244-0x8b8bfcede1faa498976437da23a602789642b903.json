{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"pragma solidity \\u003e= 0.6.4;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n  function mint(address account, uint256 amount) external;\\n  function burn(uint256 amount) external;\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"ownable.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\ncontract Owned is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"priceAggregatorInterface.sol\":{\"content\":\"pragma solidity \\u003e= 0.6.6;\\n\\ninterface priceAggregatorInterface {\\n  function registerVaultAggregator(address oracle) external;\\n  function priceRequest(\\n    address vault,\\n    uint256 lastUpdated\\n  )\\n  external\\n  view\\n  returns(int256[] memory, uint256);\\n  function roundIdCheck(address vault) external view returns(bool);\\n}\\n\"},\"priceCalculator.sol\":{\"content\":\"//////////////////////////////////////////////////\\n//SYNLEV Price Calculator Contract V 1.3\\n//////////////////////////\\n\\npragma solidity \\u003e= 0.6.6;\\n\\nimport \\u0027./ownable.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./SignedSafeMath.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./vaultInterface.sol\\u0027;\\nimport \\u0027./priceAggregatorInterface.sol\\u0027;\\n\\ncontract priceCalculator is Owned {\\n  using SafeMath for uint256;\\n  using SignedSafeMath for int256;\\n\\n  constructor() public {\\n    lossLimit = 9 * 10**8;\\n    kControl = 15 * 10**8;\\n    proposeDelay = 2 days;\\n    proposeDelayPropose = 2 days;\\n    priceAggregator = priceAggregatorInterface(0x717584a1DC53DAFddE10b9819601A7082536E79e);\\n  }\\n\\n  uint256 public constant uSmallFactor = 10**9;\\n  int256 public constant smallFactor = 10**9;\\n\\n  uint256 public lossLimit;\\n  uint256 public kControl;\\n  priceAggregatorInterface public priceAggregator;\\n  address public priceAggregatorPropose;\\n  uint256 public priceAggregatorProposeTimestamp;\\n\\n  uint256 public proposeDelay;\\n  uint256 public proposeDelayPropose;\\n  uint256 public proposeDelayTimestamp;\\n\\n  /*\\n   * @notice Calculates the most recent price data.\\n   * @dev If there is no new price data it returns current price/equity data.\\n   * Safety checks are done by SynLev price aggregator. All calcualtions done\\n   * via equity in ETH, not price to avoid rounding errors. Caculates price\\n   * based on the \\\"losing side\\\", then subracts from the other. Mitigates a\\n   * prefrence in rounding error to either bull or bear tokens.\\n   */\\n  function getUpdatedPrice(address vault, uint256 latestRoundId)\\n  public\\n  view\\n  returns(\\n    uint256[6] memory latestPrice,\\n    uint256 rRoundId,\\n    bool updated\\n  ) {\\n    //Requests price data from price aggregator proxy\\n    (\\n      int256[] memory priceData,\\n      uint256 roundId\\n    ) = priceAggregator.priceRequest(vault, latestRoundId);\\n    vaultInterface ivault = vaultInterface(vault);\\n    address bull = ivault.getBullToken();\\n    address bear = ivault.getBearToken();\\n    uint256 bullEquity = ivault.getTokenEquity(bull);\\n    uint256 bearEquity = ivault.getTokenEquity(bear);\\n    //Only update if price data if price array contains 2 or more values\\n    //If there is no new price data pricedate array will have 0 length\\n    if(priceData.length \\u003e 0 \\u0026\\u0026 bullEquity != 0 \\u0026\\u0026 bearEquity != 0) {\\n      (uint256 rBullEquity, uint256 rBearEquity) = priceCalc(priceData, bullEquity, bearEquity, ivault);\\n      uint256[6] memory data = equityToReturnData(bull, bear, rBullEquity, rBearEquity, ivault);\\n      return(data, roundId, true);\\n    }\\n    else {\\n      return(\\n        [ivault.getPrice(bull),\\n        ivault.getPrice(bear),\\n        ivault.getLiqEquity(bull),\\n        ivault.getLiqEquity(bear),\\n        ivault.getEquity(bull),\\n        ivault.getEquity(bear)],\\n        roundId,\\n        false\\n      );\\n    }\\n  }\\n\\n  function priceCalc(\\n    int256[] memory priceData,\\n    uint256 bullEquity,\\n    uint256 bearEquity,\\n    vaultInterface ivault\\n    )\\n    public\\n    view\\n    returns(uint256 rBullEquity, uint256 rBearEquity)\\n    {\\n      uint256 multiplier = ivault.getMultiplier();\\n      uint256 totalEquity = ivault.getTotalEquity();\\n      uint256 movement;\\n      uint256 bearKFactor = getKFactor(bearEquity, bullEquity, bearEquity, totalEquity);\\n      uint256 bullKFactor = getKFactor(bullEquity, bullEquity, bearEquity, totalEquity);\\n      int256  signedPriceDelta;\\n      uint256 pricedelta;\\n\\n      if(priceData[0] != priceData[1]) {\\n        //Treats 0 price value as 1, 0 causes divides by 0 error\\n        if(priceData[0] == 0) priceData[0] = 1;\\n        //Bearish movement, calc equity from the perspective of bull\\n        if(priceData[0] \\u003e priceData[1]) {\\n          //Gets price change in absolute terms.\\n          signedPriceDelta = priceData[0].sub(priceData[1]);\\n          signedPriceDelta = signedPriceDelta.mul(smallFactor);\\n          signedPriceDelta = signedPriceDelta.div(priceData[0]);\\n          pricedelta = uint256(signedPriceDelta);\\n\\n          //Converts price change to be in terms of bull equity change\\n          //As a percentage\\n          pricedelta = pricedelta.mul(multiplier.mul(bullKFactor)).div(uSmallFactor);\\n          //Dont allow loss to be greater than set loss limit\\n          pricedelta = pricedelta \\u003c lossLimit ? pricedelta : lossLimit;\\n          //Calculate equity loss of bull equity\\n          movement = bullEquity.mul(pricedelta);\\n          movement = movement.div(uSmallFactor);\\n          //Adds equity movement to running bear euqity and removes that\\n          //Loss from running bull equity\\n          bearEquity = bearEquity.add(movement);\\n          bullEquity = totalEquity.sub(bearEquity);\\n        }\\n        //Bullish movement, calc equity from the perspective of bear\\n        //Same process as above. only from bear perspective\\n        else if(priceData[0] \\u003c priceData[1]) {\\n\\n          signedPriceDelta = priceData[1].sub(priceData[0]);\\n          signedPriceDelta = signedPriceDelta.mul(smallFactor);\\n          signedPriceDelta = signedPriceDelta.div(priceData[0]);\\n          pricedelta = uint256(signedPriceDelta);\\n\\n          pricedelta = pricedelta.mul(multiplier.mul(bearKFactor)).div(uSmallFactor);\\n          pricedelta = pricedelta \\u003c lossLimit ? pricedelta : lossLimit;\\n          movement = bearEquity.mul(pricedelta);\\n          movement = movement.div(uSmallFactor);\\n          bullEquity = bullEquity.add(movement);\\n          bearEquity = totalEquity.sub(bullEquity);\\n        }\\n      }\\n\\n      return(bullEquity, bearEquity);\\n  }\\n\\n  function equityToReturnData(\\n    address bull,\\n    address bear,\\n    uint256 bullEquity,\\n    uint256 bearEquity,\\n    vaultInterface ivault\\n    )\\n    public\\n    view\\n    returns(uint256[6] memory)\\n  {\\n      uint256 bullPrice =\\n        bullEquity\\n        .mul(1 ether)\\n        .div(IERC20(bull).totalSupply().add(ivault.getLiqTokens(bull)));\\n      uint256 bearPrice =\\n        bearEquity\\n        .mul(1 ether)\\n        .div(IERC20(bear).totalSupply().add(ivault.getLiqTokens(bear)));\\n      uint256 bullTokenEquity =\\n        bullPrice\\n        .mul(IERC20(bull).totalSupply())\\n        .div(1 ether);\\n      uint256 bearTokenEquity =\\n        bearPrice\\n        .mul(IERC20(bear).totalSupply())\\n        .div(1 ether);\\n\\n      return([\\n        bullPrice,\\n        bearPrice,\\n        bullEquity.sub(bullTokenEquity),\\n        bearEquity.sub(bearTokenEquity),\\n        bullTokenEquity,\\n        bearTokenEquity\\n      ]);\\n  }\\n\\n\\n  /*\\n   * @notice Calculates k factor of selected token. K factor is the multiplier\\n   * that adjusts the leverage level to maintain 100% liquidty at all times.\\n   * @dev K factor is scaled 10^9. A K factor of 1 represents a 1:1 ratio of\\n   * bull and bear equity.\\n   * @param targetEquity The total euqity of the target bull token\\n   * @param bullEquity The total equity bull tokens\\n   * @param bearEquity The total equity bear tokens\\n   * @param totalEquity The total equity of bull and bear tokens\\n   * @return K factor\\n   */\\n  function getKFactor(\\n    uint256 targetEquity,\\n    uint256 bullEquity,\\n    uint256 bearEquity,\\n    uint256 totalEquity\\n  )\\n  public\\n  view\\n  returns(uint256) {\\n    //If either token has 0 equity k value is 0\\n    if(bullEquity  == 0 || bearEquity == 0) {\\n      return(0);\\n    }\\n    else {\\n      //Avoids divides by 0 error\\n      targetEquity = targetEquity \\u003e 0 ? targetEquity : 1;\\n      uint256 kFactor =\\n        totalEquity.mul(10**9).div(targetEquity.mul(2)) \\u003c kControl ?\\n        totalEquity.mul(10**9).div(targetEquity.mul(2)): kControl;\\n      return(kFactor);\\n    }\\n  }\\n\\n  ///////////////////\\n  //ADMIN FUNCTIONS//\\n  ///////////////////\\n  function setLossLimit(uint256 amount) public onlyOwner() {\\n    lossLimit = amount;\\n  }\\n  function setkControl(uint256 amount) public onlyOwner() {\\n    kControl = amount;\\n  }\\n  function proposeVaultPriceAggregator(address account) public onlyOwner() {\\n    priceAggregatorPropose = account;\\n    priceAggregatorProposeTimestamp = block.timestamp;\\n  }\\n  function updateVaultPriceAggregator() public onlyOwner() {\\n    require(priceAggregatorPropose != address(0));\\n    require(priceAggregatorProposeTimestamp + proposeDelay \\u003c= block.timestamp);\\n    priceAggregator = priceAggregatorInterface(priceAggregatorPropose);\\n    priceAggregatorPropose = address(0);\\n  }\\n\\n  function proposeProposeDelay(uint256 delay) public onlyOwner() {\\n    proposeDelayPropose = delay;\\n    proposeDelayTimestamp = block.timestamp;\\n  }\\n  function updateProposeDelay() public onlyOwner() {\\n    require(proposeDelayPropose != 0);\\n    require(proposeDelayTimestamp + proposeDelay \\u003c= block.timestamp);\\n    proposeDelay = proposeDelayPropose;\\n    proposeDelayPropose = 0;\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 \\u0026\\u0026 b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 \\u0026\\u0026 a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"},\"vaultInterface.sol\":{\"content\":\"pragma solidity \\u003e= 0.6.6;\\n\\ninterface vaultInterface {\\n  function tokenBuy(address token, address account) external;\\n  function tokenSell(address token, address payable account) external;\\n  function addLiquidity(address account) external;\\n  function removeLiquidity(uint256 shares) external;\\n  function updatePrice() external;\\n\\n  function getActive() external view returns(bool);\\n  function getMultiplier() external view returns(uint256);\\n  function getBullToken() external view returns(address);\\n  function getBearToken() external view returns(address);\\n  function getLatestRoundId() external view returns(uint256);\\n  function getPrice(address token) external view returns(uint256);\\n  function getEquity(address token) external view returns(uint256);\\n  function getBuyFee() external view returns(uint256);\\n  function getSellFee() external view returns(uint256);\\n  function getTotalLiqShares() external view returns(uint256);\\n  function getLiqFees() external view returns(uint256);\\n  function getBalanceEquity() external view returns(uint256);\\n  function getLiqTokens(address token) external view returns(uint256);\\n  function getLiqEquity(address token) external view returns(uint256);\\n  function getUserShares(address account) external view returns(uint256);\\n\\n  function getTotalEquity() external view returns(uint256);\\n  function getTokenEquity(address token) external view returns(uint256);\\n  function getTotalLiqEquity() external view returns(uint256);\\n  function getDepositEquity() external view returns(uint256);\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bull\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bear\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bullEquity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bearEquity\",\"type\":\"uint256\"},{\"internalType\":\"contract vaultInterface\",\"name\":\"ivault\",\"type\":\"address\"}],\"name\":\"equityToReturnData\",\"outputs\":[{\"internalType\":\"uint256[6]\",\"name\":\"\",\"type\":\"uint256[6]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetEquity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bullEquity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bearEquity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEquity\",\"type\":\"uint256\"}],\"name\":\"getKFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"latestRoundId\",\"type\":\"uint256\"}],\"name\":\"getUpdatedPrice\",\"outputs\":[{\"internalType\":\"uint256[6]\",\"name\":\"latestPrice\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256\",\"name\":\"rRoundId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"updated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kControl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lossLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceAggregator\",\"outputs\":[{\"internalType\":\"contract priceAggregatorInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceAggregatorPropose\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceAggregatorProposeTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256[]\",\"name\":\"priceData\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"bullEquity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bearEquity\",\"type\":\"uint256\"},{\"internalType\":\"contract vaultInterface\",\"name\":\"ivault\",\"type\":\"address\"}],\"name\":\"priceCalc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rBullEquity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rBearEquity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposeDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposeDelayPropose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposeDelayTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"proposeProposeDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"proposeVaultPriceAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setLossLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setkControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smallFactor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uSmallFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateProposeDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateVaultPriceAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"priceCalculator","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://478490f783081482e5ae7c30008a8e330dd85a792e800483af4d2a3ed3ad49e2"}]}