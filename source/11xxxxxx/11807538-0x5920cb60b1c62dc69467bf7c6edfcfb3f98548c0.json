{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PremiaOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\r\\nimport '@openzeppelin/contracts/utils/SafeCast.sol';\\r\\n\\r\\nimport \\\"./interface/IERC20Extended.sol\\\";\\r\\nimport \\\"./interface/IFeeCalculator.sol\\\";\\r\\nimport \\\"./interface/IFlashLoanReceiver.sol\\\";\\r\\nimport \\\"./interface/IPremiaReferral.sol\\\";\\r\\nimport \\\"./interface/IPremiaUncutErc20.sol\\\";\\r\\n\\r\\nimport \\\"./uniswapV2/interfaces/IUniswapV2Router02.sol\\\";\\r\\n\\r\\n\\r\\n/// @author Premia\\r\\n/// @title An option contract\\r\\ncontract PremiaOption is Ownable, ERC1155, ReentrancyGuard {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    struct OptionWriteArgs {\\r\\n        address token;                  // Token address\\r\\n        uint256 amount;                 // Amount of tokens to write option for\\r\\n        uint256 strikePrice;            // Strike price (Must follow strikePriceIncrement of token)\\r\\n        uint256 expiration;             // Expiration timestamp of the option (Must follow expirationIncrement)\\r\\n        bool isCall;                    // If true : Call option | If false : Put option\\r\\n    }\\r\\n\\r\\n    struct OptionData {\\r\\n        address token;                  // Token address\\r\\n        uint256 strikePrice;            // Strike price (Must follow strikePriceIncrement of token)\\r\\n        uint256 expiration;             // Expiration timestamp of the option (Must follow expirationIncrement)\\r\\n        bool isCall;                    // If true : Call option | If false : Put option\\r\\n        uint256 claimsPreExp;           // Amount of options from which the funds have been withdrawn pre expiration\\r\\n        uint256 claimsPostExp;          // Amount of options from which the funds have been withdrawn post expiration\\r\\n        uint256 exercised;              // Amount of options which have been exercised\\r\\n        uint256 supply;                 // Total circulating supply\\r\\n        uint8 decimals;                 // Token decimals\\r\\n    }\\r\\n\\r\\n    // Total write cost = collateral + fee + feeReferrer\\r\\n    struct QuoteWrite {\\r\\n        address collateralToken;        // The token to deposit as collateral\\r\\n        uint256 collateral;             // The amount of collateral to deposit\\r\\n        uint8 collateralDecimals;       // Decimals of collateral token\\r\\n        uint256 fee;                    // The amount of collateralToken needed to be paid as protocol fee\\r\\n        uint256 feeReferrer;            // The amount of collateralToken which will be paid the referrer\\r\\n    }\\r\\n\\r\\n    // Total exercise cost = input + fee + feeReferrer\\r\\n    struct QuoteExercise {\\r\\n        address inputToken;             // Input token for exercise\\r\\n        uint256 input;                  // Amount of input token to pay to exercise\\r\\n        uint8 inputDecimals;            // Decimals of input token\\r\\n        address outputToken;            // Output token from the exercise\\r\\n        uint256 output;                 // Amount of output tokens which will be received on exercise\\r\\n        uint8 outputDecimals;           // Decimals of output token\\r\\n        uint256 fee;                    // The amount of inputToken needed to be paid as protocol fee\\r\\n        uint256 feeReferrer;            // The amount of inputToken which will be paid to the referrer\\r\\n    }\\r\\n\\r\\n    struct Pool {\\r\\n        uint256 tokenAmount;            // The amount of tokens in the option pool\\r\\n        uint256 denominatorAmount;      // The amounts of denominator in the option pool\\r\\n    }\\r\\n\\r\\n    IERC20 public denominator;\\r\\n    uint8 public denominatorDecimals;\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    // Address receiving protocol fees (PremiaMaker)\\r\\n    address public feeRecipient;\\r\\n\\r\\n    // PremiaReferral contract\\r\\n    IPremiaReferral public premiaReferral;\\r\\n    // The uPremia token\\r\\n    IPremiaUncutErc20 public uPremia;\\r\\n    // FeeCalculator contract\\r\\n    IFeeCalculator public feeCalculator;\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    // Whitelisted tokens for which options can be written (Each token must also have a non 0 strike price increment to be enabled)\\r\\n    address[] public tokens;\\r\\n    // Strike price increment mapping of each token\\r\\n    mapping (address => uint256) public tokenStrikeIncrement;\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    // The option id of next option type which will be created\\r\\n    uint256 public nextOptionId = 1;\\r\\n\\r\\n    // Offset to add to Unix timestamp to make it Fri 23:59:59 UTC\\r\\n    uint256 private constant _baseExpiration = 172799;\\r\\n    // Expiration increment\\r\\n    uint256 private constant _expirationIncrement = 1 weeks;\\r\\n    // Max expiration time from now\\r\\n    uint256 public maxExpiration = 365 days;\\r\\n\\r\\n    // Uniswap routers allowed to be used for swap from flashExercise\\r\\n    address[] public whitelistedUniswapRouters;\\r\\n\\r\\n    // token => expiration => strikePrice => isCall (1 for call, 0 for put) => optionId\\r\\n    mapping (address => mapping(uint256 => mapping(uint256 => mapping (bool => uint256)))) public options;\\r\\n\\r\\n    // optionId => OptionData\\r\\n    mapping (uint256 => OptionData) public optionData;\\r\\n\\r\\n    // optionId => Pool\\r\\n    mapping (uint256 => Pool) public pools;\\r\\n\\r\\n    // account => optionId => amount of options written\\r\\n    mapping (address => mapping (uint256 => uint256)) public nbWritten;\\r\\n\\r\\n    ////////////\\r\\n    // Events //\\r\\n    ////////////\\r\\n\\r\\n    event SetToken(address indexed token, uint256 strikePriceIncrement);\\r\\n    event OptionIdCreated(uint256 indexed optionId, address indexed token);\\r\\n    event OptionWritten(address indexed owner, uint256 indexed optionId, address indexed token, uint256 amount);\\r\\n    event OptionCancelled(address indexed owner, uint256 indexed optionId, address indexed token, uint256 amount);\\r\\n    event OptionExercised(address indexed user, uint256 indexed optionId, address indexed token, uint256 amount);\\r\\n    event Withdraw(address indexed user, uint256 indexed optionId, address indexed token, uint256 amount);\\r\\n    event FeePaid(address indexed user, address indexed token, address indexed referrer, uint256 feeProtocol, uint256 feeReferrer);\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    /// @param _uri URI of ERC1155 metadata\\r\\n    /// @param _denominator The token used as denominator\\r\\n    /// @param _uPremia The uPremia token\\r\\n    /// @param _feeCalculator FeeCalculator contract\\r\\n    /// @param _premiaReferral PremiaReferral contract\\r\\n    /// @param _feeRecipient Recipient of protocol fees (PremiaMaker)\\r\\n    constructor(string memory _uri, IERC20 _denominator, IPremiaUncutErc20 _uPremia, IFeeCalculator _feeCalculator,\\r\\n        IPremiaReferral _premiaReferral, address _feeRecipient) ERC1155(_uri) {\\r\\n        denominator = _denominator;\\r\\n        uPremia = _uPremia;\\r\\n        feeCalculator = _feeCalculator;\\r\\n        feeRecipient = _feeRecipient;\\r\\n        premiaReferral = _premiaReferral;\\r\\n        denominatorDecimals = IERC20Extended(address(_denominator)).decimals();\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    ///////////////\\r\\n    // Modifiers //\\r\\n    ///////////////\\r\\n\\r\\n    modifier notExpired(uint256 _optionId) {\\r\\n        require(block.timestamp < optionData[_optionId].expiration, \\\"Expired\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier expired(uint256 _optionId) {\\r\\n        require(block.timestamp >= optionData[_optionId].expiration, \\\"Not expired\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    ///////////\\r\\n    // Admin //\\r\\n    ///////////\\r\\n\\r\\n    /// @notice Set new URI for ERC1155 metadata\\r\\n    /// @param _newUri The new URI\\r\\n    function setURI(string memory _newUri) external onlyOwner {\\r\\n        _setURI(_newUri);\\r\\n    }\\r\\n\\r\\n    /// @notice Set new protocol fee recipient\\r\\n    /// @param _feeRecipient The new protocol fee recipient\\r\\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\\r\\n        feeRecipient = _feeRecipient;\\r\\n    }\\r\\n\\r\\n    /// @notice Set a new max expiration date for options writing (By default, 1 year from current date)\\r\\n    /// @param _max The max amount of seconds in the future for which an option expiration can be set\\r\\n    function setMaxExpiration(uint256 _max) external onlyOwner {\\r\\n        maxExpiration = _max;\\r\\n    }\\r\\n\\r\\n    /// @notice Set a new PremiaReferral contract\\r\\n    /// @param _premiaReferral The new PremiaReferral Contract\\r\\n    function setPremiaReferral(IPremiaReferral _premiaReferral) external onlyOwner {\\r\\n        premiaReferral = _premiaReferral;\\r\\n    }\\r\\n\\r\\n    /// @notice Set a new PremiaUncut contract\\r\\n    /// @param _uPremia The new PremiaUncut Contract\\r\\n    function setPremiaUncutErc20(IPremiaUncutErc20 _uPremia) external onlyOwner {\\r\\n        uPremia = _uPremia;\\r\\n    }\\r\\n\\r\\n    /// @notice Set a new FeeCalculator contract\\r\\n    /// @param _feeCalculator The new FeeCalculator Contract\\r\\n    function setFeeCalculator(IFeeCalculator _feeCalculator) external onlyOwner {\\r\\n        feeCalculator = _feeCalculator;\\r\\n    }\\r\\n\\r\\n    /// @notice Set settings for tokens to support writing of options paired to denominator\\r\\n    /// @dev A value of 0 means this token is disabled and options cannot be written for it\\r\\n    /// @param _tokens The list of tokens for which to set strike price increment\\r\\n    /// @param _strikePriceIncrement The new strike price increment to set for each token\\r\\n    function setTokens(address[] memory _tokens, uint256[] memory _strikePriceIncrement) external onlyOwner {\\r\\n        require(_tokens.length == _strikePriceIncrement.length);\\r\\n\\r\\n        for (uint256 i=0; i < _tokens.length; i++) {\\r\\n            if (!_isInArray(_tokens[i], tokens)) {\\r\\n                tokens.push(_tokens[i]);\\r\\n            }\\r\\n\\r\\n            require(_tokens[i] != address(denominator), \\\"Cant add denominator\\\");\\r\\n            tokenStrikeIncrement[_tokens[i]] = _strikePriceIncrement[i];\\r\\n\\r\\n            emit SetToken(_tokens[i], _strikePriceIncrement[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Set a new list of whitelisted UniswapRouter contracts allowed to be used for flashExercise\\r\\n    /// @param _addrList The new list of whitelisted routers\\r\\n    function setWhitelistedUniswapRouters(address[] memory _addrList) external onlyOwner {\\r\\n        delete whitelistedUniswapRouters;\\r\\n\\r\\n        for (uint256 i=0; i < _addrList.length; i++) {\\r\\n            whitelistedUniswapRouters.push(_addrList[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    //////////\\r\\n    // View //\\r\\n    //////////\\r\\n\\r\\n    /// @notice Get the id of an option\\r\\n    /// @param _token Token for which the option is for\\r\\n    /// @param _expiration Expiration timestamp of the option\\r\\n    /// @param _strikePrice Strike price of the option\\r\\n    /// @param _isCall Whether the option is a call or a put\\r\\n    /// @return The option id\\r\\n    function getOptionId(address _token, uint256 _expiration, uint256 _strikePrice, bool _isCall) public view returns(uint256) {\\r\\n        return options[_token][_expiration][_strikePrice][_isCall];\\r\\n    }\\r\\n\\r\\n    /// @notice Get the amount of whitelisted tokens\\r\\n    /// @return The amount of whitelisted tokens\\r\\n    function tokensLength() external view returns(uint256) {\\r\\n        return tokens.length;\\r\\n    }\\r\\n\\r\\n    /// @notice Get a quote to write an option\\r\\n    /// @param _from Address which will write the option\\r\\n    /// @param _option The option to write\\r\\n    /// @param _referrer Referrer\\r\\n    /// @param _decimals The option token decimals\\r\\n    /// @return The quote\\r\\n    function getWriteQuote(address _from, OptionWriteArgs memory _option, address _referrer, uint8 _decimals) public view returns(QuoteWrite memory) {\\r\\n        QuoteWrite memory quote;\\r\\n\\r\\n        if (_option.isCall) {\\r\\n            quote.collateralToken = _option.token;\\r\\n            quote.collateral = _option.amount;\\r\\n            quote.collateralDecimals = _decimals;\\r\\n        } else {\\r\\n            quote.collateralToken = address(denominator);\\r\\n            quote.collateral = _option.amount.mul(_option.strikePrice).div(10**_decimals);\\r\\n            quote.collateralDecimals = denominatorDecimals;\\r\\n        }\\r\\n\\r\\n        (uint256 fee, uint256 feeReferrer) = feeCalculator.getFeeAmounts(_from, _referrer != address(0), quote.collateral, IFeeCalculator.FeeType.Write);\\r\\n        quote.fee = fee;\\r\\n        quote.feeReferrer = feeReferrer;\\r\\n\\r\\n        return quote;\\r\\n    }\\r\\n\\r\\n    /// @notice Get a quote to exercise an option\\r\\n    /// @param _from Address which will exercise the option\\r\\n    /// @param _option The option to exercise\\r\\n    /// @param _referrer Referrer\\r\\n    /// @param _decimals The option token decimals\\r\\n    /// @return The quote\\r\\n    function getExerciseQuote(address _from, OptionData memory _option, uint256 _amount, address _referrer, uint8 _decimals) public view returns(QuoteExercise memory) {\\r\\n        QuoteExercise memory quote;\\r\\n\\r\\n        uint256 tokenAmount = _amount;\\r\\n        uint256 denominatorAmount = _amount.mul(_option.strikePrice).div(10**_decimals);\\r\\n\\r\\n        if (_option.isCall) {\\r\\n            quote.inputToken = address(denominator);\\r\\n            quote.input = denominatorAmount;\\r\\n            quote.inputDecimals = denominatorDecimals;\\r\\n            quote.outputToken = _option.token;\\r\\n            quote.output = tokenAmount;\\r\\n            quote.outputDecimals = _option.decimals;\\r\\n        } else {\\r\\n            quote.inputToken = _option.token;\\r\\n            quote.input = tokenAmount;\\r\\n            quote.inputDecimals = _option.decimals;\\r\\n            quote.outputToken = address(denominator);\\r\\n            quote.output = denominatorAmount;\\r\\n            quote.outputDecimals = denominatorDecimals;\\r\\n        }\\r\\n\\r\\n        (uint256 fee, uint256 feeReferrer) = feeCalculator.getFeeAmounts(_from, _referrer != address(0), quote.input, IFeeCalculator.FeeType.Exercise);\\r\\n        quote.fee = fee;\\r\\n        quote.feeReferrer = feeReferrer;\\r\\n\\r\\n        return quote;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    //////////\\r\\n    // Main //\\r\\n    //////////\\r\\n\\r\\n    /// @notice Get the id of the option, or create a new id if there is no existing id for it\\r\\n    /// @param _token Token for which the option is for\\r\\n    /// @param _expiration Expiration timestamp of the option\\r\\n    /// @param _strikePrice Strike price of the option\\r\\n    /// @param _isCall Whether the option is a call or a put\\r\\n    /// @return The option id\\r\\n    function getOptionIdOrCreate(address _token, uint256 _expiration, uint256 _strikePrice, bool _isCall) public returns(uint256) {\\r\\n        uint256 optionId = getOptionId(_token, _expiration, _strikePrice, _isCall);\\r\\n\\r\\n        if (optionId == 0) {\\r\\n            _preCheckOptionIdCreate(_token, _strikePrice, _expiration);\\r\\n\\r\\n            optionId = nextOptionId;\\r\\n            options[_token][_expiration][_strikePrice][_isCall] = optionId;\\r\\n            uint8 decimals = IERC20Extended(_token).decimals();\\r\\n            require(decimals <= 18, \\\"Too many decimals\\\");\\r\\n\\r\\n            pools[optionId] = Pool({ tokenAmount: 0, denominatorAmount: 0 });\\r\\n                optionData[optionId] = OptionData({\\r\\n                token: _token,\\r\\n                expiration: _expiration,\\r\\n                strikePrice: _strikePrice,\\r\\n                isCall: _isCall,\\r\\n                claimsPreExp: 0,\\r\\n                claimsPostExp: 0,\\r\\n                exercised: 0,\\r\\n                supply: 0,\\r\\n                decimals: decimals\\r\\n            });\\r\\n\\r\\n            emit OptionIdCreated(optionId, _token);\\r\\n\\r\\n            nextOptionId = nextOptionId.add(1);\\r\\n        }\\r\\n\\r\\n        return optionId;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    /// @notice Write an option on behalf of an address with an existing option id (Used by market delayed writing)\\r\\n    /// @dev Requires approval on option contract + token needed to write the option\\r\\n    /// @param _from Address on behalf of which the option is written\\r\\n    /// @param _optionId The id of the option to write\\r\\n    /// @param _amount Amount of options to write\\r\\n    /// @param _referrer Referrer\\r\\n    /// @return The option id\\r\\n    function writeOptionWithIdFrom(address _from, uint256 _optionId, uint256 _amount, address _referrer) external returns(uint256) {\\r\\n        require(isApprovedForAll(_from, msg.sender), \\\"Not approved\\\");\\r\\n\\r\\n        OptionData memory data = optionData[_optionId];\\r\\n        OptionWriteArgs memory writeArgs = OptionWriteArgs({\\r\\n        token: data.token,\\r\\n        amount: _amount,\\r\\n        strikePrice: data.strikePrice,\\r\\n        expiration: data.expiration,\\r\\n        isCall: data.isCall\\r\\n        });\\r\\n\\r\\n        return _writeOption(_from, writeArgs, _referrer);\\r\\n    }\\r\\n\\r\\n    /// @notice Write an option on behalf of an address\\r\\n    /// @dev Requires approval on option contract + token needed to write the option\\r\\n    /// @param _from Address on behalf of which the option is written\\r\\n    /// @param _option The option to write\\r\\n    /// @param _referrer Referrer\\r\\n    /// @return The option id\\r\\n    function writeOptionFrom(address _from, OptionWriteArgs memory _option, address _referrer) external returns(uint256) {\\r\\n        require(isApprovedForAll(_from, msg.sender), \\\"Not approved\\\");\\r\\n        return _writeOption(_from, _option, _referrer);\\r\\n    }\\r\\n\\r\\n    /// @notice Write an option\\r\\n    /// @param _option The option to write\\r\\n    /// @param _referrer Referrer\\r\\n    /// @return The option id\\r\\n    function writeOption(OptionWriteArgs memory _option, address _referrer) public returns(uint256) {\\r\\n        return _writeOption(msg.sender, _option, _referrer);\\r\\n    }\\r\\n\\r\\n    /// @notice Write an option on behalf of an address\\r\\n    /// @param _from Address on behalf of which the option is written\\r\\n    /// @param _option The option to write\\r\\n    /// @param _referrer Referrer\\r\\n    /// @return The option id\\r\\n    function _writeOption(address _from, OptionWriteArgs memory _option, address _referrer) internal nonReentrant returns(uint256) {\\r\\n        require(_option.amount > 0, \\\"Amount <= 0\\\");\\r\\n\\r\\n        uint256 optionId = getOptionIdOrCreate(_option.token, _option.expiration, _option.strikePrice, _option.isCall);\\r\\n\\r\\n        // Set referrer or get current if one already exists\\r\\n        _referrer = _trySetReferrer(_from, _referrer);\\r\\n\\r\\n        QuoteWrite memory quote = getWriteQuote(_from, _option, _referrer, optionData[optionId].decimals);\\r\\n\\r\\n        IERC20(quote.collateralToken).safeTransferFrom(_from, address(this), quote.collateral);\\r\\n        _payFees(_from, IERC20(quote.collateralToken), _referrer, quote.fee, quote.feeReferrer, quote.collateralDecimals);\\r\\n\\r\\n        if (_option.isCall) {\\r\\n            pools[optionId].tokenAmount = pools[optionId].tokenAmount.add(quote.collateral);\\r\\n        } else {\\r\\n            pools[optionId].denominatorAmount = pools[optionId].denominatorAmount.add(quote.collateral);\\r\\n        }\\r\\n\\r\\n        nbWritten[_from][optionId] = nbWritten[_from][optionId].add(_option.amount);\\r\\n\\r\\n        mint(_from, optionId, _option.amount);\\r\\n\\r\\n        emit OptionWritten(_from, optionId, _option.token, _option.amount);\\r\\n\\r\\n        return optionId;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    /// @notice Cancel an option on behalf of an address. This will burn the option ERC1155 and withdraw collateral.\\r\\n    /// @dev Requires approval of the option contract\\r\\n    ///      This is only doable by an address which wrote an amount of options >= _amount\\r\\n    ///      Must be called before expiration\\r\\n    /// @param _from Address on behalf of which the option is cancelled\\r\\n    /// @param _optionId The id of the option to cancel\\r\\n    /// @param _amount Amount to cancel\\r\\n    function cancelOptionFrom(address _from, uint256 _optionId, uint256 _amount) external {\\r\\n        require(isApprovedForAll(_from, msg.sender), \\\"Not approved\\\");\\r\\n        _cancelOption(_from, _optionId, _amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Cancel an option. This will burn the option ERC1155 and withdraw collateral.\\r\\n    /// @dev This is only doable by an address which wrote an amount of options >= _amount\\r\\n    ///      Must be called before expiration\\r\\n    /// @param _optionId The id of the option to cancel\\r\\n    /// @param _amount Amount to cancel\\r\\n    function cancelOption(uint256 _optionId, uint256 _amount) public {\\r\\n        _cancelOption(msg.sender, _optionId, _amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Cancel an option on behalf of an address. This will burn the option ERC1155 and withdraw collateral.\\r\\n    /// @dev This is only doable by an address which wrote an amount of options >= _amount\\r\\n    ///      Must be called before expiration\\r\\n    /// @param _from Address on behalf of which the option is cancelled\\r\\n    /// @param _optionId The id of the option to cancel\\r\\n    /// @param _amount Amount to cancel\\r\\n    function _cancelOption(address _from, uint256 _optionId, uint256 _amount) internal nonReentrant {\\r\\n        require(_amount > 0, \\\"Amount <= 0\\\");\\r\\n        require(nbWritten[_from][_optionId] >= _amount, \\\"Not enough written\\\");\\r\\n\\r\\n        burn(_from, _optionId, _amount);\\r\\n        nbWritten[_from][_optionId] = nbWritten[_from][_optionId].sub(_amount);\\r\\n\\r\\n        if (optionData[_optionId].isCall) {\\r\\n            pools[_optionId].tokenAmount = pools[_optionId].tokenAmount.sub(_amount);\\r\\n            IERC20(optionData[_optionId].token).safeTransfer(_from, _amount);\\r\\n        } else {\\r\\n            uint256 amount = _amount.mul(optionData[_optionId].strikePrice).div(10**optionData[_optionId].decimals);\\r\\n            pools[_optionId].denominatorAmount = pools[_optionId].denominatorAmount.sub(amount);\\r\\n            denominator.safeTransfer(_from, amount);\\r\\n        }\\r\\n\\r\\n        emit OptionCancelled(_from, _optionId, optionData[_optionId].token, _amount);\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    /// @notice Exercise an option on behalf of an address\\r\\n    /// @dev Requires approval of the option contract\\r\\n    /// @param _from Address on behalf of which the option will be exercised\\r\\n    /// @param _optionId The id of the option to exercise\\r\\n    /// @param _amount Amount to exercise\\r\\n    /// @param _referrer Referrer\\r\\n    function exerciseOptionFrom(address _from, uint256 _optionId, uint256 _amount, address _referrer) external {\\r\\n        require(isApprovedForAll(_from, msg.sender), \\\"Not approved\\\");\\r\\n        _exerciseOption(_from, _optionId, _amount, _referrer);\\r\\n    }\\r\\n\\r\\n    /// @notice Exercise an option\\r\\n    /// @param _optionId The id of the option to exercise\\r\\n    /// @param _amount Amount to exercise\\r\\n    /// @param _referrer Referrer\\r\\n    function exerciseOption(uint256 _optionId, uint256 _amount, address _referrer) public {\\r\\n        _exerciseOption(msg.sender, _optionId, _amount, _referrer);\\r\\n    }\\r\\n\\r\\n    /// @notice Exercise an option on behalf of an address\\r\\n    /// @param _from Address on behalf of which the option will be exercised\\r\\n    /// @param _optionId The id of the option to exercise\\r\\n    /// @param _amount Amount to exercise\\r\\n    /// @param _referrer Referrer\\r\\n    function _exerciseOption(address _from, uint256 _optionId, uint256 _amount, address _referrer) internal nonReentrant {\\r\\n        require(_amount > 0, \\\"Amount <= 0\\\");\\r\\n\\r\\n        OptionData storage data = optionData[_optionId];\\r\\n\\r\\n        burn(_from, _optionId, _amount);\\r\\n        data.exercised = uint256(data.exercised).add(_amount);\\r\\n\\r\\n        // Set referrer or get current if one already exists\\r\\n        _referrer = _trySetReferrer(_from, _referrer);\\r\\n\\r\\n        QuoteExercise memory quote = getExerciseQuote(_from, data, _amount, _referrer, data.decimals);\\r\\n        IERC20(quote.inputToken).safeTransferFrom(_from, address(this), quote.input);\\r\\n        _payFees(_from, IERC20(quote.inputToken), _referrer, quote.fee, quote.feeReferrer, quote.inputDecimals);\\r\\n\\r\\n        if (data.isCall) {\\r\\n            pools[_optionId].tokenAmount = pools[_optionId].tokenAmount.sub(quote.output);\\r\\n            pools[_optionId].denominatorAmount = pools[_optionId].denominatorAmount.add(quote.input);\\r\\n        } else {\\r\\n            pools[_optionId].denominatorAmount = pools[_optionId].denominatorAmount.sub(quote.output);\\r\\n            pools[_optionId].tokenAmount = pools[_optionId].tokenAmount.add(quote.input);\\r\\n        }\\r\\n\\r\\n        IERC20(quote.outputToken).safeTransfer(_from, quote.output);\\r\\n\\r\\n        emit OptionExercised(_from, _optionId, data.token, _amount);\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    /// @notice Withdraw collateral from an option post expiration on behalf of an address.\\r\\n    ///         (Funds will be send to the address on behalf of which withdrawal is made)\\r\\n    ///         Funds in the option pool will be distributed pro rata of amount of options written by the address\\r\\n    ///         Ex : If after expiration date there has been 10 options written and there is 1 eth and 1000 DAI in the pool,\\r\\n    ///              Withdraw for each option will be worth 0.1 eth and 100 dai\\r\\n    /// @dev Only callable by addresses which have unclaimed funds for options they wrote\\r\\n    ///      Requires approval of the option contract\\r\\n    /// @param _from Address on behalf of which the withdraw call is made (Which will receive the withdrawn funds)\\r\\n    /// @param _optionId The id of the option to withdraw funds from\\r\\n    function withdrawFrom(address _from, uint256 _optionId) external {\\r\\n        require(isApprovedForAll(_from, msg.sender), \\\"Not approved\\\");\\r\\n        _withdraw(_from, _optionId);\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw collateral from an option post expiration\\r\\n    ///         Funds in the option pool will be distributed pro rata of amount of options written by the address\\r\\n    ///         Ex : If after expiration date there has been 10 options written and there is 1 eth and 1000 DAI in the pool,\\r\\n    ///              Withdraw for each option will be worth 0.1 eth and 100 dai\\r\\n    /// @dev Only callable by addresses which have unclaimed funds for options they wrote\\r\\n    /// @param _optionId The id of the option to withdraw funds from\\r\\n    function withdraw(uint256 _optionId) public {\\r\\n        _withdraw(msg.sender, _optionId);\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw collateral from an option post expiration on behalf of an address.\\r\\n    ///         (Funds will be send to the address on behalf of which withdrawal is made)\\r\\n    ///         Funds in the option pool will be distributed pro rata of amount of options written by the address\\r\\n    ///         Ex : If after expiration date there has been 10 options written and there is 1 eth and 1000 DAI in the pool,\\r\\n    ///              Withdraw for each option will be worth 0.1 eth and 100 dai\\r\\n    /// @dev Only callable by addresses which have unclaimed funds for options they wrote\\r\\n    /// @param _from Address on behalf of which the withdraw call is made (Which will receive the withdrawn funds)\\r\\n    /// @param _optionId The id of the option to withdraw funds from\\r\\n    function _withdraw(address _from, uint256 _optionId) internal nonReentrant expired(_optionId) {\\r\\n        require(nbWritten[_from][_optionId] > 0, \\\"No option to claim\\\");\\r\\n\\r\\n        OptionData storage data = optionData[_optionId];\\r\\n\\r\\n        uint256 nbTotal = uint256(data.supply).add(data.exercised).sub(data.claimsPreExp);\\r\\n\\r\\n        // Amount of options user still has to claim funds from\\r\\n        uint256 claimsUser = nbWritten[_from][_optionId];\\r\\n\\r\\n        //\\r\\n\\r\\n        uint256 denominatorAmount = pools[_optionId].denominatorAmount.mul(claimsUser).div(nbTotal);\\r\\n        uint256 tokenAmount = pools[_optionId].tokenAmount.mul(claimsUser).div(nbTotal);\\r\\n\\r\\n        //\\r\\n\\r\\n        pools[_optionId].denominatorAmount.sub(denominatorAmount);\\r\\n        pools[_optionId].tokenAmount.sub(tokenAmount);\\r\\n        data.claimsPostExp = uint256(data.claimsPostExp).add(claimsUser);\\r\\n        delete nbWritten[_from][_optionId];\\r\\n\\r\\n        denominator.safeTransfer(_from, denominatorAmount);\\r\\n        IERC20(optionData[_optionId].token).safeTransfer(_from, tokenAmount);\\r\\n\\r\\n        emit Withdraw(_from, _optionId, data.token, claimsUser);\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    /// @notice Withdraw collateral from an option pre expiration on behalf of an address.\\r\\n    ///         (Funds will be send to the address on behalf of which withdrawal is made)\\r\\n    ///         Only opposite side of the collateral will be allocated when withdrawing pre expiration\\r\\n    ///         If writer deposited WETH for a WETH/DAI call, he will only receive the strike amount in DAI from a pre-expiration withdrawal,\\r\\n    ///         while doing a withdrawal post expiration would make him receive pro rata of funds left in the option pool at the expiration,\\r\\n    ///         (Which might be both WETH and DAI if not all options have been exercised)\\r\\n    ///\\r\\n    /// @dev Requires approval of the option contract\\r\\n    ///      Only callable by addresses which have unclaimed funds for options they wrote\\r\\n    ///      This also requires options to have been exercised and not claimed\\r\\n    ///      Ex : If a total of 10 options have been written (2 from Alice and 8 from Bob) and 3 options have been exercise :\\r\\n    ///           - Alice will be allowed to call withdrawPreExpiration for her 2 options written\\r\\n    ///           - Bob will only be allowed to call withdrawPreExpiration for 3 options he wrote\\r\\n    ///           - If Alice call first withdrawPreExpiration for her 2 options,\\r\\n    ///             there will be only 1 unclaimed exercised options that Bob will be allowed to withdrawPreExpiration\\r\\n    ///\\r\\n    /// @param _from Address on behalf of which the withdrawPreExpiration call is made (Which will receive the withdrawn funds)\\r\\n    /// @param _optionId The id of the option to withdraw funds from\\r\\n    /// @param _amount The amount of options for which withdrawPreExpiration\\r\\n    function withdrawPreExpirationFrom(address _from, uint256 _optionId, uint256 _amount) external {\\r\\n        require(isApprovedForAll(_from, msg.sender), \\\"Not approved\\\");\\r\\n        _withdrawPreExpiration(_from, _optionId, _amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw collateral from an option pre expiration\\r\\n    ///         (Funds will be send to the address on behalf of which withdrawal is made)\\r\\n    ///         Only opposite side of the collateral will be allocated when withdrawing pre expiration\\r\\n    ///         If writer deposited WETH for a WETH/DAI call, he will only receive the strike amount in DAI from a pre-expiration withdrawal,\\r\\n    ///         while doing a withdrawal post expiration would make him receive pro rata of funds left in the option pool at the expiration,\\r\\n    ///         (Which might be both WETH and DAI if not all options have been exercised)\\r\\n    ///\\r\\n    /// @dev Only callable by addresses which have unclaimed funds for options they wrote\\r\\n    ///      This also requires options to have been exercised and not claimed\\r\\n    ///      Ex : If a total of 10 options have been written (2 from Alice and 8 from Bob) and 3 options have been exercise :\\r\\n    ///           - Alice will be allowed to call withdrawPreExpiration for her 2 options written\\r\\n    ///           - Bob will only be allowed to call withdrawPreExpiration for 3 options he wrote\\r\\n    ///           - If Alice call first withdrawPreExpiration for her 2 options,\\r\\n    ///             there will be only 1 unclaimed exercised options that Bob will be allowed to withdrawPreExpiration\\r\\n    ///\\r\\n    /// @param _optionId The id of the option to exercise\\r\\n    /// @param _amount The amount of options for which withdrawPreExpiration\\r\\n    function withdrawPreExpiration(uint256 _optionId, uint256 _amount) public {\\r\\n        _withdrawPreExpiration(msg.sender, _optionId, _amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw collateral from an option pre expiration on behalf of an address.\\r\\n    ///         (Funds will be send to the address on behalf of which withdrawal is made)\\r\\n    ///         Only opposite side of the collateral will be allocated when withdrawing pre expiration\\r\\n    ///         If writer deposited WETH for a WETH/DAI call, he will only receive the strike amount in DAI from a pre-expiration withdrawal,\\r\\n    ///         while doing a withdrawal post expiration would make him receive pro rata of funds left in the option pool at the expiration,\\r\\n    ///         (Which might be both WETH and DAI if not all options have been exercised)\\r\\n    ///\\r\\n    /// @dev Only callable by addresses which have unclaimed funds for options they wrote\\r\\n    ///      This also requires options to have been exercised and not claimed\\r\\n    ///      Ex : If a total of 10 options have been written (2 from Alice and 8 from Bob) and 3 options have been exercise :\\r\\n    ///           - Alice will be allowed to call withdrawPreExpiration for her 2 options written\\r\\n    ///           - Bob will only be allowed to call withdrawPreExpiration for 3 options he wrote\\r\\n    ///           - If Alice call first withdrawPreExpiration for her 2 options,\\r\\n    ///             there will be only 1 unclaimed exercised options that Bob will be allowed to withdrawPreExpiration\\r\\n    ///\\r\\n    /// @param _from Address on behalf of which the withdrawPreExpiration call is made (Which will receive the withdrawn funds)\\r\\n    /// @param _optionId The id of the option to withdraw funds from\\r\\n    /// @param _amount The amount of options for which withdrawPreExpiration\\r\\n    function _withdrawPreExpiration(address _from, uint256 _optionId, uint256 _amount) internal nonReentrant notExpired(_optionId) {\\r\\n        require(_amount > 0, \\\"Amount <= 0\\\");\\r\\n\\r\\n        // Amount of options user still has to claim funds from\\r\\n        uint256 claimsUser = nbWritten[_from][_optionId];\\r\\n        require(claimsUser >= _amount, \\\"Not enough claims\\\");\\r\\n\\r\\n        OptionData storage data = optionData[_optionId];\\r\\n\\r\\n        uint256 nbClaimable = uint256(data.exercised).sub(data.claimsPreExp);\\r\\n        require(nbClaimable >= _amount, \\\"Not enough claimable\\\");\\r\\n\\r\\n        //\\r\\n\\r\\n        nbWritten[_from][_optionId] = nbWritten[_from][_optionId].sub(_amount);\\r\\n        data.claimsPreExp = uint256(data.claimsPreExp).add(_amount);\\r\\n\\r\\n        if (data.isCall) {\\r\\n            uint256 amount = _amount.mul(data.strikePrice).div(10**data.decimals);\\r\\n            pools[_optionId].denominatorAmount = pools[_optionId].denominatorAmount.sub(amount);\\r\\n            denominator.safeTransfer(_from, amount);\\r\\n        } else {\\r\\n            pools[_optionId].tokenAmount = pools[_optionId].tokenAmount.sub(_amount);\\r\\n            IERC20(data.token).safeTransfer(_from, _amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    /// @notice Flash exercise an option on behalf of an address\\r\\n    ///         This is usable on options in the money, in order to use a portion of the option collateral\\r\\n    ///         to swap a portion of it to the token required to exercise the option and pay protocol fees,\\r\\n    ///         and send the profit to the address exercising.\\r\\n    ///         This allows any option in the money to be exercised without the need of owning the token needed to exercise\\r\\n    /// @dev Requires approval of the option contract\\r\\n    /// @param _from Address on behalf of which the flash exercise is made (Which will receive the profit)\\r\\n    /// @param _optionId The id of the option to flash exercise\\r\\n    /// @param _amount Amount of option to flash exercise\\r\\n    /// @param _referrer Referrer\\r\\n    /// @param _router The UniswapRouter used to perform the swap (Needs to be a whitelisted router)\\r\\n    /// @param _amountInMax Max amount of collateral token to use for the swap, for the tx to not be reverted\\r\\n    /// @param _path Path used for the routing of the swap\\r\\n    function flashExerciseOptionFrom(address _from, uint256 _optionId, uint256 _amount, address _referrer, IUniswapV2Router02 _router, uint256 _amountInMax, address[] memory _path) external {\\r\\n        require(isApprovedForAll(_from, msg.sender), \\\"Not approved\\\");\\r\\n        _flashExerciseOption(_from, _optionId, _amount, _referrer, _router, _amountInMax, _path);\\r\\n    }\\r\\n\\r\\n    /// @notice Flash exercise an option\\r\\n    ///         This is usable on options in the money, in order to use a portion of the option collateral\\r\\n    ///         to swap a portion of it to the token required to exercise the option and pay protocol fees,\\r\\n    ///         and send the profit to the address exercising.\\r\\n    ///         This allows any option in the money to be exercised without the need of owning the token needed to exercise\\r\\n    /// @param _optionId The id of the option to flash exercise\\r\\n    /// @param _amount Amount of option to flash exercise\\r\\n    /// @param _referrer Referrer\\r\\n    /// @param _router The UniswapRouter used to perform the swap (Needs to be a whitelisted router)\\r\\n    /// @param _amountInMax Max amount of collateral token to use for the swap, for the tx to not be reverted\\r\\n    /// @param _path Path used for the routing of the swap\\r\\n    function flashExerciseOption(uint256 _optionId, uint256 _amount, address _referrer, IUniswapV2Router02 _router, uint256 _amountInMax, address[] memory _path) external {\\r\\n        _flashExerciseOption(msg.sender, _optionId, _amount, _referrer, _router, _amountInMax, _path);\\r\\n    }\\r\\n\\r\\n    /// @notice Flash exercise an option on behalf of an address\\r\\n    ///         This is usable on options in the money, in order to use a portion of the option collateral\\r\\n    ///         to swap a portion of it to the token required to exercise the option and pay protocol fees,\\r\\n    ///         and send the profit to the address exercising.\\r\\n    ///         This allows any option in the money to be exercised without the need of owning the token needed to exercise\\r\\n    /// @dev Requires approval of the option contract\\r\\n    /// @param _from Address on behalf of which the flash exercise is made (Which will receive the profit)\\r\\n    /// @param _optionId The id of the option to flash exercise\\r\\n    /// @param _amount Amount of option to flash exercise\\r\\n    /// @param _referrer Referrer\\r\\n    /// @param _router The UniswapRouter used to perform the swap (Needs to be a whitelisted router)\\r\\n    /// @param _amountInMax Max amount of collateral token to use for the swap, for the tx to not be reverted\\r\\n    /// @param _path Path used for the routing of the swap\\r\\n    function _flashExerciseOption(address _from, uint256 _optionId, uint256 _amount, address _referrer, IUniswapV2Router02 _router, uint256 _amountInMax, address[] memory _path) internal nonReentrant {\\r\\n        require(_amount > 0, \\\"Amount <= 0\\\");\\r\\n\\r\\n        burn(_from, _optionId, _amount);\\r\\n        optionData[_optionId].exercised = uint256(optionData[_optionId].exercised).add(_amount);\\r\\n\\r\\n        // Set referrer or get current if one already exists\\r\\n        _referrer = _trySetReferrer(_from, _referrer);\\r\\n\\r\\n        QuoteExercise memory quote = getExerciseQuote(_from, optionData[_optionId], _amount, _referrer, optionData[_optionId].decimals);\\r\\n\\r\\n        IERC20 tokenErc20 = IERC20(optionData[_optionId].token);\\r\\n\\r\\n        uint256 tokenAmountRequired = tokenErc20.balanceOf(address(this));\\r\\n        uint256 denominatorAmountRequired = denominator.balanceOf(address(this));\\r\\n\\r\\n        if (optionData[_optionId].isCall) {\\r\\n            pools[_optionId].tokenAmount = pools[_optionId].tokenAmount.sub(quote.output);\\r\\n            pools[_optionId].denominatorAmount = pools[_optionId].denominatorAmount.add(quote.input);\\r\\n        } else {\\r\\n            pools[_optionId].denominatorAmount = pools[_optionId].denominatorAmount.sub(quote.output);\\r\\n            pools[_optionId].tokenAmount = pools[_optionId].tokenAmount.add(quote.input);\\r\\n        }\\r\\n\\r\\n        //\\r\\n\\r\\n        if (quote.output < _amountInMax) {\\r\\n            _amountInMax = quote.output;\\r\\n        }\\r\\n\\r\\n        // Swap enough denominator to tokenErc20 to pay fee + strike price\\r\\n        uint256 tokenAmountUsed = _swap(_router, quote.outputToken, quote.inputToken, quote.input.add(quote.fee).add(quote.feeReferrer), _amountInMax, _path)[0];\\r\\n\\r\\n        // Pay fees\\r\\n        _payFees(address(this), IERC20(quote.inputToken), _referrer, quote.fee, quote.feeReferrer, quote.inputDecimals);\\r\\n\\r\\n        uint256 profit = quote.output.sub(tokenAmountUsed);\\r\\n\\r\\n        // Send profit to sender\\r\\n        IERC20(quote.outputToken).safeTransfer(_from, profit);\\r\\n\\r\\n        //\\r\\n\\r\\n        if (optionData[_optionId].isCall) {\\r\\n            denominatorAmountRequired = denominatorAmountRequired.add(quote.input);\\r\\n            tokenAmountRequired = tokenAmountRequired.sub(quote.output);\\r\\n        } else {\\r\\n            denominatorAmountRequired = denominatorAmountRequired.sub(quote.output);\\r\\n            tokenAmountRequired = tokenAmountRequired.add(quote.input);\\r\\n        }\\r\\n\\r\\n        require(denominator.balanceOf(address(this)) >= denominatorAmountRequired, \\\"Wrong denom bal\\\");\\r\\n        require(tokenErc20.balanceOf(address(this)) >= tokenAmountRequired, \\\"Wrong token bal\\\");\\r\\n\\r\\n        emit OptionExercised(_from, _optionId, optionData[_optionId].token, _amount);\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    /// @notice Flash loan collaterals sitting in this contract\\r\\n    ///         Loaned amount + fee must be repaid by the end of the transaction for the transaction to not be reverted\\r\\n    /// @param _tokenAddress Token to flashLoan\\r\\n    /// @param _amount Amount to flashLoan\\r\\n    /// @param _receiver Receiver of the flashLoan\\r\\n    function flashLoan(address _tokenAddress, uint256 _amount, IFlashLoanReceiver _receiver) public nonReentrant {\\r\\n        IERC20 _token = IERC20(_tokenAddress);\\r\\n        uint256 startBalance = _token.balanceOf(address(this));\\r\\n        _token.safeTransfer(address(_receiver), _amount);\\r\\n\\r\\n        (uint256 fee,) = feeCalculator.getFeeAmounts(msg.sender, false, _amount, IFeeCalculator.FeeType.FlashLoan);\\r\\n\\r\\n        _receiver.execute(_tokenAddress, _amount, _amount.add(fee));\\r\\n\\r\\n        uint256 endBalance = _token.balanceOf(address(this));\\r\\n\\r\\n        uint256 endBalanceRequired = startBalance.add(fee);\\r\\n\\r\\n        require(endBalance >= endBalanceRequired, \\\"Failed to pay back\\\");\\r\\n        _token.safeTransfer(feeRecipient, endBalance.sub(startBalance));\\r\\n\\r\\n        endBalance = _token.balanceOf(address(this));\\r\\n        require(endBalance >= startBalance, \\\"Failed to pay back\\\");\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    //////////////\\r\\n    // Internal //\\r\\n    //////////////\\r\\n\\r\\n    /// @notice Mint ERC1155 representing the option\\r\\n    /// @dev Requires option to not be expired\\r\\n    /// @param _account Address for which ERC1155 is minted\\r\\n    /// @param _amount Amount minted\\r\\n    function mint(address _account, uint256 _id, uint256 _amount) internal notExpired(_id) {\\r\\n        OptionData storage data = optionData[_id];\\r\\n\\r\\n        _mint(_account, _id, _amount, \\\"\\\");\\r\\n        data.supply = uint256(data.supply).add(_amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Burn ERC1155 representing the option\\r\\n    /// @param _account Address from which ERC1155 is burnt\\r\\n    /// @param _amount Amount burnt\\r\\n    function burn(address _account, uint256 _id, uint256 _amount) internal notExpired(_id) {\\r\\n        OptionData storage data = optionData[_id];\\r\\n\\r\\n        data.supply = uint256(data.supply).sub(_amount);\\r\\n        _burn(_account, _id, _amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Utility function to check if a value is inside an array\\r\\n    /// @param _value The value to look for\\r\\n    /// @param _array The array to check\\r\\n    /// @return Whether the value is in the array or not\\r\\n    function _isInArray(address _value, address[] memory _array) internal pure returns(bool) {\\r\\n        uint256 length = _array.length;\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            if (_array[i] == _value) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /// @notice Pay protocol fees\\r\\n    /// @param _from Address paying protocol fees\\r\\n    /// @param _token The token in which protocol fees are paid\\r\\n    /// @param _referrer The referrer of _from\\r\\n    /// @param _fee Protocol fee to pay to feeRecipient\\r\\n    /// @param _feeReferrer Fee to pay to referrer\\r\\n    /// @param _decimals Token decimals\\r\\n    function _payFees(address _from, IERC20 _token, address _referrer, uint256 _fee, uint256 _feeReferrer, uint8 _decimals) internal {\\r\\n        if (_fee > 0) {\\r\\n            // For flash exercise\\r\\n            if (_from == address(this)) {\\r\\n                _token.safeTransfer(feeRecipient, _fee);\\r\\n            } else {\\r\\n                _token.safeTransferFrom(_from, feeRecipient, _fee);\\r\\n            }\\r\\n\\r\\n        }\\r\\n\\r\\n        if (_feeReferrer > 0) {\\r\\n            // For flash exercise\\r\\n            if (_from == address(this)) {\\r\\n                _token.safeTransfer(_referrer, _feeReferrer);\\r\\n            } else {\\r\\n                _token.safeTransferFrom(_from, _referrer, _feeReferrer);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // If uPremia rewards are enabled\\r\\n        if (address(uPremia) != address(0)) {\\r\\n            uint256 totalFee = _fee.add(_feeReferrer);\\r\\n            if (totalFee > 0) {\\r\\n                uPremia.mintReward(_from, address(_token), totalFee, _decimals);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit FeePaid(_from, address(_token), _referrer, _fee, _feeReferrer);\\r\\n    }\\r\\n\\r\\n    /// @notice Try to set given referrer, returns current referrer if one already exists\\r\\n    /// @param _user Address for which we try to set a referrer\\r\\n    /// @param _referrer Potential referrer\\r\\n    /// @return Actual referrer (Potential referrer, or actual referrer if one already exists)\\r\\n    function _trySetReferrer(address _user, address _referrer) internal returns(address) {\\r\\n        if (address(premiaReferral) != address(0)) {\\r\\n            _referrer = premiaReferral.trySetReferrer(_user, _referrer);\\r\\n        } else {\\r\\n            _referrer = address(0);\\r\\n        }\\r\\n\\r\\n        return _referrer;\\r\\n    }\\r\\n\\r\\n    /// @notice Token swap (Used for flashExercise)\\r\\n    /// @param _router The UniswapRouter contract to use to perform the swap (Must be whitelisted)\\r\\n    /// @param _from Input token for the swap\\r\\n    /// @param _to Output token of the swap\\r\\n    /// @param _amount Amount of output tokens we want\\r\\n    /// @param _amountInMax Max amount of input token to spend for the tx to not revert\\r\\n    /// @param _path Path used for the routing of the swap\\r\\n    /// @return Swap amounts\\r\\n    function _swap(IUniswapV2Router02 _router, address _from, address _to, uint256 _amount, uint256 _amountInMax, address[] memory _path) internal returns (uint256[] memory) {\\r\\n        require(_isInArray(address(_router), whitelistedUniswapRouters), \\\"Router not whitelisted\\\");\\r\\n\\r\\n        IERC20(_from).approve(address(_router), _amountInMax);\\r\\n\\r\\n        uint256[] memory amounts = _router.swapTokensForExactTokens(\\r\\n            _amount,\\r\\n            _amountInMax,\\r\\n            _path,\\r\\n            address(this),\\r\\n            block.timestamp.add(60)\\r\\n        );\\r\\n\\r\\n        IERC20(_from).approve(address(_router), 0);\\r\\n\\r\\n        return amounts;\\r\\n    }\\r\\n\\r\\n    /// @notice Check if option settings are valid (Reverts if not valid)\\r\\n    /// @param _token Token for which option this\\r\\n    /// @param _strikePrice Strike price of the option\\r\\n    /// @param _expiration timestamp of the option\\r\\n    function _preCheckOptionIdCreate(address _token, uint256 _strikePrice, uint256 _expiration) internal view {\\r\\n        require(tokenStrikeIncrement[_token] != 0, \\\"Token not supported\\\");\\r\\n        require(_strikePrice > 0, \\\"Strike <= 0\\\");\\r\\n        require(_strikePrice % tokenStrikeIncrement[_token] == 0, \\\"Wrong strike incr\\\");\\r\\n        require(_expiration > block.timestamp, \\\"Exp passed\\\");\\r\\n        require(_expiration.sub(block.timestamp) <= maxExpiration, \\\"Exp > 1 yr\\\");\\r\\n        require(_expiration % _expirationIncrement == _baseExpiration, \\\"Wrong exp incr\\\");\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155MetadataURI.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n *\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping (uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\\n     *\\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n\\n    /*\\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor (string memory uri_) public {\\n        _setURI(uri_);\\n\\n        // register the supported interfaces to conform to ERC1155 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155);\\n\\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) external view override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            require(accounts[i] != address(0), \\\"ERC1155: batch balance query for the zero address\\\");\\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][from] = _balances[id][from].sub(amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        _balances[id][to] = _balances[id][to].add(amount);\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            _balances[id][from] = _balances[id][from].sub(\\n                amount,\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\n            );\\n            _balances[id][to] = _balances[id][to].add(amount);\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] = _balances[id][account].add(amount);\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        _balances[id][account] = _balances[id][account].sub(\\n            amount,\\n            \\\"ERC1155: burn amount exceeds balance\\\"\\n        );\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\\n                amounts[i],\\n                \\\"ERC1155: burn amount exceeds balance\\\"\\n            );\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal virtual\\n    { }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\r\\n\\r\\ninterface IERC20Extended is IERC20 {\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IFeeCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IFeeCalculator {\\r\\n    enum FeeType {Write, Exercise, Maker, Taker, FlashLoan}\\r\\n\\r\\n    function writeFee() external view returns(uint256);\\r\\n    function exerciseFee() external view returns(uint256);\\r\\n    function flashLoanFee() external view returns(uint256);\\r\\n\\r\\n    function referrerFee() external view returns(uint256);\\r\\n    function referredDiscount() external view returns(uint256);\\r\\n\\r\\n    function makerFee() external view returns(uint256);\\r\\n    function takerFee() external view returns(uint256);\\r\\n\\r\\n    function getFee(address _user, bool _hasReferrer, FeeType _feeType) external view returns(uint256);\\r\\n    function getFeeAmounts(address _user, bool _hasReferrer, uint256 _amount, FeeType _feeType) external view returns(uint256 _fee, uint256 _feeReferrer);\\r\\n    function getFeeAmountsWithDiscount(address _user, bool _hasReferrer, uint256 _baseFee) external view returns(uint256 _fee, uint256 _feeReferrer);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IFlashLoanReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IFlashLoanReceiver {\\r\\n    function execute(address _tokenAddress, uint256 _amount, uint256 _amountWithFee) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interface/IPremiaReferral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IPremiaReferral {\\r\\n    function referrals(address _referred) external view returns(address _referrer);\\r\\n    function trySetReferrer(address _referred, address _potentialReferrer) external returns(address);\\r\\n}\"\r\n    },\r\n    \"contracts/interface/IPremiaUncutErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\n\\r\\ninterface IPremiaUncutErc20 is IERC20 {\\r\\n    function getTokenPrice(address _token) external view returns(uint256);\\r\\n    function mint(address _account, uint256 _amount) external;\\r\\n    function mintReward(address _account, address _token, uint256 _feePaid, uint8 _decimals) external;\\r\\n}\"\r\n    },\r\n    \"contracts/uniswapV2/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\r\\n\\r\\nimport './IUniswapV2Router01.sol';\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapV2/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 50\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"_denominator\",\"type\":\"address\"},{\"internalType\":\"contract IPremiaUncutErc20\",\"name\":\"_uPremia\",\"type\":\"address\"},{\"internalType\":\"contract IFeeCalculator\",\"name\":\"_feeCalculator\",\"type\":\"address\"},{\"internalType\":\"contract IPremiaReferral\",\"name\":\"_premiaReferral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeProtocol\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeReferrer\",\"type\":\"uint256\"}],\"name\":\"FeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OptionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OptionExercised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"OptionIdCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OptionWritten\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strikePriceIncrement\",\"type\":\"uint256\"}],\"name\":\"SetToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"cancelOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"cancelOptionFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominatorDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"exerciseOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"exerciseOptionFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCalculator\",\"outputs\":[{\"internalType\":\"contract IFeeCalculator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"flashExerciseOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"flashExerciseOptionFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"contract IFlashLoanReceiver\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"claimsPreExp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimsPostExp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exercised\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct PremiaOption.OptionData\",\"name\":\"_option\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"getExerciseQuote\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"inputDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"outputDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeReferrer\",\"type\":\"uint256\"}],\"internalType\":\"struct PremiaOption.QuoteExercise\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isCall\",\"type\":\"bool\"}],\"name\":\"getOptionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isCall\",\"type\":\"bool\"}],\"name\":\"getOptionIdOrCreate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"}],\"internalType\":\"struct PremiaOption.OptionWriteArgs\",\"name\":\"_option\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"getWriteQuote\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"collateralDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeReferrer\",\"type\":\"uint256\"}],\"internalType\":\"struct PremiaOption.QuoteWrite\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxExpiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nbWritten\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextOptionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"optionData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"claimsPreExp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimsPostExp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exercised\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"options\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominatorAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"premiaReferral\",\"outputs\":[{\"internalType\":\"contract IPremiaReferral\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFeeCalculator\",\"name\":\"_feeCalculator\",\"type\":\"address\"}],\"name\":\"setFeeCalculator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setMaxExpiration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPremiaReferral\",\"name\":\"_premiaReferral\",\"type\":\"address\"}],\"name\":\"setPremiaReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPremiaUncutErc20\",\"name\":\"_uPremia\",\"type\":\"address\"}],\"name\":\"setPremiaUncutErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_strikePriceIncrement\",\"type\":\"uint256[]\"}],\"name\":\"setTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newUri\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addrList\",\"type\":\"address[]\"}],\"name\":\"setWhitelistedUniswapRouters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenStrikeIncrement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uPremia\",\"outputs\":[{\"internalType\":\"contract IPremiaUncutErc20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelistedUniswapRouters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"}],\"name\":\"withdrawFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPreExpiration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPreExpirationFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"}],\"internalType\":\"struct PremiaOption.OptionWriteArgs\",\"name\":\"_option\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"writeOption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"}],\"internalType\":\"struct PremiaOption.OptionWriteArgs\",\"name\":\"_option\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"writeOptionFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"writeOptionWithIdFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PremiaOption","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"50","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000008406c6c1db4d224c8b0cf7859c0881ddd68d4761000000000000000000000000602b50091b0b351ca179e87ad6e006aeceb2a6ad000000000000000000000000afcf4ca5826ed76189ea227bd863916abf43a6da000000000000000000000000c22fae86443aeed038a4ed887bba8f5035fd12f0000000000000000000000000000000000000000000000000000000000000002868747470733a2f2f7072656d69612e66696e616e63652f6170692f6461692f7b69647d2e6a736f6e000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}