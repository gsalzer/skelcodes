{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"sbControllerInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface sbControllerInterface {\\n  function requestRewards(address miner, uint256 amount) external;\\n\\n  function isValuePoolAccepted(address valuePool) external view returns (bool);\\n\\n  function getValuePoolRewards(address valuePool, uint256 day) external view returns (uint256);\\n\\n  function getValuePoolMiningFee(address valuePool) external returns (uint256, uint256);\\n\\n  function getValuePoolUnminingFee(address valuePool) external returns (uint256, uint256);\\n\\n  function getValuePoolClaimingFee(address valuePool) external returns (uint256, uint256);\\n\\n  function isServicePoolAccepted(address servicePool) external view returns (bool);\\n\\n  function getServicePoolRewards(address servicePool, uint256 day) external view returns (uint256);\\n\\n  function getServicePoolClaimingFee(address servicePool) external returns (uint256, uint256);\\n\\n  function getServicePoolRequestFeeInWei(address servicePool) external returns (uint256);\\n\\n  function getVoteForServicePoolsCount() external view returns (uint256);\\n\\n  function getVoteForServicesCount() external view returns (uint256);\\n\\n  function getVoteCastersRewards(uint256 dayNumber) external view returns (uint256);\\n\\n  function getVoteReceiversRewards(uint256 dayNumber) external view returns (uint256);\\n\\n  function getMinerMinMineDays() external view returns (uint256);\\n\\n  function getServiceMinMineDays() external view returns (uint256);\\n\\n  function getMinerMinMineAmountInWei() external view returns (uint256);\\n\\n  function getServiceMinMineAmountInWei() external view returns (uint256);\\n\\n  function getValuePoolVestingDays(address valuePool) external view returns (uint256);\\n\\n  function getServicePoolVestingDays(address poservicePoolol) external view returns (uint256);\\n\\n  function getVoteCasterVestingDays() external view returns (uint256);\\n\\n  function getVoteReceiverVestingDays() external view returns (uint256);\\n}\\n\"},\"sbEthFeePoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface sbEthFeePoolInterface {\\n  function deposit() external payable;\\n}\\n\"},\"sbGenericServicePoolV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./sbEthFeePoolInterface.sol\\\";\\nimport \\\"./sbControllerInterface.sol\\\";\\nimport \\\"./sbStrongValuePoolInterface.sol\\\";\\n\\ncontract sbGenericServicePoolV2 {\\n    using SafeMath for uint256;\\n\\n    bool public initDone;\\n    address public admin;\\n    address public pendingAdmin;\\n    address public superAdmin;\\n    address public pendingSuperAdmin;\\n    address public serviceAdmin;\\n\\n    sbStrongValuePoolInterface public sbStrongValuePool;\\n    sbEthFeePoolInterface public sbEthFeePool;\\n    sbControllerInterface public sbController;\\n\\n    mapping(address =\\u003e uint256[]) public minerMineDays;\\n    mapping(address =\\u003e uint256[]) public minerMineAmounts;\\n    mapping(address =\\u003e uint256[]) public minerMineMineSeconds;\\n\\n    uint256[] public mineDays;\\n    uint256[] public mineAmounts;\\n    uint256[] public mineMineSeconds;\\n\\n    mapping(address =\\u003e uint256) public minerDayLastClaimedFor;\\n\\n    address[] public services;\\n    mapping(address =\\u003e uint256) public serviceIndex;\\n    mapping(address =\\u003e bool) public serviceAccepted;\\n    mapping(address =\\u003e bool) public requestPending;\\n\\n    string public description;\\n\\n    function init(\\n        address sbStrongValuePoolAddress,\\n        address sbEthFeePoolAddress,\\n        address sbControllerAddress,\\n        address adminAddress,\\n        address superAdminAddress,\\n        address serviceAdminAddress,\\n        string memory desc\\n    ) public {\\n        require(!initDone, \\\"init done\\\");\\n        sbStrongValuePool = sbStrongValuePoolInterface(\\n            sbStrongValuePoolAddress\\n        );\\n        sbEthFeePool = sbEthFeePoolInterface(sbEthFeePoolAddress);\\n        sbController = sbControllerInterface(sbControllerAddress);\\n        admin = adminAddress;\\n        superAdmin = superAdminAddress;\\n        serviceAdmin = serviceAdminAddress;\\n        description = desc;\\n        initDone = true;\\n    }\\n\\n    // ADMIN\\n    // *************************************************************************************\\n    function updateServiceAdmin(address newServiceAdmin) public {\\n        require(msg.sender == superAdmin);\\n        serviceAdmin = newServiceAdmin;\\n    }\\n\\n    function setPendingAdmin(address newPendingAdmin) public {\\n        require(msg.sender == admin, \\\"not admin\\\");\\n        pendingAdmin = newPendingAdmin;\\n    }\\n\\n    function acceptAdmin() public {\\n        require(\\n            msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0),\\n            \\\"not pendingAdmin\\\"\\n        );\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n\\n    function setPendingSuperAdmin(address newPendingSuperAdmin) public {\\n        require(msg.sender == superAdmin, \\\"not superAdmin\\\");\\n        pendingSuperAdmin = newPendingSuperAdmin;\\n    }\\n\\n    function acceptSuperAdmin() public {\\n        require(\\n            msg.sender == pendingSuperAdmin \\u0026\\u0026 msg.sender != address(0),\\n            \\\"not pendingSuperAdmin\\\"\\n        );\\n        superAdmin = pendingSuperAdmin;\\n        pendingSuperAdmin = address(0);\\n    }\\n\\n    // SERVICES\\n    // *************************************************************************************\\n    function getServices() public view returns (address[] memory) {\\n        return services;\\n    }\\n\\n    function isServiceAccepted(address service) public view returns (bool) {\\n        return serviceAccepted[service];\\n    }\\n\\n    // MINING\\n    // *************************************************************************************\\n    function requestAccess() public payable {\\n        require(!requestPending[msg.sender], \\\"pending\\\");\\n        require(!serviceAccepted[msg.sender], \\\"accepted\\\");\\n        uint256 feeInWei = sbController.getServicePoolRequestFeeInWei(\\n            address(this)\\n        );\\n        require(msg.value == feeInWei, \\\"invalid fee\\\");\\n        sbEthFeePool.deposit{value: msg.value}();\\n        requestPending[msg.sender] = true;\\n    }\\n\\n    function grantAccess(address[] memory miners, bool useChecks)\\n        public\\n        payable\\n    {\\n        require(\\n            msg.sender == admin ||\\n                msg.sender == serviceAdmin ||\\n                msg.sender == superAdmin,\\n            \\\"not admin\\\"\\n        );\\n        require(miners.length != 0, \\\"zero\\\");\\n        uint256 currentDay = _getCurrentDay();\\n        for (uint256 i = 0; i \\u003c miners.length; i++) {\\n            address miner = miners[i];\\n            if (useChecks) {\\n                require(requestPending[miner], \\\"not pending\\\");\\n                require(\\n                    sbStrongValuePool.serviceMinMined(miner),\\n                    \\\"not min mined\\\"\\n                );\\n            }\\n            require(!serviceAccepted[miner], \\\"exists\\\");\\n            _update(\\n                minerMineDays[miner],\\n                minerMineAmounts[miner],\\n                minerMineMineSeconds[miner],\\n                1,\\n                true,\\n                currentDay\\n            );\\n            _update(\\n                mineDays,\\n                mineAmounts,\\n                mineMineSeconds,\\n                1,\\n                true,\\n                currentDay\\n            );\\n            uint256 len = services.length;\\n            serviceIndex[miner] = len;\\n            services.push(miner);\\n            serviceAccepted[miner] = true;\\n            requestPending[miner] = false;\\n        }\\n    }\\n\\n    function revokeAccess(address miner) public payable {\\n        require(\\n            msg.sender == admin ||\\n                msg.sender == serviceAdmin ||\\n                msg.sender == superAdmin,\\n            \\\"not admin\\\"\\n        );\\n        require(serviceAccepted[miner], \\\"invalid miner\\\");\\n        uint256 currentDay = _getCurrentDay();\\n        _update(\\n            minerMineDays[miner],\\n            minerMineAmounts[miner],\\n            minerMineMineSeconds[miner],\\n            1,\\n            false,\\n            currentDay\\n        );\\n        _update(mineDays, mineAmounts, mineMineSeconds, 1, false, currentDay);\\n        _deleteIndex(serviceIndex[miner]);\\n        serviceAccepted[miner] = false;\\n    }\\n\\n    function getMinerDayLastClaimedFor(address miner)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 len = minerMineDays[miner].length;\\n        if (len != 0) {\\n            return\\n                minerDayLastClaimedFor[miner] == 0\\n                    ? minerMineDays[miner][0].sub(1)\\n                    : minerDayLastClaimedFor[miner];\\n        }\\n        return 0;\\n    }\\n\\n    function getMinerMineData(address miner, uint256 dayNumber)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 day = dayNumber == 0 ? _getCurrentDay() : dayNumber;\\n        return _getMinerMineData(miner, day);\\n    }\\n\\n    function getMineData(uint256 dayNumber)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 day = dayNumber == 0 ? _getCurrentDay() : dayNumber;\\n        return _getMineData(day);\\n    }\\n\\n    // CLAIMING\\n    // *************************************************************************************\\n    function claimAll() public payable {\\n        uint256 len = minerMineDays[msg.sender].length;\\n        require(len != 0, \\\"no mines\\\");\\n        require(serviceAccepted[msg.sender], \\\"invalid miner\\\");\\n        require(sbStrongValuePool.serviceMinMined(msg.sender), \\\"not min mined\\\");\\n        uint256 currentDay = _getCurrentDay();\\n        uint256 dayLastClaimedFor = minerDayLastClaimedFor[msg.sender] == 0\\n            ? minerMineDays[msg.sender][0].sub(1)\\n            : minerDayLastClaimedFor[msg.sender];\\n        uint256 vestingDays = sbController.getServicePoolVestingDays(\\n            address(this)\\n        );\\n        require(\\n            currentDay \\u003e dayLastClaimedFor.add(vestingDays),\\n            \\\"already claimed\\\"\\n        );\\n        // fees are taken in _claim\\n        _claim(currentDay, msg.sender, dayLastClaimedFor, vestingDays);\\n    }\\n\\n    function claimUpTo(uint256 day) public payable {\\n        uint256 len = minerMineDays[msg.sender].length;\\n        require(len != 0, \\\"no mines\\\");\\n        require(serviceAccepted[msg.sender], \\\"invalid miner\\\");\\n        require(sbStrongValuePool.serviceMinMined(msg.sender), \\\"not min mined\\\");\\n        require(day \\u003c= _getCurrentDay(), \\\"invalid day\\\");\\n        uint256 dayLastClaimedFor = minerDayLastClaimedFor[msg.sender] == 0\\n            ? minerMineDays[msg.sender][0].sub(1)\\n            : minerDayLastClaimedFor[msg.sender];\\n        uint256 vestingDays = sbController.getServicePoolVestingDays(\\n            address(this)\\n        );\\n        require(day \\u003e dayLastClaimedFor.add(vestingDays), \\\"already claimed\\\");\\n        // fees are taken in _claim\\n        _claim(day, msg.sender, dayLastClaimedFor, vestingDays);\\n    }\\n\\n    function getRewardsDueAll(address miner) public view returns (uint256) {\\n        uint256 len = minerMineDays[miner].length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n        uint256 currentDay = _getCurrentDay();\\n        uint256 dayLastClaimedFor = minerDayLastClaimedFor[miner] == 0\\n            ? minerMineDays[miner][0].sub(1)\\n            : minerDayLastClaimedFor[miner];\\n        uint256 vestingDays = sbController.getServicePoolVestingDays(\\n            address(this)\\n        );\\n        if (!(currentDay \\u003e dayLastClaimedFor.add(vestingDays))) {\\n            return 0;\\n        }\\n        return\\n            _getRewardsDue(currentDay, miner, dayLastClaimedFor, vestingDays);\\n    }\\n\\n    function getRewardsDueUpTo(uint256 day, address miner)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 len = minerMineDays[miner].length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n        require(day \\u003c= _getCurrentDay(), \\\"invalid day\\\");\\n        uint256 dayLastClaimedFor = minerDayLastClaimedFor[miner] == 0\\n            ? minerMineDays[miner][0].sub(1)\\n            : minerDayLastClaimedFor[miner];\\n        uint256 vestingDays = sbController.getServicePoolVestingDays(\\n            address(this)\\n        );\\n        if (!(day \\u003e dayLastClaimedFor.add(vestingDays))) {\\n            return 0;\\n        }\\n        return _getRewardsDue(day, miner, dayLastClaimedFor, vestingDays);\\n    }\\n\\n    // SUPPORT\\n    // *************************************************************************************\\n    function _getMinerMineData(address miner, uint256 day)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256[] memory _Days = minerMineDays[miner];\\n        uint256[] memory _Amounts = minerMineAmounts[miner];\\n        uint256[] memory _UnitSeconds = minerMineMineSeconds[miner];\\n        return _get(_Days, _Amounts, _UnitSeconds, day);\\n    }\\n\\n    function _getMineData(uint256 day)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return _get(mineDays, mineAmounts, mineMineSeconds, day);\\n    }\\n\\n    function _get(\\n        uint256[] memory _Days,\\n        uint256[] memory _Amounts,\\n        uint256[] memory _UnitSeconds,\\n        uint256 day\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 len = _Days.length;\\n        if (len == 0) {\\n            return (day, 0, 0);\\n        }\\n        if (day \\u003c _Days[0]) {\\n            return (day, 0, 0);\\n        }\\n        uint256 lastIndex = len.sub(1);\\n        uint256 lastMinedDay = _Days[lastIndex];\\n        if (day == lastMinedDay) {\\n            return (day, _Amounts[lastIndex], _UnitSeconds[lastIndex]);\\n        } else if (day \\u003e lastMinedDay) {\\n            return (day, _Amounts[lastIndex], _Amounts[lastIndex].mul(1 days));\\n        }\\n        return _find(_Days, _Amounts, _UnitSeconds, day);\\n    }\\n\\n    function _find(\\n        uint256[] memory _Days,\\n        uint256[] memory _Amounts,\\n        uint256[] memory _UnitSeconds,\\n        uint256 day\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 left = 0;\\n        uint256 right = _Days.length.sub(1);\\n        uint256 middle = right.add(left).div(2);\\n        while (left \\u003c right) {\\n            if (_Days[middle] == day) {\\n                return (day, _Amounts[middle], _UnitSeconds[middle]);\\n            } else if (_Days[middle] \\u003e day) {\\n                if (middle \\u003e 0 \\u0026\\u0026 _Days[middle.sub(1)] \\u003c day) {\\n                    return (\\n                        day,\\n                        _Amounts[middle.sub(1)],\\n                        _Amounts[middle.sub(1)].mul(1 days)\\n                    );\\n                }\\n                if (middle == 0) {\\n                    return (day, 0, 0);\\n                }\\n                right = middle.sub(1);\\n            } else if (_Days[middle] \\u003c day) {\\n                if (\\n                    middle \\u003c _Days.length.sub(1) \\u0026\\u0026 _Days[middle.add(1)] \\u003e day\\n                ) {\\n                    return (\\n                        day,\\n                        _Amounts[middle],\\n                        _Amounts[middle].mul(1 days)\\n                    );\\n                }\\n                left = middle.add(1);\\n            }\\n            middle = right.add(left).div(2);\\n        }\\n        if (_Days[middle] != day) {\\n            return (day, 0, 0);\\n        } else {\\n            return (day, _Amounts[middle], _UnitSeconds[middle]);\\n        }\\n    }\\n\\n    function _update(\\n        uint256[] storage _Days,\\n        uint256[] storage _Amounts,\\n        uint256[] storage _UnitSeconds,\\n        uint256 amount,\\n        bool adding,\\n        uint256 currentDay\\n    ) internal {\\n        uint256 len = _Days.length;\\n        uint256 secondsInADay = 1 days;\\n        uint256 secondsSinceStartOfDay = block.timestamp % secondsInADay;\\n        uint256 secondsUntilEndOfDay = secondsInADay.sub(\\n            secondsSinceStartOfDay\\n        );\\n\\n        if (len == 0) {\\n            if (adding) {\\n                _Days.push(currentDay);\\n                _Amounts.push(amount);\\n                _UnitSeconds.push(amount.mul(secondsUntilEndOfDay));\\n            } else {\\n                require(false, \\\"1: not enough mine\\\");\\n            }\\n        } else {\\n            uint256 lastIndex = len.sub(1);\\n            uint256 lastMinedDay = _Days[lastIndex];\\n            uint256 lastMinedAmount = _Amounts[lastIndex];\\n            uint256 lastUnitSeconds = _UnitSeconds[lastIndex];\\n\\n            uint256 newAmount;\\n            uint256 newUnitSeconds;\\n\\n            if (lastMinedDay == currentDay) {\\n                if (adding) {\\n                    newAmount = lastMinedAmount.add(amount);\\n                    newUnitSeconds = lastUnitSeconds.add(\\n                        amount.mul(secondsUntilEndOfDay)\\n                    );\\n                } else {\\n                    require(lastMinedAmount \\u003e= amount, \\\"2: not enough mine\\\");\\n                    newAmount = lastMinedAmount.sub(amount);\\n                    newUnitSeconds = lastUnitSeconds.sub(\\n                        amount.mul(secondsUntilEndOfDay)\\n                    );\\n                }\\n                _Amounts[lastIndex] = newAmount;\\n                _UnitSeconds[lastIndex] = newUnitSeconds;\\n            } else {\\n                if (adding) {\\n                    newAmount = lastMinedAmount.add(amount);\\n                    newUnitSeconds = lastMinedAmount.mul(1 days).add(\\n                        amount.mul(secondsUntilEndOfDay)\\n                    );\\n                } else {\\n                    require(lastMinedAmount \\u003e= amount, \\\"3: not enough mine\\\");\\n                    newAmount = lastMinedAmount.sub(amount);\\n                    newUnitSeconds = lastMinedAmount.mul(1 days).sub(\\n                        amount.mul(secondsUntilEndOfDay)\\n                    );\\n                }\\n                _Days.push(currentDay);\\n                _Amounts.push(newAmount);\\n                _UnitSeconds.push(newUnitSeconds);\\n            }\\n        }\\n    }\\n\\n    function _claim(\\n        uint256 upToDay,\\n        address miner,\\n        uint256 dayLastClaimedFor,\\n        uint256 vestingDays\\n    ) internal {\\n        uint256 rewards = _getRewardsDue(\\n            upToDay,\\n            miner,\\n            dayLastClaimedFor,\\n            vestingDays\\n        );\\n        require(rewards \\u003e 0, \\\"no rewards\\\");\\n        (uint256 numerator, uint256 denominator) = sbController\\n            .getServicePoolClaimingFee(address(this));\\n        uint256 fee = rewards.mul(numerator).div(denominator);\\n        require(msg.value == fee, \\\"invalid fee\\\");\\n        sbEthFeePool.deposit{value: msg.value}();\\n        minerDayLastClaimedFor[miner] = upToDay.sub(vestingDays);\\n        sbController.requestRewards(miner, rewards);\\n    }\\n\\n    function _getRewardsDue(\\n        uint256 upToDay,\\n        address miner,\\n        uint256 dayLastClaimedFor,\\n        uint256 vestingDays\\n    ) internal view returns (uint256) {\\n        uint256 rewards;\\n        for (\\n            uint256 day = dayLastClaimedFor.add(1);\\n            day \\u003c= upToDay.sub(vestingDays);\\n            day++\\n        ) {\\n            uint256 availableRewards = sbController.getServicePoolRewards(\\n                address(this),\\n                day\\n            );\\n            (, uint256 minerCountForDay, ) = _getMinerMineData(miner, day);\\n            (, uint256 countForDay, ) = _getMineData(day);\\n            if (countForDay == 0) {\\n                continue;\\n            }\\n            uint256 amount = availableRewards.mul(minerCountForDay).div(\\n                countForDay\\n            );\\n            rewards = rewards.add(amount);\\n        }\\n        return rewards;\\n    }\\n\\n    function _getCurrentDay() internal view returns (uint256) {\\n        return block.timestamp.div(1 days).add(1);\\n    }\\n\\n    function _deleteIndex(uint256 index) internal {\\n        uint256 lastIndex = services.length.sub(1);\\n        address lastService = services[lastIndex];\\n        if (index == lastIndex) {\\n            serviceIndex[lastService] = 0;\\n            services.pop();\\n        } else {\\n            address serviceAtIndex = services[index];\\n            serviceIndex[serviceAtIndex] = 0;\\n            serviceIndex[lastService] = index;\\n            services[index] = lastService;\\n            services.pop();\\n        }\\n    }\\n}\\n\"},\"sbStrongValuePoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface sbStrongValuePoolInterface {\\n  function mineFor(address miner, uint256 amount) external;\\n\\n  function getMinerMineData(address miner, uint256 day)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  function getMineData(uint256 day)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  function serviceMinMined(address miner) external view returns (bool);\\n\\n  function minerMinMined(address miner) external view returns (bool);\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"claimUpTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dayNumber\",\"type\":\"uint256\"}],\"name\":\"getMineData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"getMinerDayLastClaimedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dayNumber\",\"type\":\"uint256\"}],\"name\":\"getMinerMineData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"getRewardsDueAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"getRewardsDueUpTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getServices\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"miners\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"useChecks\",\"type\":\"bool\"}],\"name\":\"grantAccess\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sbStrongValuePoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sbEthFeePoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sbControllerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adminAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"superAdminAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"serviceAdminAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initDone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isServiceAccepted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mineAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mineDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mineMineSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minerDayLastClaimedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"minerMineAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"minerMineDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"minerMineMineSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingSuperAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestAccess\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"requestPending\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"revokeAccess\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sbController\",\"outputs\":[{\"internalType\":\"contract sbControllerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sbEthFeePool\",\"outputs\":[{\"internalType\":\"contract sbEthFeePoolInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sbStrongValuePool\",\"outputs\":[{\"internalType\":\"contract sbStrongValuePoolInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"serviceAccepted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"serviceIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"services\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingSuperAdmin\",\"type\":\"address\"}],\"name\":\"setPendingSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newServiceAdmin\",\"type\":\"address\"}],\"name\":\"updateServiceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"sbGenericServicePoolV2","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7534f7c5be2f9325ad84bc7d6456ca4c5c4decb68ba2b9ff2cd47c2df79baed7"}]}