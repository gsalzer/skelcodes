{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TetherswapFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./interfaces/ITetherswapFactory.sol\\\";\\nimport \\\"./interfaces/ITetherswapPriceOracle.sol\\\";\\nimport \\\"./libraries/SafeMathTetherswap.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./TetherswapPair.sol\\\";\\n\\ncontract TetherswapFactory is ITetherswapFactory, ReentrancyGuard {\\n    using SafeMathTetherswap for uint256;\\n\\n    address public immutable override USDT;\\n    address public immutable override WETH;\\n    address public immutable override YFTE;\\n\\n    address public override governance;\\n    address public override treasury;\\n    address public override priceOracle;\\n    uint256 public override usdtListingFeeInUsd;\\n    uint256 public override wethListingFeeInUsd;\\n    uint256 public override yfteListingFeeInUsd;\\n    uint256 public override treasuryListingFeeShare = 1000000;\\n    uint256 public override minListingLockupAmountInUsd;\\n    uint256 public override targetListingLockupAmountInUsd;\\n    uint256 public override minListingLockupPeriod;\\n    uint256 public override targetListingLockupPeriod;\\n    uint256 public override lockupAmountListingFeeDiscountShare;\\n    uint256 public override defaultUsdtTradingFeePercent = 2500; // 0.2500%\\n    uint256 public override defaultNonUsdtTradingFeePercent = 3000; // 0.3000%\\n    uint256 public override treasuryProtocolFeeShare = 1000000; // 100%\\n    uint256 public override protocolFeeFractionInverse; // protocol fee off initially\\n    uint256 public override maxSlippagePercent;\\n    uint256 public override maxSlippageBlocks = 1;\\n\\n    mapping(address => mapping(address => address)) public override getPair;\\n    mapping(address => mapping(address => bool)) public override approvedPair;\\n    address[] public override allPairs;\\n\\n    modifier onlyGovernance() {\\n        require(msg.sender == governance);\\n        _;\\n    }\\n\\n    constructor(\\n        address _governance,\\n        address _treasury,\\n        address _priceOracle,\\n        uint256 _usdtListingFeeInUsd,\\n        uint256 _wethListingFeeInUsd,\\n        uint256 _yfteListingFeeInUsd,\\n        uint256 _treasuryListingFeeShare,\\n        uint256 _minListingLockupAmountInUsd,\\n        uint256 _targetListingLockupAmountInUsd,\\n        uint256 _minListingLockupPeriod,\\n        uint256 _targetListingLockupPeriod,\\n        uint256 _lockupAmountListingFeeDiscountShare,\\n        address _usdtToken,\\n        address _WETH,\\n        address _yfteToken\\n    ) public {\\n        governance = _governance;\\n        treasury = _treasury;\\n        priceOracle = _priceOracle;\\n        usdtListingFeeInUsd = _usdtListingFeeInUsd;\\n        wethListingFeeInUsd = _wethListingFeeInUsd;\\n        yfteListingFeeInUsd = _yfteListingFeeInUsd;\\n        treasuryListingFeeShare = _treasuryListingFeeShare;\\n        _setTargetListingLockupAmountInUsd(_targetListingLockupAmountInUsd);\\n        _setMinListingLockupAmountInUsd(_minListingLockupAmountInUsd);\\n        _setTargetListingLockupPeriod(_targetListingLockupPeriod);\\n        _setMinListingLockupPeriod(_minListingLockupPeriod);\\n        lockupAmountListingFeeDiscountShare = _lockupAmountListingFeeDiscountShare;\\n        USDT = _usdtToken;\\n        WETH = _WETH;\\n        YFTE = _yfteToken;\\n    }\\n\\n    function allPairsLength() external view override returns (uint256) {\\n        return allPairs.length;\\n    }\\n\\n    function _validatePair(address tokenA, address tokenB)\\n        private\\n        view\\n        returns (address token0, address token1)\\n    {\\n        require(tokenA != tokenB);\\n        (token0, token1) = tokenA < tokenB\\n            ? (tokenA, tokenB)\\n            : (tokenB, tokenA);\\n        require(token0 != address(0));\\n        require(getPair[token0][token1] == address(0)); // single check is sufficient\\n    }\\n\\n    function _createPair(address token0, address token1)\\n        private\\n        returns (address pair)\\n    {\\n        {\\n            bytes memory bytecode = type(TetherswapPair).creationCode;\\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n            assembly {\\n                pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n            }\\n        }\\n        TetherswapPair(pair).initialize(\\n            token0,\\n            token1,\\n            token0 == address(USDT) || token1 == address(USDT)\\n                ? defaultUsdtTradingFeePercent\\n                : defaultNonUsdtTradingFeePercent\\n        );\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function approvePairViaGovernance(address tokenA, address tokenB)\\n        external\\n        override\\n        onlyGovernance\\n        nonReentrant\\n    {\\n        (address token0, address token1) = _validatePair(tokenA, tokenB);\\n        approvedPair[token0][token1] = true;\\n    }\\n\\n    function _payListingFee(\\n        address listingFeeToken,\\n        uint256 lockupAmountInUsd,\\n        uint256 lockupPeriod\\n    ) private {\\n        require(\\n            listingFeeToken == USDT ||\\n                listingFeeToken == WETH ||\\n                listingFeeToken == YFTE\\n        );\\n        uint256 listingFeeTokenAmount;\\n        if (listingFeeToken == USDT) {\\n            listingFeeTokenAmount = ITetherswapPriceOracle(priceOracle)\\n                .calculateTokenAmountFromUsdAmount(USDT, usdtListingFeeInUsd);\\n        } else if (listingFeeToken == WETH) {\\n            listingFeeTokenAmount = ITetherswapPriceOracle(priceOracle)\\n                .calculateTokenAmountFromUsdAmount(WETH, wethListingFeeInUsd);\\n        } else if (listingFeeToken == YFTE) {\\n            ITetherswapPriceOracle(priceOracle).update();\\n            listingFeeTokenAmount = ITetherswapPriceOracle(priceOracle)\\n                .calculateTokenAmountFromUsdAmount(YFTE, yfteListingFeeInUsd);\\n        }\\n        uint256 discount;\\n        if (targetListingLockupAmountInUsd > minListingLockupAmountInUsd) {\\n            discount =\\n                lockupAmountListingFeeDiscountShare.mul(\\n                    lockupAmountInUsd.sub(minListingLockupAmountInUsd)\\n                ) /\\n                (\\n                    targetListingLockupAmountInUsd.sub(\\n                        minListingLockupAmountInUsd\\n                    )\\n                );\\n        }\\n        if (targetListingLockupPeriod > minListingLockupPeriod) {\\n            discount = discount.add(\\n                (uint256(1000000).sub(lockupAmountListingFeeDiscountShare)).mul(\\n                    lockupPeriod.sub(minListingLockupPeriod)\\n                ) / (targetListingLockupPeriod.sub(minListingLockupPeriod))\\n            );\\n        }\\n        uint256 discountedListingFeeTokenAmount =\\n            listingFeeTokenAmount.mul(uint256(1000000).sub(discount)) / 1000000;\\n        TransferHelper.safeTransferFrom(\\n            listingFeeToken,\\n            msg.sender,\\n            treasury,\\n            discountedListingFeeTokenAmount.mul(treasuryListingFeeShare) /\\n                1000000\\n        );\\n        TransferHelper.safeTransferFrom(\\n            listingFeeToken,\\n            msg.sender,\\n            governance,\\n            discountedListingFeeTokenAmount.mul(\\n                uint256(1000000).sub(treasuryListingFeeShare)\\n            ) / 1000000\\n        );\\n    }\\n\\n    function createPair(\\n        address newToken,\\n        uint256 newTokenAmount,\\n        address lockupToken, // USDT or WETH, or part of a governance-approved pair\\n        uint256 lockupTokenAmount,\\n        uint256 lockupPeriod,\\n        address listingFeeToken // can be zero address if governance-approved pair\\n    ) external override nonReentrant returns (address pair) {\\n        require(msg.sender != governance);\\n        require(newToken != address(0) && lockupToken != address(0));\\n        (address token0, address token1) = _validatePair(newToken, lockupToken);\\n        if (!approvedPair[token0][token1]) {\\n            require(\\n                lockupToken == USDT || lockupToken == WETH,\\n                \\\"TetherswapFactory: Pair Not Approved.\\\"\\n            );\\n            require(lockupPeriod >= minListingLockupPeriod);\\n            uint256 lockupAmountInUsd =\\n                ITetherswapPriceOracle(priceOracle)\\n                    .calculateUsdAmountFromTokenAmount(\\n                    lockupToken,\\n                    lockupTokenAmount\\n                );\\n            require(lockupAmountInUsd >= minListingLockupAmountInUsd);\\n            _payListingFee(listingFeeToken, lockupAmountInUsd, lockupPeriod);\\n        }\\n        pair = _createPair(token0, token1);\\n        uint256 liquidity;\\n        if (newTokenAmount > 0 && lockupTokenAmount > 0) {\\n            TransferHelper.safeTransferFrom(\\n                newToken,\\n                msg.sender,\\n                pair,\\n                newTokenAmount\\n            );\\n            TransferHelper.safeTransferFrom(\\n                lockupToken,\\n                msg.sender,\\n                pair,\\n                lockupTokenAmount\\n            );\\n            liquidity = TetherswapPair(pair).mint(msg.sender);\\n        }\\n        if (\\n            !approvedPair[token0][token1] &&\\n            lockupTokenAmount > 0 &&\\n            lockupPeriod > 0\\n        ) {\\n            TetherswapPair(pair).listingLock(\\n                msg.sender,\\n                lockupPeriod,\\n                liquidity\\n            );\\n        }\\n    }\\n\\n    function setPriceOracle(address _priceOracle)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        priceOracle = _priceOracle;\\n    }\\n\\n    function setTreasury(address _treasury) external override onlyGovernance {\\n        treasury = _treasury;\\n    }\\n\\n    function setGovernance(address _governance)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        require(_governance != address(0));\\n        governance = _governance;\\n    }\\n\\n    function setTreasuryProtocolFeeShare(uint256 _treasuryProtocolFeeShare)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        require(_treasuryProtocolFeeShare <= 1000000);\\n        treasuryProtocolFeeShare = _treasuryProtocolFeeShare;\\n    }\\n\\n    function setProtocolFeeFractionInverse(uint256 _protocolFeeFractionInverse)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        // max 50% of trading fee (2/1 * 1000)\\n        require(\\n            _protocolFeeFractionInverse >= 2000 ||\\n                _protocolFeeFractionInverse == 0\\n        );\\n        protocolFeeFractionInverse = _protocolFeeFractionInverse;\\n    }\\n\\n    function setUsdtListingFeeInUsd(uint256 _usdtListingFeeInUsd)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        usdtListingFeeInUsd = _usdtListingFeeInUsd;\\n    }\\n\\n    function setWethListingFeeInUsd(uint256 _wethListingFeeInUsd)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        wethListingFeeInUsd = _wethListingFeeInUsd;\\n    }\\n\\n    function setYfteListingFeeInUsd(uint256 _yfteListingFeeInUsd)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        yfteListingFeeInUsd = _yfteListingFeeInUsd;\\n    }\\n\\n    function setTreasuryListingFeeShare(uint256 _treasuryListingFeeShare)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        require(_treasuryListingFeeShare <= 1000000);\\n        treasuryListingFeeShare = _treasuryListingFeeShare;\\n    }\\n\\n    function _setMinListingLockupAmountInUsd(\\n        uint256 _minListingLockupAmountInUsd\\n    ) private {\\n        require(_minListingLockupAmountInUsd <= targetListingLockupAmountInUsd);\\n        if (_minListingLockupAmountInUsd > 0) {\\n            // needs to be at least 1000 due to TetherswapPair MINIMUM_LIQUIDITY subtraction\\n            require(_minListingLockupAmountInUsd >= 1000);\\n        }\\n        minListingLockupAmountInUsd = _minListingLockupAmountInUsd;\\n    }\\n\\n    function setMinListingLockupAmountInUsd(\\n        uint256 _minListingLockupAmountInUsd\\n    ) external override onlyGovernance {\\n        _setMinListingLockupAmountInUsd(_minListingLockupAmountInUsd);\\n    }\\n\\n    function _setTargetListingLockupAmountInUsd(\\n        uint256 _targetListingLockupAmountInUsd\\n    ) private {\\n        require(_targetListingLockupAmountInUsd >= minListingLockupAmountInUsd);\\n        targetListingLockupAmountInUsd = _targetListingLockupAmountInUsd;\\n    }\\n\\n    function setTargetListingLockupAmountInUsd(\\n        uint256 _targetListingLockupAmountInUsd\\n    ) external override onlyGovernance {\\n        _setTargetListingLockupAmountInUsd(_targetListingLockupAmountInUsd);\\n    }\\n\\n    function _setMinListingLockupPeriod(uint256 _minListingLockupPeriod)\\n        private\\n    {\\n        require(_minListingLockupPeriod <= targetListingLockupPeriod);\\n        minListingLockupPeriod = _minListingLockupPeriod;\\n    }\\n\\n    function setMinListingLockupPeriod(uint256 _minListingLockupPeriod)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        _setMinListingLockupPeriod(_minListingLockupPeriod);\\n    }\\n\\n    function _setTargetListingLockupPeriod(uint256 _targetListingLockupPeriod)\\n        private\\n    {\\n        require(_targetListingLockupPeriod >= minListingLockupPeriod);\\n        targetListingLockupPeriod = _targetListingLockupPeriod;\\n    }\\n\\n    function setTargetListingLockupPeriod(uint256 _targetListingLockupPeriod)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        _setTargetListingLockupPeriod(_targetListingLockupPeriod);\\n    }\\n\\n    function setLockupAmountListingFeeDiscountShare(\\n        uint256 _lockupAmountListingFeeDiscountShare\\n    ) external override onlyGovernance {\\n        require(_lockupAmountListingFeeDiscountShare <= 1000000);\\n        lockupAmountListingFeeDiscountShare = _lockupAmountListingFeeDiscountShare;\\n    }\\n\\n    function setDefaultUsdtTradingFeePercent(\\n        uint256 _defaultUsdtTradingFeePercent\\n    ) external override onlyGovernance {\\n        // max 1%\\n        require(_defaultUsdtTradingFeePercent <= 10000);\\n        defaultUsdtTradingFeePercent = _defaultUsdtTradingFeePercent;\\n    }\\n\\n    function setDefaultNonUsdtTradingFeePercent(\\n        uint256 _defaultNonUsdtTradingFeePercent\\n    ) external override onlyGovernance {\\n        // max 1%\\n        require(_defaultNonUsdtTradingFeePercent <= 10000);\\n        defaultNonUsdtTradingFeePercent = _defaultNonUsdtTradingFeePercent;\\n    }\\n\\n    function setMaxSlippagePercent(uint256 _maxSlippagePercent)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        // max 100%\\n        require(_maxSlippagePercent <= 100);\\n        maxSlippagePercent = _maxSlippagePercent;\\n    }\\n\\n    function setMaxSlippageBlocks(uint256 _maxSlippageBlocks)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        // min 1 block, max 7 days (15s/block)\\n        require(_maxSlippageBlocks >= 1 && _maxSlippageBlocks <= 40320);\\n        maxSlippageBlocks = _maxSlippageBlocks;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITetherswapFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface ITetherswapFactory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256 pairNum\\n    );\\n\\n    function USDT() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function YFTE() external view returns (address);\\n\\n    function governance() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function priceOracle() external view returns (address);\\n\\n    // USD amounts should be 8 dp precision\\n    // frontend should approve transfer of higher amount (e.g. 1.1x) due to price fluctuations\\n    function usdtListingFeeInUsd() external view returns (uint256);\\n\\n    function wethListingFeeInUsd() external view returns (uint256);\\n\\n    function yfteListingFeeInUsd() external view returns (uint256);\\n\\n    // need to divide share by 1,000,000 e.g. 100,000 is 10%\\n    // the rest goes to governance\\n    function treasuryListingFeeShare() external view returns (uint256);\\n\\n    function minListingLockupAmountInUsd() external view returns (uint256);\\n\\n    // if lockup amount is set to this or more, the lockup amount proportion of listing fee discount is fully unlocked\\n    // if less than this amount, then lockup amount proportion of listing fee discount is linearly interpolated from the distance between min and target lockup amounts e.g. 60% towards target from min means 60% of lockup amount discount\\n    function targetListingLockupAmountInUsd() external view returns (uint256);\\n\\n    // in seconds since unix epoch\\n    // min lockup period for the listing lockup amount\\n    function minListingLockupPeriod() external view returns (uint256);\\n\\n    // in seconds since unix epoch\\n    // if lockup period is set to this or longer, the lockup time proportion of listing fee discount is fully unlocked\\n    // if less than this period, then lockup time proportion of listing fee discount is linearly interpolated from the distance between min and target lockup times e.g. 60% towards target from min means 60% of lockup time discount\\n    function targetListingLockupPeriod() external view returns (uint256);\\n\\n    // need to divide share by 1,000,000 e.g. 100,000 is 10%\\n    // rest of listing fee discount is determined by lockup period\\n    function lockupAmountListingFeeDiscountShare()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // need to divide fee percents by 1,000,000 e.g. 3000 is 0.3000%\\n    function defaultUsdtTradingFeePercent() external view returns (uint256);\\n\\n    function defaultNonUsdtTradingFeePercent() external view returns (uint256);\\n\\n    // need to divide share by 1,000,000 e.g. 100,000 is 10%\\n    // the rest goes to governance\\n    function treasuryProtocolFeeShare() external view returns (uint256);\\n\\n    // inverse of protocol fee fraction, then multiplied by 1000.\\n    // e.g. if protocol fee is 3/7th of trading fee, then value = 7/3 * 1000 = 2333\\n    // set to 0 to disable protocol fee\\n    function protocolFeeFractionInverse() external view returns (uint256);\\n\\n    // need to divide by 100 e.g. 50 is 50%\\n    function maxSlippagePercent() external view returns (uint256);\\n\\n    // max slippage resets after this many blocks\\n    function maxSlippageBlocks() external view returns (uint256);\\n\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function approvedPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (bool approved);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function approvePairViaGovernance(address tokenA, address tokenB) external;\\n\\n    function createPair(\\n        address newToken,\\n        uint256 newTokenAmount,\\n        address lockupToken, // USDT or WETH\\n        uint256 lockupTokenAmount,\\n        uint256 lockupPeriod,\\n        address listingFeeToken\\n    ) external returns (address pair);\\n\\n    function setPriceOracle(address) external;\\n\\n    function setTreasury(address) external;\\n\\n    function setGovernance(address) external;\\n\\n    function setTreasuryProtocolFeeShare(uint256) external;\\n\\n    function setProtocolFeeFractionInverse(uint256) external;\\n\\n    function setUsdtListingFeeInUsd(uint256) external;\\n\\n    function setWethListingFeeInUsd(uint256) external;\\n\\n    function setYfteListingFeeInUsd(uint256) external;\\n\\n    function setTreasuryListingFeeShare(uint256) external;\\n\\n    function setMinListingLockupAmountInUsd(uint256) external;\\n\\n    function setTargetListingLockupAmountInUsd(uint256) external;\\n\\n    function setMinListingLockupPeriod(uint256) external;\\n\\n    function setTargetListingLockupPeriod(uint256) external;\\n\\n    function setLockupAmountListingFeeDiscountShare(uint256) external;\\n\\n    function setDefaultUsdtTradingFeePercent(uint256) external;\\n\\n    function setDefaultNonUsdtTradingFeePercent(uint256) external;\\n\\n    function setMaxSlippagePercent(uint256) external;\\n\\n    function setMaxSlippageBlocks(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITetherswapPriceOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface ITetherswapPriceOracle {\\n    function update() external;\\n\\n    // tokenAmount is to 18 dp, usdAmount is to 8 dp\\n    // token must be USDT / WETH / YFTE\\n    function calculateTokenAmountFromUsdAmount(address token, uint256 usdAmount)\\n        external\\n        view\\n        returns (uint256 tokenAmount);\\n\\n    // token must be USDT / WETH\\n    function calculateUsdAmountFromTokenAmount(\\n        address token,\\n        uint256 tokenAmount\\n    ) external view returns (uint256 usdAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMathTetherswap.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMathTetherswap {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"approve(address,uint256)\\\")));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper: APPROVE_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\\"transferFrom(address,address,uint256)\\\")));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper: TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"TransferHelper: ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TetherswapPair.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\nimport \\\"./libraries/SafeMathTetherswap.sol\\\";\\nimport \\\"./libraries/UQ112x112.sol\\\";\\nimport \\\"./interfaces/ITetherswapCallee.sol\\\";\\nimport \\\"./interfaces/ITetherswapFactory.sol\\\";\\nimport \\\"./interfaces/ITetherswapPair.sol\\\";\\n\\ncontract TetherswapPair is ITetherswapPair, ReentrancyGuard {\\n    using SafeMathTetherswap for uint256;\\n    using UQ112x112 for uint224;\\n\\n    string public constant override name = \\\"Tetherswap LP Token\\\";\\n    string public constant override symbol = \\\"TLP\\\";\\n    uint8 public constant override decimals = 18;\\n    uint256 public override totalSupply;\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    bytes32 public override DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant override PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint256) public override nonces;\\n\\n    uint256 public constant override MINIMUM_LIQUIDITY = 10**3;\\n    bytes4 private constant SELECTOR =\\n        bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n    mapping(address => uint256) public override addressToLockupExpiry;\\n    mapping(address => uint256) public override addressToLockupAmount;\\n\\n    address public override factory;\\n    address public override token0;\\n    address public override token1;\\n\\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n    uint256 public override price0CumulativeLast;\\n    uint256 public override price1CumulativeLast;\\n    uint256 public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n\\n    uint256 public override tradingFeePercent; // need to divide by 1,000,000, e.g. 3000 = 0.3%\\n    uint256 public override lastSlippageBlocks;\\n    uint256 public override priceAtLastSlippageBlocks;\\n    uint256 public override lastSwapPrice;\\n\\n    modifier onlyGovernance() {\\n        require(\\n            msg.sender == ITetherswapFactory(factory).governance(),\\n            \\\"Pair: FORBIDDEN\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor() public {\\n        factory = msg.sender;\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        uint256 _tradingFeePercent\\n    ) external override {\\n        require(msg.sender == factory, \\\"Pair: FORBIDDEN\\\"); // sufficient check\\n        token0 = _token0;\\n        token1 = _token1;\\n        tradingFeePercent = _tradingFeePercent;\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\\n                value\\n            );\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(deadline >= block.timestamp, \\\"Pair: EXPIRED\\\");\\n        bytes32 digest =\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR,\\n                    keccak256(\\n                        abi.encode(\\n                            PERMIT_TYPEHASH,\\n                            owner,\\n                            spender,\\n                            value,\\n                            nonces[owner]++,\\n                            deadline\\n                        )\\n                    )\\n                )\\n            );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == owner,\\n            \\\"Pair: INVALID_SIGNATURE\\\"\\n        );\\n        _approve(owner, spender, value);\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        override\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        )\\n    {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) private {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"Pair: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(\\n        uint256 balance0,\\n        uint256 balance1,\\n        uint112 _reserve0,\\n        uint112 _reserve1\\n    ) private {\\n        require(\\n            balance0 <= uint112(-1) && balance1 <= uint112(-1),\\n            \\\"Pair: OVERFLOW\\\"\\n        );\\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            // * never overflows, and + overflow is desired\\n            price0CumulativeLast +=\\n                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\\n                timeElapsed;\\n            price1CumulativeLast +=\\n                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\\n                timeElapsed;\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    function _mintFee(uint112 _reserve0, uint112 _reserve1)\\n        private\\n        returns (bool feeOn)\\n    {\\n        uint256 protocolFeeFractionInverse =\\n            ITetherswapFactory(factory).protocolFeeFractionInverse();\\n        feeOn = protocolFeeFractionInverse != 0;\\n        uint256 _kLast = kLast; // gas savings\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\\n                uint256 rootKLast = Math.sqrt(_kLast);\\n                if (rootK > rootKLast) {\\n                    uint256 liquidity =\\n                        totalSupply.mul(rootK.sub(rootKLast)).mul(1000) /\\n                            (\\n                                (\\n                                    rootK.mul(\\n                                        protocolFeeFractionInverse.sub(1000)\\n                                    )\\n                                )\\n                                    .add(rootKLast.mul(1000))\\n                            );\\n                    if (liquidity > 0) {\\n                        ITetherswapFactory TetherswapFactory =\\n                            ITetherswapFactory(factory);\\n                        uint256 treasuryProtocolFeeShare =\\n                            TetherswapFactory.treasuryProtocolFeeShare();\\n                        _mint(\\n                            TetherswapFactory.treasury(),\\n                            liquidity.mul(treasuryProtocolFeeShare) / 1000000\\n                        );\\n                        _mint(\\n                            TetherswapFactory.governance(),\\n                            liquidity.mul(\\n                                uint256(1000000).sub(treasuryProtocolFeeShare)\\n                            ) / 1000000\\n                        );\\n                    }\\n                }\\n            }\\n        } else if (_kLast != 0) {\\n            kLast = 0;\\n        }\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to)\\n        public\\n        override\\n        nonReentrant\\n        returns (uint256 liquidity)\\n    {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n        uint256 amount0 = balance0.sub(_reserve0);\\n        uint256 amount1 = balance1.sub(_reserve1);\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n        } else {\\n            liquidity = Math.min(\\n                amount0.mul(_totalSupply) / _reserve0,\\n                amount1.mul(_totalSupply) / _reserve1\\n            );\\n        }\\n        require(liquidity > 0, \\\"Pair: INSUFFICIENT_LIQUIDITY_MINTED\\\");\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    function _lock(\\n        address locker,\\n        uint256 lockupPeriod,\\n        uint256 liquidityLockupAmount\\n    ) private {\\n        if (lockupPeriod == 0 && liquidityLockupAmount == 0) return;\\n        if (addressToLockupExpiry[locker] == 0) {\\n            // not currently locked\\n            require(lockupPeriod > 0, \\\"Pair: ZERO_LOCKUP_PERIOD\\\");\\n            require(liquidityLockupAmount > 0, \\\"Pair: ZERO_LOCKUP_AMOUNT\\\");\\n            addressToLockupExpiry[locker] = block.timestamp.add(lockupPeriod);\\n        } else {\\n            // locking when already locked will extend lockup period\\n            addressToLockupExpiry[locker] = addressToLockupExpiry[locker].add(\\n                lockupPeriod\\n            );\\n        }\\n        addressToLockupAmount[locker] = addressToLockupAmount[locker].add(\\n            liquidityLockupAmount\\n        );\\n        _transfer(locker, address(this), liquidityLockupAmount);\\n        emit Lock(locker, lockupPeriod, liquidityLockupAmount);\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function listingLock(\\n        address lister,\\n        uint256 lockupPeriod,\\n        uint256 liquidityLockupAmount\\n    ) external override {\\n        require(msg.sender == factory, \\\"Pair: FORBIDDEN\\\");\\n        _lock(lister, lockupPeriod, liquidityLockupAmount);\\n    }\\n\\n    function lock(uint256 lockupPeriod, uint256 liquidityLockupAmount)\\n        external\\n        override\\n    {\\n        _lock(msg.sender, lockupPeriod, liquidityLockupAmount);\\n    }\\n\\n    function unlock() external override {\\n        require(\\n            addressToLockupExpiry[msg.sender] <= block.timestamp,\\n            \\\"Pair: BEFORE_EXPIRY\\\"\\n        );\\n        _transfer(address(this), msg.sender, addressToLockupAmount[msg.sender]);\\n        emit Unlock(msg.sender, addressToLockupAmount[msg.sender]);\\n        addressToLockupAmount[msg.sender] = 0;\\n        addressToLockupExpiry[msg.sender] = 0;\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256 amount0, uint256 amount1)\\n    {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n        uint256 liquidity = balanceOf[address(this)];\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n        require(\\n            amount0 > 0 && amount1 > 0,\\n            \\\"Pair: INSUFFICIENT_LIQUIDITY_BURNED\\\"\\n        );\\n        _burn(address(this), liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n        balance0 = IERC20(_token0).balanceOf(address(this));\\n        balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external override nonReentrant {\\n        require(\\n            amount0Out > 0 || amount1Out > 0,\\n            \\\"Pair: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        require(\\n            amount0Out < _reserve0 && amount1Out < _reserve1,\\n            \\\"Pair: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n\\n        uint256 balance0;\\n        uint256 balance1;\\n        {\\n            // scope for _token{0,1}, avoids stack too deep errors\\n            address _token0 = token0;\\n            address _token1 = token1;\\n            require(to != _token0 && to != _token1, \\\"Pair: INVALID_TO\\\");\\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n            if (data.length > 0)\\n                ITetherswapCallee(to).TetherswapCall(\\n                    msg.sender,\\n                    amount0Out,\\n                    amount1Out,\\n                    data\\n                );\\n            balance0 = IERC20(_token0).balanceOf(address(this));\\n            balance1 = IERC20(_token1).balanceOf(address(this));\\n            if (ITetherswapFactory(factory).maxSlippagePercent() > 0) {\\n                uint256 currentPrice = balance0.mul(1e18) / balance1;\\n                if (priceAtLastSlippageBlocks == 0) {\\n                    priceAtLastSlippageBlocks = currentPrice;\\n                    lastSlippageBlocks = block.number;\\n                } else {\\n                    bool resetSlippage =\\n                        lastSlippageBlocks.add(\\n                            ITetherswapFactory(factory).maxSlippageBlocks()\\n                        ) < block.number;\\n                    uint256 lastPrice =\\n                        resetSlippage\\n                            ? lastSwapPrice\\n                            : priceAtLastSlippageBlocks;\\n                    require(\\n                        currentPrice >=\\n                            lastPrice.mul(\\n                                uint256(100).sub(\\n                                    ITetherswapFactory(factory)\\n                                        .maxSlippagePercent()\\n                                )\\n                            ) /\\n                                100 &&\\n                            currentPrice <=\\n                            lastPrice.mul(\\n                                uint256(100).add(\\n                                    ITetherswapFactory(factory)\\n                                        .maxSlippagePercent()\\n                                )\\n                            ) /\\n                                100,\\n                        \\\"Pair: SlipLock\\\"\\n                    );\\n                    if (resetSlippage) {\\n                        priceAtLastSlippageBlocks = currentPrice;\\n                        lastSlippageBlocks = block.number;\\n                    }\\n                }\\n                lastSwapPrice = currentPrice;\\n            }\\n        }\\n        uint256 amount0In =\\n            balance0 > _reserve0 - amount0Out\\n                ? balance0 - (_reserve0 - amount0Out)\\n                : 0;\\n        uint256 amount1In =\\n            balance1 > _reserve1 - amount1Out\\n                ? balance1 - (_reserve1 - amount1Out)\\n                : 0;\\n        require(\\n            amount0In > 0 || amount1In > 0,\\n            \\\"Pair: INSUFFICIENT_INPUT_AMOUNT\\\"\\n        );\\n        {\\n            // scope for balance{0,1}Adjusted, avoids stack too deep errors\\n            uint256 balance0Adjusted =\\n                balance0.mul(1e6).sub(amount0In.mul(tradingFeePercent));\\n            uint256 balance1Adjusted =\\n                balance1.mul(1e6).sub(amount1In.mul(tradingFeePercent));\\n            require(\\n                balance0Adjusted.mul(balance1Adjusted) >=\\n                    uint256(_reserve0).mul(_reserve1).mul(1e6**2),\\n                \\\"Pair: K\\\"\\n            );\\n        }\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external override nonReentrant {\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        _safeTransfer(\\n            _token0,\\n            to,\\n            IERC20(_token0).balanceOf(address(this)).sub(reserve0)\\n        );\\n        _safeTransfer(\\n            _token1,\\n            to,\\n            IERC20(_token1).balanceOf(address(this)).sub(reserve1)\\n        );\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external override nonReentrant {\\n        _update(\\n            IERC20(token0).balanceOf(address(this)),\\n            IERC20(token1).balanceOf(address(this)),\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n\\n    function _setTradingFeePercent(uint256 _tradingFeePercent) private {\\n        // max 1%\\n        require(\\n            _tradingFeePercent <= 10000,\\n            \\\"Pair: INVALID_TRADING_FEE_PERCENT\\\"\\n        );\\n        tradingFeePercent = _tradingFeePercent;\\n    }\\n\\n    function setTradingFeePercent(uint256 _tradingFeePercent)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        _setTradingFeePercent(_tradingFeePercent);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n        // else z = 0\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UQ112x112.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITetherswapCallee.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface ITetherswapCallee {\\n    function TetherswapCall(\\n        address sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITetherswapPair.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./ITetherswapERC20.sol\\\";\\n\\ninterface ITetherswapPair is ITetherswapERC20 {\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Lock(\\n        address indexed sender,\\n        uint256 lockupPeriod,\\n        uint256 liquidityLockupAmount\\n    );\\n    event Unlock(address indexed sender, uint256 liquidityUnlocked);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function addressToLockupExpiry(address) external view returns (uint256);\\n\\n    function addressToLockupAmount(address) external view returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function tradingFeePercent() external view returns (uint256);\\n\\n    function lastSlippageBlocks() external view returns (uint256);\\n\\n    function priceAtLastSlippageBlocks() external view returns (uint256);\\n\\n    function lastSwapPrice() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function lock(uint256 lockupPeriod, uint256 liquidityLockupAmount) external;\\n\\n    function unlock() external;\\n\\n    function burn(address to)\\n        external\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function setTradingFeePercent(uint256 _tradingFeePercent) external;\\n\\n    // functions only callable by TetherswapFactory\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        uint256 _tradingFeePercent\\n    ) external;\\n\\n    function listingLock(\\n        address lister,\\n        uint256 lockupPeriod,\\n        uint256 liquidityLockupAmount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITetherswapERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface ITetherswapERC20 {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_usdtListingFeeInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wethListingFeeInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_yfteListingFeeInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treasuryListingFeeShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minListingLockupAmountInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_targetListingLockupAmountInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minListingLockupPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_targetListingLockupPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockupAmountListingFeeDiscountShare\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_usdtToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yfteToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pairNum\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"YFTE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"approvePairViaGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lockupToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockupTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupPeriod\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"listingFeeToken\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultNonUsdtTradingFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultUsdtTradingFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupAmountListingFeeDiscountShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippageBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippagePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minListingLockupAmountInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minListingLockupPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeFractionInverse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_defaultNonUsdtTradingFeePercent\",\"type\":\"uint256\"}],\"name\":\"setDefaultNonUsdtTradingFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_defaultUsdtTradingFeePercent\",\"type\":\"uint256\"}],\"name\":\"setDefaultUsdtTradingFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockupAmountListingFeeDiscountShare\",\"type\":\"uint256\"}],\"name\":\"setLockupAmountListingFeeDiscountShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSlippageBlocks\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippageBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSlippagePercent\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippagePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minListingLockupAmountInUsd\",\"type\":\"uint256\"}],\"name\":\"setMinListingLockupAmountInUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minListingLockupPeriod\",\"type\":\"uint256\"}],\"name\":\"setMinListingLockupPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"}],\"name\":\"setPriceOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_protocolFeeFractionInverse\",\"type\":\"uint256\"}],\"name\":\"setProtocolFeeFractionInverse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetListingLockupAmountInUsd\",\"type\":\"uint256\"}],\"name\":\"setTargetListingLockupAmountInUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetListingLockupPeriod\",\"type\":\"uint256\"}],\"name\":\"setTargetListingLockupPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_treasuryListingFeeShare\",\"type\":\"uint256\"}],\"name\":\"setTreasuryListingFeeShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_treasuryProtocolFeeShare\",\"type\":\"uint256\"}],\"name\":\"setTreasuryProtocolFeeShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usdtListingFeeInUsd\",\"type\":\"uint256\"}],\"name\":\"setUsdtListingFeeInUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wethListingFeeInUsd\",\"type\":\"uint256\"}],\"name\":\"setWethListingFeeInUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_yfteListingFeeInUsd\",\"type\":\"uint256\"}],\"name\":\"setYfteListingFeeInUsd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetListingLockupAmountInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetListingLockupPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryListingFeeShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryProtocolFeeShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtListingFeeInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethListingFeeInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yfteListingFeeInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TetherswapFactory","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000065d46a882f14a8bc02ca366fe23f211f20909b6000000000000000000000000065d46a882f14a8bc02ca366fe23f211f20909b6000000000000000000000000f50b57b8317aaab8a9ec567751684fb98f48dfbc0000000000000000000000000000000000000000000000000000003a3529440000000000000000000000000000000000000000000000000000000045d964b8000000000000000000000000000000000000000000000000000000002e90edd00000000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000746a52880000000000000000000000000000000000000000000000000000000246139ca8000000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000000000000000278d00000000000000000000000000000000000000000000000000000000000007a120000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000094f31ac896c9823d81cf9c2c93feceed4923218f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}