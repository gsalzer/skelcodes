{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\GFarmNFTInterface.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.5;\r\n\r\ninterface GFarmNFTInterface{\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function leverageID(uint8 _leverage) external pure returns(uint8);\r\n    function idToLeverage(uint id) external view returns(uint8);\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n\r\n// File: contracts\\GFarmTokenInterface.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\ninterface GFarmTokenInterface{\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function burn(address from, uint256 amount) external;\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n\r\n// File: @uniswap\\v2-core\\contracts\\interfaces\\IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\math\\SafeMath.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\GFarmNFTExchange.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\n\r\n\r\n\r\n\r\ncontract GFarmNFTExchange {\r\n\r\n    using SafeMath for uint;\r\n\r\n    // 1. Tokens\r\n    GFarmNFTInterface public immutable nft;\r\n    GFarmTokenInterface public immutable token;\r\n    IUniswapV2Pair public immutable lp;\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    IUniswapV2Pair constant ETH_USDC_PAIR = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\r\n\r\n    // 2. Store all NFTs for sale\r\n    struct Bidding{\r\n        uint nftID;\r\n        address payable seller;\r\n        uint start; // block\r\n        uint duration; // blocks\r\n        uint minBid; // 1e18\r\n        uint highestBid; // 1e18\r\n        uint highestBidMinusFees; // 1e18\r\n        address payable highestBidder;\r\n        uint bidCount;\r\n    }\r\n    mapping(uint => Bidding[]) public biddingsByLeverage;\r\n    mapping(uint => uint) public idToBiddingsByLeverageIndex; // nft id => index in biddingsByLeverage\r\n\r\n    // 3. GFARM2 pool\r\n    uint public accETHperGFARM; // 1e18\r\n    struct User{\r\n        uint provided; //1e18\r\n        uint debt; //1e18\r\n    }\r\n    mapping(address => User) public users;\r\n\r\n    // 4. Fees\r\n    uint public BID_FEE_P = 5;\r\n    uint public HIGHEST_BID_FEE_P = 25;\r\n    address public GOV;\r\n\r\n    // 5. Stats & Events\r\n    uint public totalEthDistributed;\r\n\r\n    event NewBidding(\r\n        address indexed seller,\r\n        uint nftID,\r\n        uint leverage,\r\n        uint duration,\r\n        uint minBid\r\n    );\r\n\r\n    event NewBid(\r\n        address indexed seller,\r\n        address indexed bidder,\r\n        uint nftID,\r\n        uint leverage,\r\n        uint amount\r\n    );\r\n\r\n    constructor(\r\n        GFarmNFTInterface _nft,\r\n        GFarmTokenInterface _token,\r\n        IUniswapV2Pair _lp,\r\n        address _gov){\r\n        nft = _nft;\r\n        token = _token;\r\n        lp = _lp;\r\n        GOV = _gov;\r\n    }\r\n\r\n    // UPDATE FEE PERCENTAGES - GOVERNANCE (EXCHANGE)\r\n\r\n    modifier onlyGov(){\r\n        require(msg.sender == GOV);\r\n        _;\r\n    }\r\n    function set_GOV(address _gov) external onlyGov{\r\n        GOV = _gov;\r\n    }\r\n    function set_BID_FEE_P(uint _fee) external onlyGov{\r\n        BID_FEE_P = _fee;\r\n    }\r\n    function set_HIGHEST_BID_FEE_P(uint _fee) external onlyGov{\r\n        HIGHEST_BID_FEE_P = _fee;\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS (EXCHANGE)\r\n\r\n    function removeBidding(uint _nftID) private{\r\n        uint leverage = nft.idToLeverage(_nftID);\r\n        Bidding[] storage leverageBiddings = biddingsByLeverage[leverage];\r\n\r\n        // 1. Update index of the last bidding of the array to this nft's index in the array\r\n        idToBiddingsByLeverageIndex[leverageBiddings[leverageBiddings.length - 1].nftID] = idToBiddingsByLeverageIndex[_nftID];\r\n\r\n        // 2. Copy last bidding of the array to replace this nft ID's listings with the last one\r\n        leverageBiddings[idToBiddingsByLeverageIndex[_nftID]] = leverageBiddings[leverageBiddings.length - 1];\r\n\r\n        // 3. Remove the last element of the biddings array\r\n        leverageBiddings.pop();\r\n\r\n        // 4. Remove index from mapping for this NFT\r\n        delete idToBiddingsByLeverageIndex[_nftID];\r\n\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS (EXCHANGE)\r\n\r\n    // 0. Modifiers\r\n    modifier notContract(){\r\n        require(tx.origin == msg.sender, \"Contracts not allowed.\");\r\n        _;\r\n    }\r\n    modifier listed(uint id){\r\n        require(isListed(id), \"This NFT isn't listed.\");\r\n        _;\r\n    }\r\n\r\n    // 1. Put an NFT for sale\r\n    function sell(uint _nftID, uint _minBid, uint _bidDuration) external notContract{\r\n        // 1. Bidding duration should be between 100 blocks and 100k blocks\r\n        require(_bidDuration >= 100 && _bidDuration <= 100000, \"Bidding duration should be between 100 and 100k blocks.\");\r\n\r\n        // 2. Transfer the NFT to this contract\r\n        nft.transferFrom(msg.sender, address(this), _nftID);\r\n\r\n        // 3. Store bidding\r\n        uint leverage = nft.idToLeverage(_nftID);\r\n        Bidding memory b = Bidding(_nftID, msg.sender, block.number, _bidDuration, _minBid, 0, 0, address(0), 0);\r\n\r\n        biddingsByLeverage[leverage].push(b);\r\n        idToBiddingsByLeverageIndex[_nftID] = biddingsByLeverage[leverage].length - 1;\r\n\r\n        // 4. Emit event\r\n        emit NewBidding(\r\n            msg.sender,\r\n            _nftID,\r\n            leverage,\r\n            _bidDuration,\r\n            _minBid\r\n        );\r\n    }\r\n\r\n    // 2. Place a bid for an NFT\r\n    function bid(uint _nftID) external payable notContract listed(_nftID){\r\n        uint leverage = nft.idToLeverage(_nftID);\r\n        Bidding storage b = biddingsByLeverage[leverage][idToBiddingsByLeverageIndex[_nftID]];\r\n\r\n        // 1. Verify msg.sender isn't the seller\r\n        require(msg.sender != b.seller, \"You can't bid for your own NFT.\");\r\n\r\n        // 2. Verify the bid hasn't ended\r\n        require(block.number < b.start.add(b.duration), \"Bidding has already ended.\");\r\n\r\n        // 3. Verify the bid is higher than the min bid\r\n        require(msg.value >= b.minBid && msg.value > b.highestBid, \"You must bid higher than the min bid and the highest bid.\");\r\n\r\n        // 4. If there was already a bid, send back the ETH to old bidder\r\n        if(b.highestBidder != address(0) && b.highestBid != 0){\r\n            b.highestBidder.transfer(b.highestBidMinusFees);\r\n        }\r\n\r\n        // 5. Set highest bidder & highest bid & add 1 to bid count\r\n        // 5% in fees go to GFARM2 stakers in the pool\r\n        uint fee = msg.value.mul(BID_FEE_P).div(100);\r\n        b.highestBid = msg.value;\r\n        b.highestBidMinusFees = msg.value.sub(fee);\r\n        b.highestBidder = msg.sender;\r\n        b.bidCount = b.bidCount.add(1);\r\n\r\n        // 6. Update pool accETHperGFARM\r\n        uint tokenBalance = token.balanceOf(address(this));\r\n        if(tokenBalance > 0){\r\n            accETHperGFARM = accETHperGFARM.add(\r\n                fee.mul(1e18).div(tokenBalance)\r\n            );\r\n        }\r\n\r\n        // 7. Store stats\r\n        totalEthDistributed = totalEthDistributed.add(fee);\r\n\r\n        // 8. Emit event\r\n        emit NewBid(\r\n            b.seller,\r\n            msg.sender,\r\n            _nftID,\r\n            leverage,\r\n            msg.value\r\n        );\r\n    }\r\n\r\n    // 3. Claim an NFT after the bid has ended\r\n    function claim(uint _nftID) external notContract listed(_nftID){\r\n        Bidding memory b = biddingsByLeverage[nft.idToLeverage(_nftID)][idToBiddingsByLeverageIndex[_nftID]];\r\n\r\n        // 1. Verify the bid has ended\r\n        require(block.number >= b.start.add(b.duration), \"Bidding hasn't ended.\");\r\n\r\n        // 2. Verify there was at least one bid\r\n        require(b.bidCount > 0, \"No bid was made.\");\r\n\r\n        // 3. Transfer the ETH to the seller (25% fee)\r\n        uint fee = b.highestBidMinusFees.mul(HIGHEST_BID_FEE_P).div(100);\r\n        b.seller.transfer(b.highestBidMinusFees.sub(fee));\r\n\r\n        // 4. Transfer the NFT to the highest bidder\r\n        nft.transferFrom(address(this), b.highestBidder, _nftID);\r\n\r\n        // 5. Remove the bidding\r\n        removeBidding(_nftID);\r\n\r\n        // 6. Pool\r\n        uint tokenBalance = token.balanceOf(address(this));\r\n        if(tokenBalance > 0){\r\n            accETHperGFARM = accETHperGFARM.add(\r\n                fee.mul(1e18).div(tokenBalance)\r\n            );\r\n        }\r\n\r\n        // 7. Store stats\r\n        totalEthDistributed = totalEthDistributed.add(fee);\r\n    }\r\n\r\n    // 4. Claim unsold NFT after bidding ends\r\n    function claimBack(uint _nftID) external notContract listed(_nftID){\r\n        Bidding memory b = biddingsByLeverage[nft.idToLeverage(_nftID)][idToBiddingsByLeverageIndex[_nftID]];\r\n\r\n        // 1. Verify there was 0 bid\r\n        require(b.bidCount == 0, \"Bids were made.\");\r\n\r\n        // 2. Verify the bid has ended\r\n        require(block.number >= b.start.add(b.duration), \"Bidding hasn't ended.\");\r\n\r\n        // 3. Send the NFT back to the seller\r\n        nft.transferFrom(address(this), b.seller, _nftID);\r\n\r\n        // 4. Remove the bidding\r\n        removeBidding(_nftID);\r\n    }\r\n\r\n    // 5. Biddings count for a leverage\r\n    function biddingsCountLeverage(uint _leverage) external view returns(uint){\r\n        return biddingsByLeverage[_leverage].length;\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS (EXCHANGE)\r\n\r\n    function isListed(uint _nftID) public view returns(bool){\r\n        return biddingsByLeverage[nft.idToLeverage(_nftID)].length > 0 &&\r\n        biddingsByLeverage[nft.idToLeverage(_nftID)][idToBiddingsByLeverageIndex[_nftID]].nftID == _nftID;\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS (POOL)\r\n\r\n    // 1. Harvest pending ETH rewards\r\n    function harvest() public notContract{\r\n        uint pending = pendingReward();\r\n        if(pending == 0){ return; }\r\n\r\n        // 1. Send pending rewards\r\n        msg.sender.transfer(pendingReward());\r\n\r\n        // 2. Update debt\r\n        User storage u = users[msg.sender];\r\n        u.debt = u.provided.mul(accETHperGFARM).div(1e18);\r\n    }\r\n\r\n    // 2. Get ETH pending reward\r\n    function pendingReward() view public returns(uint){\r\n        User memory u = users[msg.sender];\r\n        return u.provided.mul(accETHperGFARM).div(1e18).sub(u.debt);\r\n    }\r\n\r\n    // EXTERNAL FUNCTIONS (POOL)\r\n\r\n    // 1. Stake GFARM2 + harvest\r\n    function stake(uint amount) external notContract{\r\n        // 1. Transfer the GFARM2 to the contract\r\n        token.transferFrom(msg.sender, address(this), amount);\r\n\r\n        // 2. Harvest pending rewards\r\n        uint pending = pendingReward();\r\n        if(pending > 0){ msg.sender.transfer(pendingReward()); }\r\n\r\n        // 3. Set user provided & debt\r\n        User storage u = users[msg.sender];\r\n        u.provided = u.provided.add(amount);\r\n        u.debt = u.provided.mul(accETHperGFARM).div(1e18);\r\n    }\r\n\r\n    // 2. Unstake GFARM2 + harvest\r\n    function unstake(uint amount) external notContract{\r\n        // 1. Verify he doesn't unstake more than provided\r\n        User storage u = users[msg.sender];\r\n        require(amount <= u.provided, \"Unstaking more than provided.\");\r\n\r\n        // 2. Harvest pending rewards\r\n        uint pending = pendingReward();\r\n        if(pending > 0){ msg.sender.transfer(pendingReward()); }\r\n\r\n        // 3. Set user provided & debt\r\n        u.provided = u.provided.sub(amount);\r\n        u.debt = u.provided.mul(accETHperGFARM).div(1e18);\r\n\r\n        // 4. Transfer the GFARM2 to the address\r\n        token.transfer(msg.sender, amount);\r\n\r\n        // 5. Burn 10%\r\n        token.burn(msg.sender, amount.mul(10).div(100));\r\n    }\r\n\r\n    // USEFUL FRONT-END FUNCTIONS\r\n\r\n    // 1. ETH/USD price (1e5)\r\n    function getEthPrice() private view returns(uint){\r\n        (uint112 reserves0, uint112 reserves1, ) = ETH_USDC_PAIR.getReserves();\r\n        uint reserveUSDC;\r\n        uint reserveETH;\r\n\r\n        if(WETH == ETH_USDC_PAIR.token0()){\r\n            reserveETH = reserves0;\r\n            reserveUSDC = reserves1;\r\n        }else{\r\n            reserveUSDC = reserves0;\r\n            reserveETH = reserves1;\r\n        }\r\n        // Divide number of USDC by number of ETH\r\n        // we multiply by 1e12 because USDC only has 6 decimals\r\n        return reserveUSDC.mul(1e12).mul(1e5).div(reserveETH);\r\n    }\r\n\r\n    // 2. GFARM/ETH price (1e5)\r\n    function getGFarmPriceEth() private view returns(uint){\r\n        (uint112 reserves0, uint112 reserves1, ) = lp.getReserves();\r\n\r\n        uint reserveETH;\r\n        uint reserveGFARM;\r\n\r\n        if(WETH == lp.token0()){\r\n            reserveETH = reserves0;\r\n            reserveGFARM = reserves1;\r\n        }else{\r\n            reserveGFARM = reserves0;\r\n            reserveETH = reserves1;\r\n        }\r\n\r\n        return reserveETH.mul(1e5).div(reserveGFARM);\r\n    }\r\n\r\n    // TVL of GFARM2 staked in $ (1e5)\r\n    function TVL() external view returns(uint){\r\n        return token.balanceOf(address(this)).mul(getGFarmPriceEth()).mul(getEthPrice()).div(1e23);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract GFarmNFTInterface\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"contract GFarmTokenInterface\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minBid\",\"type\":\"uint256\"}],\"name\":\"NewBidding\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BID_FEE_P\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HIGHEST_BID_FEE_P\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TVL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accETHperGFARM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"biddingsByLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nftID\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"highestBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"highestBidMinusFees\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"highestBidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_leverage\",\"type\":\"uint256\"}],\"name\":\"biddingsCountLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"}],\"name\":\"claimBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToBiddingsByLeverageIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"}],\"name\":\"isListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lp\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"contract GFarmNFTInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bidDuration\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"set_BID_FEE_P\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"set_GOV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"set_HIGHEST_BID_FEE_P\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract GFarmTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEthDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GFarmNFTExchange","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"00000000000000000000000043ccd9ea8f64b8918267f7ee4a071d3e9168f9cd000000000000000000000000831091da075665168e01898c6dac004a867f1e1b0000000000000000000000003f759c3f4cdba32e69ddf607e0cdcc2547061b97000000000000000000000000c66fbe50dd33c9aadd65707f7088d597c86fe00f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://eafc2d44a5a859dea61e9df824d8c0e957905e751b1f673b4df0eaa83f31f2da"}]}