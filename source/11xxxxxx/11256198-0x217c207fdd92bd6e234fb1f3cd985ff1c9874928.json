{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^ 0.6.6;\r\n\r\ncontract MagicLamp{\r\n\tPyramid PiZZa = Pyramid(0x91683899ed812C1AC49590779cb72DA6BF7971fE); // Color Token Contract We all know and love\r\n\tBlackRock ogBlack = BlackRock(0x429A63F0ccAE3D3f36A6f06eFb5580B0FF66d1e5); // ???\r\n\taddress THIS = address(this);\r\n\tuint wishes; // life of the Genie... no wishes,,, actually granted\r\n\taddress carpetRider; // stays afloat with a colored kingdom\r\n\tuint carpetRiderHP; // health of the carpet rider\r\n\taddress GENIE; // did a lot of work, and sits back and earns money... burn rugs\r\n\tuint GENIE_g; // The generation the genie is on\r\n\tERC20 colorToken;\r\n\taddress address0 = address(0);\r\n\tmapping(address => address) gateway; // this is affiliate uplink thing.\r\n\tmapping(address => uint) pocket; // what you earn through affiliates\r\n\tmapping(address => bool) initiated;\r\n\tmapping(address => bool) ofRugs; // address that belong to rug tokens\r\n\r\n\t// need 7s for 6s\r\n\taddress[7][7][7] rugTokens; //for identifying rugToken when buying colored pizza\r\n\tmapping(uint8 => mapping(uint8 => mapping(uint8 => bool))) rugsInitiated;\r\n\r\n\taddress the66thCarpetKing; // Dev.\r\n\r\n\t//LAZY U.I. ... Because we have no events and... yeah\r\n\tmapping(uint => address ) rugTokenList;\r\n\tuint rugTokenListSize;\r\n\tuint genesis;\r\n\r\n\tconstructor() public{\r\n\t\tthe66thCarpetKing = msg.sender;\r\n\t\t// Dev starts off as a fragile form of everything.\r\n\t\tGENIE = the66thCarpetKing;\r\n\t\tcarpetRider = the66thCarpetKing;\r\n\t\tcolorToken = PiZZa.resolveToken();\r\n\t\tgateway[the66thCarpetKing] = the66thCarpetKing;\r\n\t\tinitiated[the66thCarpetKing] = true;\r\n\t\tgenesis = now;\r\n\t}\r\n\r\n\tfunction ClaimKingdom___FlyFloatingCastle(uint8 r, uint8 g, uint8 b) external{\r\n\t\taddress sender = msg.sender;\r\n\t\tif((\r\n\t\t\t(r>=0 && r<=3 && g>=0 && g<=3 && b>=0 && b<=3)\r\n\t\t\t||(rugTokenListSize == 0)\r\n\t\t)&& !rugsInitiated[r][g][b]\r\n\t\t){\r\n\t\t\tRugToken newRugSource = new RugToken(r, g, b, weight(sender), PiZZa);\r\n\t\t\taddress rugAddress = address(newRugSource);\r\n\t\t\trugTokens[r][g][b] = rugAddress;\r\n\t\t\ttimerEnds[rugAddress] = genesis;\r\n\t\t\trugTokenList[rugTokenListSize] = rugAddress;\r\n\t\t\tofRugs[rugAddress] = true;\r\n\t\t\t\r\n\t\t\tif( r!=6 ){\r\n\t\t\t\tX[rugAddress] = (rugTokenListSize-1)/8+1;\r\n\t\t\t\tY[rugAddress] = (rugTokenListSize-1)%8+1;\r\n\t\t\t\tcarpetKing[rugAddress] = sender;\r\n\t\t\t}else{\r\n\t\t\t\tfloatingCastle = rugAddress;\r\n\t\t\t}\r\n\t\t\tif(rugTokenListSize == 1){\r\n\t\t\t\tcaravan[rugAddress] = true;\r\n\t\t\t}\r\n\r\n\t\t\trugsInitiated[r][g][b] = true;\r\n\t\t\trugTokenListSize += 1;\r\n\t\t}else{\r\n\t\t\taddress kingdom = rugTokenList[r];\r\n\t\t\tif( kingdom == floatingCastle && sender == carpetRider && g>=1 && g<=8 && b>=1 && b<=8 && cooldown[floatingCastle] < now){\r\n\t\t\t\tX[floatingCastle] = g;\r\n\t\t\t\tY[floatingCastle] = b;\r\n\t\t\t\tresetCooldowns(floatingCastle);\r\n\t\t\t\t//Floating Phantom Attacks\r\n\t\t\t}else{\r\n\t\t\t\trevert();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfunction weight(address addr) internal view returns(uint colors){\r\n\t\treturn PiZZa.resolveWeight(addr);//crush friction fee and get around exploit of resolves hopping wallets\r\n\t}\r\n\tfunction rugsOf(address addr, address rugColor) public view returns(uint rugCount){\r\n\t\treturn RugToken(rugColor).balanceOf(addr);\r\n\t}\r\n\tfunction ofRug(address addr) public view returns(bool){\r\n\t\treturn ofRugs[addr];\r\n\t}\r\n\r\n\tfunction buy(address _gateway, uint _red, uint _green, uint _blue) public payable returns(uint bondsCreated){\r\n\t\t\r\n\t\trequire(rugTokenListSize == 65);//make sure shit doesn't pop off too early\r\n\t\taddress sender = msg.sender;\r\n\r\n\t\t//keep colors in check\r\n\t\tif(_red>1e18) _red = 1e18;\r\n\t\tif(_green>1e18) _green = 1e18;\r\n\t\tif(_blue>1e18) _blue = 1e18;\r\n\t\t\r\n\t\t(uint R, uint G, uint B) = colorToCluster(_red,  _green,  _blue);\r\n\r\n\t\taddress rugAddress = rugTokens[ R ][ G ][ B ];\r\n\r\n\t\tif( !initiated[sender] ){\r\n\t\t\tif(weight(_gateway)==0) _gateway = carpetKing[rugAddress];\r\n\t\t\tgateway[sender] = _gateway;\r\n\t\t\tinitiated[sender] = true;\r\n\t\t}\r\n\r\n\t\tuint createdPiZZa = PiZZa.buy{value: msg.value * 934 / 1000}(sender, _red, _green, _blue);\r\n\r\n\t\tif( msg.value > 0.001 ether){\r\n\t\t\tuint power = createdPiZZa/1e18;\r\n\t\t\tif(carpetRider != sender){\r\n\t\t\t\tif(rugAddress != floatingCastle){\r\n\r\n\t\t\t\t\tif( carpetRiderHP <= power ){\r\n\t\t\t\t\t\tcarpetRiderHP = power - carpetRiderHP;\r\n\r\n\t\t\t\t\t\t//erect new floating island\r\n\t\t\t\t\t\tif(caravan[rugAddress]){\r\n\t\t\t\t\t\t\tcaravan[floatingCastle] = true;\r\n\t\t\t\t\t\t\tcaravan[rugAddress] = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//Just a little \"chaos theory\" ...\r\n\t\t\t\t\t\t//this is dropping the clock pressure of people who bought at higher prices.\r\n\t\t\t\t\t\t//hard earned clockPressure dropping.\r\n\t\t\t\t\t\tdropClockPressure(floatingCastle);\r\n\t\t\t\t\t\tX[floatingCastle] = X[rugAddress];\r\n\t\t\t\t\t\tY[floatingCastle] = Y[rugAddress];\r\n\t\t\t\t\t\tfloatingCastle = rugAddress;\r\n\r\n\t\t\t\t\t\tendRound(THIS);//new Caravan Round\r\n\r\n\t\t\t\t\t\tcarpetRider = sender;\r\n\t\t\t\t\t}else{\t\t\r\n\t\t\t\t\t\tcarpetRiderHP -= power;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tif(rugAddress == floatingCastle){\r\n\t\t\t\t\tcarpetRiderHP += power;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(wishes > 0)\r\n\t\t\t\twishes -= 1;\r\n\t\t\t\r\n\t\t\tuint rugsToMake = createdPiZZa/1e18;\r\n\t\t\tif(rugsToMake>0)\r\n\t\t\t\tRugToken(rugAddress).mint(msg.sender, rugsToMake);\r\n\r\n\t\t\tif(wishes == 0){\r\n\t\t\t\tif(rugBurnRecordSetter[GENIE_g] != address0){\r\n\t\t\t\t\tGENIE = rugBurnRecordSetter[GENIE_g];\r\n\t\t\t\t\twishes = burnCount[ GENIE_g ][rugBurnRecordSetter[GENIE_g]];\r\n\t\t\t\t\tGENIE_g += 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpayDownline(rugAddress);\r\n\t\treturn createdPiZZa;\r\n\t}\r\n\r\n\r\n\tfunction payLevel(address lvl, uint ETH) internal returns(uint riderRugs){\r\n\t\taddress sender = msg.sender;\r\n\t\tif( weight( gateway[lvl] ) > weight(sender) ){\r\n\t\t\tpocket[ gateway[lvl] ] += ETH;\r\n\t\t}else{\r\n\t\t\triderRugs += ETH;\r\n\t\t\tgateway[lvl] = lvl==sender?carpetRider:sender;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction payDownline(address rugAddress) internal{\r\n\t\t//Affiliate Payouts\r\n\t\taddress sender = msg.sender;\r\n\t\tuint riderRugs;\r\n\t\tuint val = msg.value;\r\n\t\tuint _g = val * 6 / 1000;// Genie & FomoPot earnings*/\r\n\r\n\t\triderRugs += payLevel(sender, val * 3 / 100);\r\n\t\triderRugs += payLevel(gateway[sender], val * 2 / 100);\r\n\t\triderRugs += payLevel(gateway[gateway[sender]], val / 100);\r\n\r\n\t\tpocket[carpetRider] += riderRugs;\r\n\t\t\r\n\t\tuint _4King_and_Kingdom = _g/2;\r\n\t\t\r\n\t\tpocket[ ( (block.timestamp - genesis) < 2592000 )? the66thCarpetKing: carpetKing[rugAddress] ] += _4King_and_Kingdom/2;\r\n\t\t\r\n\t\tpocket[ rugAddress ] += _4King_and_Kingdom-_4King_and_Kingdom/2;\r\n\r\n\t\tpocket[ GENIE ] += _g - _g/2;\r\n\t}\r\n\r\n\tfunction colorToCluster(uint r, uint g, uint b) public pure returns(uint8 rC, uint8 gC, uint8 bC){\r\n\t\tuint GRAY_BLOCK = 1e18/5;\r\n\t\tif(r/GRAY_BLOCK == 2 && g/GRAY_BLOCK == 2 && b/GRAY_BLOCK == 2){\r\n\t\t\trC = 6;\r\n\t\t\tgC = 6;\r\n\t\t\tbC = 6;\r\n\t\t}else{\r\n\t\t\tuint C = (uint)(1e18) / 4;\r\n\t\t\tuint x = r;\r\n\t\t\trC = x>C*3?3:x>C*2?2:x>C?1:0;\r\n\t\t\tx = g;\r\n\t\t\tgC = x>C*3?3:x>C*2?2:x>C?1:0;\r\n\t\t\tx = b;\r\n\t\t\tbC = x>C*3?3:x>C*2?2:x>C?1:0;\r\n\t\t}\r\n\r\n\t\treturn (rC, gC, bC);\r\n\t}\r\n\r\n\tfunction tokenFallback(address from, uint value, bytes calldata _data) external{\r\n\t\taddress TOKEN = address( msg.sender );\r\n\t\trequire( value > 0 );\r\n\t\tif(TOKEN == address(colorToken) ){\r\n\t\t\tif( ofRug(from) ){\r\n\t\t\t\t//These resolves came from new carpetKings\r\n\t\t\t\taddress newKing = bytesToAddress(_data);\r\n\t\t\t\tif(newKing != address0/* keep this so you can pass in heals */){\r\n\t\t\t\t\tcarpetKing[from] = newKing;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tuint rugCount = rugsOf(THIS,from);\r\n\t\t\t\t\t\r\n\t\t\t\tif( timerEnds[from] > now && rugCount>1){\r\n\t\t\t\t\ttimerEnds[from] -= (timerEnds[from] - now) * rugCount / RugToken(from).totalSupply();\r\n\t\t\t\t\tRugToken(from).rugBurn(THIS, from, rugCount/2);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}else if( ofRug(TOKEN) ){\r\n\t\t\tif( !ofRug(from) ){\r\n\t\t\t\tuint rugMagic = value;\r\n\t\t\t\tif(from == carpetRider){\r\n\t\t\t\t\tif(carpetRider != GENIE && caravan[TOKEN] ){\r\n\r\n\t\t\t\t\t\tif(rugMagic >= wishes){\r\n\t\t\t\t\t\t\t//kill\r\n\t\t\t\t\t\t\tif(wishes>0){\r\n\t\t\t\t\t\t\t\twishes = 0;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tcolorToken.transfer( carpetRider, colorToken.balanceOf(THIS) );\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t//they're already dead\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t//damage\r\n\t\t\t\t\t\t\twishes -= rugMagic;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{revert();}\r\n\t\t\t\t}else{\r\n\t\t\t\t\trevert();\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tcolorImports[from][TOKEN] += value;\r\n\t\t\t\tif( ( caravan[from] || from == GENIE /* without (floatingCastle != GENIE) because \"Phantom Caravan\" */ ) && inRing(from,TOKEN,false)  )\r\n\t\t\t\t\tmoreShares(THIS, fomoRound[THIS], bytesToAddress(_data), value);\r\n\t\t\t}\r\n\t\t}else if( TOKEN == address(PiZZa) ){\r\n\t\t\t\r\n\t\t\taddress who = bytesToAddress(_data);\r\n\t\t\tif (who == address0){\r\n\t\t\t\tprizePizza[from] += value;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\trequire( ofRug(from) );\r\n\r\n\t\t\tuint additionalTime = now - RugToken(from).ageOfPiZZa()/scaleFactor;\r\n\r\n\t\t\t//taking this out because... living on the edge\r\n\t\t\t//require( additionalTime < (now - genesis) );\t\t\t\r\n\r\n\t\t\t//it's just more fair to add pressure based off of ETH,\r\n\t\t\t//and not up the exponential diffictulty of the bonding curve\r\n\t\t\tuint pETH = pizza2ETH(value);\r\n\r\n\t\t\t//the more clock weight, the more shares in fomo.\r\n\t\t\tuint clocks = additionalTime * pETH;\r\n\t\t\r\n\t\t\t//makes adding to the timer more and more difficult as more eth comes in.\r\n\t\t\t//this can become gamable with big players.\r\n\t\t\t//but that's why we're able to drop the clock pressure in special events\r\n\t\t\tclockPressureContribution[from] += pETH;\r\n\t\t\tpizzaClockPressure += pETH;\r\n\r\n\t\t\t\r\n\t\t\tadditionalTime = additionalTime / (pizzaClockPressure / pETH )\r\n\t\t\t//Give them a few different tools to fight the clock pressure from being gamed by big money.\r\n\t\t\t*( (caravan[from] || GENIE == from)?( value/1e18 /* YES... */ ):1 );\r\n\r\n\t\t\trequire( additionalTime > 0 && value >= 1e18 );\r\n\t\t\t\r\n\t\t\tuint fomo_round = fomoRound[from];\r\n\t\t\tcurrentLead[from][fomo_round] = who;\r\n\r\n\t\t\tuint timer = timerEnds[from];\r\n\t\t\tif( fomoInitiated[from][fomo_round]  && now <= timer){\r\n\t\t\t\ttimer += additionalTime;\r\n\t\t\t}else{\r\n\t\t\t\tfomoInitiated[from][fomo_round] = true;\r\n\t\t\t\ttimer = now + additionalTime;\r\n\t\t\t}\r\n\t\t\ttimerEnds[from] = timer;\r\n\t\t\t\r\n\t\t\tmoreShares(from, fomo_round, who, clocks);\r\n\t\t\tuint FOMO_PIZZA;\r\n\t\t\tuint caravanClockWeight = totalClockWeight[THIS][fomoRound[THIS]];\r\n\r\n\t\t\tif( ( caravan[from] || from == GENIE ) && caravanClockWeight > 0){\r\n\t\t\t\tFOMO_PIZZA += value/2;\r\n\t\t\t\tpizzaPerClock[THIS][fomoRound[THIS]] += (value/4) * scaleFactor / caravanClockWeight;\r\n\t\t\t}else{\r\n\t\t\t\tFOMO_PIZZA += value/4;\r\n\t\t\t\tkingsPizza[from] += (value/4);\r\n\t\t\t}\r\n\t\t\tprizePizza[from] += FOMO_PIZZA;\r\n\t\t\tpizzaPerClock[from][fomo_round] += (value - FOMO_PIZZA - (value/4)) * scaleFactor / totalClockWeight[from][fomo_round];\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction moreShares(address from, uint fomo_round, address who, uint shares) internal{\r\n\t\ttotalClockWeight[from][fomo_round] += shares;\r\n\t\tclockWeight[from][fomo_round][who] += shares;\r\n\t\tpayouts[from][fomo_round][who] += pizzaPerClock[from][fomo_round]*shares;\r\n\t}\r\n\r\n\tfunction bytesToAddress(bytes memory bys) internal pure returns (address addr){\r\n\t\tassembly {\r\n\t\t  addr := mload(add(bys,20))\r\n\t\t} \r\n\t}\r\n\r\n\tmapping(uint => address) rugBurnRecordSetter;\r\n\tmapping(uint => mapping(address => uint)) burnCount;\r\n\r\n\tfunction countBurnedRugs( address targetColor, address who, uint rugsBurned) external{\r\n\t\taddress sender = msg.sender;\r\n\t\trequire( ofRug(sender) );\r\n\r\n\t\tif(floatingCastle == targetColor || who == THIS){\r\n\t\t\t\r\n\t\t\tif(who == THIS){\r\n\t\t\t\twho = sender;\r\n\t\t\t\trugsBurned *= 2;\r\n\t\t\t}\r\n\r\n\t\t\tburnCount[GENIE_g][who] += rugsBurned;\r\n\t\t\tif( burnCount[GENIE_g][who] > burnCount[GENIE_g][ rugBurnRecordSetter[GENIE_g] ] )\r\n\t\t\t\trugBurnRecordSetter[GENIE_g] = who;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction dropClockPressure(address kingdom) internal{\r\n\t\tpizzaClockPressure -= clockPressureContribution[kingdom];\r\n\t\tclockPressureContribution[kingdom] = 0;\r\n\t}\r\n\r\n\r\n\tfunction addressPayable(address addr) internal pure returns(address payable){return address( uint160(addr) );}\r\n\r\n\tuint pizzaClockPressure;\r\n\tmapping(address => bool) caravan;\r\n\tmapping(address => bool) portals;\r\n\tmapping(address => uint) fomoRound;\r\n\tmapping(address => uint) timerEnds;\r\n\tmapping(address => uint) prizePizza;\r\n\tmapping(address => uint) kingsPizza;\r\n\tmapping(address => uint) cooldown;\r\n\tmapping(address => mapping(uint => bool)) fomoInitiated;\r\n\tmapping(address => uint) clockPressureContribution;\r\n\tmapping(address => mapping(uint => uint)) pizzaPerClock;\r\n\tmapping(address => mapping(uint => address)) currentLead;\r\n\tmapping(address => mapping(uint => uint)) totalClockWeight;\r\n\tmapping(address => mapping(uint => mapping(address => uint))) clockWeight;\r\n\tmapping(address => mapping(uint => mapping(address => uint))) payouts;\r\n    uint256 constant scaleFactor = 0x10000000000000000;\r\n\r\n\tfunction dividendsOf(address kingdom, uint _fomoRound, address player) public view returns(uint dividends, uint yourWeight, uint totalWeight){\r\n\t\treturn ( ( clockWeight[kingdom][_fomoRound][player] * pizzaPerClock[kingdom][_fomoRound] - payouts[kingdom][_fomoRound][player] ) / scaleFactor  ,clockWeight[kingdom][_fomoRound][player] , totalClockWeight[kingdom][_fomoRound] );  \r\n\t}\r\n\r\n\tfunction withdrawDividends(address[] memory kingdoms, uint[] memory fomoRounds, address destination) public{\r\n\t\taddress sender = msg.sender;\r\n\t\tuint $PIZZA;\r\n\t\tuint _fomoRound;\r\n\t\tif(destination == address0) destination = sender;\r\n\r\n\t\tfor(uint F; F<fomoRounds.length; F++){\r\n\t\t\t_fomoRound = fomoRounds[F];\r\n\t\t\t(uint x,,) = dividendsOf(kingdoms[F],_fomoRound, sender);\r\n\t\t\t$PIZZA += x;\r\n\t\t\tpayouts[kingdoms[F]][_fomoRound][sender] = clockWeight[kingdoms[F]][_fomoRound][sender] * pizzaPerClock[kingdoms[F]][_fomoRound];\r\n\t\t}\r\n\r\n\t\togBlack.mine();\r\n\r\n\t\tif(destination == address0) destination = sender;\r\n\r\n\t\tuint amount = pocket[sender];\r\n\t\tif( $PIZZA>0 )\r\n\t\t\tPiZZa.transfer( destination, $PIZZA);\r\n\t\tif( amount>0 ){\r\n\t\t\tpocket[sender] = 0;\r\n\t\t\t(bool success, ) = destination.call{value:amount}(\"\");\r\n\t        require(success);\r\n        }\r\n\t}\r\n\r\n\tfunction exitScam(address kingdom) public{\r\n\t\tif( now > timerEnds[kingdom] && fomoInitiated[kingdom][fomoRound[kingdom]] ){\t\t\r\n\t\t\tendRound(kingdom);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\treceive() external payable {}\r\n\tfunction endRound(address kingdom) internal{\r\n\t\tuint winners_pizza = prizePizza[kingdom];\r\n\t\tuint kings = kingsPizza[kingdom];\r\n\t\tprizePizza[kingdom] = 0;\r\n\t\tkingsPizza[kingdom] = 0;\r\n\t\tuint FR = fomoRound[kingdom];\r\n\t\tfomoRound[kingdom] += 1;\r\n\r\n\t\tif( kings + winners_pizza >0 ){\r\n\t\t\tportals[kingdom] = true;\r\n\t\t\t\r\n\t\t\taddress lastBuyer = currentLead[kingdom][FR];\r\n\t\t\tdropClockPressure(kingdom);\r\n\t\t\t(uint ETH,,) = PiZZa.sellBonds(winners_pizza + kings);\r\n\t\t\tuint FOMO_ETH = ETH * winners_pizza/(kings + winners_pizza);\r\n\t\t\tpocket[lastBuyer] += FOMO_ETH + pocket[kingdom];\r\n\t\t\tpocket[kingdom] = 0;\r\n\t\t\tpocket[carpetKing[kingdom]] += ETH - FOMO_ETH;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction lastXRounds(address perspective, uint R) public view returns(\r\n\t\taddress[] memory kingdoms,\r\n\t\tuint[] memory rounds,\r\n\t\tuint totalDividends,\r\n\t\tuint count\r\n\t){\r\n\t\trounds = new uint[](rugTokenListSize*R);\r\n\t\tkingdoms = new address[](rugTokenListSize*R);\r\n\t\t\r\n\t\taddress kingdomAddr;\r\n\t\tuint divs;\r\n\t\tuint FR;\r\n\t\tuint j;\r\n\t\tfor(uint i; i<rugTokenListSize+1; i+=1){\r\n\t\t\tif(i == rugTokenListSize){\r\n\t\t\t\tkingdomAddr = address0;\r\n\t\t\t}else{\r\n\t\t\t\tkingdomAddr = rugTokenList[i];\t\r\n\t\t\t}\r\n\t\t\tFR = fomoRound[kingdomAddr];\r\n\t\t\tfor(j=0; j<R; j+=1){\r\n\t\t\t\tif(j>FR) break;\r\n\t\t\t\t(divs,,) =  dividendsOf(kingdomAddr, FR-j, perspective);\r\n\t\t\t\tif(divs> 0){\r\n\t\t\t\t\ttotalDividends +=divs;\r\n\t\t\t\t\trounds[count] = FR-j;\r\n\t\t\t\t\tkingdoms[count] = kingdomAddr;\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction allKingdoms(address perspective) public view returns(\r\n\t\taddress[] memory address_,\r\n\t\tuint[] memory UINTs_\r\n\t){\r\n\r\n\t\tuint L = rugTokenListSize;\r\n\t\tUINTs_ = new uint[](L*21);\r\n\t\taddress_ = new address[](L*3);\r\n\t\t\r\n\t\tRugToken kingdom;\r\n\t\taddress kingdomAddr;\r\n\t\tfor(uint i; i<L; i+=1){\r\n\t\t\tkingdom = RugToken(rugTokenList[i]);\r\n\t\t\tkingdomAddr = rugTokenList[i];\r\n\t\t\t(UINTs_[i+L*12], UINTs_[i+L*13], UINTs_[i+L*14]) = kingdom._RGB();\r\n\r\n\t\t\tuint prizePiZZa = prizePizza[kingdomAddr];\r\n\t\t\tuint kingsPiZZa = kingsPizza[kingdomAddr];\r\n\t\t\tuint FR = fomoRound[kingdomAddr];\r\n\t\t\tUINTs_[i] = FR;\r\n\t\t\tUINTs_[i+L] = timerEnds[kingdomAddr];\r\n\t\t\tUINTs_[i+L*2] = fomoInitiated[kingdomAddr][FR]?1:0;\r\n\t\t\tUINTs_[i+L*3] = caravan[kingdomAddr]?1:0;\r\n\t\t\tUINTs_[i+L*4] = prizePiZZa;\r\n\t\t\tUINTs_[i+L*5] = pocket[kingdomAddr];\r\n\t\t\tUINTs_[i+L*6] = kingdom.lifeForce();\r\n\t\t\t(UINTs_[i+L*7], UINTs_[i+L*17], UINTs_[i+L*18]) = dividendsOf(kingdomAddr, FR, perspective);\r\n\t\t\tUINTs_[i+L*8] = rugsOf( perspective, kingdomAddr);\r\n\t\t\tUINTs_[i+L*9] = kingdom.totalSupply();\r\n\t\t\tUINTs_[i+L*10] = X[kingdomAddr];\r\n\t\t\tUINTs_[i+L*11] = Y[kingdomAddr];\r\n\t\t\tUINTs_[i+L*15] = cooldown[kingdomAddr];\r\n\t\t\tUINTs_[i+L*16] = pizza2ETH(prizePiZZa);\r\n\t\t\tUINTs_[i+L*19] = pizza2ETH(kingsPiZZa);\r\n\t\t\tUINTs_[i+L*20] = portals[kingdomAddr]?1:0;\r\n\t\t\taddress_[i] = kingdomAddr;\r\n\t\t\taddress_[i+L] = carpetKing[kingdomAddr];\r\n\t\t\taddress_[i+L*2] = currentLead[kingdomAddr][FR];\r\n\t\t}\r\n\t}\r\n\tfunction pizza2ETH(uint x)internal view returns(uint){\r\n\t\treturn x>0?PiZZa.calculateEthereumReceived(x):0;\r\n\t}\r\n\r\n\tmapping(address => address) carpetKing;\r\n\taddress floatingCastle;\r\n\tmapping(address => uint) X;\r\n\tmapping(address => uint) Y;\r\n\tmapping(address => mapping(address => uint)) colorImports;\r\n\t\r\n\r\n\tfunction proximity(address attacker, address defender)internal view returns(uint){\r\n\t\tuint x1 = X[attacker];\r\n\t\tuint x2 = X[defender];\r\n\t\tuint y1 = Y[attacker];\r\n\t\tuint y2 = Y[defender];\r\n\t\t\r\n\t\treturn (x1<x2?(x2-x1):(x1-x2)) + (y1<y2?(y2-y1):(y1-y2));\r\n\t}\r\n\r\n\tfunction switch_slide(address attacker, address defender, bool s_s, address[] memory kingdoms, bool justSwap)internal{\r\n\t\trequire(rugTokenListSize == 65);\r\n\t\tuint dX = X[defender];\r\n\t\tuint dY = Y[defender];\r\n\t\tuint aX = X[attacker];\r\n\t\tuint aY = Y[attacker];\r\n\t\tif(!s_s){\r\n\t\t\tif(attacker != floatingCastle && defender != floatingCastle){\r\n\t\t\t\tX[defender] = aX;\r\n\t\t\t\tY[defender] = aY;\r\n\t\t\t\tX[attacker] = dX;\r\n\t\t\t\tY[attacker] = dY;\r\n\r\n\t\t\t\tif(!justSwap){\r\n\t\t\t\t\tbool temp = caravan[attacker];\r\n\t\t\t\t\tcaravan[attacker] = caravan[defender];\r\n\t\t\t\t\tcaravan[defender] = temp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tuint i;\r\n\t\t\tuint j;\r\n\t\t\taddress K;\r\n\t\t\t//make sure none of the addresses are the same\r\n\t\t\trequire(kingdoms.length==6);\r\n\t\t\tfor( i =0; i<6;i++){\r\n\t\t\t\tK = kingdoms[i];\r\n\t\t\t\trequire( K!=attacker && K!=defender && ofRug(K) && K!=floatingCastle && ( aY == dY )?(Y[K] == aY):(X[K] == aX) );\r\n\t\t\t\tfor( j=i+1; j<6;j++){\r\n\t\t\t\t\trequire(K!=kingdoms[j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbool direction = !(aY > dY || aX > dX );\r\n\r\n\t\t\tloop(aY == dY , attacker, direction );\r\n\t\t\tloop(aY == dY , defender, direction );\r\n\t\t\tfor(i =0; i<6;i++){\r\n\t\t\t\tloop(aY == dY , kingdoms[i], direction );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction loop(bool XY, address K ,bool direction) internal{\r\n\t\tuint v;\r\n\t\tif(XY) v = X[K]; else v = Y[K];\r\n\t\tif(direction){\r\n\t\t\tif(v == 8){v=1;}\r\n\t\t\telse{v++;}\r\n\t\t}else{\r\n\t\t\tif(v == 1){v=8;}\r\n\t\t\telse{v--;}\r\n\t\t}\r\n\t\tif(XY) X[K] = v; else Y[K] = v;\r\n\t}\r\n\r\n\tfunction inRing(address attacker, address defender, bool self)internal returns(bool){\r\n\t\tuint distance = proximity(attacker,defender);\r\n\t\tif(self) cooldown[defender] = now;\r\n\t\tif(\r\n\t\t\t(distance == 2 && X[attacker] != X[defender] && Y[attacker] != Y[defender])\r\n\t\t\t||(distance == 1)\r\n\t\t\t||(self && attacker == defender)\r\n\t\t) return true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction usePortals(address kingdom, address[] memory swap1, address[] memory swap2) public{\r\n\t\trequire(carpetKing[kingdom] == msg.sender && portals[kingdom]);\r\n\t\tuint L = swap1.length;\r\n\t\t//make sure they are close or the current kingdom , part of the game, & unique\r\n\t\tuint i;\r\n\t\t\r\n\t\tportals[kingdom] = false;\r\n\t\tfor(i = 0; i<L;i++){\r\n\t\t\taddress s1 = swap1[i];\r\n\t\t\taddress s2 = swap2[i];\r\n\t\t\trequire( \r\n\t\t\t\t   (inRing(kingdom,s1,true))\r\n\t\t\t\t&& (inRing(s2,kingdom,true))//flipped this around so that we can get cooldown refreshes to everyone.\r\n\t\t\t\t&& s1 != s2\r\n\t\t\t\t&& ofRug(s1) \r\n\t\t\t\t&& ofRug(s2)\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tfor(i = 0; i<L;i++){switch_slide(swap1[i], swap2[i], false, new address[](0), true);}\r\n\t}\r\n\r\n\tfunction inBox(address kingdom) internal view returns(bool isInBox){\r\n\t\tuint x = X[kingdom];\r\n\t\tuint y = Y[kingdom];\r\n\t\treturn 6>=x && x>=3 && 6>=y && y>=3 && floatingCastle!=kingdom;\r\n\t}\r\n\r\n\r\n\tfunction fight( address attacker, address defender) internal returns(uint prizeTakenFromDefender, uint kingsTakenFromDefender,uint prizeTakenFromAttacker, uint kingsTakenFromAttacker, bool weightShift){\t\r\n\t\tRugToken Attacker = RugToken(attacker);\r\n\t\tRugToken Defender = RugToken(defender);\r\n\r\n\r\n\t\tuint ATTACK = colorImports[attacker][defender];\r\n\t\tuint DEFENSE = colorImports[defender][attacker];\r\n\t\t\r\n\t\tif(ATTACK + DEFENSE>0){\r\n\t\t\tif( inBox(attacker) )\r\n\t\t\t\tAttacker.lifeForceDamage(DEFENSE , ATTACK + DEFENSE);\r\n\t\t\telse{\r\n\t\t\t\tprizeTakenFromAttacker = prizePizza[attacker] * DEFENSE / (ATTACK + DEFENSE);\r\n\t\t\t\tkingsTakenFromAttacker = kingsPizza[attacker] * DEFENSE / (ATTACK + DEFENSE);\r\n\t\t\t}\r\n\r\n\t\t\tif( inBox(defender) )\r\n\t\t\t\tif(!caravan[defender] && defender != GENIE )//ABSOLUTE DEFENSE!\r\n\t\t\t\t\tDefender.lifeForceDamage(ATTACK , ATTACK + DEFENSE);\r\n\t\t\telse{\r\n\t\t\t\tprizeTakenFromDefender = prizePizza[defender] * ATTACK / (ATTACK + DEFENSE);\r\n\t\t\t\tkingsTakenFromDefender = kingsPizza[defender] * ATTACK / (ATTACK + DEFENSE);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tweightShift = ATTACK >= DEFENSE;\r\n\t}\r\n\r\n\tfunction rugpull(address attacker, address defender, address[] memory kingdoms) public{\r\n\t\taddress sender = msg.sender;\r\n\t\tif( sender == carpetKing[attacker] && ofRug(attacker) && ofRug(defender) && ( proximity(attacker,defender)==1 || attacker == floatingCastle) && defender!=floatingCastle && now > cooldown[attacker] ){\r\n\t\t\t\r\n\t\t\t(uint prizeTakenFromDefender, uint kingsTakenFromDefender, uint prizeTakenFromAttacker, uint kingsTakenFromAttacker, bool weightShift) = fight(attacker, defender);\r\n\r\n\t\t\tresetCooldowns(attacker);\r\n\t\t\tresetCooldowns(defender);\r\n\r\n\t\t\tif(!caravan[attacker])\r\n\t\t\t\tcolorImports[attacker][defender] = 0;\r\n\t\t\telse{\r\n\t\t\t\t//A source of clock pressure dropping that will scatter around the board\r\n\t\t\t\t//Chaos to prevent big droppers from gaming with large amounts\r\n\t\t\t\tdropClockPressure(attacker);\r\n\r\n\t\t\t\tuint tA = timerEnds[attacker];\r\n\t\t\t\tuint tD = timerEnds[defender];\r\n\t\t\t\t//to help minimize extreme clock times that can spike from holding lamp\r\n\t\t\t\tif( tD > now  && tA > now  ){\r\n\t\t\t\t\tif( tA > tD ){\r\n\t\t\t\t\t\ttimerEnds[attacker] -= (tA-now)/2;\r\n\t\t\t\t\t\ttimerEnds[defender] += (tA-now)/2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(!caravan[defender] && GENIE != defender)\r\n\t\t\t\tcolorImports[defender][attacker] = 0;\r\n\r\n\r\n\t\t\tif(attacker != floatingCastle){\r\n\t\t\t\tswitch_slide(attacker,defender, weightShift , kingdoms, false);\r\n\t\t\t}\r\n\r\n\t\t\t//underflow overflow... be mad\r\n\t\t\tprizePizza[defender] +=  prizeTakenFromAttacker - prizeTakenFromDefender;\r\n\t\t\tkingsPizza[defender] +=  kingsTakenFromAttacker - kingsTakenFromDefender;\r\n\t\t\tprizePizza[attacker] +=  prizeTakenFromDefender - prizeTakenFromAttacker;\r\n\t\t\tkingsPizza[attacker] +=  kingsTakenFromDefender - kingsTakenFromAttacker;\r\n\t\t\t\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\tfunction resetCooldowns(address kingdom) internal{\r\n\t\tuint timer = timerEnds[kingdom];\r\n\t\t//no singularities\r\n\t\tcooldown[kingdom] = timer<now?(now + (now-timer) ):timer;\r\n\t}\r\n\r\n\tfunction globalData( address perspective, address kingdom) public view returns(\r\n\t\taddress _GENIE,\r\n\t\tuint _wishes,\r\n\t\tuint _generation,\r\n\t\taddress _carpetRider,\r\n\t\tuint _carpetRiderHP,\r\n\t\taddress _floatingCastle,\r\n\t\taddress _gateway, \r\n\t\tuint _pocket , \r\n\t\tuint _pizzaClockPressure,\r\n\t\tuint[] memory _UINTs \r\n\t ){\r\n\t\t_GENIE = GENIE;\r\n\t\t_wishes = wishes;\r\n\t\t_generation = GENIE_g;\r\n\t\t_carpetRider = carpetRider;\r\n\t\t_carpetRiderHP = carpetRiderHP;\r\n\t\t_floatingCastle = floatingCastle;\r\n\t\t_gateway = gateway[perspective];\r\n\t\t_pocket = pocket[perspective];\r\n\t\t_pizzaClockPressure = pizzaClockPressure;\r\n\t\t\t\r\n\t\t_UINTs = new uint[](66);\r\n\t\tuint i;\r\n\t\tfor(i=0; i<65; i+=1){\r\n\t\t\t_UINTs[i] = colorImports[kingdom][rugTokenList[i]];\r\n\t\t}\r\n\r\n\t\t_UINTs[65] = fomoRound[THIS];\r\n\t}\r\n\r\n}\r\n\r\nabstract contract  BlackRock{\r\n\tfunction mine() public virtual;\r\n}\r\n\r\nabstract contract  ERC20{\r\n\tfunction transfer(address _to, uint _value) public virtual returns (bool);\r\n\tfunction transfer(address _to, uint _value, bytes memory _data) public virtual returns (bool);\r\n\tfunction RGB_Ratio(address addr) public view virtual returns(uint,uint,uint);\r\n\tfunction balanceOf(address _address) public view virtual returns (uint256 balance);\r\n}\r\n\r\nabstract contract Pyramid is ERC20{\r\n    function buy(address addr, uint _red, uint _green, uint _blue) public virtual payable returns(uint createdBonds);\r\n    function resolveToken() public view virtual returns(ERC20);\r\n    function average_buyInTimeSum(address addr) public virtual returns(uint);\r\n    function average_ethSpent(address addr) public virtual returns(uint);\r\n    function resolveWeight(address addr) public view virtual returns(uint);\r\n    function red(address addr) public virtual returns(uint);\r\n    function green(address addr) public virtual returns(uint);\r\n    function blue(address addr) public virtual returns(uint);\r\n    function sellBonds(uint amount) public virtual returns(uint returned_eth, uint returned_resolves, uint initialInput_ETH);\r\n    function calculateEthereumReceived(uint256 _tokensToSell) public virtual view returns(uint256);\r\n}\r\n\r\ncontract RugToken{\r\n\tstring public name = \"Comfy Rugs\";\r\n    string public symbol = \"_RUG\";\r\n    uint8 constant public decimals = 0;\r\n\taddress payable lampAddress;\r\n\tMagicLamp magicLamp;\r\n\tuint8[3] RGB;\r\n\tuint public ageOfPiZZa;\r\n\r\n\tfunction _RGB() public view returns(uint8 _R,uint8 _G,uint8 _B){\r\n\t\treturn (RGB[0],RGB[1],RGB[2]);\r\n\t}\r\n\taddress THIS = address(this);\r\n\r\n\tuint public lifeForce = 0;\r\n\tERC20 colorToken;\r\n\taddress carpetKing;\r\n\tPyramid PiZZa;\r\n\r\n\tconstructor(uint8 _R, uint8 _G, uint8 _B, uint life, Pyramid _PiZZa) public{\r\n\t\tlampAddress = msg.sender;\r\n\t\tlifeForce = life;\r\n\t\tmagicLamp = MagicLamp(lampAddress);\r\n\t\t\r\n\t\tRGB[0] = _R;\r\n\t\tRGB[1] = _G;\r\n\t\tRGB[2] = _B;\r\n\t\tPiZZa = _PiZZa;\r\n\t\tcolorToken = PiZZa.resolveToken();\r\n\t}\r\n\r\n\tfunction rebrand(string  memory _name, string  memory _symbol, bool namingStyle) public{\r\n\t\trequire(msg.sender == carpetKing);\r\n\t\tif(namingStyle)\r\n\t\t\tname = str(_name, \" Rugs\");\r\n\t\telse\r\n\t\t\tname = str(\"Rugs of \",_name);\r\n\r\n\t\tsymbol = str(_symbol, \"_RUG\");\r\n\t}\r\n\r\n\tfunction str(string memory X, string memory Y) internal pure returns(string memory){\r\n\t\treturn string(abi.encodePacked( X, Y));\r\n\t}\r\n\r\n\t//event NewCarpetKing(address carpetKing, uint newLife, bytes data);\r\n\tfunction tokenFallback(address from, uint value, bytes calldata _data) external{\r\n\t\taddress TOKEN = msg.sender;\r\n\t\tif( TOKEN == address(colorToken) ){\r\n\t\t\t\r\n\t\t\t(uint r, uint g, uint b) = colorToken.RGB_Ratio(THIS);\r\n\t\t\tif( value > lifeForce && colorMatch(r,g,b) ){\r\n\t\t\t\tcarpetKing = from;\r\n\t\t\t\tlifeForce = value;\r\n\t\t\t}\r\n\r\n\t\t\tthis.burnRugs(THIS,0);\r\n\r\n\t\t}else if(TOKEN == address( PiZZa )){\r\n\t\t\t(uint r, uint g, uint b) = PiZZa.RGB_Ratio(THIS);\r\n\t\t\tif( colorMatch(r,g,b) ){\r\n\t\t\t\tageOfPiZZa = PiZZa.average_buyInTimeSum(THIS) / PiZZa.average_ethSpent(THIS);\r\n\t\t\t\tPiZZa.transfer( lampAddress, PiZZa.balanceOf(THIS), abi.encodePacked( from ) );\r\n\t\t\t}else{\r\n\t\t\t\trevert();\r\n\t\t\t}\r\n\t\t}else if( magicLamp.ofRug(TOKEN) && TOKEN != THIS){\r\n\t\t\trequire(value>0);\r\n\t\t\tRugToken(TOKEN).transfer( lampAddress, magicLamp.rugsOf(THIS,TOKEN), abi.encodePacked( from ) );\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction colorMatch(uint r, uint g, uint b) internal view returns(bool){\r\n\t\t(uint8 rC, uint8 gC, uint8 bC) = magicLamp.colorToCluster(r,g,b);\r\n\t\treturn (RGB[0] == rC && RGB[1] == gC && RGB[2] == bC);\r\n\t}\r\n\r\n\tmodifier authOnly{\r\n\t  require( msg.sender == lampAddress || magicLamp.ofRug(msg.sender) );\r\n\t  _;\r\n    }\r\n\r\n\r\n\tfunction mint(address _address, uint _value) external authOnly(){\r\n\t\tbalances[_address] += _value;\r\n\t\t_totalSupply += _value;\r\n\t\tthis.burnRugs(THIS,0);\r\n\t}\r\n\r\n\tfunction burnRugs(address _address, uint _value) public authOnly(){\r\n\t\tbalances[_address] -= _value;\r\n\t\t_totalSupply -= _value;\r\n\r\n\t\tuint PIZZA = PiZZa.balanceOf(THIS);\r\n\t\tif(PIZZA>0)\r\n\t\t\tPiZZa.transfer( lampAddress, PIZZA );\r\n\t\t\r\n\t\tuint color = colorToken.balanceOf(THIS);\r\n\t\tif(color>0)\r\n\t\t\tcolorToken.transfer(lampAddress,color , abi.encodePacked(carpetKing) );\r\n\t}\r\n\r\n\tfunction rugBurn(address _target, address rugColor, uint _value) public {\r\n\t\taddress sender = msg.sender;\r\n\r\n\t\tuint targetsRugs = magicLamp.rugsOf(_target, rugColor);\r\n\t\trequire( \r\n\t\t\tmagicLamp.ofRug(rugColor)\r\n\t\t\t&& (THIS != rugColor || sender == lampAddress)\r\n\t\t\t&& _value <= balances[sender] \r\n\t\t\t&& _value > 0\r\n\t\t);\r\n\r\n\t\tuint damage;\r\n\t\tif( targetsRugs <= _value){\r\n\t\t\tdamage = targetsRugs;\r\n\t\t}else{\r\n\t\t\tdamage = _value;\r\n\t\t}\r\n\r\n\t\tburnRugs(sender, damage);\r\n\t\tRugToken(rugColor).burnRugs(_target, damage);\r\n\t\tmagicLamp.countBurnedRugs(rugColor, sender, damage);\r\n\r\n\t\temit RugBurn(sender, _target, damage);\r\n\t}\r\n\r\n\tfunction lifeForceDamage(uint N, uint D) external authOnly(){\r\n\t\tlifeForce = lifeForce * N/D;\r\n\t}\r\n\r\n\tmapping(address => uint256) balances;\r\n\r\n\tuint _totalSupply;\r\n\r\n\tmapping(address => mapping(address => uint)) approvals;\r\n\r\n\tevent Transfer(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 amount\r\n\t);\r\n\r\n\tevent RugBurn(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 amount\r\n\t);\r\n\t\r\n\tfunction totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _address) public view returns (uint256 balance) {\r\n\t\treturn balances[_address];\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint _value, bytes memory _data) public virtual returns (bool) {\r\n\t\tif( isContract(_to) ){\r\n\t\t\treturn transferToContract(_to, _value, _data);\r\n\t\t}else{\r\n\t\t\treturn transferToAddress(_to, _value);\r\n\t\t}\r\n\t}\r\n\t// Standard function transfer similar to ERC20 transfer with no _data.\r\n\t// Added due to backwards compatibility reasons .\r\n\tfunction transfer(address _to, uint _value) public virtual returns (bool) {\r\n\t\t//standard function transfer similar to ERC20 transfer with no _data\r\n\t\t//added due to backwards compatibility reasons\r\n\t\tbytes memory empty;\r\n\t\tif(isContract(_to)){\r\n\t\t\treturn transferToContract(_to, _value, empty);\r\n\t\t}else{\r\n\t\t\treturn transferToAddress(_to, _value);\r\n\t\t}\r\n\t}\r\n\r\n\t//function that is called when transaction target is an address\r\n\tfunction transferToAddress(address _to, uint _value) private returns (bool) {\r\n\t\tmoveTokens(msg.sender, _to, _value);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//function that is called when transaction target is a contract\r\n\tfunction transferToContract(address _to, uint _value, bytes memory _data) private returns (bool) {\r\n\t\tmoveTokens(msg.sender, _to, _value);\r\n\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n\t\treceiver.tokenFallback(msg.sender, _value, _data);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction moveTokens(address _from, address _to, uint _amount) internal virtual{\r\n\t\trequire( _amount <= balances[_from] );\r\n\t\tthis.burnRugs(THIS,0);\r\n\t\tbalances[_from] -= _amount;\r\n\t\tbalances[_to] += _amount;\r\n\t}\r\n\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return approvals[src][guy];\r\n    }\r\n  \t\r\n    function transferFrom(address src, address dst, uint amount) public returns (bool){\r\n        address sender = msg.sender;\r\n        require(approvals[src][sender] >=  amount);\r\n        require(balances[src] >= amount);\r\n        approvals[src][sender] -= amount;\r\n        moveTokens(src,dst,amount);\r\n        //bytes memory empty;\r\n        emit Transfer(sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    event Approval(address indexed src, address indexed guy, uint amount);\r\n    function approve(address guy, uint amount) public returns (bool) {\r\n        address sender = msg.sender;\r\n        approvals[sender][guy] = amount;\r\n\r\n        emit Approval( sender, guy, amount );\r\n        return true;\r\n    }\r\n\r\n    function isContract(address _addr) public view returns (bool is_contract) {\r\n\t\tuint length;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\tif(length>0) {\r\n\t\t\treturn true;\r\n\t\t}else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nabstract contract ERC223ReceivingContract{\r\n    function tokenFallback(address _from, uint _value, bytes calldata _data) external virtual;\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"r\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"g\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"b\",\"type\":\"uint8\"}],\"name\":\"ClaimKingdom___FlyFloatingCastle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"perspective\",\"type\":\"address\"}],\"name\":\"allKingdoms\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"address_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"UINTs_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_red\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_green\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blue\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bondsCreated\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"g\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"colorToCluster\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"rC\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"gC\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"bC\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetColor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rugsBurned\",\"type\":\"uint256\"}],\"name\":\"countBurnedRugs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"kingdom\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fomoRound\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yourWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"kingdom\",\"type\":\"address\"}],\"name\":\"exitScam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"perspective\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"kingdom\",\"type\":\"address\"}],\"name\":\"globalData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_GENIE\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_wishes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_generation\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_carpetRider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_carpetRiderHP\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_floatingCastle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pocket\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pizzaClockPressure\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_UINTs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"perspective\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"R\",\"type\":\"uint256\"}],\"name\":\"lastXRounds\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"kingdoms\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rounds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalDividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ofRug\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"attacker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defender\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"kingdoms\",\"type\":\"address[]\"}],\"name\":\"rugpull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rugColor\",\"type\":\"address\"}],\"name\":\"rugsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rugCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"kingdom\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"swap1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"swap2\",\"type\":\"address[]\"}],\"name\":\"usePortals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"kingdoms\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fomoRounds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"withdrawDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MagicLamp","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a6cd139ae45321d109000fd580ebc3f942a8216adc6ccd21d15fed434ef0273c"}]}