{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IMultisigCarrier.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract IMultisigCarrier {\r\n\r\n    function vaultParties(\r\n        address vaultAddress\r\n    ) public view returns (address[] memory);\r\n\r\n    function approveFrom(\r\n        address caller,\r\n        address payable destination,\r\n        address currencyAddress,\r\n        uint256 amount\r\n    ) public returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/MultisigVault.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract MultisigVault {\r\n\r\n    address private _carrier;\r\n\r\n    constructor() public {\r\n        _carrier = msg.sender;\r\n    }\r\n\r\n    function parties() public view returns (address[] memory) {\r\n        IMultisigCarrier multisigCarrier = IMultisigCarrier(_carrier);\r\n        return multisigCarrier.vaultParties(address(this));\r\n    }\r\n\r\n    function carrier() public view returns (address) {\r\n        return _carrier;\r\n    }\r\n\r\n    function approve(\r\n        address payable destination,\r\n        address currencyAddress,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        IMultisigCarrier multisigCarrier = IMultisigCarrier(_carrier);\r\n        return multisigCarrier.approveFrom(msg.sender, destination, currencyAddress, amount);\r\n    }\r\n\r\n    function external_call(address destination, uint value, bytes memory data) public returns (bool) {\r\n        require(msg.sender == _carrier, \"Carriable: caller is not the carrier\");\r\n\r\n        bool result;\r\n        assembly {\r\n            let dataLength := mload(data)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n                sub(gas(), 34710),   // 34710 is the value that solidity is currently emitting\r\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n                destination,\r\n                value,\r\n                d,\r\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n                0,\r\n                0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    function () external payable {}\r\n}\r\n\r\n// File: contracts/MultisigCarrier.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract MultisigCarrier {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct VaultInfo {\r\n        bool initiated;\r\n        uint8 signatureMinThreshold;\r\n        address[] parties;\r\n    }\r\n\r\n    struct Approval {\r\n        uint32 nonce;\r\n        uint8  coincieded;\r\n        bool   finished;\r\n        address[] parties;\r\n    }\r\n\r\n    uint32 private _nonce;\r\n    address private _owner;\r\n\r\n    mapping(\r\n        address => VaultInfo\r\n    ) private _vaultInfos;\r\n\r\n    mapping(\r\n        // MutlisigVault\r\n        address => mapping(\r\n            // Destination\r\n            address => mapping(\r\n                // Currency\r\n                address => mapping(\r\n                    // Amount\r\n                    uint256 => Approval\r\n                )\r\n            )\r\n        )\r\n    ) public _approvals;\r\n\r\n    mapping(uint256 => bool) public _finished;\r\n\r\n    event NewMultisigCarrierCreated(address multisigCarrierAddress);\r\n\r\n    /**\r\n      * @dev Construcor.\r\n      *\r\n      * Requirements:\r\n      * - `_signatureMinThreshold` .\r\n      * - `_parties`.\r\n      */\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n\r\n    function createMultisigVault() public returns (address) {\r\n        MultisigVault multisigVault = new MultisigVault();\r\n        VaultInfo storage vaultInfo = _vaultInfos[address(multisigVault)];\r\n        vaultInfo.initiated = true;\r\n\r\n        emit NewMultisigCarrierCreated(address(multisigVault));\r\n\r\n        return address(multisigVault);\r\n    }\r\n\r\n\r\n    function setVaultInfo(\r\n        address vaultAddress,\r\n        uint8 signatureMinThreshold,\r\n        address[] memory parties\r\n    ) public onlyOwner() returns (bool) {\r\n        require(signatureMinThreshold > 0, \"Parties are already set\");\r\n        require(parties.length > 0 && parties.length <= 10, \"Minimum 1, maximum 10 parties\");\r\n        require(signatureMinThreshold <= parties.length, \"Min signatures mismatches parties array\");\r\n\r\n        VaultInfo storage vaultInfo = _vaultInfos[vaultAddress];\r\n        require(vaultInfo.signatureMinThreshold == 0, \"Vault initialized already\");\r\n        vaultInfo.signatureMinThreshold = signatureMinThreshold;\r\n        vaultInfo.parties = parties;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function vaultParties(\r\n        address vaultAddress\r\n    ) public view returns (address[] memory) {\r\n        VaultInfo storage vaultInfo = _vaultInfos[vaultAddress];\r\n        return vaultInfo.parties;\r\n    }\r\n\r\n\r\n    function approve(\r\n        address payable vaultAddress,\r\n        address payable destination,\r\n        address currencyAddress,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        approveAndRelease(msg.sender, vaultAddress, destination, currencyAddress, amount);\r\n    }\r\n\r\n    function approveFrom(\r\n        address caller,\r\n        address payable destination,\r\n        address currencyAddress,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        approveAndRelease(caller, msg.sender, destination, currencyAddress, amount);\r\n    }\r\n\r\n\r\n    function approveAndRelease(\r\n        address caller,\r\n        address payable vaultAddress,\r\n        address payable destination,\r\n        address currencyAddress,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        VaultInfo storage vaultInfo = _vaultInfos[vaultAddress];\r\n\r\n        require(vaultInfo.initiated, \"Vault does not exist\");\r\n        require(containsParty(vaultInfo.parties, caller), \"Not a member\");\r\n\r\n        if (currencyAddress == etherAddress()) {\r\n            address multisig = address(vaultAddress);  // https://biboknow.com/page-ethereum/78597/solidity-0-6-0-addressthis-balance-throws-error-invalid-opcode\r\n            require(multisig.balance >= amount, \"Insufficient balance\");\r\n        } else {\r\n            require(IERC20(currencyAddress).balanceOf(address(vaultAddress)) >= amount, \"Insufficient balance\");\r\n        }\r\n\r\n        Approval storage approval = _approvals[vaultAddress][destination][currencyAddress][amount];\r\n\r\n        require(!containsParty(approval.parties, caller), \"Party already approved\");\r\n\r\n        if (approval.coincieded == 0) {\r\n            _nonce += 1;\r\n            approval.nonce = _nonce;\r\n        }\r\n\r\n        approval.parties.push(caller);\r\n        approval.coincieded += 1;\r\n\r\n        if ( approval.coincieded >= vaultInfo.signatureMinThreshold ) {\r\n            _finished[approval.nonce] = true;\r\n            delete _approvals[vaultAddress][destination][currencyAddress][amount];\r\n\r\n            releaseFunds(vaultAddress, destination, currencyAddress, amount);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    function getNonce(\r\n        address vaultAddress,\r\n        address destination,\r\n        address currencyAddress,\r\n        uint256 amount\r\n    ) public view returns (uint256) {\r\n        Approval storage approval = _approvals[vaultAddress][destination][currencyAddress][amount];\r\n\r\n        return approval.nonce;\r\n    }\r\n\r\n\r\n    function partyCoincieded(\r\n        address vaultAddress,\r\n        address destination,\r\n        address currencyAddress,\r\n        uint256 amount,\r\n        uint256 nonce,\r\n        address partyAddress\r\n    ) public view returns (bool) {\r\n        if ( _finished[nonce] ) {\r\n          return true;\r\n        } else {\r\n          Approval storage approval = _approvals[vaultAddress][destination][currencyAddress][amount];\r\n\r\n          require(approval.nonce == nonce, \"Nonce does not match\");\r\n\r\n          return containsParty(approval.parties, partyAddress);\r\n        }\r\n    }\r\n\r\n\r\n    function releaseFunds(\r\n        address payable vaultAddress,\r\n        address payable destination,\r\n        address currencyAddress,\r\n        uint256 amount\r\n    ) internal {\r\n        MultisigVault multisigVault = MultisigVault(vaultAddress);\r\n\r\n        if (currencyAddress == etherAddress()) {\r\n            multisigVault.external_call(destination, amount, \"\");\r\n        } else {\r\n            multisigVault.external_call(currencyAddress, 0, abi.encodeWithSelector(IERC20(currencyAddress).transfer.selector, destination, amount));\r\n        }\r\n    }\r\n\r\n\r\n    function containsParty(address[] memory parties, address party) internal pure returns (bool) {\r\n        for (uint256 i = 0; i < parties.length; i++) {\r\n          if ( parties[i] == party ) {\r\n            return true;\r\n          }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    function etherAddress() public pure returns (address) {\r\n        return address(0x0);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"multisigCarrierAddress\",\"type\":\"address\"}],\"name\":\"NewMultisigCarrierCreated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_approvals\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"coincieded\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_finished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createMultisigVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"partyAddress\",\"type\":\"address\"}],\"name\":\"partyCoincieded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"signatureMinThreshold\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"parties\",\"type\":\"address[]\"}],\"name\":\"setVaultInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"}],\"name\":\"vaultParties\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MultisigCarrier","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f5e97dd4feea1526485aae27baa7daf02201140012bc95cc09eee7873f4144b3"}]}