{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/Bytes.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n// Functions named bytesToX, except bytesToBytes20, where X is some type of size N < 32 (size of one word)\\n// implements the following algorithm:\\n// f(bytes memory input, uint offset) -> X out\\n// where byte representation of out is N bytes from input at the given offset\\n// 1) We compute memory location of the word W such that last N bytes of W is input[offset..offset+N]\\n// W_address = input + 32 (skip stored length of bytes) + offset - (32 - N) == input + offset + N\\n// 2) We load W from memory into out, last N bytes of W are placed into out\\n\\nlibrary Bytes {\\n    function toBytesFromUInt16(uint16 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 2);\\n    }\\n\\n    function toBytesFromUInt24(uint24 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 3);\\n    }\\n\\n    function toBytesFromUInt32(uint32 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 4);\\n    }\\n\\n    function toBytesFromUInt128(uint128 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 16);\\n    }\\n\\n    // Copies 'len' lower bytes from 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length 'len'.\\n    function toBytesFromUIntTruncated(uint256 self, uint8 byteLength) private pure returns (bytes memory bts) {\\n        require(byteLength <= 32, \\\"a\\\");\\n        bts = new bytes(byteLength);\\n        // Even though the bytes will allocate a full word, we don't want\\n        // any potential garbage bytes in there.\\n        uint256 data = self << ((32 - byteLength) * 8);\\n        assembly {\\n            mstore(\\n                add(bts, 32), // BYTES_HEADER_SIZE\\n                data\\n            )\\n        }\\n    }\\n\\n    // Copies 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length '20'.\\n    function toBytesFromAddress(address self) internal pure returns (bytes memory bts) {\\n        bts = toBytesFromUIntTruncated(uint256(self), 20);\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToAddress(bytes memory self, uint256 _start) internal pure returns (address addr) {\\n        uint256 offset = _start + 20;\\n        require(self.length >= offset, \\\"b\\\");\\n        assembly {\\n            addr := mload(add(self, offset))\\n        }\\n    }\\n\\n    // Reasoning about why this function works is similar to that of other similar functions, except NOTE below.\\n    // NOTE: that bytes1..32 is stored in the beginning of the word unlike other primitive types\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToBytes20(bytes memory self, uint256 _start) internal pure returns (bytes20 r) {\\n        require(self.length >= (_start + 20), \\\"c\\\");\\n        assembly {\\n            r := mload(add(add(self, 0x20), _start))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x2)\\n    function bytesToUInt16(bytes memory _bytes, uint256 _start) internal pure returns (uint16 r) {\\n        uint256 offset = _start + 0x2;\\n        require(_bytes.length >= offset, \\\"d\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x3)\\n    function bytesToUInt24(bytes memory _bytes, uint256 _start) internal pure returns (uint24 r) {\\n        uint256 offset = _start + 0x3;\\n        require(_bytes.length >= offset, \\\"e\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x4)\\n    function bytesToUInt32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 r) {\\n        uint256 offset = _start + 0x4;\\n        require(_bytes.length >= offset, \\\"f\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x10)\\n    function bytesToUInt128(bytes memory _bytes, uint256 _start) internal pure returns (uint128 r) {\\n        uint256 offset = _start + 0x10;\\n        require(_bytes.length >= offset, \\\"g\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x14)\\n    function bytesToUInt160(bytes memory _bytes, uint256 _start) internal pure returns (uint160 r) {\\n        uint256 offset = _start + 0x14;\\n        require(_bytes.length >= offset, \\\"h\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x20)\\n    function bytesToBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 r) {\\n        uint256 offset = _start + 0x20;\\n        require(_bytes.length >= offset, \\\"i\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\\n    // Get slice from bytes arrays\\n    // Returns the newly created 'bytes memory'\\n    // NOTE: theoretically possible overflow of (_start + _length)\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_bytes.length >= (_start + _length), \\\"j\\\"); // bytes length is less then start byte + length bytes\\n\\n        bytes memory tempBytes = new bytes(_length);\\n\\n        if (_length != 0) {\\n            // TODO: Review this thoroughly.\\n            assembly {\\n                let slice_curr := add(tempBytes, 0x20)\\n                let slice_end := add(slice_curr, _length)\\n\\n                for {\\n                    let array_current := add(_bytes, add(_start, 0x20))\\n                } lt(slice_curr, slice_end) {\\n                    slice_curr := add(slice_curr, 0x20)\\n                    array_current := add(array_current, 0x20)\\n                } {\\n                    mstore(slice_curr, mload(array_current))\\n                }\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// Reads byte stream\\n    /// @return new_offset - offset + amount of bytes read\\n    /// @return data - actually read data\\n    // NOTE: theoretically possible overflow of (_offset + _length)\\n    function read(\\n        bytes memory _data,\\n        uint256 _offset,\\n        uint256 _length\\n    ) internal pure returns (uint256 new_offset, bytes memory data) {\\n        data = slice(_data, _offset, _length);\\n        new_offset = _offset + _length;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readBool(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, bool r) {\\n        new_offset = _offset + 1;\\n        r = uint8(_data[_offset]) != 0;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readUint8(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint8 r) {\\n        new_offset = _offset + 1;\\n        r = uint8(_data[_offset]);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 2)\\n    function readUInt16(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint16 r) {\\n        new_offset = _offset + 2;\\n        r = bytesToUInt16(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 3)\\n    function readUInt24(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint24 r) {\\n        new_offset = _offset + 3;\\n        r = bytesToUInt24(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 4)\\n    function readUInt32(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint32 r) {\\n        new_offset = _offset + 4;\\n        r = bytesToUInt32(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 16)\\n    function readUInt128(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint128 r) {\\n        new_offset = _offset + 16;\\n        r = bytesToUInt128(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readUInt160(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint160 r) {\\n        new_offset = _offset + 20;\\n        r = bytesToUInt160(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readAddress(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, address r) {\\n        new_offset = _offset + 20;\\n        r = bytesToAddress(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readBytes20(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, bytes20 r) {\\n        new_offset = _offset + 20;\\n        r = bytesToBytes20(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 32)\\n    function readBytes32(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, bytes32 r) {\\n        new_offset = _offset + 32;\\n        r = bytesToBytes32(_data, _offset);\\n    }\\n\\n    /// Trim bytes into single word\\n    function trim(bytes memory _data, uint256 _new_length) internal pure returns (uint256 r) {\\n        require(_new_length <= 0x20, \\\"k\\\"); // new_length is longer than word\\n        require(_data.length >= _new_length, \\\"l\\\"); // data is to short\\n\\n        uint256 a;\\n        assembly {\\n            a := mload(add(_data, 0x20)) // load bytes into uint256\\n        }\\n\\n        return a >> ((0x20 - _new_length) * 8);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/BytesTest.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\nimport \\\"../Bytes.sol\\\";\\n\\ncontract BytesTest {\\n    function read(\\n        bytes calldata _data,\\n        uint256 _offset,\\n        uint256 _len\\n    ) external pure returns (uint256 new_offset, bytes memory data) {\\n        return Bytes.read(_data, _offset, _len);\\n    }\\n\\n    function testUInt24(uint24 x) external pure returns (uint24 r, uint256 offset) {\\n        require(keccak256(new bytes(0)) == keccak256(new bytes(0)));\\n\\n        bytes memory buf = Bytes.toBytesFromUInt24(x);\\n        (offset, r) = Bytes.readUInt24(buf, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/ZkSync.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeMathUInt128.sol\\\";\\nimport \\\"./SafeCast.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\nimport \\\"./Storage.sol\\\";\\nimport \\\"./Config.sol\\\";\\nimport \\\"./Events.sol\\\";\\n\\nimport \\\"./Bytes.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\nimport \\\"./UpgradeableMaster.sol\\\";\\n\\n/// @title zkSync main contract\\n/// @author Matter Labs\\ncontract ZkSync is UpgradeableMaster, Storage, Config, Events, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using SafeMathUInt128 for uint128;\\n\\n    bytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n    /// @notice Data needed to process onchain operation from block public data.\\n    /// @notice Onchain operations is operations that need some processing on L1: Deposits, Withdrawals, ChangePubKey.\\n    /// @param publicDataOffset Byte offset in public data for onchain operation\\n    /// @param ethWitness Some external data that can be needed for operation processing\\n    struct OnchainOperationData {\\n        uint32 publicDataOffset;\\n        bytes ethWitness;\\n    }\\n\\n    /// @notice Data needed to commit new block\\n    struct CommitBlockInfo {\\n        uint32 blockNumber;\\n        uint32 feeAccount;\\n        bytes32 newStateHash;\\n        bytes publicData;\\n        uint256 timestamp;\\n        OnchainOperationData[] onchainOperations;\\n    }\\n\\n    /// @notice Data needed to execute committed and verified block\\n    /// @param commitmentsInSlot verified commitments in one slot\\n    /// @param commitmentIdx index such that commitmentsInSlot[commitmentIdx] is current block commitment\\n    struct ExecuteBlockInfo {\\n        StoredBlockInfo storedBlock;\\n        bytes[] pendingOnchainOpsPubdata;\\n    }\\n\\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\\n    struct ProofInput {\\n        uint256[] recursiveInput;\\n        uint256[] proof;\\n        uint256[] commitments;\\n        uint8[] vkIndexes;\\n        uint256[16] subproofsLimbs;\\n    }\\n\\n    // Upgrade functional\\n\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external pure override returns (uint256) {\\n        return UPGRADE_NOTICE_PERIOD;\\n    }\\n\\n    /// @notice Notification that upgrade notice period started\\n    function upgradeNoticePeriodStarted() external override {}\\n\\n    /// @notice Notification that upgrade preparation status is activated\\n    function upgradePreparationStarted() external override {\\n        upgradePreparationActive = true;\\n        upgradePreparationActivationTime = block.timestamp;\\n    }\\n\\n    /// @notice Notification that upgrade canceled\\n    function upgradeCanceled() external override {\\n        upgradePreparationActive = false;\\n        upgradePreparationActivationTime = 0;\\n    }\\n\\n    /// @notice Notification that upgrade finishes\\n    function upgradeFinishes() external override {\\n        upgradePreparationActive = false;\\n        upgradePreparationActivationTime = 0;\\n    }\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external view override returns (bool) {\\n        return !exodusMode;\\n    }\\n\\n    /// @notice zkSync contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param initializationParameters Encoded representation of initialization parameters:\\n    /// @dev _governanceAddress The address of Governance contract\\n    /// @dev _verifierAddress The address of Verifier contract\\n    /// @dev _genesisStateHash Genesis blocks (first block) state tree root hash\\n    function initialize(bytes calldata initializationParameters) external {\\n        initializeReentrancyGuard();\\n\\n        (address _governanceAddress, address _verifierAddress, bytes32 _genesisStateHash) =\\n            abi.decode(initializationParameters, (address, address, bytes32));\\n\\n        verifier = Verifier(_verifierAddress);\\n        governance = Governance(_governanceAddress);\\n\\n        // We need initial state hash because it is used in the commitment of the next block\\n        StoredBlockInfo memory storedBlockZero =\\n            StoredBlockInfo(0, 0, EMPTY_STRING_KECCAK, 0, _genesisStateHash, bytes32(0));\\n\\n        storedBlockHashes[0] = hashStoredBlockInfo(storedBlockZero);\\n    }\\n\\n    /// @notice zkSync contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {\\n        require(upgradeParameters.length == 0, \\\"af\\\"); // upgrade parameters should be empty\\n\\n        // Convert last verified block from old format to new format\\n        require(totalBlocksCommitted == totalBlocksExecuted, \\\"ag\\\"); // all blocks should be verified\\n        require(numberOfPendingWithdrawals_DEPRECATED == 0, \\\"ah\\\"); // pending withdrawal is not used anymore\\n        require(totalOpenPriorityRequests == 0, \\\"ai\\\"); // no uncommitted priority requests\\n\\n        Block_DEPRECATED memory lastBlock = blocks_DEPRECATED[totalBlocksExecuted];\\n        require(lastBlock.priorityOperations == 0, \\\"aj\\\"); // last block should not contain priority operations\\n\\n        StoredBlockInfo memory rehashedLastBlock =\\n            StoredBlockInfo(\\n                totalBlocksExecuted,\\n                lastBlock.priorityOperations,\\n                EMPTY_STRING_KECCAK,\\n                0,\\n                lastBlock.stateRoot,\\n                lastBlock.commitment\\n            );\\n        storedBlockHashes[totalBlocksExecuted] = hashStoredBlockInfo(rehashedLastBlock);\\n        totalBlocksProven = totalBlocksExecuted;\\n    }\\n\\n    /// @notice Sends tokens\\n    /// @dev NOTE: will revert if transfer call fails or rollup balance difference (before and after transfer) is bigger than _maxAmount\\n    /// @param _tokenAddress Token address\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @param _maxAmount Maximum possible amount of tokens to transfer to this account\\n    function withdrawERC20Guarded(\\n        address _tokenAddress,\\n        address _to,\\n        uint128 _amount,\\n        uint128 _maxAmount\\n    ) external returns (uint128 withdrawnAmount) {\\n        require(msg.sender == address(this), \\\"ak\\\"); // wtg10 - can be called only from this contract as one \\\"external\\\" call (to revert all this function state changes if it is needed)\\n        IERC20 token = IERC20(_tokenAddress);\\n\\n        uint256 balanceBefore = token.balanceOf(address(this));\\n        require(Utils.sendERC20(token, _to, _amount), \\\"al\\\"); // wtg11 - ERC20 transfer fails\\n        uint256 balanceAfter = token.balanceOf(address(this));\\n        uint256 balanceDiff = balanceBefore.sub(balanceAfter);\\n        require(balanceDiff <= _maxAmount, \\\"am\\\"); // wtg12 - rollup balance difference (before and after transfer) is bigger than _maxAmount\\n\\n        return SafeCast.toUint128(balanceDiff);\\n    }\\n\\n    /// @notice Accrues users balances from deposit priority requests in Exodus mode\\n    /// @dev WARNING: Only for Exodus mode\\n    /// @dev Canceling may take several separate transactions to be completed\\n    /// @param _n number of requests to process\\n    function cancelOutstandingDepositsForExodusMode(uint64 _n, bytes[] memory depositsPubdata) external nonReentrant {\\n        require(exodusMode, \\\"an\\\"); // exodus mode not active\\n        uint64 toProcess = Utils.minU64(totalOpenPriorityRequests, _n);\\n        require(toProcess > 0, \\\"ao\\\"); // no deposits to process\\n        uint64 currentDepositIdx = 0;\\n        for (uint64 id = firstPriorityRequestId; id < firstPriorityRequestId + toProcess; id++) {\\n            if (priorityRequests[id].opType == Operations.OpType.Deposit) {\\n                bytes memory depositPubdata = depositsPubdata[currentDepositIdx];\\n                require(Utils.hashBytesToBytes20(depositPubdata) == priorityRequests[id].hashedPubData, \\\"ap\\\");\\n                ++currentDepositIdx;\\n\\n                Operations.Deposit memory op = Operations.readDepositPubdata(depositPubdata);\\n                bytes22 packedBalanceKey = packAddressAndTokenId(op.owner, op.tokenId);\\n                balancesToWithdraw[packedBalanceKey].balanceToWithdraw += op.amount;\\n            }\\n            delete priorityRequests[id];\\n        }\\n        firstPriorityRequestId += toProcess;\\n        totalOpenPriorityRequests -= toProcess;\\n    }\\n\\n    /// @notice Withdraw ETH to Layer 1 - register withdrawal and transfer ether to sender\\n    /// @param _amount Ether amount to withdraw\\n    function withdrawETH(uint128 _amount) external nonReentrant {\\n        registerWithdrawal(0, _amount, msg.sender);\\n        (bool success, ) = msg.sender.call{value: _amount}(\\\"\\\");\\n        require(success, \\\"aq\\\"); // ETH withdraw failed\\n    }\\n\\n    /// @notice Deposit ETH to Layer 2 - transfer ether from user into contract, validate it, register deposit\\n    /// @param _zkSyncAddress The receiver Layer 2 address\\n    function depositETH(address _zkSyncAddress) external payable nonReentrant {\\n        requireActive();\\n        registerDeposit(0, SafeCast.toUint128(msg.value), _zkSyncAddress);\\n    }\\n\\n    /// @notice Deposit ERC20 token to Layer 2 - transfer ERC20 tokens from user into contract, validate it, register deposit\\n    /// @param _token Token address\\n    /// @param _amount Token amount\\n    /// @param _zkSyncAddress Receiver Layer 2 address\\n    function depositERC20(\\n        IERC20 _token,\\n        uint104 _amount,\\n        address _zkSyncAddress\\n    ) external nonReentrant {\\n        requireActive();\\n\\n        // Get token id by its address\\n        uint16 tokenId = governance.validateTokenAddress(address(_token));\\n        require(!governance.pausedTokens(tokenId), \\\"ar\\\"); // token deposits are paused\\n\\n        uint256 balanceBefore = _token.balanceOf(address(this));\\n        require(Utils.transferFromERC20(_token, msg.sender, address(this), SafeCast.toUint128(_amount)), \\\"as\\\"); // token transfer failed deposit\\n        uint256 balanceAfter = _token.balanceOf(address(this));\\n        uint128 depositAmount = SafeCast.toUint128(balanceAfter.sub(balanceBefore));\\n\\n        registerDeposit(tokenId, depositAmount, _zkSyncAddress);\\n    }\\n\\n    /// @notice Withdraw ERC20 token to Layer 1 - register withdrawal and transfer ERC20 to sender\\n    /// @param _token Token address\\n    /// @param _amount amount to withdraw\\n    function withdrawERC20(address _token, uint128 _amount) external nonReentrant {\\n        uint16 tokenId = governance.validateTokenAddress(_token);\\n        bytes22 packedBalanceKey = packAddressAndTokenId(msg.sender, tokenId);\\n        uint128 balance = balancesToWithdraw[packedBalanceKey].balanceToWithdraw;\\n        uint128 withdrawnAmount = this.withdrawERC20Guarded(_token, msg.sender, _amount, balance);\\n        registerWithdrawal(tokenId, withdrawnAmount, msg.sender);\\n    }\\n\\n    /// @notice Register full exit request - pack pubdata, add priority request\\n    /// @param _accountId Numerical id of the account\\n    /// @param _token Token address, 0 address for ether\\n    function fullExit(uint32 _accountId, address _token) external nonReentrant {\\n        requireActive();\\n        require(_accountId <= MAX_ACCOUNT_ID, \\\"at\\\");\\n\\n        uint16 tokenId;\\n        if (_token == address(0)) {\\n            tokenId = 0;\\n        } else {\\n            tokenId = governance.validateTokenAddress(_token);\\n        }\\n\\n        // Priority Queue request\\n        Operations.FullExit memory op =\\n            Operations.FullExit({\\n                accountId: _accountId,\\n                owner: msg.sender,\\n                tokenId: tokenId,\\n                amount: 0 // unknown at this point\\n            });\\n        bytes memory pubData = Operations.writeFullExitPubdata(op);\\n        addPriorityRequest(Operations.OpType.FullExit, pubData);\\n\\n        // User must fill storage slot of balancesToWithdraw(msg.sender, tokenId) with nonzero value\\n        // In this case operator should just overwrite this slot during confirming withdrawal\\n        bytes22 packedBalanceKey = packAddressAndTokenId(msg.sender, tokenId);\\n        balancesToWithdraw[packedBalanceKey].gasReserveValue = FILLED_GAS_RESERVE_VALUE;\\n    }\\n\\n    /// @dev Process one block commit using previous block StoredBlockInfo,\\n    /// @dev returns new block StoredBlockInfo\\n    /// @dev NOTE: Does not change storage (except events, so we can't mark it view)\\n    function commitOneBlock(StoredBlockInfo memory _previousBlock, CommitBlockInfo memory _newBlock)\\n        internal\\n        returns (StoredBlockInfo memory storedNewBlock)\\n    {\\n        require(_newBlock.blockNumber == _previousBlock.blockNumber + 1, \\\"au\\\"); // only commit next block\\n\\n        // Check timestamp of the new block\\n        {\\n            require(_newBlock.timestamp >= _previousBlock.timestamp, \\\"av\\\"); // Block should be after previous block\\n            bool timestampNotTooSmall = block.timestamp - COMMIT_TIMESTAMP_NOT_OLDER <= _newBlock.timestamp;\\n            bool timestampNotTooBig = _newBlock.timestamp <= block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA;\\n            require(timestampNotTooSmall && timestampNotTooBig, \\\"aw\\\"); // New block timestamp is not valid\\n        }\\n\\n        // Check onchain operations\\n        (bytes32 pendingOnchainOpsHash, uint64 priorityReqCommitted, bytes memory onchainOpsOffsetCommitment) =\\n            collectOnchainOps(_newBlock);\\n\\n        // Create block commitment for verification proof\\n        bytes32 commitment = createBlockCommitment(_previousBlock, _newBlock, onchainOpsOffsetCommitment);\\n\\n        return\\n            StoredBlockInfo(\\n                _newBlock.blockNumber,\\n                priorityReqCommitted,\\n                pendingOnchainOpsHash,\\n                _newBlock.timestamp,\\n                _newBlock.newStateHash,\\n                commitment\\n            );\\n    }\\n\\n    /// @notice Commit block\\n    /// @notice 1. Checks onchain operations, timestamp.\\n    /// @notice 2. Store block commitments\\n    function commitBlocks(StoredBlockInfo memory _lastCommittedBlockData, CommitBlockInfo[] memory _newBlocksData)\\n        external\\n        nonReentrant\\n    {\\n        requireActive();\\n        governance.requireActiveValidator(msg.sender);\\n        // Check that we commit blocks after last committed block\\n        require(storedBlockHashes[totalBlocksCommitted] == hashStoredBlockInfo(_lastCommittedBlockData), \\\"ax\\\"); // incorrect previous block data\\n\\n        StoredBlockInfo memory lastCommittedBlock = _lastCommittedBlockData;\\n\\n        uint64 committedPriorityRequests = 0;\\n        for (uint32 i = 0; i < _newBlocksData.length; ++i) {\\n            lastCommittedBlock = commitOneBlock(lastCommittedBlock, _newBlocksData[i]);\\n\\n            committedPriorityRequests += lastCommittedBlock.priorityOperations;\\n            storedBlockHashes[lastCommittedBlock.blockNumber] = hashStoredBlockInfo(lastCommittedBlock);\\n\\n            emit BlockCommit(lastCommittedBlock.blockNumber);\\n        }\\n\\n        totalBlocksCommitted += uint32(_newBlocksData.length);\\n\\n        totalCommittedPriorityRequests += committedPriorityRequests;\\n        require(totalCommittedPriorityRequests <= totalOpenPriorityRequests, \\\"ay\\\");\\n    }\\n\\n    /// @dev 1. Try to send token to _recipients\\n    /// @dev 2. On failure: Increment _recipients balance to withdraw.\\n    function withdrawOrStore(\\n        uint16 _tokenId,\\n        address _recipient,\\n        uint128 _amount\\n    ) internal {\\n        emit RollupWithdrawal(_recipient, _tokenId, _amount);\\n        bytes22 packedBalanceKey = packAddressAndTokenId(_recipient, _tokenId);\\n\\n        bool sent = false;\\n        if (_tokenId == 0) {\\n            address payable toPayable = address(uint160(_recipient));\\n            sent = Utils.sendETHNoRevert(toPayable, _amount);\\n        } else {\\n            address tokenAddr = governance.tokenAddresses(_tokenId);\\n            try this.withdrawERC20Guarded{gas: ERC20_WITHDRAWAL_GAS_LIMIT}(tokenAddr, _recipient, _amount, _amount) {\\n                sent = true;\\n            } catch {\\n                sent = false;\\n            }\\n        }\\n        if (sent) {\\n            emit OnchainWithdrawal(_recipient, _tokenId, _amount);\\n        } else {\\n            increaseBalanceToWithdraw(packedBalanceKey, _amount);\\n        }\\n    }\\n\\n    /// @dev Executes one block\\n    /// @dev 1. Processes all pending operations (Send Exits, Complete priority requests)\\n    /// @dev 2. Finalizes block on Ethereum\\n    /// @dev _executedBlockIdx is index in the array of the blocks that we want to execute together\\n    function executeOneBlock(ExecuteBlockInfo memory _blockExecuteData, uint32 _executedBlockIdx) internal {\\n        // Ensure block was committed\\n        require(\\n            hashStoredBlockInfo(_blockExecuteData.storedBlock) ==\\n                storedBlockHashes[_blockExecuteData.storedBlock.blockNumber],\\n            \\\"exe10\\\" // executing block should be committed\\n        );\\n        require(_blockExecuteData.storedBlock.blockNumber == totalBlocksExecuted + _executedBlockIdx + 1, \\\"az\\\"); // Execute blocks in order\\n        require(_blockExecuteData.storedBlock.blockNumber <= totalBlocksProven, \\\"ba\\\"); // Can't execute blocks more then committed and proven currently.\\n\\n        bytes32 pendingOnchainOpsHash = EMPTY_STRING_KECCAK;\\n        for (uint32 i = 0; i < _blockExecuteData.pendingOnchainOpsPubdata.length; ++i) {\\n            bytes memory pubData = _blockExecuteData.pendingOnchainOpsPubdata[i];\\n\\n            Operations.OpType opType = Operations.OpType(uint8(pubData[0]));\\n\\n            if (opType == Operations.OpType.PartialExit) {\\n                Operations.PartialExit memory op = Operations.readPartialExitPubdata(pubData);\\n                withdrawOrStore(op.tokenId, op.owner, op.amount);\\n            } else if (opType == Operations.OpType.ForcedExit) {\\n                Operations.ForcedExit memory op = Operations.readForcedExitPubdata(pubData);\\n                withdrawOrStore(op.tokenId, op.target, op.amount);\\n            } else if (opType == Operations.OpType.FullExit) {\\n                Operations.FullExit memory op = Operations.readFullExitPubdata(pubData);\\n                withdrawOrStore(op.tokenId, op.owner, op.amount);\\n            } else {\\n                revert(\\\"exe13\\\"); // unsupported op in block execution\\n            }\\n\\n            pendingOnchainOpsHash = Utils.concatHash(pendingOnchainOpsHash, pubData);\\n        }\\n        require(pendingOnchainOpsHash == _blockExecuteData.storedBlock.pendingOnchainOperationsHash, \\\"bb\\\"); // incorrect onchain ops executed\\n    }\\n\\n    /// @notice Execute blocks, completing priority operations and processing withdrawals.\\n    /// @notice 1. Processes all pending operations (Send Exits, Complete priority requests)\\n    /// @notice 2. Finalizes block on Ethereum\\n    function executeBlocks(ExecuteBlockInfo[] memory _blocksData) external nonReentrant {\\n        requireActive();\\n        governance.requireActiveValidator(msg.sender);\\n\\n        uint64 priorityRequestsExecuted = 0;\\n        uint32 nBlocks = uint32(_blocksData.length);\\n        for (uint32 i = 0; i < nBlocks; ++i) {\\n            executeOneBlock(_blocksData[i], i);\\n            priorityRequestsExecuted += _blocksData[i].storedBlock.priorityOperations;\\n            emit BlockVerification(_blocksData[i].storedBlock.blockNumber);\\n        }\\n\\n        firstPriorityRequestId += priorityRequestsExecuted;\\n        totalCommittedPriorityRequests -= priorityRequestsExecuted;\\n        totalOpenPriorityRequests -= priorityRequestsExecuted;\\n\\n        totalBlocksExecuted += nBlocks;\\n    }\\n\\n    /// @notice Blocks commitment verification.\\n    /// @notice Only verifies block commitments without any other processing\\n    function proveBlocks(StoredBlockInfo[] memory _committedBlocks, ProofInput memory _proof) external nonReentrant {\\n        uint32 currentTotalBlocksProven = totalBlocksProven;\\n        for (uint256 i = 0; i < _committedBlocks.length; ++i) {\\n            require(\\n                hashStoredBlockInfo(_committedBlocks[i]) == storedBlockHashes[currentTotalBlocksProven + 1],\\n                \\\"pbl2\\\"\\n            );\\n            ++currentTotalBlocksProven;\\n\\n            require(_proof.commitments[i] & INPUT_MASK == uint256(_committedBlocks[i].commitment) & INPUT_MASK, \\\"bc\\\"); // incorrect block commitment in proof\\n        }\\n\\n        bool success =\\n            verifier.verifyAggregatedProof(\\n                _proof.recursiveInput,\\n                _proof.proof,\\n                _proof.vkIndexes,\\n                _proof.commitments,\\n                _proof.subproofsLimbs,\\n                true\\n            );\\n        require(success, \\\"bd\\\"); // Aggregated proof verification fail\\n\\n        require(currentTotalBlocksProven <= totalBlocksCommitted, \\\"be\\\");\\n        totalBlocksProven = currentTotalBlocksProven;\\n    }\\n\\n    /// @notice Reverts unverified blocks\\n    function revertBlocks(StoredBlockInfo[] memory _blocksToRevert) external nonReentrant {\\n        governance.requireActiveValidator(msg.sender);\\n\\n        uint32 blocksCommitted = totalBlocksCommitted;\\n        uint32 blocksToRevert = Utils.minU32(uint32(_blocksToRevert.length), blocksCommitted - totalBlocksExecuted);\\n        uint64 revertedPriorityRequests = 0;\\n\\n        for (uint32 i = 0; i < blocksToRevert; ++i) {\\n            StoredBlockInfo memory storedBlockInfo = _blocksToRevert[i];\\n            require(storedBlockHashes[blocksCommitted] == hashStoredBlockInfo(storedBlockInfo), \\\"bf\\\"); // incorrect stored block info\\n\\n            delete storedBlockHashes[blocksCommitted];\\n\\n            --blocksCommitted;\\n            revertedPriorityRequests += storedBlockInfo.priorityOperations;\\n        }\\n\\n        totalBlocksCommitted = blocksCommitted;\\n        totalCommittedPriorityRequests -= revertedPriorityRequests;\\n        if (totalBlocksCommitted < totalBlocksProven) {\\n            totalBlocksProven = totalBlocksCommitted;\\n        }\\n\\n        emit BlocksRevert(totalBlocksExecuted, blocksCommitted);\\n    }\\n\\n    /// @notice Checks if Exodus mode must be entered. If true - enters exodus mode and emits ExodusMode event.\\n    /// @dev Exodus mode must be entered in case of current ethereum block number is higher than the oldest\\n    /// @dev of existed priority requests expiration block number.\\n    /// @return bool flag that is true if the Exodus mode must be entered.\\n    function triggerExodusIfNeeded() external returns (bool) {\\n        bool trigger =\\n            block.number >= priorityRequests[firstPriorityRequestId].expirationBlock &&\\n                priorityRequests[firstPriorityRequestId].expirationBlock != 0;\\n        if (trigger) {\\n            if (!exodusMode) {\\n                exodusMode = true;\\n                emit ExodusMode();\\n            }\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /// @notice Withdraws token from Franklin to root chain in case of exodus mode. User must provide proof that he owns funds\\n    /// @param _storedBlockInfo Last verified block\\n    /// @param _accountId Id of the account in the tree\\n    /// @param _proof Proof\\n    /// @param _tokenId Verified token id\\n    /// @param _amount Amount for owner (must be total amount, not part of it)\\n    function exit(\\n        StoredBlockInfo memory _storedBlockInfo,\\n        uint32 _accountId,\\n        uint16 _tokenId,\\n        uint128 _amount,\\n        ProofInput memory _proof\\n    ) external nonReentrant {\\n        bytes22 packedBalanceKey = packAddressAndTokenId(msg.sender, _tokenId);\\n        require(exodusMode, \\\"bg\\\"); // must be in exodus mode\\n        require(!exited[_accountId][_tokenId], \\\"bh\\\"); // already exited\\n        require(storedBlockHashes[totalBlocksExecuted] == hashStoredBlockInfo(_storedBlockInfo), \\\"bi\\\"); // incorrect sotred block info\\n\\n        uint256 commitment =\\n            uint256(sha256(abi.encodePacked(_storedBlockInfo.stateHash, _accountId, msg.sender, _tokenId, _amount)));\\n        require(_proof.commitments.length == 1, \\\"bj\\\");\\n        commitment = commitment & INPUT_MASK;\\n        require(_proof.commitments[0] == commitment, \\\"bk\\\");\\n\\n        bool proofCorrect =\\n            verifier.verifyAggregatedProof(\\n                _proof.recursiveInput,\\n                _proof.proof,\\n                _proof.vkIndexes,\\n                _proof.commitments,\\n                _proof.subproofsLimbs,\\n                false\\n            );\\n        require(proofCorrect, \\\"bl\\\");\\n\\n        increaseBalanceToWithdraw(packedBalanceKey, _amount);\\n        exited[_accountId][_tokenId] = true;\\n    }\\n\\n    function setAuthPubkeyHash(bytes calldata _pubkey_hash, uint32 _nonce) external nonReentrant {\\n        require(_pubkey_hash.length == PUBKEY_HASH_BYTES, \\\"bm\\\"); // PubKeyHash should be 20 bytes.\\n        require(authFacts[msg.sender][_nonce] == bytes32(0), \\\"bn\\\"); // auth fact for nonce should be empty\\n\\n        authFacts[msg.sender][_nonce] = keccak256(_pubkey_hash);\\n\\n        emit FactAuth(msg.sender, _nonce, _pubkey_hash);\\n    }\\n\\n    /// @notice Register deposit request - pack pubdata, add priority request and emit OnchainDeposit event\\n    /// @param _tokenId Token by id\\n    /// @param _amount Token amount\\n    /// @param _owner Receiver\\n    function registerDeposit(\\n        uint16 _tokenId,\\n        uint128 _amount,\\n        address _owner\\n    ) internal {\\n        // Priority Queue request\\n        Operations.Deposit memory op =\\n            Operations.Deposit({\\n                accountId: 0, // unknown at this point\\n                owner: _owner,\\n                tokenId: _tokenId,\\n                amount: _amount\\n            });\\n        bytes memory pubData = Operations.writeDepositPubdata(op);\\n        addPriorityRequest(Operations.OpType.Deposit, pubData);\\n\\n        emit OnchainDeposit(msg.sender, _tokenId, _amount, _owner);\\n    }\\n\\n    /// @notice Register withdrawal - update user balance and emit OnchainWithdrawal event\\n    /// @param _token - token by id\\n    /// @param _amount - token amount\\n    /// @param _to - address to withdraw to\\n    function registerWithdrawal(\\n        uint16 _token,\\n        uint128 _amount,\\n        address payable _to\\n    ) internal {\\n        bytes22 packedBalanceKey = packAddressAndTokenId(_to, _token);\\n        uint128 balance = balancesToWithdraw[packedBalanceKey].balanceToWithdraw;\\n        balancesToWithdraw[packedBalanceKey].balanceToWithdraw = balance.sub(_amount);\\n        emit OnchainWithdrawal(_to, _token, _amount);\\n    }\\n\\n    function emitDepositCommitEvent(uint32 _blockNumber, Operations.Deposit memory depositData) internal {\\n        emit DepositCommit(\\n            _blockNumber,\\n            depositData.accountId,\\n            depositData.owner,\\n            depositData.tokenId,\\n            depositData.amount\\n        );\\n    }\\n\\n    function emitFullExitCommitEvent(uint32 _blockNumber, Operations.FullExit memory fullExitData) internal {\\n        emit FullExitCommit(\\n            _blockNumber,\\n            fullExitData.accountId,\\n            fullExitData.owner,\\n            fullExitData.tokenId,\\n            fullExitData.amount\\n        );\\n    }\\n\\n    /// @dev Gets operations packed in bytes array. Unpacks it and stores onchain operations.\\n    /// @dev Priority operations must be committed in the same order as they are in the priority queue.\\n    /// @dev NOTE: does not change storage! (only emits events)\\n    /// @dev processableOperationsHash - hash of the all operations that needs to be executed  (Deposit, Exits, ChangPubKey)\\n    /// @dev priorityOperationsProcessed - number of priority operations processed in this block (Deposits, FullExits)\\n    /// @dev offsetsCommitment - array where 1 is stored in chunk where onchainOperation begins and other are 0 (used in commitments)\\n    function collectOnchainOps(CommitBlockInfo memory _newBlockData)\\n        internal\\n        returns (\\n            bytes32 processableOperationsHash,\\n            uint64 priorityOperationsProcessed,\\n            bytes memory offsetsCommitment\\n        )\\n    {\\n        bytes memory pubData = _newBlockData.publicData;\\n\\n        uint64 uncommittedPriorityRequestsOffset = firstPriorityRequestId + totalCommittedPriorityRequests;\\n        priorityOperationsProcessed = 0;\\n        processableOperationsHash = EMPTY_STRING_KECCAK;\\n\\n        require(pubData.length % CHUNK_BYTES == 0, \\\"bo\\\"); // pubdata length must be a multiple of CHUNK_BYTES\\n        offsetsCommitment = new bytes(pubData.length / CHUNK_BYTES);\\n        for (uint32 i = 0; i < _newBlockData.onchainOperations.length; ++i) {\\n            OnchainOperationData memory onchainOpData = _newBlockData.onchainOperations[i];\\n\\n            uint256 pubdataOffset = onchainOpData.publicDataOffset;\\n            require(pubdataOffset % CHUNK_BYTES == 0, \\\"bp\\\"); // offsets should be on chunks boundaries\\n            require(offsetsCommitment[pubdataOffset / CHUNK_BYTES] == 0x00, \\\"bq\\\"); // offset commitment should be empty\\n            offsetsCommitment[pubdataOffset / CHUNK_BYTES] = bytes1(0x01);\\n\\n            Operations.OpType opType = Operations.OpType(uint8(pubData[pubdataOffset]));\\n\\n            if (opType == Operations.OpType.Deposit) {\\n                bytes memory opPubData = Bytes.slice(pubData, pubdataOffset, DEPOSIT_BYTES);\\n\\n                Operations.Deposit memory depositData = Operations.readDepositPubdata(opPubData);\\n                emitDepositCommitEvent(_newBlockData.blockNumber, depositData);\\n\\n                checkPriorityOperation(depositData, uncommittedPriorityRequestsOffset + priorityOperationsProcessed);\\n                priorityOperationsProcessed++;\\n            } else if (opType == Operations.OpType.PartialExit) {\\n                bytes memory opPubData = Bytes.slice(pubData, pubdataOffset, PARTIAL_EXIT_BYTES);\\n\\n                processableOperationsHash = Utils.concatHash(processableOperationsHash, opPubData);\\n            } else if (opType == Operations.OpType.ForcedExit) {\\n                bytes memory opPubData = Bytes.slice(pubData, pubdataOffset, FORCED_EXIT_BYTES);\\n\\n                processableOperationsHash = Utils.concatHash(processableOperationsHash, opPubData);\\n            } else if (opType == Operations.OpType.FullExit) {\\n                bytes memory opPubData = Bytes.slice(pubData, pubdataOffset, FULL_EXIT_BYTES);\\n\\n                Operations.FullExit memory fullExitData = Operations.readFullExitPubdata(opPubData);\\n                emitFullExitCommitEvent(_newBlockData.blockNumber, fullExitData);\\n\\n                checkPriorityOperation(fullExitData, uncommittedPriorityRequestsOffset + priorityOperationsProcessed);\\n                priorityOperationsProcessed++;\\n\\n                processableOperationsHash = Utils.concatHash(processableOperationsHash, opPubData);\\n            } else if (opType == Operations.OpType.ChangePubKey) {\\n                bytes memory opPubData = Bytes.slice(pubData, pubdataOffset, CHANGE_PUBKEY_BYTES);\\n\\n                Operations.ChangePubKey memory op = Operations.readChangePubKeyPubdata(opPubData);\\n\\n                if (onchainOpData.ethWitness.length != 0) {\\n                    bool valid = verifyChangePubkey(onchainOpData.ethWitness, op);\\n                    require(valid, \\\"br\\\"); // failed to verify change pubkey hash signature\\n                } else {\\n                    bool valid = authFacts[op.owner][op.nonce] == keccak256(abi.encodePacked(op.pubKeyHash));\\n                    require(valid, \\\"bs\\\"); // new pub key hash is not authenticated properly\\n                }\\n            } else {\\n                revert(\\\"fpp14\\\"); // unsupported op\\n            }\\n        }\\n    }\\n\\n    /// @notice Checks that change operation is correct\\n    function verifyChangePubkey(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        Operations.ChangePubkeyType changePkType = Operations.ChangePubkeyType(uint8(_ethWitness[0]));\\n        if (changePkType == Operations.ChangePubkeyType.ECRECOVER) {\\n            return verifyChangePubkeyECRECOVER(_ethWitness, _changePk);\\n        } else if (changePkType == Operations.ChangePubkeyType.CREATE2) {\\n            return verifyChangePubkeyCREATE2(_ethWitness, _changePk);\\n        } else {\\n            revert(\\\"chp13\\\"); // Incorrect ChangePubKey type\\n        }\\n    }\\n\\n    /// @notice Checks that signature is valid for pubkey change message\\n    /// @param _ethWitness Signature (65 bytes) + 32 bytes of the arbitrary signed data\\n    /// @param _changePk Parsed change pubkey operation\\n    function verifyChangePubkeyECRECOVER(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        (uint256 offset, bytes memory signature) = Bytes.read(_ethWitness, 1, 65); // offset is 1 because we skip type of ChangePubkey\\n        (, bytes32 additionalData) = Bytes.readBytes32(_ethWitness, offset);\\n        bytes32 messageHash =\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n60\\\",\\n                    _changePk.pubKeyHash,\\n                    _changePk.nonce,\\n                    _changePk.accountId,\\n                    additionalData\\n                )\\n            );\\n        address recoveredAddress = Utils.recoverAddressFromEthSignature(signature, messageHash);\\n        return recoveredAddress == _changePk.owner && recoveredAddress != address(0);\\n    }\\n\\n    /// @notice Checks that signature is valid for pubkey change message\\n    /// @param _ethWitness Create2 deployer address, saltArg, codeHash\\n    /// @param _changePk Parsed change pubkey operation\\n    function verifyChangePubkeyCREATE2(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        address creatorAddress;\\n        bytes32 saltArg; // salt arg is additional bytes that are encoded in the CREATE2 salt\\n        bytes32 codeHash;\\n        uint256 offset = 1; // offset is 1 because we skip type of ChangePubkey\\n        (offset, creatorAddress) = Bytes.readAddress(_ethWitness, offset);\\n        (offset, saltArg) = Bytes.readBytes32(_ethWitness, offset);\\n        (offset, codeHash) = Bytes.readBytes32(_ethWitness, offset);\\n        // salt from CREATE2 specification\\n        bytes32 salt = keccak256(abi.encodePacked(saltArg, _changePk.pubKeyHash));\\n        // Address computation according to CREATE2 definition: https://eips.ethereum.org/EIPS/eip-1014\\n        address recoveredAddress =\\n            address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), creatorAddress, salt, codeHash)))));\\n        // This type of change pubkey can be done only once\\n        return recoveredAddress == _changePk.owner && _changePk.nonce == 0;\\n    }\\n\\n    /// @dev Creates block commitment from its data\\n    /// @dev _offsetCommitment - hash of the array where 1 is stored in chunk where onchainOperation begins and 0 for other chunks\\n    function createBlockCommitment(\\n        StoredBlockInfo memory _previousBlock,\\n        CommitBlockInfo memory _newBlockData,\\n        bytes memory _offsetCommitment\\n    ) internal view returns (bytes32 commitment) {\\n        bytes32 hash = sha256(abi.encodePacked(uint256(_newBlockData.blockNumber), uint256(_newBlockData.feeAccount)));\\n        hash = sha256(abi.encodePacked(hash, _previousBlock.stateHash));\\n        hash = sha256(abi.encodePacked(hash, _newBlockData.newStateHash));\\n        hash = sha256(abi.encodePacked(hash, uint256(_newBlockData.timestamp)));\\n\\n        bytes memory pubdata = abi.encodePacked(_newBlockData.publicData, _offsetCommitment);\\n\\n        /// The code below is equivalent to `commitment = sha256(abi.encodePacked(hash, _publicData))`\\n\\n        /// We use inline assembly instead of this concise and readable code in order to avoid copying of `_publicData` (which saves ~90 gas per transfer operation).\\n\\n        /// Specifically, we perform the following trick:\\n        /// First, replace the first 32 bytes of `_publicData` (where normally its length is stored) with the value of `hash`.\\n        /// Then, we call `sha256` precompile passing the `_publicData` pointer and the length of the concatenated byte buffer.\\n        /// Finally, we put the `_publicData.length` back to its original location (to the first word of `_publicData`).\\n        assembly {\\n            let hashResult := mload(0x40)\\n            let pubDataLen := mload(pubdata)\\n            mstore(pubdata, hash)\\n            // staticcall to the sha256 precompile at address 0x2\\n            let success := staticcall(gas(), 0x2, pubdata, add(pubDataLen, 0x20), hashResult, 0x20)\\n            mstore(pubdata, pubDataLen)\\n\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n                case 0 {\\n                    invalid()\\n                }\\n\\n            commitment := mload(hashResult)\\n        }\\n    }\\n\\n    /// @notice Checks that deposit is same as operation in priority queue\\n    /// @param _deposit Deposit data\\n    /// @param _priorityRequestId Operation's id in priority queue\\n    function checkPriorityOperation(Operations.Deposit memory _deposit, uint64 _priorityRequestId) internal view {\\n        Operations.OpType priorReqType = priorityRequests[_priorityRequestId].opType;\\n        require(priorReqType == Operations.OpType.Deposit, \\\"bt\\\"); // incorrect priority op type\\n\\n        bytes20 hashedPubdata = priorityRequests[_priorityRequestId].hashedPubData;\\n        require(Operations.checkDepositInPriorityQueue(_deposit, hashedPubdata), \\\"bu\\\");\\n    }\\n\\n    /// @notice Checks that FullExit is same as operation in priority queue\\n    /// @param _fullExit FullExit data\\n    /// @param _priorityRequestId Operation's id in priority queue\\n    function checkPriorityOperation(Operations.FullExit memory _fullExit, uint64 _priorityRequestId) internal view {\\n        Operations.OpType priorReqType = priorityRequests[_priorityRequestId].opType;\\n        require(priorReqType == Operations.OpType.FullExit, \\\"bv\\\"); // incorrect priority op type\\n\\n        bytes20 hashedPubdata = priorityRequests[_priorityRequestId].hashedPubData;\\n        require(Operations.checkFullExitInPriorityQueue(_fullExit, hashedPubdata), \\\"bw\\\");\\n    }\\n\\n    /// @notice Checks that current state not is exodus mode\\n    function requireActive() internal view {\\n        require(!exodusMode, \\\"bx\\\"); // exodus mode activated\\n    }\\n\\n    // Priority queue\\n\\n    /// @notice Saves priority request in storage\\n    /// @dev Calculates expiration block for request, store this request and emit NewPriorityRequest event\\n    /// @param _opType Rollup operation type\\n    /// @param _pubData Operation pubdata\\n    function addPriorityRequest(Operations.OpType _opType, bytes memory _pubData) internal {\\n        // Expiration block is: current block number + priority expiration delta\\n        uint64 expirationBlock = uint64(block.number + PRIORITY_EXPIRATION);\\n\\n        uint64 nextPriorityRequestId = firstPriorityRequestId + totalOpenPriorityRequests;\\n\\n        bytes20 hashedPubData = Utils.hashBytesToBytes20(_pubData);\\n\\n        priorityRequests[nextPriorityRequestId] = PriorityOperation({\\n            hashedPubData: hashedPubData,\\n            expirationBlock: expirationBlock,\\n            opType: _opType\\n        });\\n\\n        emit NewPriorityRequest(msg.sender, nextPriorityRequestId, _opType, _pubData, uint256(expirationBlock));\\n\\n        totalOpenPriorityRequests++;\\n    }\\n\\n    /// @notice Deletes processed priority requests\\n    /// @param _number The number of requests\\n    function deleteRequests(uint64 _number) internal {\\n        require(_number <= totalOpenPriorityRequests, \\\"by\\\"); // number is higher than total priority requests number\\n\\n        uint64 numberOfRequestsToClear = Utils.minU64(_number, MAX_PRIORITY_REQUESTS_TO_DELETE_IN_VERIFY);\\n        uint64 startIndex = firstPriorityRequestId;\\n        for (uint64 i = startIndex; i < startIndex + numberOfRequestsToClear; i++) {\\n            delete priorityRequests[i];\\n        }\\n\\n        totalOpenPriorityRequests -= _number;\\n        firstPriorityRequestId += _number;\\n        totalCommittedPriorityRequests -= _number;\\n    }\\n\\n    function increaseBalanceToWithdraw(bytes22 _packedBalanceKey, uint128 _amount) internal {\\n        uint128 balance = balancesToWithdraw[_packedBalanceKey].balanceToWithdraw;\\n        balancesToWithdraw[_packedBalanceKey] = BalanceToWithdraw(balance.add(_amount), FILLED_GAS_RESERVE_VALUE);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    /// @dev Address of lock flag variable.\\n    /// @dev Flag is placed at random memory location to not interfere with Storage contract.\\n    uint256 private constant LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4; // keccak256(\\\"ReentrancyGuard\\\") - 1;\\n\\n    function initializeReentrancyGuard() internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        assembly {\\n            sstore(LOCK_FLAG_ADDRESS, 1)\\n        }\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        bool notEntered;\\n        assembly {\\n            notEntered := sload(LOCK_FLAG_ADDRESS)\\n        }\\n\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(notEntered, \\\"o\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        assembly {\\n            sstore(LOCK_FLAG_ADDRESS, 0)\\n        }\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        assembly {\\n            sstore(LOCK_FLAG_ADDRESS, 1)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"u\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, \\\"v\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"w\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"x\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, \\\"y\\\");\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/SafeMathUInt128.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUInt128 {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\\n        uint128 c = a + b;\\n        require(c >= a, \\\"z\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint128 a,\\n        uint128 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint128) {\\n        require(b <= a, \\\"aa\\\");\\n        uint128 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint128 c = a * b;\\n        require(c / a == b, \\\"ab\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint128 a,\\n        uint128 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint128) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"ac\\\");\\n        uint128 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint128 a,\\n        uint128 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint128) {\\n        require(b != 0, \\\"ad\\\");\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/SafeCast.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and then downcasting.\\n *\\n * _Available since v2.5.0._\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"p\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"q\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"r\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"s\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"t\\\");\\n        return uint8(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Utils.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Bytes.sol\\\";\\n\\nlibrary Utils {\\n    /// @notice Returns lesser of two values\\n    function minU32(uint32 a, uint32 b) internal pure returns (uint32) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Returns lesser of two values\\n    function minU64(uint64 a, uint64 b) internal pure returns (uint64) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Sends tokens\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transfer` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function sendERC20(\\n        IERC20 _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) =\\n            address(_token).call(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", _to, _amount));\\n        // `transfer` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Transfers token from one address to another\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transferFrom` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _from Address of sender\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function transferFromERC20(\\n        IERC20 _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) =\\n            address(_token).call(abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", _from, _to, _amount));\\n        // `transferFrom` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Sends ETH\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function sendETHNoRevert(address payable _to, uint256 _amount) internal returns (bool) {\\n        // TODO: Use constant from Config\\n        uint256 ETH_WITHDRAWAL_GAS_LIMIT = 10000;\\n\\n        (bool callSuccess, ) = _to.call{gas: ETH_WITHDRAWAL_GAS_LIMIT, value: _amount}(\\\"\\\");\\n        return callSuccess;\\n    }\\n\\n    /// @notice Recovers signer's address from ethereum signature for given message\\n    /// @param _signature 65 bytes concatenated. R (32) + S (32) + V (1)\\n    /// @param _messageHash signed message hash.\\n    /// @return address of the signer\\n    function recoverAddressFromEthSignature(bytes memory _signature, bytes32 _messageHash)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(_signature.length == 65, \\\"ae\\\"); // incorrect signature length\\n\\n        bytes32 signR;\\n        bytes32 signS;\\n        uint256 offset = 0;\\n\\n        (offset, signR) = Bytes.readBytes32(_signature, offset);\\n        (offset, signS) = Bytes.readBytes32(_signature, offset);\\n        uint8 signV = uint8(_signature[offset]);\\n\\n        return ecrecover(_messageHash, signV, signR, signS);\\n    }\\n\\n    /// @notice Returns new_hash = hash(old_hash + bytes)\\n    function concatHash(bytes32 _hash, bytes memory _bytes) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_hash, _bytes));\\n    }\\n\\n    function hashBytesToBytes20(bytes memory _bytes) internal pure returns (bytes20) {\\n        return bytes20(uint160(uint256(keccak256(_bytes))));\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Storage.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./IERC20.sol\\\";\\n\\nimport \\\"./Governance.sol\\\";\\nimport \\\"./Verifier.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\n/// @title zkSync storage contract\\n/// @author Matter Labs\\ncontract Storage {\\n    /// @notice Flag indicates that upgrade preparation status is active\\n    /// @dev Will store false in case of not active upgrade mode\\n    bool public upgradePreparationActive;\\n\\n    /// @notice Upgrade preparation activation timestamp (as seconds since unix epoch)\\n    /// @dev Will be equal to zero in case of not active upgrade mode\\n    uint256 public upgradePreparationActivationTime;\\n\\n    /// @dev Verifier contract. Used to verify block proof and exit proof\\n    Verifier public verifier;\\n\\n    /// @dev Governance contract. Contains the governor (the owner) of whole system, validators list, possible tokens list\\n    Governance public governance;\\n\\n    uint8 constant FILLED_GAS_RESERVE_VALUE = 0xff; // we use it to set gas revert value so slot will not be emptied with 0 balance\\n    struct BalanceToWithdraw {\\n        uint128 balanceToWithdraw;\\n        uint8 gasReserveValue; // gives user opportunity to fill storage slot with nonzero value\\n    }\\n\\n    /// @notice Root-chain balances (per owner and token id, see packAddressAndTokenId) to withdraw\\n    mapping(bytes22 => BalanceToWithdraw) public balancesToWithdraw;\\n\\n    // @dev Pending withdrawals are not used in this version\\n    struct PendingWithdrawal_DEPRECATED {\\n        address to;\\n        uint16 tokenId;\\n    }\\n    mapping(uint32 => PendingWithdrawal_DEPRECATED) public pendingWithdrawals_DEPRECATED;\\n    uint32 public firstPendingWithdrawalIndex_DEPRECATED;\\n    uint32 public numberOfPendingWithdrawals_DEPRECATED;\\n\\n    /// @notice Total number of verified blocks i.e. blocks[totalBlocksVerified] points at the latest verified block (block 0 is genesis)\\n    uint32 public totalBlocksExecuted;\\n\\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\\n    uint32 public totalBlocksCommitted;\\n\\n    /// @Old rollup block stored data - not used in current version\\n    /// @member validator Block producer\\n    /// @member committedAtBlock ETH block number at which this block was committed\\n    /// @member cumulativeOnchainOperations Total number of operations in this and all previous blocks\\n    /// @member priorityOperations Total number of priority operations for this block\\n    /// @member commitment Hash of the block circuit commitment\\n    /// @member stateRoot New tree root hash\\n    ///\\n    /// Consider memory alignment when changing field order: https://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html\\n    struct Block_DEPRECATED {\\n        uint32 committedAtBlock;\\n        uint64 priorityOperations;\\n        uint32 chunks;\\n        bytes32 withdrawalsDataHash; // can be restricted to 16 bytes to reduce number of required storage slots\\n        bytes32 commitment;\\n        bytes32 stateRoot;\\n    }\\n    mapping(uint32 => Block_DEPRECATED) public blocks_DEPRECATED;\\n\\n    /// @notice Flag indicates that a user has exited certain token balance (per account id and tokenId)\\n    mapping(uint32 => mapping(uint16 => bool)) public exited;\\n\\n    /// @notice Flag indicates that exodus (mass exit) mode is triggered\\n    /// @notice Once it was raised, it can not be cleared again, and all users must exit\\n    bool public exodusMode;\\n\\n    /// @notice User authenticated fact hashes for some nonce.\\n    mapping(address => mapping(uint32 => bytes32)) public authFacts;\\n\\n    /// @notice Old Priority Operation container\\n    /// @member opType Priority operation type\\n    /// @member pubData Priority operation public data\\n    /// @member expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\\n    struct PriorityOperation_DEPRECATED {\\n        Operations.OpType opType;\\n        bytes pubData;\\n        uint256 expirationBlock;\\n    }\\n\\n    /// @notice Priority Requests mapping (request id - operation)\\n    /// @dev Contains op type, pubdata and expiration block of unsatisfied requests.\\n    /// @dev Numbers are in order of requests receiving\\n    mapping(uint64 => PriorityOperation_DEPRECATED) public priorityRequests_DEPRECATED;\\n\\n    /// @notice First open priority request id\\n    uint64 public firstPriorityRequestId;\\n\\n    /// @notice Total number of requests\\n    uint64 public totalOpenPriorityRequests;\\n\\n    /// @notice Total number of committed requests.\\n    /// @dev Used in checks: if the request matches the operation on Rollup contract and if provided number of requests is not too big\\n    uint64 public totalCommittedPriorityRequests;\\n\\n    /// @notice Packs address and token id into single word to use as a key in balances mapping\\n    function packAddressAndTokenId(address _address, uint16 _tokenId) internal pure returns (bytes22) {\\n        return bytes22((uint176(_address) | (uint176(_tokenId) << 160)));\\n    }\\n\\n    /// @notice Gets value from balancesToWithdraw\\n    function getBalanceToWithdraw(address _address, uint16 _tokenId) public view returns (uint128) {\\n        return balancesToWithdraw[packAddressAndTokenId(_address, _tokenId)].balanceToWithdraw;\\n    }\\n\\n    /// @Rollup block stored data\\n    /// @member blockNumber Rollup block number\\n    /// @member priorityOperations Number of priority operations processed\\n    /// @member pendingOnchainOperationsHash Hash of all operations that must be processed after verify\\n    /// @member timestamp Rollup block timestamp, have the same format as Ethereum block constant\\n    /// @member stateHash Root hash of the rollup state\\n    /// @member commitment Verified input for the zkSync circuit\\n    struct StoredBlockInfo {\\n        uint32 blockNumber;\\n        uint64 priorityOperations;\\n        bytes32 pendingOnchainOperationsHash;\\n        uint256 timestamp;\\n        bytes32 stateHash;\\n        bytes32 commitment;\\n    }\\n\\n    /// @notice Returns the keccak hash of the ABI-encoded StoredBlockInfo\\n    function hashStoredBlockInfo(StoredBlockInfo memory _storedBlockInfo) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(_storedBlockInfo));\\n    }\\n\\n    /// @notice Stored hashed StoredBlockInfo for some block number\\n    mapping(uint32 => bytes32) public storedBlockHashes;\\n\\n    /// @notice Total blocks proven.\\n    uint32 public totalBlocksProven;\\n\\n    /// @notice Priority Operation container\\n    /// @member hashedPubData Hashed priority operation public data\\n    /// @member expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\\n    /// @member opType Priority operation type\\n    struct PriorityOperation {\\n        bytes20 hashedPubData;\\n        uint64 expirationBlock;\\n        Operations.OpType opType;\\n    }\\n\\n    /// @notice Priority Requests mapping (request id - operation)\\n    /// @dev Contains op type, pubdata and expiration block of unsatisfied requests.\\n    /// @dev Numbers are in order of requests receiving\\n    mapping(uint64 => PriorityOperation) public priorityRequests;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Config.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title zkSync configuration constants\\n/// @author Matter Labs\\ncontract Config {\\n    /// @dev ERC20 token withdrawal gas limit, used only for complete withdrawals\\n    uint256 constant ERC20_WITHDRAWAL_GAS_LIMIT = 50000;\\n\\n    /// @dev ETH token withdrawal gas limit, used only for complete withdrawals\\n    uint256 constant ETH_WITHDRAWAL_GAS_LIMIT = 10000;\\n\\n    /// @dev Bytes in one chunk\\n    uint8 constant CHUNK_BYTES = 9;\\n\\n    /// @dev zkSync address length\\n    uint8 constant ADDRESS_BYTES = 20;\\n\\n    uint8 constant PUBKEY_HASH_BYTES = 20;\\n\\n    /// @dev Public key bytes length\\n    uint8 constant PUBKEY_BYTES = 32;\\n\\n    /// @dev Ethereum signature r/s bytes length\\n    uint8 constant ETH_SIGN_RS_BYTES = 32;\\n\\n    /// @dev Success flag bytes length\\n    uint8 constant SUCCESS_FLAG_BYTES = 1;\\n\\n    /// @dev Max amount of tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 constant MAX_AMOUNT_OF_REGISTERED_TOKENS = 127;\\n\\n    /// @dev Max account id that could be registered in the network\\n    uint32 constant MAX_ACCOUNT_ID = (2**24) - 1;\\n\\n    /// @dev Expected average period of block creation\\n    uint256 constant BLOCK_PERIOD = 15 seconds;\\n\\n    /// @dev ETH blocks verification expectation\\n    /// @dev Blocks can be reverted if they are not verified for at least EXPECT_VERIFICATION_IN.\\n    /// @dev If set to 0 validator can revert blocks at any time.\\n    uint256 constant EXPECT_VERIFICATION_IN = 0 hours / BLOCK_PERIOD;\\n\\n    uint256 constant NOOP_BYTES = 1 * CHUNK_BYTES;\\n    uint256 constant DEPOSIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 constant TRANSFER_TO_NEW_BYTES = 6 * CHUNK_BYTES;\\n    uint256 constant PARTIAL_EXIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 constant TRANSFER_BYTES = 2 * CHUNK_BYTES;\\n    uint256 constant FORCED_EXIT_BYTES = 6 * CHUNK_BYTES;\\n\\n    /// @dev Full exit operation length\\n    uint256 constant FULL_EXIT_BYTES = 6 * CHUNK_BYTES;\\n\\n    /// @dev OnchainWithdrawal data length\\n    uint256 constant ONCHAIN_WITHDRAWAL_BYTES = 1 + 20 + 2 + 16; // (uint8 addToPendingWithdrawalsQueue, address _to, uint16 _tokenId, uint128 _amount)\\n\\n    /// @dev ChangePubKey operation length\\n    uint256 constant CHANGE_PUBKEY_BYTES = 6 * CHUNK_BYTES;\\n\\n    /// @dev Expiration delta for priority request to be satisfied (in seconds)\\n    /// @dev NOTE: Priority expiration should be > (EXPECT_VERIFICATION_IN * BLOCK_PERIOD)\\n    /// @dev otherwise incorrect block with priority op could not be reverted.\\n    uint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days;\\n\\n    /// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\\n    uint256 constant PRIORITY_EXPIRATION =\\n        PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD;\\n\\n    /// @dev Maximum number of priority request to clear during verifying the block\\n    /// @dev Cause deleting storage slots cost 5k gas per each slot it's unprofitable to clear too many slots\\n    /// @dev Value based on the assumption of ~750k gas cost of verifying and 5 used storage slots per PriorityOperation structure\\n    uint64 constant MAX_PRIORITY_REQUESTS_TO_DELETE_IN_VERIFY = 6;\\n\\n    /// @dev Reserved time for users to send full exit priority operation in case of an upgrade (in seconds)\\n    uint256 constant MASS_FULL_EXIT_PERIOD = 3 days;\\n\\n    /// @dev Reserved time for users to withdraw funds from full exit priority operation in case of an upgrade (in seconds)\\n    uint256 constant TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT = 2 days;\\n\\n    /// @dev Notice period before activation preparation status of upgrade mode (in seconds)\\n    /// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\\n    uint256 constant UPGRADE_NOTICE_PERIOD =\\n        MASS_FULL_EXIT_PERIOD+PRIORITY_EXPIRATION_PERIOD+TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT;\\n\\n    /// @dev Timestamp - seconds since unix epoch\\n    uint256 constant COMMIT_TIMESTAMP_NOT_OLDER = 8 hours;\\n\\n    /// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\\n    /// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\\n    uint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 15 minutes;\\n\\n    /// @dev Bit mask to apply for verifier public input before verifying.\\n    uint256 constant INPUT_MASK = 14474011154664524427946373126085988481658748083205070504932198000989141204991;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Events.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\n/// @title zkSync events\\n/// @author Matter Labs\\ninterface Events {\\n    /// @notice Event emitted when a block is committed\\n    event BlockCommit(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when a block is verified\\n    event BlockVerification(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when user funds are withdrawn from the account\\n    event OnchainWithdrawal(address indexed owner, uint16 indexed tokenId, uint128 amount);\\n\\n    /// @notice Event emitted when user funds are withdrawn from the rollup\\n    event RollupWithdrawal(address indexed owner, uint16 indexed tokenId, uint128 amount);\\n\\n    /// @notice Event emitted when user send a transaction to deposit her funds\\n    event OnchainDeposit(address indexed sender, uint16 indexed tokenId, uint128 amount, address indexed owner);\\n\\n    /// @notice Event emitted when user sends a authentication fact (e.g. pub-key hash)\\n    event FactAuth(address indexed sender, uint32 nonce, bytes fact);\\n\\n    /// @notice Event emitted when blocks are reverted\\n    event BlocksRevert(uint32 totalBlocksVerified, uint32 totalBlocksCommitted);\\n\\n    /// @notice Exodus mode entered event\\n    event ExodusMode();\\n\\n    /// @notice New priority request event. Emitted when a request is placed into mapping\\n    event NewPriorityRequest(\\n        address sender,\\n        uint64 serialId,\\n        Operations.OpType opType,\\n        bytes pubData,\\n        uint256 expirationBlock\\n    );\\n\\n    /// @notice Deposit committed event.\\n    event DepositCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Full exit committed event.\\n    event FullExitCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Pending withdrawals index range that were added in the verifyBlock operation.\\n    /// NOTE: processed indexes in the queue map are [queueStartIndex, queueEndIndex)\\n    event PendingWithdrawalsAdd(uint32 queueStartIndex, uint32 queueEndIndex);\\n\\n    /// @notice Pending withdrawals index range that were executed in the completeWithdrawals operation.\\n    /// NOTE: processed indexes in the queue map are [queueStartIndex, queueEndIndex)\\n    event PendingWithdrawalsComplete(uint32 queueStartIndex, uint32 queueEndIndex);\\n}\\n\\n/// @title Upgrade events\\n/// @author Matter Labs\\ninterface UpgradeEvents {\\n    /// @notice Event emitted when new upgradeable contract is added to upgrade gatekeeper's list of managed contracts\\n    event NewUpgradable(uint256 indexed versionId, address indexed upgradeable);\\n\\n    /// @notice Upgrade mode enter event\\n    event NoticePeriodStart(\\n        uint256 indexed versionId,\\n        address[] newTargets,\\n        uint256 noticePeriod // notice period (in seconds)\\n    );\\n\\n    /// @notice Upgrade mode cancel event\\n    event UpgradeCancel(uint256 indexed versionId);\\n\\n    /// @notice Upgrade mode preparation status event\\n    event PreparationStart(uint256 indexed versionId);\\n\\n    /// @notice Upgrade mode complete event\\n    event UpgradeComplete(uint256 indexed versionId, address[] newTargets);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Operations.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./Bytes.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\n/// @title zkSync operations tools\\nlibrary Operations {\\n    // Circuit ops and their pubdata (chunks * bytes)\\n\\n    /// @notice zkSync circuit operation type\\n    enum OpType {\\n        Noop,\\n        Deposit,\\n        TransferToNew,\\n        PartialExit,\\n        _CloseAccount, // used for correct op id offset\\n        Transfer,\\n        FullExit,\\n        ChangePubKey,\\n        ForcedExit,\\n        TransferFrom\\n    }\\n\\n    // Byte lengths\\n\\n    uint8 constant OP_TYPE_BYTES = 1;\\n\\n    uint8 constant TOKEN_BYTES = 2;\\n\\n    uint8 constant PUBKEY_BYTES = 32;\\n\\n    uint8 constant NONCE_BYTES = 4;\\n\\n    uint8 constant PUBKEY_HASH_BYTES = 20;\\n\\n    uint8 constant ADDRESS_BYTES = 20;\\n\\n    /// @dev Packed fee bytes lengths\\n    uint8 constant FEE_BYTES = 2;\\n\\n    /// @dev zkSync account id bytes lengths\\n    uint8 constant ACCOUNT_ID_BYTES = 4;\\n\\n    uint8 constant AMOUNT_BYTES = 16;\\n\\n    /// @dev Signature (for example full exit signature) bytes length\\n    uint8 constant SIGNATURE_BYTES = 64;\\n\\n    // Deposit pubdata\\n    struct Deposit {\\n        // uint8 opType\\n        uint32 accountId;\\n        uint16 tokenId;\\n        uint128 amount;\\n        address owner;\\n    }\\n\\n    uint256 public constant PACKED_DEPOSIT_PUBDATA_BYTES =\\n        OP_TYPE_BYTES + ACCOUNT_ID_BYTES + TOKEN_BYTES + AMOUNT_BYTES + ADDRESS_BYTES;\\n\\n    /// Deserialize deposit pubdata\\n    function readDepositPubdata(bytes memory _data) internal pure returns (Deposit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n\\n        require(offset == PACKED_DEPOSIT_PUBDATA_BYTES, \\\"m\\\"); // reading invalid deposit pubdata size\\n    }\\n\\n    /// Serialize deposit pubdata\\n    function writeDepositPubdata(Deposit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            uint8(OpType.Deposit),\\n            bytes4(0), // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenId, // tokenId\\n            op.amount, // amount\\n            op.owner // owner\\n        );\\n    }\\n\\n    /// @notice Write deposit pubdata for priority queue check.\\n    function checkDepositInPriorityQueue(Deposit memory op, bytes20 hashedPubdata) internal pure returns (bool) {\\n        return Utils.hashBytesToBytes20(writeDepositPubdata(op)) == hashedPubdata;\\n    }\\n\\n    // FullExit pubdata\\n\\n    struct FullExit {\\n        // uint8 opType\\n        uint32 accountId;\\n        address owner;\\n        uint16 tokenId;\\n        uint128 amount;\\n    }\\n\\n    uint256 public constant PACKED_FULL_EXIT_PUBDATA_BYTES =\\n        OP_TYPE_BYTES + ACCOUNT_ID_BYTES + ADDRESS_BYTES + TOKEN_BYTES + AMOUNT_BYTES;\\n\\n    function readFullExitPubdata(bytes memory _data) internal pure returns (FullExit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n\\n        require(offset == PACKED_FULL_EXIT_PUBDATA_BYTES, \\\"n\\\"); // reading invalid full exit pubdata size\\n    }\\n\\n    function writeFullExitPubdata(FullExit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            uint8(OpType.FullExit),\\n            op.accountId, // accountId\\n            op.owner, // owner\\n            op.tokenId, // tokenId\\n            uint128(0) // amount -- ignored\\n        );\\n    }\\n\\n    function checkFullExitInPriorityQueue(FullExit memory op, bytes20 hashedPubdata) internal pure returns (bool) {\\n        op.amount = 0;\\n        return Utils.hashBytesToBytes20(writeFullExitPubdata(op)) == hashedPubdata;\\n    }\\n\\n    // PartialExit pubdata\\n\\n    struct PartialExit {\\n        //uint8 opType\\n        //uint32 accountId; -- present in pubdata, ignored at serialization\\n        uint16 tokenId;\\n        uint128 amount;\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n        address owner;\\n    }\\n\\n    function readPartialExitPubdata(bytes memory _data) internal pure returns (PartialExit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES; // opType + accountId (ignored)\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        offset += FEE_BYTES; // fee (ignored)\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n    }\\n\\n    // ForcedExit pubdata\\n\\n    struct ForcedExit {\\n        //uint8 opType; -- present in pubdata, ignored at serialization\\n        //uint32 initiatorAccountId; -- present in pubdata, ignored at serialization\\n        //uint32 targetAccountId; -- present in pubdata, ignored at serialization\\n        uint16 tokenId;\\n        uint128 amount;\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n        address target;\\n    }\\n\\n    function readForcedExitPubdata(bytes memory _data) internal pure returns (ForcedExit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES * 2; // opType + initiatorAccountId + targetAccountId (ignored)\\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        offset += FEE_BYTES; // fee (ignored)\\n        (offset, parsed.target) = Bytes.readAddress(_data, offset); // target\\n    }\\n\\n    // ChangePubKey\\n\\n    enum ChangePubkeyType {ECRECOVER, CREATE2}\\n\\n    struct ChangePubKey {\\n        // uint8 opType; -- present in pubdata, ignored at serialization\\n        uint32 accountId;\\n        bytes20 pubKeyHash;\\n        address owner;\\n        uint32 nonce;\\n        //uint16 tokenId; -- present in pubdata, ignored at serialization\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n    }\\n\\n    function readChangePubKeyPubdata(bytes memory _data) internal pure returns (ChangePubKey memory parsed) {\\n        uint256 offset = OP_TYPE_BYTES;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.pubKeyHash) = Bytes.readBytes20(_data, offset); // pubKeyHash\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n        (offset, parsed.nonce) = Bytes.readUInt32(_data, offset); // nonce\\n    }\\n\\n    // Withdrawal data process\\n\\n    function readWithdrawalData(bytes memory _data, uint256 _offset)\\n        internal\\n        pure\\n        returns (\\n            bool _addToPendingWithdrawalsQueue,\\n            address _to,\\n            uint16 _tokenId,\\n            uint128 _amount\\n        )\\n    {\\n        uint256 offset = _offset;\\n        (offset, _addToPendingWithdrawalsQueue) = Bytes.readBool(_data, offset);\\n        (offset, _to) = Bytes.readAddress(_data, offset);\\n        (offset, _tokenId) = Bytes.readUInt16(_data, offset);\\n        (offset, _amount) = Bytes.readUInt128(_data, offset);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/UpgradeableMaster.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Interface of the upgradeable master contract (defines notice period duration and allows finish upgrade during preparation of it)\\n/// @author Matter Labs\\ninterface UpgradeableMaster {\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external returns (uint256);\\n\\n    /// @notice Notifies contract that notice period started\\n    function upgradeNoticePeriodStarted() external;\\n\\n    /// @notice Notifies contract that upgrade preparation status is activated\\n    function upgradePreparationStarted() external;\\n\\n    /// @notice Notifies contract that upgrade canceled\\n    function upgradeCanceled() external;\\n\\n    /// @notice Notifies contract that upgrade finishes\\n    function upgradeFinishes() external;\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external returns (bool);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Governance.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Config.sol\\\";\\n\\n/// @title Governance Contract\\n/// @author Matter Labs\\ncontract Governance is Config {\\n    /// @notice Token added to Franklin net\\n    event NewToken(address indexed token, uint16 indexed tokenId);\\n\\n    /// @notice Governor changed\\n    event NewGovernor(address newGovernor);\\n\\n    /// @notice Validator's status changed\\n    event ValidatorStatusUpdate(address indexed validatorAddress, bool isActive);\\n\\n    event TokenPausedUpdate(address indexed token, bool paused);\\n\\n    /// @notice Address which will exercise governance over the network i.e. add tokens, change validator set, conduct upgrades\\n    address public networkGovernor;\\n\\n    /// @notice Total number of ERC20 tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 public totalTokens;\\n\\n    /// @notice List of registered tokens by tokenId\\n    mapping(uint16 => address) public tokenAddresses;\\n\\n    /// @notice List of registered tokens by address\\n    mapping(address => uint16) public tokenIds;\\n\\n    /// @notice List of permitted validators\\n    mapping(address => bool) public validators;\\n\\n    /// @notice Paused tokens list, deposits are impossible to create for paused tokens\\n    mapping(uint16 => bool) public pausedTokens;\\n\\n    constructor() {}\\n\\n    /// @notice Governance contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param initializationParameters Encoded representation of initialization parameters:\\n    ///     _networkGovernor The address of network governor\\n    function initialize(bytes calldata initializationParameters) external {\\n        address _networkGovernor = abi.decode(initializationParameters, (address));\\n\\n        networkGovernor = _networkGovernor;\\n    }\\n\\n    /// @notice Governance contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    /// @notice Change current governor\\n    /// @param _newGovernor Address of the new governor\\n    function changeGovernor(address _newGovernor) external {\\n        requireGovernor(msg.sender);\\n        if (networkGovernor != _newGovernor) {\\n            networkGovernor = _newGovernor;\\n            emit NewGovernor(_newGovernor);\\n        }\\n    }\\n\\n    /// @notice Add token to the list of networks tokens\\n    /// @param _token Token address\\n    function addToken(address _token) external {\\n        requireGovernor(msg.sender);\\n        require(tokenIds[_token] == 0, \\\"bz\\\"); // token exists\\n        require(totalTokens < MAX_AMOUNT_OF_REGISTERED_TOKENS, \\\"ca\\\"); // no free identifiers for tokens\\n\\n        totalTokens++;\\n        uint16 newTokenId = totalTokens; // it is not `totalTokens - 1` because tokenId = 0 is reserved for eth\\n\\n        tokenAddresses[newTokenId] = _token;\\n        tokenIds[_token] = newTokenId;\\n        emit NewToken(_token, newTokenId);\\n    }\\n\\n    /// @notice Pause token deposits for the given token\\n    /// @param _tokenAddr Token address\\n    /// @param _tokenPaused Token paused status\\n    function setTokenPaused(address _tokenAddr, bool _tokenPaused) external {\\n        requireGovernor(msg.sender);\\n\\n        uint16 tokenId = this.validateTokenAddress(_tokenAddr);\\n        if (pausedTokens[tokenId] != _tokenPaused) {\\n            pausedTokens[tokenId] = _tokenPaused;\\n            emit TokenPausedUpdate(_tokenAddr, _tokenPaused);\\n        }\\n    }\\n\\n    /// @notice Change validator status (active or not active)\\n    /// @param _validator Validator address\\n    /// @param _active Active flag\\n    function setValidator(address _validator, bool _active) external {\\n        requireGovernor(msg.sender);\\n        if (validators[_validator] != _active) {\\n            validators[_validator] = _active;\\n            emit ValidatorStatusUpdate(_validator, _active);\\n        }\\n    }\\n\\n    /// @notice Check if specified address is is governor\\n    /// @param _address Address to check\\n    function requireGovernor(address _address) public view {\\n        require(_address == networkGovernor, \\\"cb\\\"); // only by governor\\n    }\\n\\n    /// @notice Checks if validator is active\\n    /// @param _address Validator address\\n    function requireActiveValidator(address _address) external view {\\n        require(validators[_address], \\\"cc\\\"); // validator is not active\\n    }\\n\\n    /// @notice Validate token id (must be less than or equal to total tokens amount)\\n    /// @param _tokenId Token id\\n    /// @return bool flag that indicates if token id is less than or equal to total tokens amount\\n    function isValidTokenId(uint16 _tokenId) external view returns (bool) {\\n        return _tokenId <= totalTokens;\\n    }\\n\\n    /// @notice Validate token address\\n    /// @param _tokenAddr Token address\\n    /// @return tokens id\\n    function validateTokenAddress(address _tokenAddr) external view returns (uint16) {\\n        uint16 tokenId = tokenIds[_tokenAddr];\\n        require(tokenId != 0, \\\"cd\\\"); // 0 is not a valid token\\n        return tokenId;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Verifier.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\nimport \\\"./KeysWithPlonkVerifier.sol\\\";\\nimport \\\"./Config.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract Verifier is KeysWithPlonkVerifier, Config {\\n    function initialize(bytes calldata) external {}\\n\\n    /// @notice Verifier contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    function verifyAggregatedProof(\\n        uint256[] memory _recursiveInput,\\n        uint256[] memory _proof,\\n        uint8[] memory _vkIndexes,\\n        uint256[] memory _individual_vks_inputs,\\n        uint256[16] memory _subproofs_limbs,\\n        bool blockProof\\n    ) external view returns (bool) {\\n        for (uint256 i = 0; i < _individual_vks_inputs.length; ++i) {\\n            uint256 commitment = _individual_vks_inputs[i];\\n            _individual_vks_inputs[i] = uint256(commitment) & INPUT_MASK;\\n        }\\n        VerificationKey memory vk = getVkAggregated(uint32(_vkIndexes.length));\\n\\n        uint256 treeRoot = blockProof ? VK_TREE_ROOT : VK_EXIT_TREE_ROOT;\\n\\n        return\\n            verify_serialized_proof_with_recursion(\\n                _recursiveInput,\\n                _proof,\\n                treeRoot,\\n                VK_MAX_INDEX,\\n                _vkIndexes,\\n                _individual_vks_inputs,\\n                _subproofs_limbs,\\n                vk\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/KeysWithPlonkVerifier.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./PlonkCore.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract KeysWithPlonkVerifier is VerifierWithDeserialize {\\n\\n    uint256 constant VK_TREE_ROOT = 0x2d30d1a0fc7880759a9a38f5f2b2faeeb449186dbb1ea3461980b1defdd3d009;\\n    uint8 constant VK_MAX_INDEX = 5;\\n    uint256 constant VK_EXIT_TREE_ROOT = 0x1a0126b1a46229ab86d1596d8c1c0129629f8aaf71d08027471d1ceaa22e76ad;\\n\\n    function getVkAggregated(uint32 _proofs) internal pure returns (VerificationKey memory vk) {\\n        if (_proofs == uint32(1)) { return getVkAggregated1(); }\\n        else if (_proofs == uint32(5)) { return getVkAggregated5(); }\\n        else if (_proofs == uint32(10)) { return getVkAggregated10(); }\\n        else if (_proofs == uint32(20)) { return getVkAggregated20(); }\\n    }\\n\\n    \\n    function getVkAggregated1() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 4194304;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x18c95f1ae6514e11a1b30fd7923947c5ffcec5347f16e91b4dd654168326bede);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x1b2d28f346ba6302090869b58c0ccf45994c8aaee54101d489e4605b9b9d69a5,\\n            0x05b254b5537aede870276a46ae3046ae4cb36a5e41b1a1208355a4b2de0fc3c4\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x0e111faf12e663d8e6aa9b7c434376e13fb4ae52bb597bcc23f2044710daa60a,\\n            0x16505d91104cdf110698ebe99f0abd162630e4b108356640d1abd8596c4680d2\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x0e6aaf4f2ceb4d0b781ccbcb8c6b235d6c74df0079e8db8eefc9539b6ca2d920,\\n            0x0779a9706bd1a8315662914928188f51a2081d1bbeb863a1f6945ab6e1752513\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x12f8cc0d6eaa884fa1fa6ec2c23cd21892dff4298c67451f6c234293a85d977b,\\n            0x165d8106e03536fcf8c66391ee31e97b00664932d63d61a008108d68f8da2dcd\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x282ab78735c94c7d4fe2b134e7cee6bf967921c744b2df5b1ac7980ca39a6ef4,\\n            0x0f627a1b42661cca9fa1e2de44d78413a1817b0ea44506de524f3aeb43b00c69\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x0f1abdaaea6fc0c841cbdbb84315392c7de7270704d2bd990f3205f06f3c2e72,\\n            0x18e32227065587b5814b4d1f8d7f78689af94f711d0521575c2ad723706403ac\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x2e43a380b145f473c7b76c29110fa2a54d29e39e4c3e7a0667656f5d7c6fa783,\\n            0x0c56e0e6679b4b71113d073ad16a405c62f1154a37202dcefce83ab2aa2bfd99\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x287f80f33b27cac8c1d7ea38e3f38b9547fc64241f369332ced9f13255f02a11,\\n            0x0019b4dfa8d1fa5172b3609a3ee75532a8fcdd946df313edb466502baec90916\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x262c679d64425eba4718852094935ed36c916c8e58970723ab56a6edfec8ee53,\\n            0x11512b535dcd41a87ff8fe16b944b0fc33a13b6ab82bed1e1fef9f887fb8bd17\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x06e470b8f5828b55b7c2a1c25879f07c2e60ff3936de7c7a9a1d0cf11c7154cb,\\n            0x0183d6431267f015d722e1e47fae0d8f6a66b1b75c271f6f2f7a19fd9bde0deb\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x2c42b01e3e994120ebbc941def201a6242ceca9d24a5b0c21c1e00267126eb03,\\n            0x2b3ee88ed3e1550605d061cb8db20ff97560e735f23e3234b32b875b2b0af854\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x20f62698b7f1defcc8da79330979c7d176d2c9b72d031dac96e1db91c7596f22,\\n            0x0ff81068a3a7706205893199514f4bbf06aa644ba08591b2b5cf315136fbbe89\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x1645e6c282336dfd4ec70d4ebb71050390f70927a887dcfd6527070659f3a7e7,\\n            0x1c93ca29a27a931a34482db88bed589951aa7d406b5583da235bf618fb4d048e\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkAggregated5() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 16777216;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x1951441010b2b95a6e47a6075066a50a036f5ba978c050f2821df86636c0facb);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x20798e765493cd6c469f4ce0fb7b28da9a5f7953c8cec9a5735f06f389cafde5,\\n            0x17251e248d9e9bcfdd48c67b819e975ad3dafb103f4970fe2c5c7c09c7a5c01d\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x2fc13898392af94dde4dc8522b3d40059ed91645d3d67dc828310e742bb367ff,\\n            0x1901ae3711afcac1852051b9a0b2b849fe421d823f1abcb21dc951c88773d5ec\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x044f772c23604be394e1552d017e90e8ce76107b47436df67e6cf8af217df127,\\n            0x0b2c6cfb5740376c4ad4bdf448e23ca636e3d63fd0e21509e19bfd2f17e4f9db\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x2d6e15e221beaa35378a2dc4eec988cad1a9bdaabb7a94939747506a7c11fb07,\\n            0x07f0555dd28e1849d2dfb67d09b6cd0a044d8e1598b7f2dabac47d02afbde104\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x0f75e4f497f3ab4badccb48d638b32a1c72d725683cb579587c56345c7b5c5ca,\\n            0x0cfcffa462dd360860a637ec6c85aca924738472a1890904ffb3b12035cd2a95\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x1b452c4ed0d39f1a0c3509e6c0e0716206daf34ac56d7b392381b77b831d04b8,\\n            0x2ec5fc94a3d9fa7f7e8d8f4c976634a4c581469202cdf0962c6bbc1cfe1e2854\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x1d76ec2121fd568d20f6a3225bd9f605502941e2fa885972084509bd7b792f83,\\n            0x10e264487cf80e39e94079e84f9a7805a9c5f50a9f8f9c18490927dec45c015a\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x1b4c31be5bb7126ffee8a38dbc07b0b1f134144d6ae9a7cc4012408caeefd287,\\n            0x2bcc49e52073baa3db469867cc6e69ba5c058a70e53c37d7cfc1a4930265f506\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x1284551f36faeb407cc7032eaea6f3c1ce0709a7a5487d5b6cad65e93cc9f5ad,\\n            0x2ab751e5e2e598d6bff15eff38df0042bd609b0c9cae2a276153883cdf0db65f\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x2461419a8b3fa4852edd1962d47f839a7d6d0aa03d7854c5e5fa9f616082720d,\\n            0x2a33adabc8e1348789e0f6fe74d3a1627d2971067a6f564fe836add79cd4fb8e\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x26c5de18a55d3e05389089e4f87c22e4a65fdfb3c8ceebe94fad480762005d8b,\\n            0x12cae9a5899d7582e5f95fd9fab2b9907b9f72728630e816de77154b759f757a\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x2ac7330d3ca44d25eac57b4882bddf9ac755354701b0ad3f59c79b5af701bc50,\\n            0x1b295eee1b5472020b65ae792c4b1857457a32f56b93b0258f1ad6a6cbd9121e\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x0587644c2baa2878f893a96eccaa3393e213496aefbcbba257faf04aaa22bff5,\\n            0x00e27f098241d232356ce65b1b2eabc53e6920f407667d9834450ad6cba32cee\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkAggregated10() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 33554432;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0d94d63997367c97a8ed16c17adaae39262b9af83acb9e003f94c217303dd160);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x195ddaa40f4b6e9b30d12fa31b569a464bc6bfed3ee6ff93d9e682f2feead9be,\\n            0x2ff44a308801b2e8c089531d6aef1c36934f397d61bcd4b0d40a374bf9df9436\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x0d3fa3f06569639bf5bbaf07f4938f56590e0ef1fc40bf3b1a38c833c520e06d,\\n            0x03f5fac1bb71bb9f9995989addf5dc96077149859b9e04f0a1c3155daf209dda\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x2fd417c4292d8d98209fbf5e4f2d9db2ccac53347a5a6a47ec844afedc7bcc1c,\\n            0x2c283b236436a7263d2e67971df7cd534a0c7afd5a6709540cb9e42b464a1306\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x0992d873a69f092ad514b93050c8a380a29638aece0ee6119558bc441cfcb0ab,\\n            0x2773318f90e7ac7591f681caae174e2bc81d85406a0224d0d6709311293f1ad6\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x287a21ccbbb448f17ea093bf72e5ffa6408ab0c42b5a0a2ba6cfa54dfa81ca8e,\\n            0x30276a7e2e21e76cb5e6d11dfd8c9fdf21ef1d39ce8b6322198ff83e0d2abf2f\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x2928f5217dc1375eac8c7b4d695d6fafacf012f98262defe9c5b09a851921176,\\n            0x0e0c579f9a0bfa1d6ce0e510814a16f24298db9545d1dabc2bb303e329c91716\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x06546546c2d7526784dcfc955ae3f714514efdf93f1672c3ae89227c237552f6,\\n            0x0bf25d7526789defc06fcd53246265f050341964806b46c615696ab4e6482abf\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x22b4669582b192b994fd4fece3a71194e117258c25118d8bc62be88e394862ab,\\n            0x0368275fa2196f8f73814e96cf0a650568969b6e0e65c66049519dc01250ab3b\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x13164c9232db87769529343c77e90d4e5d178b0695d5acc44b9e3af5e138d3cd,\\n            0x2b95e0779238d9324dda354e700d8747856b5885f42de8ac8f119e690bc6b4ce\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x09b9984565afa4a789d6ba629d81bc7a8f191f609a415dd071d68068f1ece1a9,\\n            0x0c7ade93f30c15025e00ec419a8234e23c75b8b41a6d262a0567e1494a63a089\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x050ab6d4715d929e6a03d246665bdb3ae3fb330cb1624b9dd80a16915f919097,\\n            0x05080bc8892e8cfa5173c161655d0d9604de4246ce93ee0f39aecc44643c8338\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x144272056d3bfd3a20817bd9e83db9255bf75d1087ea026ed265f350558bdbdb,\\n            0x1291171a46ae520cfeb48306f75bd9b6bcc682c25f5491bbae05967032226db7\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x135e1e48ff5f743ef65611bd6c035d609898a3aa0e1e7ac73ff84aa1591a0ff0,\\n            0x29e8199b33b3c240d61b5bdd63758876283dc51abb963c8a3ed6d7c39f9f61d4\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkAggregated20() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 67108864;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x1dba8b5bdd64ef6ce29a9039aca3c0e524395c43b9227b96c75090cc6cc7ec97);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x27310730dd3548df041a98ca4440019aac2ff23896dc0b311131e3bd258ed585,\\n            0x2afba6db2001ec0fb46a7aa815df9d284f93be7735f4603183df22810a8d34eb\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x2b6e6a32d4e82fd7c982ec92a970e99ca6fece8a7426f0f03c82674e285f3abc,\\n            0x0b1cd760a8d7c2956f620733013b687515d1a8667453eb6ebddef095d9c82c6e\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x01382f6465a7bed9283aeb0d42bfec55233220397fd54c5c31b3b0358d97840d,\\n            0x098ceef2375246c73b544e0e6d59942d555997f58d71fe650b3c56cb7b0c1e1f\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x0d05c024a2e0990fb0dd6831d5768ad0e5ea2cab4e56f70c02b5d20eccd59242,\\n            0x1caef11577704020cb0bc332a06cfcbdc91688826ecfce4d7fa95b1d356e33c6\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x150f1c2a2da8b30067f44c774dc7c913ce5b503794489eae66117ab28d7f0d56,\\n            0x1315bfe5e9c07a370e62ac4ee82677259abd15b698b5c679bb9cf97112406602\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x16ee6c88117311a18268d276280d151ef746b429d4e3bebde63432220fcc43af,\\n            0x12af9840baa1f43fe449b3aba6fbcd9a96dfd50bfb670227c5299191722b676b\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x0a4ff4dbdd532c7848559ca80b18d0e026aa05481e41bf0c7f3c3d2033c504c1,\\n            0x03b1b5f40650541a02900534cf4b941f3c3abf54d0dce8753fbf41905067fba2\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x1aeed9f925d1a9021bf63cace33e5e329a2fc2bc3ff2f15d44bd64b2612f776c,\\n            0x161e4b64f846f86f1a86cb57a179d18deb4d5485e90384c343c42827062717b2\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x08bb3a04dfc8a05064f3cca8ef52d8eeb2f3a0b2d3b3c243dc2d2c37ac63b09d,\\n            0x0f9cd3f78f222982e949d97119c5197553bce77ecc808d9360b5d98c9323dada\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x2d6933d1ead2cc32e1743d39f9230f34b2ba7cbd6f0ce4a495e2a6c06f56527c,\\n            0x2537cf3a2fbd9f49da269c2ac8f980347e7d6c3063bb4fbaf079976e86880849\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x174beb42335087164d215735b4ed67200735d97b35deb24e946388b851b54ebc,\\n            0x0ed913c69e882565aa8fcda65f9029b0c8e388790af40e802ea7c3ad6f114246\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x01088efa71f09d3067482a7383fe52b37417cf7fe85410b67dcb2e28139efbca,\\n            0x270b2a49ecbf9852a418726bdbe9df4d453eb88e39927089d5a0d27338798d75\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x2fcc3bec8b60cca2c3d9b8ef77883b04eb896124157b8356cef0436177fb6ab8,\\n            0x24eb48d7484ae4bb0163d49e165a27c6375b9969c3bad591a1e0a1355e2e128f\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/PlonkCore.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\nlibrary PairingsBn254 {\\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant bn254_b_coeff = 3;\\n\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n\\n    struct Fr {\\n        uint256 value;\\n    }\\n\\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\\n        require(fr < r_mod);\\n        return Fr({value: fr});\\n    }\\n\\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\\n        n.value = self.value;\\n    }\\n\\n    function assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = other.value;\\n    }\\n\\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\\n        require(fr.value != 0);\\n        return pow(fr, r_mod - 2);\\n    }\\n\\n    function add_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, other.value, r_mod);\\n    }\\n\\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\\n    }\\n\\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = mulmod(self.value, other.value, r_mod);\\n    }\\n\\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\\n        uint256[1] memory result;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\\n        }\\n        require(success);\\n        return Fr({value: result[0]});\\n    }\\n\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint256[2] X;\\n        uint256[2] Y;\\n    }\\n\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        if (x == 0 && y == 0) {\\n            // point of infinity is (0,0)\\n            return G1Point(x, y);\\n        }\\n\\n        // check encoding\\n        require(x < q_mod);\\n        require(y < q_mod);\\n        // check on curve\\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\\n        rhs = mulmod(rhs, x, q_mod); // x^3\\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\\n        require(lhs == rhs);\\n\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\\n        return G2Point(x, y);\\n    }\\n\\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\\n        result.X = self.X;\\n        result.Y = self.Y;\\n    }\\n\\n    function P2() internal pure returns (G2Point memory) {\\n        // for some reason ethereum expects to have c1*v + c0 form\\n\\n        return\\n            G2Point(\\n                [\\n                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\\n                ],\\n                [\\n                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n                ]\\n            );\\n    }\\n\\n    function negate(G1Point memory self) internal pure {\\n        // The prime q in the base field F_q for G1\\n        if (self.Y == 0) {\\n            require(self.X == 0);\\n            return;\\n        }\\n\\n        self.Y = q_mod - self.Y;\\n    }\\n\\n    function point_add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\\n        point_add_into_dest(p1, p2, r);\\n        return r;\\n    }\\n\\n    function point_add_assign(G1Point memory p1, G1Point memory p2) internal view {\\n        point_add_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_add_into_dest(\\n        G1Point memory p1,\\n        G1Point memory p2,\\n        G1Point memory dest\\n    ) internal view {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we add zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we add into zero, and we add non-zero point\\n            dest.X = p2.X;\\n            dest.Y = p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_sub_assign(G1Point memory p1, G1Point memory p2) internal view {\\n        point_sub_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_sub_into_dest(\\n        G1Point memory p1,\\n        G1Point memory p2,\\n        G1Point memory dest\\n    ) internal view {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we subtracted zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we subtract from zero, and we subtract non-zero point\\n            dest.X = p2.X;\\n            dest.Y = q_mod - p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = q_mod - p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_mul(G1Point memory p, Fr memory s) internal view returns (G1Point memory r) {\\n        point_mul_into_dest(p, s, r);\\n        return r;\\n    }\\n\\n    function point_mul_assign(G1Point memory p, Fr memory s) internal view {\\n        point_mul_into_dest(p, s, p);\\n    }\\n\\n    function point_mul_into_dest(\\n        G1Point memory p,\\n        Fr memory s,\\n        G1Point memory dest\\n    ) internal view {\\n        uint256[3] memory input;\\n        input[0] = p.X;\\n        input[1] = p.Y;\\n        input[2] = s.value;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\\n        }\\n        require(success);\\n    }\\n\\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\\n        require(p1.length == p2.length);\\n        uint256 elements = p1.length;\\n        uint256 inputSize = elements * 6;\\n        uint256[] memory input = new uint256[](inputSize);\\n        for (uint256 i = 0; i < elements; i++) {\\n            input[i * 6 + 0] = p1[i].X;\\n            input[i * 6 + 1] = p1[i].Y;\\n            input[i * 6 + 2] = p2[i].X[0];\\n            input[i * 6 + 3] = p2[i].X[1];\\n            input[i * 6 + 4] = p2[i].Y[0];\\n            input[i * 6 + 5] = p2[i].Y[1];\\n        }\\n        uint256[1] memory out;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\\n        }\\n        require(success);\\n        return out[0] != 0;\\n    }\\n\\n    /// Convenience method for a pairing check for two pairs.\\n    function pairingProd2(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2\\n    ) internal view returns (bool) {\\n        G1Point[] memory p1 = new G1Point[](2);\\n        G2Point[] memory p2 = new G2Point[](2);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        return pairing(p1, p2);\\n    }\\n}\\n\\nlibrary TranscriptLibrary {\\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint32 constant DST_0 = 0;\\n    uint32 constant DST_1 = 1;\\n    uint32 constant DST_CHALLENGE = 2;\\n\\n    struct Transcript {\\n        bytes32 state_0;\\n        bytes32 state_1;\\n        uint32 challenge_counter;\\n    }\\n\\n    function new_transcript() internal pure returns (Transcript memory t) {\\n        t.state_0 = bytes32(0);\\n        t.state_1 = bytes32(0);\\n        t.challenge_counter = 0;\\n    }\\n\\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\\n        bytes32 old_state_0 = self.state_0;\\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\\n    }\\n\\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\\n        update_with_u256(self, value.value);\\n    }\\n\\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\\n        update_with_u256(self, p.X);\\n        update_with_u256(self, p.Y);\\n    }\\n\\n    function get_challenge(Transcript memory self) internal pure returns (PairingsBn254.Fr memory challenge) {\\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\\n        self.challenge_counter += 1;\\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\\n    }\\n}\\n\\ncontract Plonk4VerifierWithAccessToDNext {\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\\n\\n    uint256 constant ZERO = 0;\\n    uint256 constant ONE = 1;\\n    uint256 constant TWO = 2;\\n    uint256 constant THREE = 3;\\n    uint256 constant FOUR = 4;\\n\\n    uint256 constant STATE_WIDTH = 4;\\n    uint256 constant NUM_DIFFERENT_GATES = 2;\\n    uint256 constant NUM_SETUP_POLYS_FOR_MAIN_GATE = 7;\\n    uint256 constant NUM_SETUP_POLYS_RANGE_CHECK_GATE = 0;\\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP = 1;\\n    uint256 constant NUM_GATE_SELECTORS_OPENED_EXPLICITLY = 1;\\n\\n    uint256 constant RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK =\\n        0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    uint256 constant LIMB_WIDTH = 68;\\n\\n    struct VerificationKey {\\n        uint256 domain_size;\\n        uint256 num_inputs;\\n        PairingsBn254.Fr omega;\\n        PairingsBn254.G1Point[NUM_SETUP_POLYS_FOR_MAIN_GATE + NUM_SETUP_POLYS_RANGE_CHECK_GATE] gate_setup_commitments;\\n        PairingsBn254.G1Point[NUM_DIFFERENT_GATES] gate_selector_commitments;\\n        PairingsBn254.G1Point[STATE_WIDTH] copy_permutation_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_non_residues;\\n        PairingsBn254.G2Point g2_x;\\n    }\\n\\n    struct Proof {\\n        uint256[] input_values;\\n        PairingsBn254.G1Point[STATE_WIDTH] wire_commitments;\\n        PairingsBn254.G1Point copy_permutation_grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH] wire_values_at_z;\\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] wire_values_at_z_omega;\\n        PairingsBn254.Fr[NUM_GATE_SELECTORS_OPENED_EXPLICITLY] gate_selector_values_at_z;\\n        PairingsBn254.Fr copy_grand_product_at_z_omega;\\n        PairingsBn254.Fr quotient_polynomial_at_z;\\n        PairingsBn254.Fr linearization_polynomial_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH - 1] permutation_polynomials_at_z;\\n        PairingsBn254.G1Point opening_at_z_proof;\\n        PairingsBn254.G1Point opening_at_z_omega_proof;\\n    }\\n\\n    struct PartialVerifierState {\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr[] cached_lagrange_evals;\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function batch_evaluate_lagrange_poly_out_of_domain(\\n        uint256[] memory poly_nums,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr[] memory res) {\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory tmp_1 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory tmp_2 = PairingsBn254.new_fr(domain_size);\\n        PairingsBn254.Fr memory vanishing_at_z = at.pow(domain_size);\\n        vanishing_at_z.sub_assign(one);\\n        // we can not have random point z be in domain\\n        require(vanishing_at_z.value != 0);\\n        PairingsBn254.Fr[] memory nums = new PairingsBn254.Fr[](poly_nums.length);\\n        PairingsBn254.Fr[] memory dens = new PairingsBn254.Fr[](poly_nums.length);\\n        // numerators in a form omega^i * (z^n - 1)\\n        // denoms in a form (z - omega^i) * N\\n        for (uint256 i = 0; i < poly_nums.length; i++) {\\n            tmp_1 = omega.pow(poly_nums[i]); // power of omega\\n            nums[i].assign(vanishing_at_z);\\n            nums[i].mul_assign(tmp_1);\\n\\n            dens[i].assign(at); // (X - omega^i) * N\\n            dens[i].sub_assign(tmp_1);\\n            dens[i].mul_assign(tmp_2); // mul by domain size\\n        }\\n\\n        PairingsBn254.Fr[] memory partial_products = new PairingsBn254.Fr[](poly_nums.length);\\n        partial_products[0].assign(PairingsBn254.new_fr(1));\\n        for (uint256 i = 1; i < dens.length - 1; i++) {\\n            partial_products[i].assign(dens[i - 1]);\\n            partial_products[i].mul_assign(dens[i]);\\n        }\\n\\n        tmp_2.assign(partial_products[partial_products.length - 1]);\\n        tmp_2.mul_assign(dens[dens.length - 1]);\\n        tmp_2 = tmp_2.inverse(); // tmp_2 contains a^-1 * b^-1 (with! the last one)\\n\\n        for (uint256 i = dens.length - 1; i < dens.length; i--) {\\n            dens[i].assign(tmp_2); // all inversed\\n            dens[i].mul_assign(partial_products[i]); // clear lowest terms\\n            tmp_2.mul_assign(dens[i]);\\n        }\\n\\n        for (uint256 i = 0; i < nums.length; i++) {\\n            nums[i].mul_assign(dens[i]);\\n        }\\n\\n        return nums;\\n    }\\n\\n    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)\\n        internal\\n        view\\n        returns (PairingsBn254.Fr memory res)\\n    {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function verify_at_z(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.Fr memory lhs = evaluate_vanishing(vk.domain_size, state.z);\\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\\n\\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\\n\\n        // public inputs\\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\\n            tmp.assign(state.cached_lagrange_evals[i]);\\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            inputs_term.add_assign(tmp);\\n        }\\n\\n        inputs_term.mul_assign(proof.gate_selector_values_at_z[0]);\\n        rhs.add_assign(inputs_term);\\n\\n        // now we need 5th power\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.copy_grand_product_at_z_omega);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp.mul_assign(state.beta);\\n            tmp.add_assign(state.gamma);\\n            tmp.add_assign(proof.wire_values_at_z[i]);\\n\\n            z_part.mul_assign(tmp);\\n        }\\n\\n        tmp.assign(state.gamma);\\n        // we need a wire value of the last polynomial in enumeration\\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH - 1]);\\n\\n        z_part.mul_assign(tmp);\\n        z_part.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(z_part);\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        tmp.assign(state.cached_lagrange_evals[0]);\\n        tmp.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(tmp);\\n\\n        return lhs.value == rhs.value;\\n    }\\n\\n    function add_contribution_from_range_constraint_gates(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        PairingsBn254.Fr memory current_alpha\\n    ) internal pure returns (PairingsBn254.Fr memory res) {\\n        // now add contribution from range constraint gate\\n        // we multiply selector commitment by all the factors (alpha*(c - 4d)(c - 4d - 1)(..-2)(..-3) + alpha^2 * (4b - c)()()() + {} + {})\\n\\n        PairingsBn254.Fr memory one_fr = PairingsBn254.new_fr(ONE);\\n        PairingsBn254.Fr memory two_fr = PairingsBn254.new_fr(TWO);\\n        PairingsBn254.Fr memory three_fr = PairingsBn254.new_fr(THREE);\\n        PairingsBn254.Fr memory four_fr = PairingsBn254.new_fr(FOUR);\\n\\n        res = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t0 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t1 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t2 = PairingsBn254.new_fr(0);\\n\\n        for (uint256 i = 0; i < 3; i++) {\\n            current_alpha.mul_assign(state.alpha);\\n\\n            // high - 4*low\\n\\n            // this is 4*low\\n            t0 = PairingsBn254.copy(proof.wire_values_at_z[3 - i]);\\n            t0.mul_assign(four_fr);\\n\\n            // high\\n            t1 = PairingsBn254.copy(proof.wire_values_at_z[2 - i]);\\n            t1.sub_assign(t0);\\n\\n            // t0 is now t1 - {0,1,2,3}\\n\\n            // first unroll manually for -0;\\n            t2 = PairingsBn254.copy(t1);\\n\\n            // -1\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(one_fr);\\n            t2.mul_assign(t0);\\n\\n            // -2\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(two_fr);\\n            t2.mul_assign(t0);\\n\\n            // -3\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(three_fr);\\n            t2.mul_assign(t0);\\n\\n            t2.mul_assign(current_alpha);\\n\\n            res.add_assign(t2);\\n        }\\n\\n        // now also d_next - 4a\\n\\n        current_alpha.mul_assign(state.alpha);\\n\\n        // high - 4*low\\n\\n        // this is 4*low\\n        t0 = PairingsBn254.copy(proof.wire_values_at_z[0]);\\n        t0.mul_assign(four_fr);\\n\\n        // high\\n        t1 = PairingsBn254.copy(proof.wire_values_at_z_omega[0]);\\n        t1.sub_assign(t0);\\n\\n        // t0 is now t1 - {0,1,2,3}\\n\\n        // first unroll manually for -0;\\n        t2 = PairingsBn254.copy(t1);\\n\\n        // -1\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(one_fr);\\n        t2.mul_assign(t0);\\n\\n        // -2\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(two_fr);\\n        t2.mul_assign(t0);\\n\\n        // -3\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(three_fr);\\n        t2.mul_assign(t0);\\n\\n        t2.mul_assign(current_alpha);\\n\\n        res.add_assign(t2);\\n\\n        return res;\\n    }\\n\\n    function reconstruct_linearization_commitment(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point memory res) {\\n        // we compute what power of v is used as a delinearization factor in batch opening of\\n        // commitments. Let's label W(x) = 1 / (x - z) *\\n        // [\\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\\n        // + v (r(x) - r(z))\\n        // + v^{2..5} * (witness(x) - witness(z))\\n        // + v^{6} * (selector(x) - selector(z))\\n        // + v^{7..9} * (permutation(x) - permutation(z))\\n        // ]\\n        // W'(x) = 1 / (x - z*omega) *\\n        // [\\n        // + v^10 (z(x) - z(z*omega)) <- we need this power\\n        // + v^11 * (d(x) - d(z*omega))\\n        // ]\\n        //\\n\\n        // we reconstruct linearization polynomial virtual selector\\n        // for that purpose we first linearize over main gate (over all it's selectors)\\n        // and multiply them by value(!) of the corresponding main gate selector\\n        res = PairingsBn254.copy_g1(vk.gate_setup_commitments[STATE_WIDTH + 1]); // index of q_const(x)\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\\n\\n        // addition gates\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            tmp_g1 = vk.gate_setup_commitments[i].point_mul(proof.wire_values_at_z[i]);\\n            res.point_add_assign(tmp_g1);\\n        }\\n\\n        // multiplication gate\\n        tmp_fr.assign(proof.wire_values_at_z[0]);\\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\\n        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH].point_mul(tmp_fr);\\n        res.point_add_assign(tmp_g1);\\n\\n        // d_next\\n        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH + 2].point_mul(proof.wire_values_at_z_omega[0]); // index of q_d_next(x)\\n        res.point_add_assign(tmp_g1);\\n\\n        // multiply by main gate selector(z)\\n        res.point_mul_assign(proof.gate_selector_values_at_z[0]); // these is only one explicitly opened selector\\n\\n        PairingsBn254.Fr memory current_alpha = PairingsBn254.new_fr(ONE);\\n\\n        // calculate scalar contribution from the range check gate\\n        tmp_fr = add_contribution_from_range_constraint_gates(state, proof, current_alpha);\\n        tmp_g1 = vk.gate_selector_commitments[1].point_mul(tmp_fr); // selector commitment for range constraint gate * scalar\\n        res.point_add_assign(tmp_g1);\\n\\n        // proceed as normal to copy permutation\\n        current_alpha.mul_assign(state.alpha); // alpha^5\\n\\n        PairingsBn254.Fr memory alpha_for_grand_product = PairingsBn254.copy(current_alpha);\\n\\n        // z * non_res * beta + gamma + a\\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\\n        grand_product_part_at_z.mul_assign(state.beta);\\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\\n        grand_product_part_at_z.add_assign(state.gamma);\\n        for (uint256 i = 0; i < vk.copy_permutation_non_residues.length; i++) {\\n            tmp_fr.assign(state.z);\\n            tmp_fr.mul_assign(vk.copy_permutation_non_residues[i]);\\n            tmp_fr.mul_assign(state.beta);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i + 1]);\\n\\n            grand_product_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        grand_product_part_at_z.mul_assign(alpha_for_grand_product);\\n\\n        // alpha^n & L_{0}(z), and we bump current_alpha\\n        current_alpha.mul_assign(state.alpha);\\n\\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\\n        tmp_fr.mul_assign(current_alpha);\\n\\n        grand_product_part_at_z.add_assign(tmp_fr);\\n\\n        // prefactor for grand_product(x) is complete\\n\\n        // add to the linearization a part from the term\\n        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp_fr.assign(state.beta);\\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\\n\\n            last_permutation_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        last_permutation_part_at_z.mul_assign(state.beta);\\n        last_permutation_part_at_z.mul_assign(proof.copy_grand_product_at_z_omega);\\n        last_permutation_part_at_z.mul_assign(alpha_for_grand_product); // we multiply by the power of alpha from the argument\\n\\n        // actually multiply prefactors by z(x) and perm_d(x) and combine them\\n        tmp_g1 = proof.copy_permutation_grand_product_commitment.point_mul(grand_product_part_at_z);\\n        tmp_g1.point_sub_assign(vk.copy_permutation_commitments[STATE_WIDTH - 1].point_mul(last_permutation_part_at_z));\\n\\n        res.point_add_assign(tmp_g1);\\n        // multiply them by v immedately as linearization has a factor of v^1\\n        res.point_mul_assign(state.v);\\n        // res now contains contribution from the gates linearization and\\n        // copy permutation part\\n\\n        // now we need to add a part that is the rest\\n        // for z(x*omega):\\n        // - (a(z) + beta*perm_a + gamma)*()*()*(d(z) + gamma) * z(x*omega)\\n    }\\n\\n    function aggregate_commitments(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point[2] memory res) {\\n        PairingsBn254.G1Point memory d = reconstruct_linearization_commitment(state, proof, vk);\\n\\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\\n        for (uint256 i = 1; i < proof.quotient_poly_commitments.length; i++) {\\n            tmp_fr.mul_assign(z_in_domain_size);\\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        commitment_aggregation.point_add_assign(d);\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint256 i = 0; i < NUM_GATE_SELECTORS_OPENED_EXPLICITLY; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.gate_selector_commitments[0].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint256 i = 0; i < vk.copy_permutation_commitments.length - 1; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.copy_permutation_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        // now do prefactor for grand_product(x*omega)\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        commitment_aggregation.point_add_assign(proof.copy_permutation_grand_product_commitment.point_mul(tmp_fr));\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH - 1].point_mul(tmp_fr);\\n        commitment_aggregation.point_add_assign(tmp_g1);\\n\\n        // collect opening values\\n        aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.wire_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_fr.assign(proof.gate_selector_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.copy_grand_product_at_z_omega);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\\n\\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\\n\\n        tmp_fr.assign(state.z);\\n        tmp_fr.mul_assign(vk.omega);\\n        tmp_fr.mul_assign(state.u);\\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\\n\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\\n        pair_with_x.negate();\\n\\n        res[0] = pair_with_generator;\\n        res[1] = pair_with_x;\\n\\n        return res;\\n    }\\n\\n    function verify_initial(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        require(proof.input_values.length == vk.num_inputs);\\n        require(vk.num_inputs >= 1);\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            transcript.update_with_g1(proof.wire_commitments[i]);\\n        }\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\\n        }\\n\\n        state.z = transcript.get_challenge();\\n\\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {\\n            lagrange_poly_numbers[i] = i;\\n        }\\n\\n        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain(\\n            lagrange_poly_numbers,\\n            vk.domain_size,\\n            vk.omega,\\n            state.z\\n        );\\n\\n        bool valid = verify_at_z(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.gate_selector_values_at_z[0]);\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.copy_grand_product_at_z_omega);\\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\\n\\n        state.v = transcript.get_challenge();\\n        transcript.update_with_g1(proof.opening_at_z_proof);\\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\\n        state.u = transcript.get_challenge();\\n\\n        return true;\\n    }\\n\\n    // This verifier is for a PLONK with a state width 4\\n    // and main gate equation\\n    // q_a(X) * a(X) +\\n    // q_b(X) * b(X) +\\n    // q_c(X) * c(X) +\\n    // q_d(X) * d(X) +\\n    // q_m(X) * a(X) * b(X) +\\n    // q_constants(X)+\\n    // q_d_next(X) * d(X*omega)\\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\\n    // q_d_next(X) \\\"peeks\\\" into the next row of the trace, so it takes\\n    // the same d(X) polynomial, but shifted\\n\\n    function aggregate_for_verification(Proof memory proof, VerificationKey memory vk)\\n        internal\\n        view\\n        returns (bool valid, PairingsBn254.G1Point[2] memory part)\\n    {\\n        PartialVerifierState memory state;\\n\\n        valid = verify_initial(state, proof, vk);\\n\\n        if (valid == false) {\\n            return (valid, part);\\n        }\\n\\n        part = aggregate_commitments(state, proof, vk);\\n\\n        (valid, part);\\n    }\\n\\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\\n        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        valid = PairingsBn254.pairingProd2(\\n            recursive_proof_part[0],\\n            PairingsBn254.P2(),\\n            recursive_proof_part[1],\\n            vk.g2_x\\n        );\\n\\n        return valid;\\n    }\\n\\n    function verify_recursive(\\n        Proof memory proof,\\n        VerificationKey memory vk,\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[16] memory subproofs_limbs\\n    ) internal view returns (bool) {\\n        (uint256 recursive_input, PairingsBn254.G1Point[2] memory aggregated_g1s) =\\n            reconstruct_recursive_public_input(\\n                recursive_vks_root,\\n                max_valid_index,\\n                recursive_vks_indexes,\\n                individual_vks_inputs,\\n                subproofs_limbs\\n            );\\n\\n        assert(recursive_input == proof.input_values[0]);\\n\\n        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        // aggregated_g1s = inner\\n        // recursive_proof_part = outer\\n        PairingsBn254.G1Point[2] memory combined = combine_inner_and_outer(aggregated_g1s, recursive_proof_part);\\n\\n        valid = PairingsBn254.pairingProd2(combined[0], PairingsBn254.P2(), combined[1], vk.g2_x);\\n\\n        return valid;\\n    }\\n\\n    function combine_inner_and_outer(PairingsBn254.G1Point[2] memory inner, PairingsBn254.G1Point[2] memory outer)\\n        internal\\n        view\\n        returns (PairingsBn254.G1Point[2] memory result)\\n    {\\n        // reuse the transcript primitive\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        transcript.update_with_g1(inner[0]);\\n        transcript.update_with_g1(inner[1]);\\n        transcript.update_with_g1(outer[0]);\\n        transcript.update_with_g1(outer[1]);\\n        PairingsBn254.Fr memory challenge = transcript.get_challenge();\\n        // 1 * inner + challenge * outer\\n        result[0] = PairingsBn254.copy_g1(inner[0]);\\n        result[1] = PairingsBn254.copy_g1(inner[1]);\\n        PairingsBn254.G1Point memory tmp = outer[0].point_mul(challenge);\\n        result[0].point_add_assign(tmp);\\n        tmp = outer[1].point_mul(challenge);\\n        result[1].point_add_assign(tmp);\\n\\n        return result;\\n    }\\n\\n    function reconstruct_recursive_public_input(\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[16] memory subproofs_aggregated\\n    ) internal pure returns (uint256 recursive_input, PairingsBn254.G1Point[2] memory reconstructed_g1s) {\\n        assert(recursive_vks_indexes.length == individual_vks_inputs.length);\\n        bytes memory concatenated = abi.encodePacked(recursive_vks_root);\\n        uint8 index;\\n        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {\\n            index = recursive_vks_indexes[i];\\n            assert(index <= max_valid_index);\\n            concatenated = abi.encodePacked(concatenated, index);\\n        }\\n        uint256 input;\\n        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {\\n            input = individual_vks_inputs[i];\\n            assert(input < r_mod);\\n            concatenated = abi.encodePacked(concatenated, input);\\n        }\\n\\n        concatenated = abi.encodePacked(concatenated, subproofs_aggregated);\\n\\n        bytes32 commitment = sha256(concatenated);\\n        recursive_input = uint256(commitment) & RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK;\\n\\n        reconstructed_g1s[0] = PairingsBn254.new_g1_checked(\\n            subproofs_aggregated[0] +\\n                (subproofs_aggregated[1] << LIMB_WIDTH) +\\n                (subproofs_aggregated[2] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[3] << (3 * LIMB_WIDTH)),\\n            subproofs_aggregated[4] +\\n                (subproofs_aggregated[5] << LIMB_WIDTH) +\\n                (subproofs_aggregated[6] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[7] << (3 * LIMB_WIDTH))\\n        );\\n\\n        reconstructed_g1s[1] = PairingsBn254.new_g1_checked(\\n            subproofs_aggregated[8] +\\n                (subproofs_aggregated[9] << LIMB_WIDTH) +\\n                (subproofs_aggregated[10] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[11] << (3 * LIMB_WIDTH)),\\n            subproofs_aggregated[12] +\\n                (subproofs_aggregated[13] << LIMB_WIDTH) +\\n                (subproofs_aggregated[14] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[15] << (3 * LIMB_WIDTH))\\n        );\\n\\n        return (recursive_input, reconstructed_g1s);\\n    }\\n}\\n\\ncontract VerifierWithDeserialize is Plonk4VerifierWithAccessToDNext {\\n    uint256 constant SERIALIZED_PROOF_LENGTH = 34;\\n\\n    function deserialize_proof(uint256[] memory public_inputs, uint256[] memory serialized_proof)\\n        internal\\n        pure\\n        returns (Proof memory proof)\\n    {\\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH);\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i++) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n\\n            j += 2;\\n        }\\n\\n        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j + 1]\\n        );\\n        j += 2;\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j + 1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {\\n            proof.gate_selector_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        proof.copy_grand_product_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n        j += 2;\\n\\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n    }\\n\\n    function verify_serialized_proof(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof,\\n        VerificationKey memory vk\\n    ) public view returns (bool) {\\n        require(vk.num_inputs == public_inputs.length);\\n\\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\\n\\n        bool valid = verify(proof, vk);\\n\\n        return valid;\\n    }\\n\\n    function verify_serialized_proof_with_recursion(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof,\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[16] memory subproofs_limbs,\\n        VerificationKey memory vk\\n    ) public view returns (bool) {\\n        require(vk.num_inputs == public_inputs.length);\\n\\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\\n\\n        bool valid =\\n            verify_recursive(\\n                proof,\\n                vk,\\n                recursive_vks_root,\\n                max_valid_index,\\n                recursive_vks_indexes,\\n                individual_vks_inputs,\\n                subproofs_limbs\\n            );\\n\\n        return valid;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Upgradeable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Interface of the upgradeable contract\\n/// @author Matter Labs\\ninterface Upgradeable {\\n    /// @notice Upgrades target of upgradeable contract\\n    /// @param newTarget New target\\n    /// @param newTargetInitializationParameters New target initialization parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/ZkSyncWithdrawalUnitTest.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\n\\nimport \\\"../ZkSync.sol\\\";\\n\\ncontract ZkSyncWithdrawalUnitTest is ZkSync {\\n    function setBalanceToWithdraw(\\n        address _owner,\\n        uint16 _token,\\n        uint128 _amount\\n    ) external {\\n        balancesToWithdraw[packAddressAndTokenId(_owner, _token)].balanceToWithdraw = _amount;\\n    }\\n\\n    function receiveETH() external payable {}\\n\\n    function withdrawOrStoreExternal(\\n        uint16 _tokenId,\\n        address _recipient,\\n        uint128 _amount\\n    ) external {\\n        return withdrawOrStore(_tokenId, _recipient, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/ZKSyncSignatureUnitTest.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\n\\n\\nimport \\\"../ZkSync.sol\\\";\\n\\ncontract ZKSyncSignatureUnitTest is ZkSync {\\n    function changePubkeySignatureCheck(\\n        bytes calldata _signature,\\n        bytes20 _newPkHash,\\n        uint32 _nonce,\\n        address _ethAddress,\\n        uint24 _accountId\\n    ) external pure returns (bool) {\\n        Operations.ChangePubKey memory changePk;\\n        changePk.owner = _ethAddress;\\n        changePk.nonce = _nonce;\\n        changePk.pubKeyHash = _newPkHash;\\n        changePk.accountId = _accountId;\\n        bytes memory witness = abi.encodePacked(bytes1(0x01), _signature, bytes32(0));\\n        return verifyChangePubkeyECRECOVER(witness, changePk);\\n    }\\n\\n    function testRecoverAddressFromEthSignature(bytes calldata _signature, bytes32 _messageHash)\\n        external\\n        pure\\n        returns (address)\\n    {\\n        return Utils.recoverAddressFromEthSignature(_signature, _messageHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/ZkSyncProcessOpUnitTest.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\n\\n\\nimport \\\"../ZkSync.sol\\\";\\n\\ncontract ZkSyncProcessOpUnitTest is ZkSync {\\n    function collectOnchainOpsExternal(\\n        CommitBlockInfo memory _newBlockData,\\n        bytes32 processableOperationsHash,\\n        uint64 priorityOperationsProcessed,\\n        bytes memory offsetsCommitment\\n    ) external {\\n        (bytes32 resOpHash, uint64 resPriorOps, bytes memory resOffsetsCommitment) = collectOnchainOps(_newBlockData);\\n        require(resOpHash == processableOperationsHash, \\\"hash\\\");\\n        require(resPriorOps == priorityOperationsProcessed, \\\"prop\\\");\\n        require(keccak256(resOffsetsCommitment) == keccak256(offsetsCommitment), \\\"offComm\\\");\\n    }\\n\\n    function commitPriorityRequests() external {\\n        totalCommittedPriorityRequests = totalOpenPriorityRequests;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/DummyTarget.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\nimport \\\"../Upgradeable.sol\\\";\\nimport \\\"../UpgradeableMaster.sol\\\";\\n\\ninterface DummyTarget {\\n    function get_DUMMY_INDEX() external pure returns (uint256);\\n\\n    function initialize(bytes calldata initializationParameters) external;\\n\\n    function upgrade(bytes calldata upgradeParameters) external;\\n\\n    function verifyPriorityOperation() external;\\n}\\n\\ncontract DummyFirst is UpgradeableMaster, DummyTarget {\\n    uint256 constant UPGRADE_NOTICE_PERIOD = 4;\\n\\n    function get_UPGRADE_NOTICE_PERIOD() external pure returns (uint256) {\\n        return UPGRADE_NOTICE_PERIOD;\\n    }\\n\\n    function getNoticePeriod() external pure override returns (uint256) {\\n        return UPGRADE_NOTICE_PERIOD;\\n    }\\n\\n    function upgradeNoticePeriodStarted() external override {}\\n\\n    function upgradePreparationStarted() external override {}\\n\\n    function upgradeCanceled() external override {}\\n\\n    function upgradeFinishes() external override {}\\n\\n    function isReadyForUpgrade() external view override returns (bool) {\\n        return totalVerifiedPriorityOperations() >= totalRegisteredPriorityOperations();\\n    }\\n\\n    uint256 private constant DUMMY_INDEX = 1;\\n\\n    function get_DUMMY_INDEX() external pure override returns (uint256) {\\n        return DUMMY_INDEX;\\n    }\\n\\n    uint64 _verifiedPriorityOperations;\\n\\n    function initialize(bytes calldata initializationParameters) external override {\\n        bytes32 byte_0 = bytes32(uint256(uint8(initializationParameters[0])));\\n        bytes32 byte_1 = bytes32(uint256(uint8(initializationParameters[1])));\\n        assembly {\\n            sstore(1, byte_0)\\n            sstore(2, byte_1)\\n        }\\n    }\\n\\n    function upgrade(bytes calldata upgradeParameters) external override {}\\n\\n    function totalVerifiedPriorityOperations() internal view returns (uint64) {\\n        return _verifiedPriorityOperations;\\n    }\\n\\n    function totalRegisteredPriorityOperations() internal pure returns (uint64) {\\n        return 1;\\n    }\\n\\n    function verifyPriorityOperation() external override {\\n        _verifiedPriorityOperations++;\\n    }\\n}\\n\\ncontract DummySecond is UpgradeableMaster, DummyTarget {\\n    uint256 constant UPGRADE_NOTICE_PERIOD = 4;\\n\\n    function get_UPGRADE_NOTICE_PERIOD() external pure returns (uint256) {\\n        return UPGRADE_NOTICE_PERIOD;\\n    }\\n\\n    function getNoticePeriod() external pure override returns (uint256) {\\n        return UPGRADE_NOTICE_PERIOD;\\n    }\\n\\n    function upgradeNoticePeriodStarted() external override {}\\n\\n    function upgradePreparationStarted() external override {}\\n\\n    function upgradeCanceled() external override {}\\n\\n    function upgradeFinishes() external override {}\\n\\n    function isReadyForUpgrade() external view override returns (bool) {\\n        return totalVerifiedPriorityOperations() >= totalRegisteredPriorityOperations();\\n    }\\n\\n    uint256 private constant DUMMY_INDEX = 2;\\n\\n    function get_DUMMY_INDEX() external pure override returns (uint256) {\\n        return DUMMY_INDEX;\\n    }\\n\\n    uint64 _verifiedPriorityOperations;\\n\\n    function initialize(bytes calldata) external pure override {\\n        revert(\\\"dsini\\\");\\n    }\\n\\n    function upgrade(bytes calldata upgradeParameters) external override {\\n        bytes32 byte_0 = bytes32(uint256(uint8(upgradeParameters[0])));\\n        bytes32 byte_1 = bytes32(uint256(uint8(upgradeParameters[1])));\\n        assembly {\\n            sstore(2, byte_0)\\n            sstore(3, byte_1)\\n        }\\n    }\\n\\n    function totalVerifiedPriorityOperations() internal view returns (uint64) {\\n        return _verifiedPriorityOperations;\\n    }\\n\\n    function totalRegisteredPriorityOperations() internal pure returns (uint64) {\\n        return 0;\\n    }\\n\\n    function verifyPriorityOperation() external override {\\n        _verifiedPriorityOperations++;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/OperationsTest.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\nimport \\\"../Operations.sol\\\";\\n\\ncontract OperationsTest {\\n    function testDeposit() external pure returns (uint256, uint256) {\\n        //        Operations.Deposit memory x =\\n        //            Operations.Deposit({\\n        //                accountId: 0,\\n        //                tokenId: 0x0102,\\n        //                amount: 0x101112131415161718191a1b1c1d1e1f,\\n        //                owner: 0x823B747710C5bC9b8A47243f2c3d1805F1aA00c5\\n        //            });\\n        //\\n        //        bytes memory pubdata = Operations.writeDepositPubdata(x);\\n        //        //require(pubdata.length == Operations.PackedFullExitPubdataBytes());\\n        //        Operations.Deposit memory r = Operations.readDepositPubdata(pubdata);\\n        //\\n        //        require(x.tokenId == r.tokenId, \\\"tokenId mismatch\\\");\\n        //        require(x.amount == r.amount, \\\"amount mismatch\\\");\\n        //        require(x.owner == r.owner, \\\"owner mismatch\\\");\\n    }\\n\\n    function testDepositMatch(bytes calldata offchain) external pure returns (bool) {\\n        //        Operations.Deposit memory x =\\n        //            Operations.Deposit({\\n        //                accountId: 0,\\n        //                tokenId: 0x0102,\\n        //                amount: 0x101112131415161718191a1b1c1d1e1f,\\n        //                owner: 0x823B747710C5bC9b8A47243f2c3d1805F1aA00c5\\n        //            });\\n        //        bytes memory onchain = Operations.writeDepositPubdata(x);\\n        //\\n        //        return Operations.depositPubdataMatch(onchain, offchain);\\n    }\\n\\n    function testFullExit() external pure {\\n        //        Operations.FullExit memory x =\\n        //            Operations.FullExit({\\n        //                accountId: 0x01020304,\\n        //                owner: 0x823B747710C5bC9b8A47243f2c3d1805F1aA00c5,\\n        //                tokenId: 0x3132,\\n        //                amount: 0x101112131415161718191a1b1c1d1e1f\\n        //            });\\n        //\\n        //        bytes memory pubdata = Operations.writeFullExitPubdata(x);\\n        //        //require(pubdata.length == Operations.PackedDepositPubdataBytes());\\n        //        Operations.FullExit memory r = Operations.readFullExitPubdata(pubdata);\\n        //\\n        //        require(x.accountId == r.accountId, \\\"accountId mismatch\\\");\\n        //        require(x.owner == r.owner, \\\"owner mismatch\\\");\\n        //        require(x.tokenId == r.tokenId, \\\"tokenId mismatch\\\");\\n        //        require(x.amount == r.amount, \\\"amount mismatch\\\");\\n    }\\n\\n    function testFullExitMatch(bytes calldata offchain) external pure returns (bool) {\\n        //        Operations.FullExit memory x =\\n        //            Operations.FullExit({\\n        //                accountId: 0x01020304,\\n        //                owner: 0x823B747710C5bC9b8A47243f2c3d1805F1aA00c5,\\n        //                tokenId: 0x3132,\\n        //                amount: 0\\n        //            });\\n        //        bytes memory onchain = Operations.writeFullExitPubdata(x);\\n        //\\n        //        return Operations.fullExitPubdataMatch(onchain, offchain);\\n    }\\n\\n    function writePartialExitPubdata(Operations.PartialExit memory op) internal pure returns (bytes memory buf) {\\n        //        buf = abi.encodePacked(\\n        //            uint8(Operations.OpType.PartialExit),\\n        //            bytes4(0), // accountId - ignored\\n        //            op.tokenId, // tokenId\\n        //            op.amount, // amount\\n        //            bytes2(0), // fee - ignored\\n        //            op.owner // owner\\n        //        );\\n    }\\n\\n    function testPartialExit() external pure {\\n        //        Operations.PartialExit memory x =\\n        //            Operations.PartialExit({\\n        //                tokenId: 0x3132,\\n        //                amount: 0x101112131415161718191a1b1c1d1e1f,\\n        //                owner: 0x823B747710C5bC9b8A47243f2c3d1805F1aA00c5\\n        //            });\\n        //\\n        //        bytes memory pubdata = writePartialExitPubdata(x);\\n        //        Operations.PartialExit memory r = Operations.readPartialExitPubdata(pubdata);\\n        //\\n        //        require(x.owner == r.owner, \\\"owner mismatch\\\");\\n        //        require(x.tokenId == r.tokenId, \\\"tokenId mismatch\\\");\\n        //        require(x.amount == r.amount, \\\"amount mismatch\\\");\\n    }\\n\\n    function writeForcedExitPubdata(Operations.ForcedExit memory op) internal pure returns (bytes memory buf) {\\n        //        buf = abi.encodePacked(\\n        //            uint8(Operations.OpType.ForcedExit),\\n        //            bytes4(0), // initator accountId - ignored\\n        //            bytes4(0), // target accountId - ignored\\n        //            op.tokenId, // tokenId\\n        //            op.amount, // amount\\n        //            bytes2(0), // fee - ignored\\n        //            op.target // owner\\n        //        );\\n    }\\n\\n    function testForcedExit() external pure {\\n        //        Operations.ForcedExit memory x =\\n        //            Operations.ForcedExit({\\n        //                target: 0x823B747710C5bC9b8A47243f2c3d1805F1aA00c5,\\n        //                tokenId: 0x3132,\\n        //                amount: 0x101112131415161718191a1b1c1d1e1f\\n        //            });\\n        //\\n        //        bytes memory pubdata = writeForcedExitPubdata(x);\\n        //        Operations.ForcedExit memory r = Operations.readForcedExitPubdata(pubdata);\\n        //\\n        //        require(x.target == r.target, \\\"target mismatch\\\");\\n        //        require(x.tokenId == r.tokenId, \\\"tokenId mismatch\\\");\\n        //        require(x.amount == r.amount, \\\"packed amount mismatch\\\");\\n    }\\n\\n    function parseDepositFromPubdata(bytes calldata _pubdata)\\n        external\\n        pure\\n        returns (\\n            uint16 tokenId,\\n            uint128 amount,\\n            address owner\\n        )\\n    {\\n        //        Operations.Deposit memory r = Operations.readDepositPubdata(_pubdata);\\n        //        return (r.tokenId, r.amount, r.owner);\\n    }\\n\\n    function parseFullExitFromPubdata(bytes calldata _pubdata)\\n        external\\n        pure\\n        returns (\\n            uint32 accountId,\\n            address owner,\\n            uint16 tokenId,\\n            uint128 amount\\n        )\\n    {\\n        //        Operations.FullExit memory r = Operations.readFullExitPubdata(_pubdata);\\n        //        accountId = r.accountId;\\n        //        owner = r.owner;\\n        //        tokenId = r.tokenId;\\n        //        amount = r.amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/DeployFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Governance.sol\\\";\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"./UpgradeGatekeeper.sol\\\";\\nimport \\\"./ZkSync.sol\\\";\\nimport \\\"./Verifier.sol\\\";\\nimport \\\"./TokenInit.sol\\\";\\n\\ncontract DeployFactory is TokenDeployInit {\\n    // Why do we deploy contracts in the constructor?\\n    //\\n    // If we want to deploy Proxy and UpgradeGatekeeper (using new) we have to deploy their contract code with this contract\\n    // in total deployment of this contract would cost us around 2.5kk of gas and calling final transaction\\n    // deployProxyContracts would cost around 3.5kk of gas(which is equivalent but slightly cheaper then doing deploy old way by sending\\n    // transactions one by one) but doing this in one method gives us simplicity and atomicity of our deployment.\\n    //\\n    // If we use selfdesctruction in the constructor then it removes overhead of deploying Proxy and UpgradeGatekeeper\\n    // with DeployFactory and in total this constructor would cost us around 3.5kk, so we got simplicity and atomicity of\\n    // deploy without overhead.\\n    //\\n    // `_feeAccountAddress` argument is not used by the constructor itself, but it's important to have this\\n    // information as a part of a transaction, since this transaction can be used for restoring the tree\\n    // state. By including this address to the list of arguments, we're making ourselves able to restore\\n    // genesis state, as the very first account in tree is a fee account, and we need its address before\\n    // we're able to start recovering the data from the Ethereum blockchain.\\n    constructor(\\n        Governance _govTarget,\\n        Verifier _verifierTarget,\\n        ZkSync _zkSyncTarget,\\n        bytes32 _genesisRoot,\\n        address _firstValidator,\\n        address _governor,\\n        address _feeAccountAddress\\n    ) {\\n        require(_firstValidator != address(0));\\n        require(_governor != address(0));\\n        require(_feeAccountAddress != address(0));\\n\\n        deployProxyContracts(_govTarget, _verifierTarget, _zkSyncTarget, _genesisRoot, _firstValidator, _governor);\\n\\n        selfdestruct(msg.sender);\\n    }\\n\\n    event Addresses(address governance, address zksync, address verifier, address gatekeeper);\\n\\n    function deployProxyContracts(\\n        Governance _governanceTarget,\\n        Verifier _verifierTarget,\\n        ZkSync _zksyncTarget,\\n        bytes32 _genesisRoot,\\n        address _validator,\\n        address _governor\\n    ) internal {\\n        Proxy governance = new Proxy(address(_governanceTarget), abi.encode(this));\\n        // set this contract as governor\\n        Proxy verifier = new Proxy(address(_verifierTarget), abi.encode());\\n        Proxy zkSync =\\n            new Proxy(address(_zksyncTarget), abi.encode(address(governance), address(verifier), _genesisRoot));\\n\\n        UpgradeGatekeeper upgradeGatekeeper = new UpgradeGatekeeper(zkSync);\\n\\n        governance.transferMastership(address(upgradeGatekeeper));\\n        upgradeGatekeeper.addUpgradeable(address(governance));\\n\\n        verifier.transferMastership(address(upgradeGatekeeper));\\n        upgradeGatekeeper.addUpgradeable(address(verifier));\\n\\n        zkSync.transferMastership(address(upgradeGatekeeper));\\n        upgradeGatekeeper.addUpgradeable(address(zkSync));\\n\\n        upgradeGatekeeper.transferMastership(_governor);\\n\\n        emit Addresses(address(governance), address(zkSync), address(verifier), address(upgradeGatekeeper));\\n\\n        finalizeGovernance(Governance(address(governance)), _validator, _governor);\\n    }\\n\\n    function finalizeGovernance(\\n        Governance _governance,\\n        address _validator,\\n        address _finalGovernor\\n    ) internal {\\n        address[] memory tokens = getTokens();\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            _governance.addToken(tokens[i]);\\n        }\\n        _governance.setValidator(_validator, true);\\n        _governance.changeGovernor(_finalGovernor);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Proxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./UpgradeableMaster.sol\\\";\\n\\n/// @title Proxy Contract\\n/// @dev NOTICE: Proxy must implement UpgradeableMaster interface to prevent calling some function of it not by master of proxy\\n/// @author Matter Labs\\ncontract Proxy is Upgradeable, UpgradeableMaster, Ownable {\\n    /// @dev Storage position of \\\"target\\\" (actual implementation address: keccak256('eip1967.proxy.implementation') - 1)\\n    bytes32 private constant targetPosition = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice Contract constructor\\n    /// @dev Calls Ownable contract constructor and initialize target\\n    /// @param target Initial implementation address\\n    /// @param targetInitializationParameters Target initialization parameters\\n    constructor(address target, bytes memory targetInitializationParameters) Ownable(msg.sender) {\\n        setTarget(target);\\n        (bool initializationSuccess, ) =\\n            getTarget().delegatecall(abi.encodeWithSignature(\\\"initialize(bytes)\\\", targetInitializationParameters));\\n        require(initializationSuccess, \\\"uin11\\\"); // uin11 - target initialization failed\\n    }\\n\\n    /// @notice Intercepts initialization calls\\n    function initialize(bytes calldata) external pure {\\n        revert(\\\"ini11\\\"); // ini11 - interception of initialization call\\n    }\\n\\n    /// @notice Intercepts upgrade calls\\n    function upgrade(bytes calldata) external pure {\\n        revert(\\\"upg11\\\"); // upg11 - interception of upgrade call\\n    }\\n\\n    /// @notice Returns target of contract\\n    /// @return target Actual implementation address\\n    function getTarget() public view returns (address target) {\\n        bytes32 position = targetPosition;\\n        assembly {\\n            target := sload(position)\\n        }\\n    }\\n\\n    /// @notice Sets new target of contract\\n    /// @param _newTarget New actual implementation address\\n    function setTarget(address _newTarget) internal {\\n        bytes32 position = targetPosition;\\n        assembly {\\n            sstore(position, _newTarget)\\n        }\\n    }\\n\\n    /// @notice Upgrades target\\n    /// @param newTarget New target\\n    /// @param newTargetUpgradeParameters New target upgrade parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetUpgradeParameters) external override {\\n        requireMaster(msg.sender);\\n\\n        setTarget(newTarget);\\n        (bool upgradeSuccess, ) =\\n            getTarget().delegatecall(abi.encodeWithSignature(\\\"upgrade(bytes)\\\", newTargetUpgradeParameters));\\n        require(upgradeSuccess, \\\"ufu11\\\"); // ufu11 - target upgrade failed\\n    }\\n\\n    /// @notice Performs a delegatecall to the contract implementation\\n    /// @dev Fallback function allowing to perform a delegatecall to the given implementation\\n    /// This function will return whatever the implementation call returns\\n    function _fallback() internal {\\n        address _target = getTarget();\\n        assembly {\\n            // The pointer to the free memory slot\\n            let ptr := mload(0x40)\\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\\n            calldatacopy(ptr, 0x0, calldatasize())\\n            // Delegatecall method of the implementation contract, returns 0 on error\\n            let result := delegatecall(gas(), _target, ptr, calldatasize(), 0x0, 0)\\n            // Get the size of the last return data\\n            let size := returndatasize()\\n            // Copy the size length of bytes from return data at zero position to pointer position\\n            returndatacopy(ptr, 0x0, size)\\n            // Depending on result value\\n            switch result\\n                case 0 {\\n                    // End execution and revert state changes\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    // Return data with length of size at pointers position\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n\\n    /// @notice Will run when no functions matches call data\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    /// @notice Same as fallback but called when calldata is empty\\n    receive() external payable {\\n        _fallback();\\n    }\\n\\n    /// UpgradeableMaster functions\\n\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external override returns (uint256) {\\n        (bool success, bytes memory result) = getTarget().delegatecall(abi.encodeWithSignature(\\\"getNoticePeriod()\\\"));\\n        require(success, \\\"unp11\\\"); // unp11 - upgradeNoticePeriod delegatecall failed\\n        return abi.decode(result, (uint256));\\n    }\\n\\n    /// @notice Notifies proxy contract that notice period started\\n    function upgradeNoticePeriodStarted() external override {\\n        requireMaster(msg.sender);\\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\\\"upgradeNoticePeriodStarted()\\\"));\\n        require(success, \\\"nps11\\\"); // nps11 - upgradeNoticePeriodStarted delegatecall failed\\n    }\\n\\n    /// @notice Notifies proxy contract that upgrade preparation status is activated\\n    function upgradePreparationStarted() external override {\\n        requireMaster(msg.sender);\\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\\\"upgradePreparationStarted()\\\"));\\n        require(success, \\\"ups11\\\"); // ups11 - upgradePreparationStarted delegatecall failed\\n    }\\n\\n    /// @notice Notifies proxy contract that upgrade canceled\\n    function upgradeCanceled() external override {\\n        requireMaster(msg.sender);\\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\\\"upgradeCanceled()\\\"));\\n        require(success, \\\"puc11\\\"); // puc11 - upgradeCanceled delegatecall failed\\n    }\\n\\n    /// @notice Notifies proxy contract that upgrade finishes\\n    function upgradeFinishes() external override {\\n        requireMaster(msg.sender);\\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\\\"upgradeFinishes()\\\"));\\n        require(success, \\\"puf11\\\"); // puf11 - upgradeFinishes delegatecall failed\\n    }\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external override returns (bool) {\\n        (bool success, bytes memory result) = getTarget().delegatecall(abi.encodeWithSignature(\\\"isReadyForUpgrade()\\\"));\\n        require(success, \\\"rfu11\\\"); // rfu11 - readyForUpgrade delegatecall failed\\n        return abi.decode(result, (bool));\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/UpgradeGatekeeper.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Events.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./UpgradeableMaster.sol\\\";\\n\\n/// @title Upgrade Gatekeeper Contract\\n/// @author Matter Labs\\ncontract UpgradeGatekeeper is UpgradeEvents, Ownable {\\n    using SafeMath for uint256;\\n\\n    /// @notice Array of addresses of upgradeable contracts managed by the gatekeeper\\n    Upgradeable[] public managedContracts;\\n\\n    /// @notice Upgrade mode statuses\\n    enum UpgradeStatus {Idle, NoticePeriod, Preparation}\\n\\n    UpgradeStatus public upgradeStatus;\\n\\n    /// @notice Notice period finish timestamp (as seconds since unix epoch)\\n    /// @dev Will be equal to zero in case of not active upgrade mode\\n    uint256 public noticePeriodFinishTimestamp;\\n\\n    /// @notice Addresses of the next versions of the contracts to be upgraded (if element of this array is equal to zero address it means that appropriate upgradeable contract wouldn't be upgraded this time)\\n    /// @dev Will be empty in case of not active upgrade mode\\n    address[] public nextTargets;\\n\\n    /// @notice Version id of contracts\\n    uint256 public versionId;\\n\\n    /// @notice Contract which defines notice period duration and allows finish upgrade during preparation of it\\n    UpgradeableMaster public mainContract;\\n\\n    /// @notice Contract constructor\\n    /// @param _mainContract Contract which defines notice period duration and allows finish upgrade during preparation of it\\n    /// @dev Calls Ownable contract constructor\\n    constructor(UpgradeableMaster _mainContract) Ownable(msg.sender) {\\n        mainContract = _mainContract;\\n        versionId = 0;\\n    }\\n\\n    /// @notice Adds a new upgradeable contract to the list of contracts managed by the gatekeeper\\n    /// @param addr Address of upgradeable contract to add\\n    function addUpgradeable(address addr) external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.Idle, \\\"apc11\\\"); /// apc11 - upgradeable contract can't be added during upgrade\\n\\n        managedContracts.push(Upgradeable(addr));\\n        emit NewUpgradable(versionId, addr);\\n    }\\n\\n    /// @notice Starts upgrade (activates notice period)\\n    /// @param newTargets New managed contracts targets (if element of this array is equal to zero address it means that appropriate upgradeable contract wouldn't be upgraded this time)\\n    function startUpgrade(address[] calldata newTargets) external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.Idle, \\\"spu11\\\"); // spu11 - unable to activate active upgrade mode\\n        require(newTargets.length == managedContracts.length, \\\"spu12\\\"); // spu12 - number of new targets must be equal to the number of managed contracts\\n\\n        uint256 noticePeriod = mainContract.getNoticePeriod();\\n        mainContract.upgradeNoticePeriodStarted();\\n        upgradeStatus = UpgradeStatus.NoticePeriod;\\n        noticePeriodFinishTimestamp = block.timestamp.add(noticePeriod);\\n        nextTargets = newTargets;\\n        emit NoticePeriodStart(versionId, newTargets, noticePeriod);\\n    }\\n\\n    /// @notice Cancels upgrade\\n    function cancelUpgrade() external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus != UpgradeStatus.Idle, \\\"cpu11\\\"); // cpu11 - unable to cancel not active upgrade mode\\n\\n        mainContract.upgradeCanceled();\\n        upgradeStatus = UpgradeStatus.Idle;\\n        noticePeriodFinishTimestamp = 0;\\n        delete nextTargets;\\n        emit UpgradeCancel(versionId);\\n    }\\n\\n    /// @notice Activates preparation status\\n    /// @return Bool flag indicating that preparation status has been successfully activated\\n    function startPreparation() external returns (bool) {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.NoticePeriod, \\\"ugp11\\\"); // ugp11 - unable to activate preparation status in case of not active notice period status\\n\\n        if (block.timestamp >= noticePeriodFinishTimestamp) {\\n            upgradeStatus = UpgradeStatus.Preparation;\\n            mainContract.upgradePreparationStarted();\\n            emit PreparationStart(versionId);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /// @notice Finishes upgrade\\n    /// @param targetsUpgradeParameters New targets upgrade parameters per each upgradeable contract\\n    function finishUpgrade(bytes[] calldata targetsUpgradeParameters) external {\\n        requireMaster(msg.sender);\\n        require(upgradeStatus == UpgradeStatus.Preparation, \\\"fpu11\\\"); // fpu11 - unable to finish upgrade without preparation status active\\n        require(targetsUpgradeParameters.length == managedContracts.length, \\\"fpu12\\\"); // fpu12 - number of new targets upgrade parameters must be equal to the number of managed contracts\\n        require(mainContract.isReadyForUpgrade(), \\\"fpu13\\\"); // fpu13 - main contract is not ready for upgrade\\n        mainContract.upgradeFinishes();\\n\\n        for (uint64 i = 0; i < managedContracts.length; i++) {\\n            address newTarget = nextTargets[i];\\n            if (newTarget != address(0)) {\\n                managedContracts[i].upgradeTarget(newTarget, targetsUpgradeParameters[i]);\\n            }\\n        }\\n        versionId++;\\n        emit UpgradeComplete(versionId, nextTargets);\\n\\n        upgradeStatus = UpgradeStatus.Idle;\\n        noticePeriodFinishTimestamp = 0;\\n        delete nextTargets;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/TokenInit.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\ncontract TokenDeployInit {\\n    function getTokens() internal pure returns (address[] memory) {\\n        address[] memory tokens = new address[](16);\\n        tokens[0] = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n        tokens[1] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n        tokens[2] = 0x0000000000085d4780B73119b644AE5ecd22b376;\\n        tokens[3] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n        tokens[4] = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\\n        tokens[5] = 0x4Fabb145d64652a948d72533023f6E7A623C7C53;\\n        tokens[6] = 0x80fB784B7eD66730e8b1DBd9820aFD29931aab03;\\n        tokens[7] = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;\\n        tokens[8] = 0xdd974D5C2e2928deA5F71b9825b8b646686BD200;\\n        tokens[9] = 0x514910771AF9Ca656af840dff83E8264EcF986CA;\\n        tokens[10] = 0x0F5D2fB29fb7d3CFeE444a200298f468908cC942;\\n        tokens[11] = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\\n        tokens[12] = 0x1985365e9f78359a9B6AD760e32412f4a445E862;\\n        tokens[13] = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\\n        tokens[14] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n        tokens[15] = 0xE41d2489571d322189246DaFA5ebDe1F4699F498;\\n        return tokens;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Ownable Contract\\n/// @author Matter Labs\\ncontract Ownable {\\n    /// @dev Storage position of the masters address (keccak256('eip1967.proxy.admin') - 1)\\n    bytes32 private constant masterPosition = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice Contract constructor\\n    /// @dev Sets msg sender address as masters address\\n    /// @param masterAddress Master address\\n    constructor(address masterAddress) {\\n        setMaster(masterAddress);\\n    }\\n\\n    /// @notice Check if specified address is master\\n    /// @param _address Address to check\\n    function requireMaster(address _address) internal view {\\n        require(_address == getMaster(), \\\"oro11\\\"); // oro11 - only by master\\n    }\\n\\n    /// @notice Returns contract masters address\\n    /// @return master Master's address\\n    function getMaster() public view returns (address master) {\\n        bytes32 position = masterPosition;\\n        assembly {\\n            master := sload(position)\\n        }\\n    }\\n\\n    /// @dev Sets new masters address\\n    /// @param _newMaster New master's address\\n    function setMaster(address _newMaster) internal {\\n        bytes32 position = masterPosition;\\n        assembly {\\n            sstore(position, _newMaster)\\n        }\\n    }\\n\\n    /// @notice Transfer mastership of the contract to new master\\n    /// @param _newMaster New masters address\\n    function transferMastership(address _newMaster) external {\\n        requireMaster(msg.sender);\\n        require(_newMaster != address(0), \\\"otp11\\\"); // otp11 - new masters address can't be zero address\\n        setMaster(_newMaster);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/tokens/MintableERC20NoTransferReturnValueTest.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\nimport \\\"./ContextTest.sol\\\";\\nimport \\\"./MintableIERC20NoTransferReturnValueTest.sol\\\";\\nimport \\\"../../SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract MintableERC20NoTransferReturnValueTest is ContextTest, MintableIERC20NoTransferReturnValueTest {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    function mint(address to, uint256 amount) external override {\\n        _mint(to, amount);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public override {\\n        _transfer(_msgSender(), recipient, amount);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\")\\n        );\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\")\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(\\n            account,\\n            _msgSender(),\\n            _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\")\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/tokens/ContextTest.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextTest {\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/tokens/MintableIERC20NoTransferReturnValueTest.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface MintableIERC20NoTransferReturnValueTest {\\n    function mint(address to, uint256 amount) external;\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external;\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/tokens/MintableERC20FeeAndDividendsTest.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\nimport \\\"./ContextTest.sol\\\";\\nimport \\\"./MintableIERC20Test.sol\\\";\\nimport \\\"../../SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract MintableERC20FeeAndDividendsTest is ContextTest, MintableIERC20Test {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    function mint(address to, uint256 amount) external override {\\n        _mint(to, amount);\\n    }\\n\\n    bool _shouldBeFeeTransfers;\\n    bool _senderUnintuitiveProcess;\\n\\n    uint256 public FEE_AMOUNT_AS_VALUE = 15;\\n    uint256 public DIVIDEND_AMOUNT_AS_VALUE = 7;\\n\\n    /// shouldBeFeeTransfers - true if there is should be taken fee, false if there should be dividends\\n    /// senderUnintuitiveProcess - true if there is should be taken fee from sender (or dividends for him), false if this process works with recipient\\n    constructor(bool shouldBeFeeTransfers, bool senderUnintuitiveProcess) {\\n        _shouldBeFeeTransfers = shouldBeFeeTransfers;\\n        _senderUnintuitiveProcess = senderUnintuitiveProcess;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\")\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\")\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n\\n        if (_shouldBeFeeTransfers) {\\n            require(FEE_AMOUNT_AS_VALUE <= amount, \\\"tet10\\\"); // tet10 - fee is bigger than transfer amount\\n            if (_senderUnintuitiveProcess) {\\n                _burn(sender, FEE_AMOUNT_AS_VALUE);\\n            } else {\\n                _burn(recipient, FEE_AMOUNT_AS_VALUE);\\n            }\\n        } else {\\n            if (_senderUnintuitiveProcess) {\\n                _mint(sender, DIVIDEND_AMOUNT_AS_VALUE);\\n            } else {\\n                _mint(recipient, DIVIDEND_AMOUNT_AS_VALUE);\\n            }\\n        }\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(\\n            account,\\n            _msgSender(),\\n            _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\")\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/dev-contracts/tokens/MintableIERC20Test.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface MintableIERC20Test {\\n    function mint(address to, uint256 amount) external;\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"NewGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"NewToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"TokenPausedUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"ValidatorStatusUpdate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initializationParameters\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"isValidTokenId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"pausedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"requireActiveValidator\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"requireGovernor\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_tokenPaused\",\"type\":\"bool\"}],\"name\":\"setTokenPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"tokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenIds\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"upgradeParameters\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"validateTokenAddress\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Governance","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}