{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.12;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        require(b > 0);\r\n        uint c = a / b;\r\n        require(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint a, uint b) internal pure returns (uint) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n\r\ninterface ISupplyController {\r\n\tfunction mint(address token, address owner, uint amount) external;\r\n}\r\n\r\ninterface IADXToken {\r\n\tfunction transfer(address to, uint256 amount) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\tfunction balanceOf(address spender) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\tfunction supplyController() external view returns (ISupplyController);\r\n}\r\n\r\ncontract ADXLoyaltyPoolToken {\r\n\tusing SafeMath for uint;\r\n\r\n\t// ERC20 stuff\r\n\t// Constants\r\n\tstring public constant name = \"AdEx Loyalty\";\r\n\tuint8 public constant decimals = 18;\r\n\tstring public symbol = \"ADX-LOYALTY\";\r\n\r\n\t// Mutable variables\r\n\tuint public totalSupply;\r\n\tmapping(address => uint) balances;\r\n\tmapping(address => mapping(address => uint)) allowed;\r\n\r\n\t// EIP 2612\r\n\tbytes32 public DOMAIN_SEPARATOR;\r\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\tmapping(address => uint) public nonces;\r\n\r\n\t// ERC20 events\r\n\tevent Approval(address indexed owner, address indexed spender, uint amount);\r\n\tevent Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n\tfunction balanceOf(address owner) external view returns (uint balance) {\r\n\t\treturn balances[owner];\r\n\t}\r\n\r\n\tfunction transfer(address to, uint amount) external returns (bool success) {\r\n\t\trequire(to != address(this), 'BAD_ADDRESS');\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(amount);\r\n\t\tbalances[to] = balances[to].add(amount);\r\n\t\temit Transfer(msg.sender, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address from, address to, uint amount) external returns (bool success) {\r\n\t\tbalances[from] = balances[from].sub(amount);\r\n\t\tallowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\r\n\t\tbalances[to] = balances[to].add(amount);\r\n\t\temit Transfer(from, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approve(address spender, uint amount) external returns (bool success) {\r\n\t\tallowed[msg.sender][spender] = amount;\r\n\t\temit Approval(msg.sender, spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowance(address owner, address spender) external view returns (uint remaining) {\r\n\t\treturn allowed[owner][spender];\r\n\t}\r\n\r\n\t// EIP 2612\r\n\tfunction permit(address owner, address spender, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n\t\trequire(deadline >= block.timestamp, 'DEADLINE_EXPIRED');\r\n\t\tbytes32 digest = keccak256(abi.encodePacked(\r\n\t\t\t'\\x19\\x01',\r\n\t\t\tDOMAIN_SEPARATOR,\r\n\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline))\r\n\t\t));\r\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\r\n\t\trequire(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\r\n\t\tallowed[owner][spender] = amount;\r\n\t\temit Approval(owner, spender, amount);\r\n\t}\r\n\r\n\t// Inner\r\n\tfunction innerMint(address owner, uint amount) internal {\r\n\t\ttotalSupply = totalSupply.add(amount);\r\n\t\tbalances[owner] = balances[owner].add(amount);\r\n\t\t// Because of https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\r\n\t\temit Transfer(address(0), owner, amount);\r\n\t}\r\n\tfunction innerBurn(address owner, uint amount) internal {\r\n\t\ttotalSupply = totalSupply.sub(amount);\r\n\t\tbalances[owner] = balances[owner].sub(amount);\r\n\t\temit Transfer(owner, address(0), amount);\r\n\t}\r\n\r\n\r\n\t// Pool functionality\r\n\tevent LogSetGovernance(address indexed addr, bool hasGovt, uint time);\r\n\tevent LogSetIncentive(uint incentive, uint time);\r\n\r\n\tIADXToken public ADXToken;\r\n\tuint public incentivePerTokenPerAnnum;\r\n\tuint public lastMintTime;\r\n\tuint public maxTotalADX;\r\n\tmapping (address => bool) public governance;\r\n\tconstructor(IADXToken token, uint incentive, uint cap) public {\r\n\t\tADXToken = token;\r\n\t\tincentivePerTokenPerAnnum = incentive;\r\n\t\tmaxTotalADX = cap;\r\n\t\tgovernance[msg.sender] = true;\r\n\t\tlastMintTime = block.timestamp;\r\n\t\t// EIP 2612\r\n\t\tuint chainId;\r\n\t\tassembly {\r\n\t\t\tchainId := chainid()\r\n\t\t}\r\n\t\tDOMAIN_SEPARATOR = keccak256(\r\n\t\t\tabi.encode(\r\n\t\t\t\tkeccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n\t\t\t\tkeccak256(bytes(name)),\r\n\t\t\t\tkeccak256(bytes('1')),\r\n\t\t\t\tchainId,\r\n\t\t\t\taddress(this)\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t\temit LogSetGovernance(msg.sender, true, block.timestamp);\r\n\t\temit LogSetIncentive(incentive, block.timestamp);\r\n\t}\r\n\r\n\t// Governance functions\r\n\tfunction setGovernance(address addr, bool hasGovt) external {\r\n\t\trequire(governance[msg.sender], 'NOT_GOVERNANCE');\r\n\t\tgovernance[addr] = hasGovt;\r\n\t\temit LogSetGovernance(addr, hasGovt, block.timestamp);\r\n\t}\r\n\t// This doesn't trigger a mint because otherwise we risk of being unable to setIncentive to 0\r\n\t// if minting is impossible\r\n\t// It's the better tradeoff to make - and the issue of front-running mintIncnetive with setIncentive(0) can\r\n\t// be solved by timelocking the governance\r\n\tfunction setIncentive(uint newIncentive) external {\r\n\t\trequire(governance[msg.sender], 'NOT_GOVERNANCE');\r\n\t\tincentivePerTokenPerAnnum = newIncentive;\r\n\t\tlastMintTime = block.timestamp;\r\n\t\temit LogSetIncentive(newIncentive, block.timestamp);\r\n\t}\r\n\tfunction setSymbol(string calldata newSymbol) external {\r\n\t\trequire(governance[msg.sender], 'NOT_GOVERNANCE');\r\n\t\tsymbol = newSymbol;\r\n\t}\r\n\tfunction setMaxTotalADX(uint newMaxTotalADX) external {\r\n\t\trequire(governance[msg.sender], 'NOT_GOVERNANCE');\r\n\t\tmaxTotalADX = newMaxTotalADX;\r\n\t}\r\n\r\n\r\n\t// Pool stuff\r\n\t// There are a few notable items in how minting works\r\n\t// 1) if ADX is sent to the LoyaltyPool in-between mints, it will calculate the incentive as if this amount\r\n\t// has been there the whole time since the last mint\r\n\t// 2) Compounding is happening when mint is called, so essentially when entities enter/leave/trigger it manually\r\n\tfunction toMint() external view returns (uint) {\r\n\t\tif (block.timestamp <= lastMintTime) return 0;\r\n\t\tuint totalADX = ADXToken.balanceOf(address(this));\r\n\t\treturn (block.timestamp - lastMintTime)\r\n\t\t\t.mul(totalADX)\r\n\t\t\t.mul(incentivePerTokenPerAnnum)\r\n\t\t\t.div(365 days * 10e17);\r\n\t}\r\n\r\n\tfunction shareValue() external view returns (uint) {\r\n\t\tif (totalSupply == 0) return 0;\r\n\t\treturn ADXToken.balanceOf(address(this))\r\n\t\t\t.add(this.toMint())\r\n\t\t\t.mul(10e17)\r\n\t\t\t.div(totalSupply);\r\n\t}\r\n\r\n\tfunction mintIncentive() public {\r\n\t\tif (incentivePerTokenPerAnnum == 0) return;\r\n\t\tuint amountToMint = this.toMint();\r\n\t\tif (amountToMint == 0) return;\r\n\t\tlastMintTime = block.timestamp;\r\n\t\tADXToken.supplyController().mint(address(ADXToken), address(this), amountToMint);\r\n\t}\r\n\r\n\tfunction enter(uint256 amount) external {\r\n\t\t// Please note that minting has to be in the beginning so that we take it into account\r\n\t\t// when using ADXToken.balanceOf()\r\n\t\t// Minting makes an external call but it's to a trusted contract (ADXToken)\r\n\t\tmintIncentive();\r\n\r\n\t\tuint totalADX = ADXToken.balanceOf(address(this));\r\n\t\trequire(totalADX.add(amount) <= maxTotalADX, 'REACHED_MAX_TOTAL_ADX');\r\n\r\n\t\t// The totalADX == 0 check here should be redudnant; the only way to get totalSupply to a nonzero val is by adding ADX\r\n\t\tif (totalSupply == 0 || totalADX == 0) {\r\n\t\t\tinnerMint(msg.sender, amount);\r\n\t\t} else {\r\n\t\t\tuint256 newShares = amount.mul(totalSupply).div(totalADX);\r\n\t\t\tinnerMint(msg.sender, newShares);\r\n\t\t}\r\n\t\trequire(ADXToken.transferFrom(msg.sender, address(this), amount));\r\n\t}\r\n\r\n\tfunction leaveInner(uint256 shares) internal {\r\n\t\tuint256 totalADX = ADXToken.balanceOf(address(this));\r\n\t\tuint256 adxAmount = shares.mul(totalADX).div(totalSupply);\r\n\t\tinnerBurn(msg.sender, shares);\r\n\t\trequire(ADXToken.transfer(msg.sender, adxAmount));\r\n\t}\r\n\r\n\tfunction leave(uint256 shares) external {\r\n\t\tmintIncentive();\r\n\t\tleaveInner(shares);\r\n\t}\r\n\r\n\t// Guarantees ADX can be taken out even if minting is failing\r\n\tfunction emergencyLeave(uint256 shares) external {\r\n\t\tleaveInner(shares);\r\n\t}\r\n}\r\n\r\ninterface IChainlinkSimple {\r\n\tfunction latestAnswer() external view returns (uint);\r\n}\r\n\r\n// NOTE: If this needs to be upgraded, we just deploy a new instance and remove the governance rights\r\n// of the old instance and set rights for the new instance\r\ncontract ADXLoyaltyPoolIncentiveController {\r\n\tIChainlinkSimple public constant ADXUSDOracle = IChainlinkSimple(0x231e764B44b2C1b7Ca171fa8021A24ed520Cde10);\r\n\tADXLoyaltyPoolToken public immutable loyaltyPool;\r\n\tconstructor(ADXLoyaltyPoolToken lpt) public {\r\n\t\tloyaltyPool = lpt;\r\n\t}\r\n\r\n\tfunction adjustIncentive() external {\r\n\t\t// Mint the current incurred incentive before changing the rate,\r\n\t\t// otherwise new rate would be applied for the entire period since the last mint\r\n\t\tloyaltyPool.mintIncentive();\r\n\r\n\t\t// At some point we might enable bonus periods:\r\n\t\t// if (block.timestamp < ...) { ... }\r\n\t\t// Or overinflation protection\r\n\t\t// if (loyaltyPool.ADXToken().totalSupply() > ...) { ... }\r\n\r\n\t\t// Reset the rate based on the price from the Chainlink oracle\r\n\t\tuint price = ADXUSDOracle.latestAnswer();\r\n\t\trequire(price > 0, 'INVALID_ANSWER');\r\n\t\tif (price < 0.05*10**8) {\r\n\t\t\tloyaltyPool.setIncentive(uint(0.10*10**18));\r\n\t\t} else if (price < 0.10*10**8) {\r\n\t\t\tloyaltyPool.setIncentive(uint(0.15*10**18));\r\n\t\t} else if (price < 0.20*10**8) {\r\n\t\t\tloyaltyPool.setIncentive(uint(0.25*10**18));\r\n\t\t} else if (price < 0.30*10**8) {\r\n\t\t\tloyaltyPool.setIncentive(uint(0.30*10**18));\r\n\t\t} else if (price < 0.50*10**8) {\r\n\t\t\tloyaltyPool.setIncentive(uint(0.35*10**18));\r\n\t\t} else if (price < 1.00*10**8) {\r\n\t\t\tloyaltyPool.setIncentive(uint(0.40*10**18));\r\n\t\t} else if (price < 2.00*10**8) {\r\n\t\t\tloyaltyPool.setIncentive(uint(0.45*10**18));\r\n\t\t} else {\r\n\t\t\tloyaltyPool.setIncentive(uint(0.50*10**18));\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ADXLoyaltyPoolToken\",\"name\":\"lpt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ADXUSDOracle\",\"outputs\":[{\"internalType\":\"contract IChainlinkSimple\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adjustIncentive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loyaltyPool\",\"outputs\":[{\"internalType\":\"contract ADXLoyaltyPoolToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ADXLoyaltyPoolIncentiveController","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d9a4cb9dc9296e111c66dfacab8be034ee2e1c2c","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7baa2a40166f5f93bd87c0d9ab0359588341117f92142421b025d5221243a91c"}]}