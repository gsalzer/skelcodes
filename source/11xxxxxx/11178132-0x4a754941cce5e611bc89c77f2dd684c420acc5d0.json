{"status":"1","message":"OK","result":[{"SourceCode":"{\"ownable.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\ncontract Owned is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"vaultHelper.sol\":{\"content\":\"//////////////////////////////////////////////////\\n//SYNLEV Vault Helper contract V 1.0.0\\n//////////////////////////\\n\\npragma solidity \\u003e= 0.6.6;\\n\\nimport \\u0027./ownable.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./vaultInterface.sol\\u0027;\\n\\ncontract vaultHelper is Owned {\\n  using SafeMath for uint256;\\n\\n  constructor() public {\\n    balanceControlFactor = 10**9;\\n  }\\n\\n  uint256 public balanceControlFactor;\\n\\n  /*\\n   * @notice Returns the buy bonus based on the incoming ETH and selected token.\\n   * Only relevant to token buys\\n   * @param token The selected bull or bear token\\n   * @param eth The amount of ETH to be added\\n   * @return Bonus in ETH\\n   */\\n  function getBonus(address vault, address token, uint256 eth)\\n  public\\n  view\\n  returns(uint256)\\n  {\\n    vaultInterface ivault = vaultInterface(vault);\\n    //Grab total equity of both tokens\\n    uint256 totaleth0 = ivault.getTotalEquity();\\n    //Grab total equity of only target token\\n    uint256 tokeneth0 = ivault.getTokenEquity(token);\\n    uint256 balanceEquity = ivault.getBalanceEquity();\\n    //Check if we need to calc a bonus\\n    if(balanceEquity \\u003e 0 \\u0026\\u0026 totaleth0 \\u003e tokeneth0.mul(2)) {\\n      //Current ratio of token equity to total equity\\n      uint256 ratio0 = tokeneth0.mul(1 ether).div(totaleth0);\\n      //Ratio of token equity to total equity after buy\\n      uint256 ratio1 = tokeneth0.add(eth).mul(1 ether).div(totaleth0.add(eth));\\n      //If the after buy ratio is grater than .5 (50%) we reward the entire\\n      //balance equity\\n      return(\\n        ratio1 \\u003c= 5 * 10**17 ?\\n        ratio1.sub(ratio0).mul(1 ether).div(5 * 10**17 - ratio0).mul(balanceEquity).div(1 ether) :\\n        balanceEquity\\n      );\\n    }\\n    else {\\n      return(0);\\n    }\\n  }\\n\\n  /*\\n   * @notice Returns the sell penalty based on the outgoing ETH and selected\\n   * token. Only relevant to token sells.\\n   * @param token The selected bull or bear token\\n   * @param eth The amount of outgoing ETH\\n   * @return Penalty in ETH\\n   */\\n  function getPenalty(address vault, address token, uint256 eth)\\n  public\\n  view\\n  returns(uint256)\\n  {\\n    vaultInterface ivault = vaultInterface(vault);\\n    //Grab total equity of both tokens\\n    uint256 totaleth0 = ivault.getTotalEquity();\\n    //Grab total equity of only target token\\n    uint256 tokeneth0 = ivault.getTokenEquity(token);\\n    //Calc target token equity after sell\\n    uint256 tokeneth1 = tokeneth0.sub(eth);\\n    //Only calc penalty if ratio is less than .5 (50%) after token sell\\n    if(totaleth0.div(2) \\u003e= tokeneth1) {\\n      //Current ratio of token equity to total equity\\n      uint256 ratio0 = tokeneth0.mul(1 ether).div(totaleth0);\\n      //Ratio of token equity to total equity after buy\\n      uint256 ratio1 = tokeneth1.mul(1 ether).div(totaleth0.sub(eth));\\n      return(balanceControlFactor.mul(ratio0.sub(ratio1).div(2)).mul(eth).div(10**9).div(1 ether));\\n    }\\n    else {\\n      return(0);\\n    }\\n  }\\n\\n  /*\\n   * @notice Returns the current LP share price. Defaults to 1 ETH if 0 LP\\n   * @param token The selected bull or bear token\\n   * @param eth The amount of outgoing ETH\\n   * @return Penalty in ETH\\n   */\\n  function getSharePrice(address vault)\\n  public\\n  view\\n  returns(uint256)\\n  {\\n    vaultInterface ivault = vaultInterface(vault);\\n    address bull = ivault.getBullToken();\\n    address bear = ivault.getBearToken();\\n    if(ivault.getTotalLiqShares() == 0) {\\n      return(1 ether);\\n    }\\n    else {\\n      return(\\n        ivault.getLiqEquity(bull)\\n        .add(ivault.getLiqEquity(bear))\\n        .add(ivault.getLiqFees())\\n        .mul(1 ether)\\n        .div(ivault.getTotalLiqShares())\\n      );\\n    }\\n  }\\n\\n\\n  /*\\n   * @notice Calc how many bull/bear tokens virtually mint based on incoming\\n   * ETH.\\n   * @returns bull/bear equity and bull/bear tokens to be added\\n  */\\n  function getLiqAddTokens(address vault, uint256 eth)\\n  public\\n  view\\n  returns(uint256, uint256, uint256, uint256)\\n  {\\n    vaultInterface ivault = vaultInterface(vault);\\n    address bull = ivault.getBullToken();\\n    address bear = ivault.getBearToken();\\n    uint256 bullEquity = ivault.getLiqEquity(bull) \\u003c ivault.getLiqEquity(bear) ?\\n      ivault.getLiqEquity(bear).sub(ivault.getLiqEquity(bull)) : 0 ;\\n    uint256 bearEquity = ivault.getLiqEquity(bear) \\u003c ivault.getLiqEquity(bull) ?\\n      ivault.getLiqEquity(bull).sub(ivault.getLiqEquity(bear)) : 0 ;\\n    if(bullEquity \\u003e= eth) bullEquity = eth;\\n    else if(bearEquity \\u003e= eth) bearEquity = eth;\\n    else if(bullEquity \\u003e bearEquity) {\\n      bullEquity = bullEquity.add(eth.sub(bullEquity).div(2));\\n      bearEquity = eth.sub(bullEquity);\\n    }\\n    else if(bearEquity \\u003e bullEquity) {\\n      bearEquity = bearEquity.add(eth.sub(bearEquity).div(2));\\n      bullEquity = eth.sub(bearEquity);\\n    }\\n    else {\\n      bullEquity = eth.div(2);\\n      bearEquity = eth.sub(bullEquity);\\n    }\\n    return(\\n      bullEquity,\\n      bearEquity,\\n      bullEquity.mul(1 ether).div(ivault.getPrice(bull)),\\n      bearEquity.mul(1 ether).div(ivault.getPrice(bear))\\n    );\\n  }\\n\\n  /*\\n   * @notice Calc how many bull/bear tokens virtually burn based on shares\\n   * being removed.\\n   * @param shares Amount of shares user removing from LP\\n   * @returns bull/bear equity and bull/bear tokens to be removed\\n  */\\n  function getLiqRemoveTokens(address vault, uint256 shares)\\n  public\\n  view\\n  returns(uint256, uint256, uint256, uint256, uint256)\\n  {\\n    vaultInterface ivault = vaultInterface(vault);\\n    address bull = ivault.getBullToken();\\n    address bear = ivault.getBearToken();\\n    uint256 eth =\\n      shares\\n      .mul(ivault.getLiqEquity(bull)\\n      .add(ivault.getLiqEquity(bear))\\n      .mul(1 ether).div(ivault.getTotalLiqShares()))\\n      .div(1 ether);\\n    uint256 bullEquity = ivault.getLiqEquity(bull) \\u003e ivault.getLiqEquity(bear) ?\\n      ivault.getLiqEquity(bull).sub(ivault.getLiqEquity(bear)) : 0 ;\\n    uint256 bearEquity = ivault.getLiqEquity(bear) \\u003e ivault.getLiqEquity(bull) ?\\n      ivault.getLiqEquity(bear).sub(ivault.getLiqEquity(bull)) : 0 ;\\n    if(bullEquity \\u003e= eth) bullEquity = eth;\\n    else if(bearEquity \\u003e= eth) bearEquity = eth;\\n    else if(bullEquity \\u003e bearEquity) {\\n      bullEquity = bullEquity.add(eth.sub(bullEquity).div(2));\\n      bearEquity = eth.sub(bullEquity);\\n    }\\n    else if(bearEquity \\u003e bullEquity) {\\n      bearEquity = bearEquity.add(eth.sub(bearEquity).div(2));\\n      bullEquity = eth.sub(bearEquity);\\n    }\\n    else {\\n      bullEquity = eth.div(2);\\n      bearEquity = eth.sub(bullEquity);\\n    }\\n    uint256 bullTokens = bullEquity.mul(1 ether).div(ivault.getPrice(bull));\\n    uint256 bearTokens = bearEquity.mul(1 ether).div(ivault.getPrice(bear));\\n    bullTokens = bullTokens \\u003e ivault.getLiqTokens(bull) ?\\n      ivault.getLiqTokens(bull) : bullTokens;\\n    bearTokens = bearTokens \\u003e ivault.getLiqTokens(bear) ?\\n      ivault.getLiqTokens(bear) : bearTokens;\\n    uint256 feesPaid = ivault.getLiqFees();\\n    feesPaid = feesPaid.mul(shares);\\n    feesPaid = feesPaid.mul(1 ether);\\n    feesPaid = feesPaid.div(ivault.getTotalLiqShares()).div(1 ether);\\n    feesPaid = shares \\u003c= ivault.getTotalLiqShares() ? feesPaid : ivault.getLiqFees();\\n\\n    return(\\n      bullEquity,\\n      bearEquity,\\n      bullTokens,\\n      bearTokens,\\n      feesPaid\\n    );\\n  }\\n\\n  function setbalanceControlFactor(uint256 amount) public onlyOwner() {\\n    balanceControlFactor = amount;\\n  }\\n\\n\\n}\\n\"},\"vaultInterface.sol\":{\"content\":\"pragma solidity \\u003e= 0.6.6;\\n\\ninterface vaultInterface {\\n  function tokenBuy(address token, address account) external;\\n  function tokenSell(address token, address payable account) external;\\n  function addLiquidity(address account) external;\\n  function removeLiquidity(uint256 shares) external;\\n  function updatePrice() external;\\n\\n  function getActive() external view returns(bool);\\n  function getMultiplier() external view returns(uint256);\\n  function getBullToken() external view returns(address);\\n  function getBearToken() external view returns(address);\\n  function getLatestRoundId() external view returns(uint256);\\n  function getPrice(address token) external view returns(uint256);\\n  function getEquity(address token) external view returns(uint256);\\n  function getBuyFee() external view returns(uint256);\\n  function getSellFee() external view returns(uint256);\\n  function getTotalLiqShares() external view returns(uint256);\\n  function getLiqFees() external view returns(uint256);\\n  function getBalanceEquity() external view returns(uint256);\\n  function getLiqTokens(address token) external view returns(uint256);\\n  function getLiqEquity(address token) external view returns(uint256);\\n  function getUserShares(address account) external view returns(uint256);\\n\\n  function getTotalEquity() external view returns(uint256);\\n  function getTokenEquity(address token) external view returns(uint256);\\n  function getTotalLiqEquity() external view returns(uint256);\\n  function getDepositEquity() external view returns(uint256);\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"balanceControlFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"getLiqAddTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"getLiqRemoveTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"getPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setbalanceControlFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"vaultHelper","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://54c420763812f6cc04e8ede362559e83d9a9454fb46b2fa64a1a6efd9ba2aef9"}]}