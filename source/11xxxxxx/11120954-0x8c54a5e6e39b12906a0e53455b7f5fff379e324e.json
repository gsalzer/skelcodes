{"status":"1","message":"OK","result":[{"SourceCode":"// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.7;\r\n\r\nabstract contract StructLike {\r\n    function val(uint256 _id) virtual public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title LinkedList (Structured Link List)\r\n * @author Vittorio Minacori (https://github.com/vittominacori)\r\n * @dev An utility library for using sorted linked list data structures in your Solidity project.\r\n */\r\nlibrary LinkedList {\r\n\r\n    uint256 private constant NULL = 0;\r\n    uint256 private constant HEAD = 0;\r\n\r\n    bool private constant PREV = false;\r\n    bool private constant NEXT = true;\r\n\r\n    struct List {\r\n        mapping(uint256 => mapping(bool => uint256)) list;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the list exists\r\n     * @param self stored linked list from contract\r\n     * @return bool true if list exists, false otherwise\r\n     */\r\n    function isList(List storage self) internal view returns (bool) {\r\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\r\n        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the node exists\r\n     * @param self stored linked list from contract\r\n     * @param _node a node to search for\r\n     * @return bool true if node exists, false otherwise\r\n     */\r\n    function isNode(List storage self, uint256 _node) internal view returns (bool) {\r\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\r\n            if (self.list[HEAD][NEXT] == _node) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the list\r\n     * @param self stored linked list from contract\r\n     * @return uint256\r\n     */\r\n    function range(List storage self) internal view returns (uint256) {\r\n        uint256 i;\r\n        uint256 num;\r\n        (, i) = adj(self, HEAD, NEXT);\r\n        while (i != HEAD) {\r\n            (, i) = adj(self, i, NEXT);\r\n            num++;\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the links of a node as a tuple\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to get\r\n     * @return bool, uint256, uint256 true if node exists or false otherwise, previous node, next node\r\n     */\r\n    function node(List storage self, uint256 _node) internal view returns (bool, uint256, uint256) {\r\n        if (!isNode(self, _node)) {\r\n            return (false, 0, 0);\r\n        } else {\r\n            return (true, self.list[_node][PREV], self.list[_node][NEXT]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link of a node `_node` in direction `_direction`.\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to step from\r\n     * @param _direction direction to step in\r\n     * @return bool, uint256 true if node exists or false otherwise, node in _direction\r\n     */\r\n    function adj(List storage self, uint256 _node, bool _direction) internal view returns (bool, uint256) {\r\n        if (!isNode(self, _node)) {\r\n            return (false, 0);\r\n        } else {\r\n            return (true, self.list[_node][_direction]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link of a node `_node` in direction `NEXT`.\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to step from\r\n     * @return bool, uint256 true if node exists or false otherwise, next node\r\n     */\r\n    function next(List storage self, uint256 _node) internal view returns (bool, uint256) {\r\n        return adj(self, _node, NEXT);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link of a node `_node` in direction `PREV`.\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to step from\r\n     * @return bool, uint256 true if node exists or false otherwise, previous node\r\n     */\r\n    function prev(List storage self, uint256 _node) internal view returns (bool, uint256) {\r\n        return adj(self, _node, PREV);\r\n    }\r\n\r\n    /**\r\n     * @dev Can be used before `insert` to build an ordered list.\r\n     * @dev Get the node and then `back` or `face` basing on your list order.\r\n     * @dev If you want to order basing on other than `structure.val()` override this function\r\n     * @param self stored linked list from contract\r\n     * @param _struct the structure instance\r\n     * @param _val value to seek\r\n     * @return uint256 next node with a value less than _value\r\n     */\r\n    function sort(List storage self, address _struct, uint256 _val) internal view returns (uint256) {\r\n        if (range(self) == 0) {\r\n            return 0;\r\n        }\r\n        bool exists;\r\n        uint256 next_;\r\n        (exists, next_) = adj(self, HEAD, NEXT);\r\n        while ((next_ != 0) && ((_val < StructLike(_struct).val(next_)) != NEXT)) {\r\n            next_ = self.list[next_][NEXT];\r\n        }\r\n        return next_;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a bidirectional link between two nodes on direction `_direction`\r\n     * @param self stored linked list from contract\r\n     * @param _node first node for linking\r\n     * @param _link  node to link to in the _direction\r\n     */\r\n    function form(List storage self, uint256 _node, uint256 _link, bool _dir) internal {\r\n        self.list[_link][!_dir] = _node;\r\n        self.list[_node][_dir] = _link;\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\r\n     * @param self stored linked list from contract\r\n     * @param _node existing node\r\n     * @param _new  new node to insert\r\n     * @param _direction direction to insert node in\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function insert(List storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\r\n        if (!isNode(self, _new) && isNode(self, _node)) {\r\n            uint256 c = self.list[_node][_direction];\r\n            form(self, _node, _new, _direction);\r\n            form(self, _new, c, _direction);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_new` beside existing node `_node` in direction `NEXT`.\r\n     * @param self stored linked list from contract\r\n     * @param _node existing node\r\n     * @param _new  new node to insert\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function face(List storage self, uint256 _node, uint256 _new) internal returns (bool) {\r\n        return insert(self, _node, _new, NEXT);\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_new` beside existing node `_node` in direction `PREV`.\r\n     * @param self stored linked list from contract\r\n     * @param _node existing node\r\n     * @param _new  new node to insert\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function back(List storage self, uint256 _node, uint256 _new) internal returns (bool) {\r\n        return insert(self, _node, _new, PREV);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an entry from the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _node node to remove from the list\r\n     * @return uint256 the removed node\r\n     */\r\n    function del(List storage self, uint256 _node) internal returns (uint256) {\r\n        if ((_node == NULL) || (!isNode(self, _node))) {\r\n            return 0;\r\n        }\r\n        form(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\r\n        delete self.list[_node][PREV];\r\n        delete self.list[_node][NEXT];\r\n        return _node;\r\n    }\r\n\r\n    /**\r\n     * @dev Pushes an entry to the head of the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _node new entry to push to the head\r\n     * @param _direction push to the head (NEXT) or tail (PREV)\r\n     * @return bool true if success, false otherwise\r\n     */\r\n    function push(List storage self, uint256 _node, bool _direction) internal returns (bool) {\r\n        return insert(self, HEAD, _node, _direction);\r\n    }\r\n\r\n    /**\r\n     * @dev Pops the first entry from the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _direction pop from the head (NEXT) or the tail (PREV)\r\n     * @return uint256 the removed node\r\n     */\r\n    function pop(List storage self, bool _direction) internal returns (uint256) {\r\n        bool exists;\r\n        uint256 adj_;\r\n        (exists, adj_) = adj(self, HEAD, _direction);\r\n        return del(self, adj_);\r\n    }\r\n}\r\n\r\nabstract contract SAFEEngineLike {\r\n    function collateralTypes(bytes32) virtual public view returns (\r\n        uint256 debtAmount,       // [wad]\r\n        uint256 accumulatedRate   // [ray]\r\n    );\r\n    function updateAccumulatedRate(bytes32,address,int) virtual external;\r\n    function coinBalance(address) virtual public view returns (uint);\r\n}\r\n\r\ncontract TaxCollector {\r\n    using LinkedList for LinkedList.List;\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint) public authorizedAccounts;\r\n    /**\r\n     * @notice Add auth to an account\r\n     * @param account Account to add auth to\r\n     */\r\n    function addAuthorization(address account) external isAuthorized {\r\n        authorizedAccounts[account] = 1;\r\n        emit AddAuthorization(account);\r\n    }\r\n    /**\r\n     * @notice Remove auth from an account\r\n     * @param account Account to remove auth from\r\n     */\r\n    function removeAuthorization(address account) external isAuthorized {\r\n        authorizedAccounts[account] = 0;\r\n        emit RemoveAuthorization(account);\r\n    }\r\n    /**\r\n    * @notice Checks whether msg.sender can call an authed function\r\n    **/\r\n    modifier isAuthorized {\r\n        require(authorizedAccounts[msg.sender] == 1, \"TaxCollector/account-not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Events ---\r\n    event AddAuthorization(address account);\r\n    event RemoveAuthorization(address account);\r\n    event InitializeCollateralType(bytes32 collateralType);\r\n    event ModifyParameters(\r\n      bytes32 collateralType,\r\n      bytes32 parameter,\r\n      uint data\r\n    );\r\n    event ModifyParameters(bytes32 parameter, uint data);\r\n    event ModifyParameters(bytes32 parameter, address data);\r\n    event ModifyParameters(\r\n      bytes32 collateralType,\r\n      uint256 position,\r\n      uint256 val\r\n    );\r\n    event ModifyParameters(\r\n      bytes32 collateralType,\r\n      uint256 position,\r\n      uint256 taxPercentage,\r\n      address receiverAccount\r\n    );\r\n    event AddSecondaryReceiver(\r\n      bytes32 collateralType,\r\n      uint secondaryReceiverNonce,\r\n      uint latestSecondaryReceiver,\r\n      uint secondaryReceiverAllotedTax,\r\n      uint secondaryReceiverRevenueSources\r\n    );\r\n    event ModifySecondaryReceiver(\r\n      bytes32 collateralType,\r\n      uint secondaryReceiverNonce,\r\n      uint latestSecondaryReceiver,\r\n      uint secondaryReceiverAllotedTax,\r\n      uint secondaryReceiverRevenueSources\r\n    );\r\n    event CollectTax(bytes32 collateralType, uint latestAccumulatedRate, int deltaRate);\r\n    event DistributeTax(bytes32 collateralType, address target, int taxCut);\r\n\r\n    // --- Data ---\r\n    struct CollateralType {\r\n        // Per second borrow rate for this specific collateral type\r\n        uint256 stabilityFee;\r\n        // When SF was last collected for this collateral type\r\n        uint256 updateTime;\r\n    }\r\n    // SF receiver\r\n    struct TaxReceiver {\r\n        // Whether this receiver can accept a negative rate (taking SF from it)\r\n        uint256 canTakeBackTax;                                                 // [bool]\r\n        // Percentage of SF allocated to this receiver\r\n        uint256 taxPercentage;                                                  // [ray%]\r\n    }\r\n\r\n    // Data about each collateral type\r\n    mapping (bytes32 => CollateralType)                  public collateralTypes;\r\n    // Percentage of each collateral's SF that goes to other addresses apart from the primary receiver\r\n    mapping (bytes32 => uint)                            public secondaryReceiverAllotedTax;              // [%ray]\r\n    // Whether an address is already used for a tax receiver\r\n    mapping (address => uint256)                         public usedSecondaryReceiver;                    // [bool]\r\n    // Address associated to each tax receiver index\r\n    mapping (uint256 => address)                         public secondaryReceiverAccounts;\r\n    // How many collateral types send SF to a specific tax receiver\r\n    mapping (address => uint256)                         public secondaryReceiverRevenueSources;\r\n    // Tax receiver data\r\n    mapping (bytes32 => mapping(uint256 => TaxReceiver)) public secondaryTaxReceivers;\r\n\r\n    address    public primaryTaxReceiver;\r\n    // Base stability fee charged to all collateral types\r\n    uint256    public globalStabilityFee;                                                                 // [ray%]\r\n    // Number of secondary tax receivers ever added\r\n    uint256    public secondaryReceiverNonce;\r\n    // Max number of secondarytax receivers a collateral type can have\r\n    uint256    public maxSecondaryReceivers;\r\n    // Latest secondary tax receiver that still has at least one revenue source\r\n    uint256    public latestSecondaryReceiver;\r\n\r\n    // All collateral types\r\n    bytes32[]        public   collateralList;\r\n    // Linked list with tax receiver data\r\n    LinkedList.List  internal secondaryReceiverList;\r\n\r\n    SAFEEngineLike public safeEngine;\r\n\r\n    // --- Init ---\r\n    constructor(address safeEngine_) public {\r\n        authorizedAccounts[msg.sender] = 1;\r\n        safeEngine = SAFEEngineLike(safeEngine_);\r\n        emit AddAuthorization(msg.sender);\r\n    }\r\n\r\n    // --- Math ---\r\n    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\r\n      assembly {\r\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\r\n        default {\r\n          switch mod(n, 2) case 0 { z := b } default { z := x }\r\n          let half := div(b, 2)  // for rounding.\r\n          for { n := div(n, 2) } n { n := div(n,2) } {\r\n            let xx := mul(x, x)\r\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n            let xxRound := add(xx, half)\r\n            if lt(xxRound, xx) { revert(0,0) }\r\n            x := div(xxRound, b)\r\n            if mod(n,2) {\r\n              let zx := mul(z, x)\r\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n              let zxRound := add(zx, half)\r\n              if lt(zxRound, zx) { revert(0,0) }\r\n              z := div(zxRound, b)\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    uint256 constant RAY     = 10 ** 27;\r\n    uint256 constant HUNDRED = 10 ** 29;\r\n    uint256 constant ONE     = 1;\r\n\r\n    function addition(uint x, uint y) internal pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x);\r\n    }\r\n    function addition(int x, int y) internal pure returns (int z) {\r\n        z = x + y;\r\n        if (y <= 0) require(z <= x);\r\n        if (y  > 0) require(z > x);\r\n    }\r\n    function subtract(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function subtract(int x, int y) internal pure returns (int z) {\r\n        z = x - y;\r\n        require(y <= 0 || z <= x);\r\n        require(y >= 0 || z >= x);\r\n    }\r\n    function deduct(uint x, uint y) internal pure returns (int z) {\r\n        z = int(x) - int(y);\r\n        require(int(x) >= 0 && int(y) >= 0);\r\n    }\r\n    function multiply(uint x, int y) internal pure returns (int z) {\r\n        z = int(x) * y;\r\n        require(int(x) >= 0);\r\n        require(y == 0 || z / y == int(x));\r\n    }\r\n    function multiply(int x, int y) internal pure returns (int z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\r\n        z = x * y;\r\n        require(y == 0 || z / y == x);\r\n        z = z / RAY;\r\n    }\r\n\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n    function either(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := or(x, y)}\r\n    }\r\n\r\n    // --- Administration ---\r\n    /**\r\n     * @notice Initialize a brand new collateral type\r\n     * @param collateralType Collateral type name (e.g ETH-A, TBTC-B)\r\n     */\r\n    function initializeCollateralType(bytes32 collateralType) external isAuthorized {\r\n        CollateralType storage collateralType_ = collateralTypes[collateralType];\r\n        require(collateralType_.stabilityFee == 0, \"TaxCollector/collateral-type-already-init\");\r\n        collateralType_.stabilityFee = RAY;\r\n        collateralType_.updateTime   = now;\r\n        collateralList.push(collateralType);\r\n        emit InitializeCollateralType(collateralType);\r\n    }\r\n    /**\r\n     * @notice Modify collateral specific uint params\r\n     * @param collateralType Collateral type who's parameter is modified\r\n     * @param parameter The name of the parameter modified\r\n     * @param data New value for the parameter\r\n     */\r\n    function modifyParameters(\r\n        bytes32 collateralType,\r\n        bytes32 parameter,\r\n        uint data\r\n    ) external isAuthorized {\r\n        require(now == collateralTypes[collateralType].updateTime, \"TaxCollector/update-time-not-now\");\r\n        if (parameter == \"stabilityFee\") collateralTypes[collateralType].stabilityFee = data;\r\n        else revert(\"TaxCollector/modify-unrecognized-param\");\r\n        emit ModifyParameters(\r\n          collateralType,\r\n          parameter,\r\n          data\r\n        );\r\n    }\r\n    /**\r\n     * @notice Modify general uint params\r\n     * @param parameter The name of the parameter modified\r\n     * @param data New value for the parameter\r\n     */\r\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized {\r\n        if (parameter == \"globalStabilityFee\") globalStabilityFee = data;\r\n        else if (parameter == \"maxSecondaryReceivers\") maxSecondaryReceivers = data;\r\n        else revert(\"TaxCollector/modify-unrecognized-param\");\r\n        emit ModifyParameters(parameter, data);\r\n    }\r\n    /**\r\n     * @notice Modify general address params\r\n     * @param parameter The name of the parameter modified\r\n     * @param data New value for the parameter\r\n     */\r\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\r\n        require(data != address(0), \"TaxCollector/null-data\");\r\n        if (parameter == \"primaryTaxReceiver\") primaryTaxReceiver = data;\r\n        else revert(\"TaxCollector/modify-unrecognized-param\");\r\n        emit ModifyParameters(parameter, data);\r\n    }\r\n    /**\r\n     * @notice Set whether a tax receiver can incur negative fees\r\n     * @param collateralType Collateral type giving fees to the tax receiver\r\n     * @param position Receiver position in the list\r\n     * @param val Value that specifies whether a tax receiver can incur negative rates\r\n     */\r\n    function modifyParameters(\r\n        bytes32 collateralType,\r\n        uint256 position,\r\n        uint256 val\r\n    ) external isAuthorized {\r\n        if (both(secondaryReceiverList.isNode(position), secondaryTaxReceivers[collateralType][position].taxPercentage > 0)) {\r\n            secondaryTaxReceivers[collateralType][position].canTakeBackTax = val;\r\n        }\r\n        else revert(\"TaxCollector/unknown-tax-receiver\");\r\n        emit ModifyParameters(\r\n          collateralType,\r\n          position,\r\n          val\r\n        );\r\n    }\r\n    /**\r\n     * @notice Create or modify a secondary tax receiver's data\r\n     * @param collateralType Collateral type that will give SF to the tax receiver\r\n     * @param position Receiver position in the list. Used to determine whether a new tax receiver is\r\n              created or an existing one is edited\r\n     * @param taxPercentage Percentage of SF offered to the tax receiver\r\n     * @param receiverAccount Receiver address\r\n     */\r\n    function modifyParameters(\r\n      bytes32 collateralType,\r\n      uint256 position,\r\n      uint256 taxPercentage,\r\n      address receiverAccount\r\n    ) external isAuthorized {\r\n        (!secondaryReceiverList.isNode(position)) ?\r\n          addSecondaryReceiver(collateralType, taxPercentage, receiverAccount) :\r\n          modifySecondaryReceiver(collateralType, position, taxPercentage);\r\n        emit ModifyParameters(\r\n          collateralType,\r\n          position,\r\n          taxPercentage,\r\n          receiverAccount\r\n        );\r\n    }\r\n\r\n    // --- Tax Receiver Utils ---\r\n    /**\r\n     * @notice Add a new secondary tax receiver\r\n     * @param collateralType Collateral type that will give SF to the tax receiver\r\n     * @param taxPercentage Percentage of SF offered to the tax receiver\r\n     * @param receiverAccount Tax receiver address\r\n     */\r\n    function addSecondaryReceiver(bytes32 collateralType, uint256 taxPercentage, address receiverAccount) internal {\r\n        require(receiverAccount != address(0), \"TaxCollector/null-account\");\r\n        require(receiverAccount != primaryTaxReceiver, \"TaxCollector/primary-receiver-cannot-be-secondary\");\r\n        require(taxPercentage > 0, \"TaxCollector/null-sf\");\r\n        require(usedSecondaryReceiver[receiverAccount] == 0, \"TaxCollector/account-already-used\");\r\n        require(addition(secondaryReceiversAmount(), ONE) <= maxSecondaryReceivers, \"TaxCollector/exceeds-max-receiver-limit\");\r\n        require(addition(secondaryReceiverAllotedTax[collateralType], taxPercentage) < HUNDRED, \"TaxCollector/tax-cut-exceeds-hundred\");\r\n        secondaryReceiverNonce                                                       = addition(secondaryReceiverNonce, 1);\r\n        latestSecondaryReceiver                                                      = secondaryReceiverNonce;\r\n        usedSecondaryReceiver[receiverAccount]                                       = ONE;\r\n        secondaryReceiverAllotedTax[collateralType]                                  = addition(secondaryReceiverAllotedTax[collateralType], taxPercentage);\r\n        secondaryTaxReceivers[collateralType][latestSecondaryReceiver].taxPercentage = taxPercentage;\r\n        secondaryReceiverAccounts[latestSecondaryReceiver]                           = receiverAccount;\r\n        secondaryReceiverRevenueSources[receiverAccount]                             = ONE;\r\n        secondaryReceiverList.push(latestSecondaryReceiver, false);\r\n        emit AddSecondaryReceiver(\r\n          collateralType,\r\n          secondaryReceiverNonce,\r\n          latestSecondaryReceiver,\r\n          secondaryReceiverAllotedTax[collateralType],\r\n          secondaryReceiverRevenueSources[receiverAccount]\r\n        );\r\n    }\r\n    /**\r\n     * @notice Update a secondary tax receiver's data (add a new SF source or modify % of SF taken from a collateral type)\r\n     * @param collateralType Collateral type that will give SF to the tax receiver\r\n     * @param position Receiver's position in the tax receiver list\r\n     * @param taxPercentage Percentage of SF offered to the tax receiver (ray%)\r\n     */\r\n    function modifySecondaryReceiver(bytes32 collateralType, uint256 position, uint256 taxPercentage) internal {\r\n        if (taxPercentage == 0) {\r\n          secondaryReceiverAllotedTax[collateralType] = subtract(\r\n            secondaryReceiverAllotedTax[collateralType],\r\n            secondaryTaxReceivers[collateralType][position].taxPercentage\r\n          );\r\n\r\n          if (secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]] == 1) {\r\n            if (position == latestSecondaryReceiver) {\r\n              (, uint256 prevReceiver) = secondaryReceiverList.prev(latestSecondaryReceiver);\r\n              latestSecondaryReceiver = prevReceiver;\r\n            }\r\n            secondaryReceiverList.del(position);\r\n            delete(usedSecondaryReceiver[secondaryReceiverAccounts[position]]);\r\n            delete(secondaryTaxReceivers[collateralType][position]);\r\n            delete(secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]]);\r\n            delete(secondaryReceiverAccounts[position]);\r\n          } else if (secondaryTaxReceivers[collateralType][position].taxPercentage > 0) {\r\n            secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]] = subtract(secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]], 1);\r\n            delete(secondaryTaxReceivers[collateralType][position]);\r\n          }\r\n        } else {\r\n          uint256 secondaryReceiverAllotedTax_ = addition(\r\n            subtract(secondaryReceiverAllotedTax[collateralType], secondaryTaxReceivers[collateralType][position].taxPercentage),\r\n            taxPercentage\r\n          );\r\n          require(secondaryReceiverAllotedTax_ < HUNDRED, \"TaxCollector/tax-cut-too-big\");\r\n          if (secondaryTaxReceivers[collateralType][position].taxPercentage == 0) {\r\n            secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]] = addition(\r\n              secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]],\r\n              1\r\n            );\r\n          }\r\n          secondaryReceiverAllotedTax[collateralType]                   = secondaryReceiverAllotedTax_;\r\n          secondaryTaxReceivers[collateralType][position].taxPercentage = taxPercentage;\r\n        }\r\n        emit ModifySecondaryReceiver(\r\n          collateralType,\r\n          secondaryReceiverNonce,\r\n          latestSecondaryReceiver,\r\n          secondaryReceiverAllotedTax[collateralType],\r\n          secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]]\r\n        );\r\n    }\r\n\r\n    // --- Tax Collection Utils ---\r\n    /**\r\n     * @notice Check if multiple collateral types are up to date with taxation\r\n     */\r\n    function collectedManyTax(uint start, uint end) public view returns (bool ok) {\r\n        require(both(start <= end, end < collateralList.length), \"TaxCollector/invalid-indexes\");\r\n        for (uint i = start; i <= end; i++) {\r\n          if (now > collateralTypes[collateralList[i]].updateTime) {\r\n            ok = false;\r\n            return ok;\r\n          }\r\n        }\r\n        ok = true;\r\n    }\r\n    /**\r\n     * @notice Check how much SF will be charged (to collateral types between indexes 'start' and 'end'\r\n     *         in the collateralList) during the next taxation\r\n     * @param start Index in collateralList from which to start looping and calculating the tax outcome\r\n     * @param end Index in collateralList at which we stop looping and calculating the tax outcome\r\n     */\r\n    function taxManyOutcome(uint start, uint end) public view returns (bool ok, int rad) {\r\n        require(both(start <= end, end < collateralList.length), \"TaxCollector/invalid-indexes\");\r\n        int  primaryReceiverBalance = -int(safeEngine.coinBalance(primaryTaxReceiver));\r\n        int  deltaRate;\r\n        uint debtAmount;\r\n        for (uint i = start; i <= end; i++) {\r\n          if (now > collateralTypes[collateralList[i]].updateTime) {\r\n            (debtAmount, ) = safeEngine.collateralTypes(collateralList[i]);\r\n            (, deltaRate)  = taxSingleOutcome(collateralList[i]);\r\n            rad = addition(rad, multiply(debtAmount, deltaRate));\r\n          }\r\n        }\r\n        if (rad < 0) {\r\n          ok = (rad < primaryReceiverBalance) ? false : true;\r\n        } else {\r\n          ok = true;\r\n        }\r\n    }\r\n    /**\r\n     * @notice Get how much SF will be distributed after taxing a specific collateral type\r\n     * @param collateralType Collateral type to compute the taxation outcome for\r\n     */\r\n    function taxSingleOutcome(bytes32 collateralType) public view returns (uint, int) {\r\n        (, uint lastAccumulatedRate) = safeEngine.collateralTypes(collateralType);\r\n        uint newlyAccumulatedRate =\r\n          rmultiply(\r\n            rpow(\r\n              addition(\r\n                globalStabilityFee,\r\n                collateralTypes[collateralType].stabilityFee\r\n              ),\r\n              subtract(\r\n                now,\r\n                collateralTypes[collateralType].updateTime\r\n              ),\r\n            RAY),\r\n          lastAccumulatedRate);\r\n        return (newlyAccumulatedRate, deduct(newlyAccumulatedRate, lastAccumulatedRate));\r\n    }\r\n\r\n    // --- Tax Receiver Utils ---\r\n    /**\r\n     * @notice Get the secondary tax receiver list length\r\n     */\r\n    function secondaryReceiversAmount() public view returns (uint) {\r\n        return secondaryReceiverList.range();\r\n    }\r\n    /**\r\n     * @notice Get the collateralList length\r\n     */\r\n    function collateralListLength() public view returns (uint) {\r\n        return collateralList.length;\r\n    }\r\n    /**\r\n     * @notice Check if a tax receiver is at a certain position in the list\r\n     */\r\n    function isSecondaryReceiver(uint256 _receiver) public view returns (bool) {\r\n        if (_receiver == 0) return false;\r\n        return secondaryReceiverList.isNode(_receiver);\r\n    }\r\n\r\n    // --- Tax (Stability Fee) Collection ---\r\n    /**\r\n     * @notice Collect tax from multiple collateral types at once\r\n     * @param start Index in collateralList from which to start looping and calculating the tax outcome\r\n     * @param end Index in collateralList at which we stop looping and calculating the tax outcome\r\n     */\r\n    function taxMany(uint start, uint end) external {\r\n        require(both(start <= end, end < collateralList.length), \"TaxCollector/invalid-indexes\");\r\n        for (uint i = start; i <= end; i++) {\r\n            taxSingle(collateralList[i]);\r\n        }\r\n    }\r\n    /**\r\n     * @notice Collect tax from a single collateral type\r\n     * @param collateralType Collateral type to tax\r\n     */\r\n    function taxSingle(bytes32 collateralType) public returns (uint) {\r\n        uint latestAccumulatedRate;\r\n        if (now <= collateralTypes[collateralType].updateTime) {\r\n          (, latestAccumulatedRate) = safeEngine.collateralTypes(collateralType);\r\n          return latestAccumulatedRate;\r\n        }\r\n        (, int deltaRate) = taxSingleOutcome(collateralType);\r\n        // Check how much debt has been generated for collateralType\r\n        (uint debtAmount, ) = safeEngine.collateralTypes(collateralType);\r\n        splitTaxIncome(collateralType, debtAmount, deltaRate);\r\n        (, latestAccumulatedRate) = safeEngine.collateralTypes(collateralType);\r\n        collateralTypes[collateralType].updateTime = now;\r\n        emit CollectTax(collateralType, latestAccumulatedRate, deltaRate);\r\n        return latestAccumulatedRate;\r\n    }\r\n    /**\r\n     * @notice Split SF between all tax receivers\r\n     * @param collateralType Collateral type to distribute SF for\r\n     * @param deltaRate Difference between the last and the latest accumulate rates for the collateralType\r\n     */\r\n    function splitTaxIncome(bytes32 collateralType, uint debtAmount, int deltaRate) internal {\r\n        // Start looping from the latest tax receiver\r\n        uint256 currentSecondaryReceiver = latestSecondaryReceiver;\r\n        // While we still haven't gone through the entire tax receiver list\r\n        while (currentSecondaryReceiver > 0) {\r\n          // If the current tax receiver should receive SF from collateralType\r\n          if (secondaryTaxReceivers[collateralType][currentSecondaryReceiver].taxPercentage > 0) {\r\n            distributeTax(\r\n              collateralType,\r\n              secondaryReceiverAccounts[currentSecondaryReceiver],\r\n              currentSecondaryReceiver,\r\n              debtAmount,\r\n              deltaRate\r\n            );\r\n          }\r\n          // Continue looping\r\n          (, currentSecondaryReceiver) = secondaryReceiverList.prev(currentSecondaryReceiver);\r\n        }\r\n        // Distribute to primary receiver\r\n        distributeTax(collateralType, primaryTaxReceiver, uint(-1), debtAmount, deltaRate);\r\n    }\r\n\r\n    /**\r\n     * @notice Give/withdraw SF from a tax receiver\r\n     * @param collateralType Collateral type to distribute SF for\r\n     * @param receiver Tax receiver address\r\n     * @param receiverListPosition Position of receiver in the secondaryReceiverList (if the receiver is secondary)\r\n     * @param debtAmount Total debt currently issued\r\n     * @param deltaRate Difference between the latest and the last accumulated rates for the collateralType\r\n     */\r\n    function distributeTax(\r\n        bytes32 collateralType,\r\n        address receiver,\r\n        uint256 receiverListPosition,\r\n        uint256 debtAmount,\r\n        int256 deltaRate\r\n    ) internal {\r\n        // Check how many coins the receiver has and negate the value\r\n        int256 coinBalance   = -int(safeEngine.coinBalance(receiver));\r\n        // Compute the % out of SF that should be allocated to the receiver\r\n        int256 currentTaxCut = (receiver == primaryTaxReceiver) ?\r\n          multiply(subtract(HUNDRED, secondaryReceiverAllotedTax[collateralType]), deltaRate) / int(HUNDRED) :\r\n          multiply(int(secondaryTaxReceivers[collateralType][receiverListPosition].taxPercentage), deltaRate) / int(HUNDRED);\r\n        /**\r\n            If SF is negative and a tax receiver doesn't have enough coins to absorb the loss,\r\n            compute a new tax cut that can be absorbed\r\n        **/\r\n        currentTaxCut  = (\r\n          both(multiply(debtAmount, currentTaxCut) < 0, coinBalance > multiply(debtAmount, currentTaxCut))\r\n        ) ? coinBalance / int(debtAmount) : currentTaxCut;\r\n        /**\r\n          If the tax receiver's tax cut is not null and if the receiver accepts negative SF\r\n          offer/take SF to/from them\r\n        **/\r\n        if (currentTaxCut != 0) {\r\n          if (\r\n            either(\r\n              receiver == primaryTaxReceiver,\r\n              either(\r\n                deltaRate >= 0,\r\n                both(currentTaxCut < 0, secondaryTaxReceivers[collateralType][receiverListPosition].canTakeBackTax > 0)\r\n              )\r\n            )\r\n          ) {\r\n            safeEngine.updateAccumulatedRate(collateralType, receiver, currentTaxCut);\r\n            emit DistributeTax(collateralType, receiver, currentTaxCut);\r\n          }\r\n       }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeEngine_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondaryReceiverNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"latestSecondaryReceiver\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondaryReceiverAllotedTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondaryReceiverRevenueSources\",\"type\":\"uint256\"}],\"name\":\"AddSecondaryReceiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"latestAccumulatedRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaRate\",\"type\":\"int256\"}],\"name\":\"CollectTax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"taxCut\",\"type\":\"int256\"}],\"name\":\"DistributeTax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"}],\"name\":\"InitializeCollateralType\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"taxPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiverAccount\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondaryReceiverNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"latestSecondaryReceiver\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondaryReceiverAllotedTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondaryReceiverRevenueSources\",\"type\":\"uint256\"}],\"name\":\"ModifySecondaryReceiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveAuthorization\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collateralList\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"collateralTypes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stabilityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"collectedManyTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalStabilityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"}],\"name\":\"initializeCollateralType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_receiver\",\"type\":\"uint256\"}],\"name\":\"isSecondaryReceiver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestSecondaryReceiver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSecondaryReceivers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiverAccount\",\"type\":\"address\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"primaryTaxReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeEngine\",\"outputs\":[{\"internalType\":\"contract SAFEEngineLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"secondaryReceiverAccounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"secondaryReceiverAllotedTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondaryReceiverNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"secondaryReceiverRevenueSources\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondaryReceiversAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"secondaryTaxReceivers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"canTakeBackTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxPercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"taxMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"taxManyOutcome\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"rad\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"}],\"name\":\"taxSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"}],\"name\":\"taxSingleOutcome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usedSecondaryReceiver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TaxCollector","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f0b7808b940b78be81ad6f9e075ce8be4a837e2c","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8e1f5c7a824efe88bba1f6dab2ca2ecbae2aa91ec00abe59fe35667f24dd90e3"}]}