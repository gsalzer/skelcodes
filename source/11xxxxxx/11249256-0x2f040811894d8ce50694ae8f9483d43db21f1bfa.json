{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address whom) external view returns (uint);\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transfer(address dst, uint amt) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n}\r\n\r\ninterface IMPool {\r\n    function isBound(address t) external view returns (bool);\r\n    function getFinalTokens() external view returns(address[] memory);\r\n    function getBalance(address token) external view returns (uint);\r\n    function setSwapFee(uint swapFee) external;\r\n    function setController(address controller) external;\r\n    function setPair(address pair) external;\r\n    function bind(address token, uint balance, uint denorm) external;\r\n    function finalize(address beneficiary, uint256 initAmount) external;\r\n    function updatePairGPInfo(address[] calldata gps, uint[] calldata shares) external;\r\n    function joinPool(address beneficiary, uint poolAmountOut, uint[] calldata maxAmountsIn) external;\r\n    function joinswapExternAmountIn(address beneficiary, address tokenIn, uint tokenAmountIn, uint minPoolAmountOut) external returns (uint poolAmountOut);\r\n}\r\n\r\ninterface IPairToken {\r\n    function setController(address _controller) external ;\r\n}\r\n\r\ninterface IMFactory {\r\n    function newMPool() external returns (IMPool);\r\n}\r\n\r\ninterface IPairFactory {\r\n    function newPair(address pool, uint256 perBlock, uint256 rate) external returns (IPairToken);\r\n    function getPairToken(address pool) external view returns (address);\r\n}\r\n\r\n\r\n\r\n/********************************** WARNING **********************************/\r\n//                                                                           //\r\n// This contract is only meant to be used in conjunction with ds-proxy.      //\r\n// Calling this contract directly will lead to loss of funds.                //\r\n//                                                                           //\r\n/********************************** WARNING **********************************/\r\n\r\ncontract MActions {\r\n\r\n    function createWithPair(\r\n        IMFactory factory,\r\n        IPairFactory pairFactory,\r\n        address[] calldata tokens,\r\n        uint[] calldata balances,\r\n        uint[] calldata denorms,\r\n        address[] calldata gps,\r\n        uint[] calldata shares,\r\n        uint swapFee,\r\n        uint gpRate\r\n    ) external returns (IMPool pool) {\r\n        pool = create(factory, tokens, balances, denorms, swapFee, 0, false);\r\n\r\n        IPairToken pair = pairFactory.newPair(address(pool), 4 * 10 ** 18, gpRate);\r\n\r\n        pool.setPair(address(pair));\r\n        if (gpRate > 0 && gps.length != 0 && gps.length == shares.length) {\r\n            pool.updatePairGPInfo(gps, shares);\r\n        }\r\n        pool.finalize(msg.sender, 0);\r\n        pool.setController(msg.sender);\r\n        pair.setController(msg.sender);\r\n    }\r\n\r\n    function create(\r\n        IMFactory factory,\r\n        address[] memory tokens,\r\n        uint[] memory balances,\r\n        uint[] memory denorms,\r\n        uint swapFee,\r\n        uint initLpSupply,\r\n        bool finalize\r\n    ) public returns (IMPool pool) {\r\n        require(tokens.length == balances.length, \"ERR_LENGTH_MISMATCH\");\r\n        require(tokens.length == denorms.length, \"ERR_LENGTH_MISMATCH\");\r\n\r\n        pool = factory.newMPool();\r\n        pool.setSwapFee(swapFee);\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            IERC20 token = IERC20(tokens[i]);\r\n            safeTransferFrom(token, msg.sender, address(this), balances[i]);\r\n            if (token.allowance(address(this), address(pool)) > 0) {\r\n                safeApprove(token, address(pool), 0);\r\n            }\r\n            safeApprove(token, address(pool), balances[i]);\r\n            pool.bind(tokens[i], balances[i], denorms[i]);\r\n        }\r\n        if (finalize) {\r\n            pool.finalize(msg.sender, initLpSupply);\r\n            pool.setController(msg.sender);\r\n        }\r\n\r\n    }\r\n\r\n    function joinPool(\r\n        IMPool pool,\r\n        uint poolAmountOut,\r\n        uint[] calldata maxAmountsIn\r\n    ) external {\r\n        address[] memory tokens = pool.getFinalTokens();\r\n        require(maxAmountsIn.length == tokens.length, \"ERR_LENGTH_MISMATCH\");\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            IERC20 token = IERC20(tokens[i]);\r\n            safeTransferFrom(token, msg.sender, address(this), maxAmountsIn[i]);\r\n            if (token.allowance(address(this), address(pool)) > 0) {\r\n                safeApprove(token, address(pool), 0);\r\n            }\r\n            safeApprove(token, address(pool), maxAmountsIn[i]);\r\n        }\r\n\r\n        pool.joinPool(msg.sender, poolAmountOut, maxAmountsIn);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            IERC20 token = IERC20(tokens[i]);\r\n            if (token.balanceOf(address(this)) > 0) {\r\n                safeTransfer(token, msg.sender, token.balanceOf(address(this)));\r\n            }\r\n        }\r\n    }\r\n\r\n    function joinswapExternAmountIn(\r\n        IMPool pool,\r\n        address tokenIn,\r\n        uint tokenAmountIn,\r\n        uint minPoolAmountOut\r\n    ) external {\r\n        IERC20 token = IERC20(tokenIn);\r\n        safeTransferFrom(token, msg.sender, address(this), tokenAmountIn);\r\n        if (token.allowance(address(this), address(pool)) > 0) {\r\n            safeApprove(token, address(pool), 0);\r\n        }\r\n        safeApprove(token, address(pool), tokenAmountIn);\r\n        pool.joinswapExternAmountIn(msg.sender, tokenIn, tokenAmountIn, minPoolAmountOut);\r\n    }\r\n\r\n    function safeTransfer(IERC20 token, address to , uint256 amount) internal {\r\n        bytes memory data = abi.encodeWithSelector(token.transfer.selector, to, amount);\r\n        bytes memory returndata = functionCall(address(token), data, \"low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"not succeed\");\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to , uint256 amount) internal {\r\n        bytes memory data = abi.encodeWithSelector(token.transferFrom.selector, from, to, amount);\r\n        bytes memory returndata = functionCall(address(token), data, \"low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"not succeed\");\r\n        }\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address to , uint256 amount) internal {\r\n        bytes memory data = abi.encodeWithSelector(token.approve.selector, to, amount);\r\n        bytes memory returndata = functionCall(address(token), data, \"low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"not succeed\");\r\n        }\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.call(data);// value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IMFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"denorms\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initLpSupply\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finalize\",\"type\":\"bool\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"contract IMPool\",\"name\":\"pool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IMFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"contract IPairFactory\",\"name\":\"pairFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"denorms\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"gps\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shares\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gpRate\",\"type\":\"uint256\"}],\"name\":\"createWithPair\",\"outputs\":[{\"internalType\":\"contract IMPool\",\"name\":\"pool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IMPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IMPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MActions","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"bzzr://1c383cd7eafcc424b8124f0097d9de9707d968c71b8152efaf2892bee05fe2f8"}]}