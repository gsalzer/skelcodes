{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\n\n// \n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// \n/******************\n@title WadRayMath library\n@author Aave\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n */\nlibrary WadRayMath {\n  using SafeMath for uint256;\n\n  uint256 internal constant WAD = 1e18;\n  uint256 internal constant halfWAD = WAD / 2;\n\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant halfRAY = RAY / 2;\n\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n  function ray() internal pure returns (uint256) {\n    return RAY;\n  }\n\n  function wad() internal pure returns (uint256) {\n    return WAD;\n  }\n\n  function halfRay() internal pure returns (uint256) {\n    return halfRAY;\n  }\n\n  function halfWad() internal pure returns (uint256) {\n    return halfWAD;\n  }\n\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return halfWAD.add(a.mul(b)).div(WAD);\n  }\n\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 halfB = b / 2;\n\n    return halfB.add(a.mul(WAD)).div(b);\n  }\n\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return halfRAY.add(a.mul(b)).div(RAY);\n  }\n\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 halfB = b / 2;\n\n    return halfB.add(a.mul(RAY)).div(b);\n  }\n\n  function rayToWad(uint256 a) internal pure returns (uint256) {\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\n\n    return halfRatio.add(a).div(WAD_RAY_RATIO);\n  }\n\n  function wadToRay(uint256 a) internal pure returns (uint256) {\n    return a.mul(WAD_RAY_RATIO);\n  }\n\n  /**\n   * @dev calculates x^n, in ray. The code uses the ModExp precompile\n   * @param x base\n   * @param n exponent\n   * @return z = x^n, in ray\n   */\n  function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n    z = n % 2 != 0 ? x : RAY;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x = rayMul(x, x);\n\n      if (n % 2 != 0) {\n        z = rayMul(z, x);\n      }\n    }\n  }\n}\n\n// \ninterface IVaultsCore {\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Liquidated(\n    uint256 indexed vaultId,\n    uint256 debtRepaid,\n    uint256 collateralLiquidated,\n    address indexed owner,\n    address indexed sender\n  );\n\n  event CumulativeRateUpdated(\n    address indexed collateralType,\n    uint256 elapsedTime,\n    uint256 newCumulativeRate\n  ); //cumulative interest rate from deployment time T0\n\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\n\n  function a() external view returns (IAddressProvider);\n\n  function deposit(address _collateralType, uint256 _amount) external;\n\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\n\n  function withdrawAll(uint256 _vaultId) external;\n\n  function borrow(uint256 _vaultId, uint256 _amount) external;\n\n  function repayAll(uint256 _vaultId) external;\n\n  function repay(uint256 _vaultId, uint256 _amount) external;\n\n  function liquidate(uint256 _vaultId) external;\n\n  //Read only\n\n  function availableIncome() external view returns (uint256);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n\n  function lastRefresh(address _collateralType) external view returns (uint256);\n\n  //Refresh\n  function initializeRates(address _collateralType) external;\n\n  function refresh() external;\n\n  function refreshCollateral(address collateralType) external;\n\n  //upgrade\n  function upgrade(address _newVaultsCore) external;\n}\n\n// \ninterface IAccessController {\n  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  function MANAGER_ROLE() external view returns (bytes32);\n\n  function MINTER_ROLE() external view returns (bytes32);\n\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n  function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n\n  function renounceRole(bytes32 role, address account) external;\n}\n\n// \n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// \ninterface ISTABLEX is IERC20 {\n  function a() external view returns (IAddressProvider);\n\n  function mint(address account, uint256 amount) external;\n\n  function burn(address account, uint256 amount) external;\n}\n\n// \ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\n// \ninterface IPriceFeed {\n  event OracleUpdated(address indexed asset, address oracle);\n\n  function a() external view returns (IAddressProvider);\n\n  function setAssetOracle(address _asset, address _oracle) external;\n\n  function assetOracles(address _asset) external view returns (AggregatorV3Interface);\n\n  function getAssetPrice(address _asset) external view returns (uint256);\n\n  function convertFrom(address _asset, uint256 _balance) external view returns (uint256);\n\n  function convertTo(address _asset, uint256 _balance) external view returns (uint256);\n}\n\n// \ninterface IRatesManager {\n  function a() external view returns (IAddressProvider);\n\n  //current annualized borrow rate\n  function annualizedBorrowRate(uint256 _currentBorrowRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate totalDebt based on baseDebt at time T0\n  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate baseDebt at time T0\n  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //calculate a new cumulative rate\n  function calculateCumulativeRate(\n    uint256 _borrowRate,\n    uint256 _cumulativeRate,\n    uint256 _timeElapsed\n  ) external view returns (uint256);\n}\n\n// \ninterface ILiquidationManager {\n  function a() external view returns (IAddressProvider);\n\n  function calculateHealthFactor(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (uint256 healthFactor);\n\n  function liquidationBonus(uint256 _amount) external view returns (uint256 bonus);\n\n  function applyLiquidationDiscount(uint256 _amount) external view returns (uint256 discountedAmount);\n\n  function isHealthy(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (bool);\n}\n\n// \ninterface IVaultsDataProvider {\n  struct Vault {\n    // borrowedType support USDX / PAR\n    address collateralType;\n    address owner;\n    uint256 collateralBalance;\n    uint256 baseDebt;\n    uint256 createdAt;\n  }\n\n  function a() external view returns (IAddressProvider);\n\n  // Read\n  function baseDebt(address _collateralType) external view returns (uint256);\n\n  function vaultCount() external view returns (uint256);\n\n  function vaults(uint256 _id) external view returns (Vault memory);\n\n  function vaultOwner(uint256 _id) external view returns (address);\n\n  function vaultCollateralType(uint256 _id) external view returns (address);\n\n  function vaultCollateralBalance(uint256 _id) external view returns (uint256);\n\n  function vaultBaseDebt(uint256 _id) external view returns (uint256);\n\n  function vaultId(address _collateralType, address _owner) external view returns (uint256);\n\n  function vaultExists(uint256 _id) external view returns (bool);\n\n  function vaultDebt(uint256 _vaultId) external view returns (uint256);\n\n  function debt() external view returns (uint256);\n\n  function collateralDebt(address _collateralType) external view returns (uint256);\n\n  //Write\n  function createVault(address _collateralType, address _owner) external returns (uint256);\n\n  function setCollateralBalance(uint256 _id, uint256 _balance) external;\n\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;\n}\n\n// \ninterface IFeeDistributor {\n  event PayeeAdded(address indexed account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  function a() external view returns (IAddressProvider);\n\n  function lastReleasedAt() external view returns (uint256);\n\n  function getPayees() external view returns (address[] memory);\n\n  function totalShares() external view returns (uint256);\n\n  function shares(address payee) external view returns (uint256);\n\n  function release() external;\n\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\n}\n\n// \ninterface IAddressProvider {\n  function controller() external view returns (IAccessController);\n\n  function config() external view returns (IConfigProvider);\n\n  function core() external view returns (IVaultsCore);\n\n  function stablex() external view returns (ISTABLEX);\n\n  function ratesManager() external view returns (IRatesManager);\n\n  function priceFeed() external view returns (IPriceFeed);\n\n  function liquidationManager() external view returns (ILiquidationManager);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function feeDistributor() external view returns (IFeeDistributor);\n\n  function setAccessController(IAccessController _controller) external;\n\n  function setConfigProvider(IConfigProvider _config) external;\n\n  function setVaultsCore(IVaultsCore _core) external;\n\n  function setStableX(ISTABLEX _stablex) external;\n\n  function setRatesManager(IRatesManager _ratesManager) external;\n\n  function setPriceFeed(IPriceFeed _priceFeed) external;\n\n  function setLiquidationManager(ILiquidationManager _liquidationManager) external;\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\n}\n\n// \ninterface IConfigProvider {\n  struct CollateralConfig {\n    address collateralType;\n    uint256 debtLimit;\n    uint256 minCollateralRatio;\n    uint256 borrowRate;\n    uint256 originationFee;\n  }\n\n  function a() external view returns (IAddressProvider);\n\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\n\n  function collateralIds(address _collateralType) external view returns (uint256);\n\n  function numCollateralConfigs() external view returns (uint256);\n\n  function liquidationBonus() external view returns (uint256);\n\n  event CollateralUpdated(\n    address indexed collateralType,\n    uint256 debtLimit,\n    uint256 minCollateralRatio,\n    uint256 borrowRate,\n    uint256 originationFee\n  );\n  event CollateralRemoved(address indexed collateralType);\n\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee\n  ) external;\n\n  function removeCollateral(address _collateralType) external;\n\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\n\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\n\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\n\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\n\n  function setLiquidationBonus(uint256 _bonus) external;\n\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\n\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\n\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\n\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\n}\n\n// \ncontract ConfigProvider is IConfigProvider {\n  IAddressProvider public override a;\n\n  mapping(uint256 => CollateralConfig) private _collateralConfigs; //indexing starts at 1\n  mapping(address => uint256) public override collateralIds;\n\n  uint256 public override numCollateralConfigs;\n  uint256 public override liquidationBonus = 5e16; // 5%\n\n  constructor(IAddressProvider _addresses) public {\n    a = _addresses;\n  }\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  /**\n    Creates or overwrites an existing config for a collateral type\n    @param _collateralType address of the collateral type\n    @param _debtLimit the debt ceiling for the collateral type \n    @param _minCollateralRatio the minimum ratio to maintain to avoid liquidation\n    @param _borrowRate the borrowing rate specified in 1 second interval in RAY accuracy.\n    @param _originationFee an optional origination fee for newly created debt. Can be 0.\n  */\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee\n  ) public override onlyManager {\n    require(address(_collateralType) != address(0));\n    if (collateralIds[_collateralType] == 0) {\n      //new collateral\n      a.core().initializeRates(_collateralType);\n      CollateralConfig memory config = CollateralConfig({\n        collateralType: _collateralType,\n        debtLimit: _debtLimit,\n        minCollateralRatio: _minCollateralRatio,\n        borrowRate: _borrowRate,\n        originationFee: _originationFee\n      });\n\n      numCollateralConfigs++;\n      _collateralConfigs[numCollateralConfigs] = config;\n      collateralIds[_collateralType] = numCollateralConfigs;\n    } else {\n      // Update collateral config\n      a.core().refreshCollateral(_collateralType);\n      uint256 id = collateralIds[_collateralType];\n\n      _collateralConfigs[id].collateralType = _collateralType;\n      _collateralConfigs[id].debtLimit = _debtLimit;\n      _collateralConfigs[id].minCollateralRatio = _minCollateralRatio;\n      _collateralConfigs[id].borrowRate = _borrowRate;\n      _collateralConfigs[id].originationFee = _originationFee;\n    }\n    emit CollateralUpdated(_collateralType, _debtLimit, _minCollateralRatio, _borrowRate, _originationFee);\n  }\n\n  function emitUpdateEvent(address _collateralType) internal {\n    emit CollateralUpdated(\n      _collateralType,\n      _collateralConfigs[collateralIds[_collateralType]].debtLimit,\n      _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio,\n      _collateralConfigs[collateralIds[_collateralType]].borrowRate,\n      _collateralConfigs[collateralIds[_collateralType]].originationFee\n    );\n  }\n\n  /**\n    Remove the config for a collateral type\n    @param _collateralType address of the collateral type\n  */\n  function removeCollateral(address _collateralType) public override onlyManager {\n    uint256 id = collateralIds[_collateralType];\n    require(id != 0, \"collateral does not exist\");\n\n    collateralIds[_collateralType] = 0;\n\n    _collateralConfigs[id] = _collateralConfigs[numCollateralConfigs]; //move last entry forward\n    collateralIds[_collateralConfigs[id].collateralType] = id; //update id for last entry\n    delete _collateralConfigs[numCollateralConfigs];\n    numCollateralConfigs--;\n\n    emit CollateralRemoved(_collateralType);\n  }\n\n  /**\n    Sets the debt limit for a collateral type\n    @param _collateralType address of the collateral type\n    @param _debtLimit the new debt limit\n  */\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) public override onlyManager {\n    _collateralConfigs[collateralIds[_collateralType]].debtLimit = _debtLimit;\n    emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the minimum collateralization ratio for a collateral type\n    @dev this is the liquidation treshold under which a vault is considered open for liquidation.\n    @param _collateralType address of the collateral type\n    @param _minCollateralRatio the new minimum collateralization ratio\n  */\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio)\n    public\n    override\n    onlyManager\n  {\n    _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio = _minCollateralRatio;\n    emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the borrowing rate for a collateral type\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\n    @param _collateralType address of the collateral type\n    @param _borrowRate the new borrowing rate for a 1 sec interval\n  */\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {\n    a.core().refreshCollateral(_collateralType);\n    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;\n    emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the origiation fee for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n    @param _originationFee new origination fee in WAD\n  */\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) public override onlyManager {\n    _collateralConfigs[collateralIds[_collateralType]].originationFee = _originationFee;\n    emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Get the debt limit for a collateral type\n    @dev this is a platform wide limit for new debt issuance against a specific collateral type\n    @param _collateralType address of the collateral type\n  */\n  function collateralDebtLimit(address _collateralType) public override view returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].debtLimit;\n  }\n\n  /**\n    Get the minimum collateralization ratio for a collateral type\n    @dev this is the liquidation treshold under which a vault is considered open for liquidation.\n    @param _collateralType address of the collateral type\n  */\n  function collateralMinCollateralRatio(address _collateralType) public override view returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio;\n  }\n\n  /**\n    Get the borrowing rate for a collateral type\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\n    @param _collateralType address of the collateral type\n  */\n  function collateralBorrowRate(address _collateralType) public override view returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].borrowRate;\n  }\n\n  /**\n    Get the origiation fee for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n  */\n  function collateralOriginationFee(address _collateralType) public override view returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].originationFee;\n  }\n\n  /**\n    Set the platform wide incentive for liquidations.\n    @dev the liquidation bonus is specified in WAD\n    @param _bonus the liquidation bonus to be paid to liquidators\n  */\n  function setLiquidationBonus(uint256 _bonus) public override onlyManager {\n    liquidationBonus = _bonus;\n  }\n\n  /**\n    Retreives the entire config for a specific config id.\n    @param _id the ID of the conifg to be returned\n  */\n  function collateralConfigs(uint256 _id) public override view returns (CollateralConfig memory) {\n    require(_id <= numCollateralConfigs, \"Invalid config id\");\n    return _collateralConfigs[_id];\n  }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAddressProvider\",\"name\":\"_addresses\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"CollateralRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minCollateralRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originationFee\",\"type\":\"uint256\"}],\"name\":\"CollateralUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"a\",\"outputs\":[{\"internalType\":\"contract IAddressProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"collateralConfigs\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debtLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCollateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originationFee\",\"type\":\"uint256\"}],\"internalType\":\"struct IConfigProvider.CollateralConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralDebtLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collateralIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralMinCollateralRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"collateralOriginationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numCollateralConfigs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"}],\"name\":\"removeCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_borrowRate\",\"type\":\"uint256\"}],\"name\":\"setCollateralBorrowRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debtLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minCollateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_originationFee\",\"type\":\"uint256\"}],\"name\":\"setCollateralConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debtLimit\",\"type\":\"uint256\"}],\"name\":\"setCollateralDebtLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minCollateralRatio\",\"type\":\"uint256\"}],\"name\":\"setCollateralMinCollateralRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralType\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_originationFee\",\"type\":\"uint256\"}],\"name\":\"setCollateralOriginationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"setLiquidationBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ConfigProvider","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006fae125de41c03fa7d917ccfa17ba54ef4feb014","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}