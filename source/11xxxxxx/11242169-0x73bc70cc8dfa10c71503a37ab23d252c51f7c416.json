{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/comptroller/Comptroller.sol\": {\r\n      \"content\": \"// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol\\n//Copyright 2020 Compound Labs, Inc.\\n//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n//1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n//2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n//3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\n// Ctrl+f for PIGGY-MODIFY to see all the modifications.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"./ComptrollerStorage.sol\\\";\\nimport \\\"./IComptroller.sol\\\";\\nimport \\\"../libs/ErrorReporter.sol\\\";\\nimport \\\"../libs/Exponential.sol\\\";\\nimport \\\"../token/PToken.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"../libs/Console.sol\\\";\\n\\n//PIGGY-MODIFY: Modified some methods and fields according to WePiggy's business logic\\ncontract Comptroller is ComptrollerStorage, IComptroller, ComptrollerErrorReporter, Exponential, OwnableUpgradeSafe {\\n\\n    // @notice Emitted when an admin supports a market\\n    event MarketListed(PToken pToken);\\n\\n    // @notice Emitted when an account enters a market\\n    event MarketEntered(PToken pToken, address account);\\n\\n    // @notice Emitted when an account exits a market\\n    event MarketExited(PToken pToken, address account);\\n\\n    // @notice Emitted when close factor is changed by admin\\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\\n\\n    // @notice Emitted when a collateral factor is changed by admin\\n    event NewCollateralFactor(PToken pToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\\n\\n    // @notice Emitted when liquidation incentive is changed by admin\\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\\n\\n    // @notice Emitted when maxAssets is changed by admin\\n    event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);\\n\\n    // @notice Emitted when price oracle is changed\\n    event NewPriceOracle(IPriceOracle oldPriceOracle, IPriceOracle newPriceOracle);\\n\\n    // @notice Emitted when pause guardian is changed\\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\\n\\n    // @notice Emitted when an action is paused globally\\n    event ActionPaused(string action, bool pauseState);\\n\\n    // @notice Emitted when an action is paused on a market\\n    event ActionPaused(PToken pToken, string action, bool pauseState);\\n\\n    // @notice Emitted when market mining status is changed\\n    event MarketMining(PToken pToken, bool isMining);\\n\\n    /// @notice Emitted when borrow cap for a cToken is changed\\n    event NewBorrowCap(PToken indexed pToken, uint newBorrowCap);\\n\\n    /// @notice Emitted when borrow cap guardian is changed\\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\\n\\n\\n\\n    // closeFactorMantissa must be strictly greater than this value\\n    uint internal constant closeFactorMinMantissa = 0.05e18;\\n\\n    // closeFactorMantissa must not exceed this value\\n    uint internal constant closeFactorMaxMantissa = 0.9e18;\\n\\n    // No collateralFactorMantissa may exceed this value\\n    uint internal constant collateralFactorMaxMantissa = 0.9e18;\\n\\n    // liquidationIncentiveMantissa must be no less than this value\\n    uint internal constant liquidationIncentiveMinMantissa = 1.0e18;\\n\\n    // liquidationIncentiveMantissa must be no greater than this value\\n    uint internal constant liquidationIncentiveMaxMantissa = 1.5e18;\\n\\n    function initialize() public initializer {\\n        super.__Ownable_init();\\n    }\\n\\n\\n    /*** Assets You Are In ***/\\n\\n    function enterMarkets(address[] memory pTokens) public override(IComptroller) returns (uint[] memory)  {\\n        uint len = pTokens.length;\\n\\n        uint[] memory results = new uint[](len);\\n        for (uint i = 0; i < len; i++) {\\n            PToken pToken = PToken(pTokens[i]);\\n            results[i] = uint(addToMarketInternal(pToken, msg.sender));\\n        }\\n\\n        return results;\\n    }\\n\\n    /**\\n     * @notice Add the market to the borrower's \\\"assets in\\\" for liquidity calculations\\n     * @param pToken The market to enter\\n     * @param borrower The address of the account to modify\\n     * @return Success indicator for whether the market was entered\\n     */\\n    function addToMarketInternal(PToken pToken, address borrower) internal returns (Error) {\\n        Market storage marketToJoin = markets[address(pToken)];\\n\\n        if (!marketToJoin.isListed) {// market is not listed, cannot join\\n            return Error.MARKET_NOT_LISTED;\\n        }\\n\\n        if (marketToJoin.accountMembership[borrower] == true) {// already joined\\n            return Error.NO_ERROR;\\n        }\\n\\n        if (accountAssets[borrower].length >= maxAssets) {// no space, cannot join\\n            return Error.TOO_MANY_ASSETS;\\n        }\\n\\n        marketToJoin.accountMembership[borrower] = true;\\n        accountAssets[borrower].push(pToken);\\n\\n        emit MarketEntered(pToken, borrower);\\n\\n        return Error.NO_ERROR;\\n    }\\n\\n    function exitMarket(address pTokenAddress) external override(IComptroller) returns (uint) {\\n        PToken pToken = PToken(pTokenAddress);\\n\\n        // Get sender tokensHeld and amountOwed underlying from the pToken\\n        (uint oErr, uint tokensHeld, uint amountOwed,) = pToken.getAccountSnapshot(msg.sender);\\n        require(oErr == 0, \\\"exitMarket: getAccountSnapshot failed\\\");\\n        // semi-opaque error code\\n\\n        // Fail if the sender has a borrow balance\\n        if (amountOwed != 0) {\\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\\n        }\\n\\n        // Fail if the sender is not permitted to redeem all of their tokens\\n        uint allowed = redeemAllowedInternal(pTokenAddress, msg.sender, tokensHeld);\\n        if (allowed != 0) {\\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\\n        }\\n\\n        Market storage marketToExit = markets[address(pToken)];\\n        // Return true if the sender is not already ‘in’ the market\\n        if (!marketToExit.accountMembership[msg.sender]) {\\n            return uint(Error.NO_ERROR);\\n        }\\n        // Set pToken account membership to false\\n        delete marketToExit.accountMembership[msg.sender];\\n\\n        // Delete pToken from the account’s list of assets\\n        // load into memory for faster iteration\\n        PToken[] memory userAssetList = accountAssets[msg.sender];\\n        uint len = userAssetList.length;\\n        uint assetIndex = len;\\n        for (uint i = 0; i < len; i++) {\\n            if (userAssetList[i] == pToken) {\\n                assetIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // We *must* have found the asset in the list or our redundant data structure is broken\\n        assert(assetIndex < len);\\n\\n        // copy last item in list to location of item to be removed, reduce length by 1\\n        PToken[] storage storedList = accountAssets[msg.sender];\\n        storedList[assetIndex] = storedList[storedList.length - 1];\\n        storedList.pop();\\n\\n        emit MarketExited(pToken, msg.sender);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n\\n    /**\\n    * @notice Returns the assets an account has entered\\n    * @param account The address of the account to pull assets for\\n    * @return A dynamic list with the assets the account has entered\\n    */\\n    function getAssetsIn(address account) external view returns (PToken[] memory) {\\n        PToken[] memory assetsIn = accountAssets[account];\\n        return assetsIn;\\n    }\\n\\n    /**\\n     * @notice Returns whether the given account is entered in the given asset\\n     * @param account The address of the account to check\\n     * @param pToken The pToken to check\\n     * @return True if the account is in the asset, otherwise false.\\n     */\\n    function checkMembership(address account, PToken pToken) external view returns (bool) {\\n        return markets[address(pToken)].accountMembership[account];\\n    }\\n\\n    /*** Policy Hooks ***/\\n\\n    function mintAllowed(\\n        address pToken,\\n        address minter,\\n        uint mintAmount\\n    ) external override(IComptroller) returns (uint){\\n\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!mintGuardianPaused[pToken], \\\"mint is paused\\\");\\n\\n        if (!markets[pToken].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function mintVerify(\\n        address pToken,\\n        address minter,\\n        uint mintAmount,\\n        uint mintTokens\\n    ) external override(IComptroller) {\\n\\n    }\\n\\n    function redeemAllowed(\\n        address pToken,\\n        address redeemer,\\n        uint redeemTokens\\n    ) external override(IComptroller) returns (uint){\\n\\n        uint allowed = redeemAllowedInternal(pToken, redeemer, redeemTokens);\\n        if (allowed != uint(Error.NO_ERROR)) {\\n            return allowed;\\n        }\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n    * PIGGY-MODIFY:\\n    * @notice Checks if the account should be allowed to redeem tokens in the given market\\n    * @param pToken The market to verify the redeem against\\n    * @param redeemer The account which would redeem the tokens\\n    * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\\n    * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n    */\\n    function redeemAllowedInternal(address pToken, address redeemer, uint redeemTokens) internal view returns (uint) {\\n        if (!markets[pToken].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\\n        if (!markets[pToken].accountMembership[redeemer]) {\\n            return uint(Error.NO_ERROR);\\n        }\\n\\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, PToken(pToken), redeemTokens, 0);\\n        if (err != Error.NO_ERROR) {\\n            return uint(err);\\n        }\\n        if (shortfall > 0) {\\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\\n        }\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function redeemVerify(\\n        address pToken,\\n        address redeemer,\\n        uint redeemAmount,\\n        uint redeemTokens\\n    ) external override(IComptroller) {\\n\\n    }\\n\\n    function borrowAllowed(\\n        address pToken,\\n        address borrower,\\n        uint borrowAmount\\n    ) external override(IComptroller) returns (uint) {\\n\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!borrowGuardianPaused[pToken], \\\"borrow is paused\\\");\\n\\n        if (!markets[pToken].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        if (!markets[pToken].accountMembership[borrower]) {\\n\\n            // only pTokens may call borrowAllowed if borrower not in market\\n            require(msg.sender == pToken, \\\"sender must be pToken\\\");\\n\\n            // attempt to add borrower to the market\\n            Error err = addToMarketInternal(PToken(msg.sender), borrower);\\n            if (err != Error.NO_ERROR) {\\n                return uint(err);\\n            }\\n\\n            // it should be impossible to break the important invariant\\n            assert(markets[pToken].accountMembership[borrower]);\\n        }\\n\\n        if (oracle.getUnderlyingPrice(PToken(pToken)) == 0) {\\n            return uint(Error.PRICE_ERROR);\\n        }\\n\\n        uint borrowCap = borrowCaps[pToken];\\n        // Borrow cap of 0 corresponds to unlimited borrowing\\n        if (borrowCap != 0) {\\n            uint totalBorrows = PToken(pToken).totalBorrows();\\n            (MathError mathErr, uint nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);\\n            require(mathErr == MathError.NO_ERROR, \\\"total borrows overflow\\\");\\n            require(nextTotalBorrows < borrowCap, \\\"market borrow cap reached\\\");\\n        }\\n\\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, PToken(pToken), 0, borrowAmount);\\n        if (err != Error.NO_ERROR) {\\n            return uint(err);\\n        }\\n        if (shortfall > 0) {\\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\\n        }\\n\\n        return uint(Error.NO_ERROR);\\n\\n    }\\n\\n    function borrowVerify(\\n        address pToken,\\n        address borrower,\\n        uint borrowAmount\\n    ) external override(IComptroller) {\\n\\n    }\\n\\n    function repayBorrowAllowed(\\n        address pToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount\\n    ) external override(IComptroller) returns (uint) {\\n\\n        if (!markets[pToken].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function repayBorrowVerify(\\n        address pToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount,\\n        uint borrowerIndex\\n    ) external override(IComptroller) {\\n\\n    }\\n\\n    function liquidateBorrowAllowed(\\n        address pTokenBorrowed,\\n        address pTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount\\n    ) external override(IComptroller) returns (uint){\\n\\n        if (!markets[pTokenBorrowed].isListed || !markets[pTokenCollateral].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        /* The borrower must have shortfall in order to be liquidatable */\\n        (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\\n        if (err != Error.NO_ERROR) {\\n            return uint(err);\\n        }\\n        if (shortfall == 0) {\\n            return uint(Error.INSUFFICIENT_SHORTFALL);\\n        }\\n\\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\\n        uint borrowBalance = PToken(pTokenBorrowed).borrowBalanceStored(borrower);\\n        (MathError mathErr, uint maxClose) = mulScalarTruncate(Exp({mantissa : closeFactorMantissa}), borrowBalance);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return uint(Error.MATH_ERROR);\\n        }\\n        if (repayAmount > maxClose) {\\n            return uint(Error.TOO_MUCH_REPAY);\\n        }\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function liquidateBorrowVerify(\\n        address pTokenBorrowed,\\n        address pTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount,\\n        uint seizeTokens\\n    ) external override(IComptroller) {\\n\\n    }\\n\\n    function seizeAllowed(\\n        address pTokenCollateral,\\n        address pTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens\\n    ) external override(IComptroller) returns (uint){\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!seizeGuardianPaused, \\\"seize is paused\\\");\\n\\n        if (!markets[pTokenCollateral].isListed || !markets[pTokenBorrowed].isListed) {\\n            return uint(Error.MARKET_NOT_LISTED);\\n        }\\n\\n        if (PToken(pTokenCollateral).comptroller() != PToken(pTokenBorrowed).comptroller()) {\\n            return uint(Error.COMPTROLLER_MISMATCH);\\n        }\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function seizeVerify(\\n        address pTokenCollateral,\\n        address pTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens\\n    ) external override(IComptroller) {\\n\\n    }\\n\\n    function transferAllowed(\\n        address pToken,\\n        address src,\\n        address dst,\\n        uint transferTokens\\n    ) external override(IComptroller) returns (uint){\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(!transferGuardianPaused, \\\"transfer is paused\\\");\\n\\n        // Currently the only consideration is whether or not\\n        //  the src is allowed to redeem this many tokens\\n        uint allowed = redeemAllowedInternal(pToken, src, transferTokens);\\n        if (allowed != uint(Error.NO_ERROR)) {\\n            return allowed;\\n        }\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function transferVerify(\\n        address pToken,\\n        address src,\\n        address dst,\\n        uint transferTokens\\n    ) external override(IComptroller) {\\n\\n    }\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    /**\\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\\n     *  Note that `pTokenBalance` is the number of pTokens the account owns in the market,\\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\\n     */\\n    struct AccountLiquidityLocalVars {\\n        uint sumCollateral;\\n        uint sumBorrowPlusEffects;\\n        uint pTokenBalance;\\n        uint borrowBalance;\\n        uint exchangeRateMantissa;\\n        uint oraclePriceMantissa;\\n        Exp collateralFactor;\\n        Exp exchangeRate;\\n        Exp oraclePrice;\\n        Exp tokensToDenom;\\n    }\\n\\n    /**\\n     * @notice Determine the current account liquidity wrt collateral requirements\\n     * @return (possible error code (semi-opaque),\\n                account liquidity in excess of collateral requirements,\\n     *          account shortfall below collateral requirements)\\n     */\\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, PToken(0), 0, 0);\\n\\n        return (uint(err), liquidity, shortfall);\\n    }\\n\\n\\n    /**\\n     * @notice Determine the current account liquidity wrt collateral requirements\\n     * @return (possible error code,\\n                account liquidity in excess of collateral requirements,\\n     *          account shortfall below collateral requirements)\\n     */\\n    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\\n        return getHypotheticalAccountLiquidityInternal(account, PToken(0), 0, 0);\\n    }\\n\\n    /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @param pTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @return (possible error code (semi-opaque),\\n                hypothetical account liquidity in excess of collateral requirements,\\n     *          hypothetical account shortfall below collateral requirements)\\n     */\\n    function getHypotheticalAccountLiquidity(\\n        address account,\\n        address pTokenModify,\\n        uint redeemTokens,\\n        uint borrowAmount) public view returns (uint, uint, uint) {\\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, PToken(pTokenModify), redeemTokens, borrowAmount);\\n        return (uint(err), liquidity, shortfall);\\n    }\\n\\n\\n    /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @param account The account to determine liquidity for\\n     * @param pTokenModify The market to hypothetically redeem/borrow in\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @dev Note that we calculate the exchangeRateStored for each collateral pToken using stored data,\\n     *  without calculating accumulated interest.\\n     * @return (possible error code,\\n                hypothetical account liquidity in excess of collateral requirements,\\n     *          hypothetical account shortfall below collateral requirements)\\n     */\\n    function getHypotheticalAccountLiquidityInternal(\\n        address account,\\n        PToken pTokenModify,\\n        uint redeemTokens,\\n        uint borrowAmount) internal view returns (Error, uint, uint) {\\n\\n        AccountLiquidityLocalVars memory vars;\\n        // Holds all our calculation results\\n        uint oErr;\\n        MathError mErr;\\n\\n        // For each asset the account is in\\n        PToken[] memory assets = accountAssets[account];\\n        for (uint i = 0; i < assets.length; i++) {\\n            PToken asset = assets[i];\\n\\n            // Read the balances and exchange rate from the cToken\\n            (oErr, vars.pTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\\n            if (oErr != 0) {// semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\\n                return (Error.SNAPSHOT_ERROR, 0, 0);\\n            }\\n            vars.collateralFactor = Exp({mantissa : markets[address(asset)].collateralFactorMantissa});\\n            vars.exchangeRate = Exp({mantissa : vars.exchangeRateMantissa});\\n\\n            // Get the normalized price of the asset\\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\\n            if (vars.oraclePriceMantissa == 0) {\\n                return (Error.PRICE_ERROR, 0, 0);\\n            }\\n            vars.oraclePrice = Exp({mantissa : vars.oraclePriceMantissa});\\n\\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\\n            (mErr, vars.tokensToDenom) = mulExp3(vars.collateralFactor, vars.exchangeRate, vars.oraclePrice);\\n            if (mErr != MathError.NO_ERROR) {\\n                return (Error.MATH_ERROR, 0, 0);\\n            }\\n\\n            // sumCollateral += tokensToDenom * pTokenBalance\\n            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToDenom, vars.pTokenBalance, vars.sumCollateral);\\n            if (mErr != MathError.NO_ERROR) {\\n                return (Error.MATH_ERROR, 0, 0);\\n            }\\n\\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\\n            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\\n            if (mErr != MathError.NO_ERROR) {\\n                return (Error.MATH_ERROR, 0, 0);\\n            }\\n\\n            // Calculate effects of interacting with pTokenModify\\n            if (asset == pTokenModify) {\\n                // redeem effect\\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\\n                if (mErr != MathError.NO_ERROR) {\\n                    return (Error.MATH_ERROR, 0, 0);\\n                }\\n\\n                // borrow effect\\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\\n                if (mErr != MathError.NO_ERROR) {\\n                    return (Error.MATH_ERROR, 0, 0);\\n                }\\n            }\\n        }\\n\\n        // These are safe, as the underflow condition is checked first\\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\\n        } else {\\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\\n        }\\n    }\\n\\n    function liquidateCalculateSeizeTokens(\\n        address pTokenBorrowed,\\n        address pTokenCollateral,\\n        uint repayAmount\\n    ) external override(IComptroller) view returns (uint, uint) {\\n        /* Read oracle prices for borrowed and collateral markets */\\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(PToken(pTokenBorrowed));\\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(PToken(pTokenCollateral));\\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\\n            return (uint(Error.PRICE_ERROR), 0);\\n        }\\n\\n        /*\\n        * Get the exchange rate and calculate the number of collateral tokens to seize:\\n        *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\\n        *  seizeTokens = seizeAmount / exchangeRate\\n        *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\n        */\\n        uint exchangeRateMantissa = PToken(pTokenCollateral).exchangeRateStored();\\n        // Note: reverts on error\\n        uint seizeTokens;\\n        Exp memory numerator;\\n        Exp memory denominator;\\n        Exp memory ratio;\\n        MathError mathErr;\\n\\n        (mathErr, numerator) = mulExp(liquidationIncentiveMantissa, priceBorrowedMantissa);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return (uint(Error.MATH_ERROR), 0);\\n        }\\n\\n        (mathErr, denominator) = mulExp(priceCollateralMantissa, exchangeRateMantissa);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return (uint(Error.MATH_ERROR), 0);\\n        }\\n\\n        (mathErr, ratio) = divExp(numerator, denominator);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return (uint(Error.MATH_ERROR), 0);\\n        }\\n\\n        (mathErr, seizeTokens) = mulScalarTruncate(ratio, repayAmount);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return (uint(Error.MATH_ERROR), 0);\\n        }\\n\\n        return (uint(Error.NO_ERROR), seizeTokens);\\n\\n    }\\n\\n    /*** Admin Functions ***/\\n\\n    /**\\n      * @notice Sets a new price oracle for the comptroller\\n      * @dev Admin function to set a new price oracle\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPriceOracle(IPriceOracle newOracle) public onlyOwner returns (uint) {\\n\\n\\n        // Track the old oracle for the comptroller\\n        IPriceOracle oldOracle = oracle;\\n\\n        // Set comptroller's oracle to newOracle\\n        oracle = newOracle;\\n\\n        // Emit NewPriceOracle(oldOracle, newOracle)\\n        emit NewPriceOracle(oldOracle, newOracle);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sets the closeFactor used when liquidating borrows\\n      * @dev Admin function to set closeFactor\\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\n      */\\n    function _setCloseFactor(uint newCloseFactorMantissa) external onlyOwner returns (uint) {\\n\\n\\n        Exp memory newCloseFactorExp = Exp({mantissa : newCloseFactorMantissa});\\n        Exp memory lowLimit = Exp({mantissa : closeFactorMinMantissa});\\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\\n        }\\n\\n        Exp memory highLimit = Exp({mantissa : closeFactorMaxMantissa});\\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\\n        }\\n\\n        uint oldCloseFactorMantissa = closeFactorMantissa;\\n        closeFactorMantissa = newCloseFactorMantissa;\\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sets the collateralFactor for a market\\n      * @dev Admin function to set per-market collateralFactor\\n      * @param pToken The market to set the factor on\\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\n      */\\n    function _setCollateralFactor(PToken pToken, uint newCollateralFactorMantissa) external onlyOwner returns (uint) {\\n\\n\\n        // Verify market is listed\\n        Market storage market = markets[address(pToken)];\\n        if (!market.isListed) {\\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\\n        }\\n\\n        Exp memory newCollateralFactorExp = Exp({mantissa : newCollateralFactorMantissa});\\n\\n        // Check collateral factor <= 0.9\\n        Exp memory highLimit = Exp({mantissa : collateralFactorMaxMantissa});\\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\\n        }\\n\\n        // If collateral factor != 0, fail if price == 0\\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(pToken) == 0) {\\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\\n        }\\n\\n        // Set market's collateral factor to new collateral factor, remember old value\\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\\n\\n        // Emit event with asset, old collateral factor, and new collateral factor\\n        emit NewCollateralFactor(pToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sets maxAssets which controls how many markets can be entered\\n      * @dev Admin function to set maxAssets\\n      * @param newMaxAssets New max assets\\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\n      */\\n    function _setMaxAssets(uint newMaxAssets) external onlyOwner returns (uint) {\\n\\n\\n        uint oldMaxAssets = maxAssets;\\n        maxAssets = newMaxAssets;\\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sets liquidationIncentive\\n      * @dev Admin function to set liquidationIncentive\\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\n      */\\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external onlyOwner returns (uint) {\\n\\n\\n        // Check de-scaled min <= newLiquidationIncentive <= max\\n        Exp memory newLiquidationIncentive = Exp({mantissa : newLiquidationIncentiveMantissa});\\n        Exp memory minLiquidationIncentive = Exp({mantissa : liquidationIncentiveMinMantissa});\\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\\n        }\\n\\n        Exp memory maxLiquidationIncentive = Exp({mantissa : liquidationIncentiveMaxMantissa});\\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\\n        }\\n\\n        // Save current value for use in log\\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\\n\\n        // Set liquidation incentive to new incentive\\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\\n\\n        // Emit event with old incentive, new incentive\\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Add the market to the markets mapping and set it as listed\\n      * @dev Admin function to set isListed and add support for the market\\n      * @param pToken The address of the market (token) to list\\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\\n      */\\n    function _supportMarket(PToken pToken) external onlyOwner returns (uint) {\\n\\n\\n        if (markets[address(pToken)].isListed) {\\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\\n        }\\n\\n        markets[address(pToken)] = Market({isListed : true, isMining : false, collateralFactorMantissa : 0});\\n\\n        _addMarketInternal(address(pToken));\\n\\n        emit MarketListed(pToken);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function _addMarketInternal(address pToken) internal onlyOwner {\\n        for (uint i = 0; i < allMarkets.length; i ++) {\\n            require(allMarkets[i] != PToken(pToken), \\\"market already added\\\");\\n        }\\n        allMarkets.push(PToken(pToken));\\n    }\\n\\n    /**\\n      * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\\n      * @param pTokens The addresses of the markets (tokens) to change the borrow caps for\\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\\n      */\\n    function _setMarketBorrowCaps(PToken[] calldata pTokens, uint[] calldata newBorrowCaps) external {\\n        require(msg.sender == owner() || msg.sender == borrowCapGuardian, \\\"only owner or borrow cap guardian can set borrow caps\\\");\\n\\n        uint numMarkets = pTokens.length;\\n        uint numBorrowCaps = newBorrowCaps.length;\\n\\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \\\"invalid input\\\");\\n\\n        for (uint i = 0; i < numMarkets; i++) {\\n            borrowCaps[address(pTokens[i])] = newBorrowCaps[i];\\n            emit NewBorrowCap(pTokens[i], newBorrowCaps[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Admin function to change the Borrow Cap Guardian\\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\\n     */\\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external onlyOwner {\\n\\n        // Save current value for inclusion in log\\n        address oldBorrowCapGuardian = borrowCapGuardian;\\n\\n        // Store borrowCapGuardian with value newBorrowCapGuardian\\n        borrowCapGuardian = newBorrowCapGuardian;\\n\\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\\n    }\\n\\n    /**\\n     * @notice Admin function to change the Pause Guardian\\n     * @param newPauseGuardian The address of the new Pause Guardian\\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\\n     */\\n    function _setPauseGuardian(address newPauseGuardian) public onlyOwner returns (uint) {\\n\\n        // Save current value for inclusion in log\\n        address oldPauseGuardian = pauseGuardian;\\n\\n        // Store pauseGuardian with value newPauseGuardian\\n        pauseGuardian = newPauseGuardian;\\n\\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function _setMintPaused(PToken pToken, bool state) public returns (bool) {\\n        require(markets[address(pToken)].isListed, \\\"cannot pause a market that is not listed\\\");\\n        require(msg.sender == pauseGuardian || msg.sender == owner(), \\\"only pause guardian and owner can pause\\\");\\n        require(msg.sender == owner() || state == true, \\\"only owner can unpause\\\");\\n\\n        mintGuardianPaused[address(pToken)] = state;\\n        emit ActionPaused(pToken, \\\"Mint\\\", state);\\n        return state;\\n    }\\n\\n    function _setBorrowPaused(PToken pToken, bool state) public returns (bool) {\\n        require(markets[address(pToken)].isListed, \\\"cannot pause a market that is not listed\\\");\\n        require(msg.sender == pauseGuardian || msg.sender == owner(), \\\"only pause guardian and owner can pause\\\");\\n        require(msg.sender == owner() || state == true, \\\"only owner can unpause\\\");\\n\\n        borrowGuardianPaused[address(pToken)] = state;\\n        emit ActionPaused(pToken, \\\"Borrow\\\", state);\\n        return state;\\n    }\\n\\n    function _setTransferPaused(bool state) public returns (bool) {\\n        require(msg.sender == pauseGuardian || msg.sender == owner(), \\\"only pause guardian and owner can pause\\\");\\n        require(msg.sender == owner() || state == true, \\\"only owner can unpause\\\");\\n\\n        transferGuardianPaused = state;\\n        emit ActionPaused(\\\"Transfer\\\", state);\\n        return state;\\n    }\\n\\n    function _setSeizePaused(bool state) public returns (bool) {\\n        require(msg.sender == pauseGuardian || msg.sender == owner(), \\\"only pause guardian and owner can pause\\\");\\n        require(msg.sender == owner() || state == true, \\\"only owner can unpause\\\");\\n\\n        seizeGuardianPaused = state;\\n        emit ActionPaused(\\\"Seize\\\", state);\\n        return state;\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/comptroller/ComptrollerStorage.sol\": {\r\n      \"content\": \"// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/ComptrollerStorage.sol\\n//Copyright 2020 Compound Labs, Inc.\\n//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n//1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n//2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n//3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\n// Ctrl+f for PIGGY-MODIFY to see all the modifications.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"../oracle/IPriceOracle.sol\\\";\\nimport \\\"../token/PToken.sol\\\";\\n\\ncontract ComptrollerStorage {\\n\\n    /**\\n     * @notice Oracle which gives the price of any given asset\\n     */\\n    IPriceOracle public oracle;\\n\\n    /**\\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n     */\\n    uint256 public closeFactorMantissa;\\n\\n    /**\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\\n     */\\n    uint256 public liquidationIncentiveMantissa;\\n\\n    /**\\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\\n     */\\n    uint256 public maxAssets;\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Per-account mapping of \\\"assets you are in\\\", capped by maxAssets\\n     */\\n    mapping(address => PToken[]) public accountAssets;\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     */\\n    struct Market {\\n        // @notice Whether or not this market is listed\\n        bool isListed;\\n\\n        // @notice Multiplier representing the most one can borrow against their collateral in this market.\\n        // For instance, 0.9 to allow borrowing 90% of collateral value. Must be between 0 and 1, and stored as a mantissa.\\n        uint256 collateralFactorMantissa;\\n\\n        // @notice Per-market mapping of \\\"accounts in this asset\\\"\\n        mapping(address => bool) accountMembership;\\n\\n        // @notice Whether or not this market receives Piggy\\n        bool isMining;\\n    }\\n\\n    /**\\n     * @notice Official mapping of pTokens -> Market metadata\\n     * @dev Used e.g. to determine if a market is supported\\n     */\\n    mapping(address => Market) public markets;\\n\\n    /**\\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\\n     *  Actions which allow users to remove their own assets cannot be paused.\\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\\n     */\\n    address public pauseGuardian;\\n    bool public _mintGuardianPaused;\\n    bool public _borrowGuardianPaused;\\n    bool public transferGuardianPaused;\\n    bool public seizeGuardianPaused;\\n    mapping(address => bool) public mintGuardianPaused;\\n    mapping(address => bool) public borrowGuardianPaused;\\n\\n    /// @notice A list of all markets\\n    PToken[] public allMarkets;\\n\\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\\n    address public borrowCapGuardian;\\n\\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\\n    mapping(address => uint256) public borrowCaps;\\n}\\n\"\r\n    },\r\n    \"contracts/comptroller/IComptroller.sol\": {\r\n      \"content\": \"// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/ComptrollerInterface.sol\\n//Copyright 2020 Compound Labs, Inc.\\n//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n//1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n//2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n//3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\n// Ctrl+f for PIGGY-MODIFY to see all the modifications.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IComptroller {\\n\\n    /*** Assets You Are In ***/\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Add assets to be included in account liquidity calculation\\n     * @param pTokens The list of addresses of the cToken markets to be enabled\\n     * @return Success indicator for whether each corresponding market was entered\\n     */\\n    function enterMarkets(address[] calldata pTokens) external returns (uint[] memory);\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Removes asset from sender's account liquidity calculation\\n     * @dev Sender must not have an outstanding borrow balance in the asset,\\n     *  or be providing necessary collateral for an outstanding borrow.\\n     * @param pTokenAddress The address of the asset to be removed\\n     * @return Whether or not the account successfully exited the market\\n     */\\n    function exitMarket(address pTokenAddress) external returns (uint);\\n\\n    /*** Policy Hooks ***/\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Checks if the account should be allowed to mint tokens in the given market\\n     * @param pToken The market to verify the mint against\\n     * @param minter The account which would get the minted tokens\\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function mintAllowed(\\n        address pToken,\\n        address minter,\\n        uint mintAmount\\n    ) external returns (uint);\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Validates mint and reverts on rejection. May emit logs.\\n     * @param pToken Asset being minted\\n     * @param minter The address minting the tokens\\n     * @param mintAmount The amount of the underlying asset being minted\\n     * @param mintTokens The number of tokens being minted\\n     */\\n    function mintVerify(\\n        address pToken,\\n        address minter,\\n        uint mintAmount,\\n        uint mintTokens\\n    ) external;\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\\n     * @param pToken The market to verify the redeem against\\n     * @param redeemer The account which would redeem the tokens\\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function redeemAllowed(\\n        address pToken,\\n        address redeemer,\\n        uint redeemTokens\\n    ) external returns (uint);\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Validates redeem and reverts on rejection. May emit logs.\\n     * @param pToken Asset being redeemed\\n     * @param redeemer The address redeeming the tokens\\n     * @param redeemAmount The amount of the underlying asset being redeemed\\n     * @param redeemTokens The number of tokens being redeemed\\n     */\\n    function redeemVerify(\\n        address pToken,\\n        address redeemer,\\n        uint redeemAmount,\\n        uint redeemTokens\\n    ) external;\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\\n     * @param pToken The market to verify the borrow against\\n     * @param borrower The account which would borrow the asset\\n     * @param borrowAmount The amount of underlying the account would borrow\\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function borrowAllowed(\\n        address pToken,\\n        address borrower,\\n        uint borrowAmount\\n    ) external returns (uint);\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Validates borrow and reverts on rejection. May emit logs.\\n     * @param pToken Asset whose underlying is being borrowed\\n     * @param borrower The address borrowing the underlying\\n     * @param borrowAmount The amount of the underlying asset requested to borrow\\n     */\\n    function borrowVerify(\\n        address pToken,\\n        address borrower,\\n        uint borrowAmount\\n    ) external;\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\\n     * @param pToken The market to verify the repay against\\n     * @param payer The account which would repay the asset\\n     * @param borrower The account which would borrowed the asset\\n     * @param repayAmount The amount of the underlying asset the account would repay\\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function repayBorrowAllowed(\\n        address pToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount\\n    ) external returns (uint);\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\\n     * @param pToken Asset being repaid\\n     * @param payer The address repaying the borrow\\n     * @param borrower The address of the borrower\\n     * @param repayAmount The amount of underlying being repaid\\n     */\\n    function repayBorrowVerify(\\n        address pToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount,\\n        uint borrowerIndex\\n    ) external;\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Checks if the liquidation should be allowed to occur\\n     * @param pTokenBorrowed Asset which was borrowed by the borrower\\n     * @param pTokenCollateral Asset which was used as collateral and will be seized\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param repayAmount The amount of underlying being repaid\\n     */\\n    function liquidateBorrowAllowed(\\n        address pTokenBorrowed,\\n        address pTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount\\n    ) external returns (uint);\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\\n     * @param pTokenBorrowed Asset which was borrowed by the borrower\\n     * @param pTokenCollateral Asset which was used as collateral and will be seized\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param repayAmount The amount of underlying being repaid\\n     */\\n    function liquidateBorrowVerify(\\n        address pTokenBorrowed,\\n        address pTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount,\\n        uint seizeTokens\\n    ) external;\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Checks if the seizing of assets should be allowed to occur\\n     * @param pTokenCollateral Asset which was used as collateral and will be seized\\n     * @param pTokenBorrowed Asset which was borrowed by the borrower\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param seizeTokens The number of collateral tokens to seize\\n     */\\n    function seizeAllowed(\\n        address pTokenCollateral,\\n        address pTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens\\n    ) external returns (uint);\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Validates seize and reverts on rejection. May emit logs.\\n     * @param pTokenCollateral Asset which was used as collateral and will be seized\\n     * @param pTokenBorrowed Asset which was borrowed by the borrower\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @param seizeTokens The number of collateral tokens to seize\\n     */\\n    function seizeVerify(\\n        address pTokenCollateral,\\n        address pTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens\\n    ) external;\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\\n     * @param pToken The market to verify the transfer against\\n     * @param src The account which sources the tokens\\n     * @param dst The account which receives the tokens\\n     * @param transferTokens The number of pTokens to transfer\\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function transferAllowed(\\n        address pToken,\\n        address src,\\n        address dst,\\n        uint transferTokens\\n    ) external returns (uint);\\n\\n    /**\\n     * PIGGY-MODIFY:\\n     * @notice Validates transfer and reverts on rejection. May emit logs.\\n     * @param pToken Asset being transferred\\n     * @param src The account which sources the tokens\\n     * @param dst The account which receives the tokens\\n     * @param transferTokens The number of pTokens to transfer\\n     */\\n    function transferVerify(\\n        address pToken,\\n        address src,\\n        address dst,\\n        uint transferTokens\\n    ) external;\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    /**\\n     * PIGGY-MODIFY:\\n    * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\\n    * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\\n    * @param pTokenBorrowed The address of the borrowed cToken\\n    * @param pTokenCollateral The address of the collateral cToken\\n    * @param repayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\\n    * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\\n    */\\n    function liquidateCalculateSeizeTokens(\\n        address pTokenBorrowed,\\n        address pTokenCollateral,\\n        uint repayAmount\\n    ) external view returns (uint, uint);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/ErrorReporter.sol\": {\r\n      \"content\": \"// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/ErrorReporter.sol\\n//Copyright 2020 Compound Labs, Inc.\\n//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n//1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n//2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n//3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\n// Ctrl+f for PIGGY-MODIFY to see all the modifications.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ncontract ComptrollerErrorReporter {\\n    enum Error {\\n        NO_ERROR,\\n        UNAUTHORIZED,\\n        COMPTROLLER_MISMATCH,\\n        INSUFFICIENT_SHORTFALL,\\n        INSUFFICIENT_LIQUIDITY,\\n        INVALID_CLOSE_FACTOR,\\n        INVALID_COLLATERAL_FACTOR,\\n        INVALID_LIQUIDATION_INCENTIVE,\\n        MARKET_NOT_ENTERED, // no longer possible\\n        MARKET_NOT_LISTED,\\n        MARKET_ALREADY_LISTED,\\n        MATH_ERROR,\\n        NONZERO_BORROW_BALANCE,\\n        PRICE_ERROR,\\n        REJECTION,\\n        SNAPSHOT_ERROR,\\n        TOO_MANY_ASSETS,\\n        TOO_MUCH_REPAY\\n    }\\n\\n    enum FailureInfo {\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\n        EXIT_MARKET_BALANCE_OWED,\\n        EXIT_MARKET_REJECTION,\\n        SET_CLOSE_FACTOR_OWNER_CHECK,\\n        SET_CLOSE_FACTOR_VALIDATION,\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\\n        SET_IMPLEMENTATION_OWNER_CHECK,\\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\\n        SET_MAX_ASSETS_OWNER_CHECK,\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\\n        SET_PRICE_ORACLE_OWNER_CHECK,\\n        SUPPORT_MARKET_EXISTS,\\n        SUPPORT_MARKET_OWNER_CHECK,\\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\\n    }\\n\\n    /**\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n      **/\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n      */\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), 0);\\n\\n        return uint(err);\\n    }\\n\\n    /**\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n      */\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), opaqueError);\\n\\n        return uint(err);\\n    }\\n}\\n\\ncontract TokenErrorReporter {\\n    enum Error {\\n        NO_ERROR,\\n        UNAUTHORIZED,\\n        BAD_INPUT,\\n        COMPTROLLER_REJECTION,\\n        COMPTROLLER_CALCULATION_ERROR,\\n        INTEREST_RATE_MODEL_ERROR,\\n        INVALID_ACCOUNT_PAIR,\\n        INVALID_CLOSE_AMOUNT_REQUESTED,\\n        INVALID_COLLATERAL_FACTOR,\\n        MATH_ERROR,\\n        MARKET_NOT_FRESH,\\n        MARKET_NOT_LISTED,\\n        TOKEN_INSUFFICIENT_ALLOWANCE,\\n        TOKEN_INSUFFICIENT_BALANCE,\\n        TOKEN_INSUFFICIENT_CASH,\\n        TOKEN_TRANSFER_IN_FAILED,\\n        TOKEN_TRANSFER_OUT_FAILED\\n    }\\n\\n    /*\\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\\n     *       This is because FailureInfo grows significantly faster, and\\n     *       the order of Error has some meaning, while the order of FailureInfo\\n     *       is entirely arbitrary.\\n     */\\n    enum FailureInfo {\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\n        BORROW_ACCRUE_INTEREST_FAILED,\\n        BORROW_CASH_NOT_AVAILABLE,\\n        BORROW_FRESHNESS_CHECK,\\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\n        BORROW_MARKET_NOT_LISTED,\\n        BORROW_COMPTROLLER_REJECTION,\\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\\n        LIQUIDATE_COMPTROLLER_REJECTION,\\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\\n        LIQUIDATE_FRESHNESS_CHECK,\\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\\n        LIQUIDATE_SEIZE_TOO_MUCH,\\n        MINT_ACCRUE_INTEREST_FAILED,\\n        MINT_COMPTROLLER_REJECTION,\\n        MINT_EXCHANGE_CALCULATION_FAILED,\\n        MINT_EXCHANGE_RATE_READ_FAILED,\\n        MINT_FRESHNESS_CHECK,\\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\n        MINT_TRANSFER_IN_FAILED,\\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\\n        REDEEM_ACCRUE_INTEREST_FAILED,\\n        REDEEM_COMPTROLLER_REJECTION,\\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\\n        REDEEM_FRESHNESS_CHECK,\\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\\n        REDUCE_RESERVES_ADMIN_CHECK,\\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\\n        REDUCE_RESERVES_FRESH_CHECK,\\n        REDUCE_RESERVES_VALIDATION,\\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\n        REPAY_BORROW_COMPTROLLER_REJECTION,\\n        REPAY_BORROW_FRESHNESS_CHECK,\\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\n        SET_COMPTROLLER_OWNER_CHECK,\\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\\n        SET_MAX_ASSETS_OWNER_CHECK,\\n        SET_ORACLE_MARKET_NOT_LISTED,\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\\n        SET_RESERVE_FACTOR_FRESH_CHECK,\\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\\n        TRANSFER_COMPTROLLER_REJECTION,\\n        TRANSFER_NOT_ALLOWED,\\n        TRANSFER_NOT_ENOUGH,\\n        TRANSFER_TOO_MUCH,\\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\\n        ADD_RESERVES_FRESH_CHECK,\\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\\n    }\\n\\n    /**\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n      **/\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n      */\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), 0);\\n\\n        return uint(err);\\n    }\\n\\n    /**\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n      */\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), opaqueError);\\n\\n        return uint(err);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Exponential.sol\": {\r\n      \"content\": \"// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Exponential.sol\\n//Copyright 2020 Compound Labs, Inc.\\n//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n//1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n//2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n//3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\n// Ctrl+f for PIGGY-MODIFY to see all the modifications.\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"./CarefulMath.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract Exponential is CarefulMath {\\n    uint constant expScale = 1e18;\\n    uint constant doubleScale = 1e36;\\n    uint constant halfExpScale = expScale/2;\\n    uint constant mantissaOne = expScale;\\n\\n    struct Exp {\\n        uint mantissa;\\n    }\\n\\n    struct Double {\\n        uint mantissa;\\n    }\\n\\n    /**\\n     * @dev Creates an exponential from numerator and denominator values.\\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\\n     *            or if `denom` is zero.\\n     */\\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\\n    }\\n\\n    /**\\n     * @dev Adds two exponentials, returning a new exponential.\\n     */\\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Subtracts two exponentials, returning a new exponential.\\n     */\\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\\n     */\\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(product));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return addUInt(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Divide an Exp by a scalar, returning a new Exp.\\n     */\\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, returning a new Exp.\\n     */\\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\\n        /*\\n          We are doing this as:\\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\\n\\n          How it works:\\n          Exp = a / b;\\n          Scalar = s;\\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\\n        */\\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n        return getExp(numerator, divisor.mantissa);\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\\n     */\\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(fraction));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials, returning a new exponential.\\n     */\\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n\\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        // We add half the scale before dividing so that we get rounding instead of truncation.\\n        //  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\\n        assert(err2 == MathError.NO_ERROR);\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\\n     */\\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\\n    }\\n\\n    /**\\n     * @dev Multiplies three exponentials, returning a new exponential.\\n     */\\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\\n        (MathError err, Exp memory ab) = mulExp(a, b);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, ab);\\n        }\\n        return mulExp(ab, c);\\n    }\\n\\n    /**\\n     * @dev Divides two exponentials, returning a new exponential.\\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\\n     */\\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        return getExp(a.mantissa, b.mantissa);\\n    }\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n     */\\n    function truncate(Exp memory exp) pure internal returns (uint) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / expScale;\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp <= right Exp.\\n     */\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa <= right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp > right Exp.\\n     */\\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa > right.mantissa;\\n    }\\n\\n    /**\\n     * @dev returns true if Exp is exactly zero\\n     */\\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\\n        return value.mantissa == 0;\\n    }\\n\\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\\n        require(n < 2**224, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(uint a, uint b) pure internal returns (uint) {\\n        return add_(a, b, \\\"addition overflow\\\");\\n    }\\n\\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(uint a, uint b) pure internal returns (uint) {\\n        return sub_(a, b, \\\"subtraction underflow\\\");\\n    }\\n\\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n    }\\n\\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / expScale;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n    }\\n\\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / doubleScale;\\n    }\\n\\n    function mul_(uint a, uint b) pure internal returns (uint) {\\n        return mul_(a, b, \\\"multiplication overflow\\\");\\n    }\\n\\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, errorMessage);\\n        return c;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n    }\\n\\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\\n        return div_(mul_(a, expScale), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n    }\\n\\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Double memory b) pure internal returns (uint) {\\n        return div_(mul_(a, doubleScale), b.mantissa);\\n    }\\n\\n    function div_(uint a, uint b) pure internal returns (uint) {\\n        return div_(a, b, \\\"divide by zero\\\");\\n    }\\n\\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/PToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"./PTokenStorage.sol\\\";\\nimport \\\"./IPToken.sol\\\";\\nimport \\\"../comptroller/IComptroller.sol\\\";\\nimport \\\"../rate/IInterestRateModel.sol\\\";\\nimport \\\"../libs/CarefulMath.sol\\\";\\nimport \\\"../libs/Exponential.sol\\\";\\nimport \\\"../libs/ErrorReporter.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Wepiggy's PToken Contract\\n * @notice Abstract base for PTokens\\n * @author Compound\\n */\\nabstract contract PToken is IPToken, Exponential, TokenErrorReporter, OwnableUpgradeSafe {\\n    /**\\n     * @notice Initialize the money market\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ EIP-20 name of this token\\n     * @param symbol_ EIP-20 symbol of this token\\n     * @param decimals_ EIP-20 decimal precision of this token\\n     */\\n    function init(IComptroller comptroller_,\\n        IInterestRateModel interestRateModel_,\\n        uint initialExchangeRateMantissa_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_) public onlyOwner {\\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\n\\n        // Set initial exchange rate\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\n        require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero.\\\");\\n\\n        // Set the comptroller\\n        uint err = _setComptroller(comptroller_);\\n        require(err == uint(Error.NO_ERROR), \\\"setting comptroller failed\\\");\\n\\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\n        accrualBlockNumber = getBlockNumber();\\n        borrowIndex = mantissaOne;\\n\\n        // Set the interest rate model (depends on block number / borrow index)\\n        err = _setInterestRateModelFresh(interestRateModel_);\\n        require(err == uint(Error.NO_ERROR), \\\"setting interest rate model failed\\\");\\n\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\n     * @dev Called by both `transfer` and `transferFrom` internally\\n     * @param spender The address of the account performing the transfer\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param tokens The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\\n        /* Fail if transfer not allowed */\\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\\n        if (allowed != 0) {\\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\\n        }\\n\\n        /* Do not allow self-transfers */\\n        if (src == dst) {\\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\\n        }\\n\\n        /* Get the allowance, infinite for the account owner */\\n        uint startingAllowance = 0;\\n        if (spender == src) {\\n            startingAllowance = uint(- 1);\\n        } else {\\n            startingAllowance = transferAllowances[src][spender];\\n        }\\n\\n        /* Do the calculations, checking for {under,over}flow */\\n        MathError mathErr;\\n        uint allowanceNew;\\n        uint srcTokensNew;\\n        uint dstTokensNew;\\n\\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\\n        }\\n\\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\\n        }\\n\\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        accountTokens[src] = srcTokensNew;\\n        accountTokens[dst] = dstTokensNew;\\n\\n        /* Eat some of the allowance (if necessary) */\\n        if (startingAllowance != uint(- 1)) {\\n            transferAllowances[src][spender] = allowanceNew;\\n        }\\n\\n        /* We emit a Transfer event */\\n        emit Transfer(src, dst, tokens);\\n\\n        comptroller.transferVerify(address(this), src, dst, tokens);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        address src = msg.sender;\\n        transferAllowances[src][spender] = amount;\\n        emit Approval(src, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\n     */\\n    function allowance(address owner, address spender) external override view returns (uint256) {\\n        return transferAllowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) external override view returns (uint256) {\\n        return accountTokens[owner];\\n    }\\n\\n    /**\\n     * @notice Get the underlying balance of the `owner`\\n     * @dev This also accrues interest in a transaction\\n     * @param owner The address of the account to query\\n     * @return The amount of underlying owned by `owner`\\n     */\\n    function balanceOfUnderlying(address owner) external override returns (uint) {\\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\\n        require(mErr == MathError.NO_ERROR, \\\"balance could not be calculated\\\");\\n        return balance;\\n    }\\n\\n    /**\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n     * @param account Address of the account to snapshot\\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\n     */\\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint, uint) {\\n        uint cTokenBalance = accountTokens[account];\\n        uint borrowBalance;\\n        uint exchangeRateMantissa;\\n\\n        MathError mErr;\\n\\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\\n        if (mErr != MathError.NO_ERROR) {\\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\\n        }\\n\\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\\n        if (mErr != MathError.NO_ERROR) {\\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\\n        }\\n\\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\\n    }\\n\\n    /**\\n     * @dev Function to simply retrieve block number\\n     *  This exists mainly for inheriting test contracts to stub this result.\\n     */\\n    function getBlockNumber() internal view returns (uint) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this cToken\\n     * @return The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() external override view returns (uint) {\\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this cToken\\n     * @return The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() external override view returns (uint) {\\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Returns the current total borrows plus accrued interest\\n     * @return The total borrows with interest\\n     */\\n    function totalBorrowsCurrent() external override nonReentrant returns (uint) {\\n        require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n        return totalBorrows;\\n    }\\n\\n    /**\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint) {\\n        require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n        return borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceStored(address account) public override view returns (uint) {\\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\\n        require(err == MathError.NO_ERROR, \\\"borrowBalanceStored: borrowBalanceStoredInternal failed\\\");\\n        return result;\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\\n     */\\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\\n        /* Note: we do not assert that the market is up to date */\\n        MathError mathErr;\\n        uint principalTimesIndex;\\n        uint result;\\n\\n        /* Get borrowBalance and borrowIndex */\\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\\n\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\n         */\\n        if (borrowSnapshot.principal == 0) {\\n            return (MathError.NO_ERROR, 0);\\n        }\\n\\n        /* Calculate new borrow balance using the interest index:\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\n         */\\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return (mathErr, 0);\\n        }\\n\\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return (mathErr, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, result);\\n    }\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\\n        require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n        return exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() public override view returns (uint) {\\n        (MathError err, uint result) = exchangeRateStoredInternal();\\n        require(err == MathError.NO_ERROR, \\\"exchangeRateStored: exchangeRateStoredInternal failed\\\");\\n        return result;\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return (error code, calculated exchange rate scaled by 1e18)\\n     */\\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\\n        uint _totalSupply = totalSupply;\\n        if (_totalSupply == 0) {\\n            /*\\n             * If there are no tokens minted:\\n             *  exchangeRate = initialExchangeRate\\n             */\\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\\n        } else {\\n            /*\\n             * Otherwise:\\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\\n             */\\n            uint totalCash = getCashPrior();\\n            uint cashPlusBorrowsMinusReserves;\\n            Exp memory exchangeRate;\\n            MathError mathErr;\\n\\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\\n            if (mathErr != MathError.NO_ERROR) {\\n                return (mathErr, 0);\\n            }\\n\\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\\n            if (mathErr != MathError.NO_ERROR) {\\n                return (mathErr, 0);\\n            }\\n\\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\\n        }\\n    }\\n\\n    /**\\n     * @notice Get cash balance of this cToken in the underlying asset\\n     * @return The quantity of underlying asset owned by this contract\\n     */\\n    function getCash() external override view returns (uint) {\\n        return getCashPrior();\\n    }\\n\\n    /**\\n     * @notice Applies accrued interest to total borrows and reserves\\n     * @dev This calculates interest accrued from the last checkpointed block\\n     *   up to the current block and writes new checkpoint to storage.\\n     */\\n    function accrueInterest() public override returns (uint) {\\n        /* Remember the initial block number */\\n        uint currentBlockNumber = getBlockNumber();\\n        uint accrualBlockNumberPrior = accrualBlockNumber;\\n\\n        /* Short-circuit accumulating 0 interest */\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\n            return uint(Error.NO_ERROR);\\n        }\\n\\n        /* Read the previous values out of storage */\\n        uint cashPrior = getCashPrior();\\n        uint borrowsPrior = totalBorrows;\\n        uint reservesPrior = totalReserves;\\n        uint borrowIndexPrior = borrowIndex;\\n\\n        /* Calculate the current borrow interest rate */\\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate is absurdly high\\\");\\n\\n        /* Calculate the number of blocks elapsed since the last accrual */\\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\\n        require(mathErr == MathError.NO_ERROR, \\\"could not calculate block delta\\\");\\n\\n        /*\\n         * Calculate the interest accumulated into borrows and reserves and the new index:\\n         *  simpleInterestFactor = borrowRate * blockDelta\\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\n         */\\n\\n        Exp memory simpleInterestFactor;\\n        uint interestAccumulated;\\n        uint totalBorrowsNew;\\n        uint totalReservesNew;\\n        uint borrowIndexNew;\\n\\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the previously calculated values into storage */\\n        accrualBlockNumber = currentBlockNumber;\\n        borrowIndex = borrowIndexNew;\\n        totalBorrows = totalBorrowsNew;\\n        totalReserves = totalReservesNew;\\n\\n        /* We emit an AccrueInterest event */\\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\\n     */\\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\\n        }\\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        return mintFresh(msg.sender, mintAmount, 0);\\n    }\\n\\n    function mintInternalForMigrate(uint mintAmount, uint mintTokens) internal nonReentrant returns (uint, uint) {\\n        require(msg.sender == migrator, \\\"mintInternalForMigrate: caller is not the migrator\\\");\\n\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\\n        }\\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        return mintFresh(msg.sender, mintAmount, mintTokens);\\n    }\\n\\n    struct MintLocalVars {\\n        Error err;\\n        MathError mathErr;\\n        uint exchangeRateMantissa;\\n        uint mintTokens;\\n        uint totalSupplyNew;\\n        uint accountTokensNew;\\n        uint actualMintAmount;\\n    }\\n\\n    /**\\n     * @notice User supplies assets into the market and receives cTokens in exchange\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param minter The address of the account which is supplying the assets\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\\n     */\\n    function mintFresh(address minter, uint mintAmount, uint mintTokens) internal returns (uint, uint) {\\n        /* Fail if mint not allowed */\\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\\n        if (allowed != 0) {\\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\\n        }\\n\\n        MintLocalVars memory vars;\\n\\n        if (mintTokens == 0) {\\n            (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\\n            if (vars.mathErr != MathError.NO_ERROR) {\\n                return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\\n            }\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         *  We call `doTransferIn` for the minter and the mintAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\\n         *  side-effects occurred. The function returns the amount actually transferred,\\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\\n         *  of cash.\\n         */\\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\\n\\n        if (mintTokens == 0) {\\n            /*\\n             * We get the current exchange rate and calculate the number of cTokens to be minted:\\n             *  mintTokens = actualMintAmount / exchangeRate\\n             */\\n\\n            (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\\n            require(vars.mathErr == MathError.NO_ERROR, \\\"MINT_EXCHANGE_CALCULATION_FAILED\\\");\\n        } else {\\n            vars.mintTokens = mintTokens;\\n        }\\n\\n\\n        /*\\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\\n         *  totalSupplyNew = totalSupply + mintTokens\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\n         */\\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\\\");\\n\\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\\\");\\n\\n        /* We write previously calculated values into storage */\\n        totalSupply = vars.totalSupplyNew;\\n        accountTokens[minter] = vars.accountTokensNew;\\n\\n        /* We emit a Mint event, and a Transfer event */\\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\\n        emit Transfer(address(this), minter, vars.mintTokens);\\n\\n        /* We call the defense hook */\\n        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\\n\\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\\n        }\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        return redeemFresh(msg.sender, redeemTokens, 0);\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\\n        }\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        return redeemFresh(msg.sender, 0, redeemAmount);\\n    }\\n\\n    struct RedeemLocalVars {\\n        Error err;\\n        MathError mathErr;\\n        uint exchangeRateMantissa;\\n        uint redeemTokens;\\n        uint redeemAmount;\\n        uint totalSupplyNew;\\n        uint accountTokensNew;\\n    }\\n\\n    /**\\n     * @notice User redeems cTokens in exchange for the underlying asset\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param redeemer The address of the account which is redeeming the tokens\\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\");\\n\\n        RedeemLocalVars memory vars;\\n\\n        /* exchangeRate = invoke Exchange Rate Stored() */\\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\\n        }\\n\\n        /* If redeemTokensIn > 0: */\\n        if (redeemTokensIn > 0) {\\n            /*\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\n             *  redeemTokens = redeemTokensIn\\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\\n             */\\n            vars.redeemTokens = redeemTokensIn;\\n\\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\\n            if (vars.mathErr != MathError.NO_ERROR) {\\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\\n            }\\n        } else {\\n            /*\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\n             *  redeemAmount = redeemAmountIn\\n             */\\n\\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\\n            if (vars.mathErr != MathError.NO_ERROR) {\\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\\n            }\\n\\n            vars.redeemAmount = redeemAmountIn;\\n        }\\n\\n        /* Fail if redeem not allowed */\\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\\n        if (allowed != 0) {\\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\\n        }\\n\\n        /*\\n         * We calculate the new total supply and redeemer balance, checking for underflow:\\n         *  totalSupplyNew = totalSupply - redeemTokens\\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\\n         */\\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\\n        }\\n\\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient cash */\\n        if (getCashPrior() < vars.redeemAmount) {\\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken has redeemAmount less of cash.\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        doTransferOut(redeemer, vars.redeemAmount);\\n\\n        /* We write previously calculated values into storage */\\n        totalSupply = vars.totalSupplyNew;\\n        accountTokens[redeemer] = vars.accountTokensNew;\\n\\n        /* We emit a Transfer event, and a Redeem event */\\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\\n\\n        /* We call the defense hook */\\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\\n        }\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n        return borrowFresh(msg.sender, borrowAmount);\\n    }\\n\\n    struct BorrowLocalVars {\\n        MathError mathErr;\\n        uint accountBorrows;\\n        uint accountBorrowsNew;\\n        uint totalBorrowsNew;\\n    }\\n\\n    /**\\n      * @notice Users borrow assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\\n        /* Fail if borrow not allowed */\\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\\n        if (allowed != 0) {\\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient underlying cash */\\n        if (getCashPrior() < borrowAmount) {\\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\\n        }\\n\\n        BorrowLocalVars memory vars;\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\n         *  accountBorrowsNew = accountBorrows + borrowAmount\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\n         */\\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\\n        }\\n\\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\\n        }\\n\\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We invoke doTransferOut for the borrower and the borrowAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken borrowAmount less of cash.\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        doTransferOut(borrower, borrowAmount);\\n\\n        /* We write the previously calculated values into storage */\\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = vars.totalBorrowsNew;\\n\\n        /* We emit a Borrow event */\\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\\n\\n        /* We call the defense hook */\\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n     */\\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\\n        }\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n     */\\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\\n        }\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\\n    }\\n\\n    struct RepayBorrowLocalVars {\\n        Error err;\\n        MathError mathErr;\\n        uint repayAmount;\\n        uint borrowerIndex;\\n        uint accountBorrows;\\n        uint accountBorrowsNew;\\n        uint totalBorrowsNew;\\n        uint actualRepayAmount;\\n    }\\n\\n    /**\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\n     * @param payer the account paying off the borrow\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount the amount of undelrying tokens being returned\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n     */\\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\\n        /* Fail if repayBorrow not allowed */\\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\\n        if (allowed != 0) {\\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\\n        }\\n\\n        RepayBorrowLocalVars memory vars;\\n\\n        /* We remember the original borrowerIndex for verification purposes */\\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\\n\\n        /* We fetch the amount the borrower owes, with accumulated interest */\\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\\n        if (vars.mathErr != MathError.NO_ERROR) {\\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\\n        }\\n\\n        /* If repayAmount == -1, repayAmount = accountBorrows */\\n        if (repayAmount == uint(- 1)) {\\n            vars.repayAmount = vars.accountBorrows;\\n        } else {\\n            vars.repayAmount = repayAmount;\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call doTransferIn for the payer and the repayAmount\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken holds an additional repayAmount of cash.\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *   it returns the amount actually transferred, in case of a fee.\\n         */\\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\n         */\\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\\\");\\n\\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\\n        require(vars.mathErr == MathError.NO_ERROR, \\\"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\\\");\\n\\n        /* We write the previously calculated values into storage */\\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = vars.totalBorrowsNew;\\n\\n        /* We emit a RepayBorrow event */\\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\\n\\n        /* We call the defense hook */\\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\\n\\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n     */\\n    function liquidateBorrowInternal(address borrower, uint repayAmount, IPToken cTokenCollateral) internal nonReentrant returns (uint, uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\\n        }\\n\\n        error = cTokenCollateral.accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\\n        }\\n\\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\\n    }\\n\\n    /**\\n     * @notice The liquidator liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\\n     */\\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, IPToken cTokenCollateral) internal returns (uint, uint) {\\n        /* Fail if liquidate not allowed */\\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\\n        if (allowed != 0) {\\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\\n        }\\n\\n        /* Verify cTokenCollateral market's block number equals current block number */\\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\\n        }\\n\\n        /* Fail if repayAmount = 0 */\\n        if (repayAmount == 0) {\\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\\n        }\\n\\n        /* Fail if repayAmount = -1 */\\n        if (repayAmount == uint(- 1)) {\\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\\n        }\\n\\n\\n        /* Fail if repayBorrow fails */\\n        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We calculate the number of collateral tokens that will be seized */\\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\\n        require(amountSeizeError == uint(Error.NO_ERROR), \\\"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\\\");\\n\\n        /* Revert if borrower collateral token balance < seizeTokens */\\n        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \\\"LIQUIDATE_SEIZE_TOO_MUCH\\\");\\n\\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\\n        uint seizeError;\\n        if (address(cTokenCollateral) == address(this)) {\\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\\n        } else {\\n            seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\\n        }\\n\\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\\n        require(seizeError == uint(Error.NO_ERROR), \\\"token seizure failed\\\");\\n\\n        /* We emit a LiquidateBorrow event */\\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\\n\\n        /* We call the defense hook */\\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\\n\\n        return (uint(Error.NO_ERROR), actualRepayAmount);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Will fail unless called by another cToken during the process of liquidation.\\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of cTokens to seize\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function seize(address liquidator, address borrower, uint seizeTokens) external override nonReentrant returns (uint) {\\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of cTokens to seize\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\\n        /* Fail if seize not allowed */\\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\\n        if (allowed != 0) {\\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\\n        }\\n\\n        MathError mathErr;\\n        uint borrowerTokensNew;\\n        uint liquidatorTokensNew;\\n\\n        /*\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\n         */\\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\\n        }\\n\\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\\n        if (mathErr != MathError.NO_ERROR) {\\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the previously calculated values into storage */\\n        accountTokens[borrower] = borrowerTokensNew;\\n        accountTokens[liquidator] = liquidatorTokensNew;\\n\\n        /* Emit a Transfer event */\\n        emit Transfer(borrower, liquidator, seizeTokens);\\n\\n        /* We call the defense hook */\\n        comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n\\n    /*** Admin Functions ***/\\n\\n    /**\\n      * @notice Sets a new comptroller for the market\\n      * @dev Admin function to set a new comptroller\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setComptroller(IComptroller newComptroller) public onlyOwner override returns (uint) {\\n        IComptroller oldComptroller = comptroller;\\n        // Ensure invoke comptroller.isComptroller() returns true\\n        // require(newComptroller.isComptroller(), \\\"marker method returned false\\\");\\n\\n        // Set market's comptroller to newComptroller\\n        comptroller = newComptroller;\\n\\n        // Emit NewComptroller(oldComptroller, newComptroller)\\n        emit NewComptroller(oldComptroller, newComptroller);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n      * @dev Admin function to accrue interest and set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactor(uint newReserveFactorMantissa) external override nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\\n        }\\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\\n        return _setReserveFactorFresh(newReserveFactorMantissa);\\n    }\\n\\n    /**\\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\n      * @dev Admin function to set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal onlyOwner returns (uint) {\\n        // Verify market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\\n        }\\n\\n        // Check newReserveFactor ≤ maxReserveFactor\\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\\n        }\\n\\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\\n        reserveFactorMantissa = newReserveFactorMantissa;\\n\\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\\n     * @param addAmount Amount of addition to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\\n        }\\n\\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\\n        (error,) = _addReservesFresh(addAmount);\\n        return error;\\n    }\\n\\n    /**\\n     * @notice Add reserves by transferring from caller\\n     * @dev Requires fresh interest accrual\\n     * @param addAmount Amount of addition to reserves\\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\\n     */\\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\\n        // totalReserves + actualAddAmount\\n        uint totalReservesNew;\\n        uint actualAddAmount;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call doTransferIn for the caller and the addAmount\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken holds an additional addAmount of cash.\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *  it returns the amount actually transferred, in case of a fee.\\n         */\\n\\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\\n\\n        totalReservesNew = totalReserves + actualAddAmount;\\n\\n        /* Revert on overflow */\\n        require(totalReservesNew >= totalReserves, \\\"add reserves unexpected overflow\\\");\\n\\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\\n        totalReserves = totalReservesNew;\\n\\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\n\\n        /* Return (NO_ERROR, actualAddAmount) */\\n        return (uint(Error.NO_ERROR), actualAddAmount);\\n    }\\n\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring to admin\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReserves(uint reduceAmount) external override nonReentrant returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\\n        }\\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\\n        return _reduceReservesFresh(reduceAmount);\\n    }\\n\\n    /**\\n     * @notice Reduces reserves by transferring to admin\\n     * @dev Requires fresh interest accrual\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReservesFresh(uint reduceAmount) internal onlyOwner returns (uint) {\\n        // totalReserves - reduceAmount\\n        uint totalReservesNew;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\\n        }\\n\\n        // Fail gracefully if protocol has insufficient underlying cash\\n        if (getCashPrior() < reduceAmount) {\\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\\n        }\\n\\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\\n        if (reduceAmount > totalReserves) {\\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        totalReservesNew = totalReserves - reduceAmount;\\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\\n        require(totalReservesNew <= totalReserves, \\\"reduce reserves unexpected underflow\\\");\\n\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\n        totalReserves = totalReservesNew;\\n\\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n        doTransferOut(payable(owner()), reduceAmount);\\n\\n        emit ReservesReduced(owner(), reduceAmount, totalReservesNew);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /**\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n     * @dev Admin function to accrue interest and update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModel(IInterestRateModel newInterestRateModel) public override returns (uint) {\\n        uint error = accrueInterest();\\n        if (error != uint(Error.NO_ERROR)) {\\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\\n        }\\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\\n        return _setInterestRateModelFresh(newInterestRateModel);\\n    }\\n\\n    /**\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\n     * @dev Admin function to update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModelFresh(IInterestRateModel newInterestRateModel) internal onlyOwner returns (uint) {\\n\\n        // Used to store old model for use in the event that is emitted on success\\n        IInterestRateModel oldInterestRateModel;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\\n        }\\n\\n        // Track the market's current interest rate model\\n        oldInterestRateModel = interestRateModel;\\n\\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\n//        require(newInterestRateModel.isInterestRateModel(), \\\"marker method returned false\\\");\\n\\n        // Set the interest rate model to newInterestRateModel\\n        interestRateModel = newInterestRateModel;\\n\\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    function _setMigrator(address newMigrator) public onlyOwner override returns (uint) {\\n        address oldMigrator = migrator;\\n\\n        // Set market's comptroller to newComptroller\\n        migrator = newMigrator;\\n\\n        // Emit NewComptroller(oldComptroller, newComptroller)\\n        emit NewMigrator(oldMigrator, newMigrator);\\n\\n        return uint(Error.NO_ERROR);\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying owned by this contract\\n     */\\n    function getCashPrior() internal virtual view returns (uint);\\n\\n    /**\\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\\n     *  This may revert due to insufficient balance or insufficient allowance.\\n     */\\n    function doTransferIn(address from, uint amount) internal virtual returns (uint);\\n\\n    /**\\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\n     */\\n    function doTransferOut(address payable to, uint amount) internal virtual;\\n\\n\\n    /*** Reentrancy Guard ***/\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"re-entered\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true;\\n        // get a gas-refund post-Istanbul\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n\\n\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n\\n    }\\n\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Console.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n//通过log函数重载，对不同类型的变量trigger不同的event，实现solidity打印效果，使用方法为：log(string name, var value)\\n\\ncontract Console {\\n    event LogUint(string);\\n\\n    function log(string memory s) internal {\\n        emit LogUint(s);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/oracle/IPriceOracle.sol\": {\r\n      \"content\": \"// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/PriceOracle.sol\\n//Copyright 2020 Compound Labs, Inc.\\n//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n//1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n//2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n//3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\n// Ctrl+f for PIGGY-MODIFY to see all the modifications.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"../token/PToken.sol\\\";\\n\\ninterface IPriceOracle {\\n    /**\\n     * @notice Get the underlying price of a asset\\n     * @param _pToken The asset to get the underlying price of\\n     * @return The underlying asset price.\\n     *  Zero means the price is unavailable.\\n     */\\n    function getUnderlyingPrice(PToken _pToken) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/token/PTokenStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"../comptroller/IComptroller.sol\\\";\\nimport \\\"../rate/IInterestRateModel.sol\\\";\\n\\ncontract PTokenStorage {\\n    /**\\n     * @notice Indicator that this is a PToken contract (for inspection)\\n     */\\n    bool public constant isPToken = true;\\n\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    bool internal _notEntered;\\n\\n    /**\\n     * @notice EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\\n     */\\n\\n    uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\\n\\n    /**\\n     * @notice Maximum fraction of interest that can be set aside for reserves\\n     */\\n    uint256 internal constant reserveFactorMaxMantissa = 1e18;\\n\\n    /**\\n     * @notice Contract which oversees inter-pToken operations\\n     */\\n    IComptroller public comptroller;\\n\\n    /**\\n     * @notice Model which tells what the current interest rate should be\\n     */\\n    IInterestRateModel public interestRateModel;\\n\\n    /**\\n     * @notice Initial exchange rate used when minting the first PTokens (used when totalSupply = 0)\\n     */\\n    uint256 internal initialExchangeRateMantissa;\\n\\n    /**\\n     * @notice Fraction of interest currently set aside for reserves\\n     */\\n    uint256 public reserveFactorMantissa;\\n\\n    /**\\n     * @notice Block number that interest was last accrued at\\n     */\\n    uint256 public accrualBlockNumber;\\n\\n    /**\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\n     */\\n    uint256 public borrowIndex;\\n\\n    /**\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\n     */\\n    uint256 public totalBorrows;\\n\\n    /**\\n     * @notice Total amount of reserves of the underlying held in this market\\n     */\\n    uint256 public totalReserves;\\n\\n    /**\\n     * @notice Total number of tokens in circulation\\n     */\\n    uint256 public totalSupply;\\n\\n    /**\\n     * @notice Official record of token balances for each account\\n     */\\n    mapping(address => uint256) internal accountTokens;\\n\\n    /**\\n     * @notice Approved token transfer amounts on behalf of others\\n     */\\n    mapping(address => mapping(address => uint256)) internal transferAllowances;\\n\\n    /**\\n     * @notice Container for borrow balance information\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n     */\\n    struct BorrowSnapshot {\\n        uint256 principal;\\n        uint256 interestIndex;\\n    }\\n\\n    /**\\n     * @notice Mapping of account addresses to outstanding borrow balances\\n     */\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\n\\n    address public migrator;\\n}\\n\"\r\n    },\r\n    \"contracts/token/IPToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"../comptroller/IComptroller.sol\\\";\\nimport \\\"../rate/IInterestRateModel.sol\\\";\\nimport \\\"./PTokenStorage.sol\\\";\\n\\nabstract contract IPToken is PTokenStorage {\\n    /*** Market Events ***/\\n\\n    /**\\n     * @notice Event emitted when interest is accrued\\n     */\\n    event AccrueInterest(\\n        uint256 cashPrior,\\n        uint256 interestAccumulated,\\n        uint256 borrowIndex,\\n        uint256 totalBorrows\\n    );\\n\\n    /**\\n     * @notice Event emitted when tokens are minted\\n     */\\n    event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\\n\\n    /**\\n     * @notice Event emitted when tokens are redeemed\\n     */\\n    event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\\n\\n    /**\\n     * @notice Event emitted when underlying is borrowed\\n     */\\n    event Borrow(\\n        address borrower,\\n        uint256 borrowAmount,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n\\n    /**\\n     * @notice Event emitted when a borrow is repaid\\n     */\\n    event RepayBorrow(\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n\\n    /**\\n     * @notice Event emitted when a borrow is liquidated\\n     */\\n    event LiquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        address cTokenCollateral,\\n        uint256 seizeTokens\\n    );\\n\\n    /*** Admin Events ***/\\n\\n    /**\\n     * @notice Event emitted when comptroller is changed\\n     */\\n    event NewComptroller(\\n        IComptroller oldComptroller,\\n        IComptroller newComptroller\\n    );\\n\\n    /**\\n     * @notice Event emitted when interestRateModel is changed\\n     */\\n    event NewMarketInterestRateModel(\\n        IInterestRateModel oldInterestRateModel,\\n        IInterestRateModel newInterestRateModel\\n    );\\n\\n    /**\\n     * @notice Event emitted when the reserve factor is changed\\n     */\\n    event NewReserveFactor(\\n        uint256 oldReserveFactorMantissa,\\n        uint256 newReserveFactorMantissa\\n    );\\n\\n    /**\\n     * @notice Event emitted when the reserves are added\\n     */\\n    event ReservesAdded(\\n        address benefactor,\\n        uint256 addAmount,\\n        uint256 newTotalReserves\\n    );\\n\\n    /**\\n     * @notice Event emitted when the reserves are reduced\\n     */\\n    event ReservesReduced(\\n        address admin,\\n        uint256 reduceAmount,\\n        uint256 newTotalReserves\\n    );\\n\\n    /**\\n     * @notice EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /**\\n     * @notice EIP20 Approval event\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @notice Failure event\\n     */\\n    event Failure(uint256 error, uint256 info, uint256 detail);\\n\\n    event NewMigrator(address oldMigrator, address newMigrator);\\n\\n    /*** User Interface ***/\\n\\n    function transfer(address dst, uint256 amount)\\n        external\\n        virtual\\n        returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external virtual returns (bool);\\n\\n    function approve(address spender, uint256 amount)\\n        external\\n        virtual\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        virtual\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address owner) external virtual view returns (uint256);\\n\\n    function balanceOfUnderlying(address owner)\\n        external\\n        virtual\\n        returns (uint256);\\n\\n    function getAccountSnapshot(address account)\\n        external\\n        virtual\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function borrowRatePerBlock() external virtual view returns (uint256);\\n\\n    function supplyRatePerBlock() external virtual view returns (uint256);\\n\\n    function totalBorrowsCurrent() external virtual returns (uint256);\\n\\n    function borrowBalanceCurrent(address account)\\n        external\\n        virtual\\n        returns (uint256);\\n\\n    function borrowBalanceStored(address account)\\n        public\\n        virtual\\n        view\\n        returns (uint256);\\n\\n    function exchangeRateCurrent() public virtual returns (uint256);\\n\\n    function exchangeRateStored() public virtual view returns (uint256);\\n\\n    function getCash() external virtual view returns (uint256);\\n\\n    function accrueInterest() public virtual returns (uint256);\\n\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external virtual returns (uint256);\\n\\n    /*** Admin Functions ***/\\n\\n    function _setComptroller(IComptroller newComptroller)\\n        public\\n        virtual\\n        returns (uint256);\\n\\n    function _setReserveFactor(uint256 newReserveFactorMantissa)\\n        external\\n        virtual\\n        returns (uint256);\\n\\n    function _reduceReserves(uint256 reduceAmount)\\n        external\\n        virtual\\n        returns (uint256);\\n\\n    function _setInterestRateModel(IInterestRateModel newInterestRateModel)\\n        public\\n        virtual\\n        returns (uint256);\\n\\n    function _setMigrator(address newMigrator)\\n        public\\n        virtual\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/rate/IInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n/**\\n  * @title wepiggy's IInterestRateModel Interface\\n  * @author wepiggy\\n  */\\ninterface IInterestRateModel {\\n    /**\\n      * @notice Calculates the current borrow interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);\\n\\n    /**\\n      * @notice Calculates the current supply interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @param reserveFactorMantissa The current reserve factor the market has\\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libs/CarefulMath.sol\": {\r\n      \"content\": \"// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/CarefulMath.sol\\n//Copyright 2020 Compound Labs, Inc.\\n//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n//1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n//2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n//3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\n// Ctrl+f for PIGGY-MODIFY to see all the modifications.\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n/**\\n  * @title Careful Math\\n  * @author Compound\\n  * @notice Derived from OpenZeppelin's SafeMath library\\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\\n  */\\ncontract CarefulMath {\\n\\n    /**\\n     * @dev Possible error codes that we can return\\n     */\\n    enum MathError {\\n        NO_ERROR,\\n        DIVISION_BY_ZERO,\\n        INTEGER_OVERFLOW,\\n        INTEGER_UNDERFLOW\\n    }\\n\\n    /**\\n    * @dev Multiplies two numbers, returns an error on overflow.\\n    */\\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (a == 0) {\\n            return (MathError.NO_ERROR, 0);\\n        }\\n\\n        uint c = a * b;\\n\\n        if (c / a != b) {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        } else {\\n            return (MathError.NO_ERROR, c);\\n        }\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (b == 0) {\\n            return (MathError.DIVISION_BY_ZERO, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, a / b);\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (b <= a) {\\n            return (MathError.NO_ERROR, a - b);\\n        } else {\\n            return (MathError.INTEGER_UNDERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, returns an error on overflow.\\n    */\\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        uint c = a + b;\\n\\n        if (c >= a) {\\n            return (MathError.NO_ERROR, c);\\n        } else {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n    * @dev add a and b and then subtract c\\n    */\\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\\n        (MathError err0, uint sum) = addUInt(a, b);\\n\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, 0);\\n        }\\n\\n        return subUInt(sum, c);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\nimport \\\"../Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract ContextUpgradeSafe is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n\\n\\n    }\\n\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/rate/BaseJumpRateModel.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"./IInterestRateModel.sol\\\";\\n\\n/**\\n  * @title Logic for Compound's JumpRateModel Contract V2.\\n  * @author Compound (modified by Dharma Labs, refactored by Arr00)\\n  * @notice Version 2 modifies Version 1 by enabling updateable parameters.\\n  */\\ncontract BaseJumpRateModel is IInterestRateModel, OwnableUpgradeSafe {\\n    using SafeMath for uint;\\n\\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\\n\\n    /**\\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\\n     */\\n    uint public constant blocksPerYear = 2102400;\\n\\n    /**\\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\\n     */\\n    uint public multiplierPerBlock;\\n\\n    /**\\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\\n     */\\n    uint public baseRatePerBlock;\\n\\n    /**\\n     * @notice The multiplierPerBlock after hitting a specified utilization point\\n     */\\n    uint public jumpMultiplierPerBlock;\\n\\n    /**\\n     * @notice The utilization point at which the jump multiplier is applied\\n     */\\n    uint public kink;\\n\\n    /**\\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     */\\n    function updateJumpRateModel(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) external {\\n        updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\\n    }\\n\\n    /**\\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market (currently unused)\\n     * @return The utilization rate as a mantissa between [0, 1e18]\\n     */\\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\\n        // Utilization rate is 0 when there are no borrows\\n        if (borrows == 0) {\\n            return 0;\\n        }\\n\\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\\n    }\\n\\n    /**\\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market\\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\\n     */\\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\\n        uint util = utilizationRate(cash, borrows, reserves);\\n\\n        if (util <= kink) {\\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\\n        } else {\\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\\n            uint excessUtil = util.sub(kink);\\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the current borrow rate per block\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market\\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\\n     */\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external virtual override view returns (uint) {\\n        return getBorrowRateInternal(cash, borrows, reserves);\\n    }\\n\\n\\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) internal view returns (uint) {\\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\\n    }\\n    /**\\n     * @notice Calculates the current supply rate per block\\n     * @param cash The amount of cash in the market\\n     * @param borrows The amount of borrows in the market\\n     * @param reserves The amount of reserves in the market\\n     * @param reserveFactorMantissa The current reserve factor for the market\\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\\n     */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external virtual override view returns (uint) {\\n        return getSupplyRateInternal(cash, borrows, reserves, reserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Internal function to update the parameters of the interest rate model\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     */\\n    function updateJumpRateModelInternal(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) internal onlyOwner {\\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\\n        multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(blocksPerYear.mul(kink_));\\n        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\\n        kink = kink_;\\n\\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rate/JumpRateModel.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./BaseJumpRateModel.sol\\\";\\n\\n\\n/**\\n  * @title Compound's JumpRateModel Contract V2 for V2 cTokens\\n  * @author Arr00\\n  * @notice Supports only for V2 cTokens\\n  */\\ncontract JumpRateModel is BaseJumpRateModel {\\n\\n    function initialize(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) public initializer {\\n        super.__Ownable_init();\\n        super.updateJumpRateModelInternal(baseRatePerYear,  multiplierPerYear, jumpMultiplierPerYear, kink_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rate/DAIInterestRateModel.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./BaseJumpRateModel.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n  * @title Compound's DAIInterestRateModel Contract (version 3)\\n  * @author Compound (modified by Dharma Labs)\\n  * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper.\\n  * Version 3 modifies the interest rate model in Version 2 by increasing the initial \\\"gap\\\" or slope of\\n  * the model prior to the \\\"kink\\\" from 2% to 4%, and enabling updateable parameters.\\n  */\\ncontract DAIInterestRateModel is BaseJumpRateModel {\\n    using SafeMath for uint;\\n\\n    /**\\n     * @notice The additional margin per block separating the base borrow rate from the roof.\\n     */\\n    uint public gapPerBlock;\\n\\n    /**\\n     * @notice The assumed (1 - reserve factor) used to calculate the minimum borrow rate (reserve factor = 0.05)\\n     */\\n    uint public constant assumedOneMinusReserveFactorMantissa = 0.95e18;\\n\\n    PotLike pot;\\n    JugLike jug;\\n\\n    /**\\n     * @notice Construct an interest rate model\\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     * @param pot_ The address of the Dai pot (where DSR is earned)\\n     * @param jug_ The address of the Dai jug (where SF is kept)\\n     */\\n    function initialize(uint jumpMultiplierPerYear, uint kink_, address pot_, address jug_) public initializer {\\n        super.__Ownable_init();\\n        super.updateJumpRateModelInternal(0, 0, jumpMultiplierPerYear, kink_);\\n        gapPerBlock = 4e16 / blocksPerYear;\\n        pot = PotLike(pot_);\\n        jug = JugLike(jug_);\\n        poke();\\n    }\\n\\n    /**\\n     * @notice External function to update the parameters of the interest rate model\\n     * @param gapPerYear The Additional margin per year separating the base borrow rate from the roof. (scaled by 1e18)\\n     * @param jumpMultiplierPerYear The jumpMultiplierPerYear after hitting a specified utilization point\\n     * @param kink_ The utilization point at which the jump multiplier is applied\\n     */\\n    function updateDAIJumpRateModel(uint gapPerYear, uint jumpMultiplierPerYear, uint kink_) external {\\n        gapPerBlock = gapPerYear / blocksPerYear;\\n        updateJumpRateModelInternal(0, 0, jumpMultiplierPerYear, kink_);\\n        poke();\\n    }\\n\\n    /**\\n     * @notice Calculates the current supply interest rate per block including the Dai savings rate\\n     * @param cash The total amount of cash the market has\\n     * @param borrows The total amount of borrows the market has outstanding\\n     * @param reserves The total amnount of reserves the market has\\n     * @param reserveFactorMantissa The current reserve factor the market has\\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n     */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external override view returns (uint) {\\n        uint protocolRate = getSupplyRateInternal(cash, borrows, reserves, reserveFactorMantissa);\\n\\n        uint underlying = cash.add(borrows).sub(reserves);\\n        if (underlying == 0) {\\n            return protocolRate;\\n        } else {\\n            uint cashRate = cash.mul(dsrPerBlock()).div(underlying);\\n            return cashRate.add(protocolRate);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the Dai savings rate per block\\n     * @return The Dai savings rate per block (as a percentage, and scaled by 1e18)\\n     */\\n    function dsrPerBlock() public view returns (uint) {\\n        return pot\\n            .dsr().sub(1e27)  // scaled 1e27 aka RAY, and includes an extra \\\"ONE\\\" before subraction\\n            .div(1e9) // descale to 1e18\\n            .mul(15); // 15 seconds per block\\n    }\\n\\n    /**\\n     * @notice Resets the baseRate and multiplier per block based on the stability fee and Dai savings rate\\n     */\\n    function poke() public {\\n        (uint duty, ) = jug.ilks(\\\"ETH-A\\\");\\n        uint stabilityFeePerBlock = duty.add(jug.base()).sub(1e27).mul(1e18).div(1e27).mul(15);\\n\\n        // We ensure the minimum borrow rate >= DSR / (1 - reserve factor)\\n        baseRatePerBlock = dsrPerBlock().mul(1e18).div(assumedOneMinusReserveFactorMantissa);\\n\\n        // The roof borrow rate is max(base rate, stability fee) + gap, from which we derive the slope\\n        if (baseRatePerBlock < stabilityFeePerBlock) {\\n            multiplierPerBlock = stabilityFeePerBlock.sub(baseRatePerBlock).add(gapPerBlock).mul(1e18).div(kink);\\n        } else {\\n            multiplierPerBlock = gapPerBlock.mul(1e18).div(kink);\\n        }\\n\\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\\n    }\\n}\\n\\n\\n/*** Maker Interfaces ***/\\n\\ninterface PotLike {\\n    function chi() external view returns (uint);\\n    function dsr() external view returns (uint);\\n    function rho() external view returns (uint);\\n    function pie(address) external view returns (uint);\\n    function drip() external returns (uint);\\n    function join(uint) external;\\n    function exit(uint) external;\\n}\\n\\ncontract JugLike {\\n    // --- Data ---\\n    struct Ilk {\\n        uint256 duty;\\n        uint256  rho;\\n    }\\n\\n   mapping (bytes32 => Ilk) public ilks;\\n   uint256 public base;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Timelock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\ncontract Timelock is OwnableUpgradeSafe {\\n    using SafeMath for uint;\\n\\n    event NewDelay(uint indexed newDelay);\\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\\n\\n    uint public constant GRACE_PERIOD = 14 days;\\n    uint public constant MINIMUM_DELAY = 2 days;\\n    uint public constant MAXIMUM_DELAY = 30 days;\\n\\n    uint public delay;\\n\\n    mapping (bytes32 => bool) public queuedTransactions;\\n\\n\\n    function initialize(uint delay_) public initializer {\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::initialize: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::initialize: Delay must not exceed maximum delay.\\\");\\n\\n        delay = delay_;\\n        OwnableUpgradeSafe.__Ownable_init();\\n    }\\n\\n    function setDelay(uint delay_) public {\\n        require(msg.sender == address(this), \\\"Timelock::setDelay: Call must come from Timelock.\\\");\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::setDelay: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n        delay = delay_;\\n\\n        emit NewDelay(delay);\\n    }\\n\\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public onlyOwner returns (bytes32)  {\\n        require(eta >= getBlockTimestamp().add(delay), \\\"Timelock::queueTransaction: Estimated execution block must satisfy delay.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = true;\\n\\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\\n        return txHash;\\n    }\\n\\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public onlyOwner {\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = false;\\n\\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\\n    }\\n\\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable onlyOwner returns (bytes memory) {\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        require(queuedTransactions[txHash], \\\"Timelock::executeTransaction: Transaction hasn't been queued.\\\");\\n        require(getBlockTimestamp() >= eta, \\\"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\\\");\\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \\\"Timelock::executeTransaction: Transaction is stale.\\\");\\n\\n        queuedTransactions[txHash] = false;\\n\\n        bytes memory callData;\\n\\n        if (bytes(signature).length == 0) {\\n            callData = data;\\n        } else {\\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n        }\\n\\n        // solium-disable-next-line security/no-call-value\\n        (bool success, bytes memory returnData) = target.call{value:value}(callData);\\n        require(success, \\\"Timelock::executeTransaction: Transaction execution reverted.\\\");\\n\\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\\n\\n        return returnData;\\n    }\\n\\n    function getBlockTimestamp() internal view returns (uint) {\\n        // solium-disable-next-line security/no-block-members\\n        return block.timestamp;\\n    }\\n}\"\r\n    },\r\n    \"contracts/token/IPERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"../comptroller/IComptroller.sol\\\";\\nimport \\\"../rate/IInterestRateModel.sol\\\";\\nimport \\\"./IPToken.sol\\\";\\nimport \\\"./PERC20Storage.sol\\\";\\n\\ninterface IPERC20 {\\n    /*** User Interface ***/\\n\\n    function mint(uint256 mintAmount) external returns (uint256);\\n\\n    function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\\n    external\\n    returns (uint256);\\n\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        IPToken pTokenCollateral\\n    ) external returns (uint256);\\n\\n    /*** Admin Functions ***/\\n\\n    function _addReserves(uint256 addAmount) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/token/PERC20Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ncontract PERC20Storage {\\n    /**\\n     * @notice Underlying asset for this CToken\\n     */\\n    address public underlying;\\n}\\n\"\r\n    },\r\n    \"contracts/token/PEther.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"./PToken.sol\\\";\\nimport \\\"../comptroller/IComptroller.sol\\\";\\n\\ncontract PEther is PToken {\\n    /**\\n     * @notice Construct a new PEther money market\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     */\\n    function initialize(IComptroller comptroller_,\\n        IInterestRateModel interestRateModel_,\\n        uint initialExchangeRateMantissa_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_) public initializer {\\n        super.__Ownable_init();\\n        super.init(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\\n    }\\n    /*** User Interface ***/\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Reverts upon any failure\\n     */\\n    function mint() external payable {\\n        (uint err,) = mintInternal(msg.value);\\n        requireNoError(err, \\\"mint failed\\\");\\n    }\\n\\n    function mintForMigrate(uint mintTokens) external payable {\\n        (uint err,) = mintInternalForMigrate(msg.value, mintTokens);\\n        requireNoError(err, \\\"mint failed\\\");\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeem(uint redeemTokens) external returns (uint) {\\n        return redeemInternal(redeemTokens);\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to redeem\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\\n        return redeemUnderlyingInternal(redeemAmount);\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrow(uint borrowAmount) external returns (uint) {\\n        return borrowInternal(borrowAmount);\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @dev Reverts upon any failure\\n     */\\n    function repayBorrow() external payable {\\n        (uint err,) = repayBorrowInternal(msg.value);\\n        requireNoError(err, \\\"repayBorrow failed\\\");\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @dev Reverts upon any failure\\n     * @param borrower the account with the debt being payed off\\n     */\\n    function repayBorrowBehalf(address borrower) external payable {\\n        (uint err,) = repayBorrowBehalfInternal(borrower, msg.value);\\n        requireNoError(err, \\\"repayBorrowBehalf failed\\\");\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @dev Reverts upon any failure\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param pTokenCollateral The market in which to seize collateral from the borrower\\n     */\\n    function liquidateBorrow(address borrower, PToken pTokenCollateral) external payable {\\n        (uint err,) = liquidateBorrowInternal(borrower, msg.value, pTokenCollateral);\\n        requireNoError(err, \\\"liquidateBorrow failed\\\");\\n    }\\n\\n    /**\\n     * @notice Send Ether to CEther to mint\\n     */\\n    receive() external payable {\\n        (uint err,) = mintInternal(msg.value);\\n        requireNoError(err, \\\"mint failed\\\");\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of Ether, before this message\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of Ether owned by this contract\\n     */\\n    function getCashPrior() internal override view returns (uint) {\\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\\n        require(err == MathError.NO_ERROR);\\n        return startingBalance;\\n    }\\n\\n    /**\\n     * @notice Perform the actual transfer in, which is a no-op\\n     * @param from Address sending the Ether\\n     * @param amount Amount of Ether being sent\\n     * @return The actual amount of Ether transferred\\n     */\\n    function doTransferIn(address from, uint amount) internal override returns (uint) {\\n        // Sanity checks\\n        require(msg.sender == from, \\\"sender mismatch\\\");\\n        require(msg.value == amount, \\\"value mismatch\\\");\\n        return amount;\\n    }\\n\\n    function doTransferOut(address payable to, uint amount) internal override {\\n        /* Send the Ether, with minimal gas and revert on failure */\\n        to.transfer(amount);\\n    }\\n\\n    function requireNoError(uint errCode, string memory message) internal pure {\\n        if (errCode == uint(Error.NO_ERROR)) {\\n            return;\\n        }\\n\\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\\n        uint i;\\n\\n        for (i = 0; i < bytes(message).length; i++) {\\n            fullMessage[i] = bytes(message)[i];\\n        }\\n\\n        fullMessage[i+0] = byte(uint8(32));\\n        fullMessage[i+1] = byte(uint8(40));\\n        fullMessage[i+2] = byte(uint8(48 + ( errCode / 10 )));\\n        fullMessage[i+3] = byte(uint8(48 + ( errCode % 10 )));\\n        fullMessage[i+4] = byte(uint8(41));\\n\\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/farm/migrator/CEthMigrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./CTokenInterface.sol\\\";\\nimport \\\"../../token/PEther.sol\\\";\\n\\ncontract CEthMigrator {\\n\\n    address public breeder;\\n    uint256 public notBeforeBlock;\\n    address payable public targetToken;\\n\\n    event Received(address, uint);\\n\\n    constructor (address _breeder, uint256 _notBeforeBlock, address payable _targetToken) public {\\n        breeder = _breeder;\\n        notBeforeBlock = _notBeforeBlock;\\n        targetToken = _targetToken;\\n    }\\n\\n\\n    function replaceMigrate(CTokenInterface oldLpToken) external payable returns (PEther, uint){\\n\\n        require(msg.sender == breeder, \\\"not from breeder\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n\\n        address self = address(this);\\n        address sender = msg.sender;\\n        uint256 lp = oldLpToken.balanceOf(sender);\\n\\n        PEther newLpToken = PEther(targetToken);\\n        if (lp == 0) {\\n            return (newLpToken, 0);\\n        }\\n\\n        // 从cToken中赎回相应的代币\\n        oldLpToken.transferFrom(sender, self, lp);\\n        oldLpToken.redeem(lp);\\n\\n        //获得赎回了多少代币\\n        uint redeemBal = self.balance;\\n\\n        // 将赎回的代币，抵押到wePiggy中，生成pToken\\n        newLpToken.mintForMigrate.value(redeemBal)(lp);\\n\\n        // 获得抵押生成的pToken有多少\\n        uint mintBal = newLpToken.balanceOf(self);\\n\\n        //将余额转到挖矿合约\\n        newLpToken.transferFrom(self, sender, mintBal);\\n\\n        //返回占比\\n        return (newLpToken, mintBal);\\n    }\\n\\n    function migrate(CTokenInterface oldLpToken) external payable returns (PEther, uint){\\n\\n        require(msg.sender == breeder, \\\"not from breeder\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n\\n        address self = address(this);\\n        address sender = msg.sender;\\n        uint256 lp = oldLpToken.balanceOf(sender);\\n\\n        PEther newLpToken = PEther(targetToken);\\n        if (lp == 0) {\\n            return (newLpToken, 0);\\n        }\\n\\n        // 从cToken中赎回相应的代币\\n        oldLpToken.transferFrom(sender, self, lp);\\n        oldLpToken.redeem(lp);\\n\\n        //获得赎回了多少代币\\n        uint redeemBal = self.balance;\\n\\n        // 将赎回的代币，抵押到wePiggy中，生成pToken\\n        newLpToken.mint.value(redeemBal)();\\n\\n        // 获得抵押生成的pToken有多少\\n        uint mintBal = newLpToken.balanceOf(self);\\n\\n        //将余额转到挖矿合约\\n        newLpToken.transferFrom(self, sender, mintBal);\\n\\n        //返回占比\\n        return (newLpToken, mintBal);\\n    }\\n\\n    receive() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n}\\n\\n\\n\\n\"\r\n    },\r\n    \"contracts/farm/migrator/CTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface CTokenInterface {\\n\\n    function transfer(address dst, uint amount) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\n\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n\\n    function balanceOfUnderlying(address owner) external returns (uint);\\n\\n    function redeem(uint redeemTokens) external returns (uint);\\n\\n    function underlying() external view returns (address);\\n\\n}\\n\\n\\n\"\r\n    },\r\n    \"contracts/farm/migrator/CErc20Migrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./CTokenInterface.sol\\\";\\nimport \\\"../../token/PERC20.sol\\\";\\n\\n//第一次进行cERC20迁移\\ncontract CErc20Migrator {\\n\\n    address public breeder;\\n    uint256 public notBeforeBlock;\\n    address targetToken;\\n\\n    constructor(address _breeder, uint256 _notBeforeBlock, address _targetToken) public {\\n        breeder = _breeder;\\n        notBeforeBlock = _notBeforeBlock;\\n        targetToken = _targetToken;\\n    }\\n\\n\\n    function replaceMigrate(CTokenInterface oldLpToken) external returns (PERC20, uint){\\n\\n        require(msg.sender == breeder, \\\"not from breeder\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n\\n        PERC20 newLpToken = PERC20(targetToken);\\n        require(oldLpToken.underlying() == newLpToken.underlying(), \\\"not match\\\");\\n\\n        address sender = msg.sender;\\n        uint256 lp = oldLpToken.balanceOf(sender);\\n\\n        if (lp == 0) {\\n            return (newLpToken, 0);\\n        }\\n\\n        // 从cToken中赎回相应的代币\\n        oldLpToken.transferFrom(sender, address(this), lp);\\n        oldLpToken.redeem(lp);\\n\\n        //获得赎回了多少代币\\n        uint redeemBal = 0;\\n        address underlying = oldLpToken.underlying();\\n\\n        IERC20 token = IERC20(underlying);\\n        redeemBal = token.balanceOf(address(this));\\n\\n        // 将赎回的代币，抵押到wePiggy中，生成pToken\\n        token.approve(address(newLpToken), redeemBal);\\n        newLpToken.mintForMigrate(redeemBal, lp);\\n\\n        // 获得抵押生成的pToken有多少\\n        uint mintBal = newLpToken.balanceOf(address(this));\\n\\n        //将余额转到挖矿合约\\n        newLpToken.transferFrom(address(this), sender, mintBal);\\n\\n        //返回占比\\n        return (newLpToken, mintBal);\\n    }\\n\\n    function migrate(CTokenInterface oldLpToken) external returns (PERC20, uint){\\n\\n        require(msg.sender == breeder, \\\"not from breeder\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n\\n        PERC20 newLpToken = PERC20(targetToken);\\n        require(oldLpToken.underlying() == newLpToken.underlying(), \\\"not match\\\");\\n\\n        address sender = msg.sender;\\n        uint256 lp = oldLpToken.balanceOf(sender);\\n\\n        if (lp == 0) {\\n            return (newLpToken, 0);\\n        }\\n\\n        // 从cToken中赎回相应的代币\\n        oldLpToken.transferFrom(sender, address(this), lp);\\n        oldLpToken.redeem(lp);\\n\\n        //获得赎回了多少代币\\n        uint redeemBal = 0;\\n        address underlying = oldLpToken.underlying();\\n\\n        IERC20 token = IERC20(underlying);\\n        redeemBal = token.balanceOf(address(this));\\n\\n        // 将赎回的代币，抵押到wePiggy中，生成pToken\\n        token.approve(address(newLpToken), redeemBal);\\n        newLpToken.mint(redeemBal);\\n\\n        // 获得抵押生成的pToken有多少\\n        uint mintBal = newLpToken.balanceOf(address(this));\\n\\n        //将余额转到挖矿合约\\n        newLpToken.transferFrom(address(this), sender, mintBal);\\n\\n        //返回占比\\n        return (newLpToken, mintBal);\\n    }\\n}\\n\\n\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/token/PERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"./PToken.sol\\\";\\nimport \\\"./IPERC20.sol\\\";\\nimport \\\"./IEIP20.sol\\\";\\nimport \\\"./IEIP20NonStandard.sol\\\";\\n\\ncontract PERC20 is PToken, IPERC20, PERC20Storage {\\n    /**\\n     * @notice Initialize the new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     */\\n    function initialize(address underlying_,\\n        IComptroller comptroller_,\\n        IInterestRateModel interestRateModel_,\\n        uint initialExchangeRateMantissa_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_) public initializer {\\n\\n        super.__Ownable_init();\\n\\n        // PToken initialize does the bulk of the work\\n        super.init(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\\n\\n        // Set underlying and sanity check it\\n        underlying = underlying_;\\n        IEIP20(underlying).totalSupply();\\n    }\\n\\n    /*** User Interface ***/\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function mint(uint mintAmount) external override returns (uint) {\\n        (uint err,) = mintInternal(mintAmount);\\n        return err;\\n    }\\n\\n    function mintForMigrate(uint mintAmount, uint mintTokens) external returns (uint) {\\n        (uint err,) = mintInternalForMigrate(mintAmount, mintTokens);\\n        return err;\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeem(uint redeemTokens) external override returns (uint) {\\n        return redeemInternal(redeemTokens);\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to redeem\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlying(uint redeemAmount) external override returns (uint) {\\n        return redeemUnderlyingInternal(redeemAmount);\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrow(uint borrowAmount) external override returns (uint) {\\n        return borrowInternal(borrowAmount);\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrow(uint repayAmount) external override returns (uint) {\\n        (uint err,) = repayBorrowInternal(repayAmount);\\n        return err;\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override returns (uint) {\\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\\n        return err;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function liquidateBorrow(address borrower, uint repayAmount, IPToken cTokenCollateral) external override returns (uint) {\\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\\n        return err;\\n    }\\n\\n    /**\\n     * @notice The sender adds to reserves.\\n     * @param addAmount The amount fo underlying token to add as reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReserves(uint addAmount) external override returns (uint) {\\n        return _addReservesInternal(addAmount);\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying tokens owned by this contract\\n     */\\n    function getCashPrior() internal override view returns (uint) {\\n        IEIP20 token = IEIP20(underlying);\\n        return token.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\n     *      This will revert due to insufficient balance or insufficient allowance.\\n     *      This function returns the actual amount received,\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferIn(address from, uint amount) internal override returns (uint) {\\n        IEIP20NonStandard token = IEIP20NonStandard(underlying);\\n        uint balanceBefore = IEIP20(underlying).balanceOf(address(this));\\n        token.transferFrom(from, address(this), amount);\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n            case 0 {// This is a non-standard ERC-20\\n                success := not(0)          // set success to true\\n            }\\n            case 32 {// This is a compliant ERC-20\\n                returndatacopy(0, 0, 32)\\n                success := mload(0)        // Set `success = returndata` of external call\\n            }\\n            default {// This is an excessively non-compliant ERC-20, revert.\\n                revert(0, 0)\\n            }\\n        }\\n        require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\n\\n        // Calculate the amount that was *actually* transferred\\n        uint balanceAfter = IEIP20(underlying).balanceOf(address(this));\\n        require(balanceAfter >= balanceBefore, \\\"TOKEN_TRANSFER_IN_OVERFLOW\\\");\\n        return balanceAfter - balanceBefore;\\n        // underflow already checked above, just subtract\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\n     *      it is >= amount, this should not revert in normal conditions.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferOut(address payable to, uint amount) internal override {\\n        IEIP20NonStandard token = IEIP20NonStandard(underlying);\\n        token.transfer(to, amount);\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n            case 0 {// This is a non-standard ERC-20\\n                success := not(0)          // set success to true\\n            }\\n            case 32 {// This is a complaint ERC-20\\n                returndatacopy(0, 0, 32)\\n                success := mload(0)        // Set `success = returndata` of external call\\n            }\\n            default {// This is an excessively non-compliant ERC-20, revert.\\n                revert(0, 0)\\n            }\\n        }\\n        require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/IEIP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title ERC 20 Token Standard Interface\\n *  https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IEIP20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n      * @notice Get the total number of tokens in circulation\\n      * @return The supply of tokens\\n      */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return success Whether or not the transfer succeeded\\n      */\\n    function transfer(address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return success Whether or not the transfer succeeded\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\n      * @return success Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent (-1 means infinite)\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/token/IEIP20NonStandard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title IEIP20NonStandard\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface IEIP20NonStandard {\\n\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return The supply of tokens\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transfer(address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external;\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved\\n      * @return success Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/SimplePriceOracle.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../token/PERC20.sol\\\";\\nimport \\\"./IPriceOracle.sol\\\";\\nimport \\\"../token/PToken.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\\\";\\n\\ncontract SimplePriceOracle is IPriceOracle, OwnableUpgradeSafe {\\n\\n    struct Datum {\\n        uint timestamp;\\n        uint price;\\n    }\\n\\n    mapping(address => Datum) private data;\\n\\n    address private _pETHUnderlying;\\n\\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa, uint timestamp);\\n\\n    function initialize() public initializer {\\n        _pETHUnderlying = address(0x0000000000000000000000000000000000000000);\\n        OwnableUpgradeSafe.__Ownable_init();\\n    }\\n\\n\\n    function getUnderlyingPrice(PToken pToken) public override view returns (uint) {\\n        if (compareStrings(pToken.symbol(), \\\"pETH\\\") || compareStrings(pToken.symbol(), \\\"cETH\\\")) {\\n            return data[_pETHUnderlying].price;\\n        } else {\\n            return data[address(PERC20(address(pToken)).underlying())].price;\\n        }\\n    }\\n\\n    function setUnderlyingPrice(PToken pToken, uint price) public onlyOwner {\\n        address asset = _pETHUnderlying;\\n        if (!compareStrings(pToken.symbol(), \\\"pETH\\\") || !compareStrings(pToken.symbol(), \\\"cETH\\\")) {\\n            asset = address(PERC20(address(pToken)).underlying());\\n        }\\n        uint bt = block.timestamp;\\n        data[asset] = Datum(bt, price);\\n        emit PricePosted(asset, data[asset].price, price, price, bt);\\n    }\\n\\n    function setPrice(address asset, uint price) public onlyOwner {\\n        uint bt = block.timestamp;\\n        emit PricePosted(asset, data[asset].price, price, price, bt);\\n        data[asset] = Datum(bt, price);\\n    }\\n\\n    function getPrice(address asset) external view returns (uint) {\\n        return data[asset].price;\\n    }\\n\\n    function get(address asset) external view returns (uint256, uint)  {\\n        return (data[asset].timestamp, data[asset].price);\\n    }\\n\\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/farm/migrator/ATokenMigrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./ATokenInterface.sol\\\";\\nimport \\\"../../token/PEther.sol\\\";\\nimport \\\"../../token/PERC20.sol\\\";\\n\\ncontract ATokenMigrator {\\n    address public breeder;\\n    uint256 public notBeforeBlock;\\n    address payable targetToken;\\n\\n    constructor (address _breeder, uint256 _notBeforeBlock, address payable _targetToken) public {\\n        breeder = _breeder;\\n        notBeforeBlock = _notBeforeBlock;\\n        targetToken = _targetToken;\\n    }\\n\\n\\n    function replaceMigrate(ATokenInterface oldLpToken) external payable returns (PToken, uint){\\n\\n        uint mintBal = 0;\\n\\n        require(msg.sender == breeder, \\\"not from breeder\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n\\n        address sender = msg.sender;\\n        uint256 lp = oldLpToken.balanceOf(sender);\\n\\n        require(lp > 0, \\\"balance must bigger than 0\\\");\\n\\n        // 从aToken中赎回相应的代币\\n        oldLpToken.transferFrom(sender, address(this), lp);\\n        oldLpToken.redeem(lp);\\n\\n        address underlyingAssetAddress = oldLpToken.underlyingAssetAddress();\\n        if (underlyingAssetAddress == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\\n\\n            address self = address(this);\\n            address sender = msg.sender;\\n            uint256 lp = oldLpToken.balanceOf(sender);\\n\\n            PEther newLpToken = PEther(targetToken);\\n            if (lp == 0) {\\n                return (newLpToken, 0);\\n            }\\n\\n            // 从cToken中赎回相应的代币\\n            oldLpToken.transferFrom(sender, self, lp);\\n            oldLpToken.redeem(lp);\\n\\n            //获得赎回了多少代币\\n            uint redeemBal = self.balance;\\n\\n            // 将赎回的代币，抵押到wePiggy中，生成pToken\\n            newLpToken.mintForMigrate.value(redeemBal)(lp);\\n\\n            // 获得抵押生成的pToken有多少\\n            uint mintBal = newLpToken.balanceOf(self);\\n\\n            //将余额转到挖矿合约\\n            newLpToken.transferFrom(self, sender, mintBal);\\n\\n            //返回占比\\n            return (newLpToken, mintBal);\\n\\n        } else {\\n\\n            PERC20 newLpToken = PERC20(targetToken);\\n            require(underlyingAssetAddress == newLpToken.underlying(), \\\"not match\\\");\\n\\n            address sender = msg.sender;\\n            uint256 lp = oldLpToken.balanceOf(sender);\\n\\n            if (lp == 0) {\\n                return (newLpToken, 0);\\n            }\\n\\n            // 从cToken中赎回相应的代币\\n            oldLpToken.transferFrom(sender, address(this), lp);\\n            oldLpToken.redeem(lp);\\n\\n            //获得赎回了多少代币\\n            uint redeemBal = 0;\\n            IERC20 token = IERC20(underlyingAssetAddress);\\n            redeemBal = token.balanceOf(address(this));\\n\\n            // 将赎回的代币，抵押到wePiggy中，生成pToken\\n            token.approve(address(newLpToken), redeemBal);\\n            newLpToken.mintForMigrate(redeemBal, lp);\\n\\n            // 获得抵押生成的pToken有多少\\n            uint mintBal = newLpToken.balanceOf(address(this));\\n\\n            //将余额转到挖矿合约\\n            newLpToken.transferFrom(address(this), sender, mintBal);\\n\\n            return (newLpToken, mintBal);\\n        }\\n\\n    }\\n\\n\\n    function migrate(ATokenInterface oldLpToken) external payable returns (PToken, uint){\\n\\n        uint mintBal = 0;\\n\\n        require(msg.sender == breeder, \\\"not from breeder\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n\\n        address sender = msg.sender;\\n        uint256 lp = oldLpToken.balanceOf(sender);\\n\\n        require(lp > 0, \\\"balance must bigger than 0\\\");\\n\\n        // 从aToken中赎回相应的代币\\n        oldLpToken.transferFrom(sender, address(this), lp);\\n        oldLpToken.redeem(lp);\\n\\n        address underlyingAssetAddress = oldLpToken.underlyingAssetAddress();\\n        if (underlyingAssetAddress == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\\n\\n            address self = address(this);\\n            address sender = msg.sender;\\n            uint256 lp = oldLpToken.balanceOf(sender);\\n\\n            PEther newLpToken = PEther(targetToken);\\n            if (lp == 0) {\\n                return (newLpToken, 0);\\n            }\\n\\n            // 从cToken中赎回相应的代币\\n            oldLpToken.transferFrom(sender, self, lp);\\n            oldLpToken.redeem(lp);\\n\\n            //获得赎回了多少代币\\n            uint redeemBal = self.balance;\\n\\n            // 将赎回的代币，抵押到wePiggy中，生成pToken\\n            newLpToken.mint.value(redeemBal)();\\n\\n            // 获得抵押生成的pToken有多少\\n            uint mintBal = newLpToken.balanceOf(self);\\n\\n            //将余额转到挖矿合约\\n            newLpToken.transferFrom(self, sender, mintBal);\\n\\n            //返回占比\\n            return (newLpToken, mintBal);\\n\\n        } else {\\n\\n            PERC20 newLpToken = PERC20(targetToken);\\n            require(underlyingAssetAddress == newLpToken.underlying(), \\\"not match\\\");\\n\\n            address sender = msg.sender;\\n            uint256 lp = oldLpToken.balanceOf(sender);\\n\\n            if (lp == 0) {\\n                return (newLpToken, 0);\\n            }\\n\\n            // 从cToken中赎回相应的代币\\n            oldLpToken.transferFrom(sender, address(this), lp);\\n            oldLpToken.redeem(lp);\\n\\n            //获得赎回了多少代币\\n            uint redeemBal = 0;\\n            IERC20 token = IERC20(underlyingAssetAddress);\\n            redeemBal = token.balanceOf(address(this));\\n\\n            // 将赎回的代币，抵押到wePiggy中，生成pToken\\n            token.approve(address(newLpToken), redeemBal);\\n            newLpToken.mint(redeemBal);\\n\\n            // 获得抵押生成的pToken有多少\\n            uint mintBal = newLpToken.balanceOf(address(this));\\n\\n            //将余额转到挖矿合约\\n            newLpToken.transferFrom(address(this), sender, mintBal);\\n\\n            return (newLpToken, mintBal);\\n        }\\n\\n    }\\n\\n    receive() external payable {\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/farm/migrator/ATokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface ATokenInterface {\\n\\n    function transfer(address dst, uint amount) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\n\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n\\n    function redeem(uint256 _amount) external;\\n\\n    function underlyingAssetAddress() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/MockErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n\\ncontract MockERC20 is ERC20 {\\n\\n    constructor(string memory name, string memory symbol, uint256 initialSupply) public ERC20(name, symbol){\\n        _mint(msg.sender, initialSupply);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/FundingManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../token/WePiggyToken.sol\\\";\\n\\ncontract FundingManager is Ownable {\\n\\n    using SafeMath for uint256;\\n\\n    struct FundingHolderInfo {\\n        uint256 ratio;\\n        string name;\\n        address addr;\\n    }\\n\\n    // The WePiggyToken !\\n    WePiggyToken public piggy;\\n\\n    // Info of each funding.\\n    FundingHolderInfo[] public fundingHolders;\\n\\n    constructor(WePiggyToken _piggy) public {\\n        piggy = _piggy;\\n    }\\n\\n\\n    // Safe piggy transfer function, just in case if rounding error causes pool to not have enough PiggyToken.\\n    function safePiggyTransfer(address _to, uint256 _amount) internal {\\n        uint256 piggyBal = piggy.balanceOf(address(this));\\n        if (_amount > piggyBal) {\\n            piggy.transfer(_to, piggyBal);\\n        } else {\\n            piggy.transfer(_to, _amount);\\n        }\\n    }\\n\\n    //Update funding pool\\n    function addFunding(string memory _name, address _addr, uint256 _ratio) public onlyOwner {\\n\\n        fundingHolders.push(FundingHolderInfo({\\n        name : _name,\\n        addr : _addr,\\n        ratio : _ratio\\n        }));\\n\\n    }\\n\\n    //Update funding pool\\n    function setFunding(uint256 pid, string memory _name, address _addr, uint256 _ratio) public onlyOwner {\\n\\n        FundingHolderInfo storage fhi = fundingHolders[pid];\\n\\n        fhi.name = _name;\\n        fhi.addr = _addr;\\n        fhi.ratio = _ratio;\\n    }\\n\\n    // Return the pool pending balance.\\n    function getPendingBalance(uint256 pid) public view returns (uint256){\\n        FundingHolderInfo storage fhi = fundingHolders[pid];\\n        uint256 piggyBal = piggy.balanceOf(address(this));\\n        uint _amount = piggyBal.mul(fhi.ratio).div(100);\\n        return _amount;\\n    }\\n\\n    //claim wpc. every can call this function, but transfer token to\\n    function claim() public {\\n        uint256 piggyBal = piggy.balanceOf(address(this));\\n        for (uint256 i = 0; i < fundingHolders.length; i++) {\\n            FundingHolderInfo storage fhi = fundingHolders[i];\\n            uint _amount = piggyBal.mul(fhi.ratio).div(100);\\n            safePiggyTransfer(fhi.addr, _amount);\\n        }\\n\\n    }\\n\\n    receive() external payable {\\n    }\\n}\"\r\n    },\r\n    \"contracts/token/WePiggyToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n// Copied and modified from SUSHI code:\\n// https://github.com/sushiswap/sushiswap/blob/master/contracts/SushiToken.sol\\n// WePiggyToken with Governance.\\ncontract WePiggyToken is ERC20, AccessControl {\\n\\n    // Create a new role identifier for the minter role\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    constructor() public ERC20(\\\"WePiggyCoin\\\", \\\"WPC\\\") {\\n\\n        // Grant the contract deployer the default admin role: it will be able\\n        // to grant and revoke any roles\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    }\\n\\n    /// @notice Creates `_amount` token to `_to`.Must only be called by the minter role.\\n    function mint(address _to, uint256 _amount) public {\\n\\n        // Check that the calling account has the minter role\\n       // require(hasRole(MINTER_ROLE, msg.sender), \\\"Caller is not a minter\\\");\\n\\n        _mint(_to, _amount);\\n        _moveDelegates(address(0), _delegates[_to], _amount);\\n    }\\n\\n\\n    // Copied and modified from YAM code:\\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\\n    // Which is copied and modified from COMPOUND:\\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\\n\\n    /// @dev A record of each accounts delegate\\n    mapping(address => address) internal _delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint256 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping(address => uint32) public numCheckpoints;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping(address => uint) public nonces;\\n\\n    /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegator The address to get delegatee for\\n     */\\n    function delegates(address delegator)\\n    external\\n    view\\n    returns (address)\\n    {\\n        return _delegates[delegator];\\n    }\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     */\\n    function delegate(address delegatee) external {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint nonce,\\n        uint expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n    external\\n    {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(name())),\\n                getChainId(),\\n                address(this)\\n            )\\n        );\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                DELEGATION_TYPEHASH,\\n                delegatee,\\n                nonce,\\n                expiry\\n            )\\n        );\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                domainSeparator,\\n                structHash\\n            )\\n        );\\n\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"WePiggyToken::delegateBySig: invalid signature\\\");\\n        require(nonce == nonces[signatory]++, \\\"WePiggyToken::delegateBySig: invalid nonce\\\");\\n        require(now <= expiry, \\\"WePiggyToken::delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account)\\n    external\\n    view\\n    returns (uint256)\\n    {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber)\\n    external\\n    view\\n    returns (uint256)\\n    {\\n        require(blockNumber < block.number, \\\"WePiggyToken::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2;\\n            // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    function _delegate(address delegator, address delegatee)\\n    internal\\n    {\\n        address currentDelegate = _delegates[delegator];\\n        uint256 delegatorBalance = balanceOf(delegator);\\n        // balance of underlying WePiggyTokens (not scaled);\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                // decrease old representative\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint256 srcRepNew = srcRepOld.sub(amount);\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                // increase new representative\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint256 dstRepNew = dstRepOld.add(amount);\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint32 nCheckpoints,\\n        uint256 oldVotes,\\n        uint256 newVotes\\n    )\\n    internal\\n    {\\n        uint32 blockNumber = safe32(block.number, \\\"WePiggyToken::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n        } else {\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2 ** 32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint256 chainId;\\n        assembly {chainId := chainid()}\\n        return chainId;\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/governance/FundingHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../token/WePiggyToken.sol\\\";\\n\\n// funding holder. Will call by gnosis-safe\\ncontract FundingHolder is Ownable {\\n\\n    // The WePiggyToken !\\n    WePiggyToken public piggy;\\n\\n    constructor(WePiggyToken _piggy) public {\\n        piggy = _piggy;\\n    }\\n\\n    // only owner can call this function.\\n    function transfer(address _to, uint256 _amount) public onlyOwner {\\n        uint256 piggyBal = piggy.balanceOf(address(this));\\n        if (_amount > piggyBal) {\\n            piggy.transfer(_to, piggyBal);\\n        } else {\\n            piggy.transfer(_to, _amount);\\n        }\\n    }\\n\\n    receive() external payable {\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/farm/PiggyBreeder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../token/WePiggyToken.sol\\\";\\n\\n// Copied and modified from sushiswap code:\\n// https://github.com/sushiswap/sushiswap/blob/master/contracts/MasterChef.sol\\n\\ninterface IMigrator {\\n    function replaceMigrate(IERC20 lpToken) external returns (IERC20, uint);\\n\\n    function migrate(IERC20 lpToken) external returns (IERC20, uint);\\n}\\n\\n// PiggyBreeder is the master of PiggyToken.\\ncontract PiggyBreeder is Ownable {\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount;     // How many LP tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt.\\n        uint256 pendingReward;\\n        bool unStakeBeforeEnableClaim;\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 lpToken;           // Address of LP token contract.\\n        uint256 allocPoint;       // How many allocation points assigned to this pool. PiggyTokens to distribute per block.\\n        uint256 lastRewardBlock;  // Last block number that PiggyTokens distribution occurs.\\n        uint256 accPiggyPerShare; // Accumulated PiggyTokens per share, times 1e12. See below.\\n        uint256 totalDeposit;       // Accumulated deposit tokens.\\n        IMigrator migrator;\\n    }\\n\\n    // The WePiggyToken !\\n    WePiggyToken public piggy;\\n\\n    // Dev address.\\n    address public devAddr;\\n\\n    // Percentage of developers mining\\n    uint256 public devMiningRate;\\n\\n    // PIGGY tokens created per block.\\n    uint256 public piggyPerBlock;\\n\\n    // The block number when WPC mining starts.\\n    uint256 public startBlock;\\n\\n    // The block number when WPC claim starts.\\n    uint256 public enableClaimBlock;\\n\\n    // Interval blocks to reduce mining volume.\\n    uint256 public reduceIntervalBlock;\\n\\n    // reduce rate\\n    uint256 public reduceRate;\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n\\n    // Info of each user that stakes LP tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n    mapping(uint256 => address[]) public userAddresses;\\n\\n    // Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint;\\n\\n    event Stake(address indexed user, uint256 indexed pid, uint256 amount);\\n    event Claim(address indexed user, uint256 indexed pid);\\n    event UnStake(address indexed user, uint256 indexed pid, uint256 amount);\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event ReplaceMigrate(address indexed user, uint256 amount);\\n\\n    constructor (\\n        WePiggyToken _piggy,\\n        address _devAddr,\\n        uint256 _piggyPerBlock,\\n        uint256 _startBlock,\\n        uint256 _enableClaimBlock,\\n        uint256 _reduceIntervalBlock,\\n        uint256 _reduceRate,\\n        uint256 _devMiningRate\\n    ) public {\\n        piggy = _piggy;\\n        devAddr = _devAddr;\\n        piggyPerBlock = _piggyPerBlock;\\n        startBlock = _startBlock;\\n        reduceIntervalBlock = _reduceIntervalBlock;\\n        reduceRate = _reduceRate;\\n        devMiningRate = _devMiningRate;\\n        enableClaimBlock = _enableClaimBlock;\\n\\n        totalAllocPoint = 0;\\n    }\\n\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    function usersLength(uint256 _pid) external view returns (uint256) {\\n        return userAddresses[_pid].length;\\n    }\\n\\n    // Update dev address by the previous dev.\\n    function setDevAddr(address _devAddr) public onlyOwner {\\n        devAddr = _devAddr;\\n    }\\n\\n    // Set the migrator contract. Can only be called by the owner.\\n    function setMigrator(uint256 _pid, IMigrator _migrator) public onlyOwner {\\n        poolInfo[_pid].migrator = _migrator;\\n    }\\n\\n    // set the enable claim block\\n    function setEnableClaimBlock(uint256 _enableClaimBlock) public onlyOwner {\\n        enableClaimBlock = _enableClaimBlock;\\n    }\\n\\n    // update reduceIntervalBlock\\n    function setReduceIntervalBlock(uint256 _reduceIntervalBlock, bool _withUpdate) public onlyOwner {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        reduceIntervalBlock = _reduceIntervalBlock;\\n    }\\n\\n    // Update the given pool's PIGGY allocation point. Can only be called by the owner.\\n    function setAllocPoint(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        //update totalAllocPoint\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n\\n        //update poolInfo\\n        poolInfo[_pid].allocPoint = _allocPoint;\\n    }\\n\\n    // update reduce rate\\n    function setReduceRate(uint256 _reduceRate, bool _withUpdate) public onlyOwner {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        reduceRate = _reduceRate;\\n    }\\n\\n    // update dev mining rate\\n    function setDevMiningRate(uint256 _devMiningRate) public onlyOwner {\\n        devMiningRate = _devMiningRate;\\n    }\\n\\n    // Migrate lp token to another lp contract.\\n    function replaceMigrate(uint256 _pid) public onlyOwner {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        IMigrator migrator = pool.migrator;\\n        require(address(migrator) != address(0), \\\"migrate: no migrator\\\");\\n\\n        IERC20 lpToken = pool.lpToken;\\n        uint256 bal = lpToken.balanceOf(address(this));\\n        lpToken.safeApprove(address(migrator), bal);\\n        (IERC20 newLpToken, uint mintBal) = migrator.replaceMigrate(lpToken);\\n\\n        require(bal == newLpToken.balanceOf(address(this)), \\\"migrate: bad\\\");\\n        pool.lpToken = newLpToken;\\n\\n        emit ReplaceMigrate(address(migrator), bal);\\n    }\\n\\n    // Move lp token data to another lp contract.\\n    function migrate(uint256 _pid, uint256 _targetPid) public onlyOwner {\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n        IMigrator migrator = pool.migrator;\\n        require(address(migrator) != address(0), \\\"migrate: no migrator\\\");\\n\\n        IERC20 lpToken = pool.lpToken;\\n        uint256 bal = lpToken.balanceOf(address(this));\\n        lpToken.safeApprove(address(migrator), bal);\\n        (IERC20 newLpToken, uint mintBal) = migrator.migrate(lpToken);\\n\\n        PoolInfo storage targetPool = poolInfo[_targetPid];\\n        IERC20 targetToken = targetPool.lpToken;\\n        require(address(targetToken) == address(newLpToken), \\\"migrate: bad\\\");\\n\\n        uint rate = mintBal.mul(1e12).div(bal);\\n        for (uint i = 0; i < userAddresses[_pid].length; i++) {\\n\\n            updatePool(_targetPid);\\n\\n            address addr = userAddresses[_pid][i];\\n            UserInfo storage user = userInfo[_pid][addr];\\n            UserInfo storage tUser = userInfo[_targetPid][addr];\\n\\n            uint tmp = user.amount.mul(rate).div(1e12);\\n\\n            tUser.amount = tUser.amount.add(tmp);\\n            targetPool.totalDeposit = targetPool.totalDeposit.add(tmp);\\n            pool.totalDeposit = pool.totalDeposit.sub(user.amount);\\n            user.rewardDebt = 0;\\n            user.amount = 0;\\n        }\\n\\n    }\\n\\n    // Safe piggy transfer function, just in case if rounding error causes pool to not have enough PiggyToken.\\n    function safePiggyTransfer(address _to, uint256 _amount) internal {\\n        uint256 piggyBal = piggy.balanceOf(address(this));\\n        if (_amount > piggyBal) {\\n            piggy.transfer(_to, piggyBal);\\n        } else {\\n            piggy.transfer(_to, _amount);\\n        }\\n    }\\n\\n    // Return piggyPerBlock, baseOn power  --> piggyPerBlock * (reduceRate/100)^power\\n    function getPiggyPerBlock(uint256 _power) public view returns (uint256){\\n        if (_power == 0) {\\n            return piggyPerBlock;\\n        } else {\\n            uint256 z = piggyPerBlock;\\n            for (uint256 i = 0; i < _power; i++) {\\n                z = z.mul(reduceRate).div(1000);\\n            }\\n            return z;\\n        }\\n    }\\n\\n    // Return reward multiplier over the given _from to _to block.\\n    function getMultiplier(uint256 _from, uint256 _to) public pure returns (uint256) {\\n        return _to.sub(_from);\\n    }\\n\\n    // View function to see all pending PiggyToken on frontend.\\n    function allPendingPiggy(address _user) external view returns (uint256){\\n        uint sum = 0;\\n        for (uint i = 0; i < poolInfo.length; i++) {\\n            sum = sum.add(_pending(i, _user));\\n        }\\n        return sum;\\n    }\\n\\n    // View function to see pending PiggyToken on frontend.\\n    function pendingPiggy(uint256 _pid, address _user) external view returns (uint256) {\\n        return _pending(_pid, _user);\\n    }\\n\\n    //internal function\\n    function _pending(uint256 _pid, address _user) internal view returns (uint256) {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n\\n        uint256 accPiggyPerShare = pool.accPiggyPerShare;\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            // pending piggy reward\\n            uint256 piggyReward = 0;\\n            uint256 lastRewardBlockPower = pool.lastRewardBlock.sub(startBlock).div(reduceIntervalBlock);\\n            uint256 blockNumberPower = block.number.sub(startBlock).div(reduceIntervalBlock);\\n\\n            // get piggyReward from pool.lastRewardBlock to block.number.\\n            // different interval different multiplier and piggyPerBlock, sum piggyReward\\n            if (lastRewardBlockPower == blockNumberPower) {\\n                uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n                piggyReward = piggyReward.add(multiplier.mul(getPiggyPerBlock(blockNumberPower)).mul(pool.allocPoint).div(totalAllocPoint));\\n            } else if (lastRewardBlockPower < blockNumberPower) {\\n                for (uint256 i = lastRewardBlockPower; i <= blockNumberPower; i++) {\\n                    uint256 multiplier = 0;\\n                    if (i == lastRewardBlockPower) {\\n                        multiplier = getMultiplier(pool.lastRewardBlock, startBlock.add(lastRewardBlockPower.add(1).mul(reduceIntervalBlock)).sub(1));\\n                    } else if (i == blockNumberPower) {\\n                        multiplier = getMultiplier(startBlock.add(blockNumberPower.mul(reduceIntervalBlock)).sub(1), block.number);\\n                    } else {\\n                        multiplier = reduceIntervalBlock;\\n                    }\\n                    piggyReward = piggyReward.add(multiplier.mul(getPiggyPerBlock(i)).mul(pool.allocPoint).div(totalAllocPoint));\\n                }\\n            }\\n\\n            accPiggyPerShare = accPiggyPerShare.add(piggyReward.mul(1e12).div(lpSupply));\\n        }\\n\\n        // get pending value\\n        uint256 pendingValue = user.amount.mul(accPiggyPerShare).div(1e12).sub(user.rewardDebt);\\n\\n        // if enableClaimBlock after block.number, return pendingValue + user.pendingReward.\\n        // else return pendingValue.\\n        if (enableClaimBlock > block.number) {\\n            return pendingValue.add(user.pendingReward);\\n        } else {\\n            if (user.pendingReward > 0 && user.unStakeBeforeEnableClaim) {\\n                return pendingValue.add(user.pendingReward);\\n            }\\n            return pendingValue;\\n        }\\n    }\\n\\n    // Update reward variables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updatePool(pid);\\n        }\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function updatePool(uint256 _pid) public {\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (lpSupply == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n\\n        // get piggyReward. piggyReward base on current PiggyPerBlock.\\n        uint256 power = block.number.sub(startBlock).div(reduceIntervalBlock);\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n        uint256 piggyReward = multiplier.mul(getPiggyPerBlock(power)).mul(pool.allocPoint).div(totalAllocPoint);\\n\\n        // mint\\n        piggy.mint(devAddr, piggyReward.mul(devMiningRate).div(100));\\n        piggy.mint(address(this), piggyReward);\\n\\n        //update pool\\n        pool.accPiggyPerShare = pool.accPiggyPerShare.add(piggyReward.mul(1e12).div(lpSupply));\\n        pool.lastRewardBlock = block.number;\\n\\n    }\\n\\n    // Add a new lp to the pool. Can only be called by the owner.\\n    // DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    function add(uint256 _allocPoint, IERC20 _lpToken, IMigrator _migrator, bool _withUpdate) public onlyOwner {\\n\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n\\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\\n\\n        //update totalAllocPoint\\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n\\n        // add poolInfo\\n        poolInfo.push(PoolInfo({\\n        lpToken : _lpToken,\\n        allocPoint : _allocPoint,\\n        lastRewardBlock : lastRewardBlock,\\n        accPiggyPerShare : 0,\\n        totalDeposit : 0,\\n        migrator : _migrator\\n        }));\\n    }\\n\\n    // Stake LP tokens to PiggyBreeder for WPC allocation.\\n    function stake(uint256 _pid, uint256 _amount) public {\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n\\n        //update poolInfo by pid\\n        updatePool(_pid);\\n\\n        // if user's amount bigger than zero, transfer PiggyToken to user.\\n        if (user.amount > 0) {\\n            uint256 pending = user.amount.mul(pool.accPiggyPerShare).div(1e12).sub(user.rewardDebt);\\n            if (pending > 0) {\\n                // if enableClaimBlock after block.number, save the pending to user.pendingReward.\\n                if (enableClaimBlock <= block.number) {\\n                    safePiggyTransfer(msg.sender, pending);\\n\\n                    // transfer user.pendingReward if user.pendingReward > 0, and update user.pendingReward to 0\\n                    if (user.pendingReward > 0) {\\n                        safePiggyTransfer(msg.sender, user.pendingReward);\\n                        user.pendingReward = 0;\\n                    }\\n                } else {\\n                    user.pendingReward = user.pendingReward.add(pending);\\n                }\\n            }\\n        }\\n\\n        if (_amount > 0) {\\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\\n            user.amount = user.amount.add(_amount);\\n            pool.totalDeposit = pool.totalDeposit.add(_amount);\\n            userAddresses[_pid].push(msg.sender);\\n        }\\n\\n        user.rewardDebt = user.amount.mul(pool.accPiggyPerShare).div(1e12);\\n\\n        emit Stake(msg.sender, _pid, _amount);\\n\\n    }\\n\\n    // UnStake LP tokens from PiggyBreeder.\\n    function unStake(uint256 _pid, uint256 _amount) public {\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n\\n        require(user.amount >= _amount, \\\"unStake: not good\\\");\\n\\n        //update poolInfo by pid\\n        updatePool(_pid);\\n\\n        //transfer PiggyToken to user.\\n        uint256 pending = user.amount.mul(pool.accPiggyPerShare).div(1e12).sub(user.rewardDebt);\\n        if (pending > 0) {\\n            // if enableClaimBlock after block.number, save the pending to user.pendingReward.\\n            if (enableClaimBlock <= block.number) {\\n                safePiggyTransfer(msg.sender, pending);\\n\\n                // transfer user.pendingReward if user.pendingReward > 0, and update user.pendingReward to 0\\n                if (user.pendingReward > 0) {\\n                    safePiggyTransfer(msg.sender, user.pendingReward);\\n                    user.pendingReward = 0;\\n                }\\n            } else {\\n                user.pendingReward = user.pendingReward.add(pending);\\n                user.unStakeBeforeEnableClaim = true;\\n            }\\n        }\\n\\n        if (_amount > 0) {\\n            // transfer LP tokens to user\\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\\n            // update user info\\n            user.amount = user.amount.sub(_amount);\\n            pool.totalDeposit = pool.totalDeposit.sub(_amount);\\n        }\\n\\n        user.rewardDebt = user.amount.mul(pool.accPiggyPerShare).div(1e12);\\n\\n        emit UnStake(msg.sender, _pid, _amount);\\n    }\\n\\n    // claim WPC\\n    function claim(uint256 _pid) public {\\n\\n        require(enableClaimBlock <= block.number, \\\"too early to claim\\\");\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n\\n        //update poolInfo by pid\\n        updatePool(_pid);\\n\\n        // if user's amount bigger than zero, transfer PiggyToken to user.\\n        if (user.amount > 0) {\\n            uint256 pending = user.amount.mul(pool.accPiggyPerShare).div(1e12).sub(user.rewardDebt);\\n            if (pending > 0) {\\n                safePiggyTransfer(msg.sender, pending);\\n            }\\n        }\\n\\n        // transfer user.pendingReward if user.pendingReward > 0, and update user.pendingReward to 0\\n        if (user.pendingReward > 0) {\\n            safePiggyTransfer(msg.sender, user.pendingReward);\\n            user.pendingReward = 0;\\n        }\\n\\n        // update user info\\n        user.rewardDebt = user.amount.mul(pool.accPiggyPerShare).div(1e12);\\n\\n        emit Claim(msg.sender, _pid);\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint256 _pid) public {\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n\\n        uint256 amount = user.amount;\\n\\n        // transfer LP tokens to user\\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\\n\\n        pool.totalDeposit = pool.totalDeposit.sub(user.amount);\\n        // update user info\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n\\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\\n    }\\n\\n\\n}\\n\\n\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PricePosted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PToken\",\"name\":\"pToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract PToken\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setUnderlyingPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SimplePriceOracle","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}