{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\modules\\SafeInt256.sol\r\n\r\npragma solidity =0.5.16;\r\nlibrary SafeInt256 {\r\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\r\n        require(((z = x + y) >= x) == (y >= 0), 'SafeInt256: addition overflow');\r\n    }\r\n\r\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\r\n        require(((z = x - y) <= x) == (y >= 0), 'SafeInt256: substraction underflow');\r\n    }\r\n\r\n    function mul(int256 x, int256 y) internal pure returns (int256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'SafeInt256: multiplication overflow');\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\SafeMath.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'SafeMath: addition overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'SafeMath: substraction underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'SafeMath: multiplication overflow');\r\n    }\r\n}\r\n\r\n// File: contracts\\ERC20\\IERC20.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\modules\\Ownable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Managerable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ncontract Managerable is Ownable {\r\n\r\n    address private _managerAddress;\r\n    /**\r\n     * @dev modifier, Only manager can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyManager() {\r\n        require(_managerAddress == msg.sender,\"Managerable: caller is not the Manager\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev set manager by owner. \r\n     *\r\n     */\r\n    function setManager(address managerAddress)\r\n    public\r\n    onlyOwner\r\n    {\r\n        _managerAddress = managerAddress;\r\n    }\r\n    /**\r\n     * @dev get manager address. \r\n     *\r\n     */\r\n    function getManager()public view returns (address) {\r\n        return _managerAddress;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Halt.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\ncontract Halt is Ownable {\r\n    \r\n    bool private halted = false; \r\n    \r\n    modifier notHalted() {\r\n        require(!halted,\"This contract is halted\");\r\n        _;\r\n    }\r\n\r\n    modifier isHalted() {\r\n        require(halted,\"This contract is not halted\");\r\n        _;\r\n    }\r\n    \r\n    /// @notice function Emergency situation that requires \r\n    /// @notice contribution period to stop or not.\r\n    function setHalt(bool halt) \r\n        public \r\n        onlyOwner\r\n    {\r\n        halted = halt;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\whiteList.sol\r\n\r\npragma solidity =0.5.16;\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint32.\r\n     */\r\nlibrary whiteListUint32 {\r\n    /**\r\n     * @dev add uint32 into white list.\r\n     * @param whiteList the storage whiteList.\r\n     * @param temp input value\r\n     */\r\n\r\n    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\r\n        if (!isEligibleUint32(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    /**\r\n     * @dev remove uint32 from whitelist.\r\n     */\r\n    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint256.\r\n     */\r\nlibrary whiteListUint256 {\r\n    // add whiteList\r\n    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\r\n        if (!isEligibleUint256(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible address.\r\n     */\r\nlibrary whiteListAddress {\r\n    // add whiteList\r\n    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\r\n        if (!isEligibleAddress(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\AddressWhiteList.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n    /**\r\n     * @dev Implementation of a whitelist filters a eligible address.\r\n     */\r\ncontract AddressWhiteList is Halt {\r\n\r\n    using whiteListAddress for address[];\r\n    uint256 constant internal allPermission = 0xffffffff;\r\n    uint256 constant internal allowBuyOptions = 1;\r\n    uint256 constant internal allowSellOptions = 1<<1;\r\n    uint256 constant internal allowExerciseOptions = 1<<2;\r\n    uint256 constant internal allowAddCollateral = 1<<3;\r\n    uint256 constant internal allowRedeemCollateral = 1<<4;\r\n    // The eligible adress list\r\n    address[] internal whiteList;\r\n    mapping(address => uint256) internal addressPermission;\r\n    /**\r\n     * @dev Implementation of add an eligible address into the whitelist.\r\n     * @param addAddress new eligible address.\r\n     */\r\n    function addWhiteList(address addAddress)public onlyOwner{\r\n        whiteList.addWhiteListAddress(addAddress);\r\n        addressPermission[addAddress] = allPermission;\r\n    }\r\n    function modifyPermission(address addAddress,uint256 permission)public onlyOwner{\r\n        addressPermission[addAddress] = permission;\r\n    }\r\n    /**\r\n     * @dev Implementation of revoke an invalid address from the whitelist.\r\n     * @param removeAddress revoked address.\r\n     */\r\n    function removeWhiteList(address removeAddress)public onlyOwner returns (bool){\r\n        addressPermission[removeAddress] = 0;\r\n        return whiteList.removeWhiteListAddress(removeAddress);\r\n    }\r\n    /**\r\n     * @dev Implementation of getting the eligible whitelist.\r\n     */\r\n    function getWhiteList()public view returns (address[] memory){\r\n        return whiteList;\r\n    }\r\n    /**\r\n     * @dev Implementation of testing whether the input address is eligible.\r\n     * @param tmpAddress input address for testing.\r\n     */    \r\n    function isEligibleAddress(address tmpAddress) public view returns (bool){\r\n        return whiteList.isEligibleAddress(tmpAddress);\r\n    }\r\n    function checkAddressPermission(address tmpAddress,uint256 state) public view returns (bool){\r\n        return  (addressPermission[tmpAddress]&state) == state;\r\n    }\r\n    modifier addressPermissionAllowed(address tmpAddress,uint256 state){\r\n        require(checkAddressPermission(tmpAddress,state) , \"Input address is not allowed\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts\\OptionsPool\\IOptionsPool.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ninterface IOptionsPool {\r\n//    function getOptionBalances(address user) external view returns(uint256[]);\r\n\r\n    function getExpirationList()external view returns (uint32[] memory);\r\n    function createOptions(address from,address settlement,uint256 type_ly_expiration,\r\n        uint128 strikePrice,uint128 underlyingPrice,uint128 amount,uint128 settlePrice) external returns(uint256);\r\n    function setSharedState(uint256 newFirstOption,int256[] calldata latestNetWorth,address[] calldata whiteList) external;\r\n    function getAllTotalOccupiedCollateral() external view returns (uint256,uint256);\r\n    function getCallTotalOccupiedCollateral() external view returns (uint256);\r\n    function getPutTotalOccupiedCollateral() external view returns (uint256);\r\n    function getTotalOccupiedCollateral() external view returns (uint256);\r\n//    function buyOptionCheck(uint32 expiration,uint32 underlying)external view;\r\n    function burnOptions(address from,uint256 id,uint256 amount,uint256 optionPrice)external;\r\n    function getOptionsById(uint256 optionsId)external view returns(uint256,address,uint8,uint32,uint256,uint256,uint256);\r\n    function getExerciseWorth(uint256 optionsId,uint256 amount)external view returns(uint256);\r\n    function calculatePhaseOptionsFall(uint256 lastOption,uint256 begin,uint256 end,address[] calldata whiteList) external view returns(int256[] memory);\r\n    function getOptionInfoLength()external view returns (uint256);\r\n    function getNetWrothCalInfo(address[] calldata whiteList)external view returns(uint256,int256[] memory);\r\n    function calRangeSharedPayment(uint256 lastOption,uint256 begin,uint256 end,address[] calldata whiteList)external view returns(int256[] memory,uint256[] memory,uint256);\r\n    function getNetWrothLatestWorth(address settlement)external view returns(int256);\r\n    function getBurnedFullPay(uint256 optionID,uint256 amount) external view returns(address,uint256);\r\n\r\n}\r\ncontract ImportOptionsPool is Ownable{\r\n    IOptionsPool internal _optionsPool;\r\n    function getOptionsPoolAddress() public view returns(address){\r\n        return address(_optionsPool);\r\n    }\r\n    function setOptionsPoolAddress(address optionsPool)public onlyOwner{\r\n        _optionsPool = IOptionsPool(optionsPool);\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Operator.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * each operator can be granted exclusive access to specific functions.\r\n *\r\n */\r\ncontract Operator is Ownable {\r\n    using whiteListAddress for address[];\r\n    address[] private _operatorList;\r\n    /**\r\n     * @dev modifier, every operator can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyOperator() {\r\n        require(_operatorList.isEligibleAddress(msg.sender),\"Managerable: caller is not the Operator\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev modifier, Only indexed operator can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyOperatorIndex(uint256 index) {\r\n        require(_operatorList.length>index && _operatorList[index] == msg.sender,\"Operator: caller is not the eligible Operator\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev add a new operator by owner. \r\n     *\r\n     */\r\n    function addOperator(address addAddress)public onlyOwner{\r\n        _operatorList.addWhiteListAddress(addAddress);\r\n    }\r\n    /**\r\n     * @dev modify indexed operator by owner. \r\n     *\r\n     */\r\n    function setOperator(uint256 index,address addAddress)public onlyOwner{\r\n        _operatorList[index] = addAddress;\r\n    }\r\n    /**\r\n     * @dev remove operator by owner. \r\n     *\r\n     */\r\n    function removeOperator(address removeAddress)public onlyOwner returns (bool){\r\n        return _operatorList.removeWhiteListAddress(removeAddress);\r\n    }\r\n    /**\r\n     * @dev get all operators. \r\n     *\r\n     */\r\n    function getOperator()public view returns (address[] memory) {\r\n        return _operatorList;\r\n    }\r\n    /**\r\n     * @dev set all operators by owner. \r\n     *\r\n     */\r\n    function setOperators(address[] memory operators)public onlyOwner {\r\n        _operatorList = operators;\r\n    }\r\n}\r\n\r\n// File: contracts\\CollateralPool\\CollateralData.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title collateral pool contract with coin and necessary storage data.\r\n * @dev A smart-contract which stores user's deposited collateral.\r\n *\r\n */\r\ncontract CollateralData is AddressWhiteList,Managerable,Operator,ImportOptionsPool{\r\n        // The total fees accumulated in the contract\r\n    mapping (address => uint256) \tinternal feeBalances;\r\n    uint32[] internal FeeRates;\r\n     /**\r\n     * @dev Returns the rate of trasaction fee.\r\n     */   \r\n    uint256 constant internal buyFee = 0;\r\n    uint256 constant internal sellFee = 1;\r\n    uint256 constant internal exerciseFee = 2;\r\n    uint256 constant internal addColFee = 3;\r\n    uint256 constant internal redeemColFee = 4;\r\n    event RedeemFee(address indexed recieptor,address indexed settlement,uint256 payback);\r\n    event AddFee(address indexed settlement,uint256 payback);\r\n    event TransferPayback(address indexed recieptor,address indexed settlement,uint256 payback);\r\n\r\n    //token net worth balance\r\n    mapping (address => int256) internal netWorthBalances;\r\n    //total user deposited collateral balance\r\n    // map from collateral address to amount\r\n    mapping (address => uint256) internal collateralBalances;\r\n    //user total paying for collateral, priced in usd;\r\n    mapping (address => uint256) internal userCollateralPaying;\r\n    //user original deposited collateral.\r\n    //map account -> collateral -> amount\r\n    mapping (address => mapping (address => uint256)) internal userInputCollateral;\r\n}\r\n\r\n// File: contracts\\modules\\Address.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call.value(value )(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\ERC20\\safeErc20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\CollateralPool\\TransactionFee.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n    /**\r\n     * @dev Implementation of a transaction fee manager.\r\n     */\r\ncontract TransactionFee is CollateralData {\r\n    using SafeMath for uint256;\r\n    constructor() internal{\r\n        initialize();\r\n    }\r\n    function initialize() onlyOwner public{\r\n        FeeRates.push(50);\r\n        FeeRates.push(0);\r\n        FeeRates.push(50);\r\n        FeeRates.push(0);\r\n        FeeRates.push(0);\r\n    }\r\n    function getFeeRateAll()public view returns (uint32[] memory){\r\n        return FeeRates;\r\n    }\r\n    function getFeeRate(uint256 feeType)public view returns (uint32){\r\n        return FeeRates[feeType];\r\n    }\r\n    /**\r\n     * @dev set the rate of trasaction fee.\r\n     * @param feeType the transaction fee type\r\n     * @param thousandth the numerator of transaction fee .\r\n     * transaction fee = thousandth/1000;\r\n     */   \r\n    function setTransactionFee(uint256 feeType,uint32 thousandth)public onlyOwner{\r\n        FeeRates[feeType] = thousandth;\r\n    }\r\n\r\n    function getFeeBalance(address settlement)public view returns(uint256){\r\n        return feeBalances[settlement];\r\n    }\r\n    function getAllFeeBalances()public view returns(address[] memory,uint256[] memory){\r\n        uint256[] memory balances = new uint256[](whiteList.length);\r\n        for (uint256 i=0;i<whiteList.length;i++){\r\n            balances[i] = feeBalances[whiteList[i]];\r\n        }\r\n        return (whiteList,balances);\r\n    }\r\n    function redeem(address currency)public onlyOwner{\r\n        uint256 fee = feeBalances[currency];\r\n        require (fee > 0, \"It's empty balance\");\r\n        feeBalances[currency] = 0;\r\n         if (currency == address(0)){\r\n            msg.sender.transfer(fee);\r\n        }else{\r\n            IERC20 currencyToken = IERC20(currency);\r\n            uint256 preBalance = currencyToken.balanceOf(address(this));\r\n            SafeERC20.safeTransfer(currencyToken,msg.sender,fee);\r\n//            currencyToken.transfer(msg.sender,fee);\r\n            uint256 afterBalance = currencyToken.balanceOf(address(this));\r\n            require(preBalance - afterBalance == fee,\"settlement token transfer error!\");\r\n        }\r\n        emit RedeemFee(msg.sender,currency,fee);\r\n    }\r\n    function redeemAll()public onlyOwner{\r\n        for (uint256 i=0;i<whiteList.length;i++){\r\n            redeem(whiteList[i]);\r\n        }\r\n    }\r\n    function _addTransactionFee(address settlement,uint256 amount) internal {\r\n        if (amount > 0){\r\n            feeBalances[settlement] = feeBalances[settlement]+amount;\r\n            emit AddFee(settlement,amount);\r\n        }\r\n    }\r\n    function calculateFee(uint256 feeType,uint256 amount)public view returns (uint256){\r\n        return FeeRates[feeType]*amount/1000;\r\n    }\r\n    /**\r\n      * @dev  transfer settlement payback amount;\r\n      * @param recieptor payback recieptor\r\n      * @param settlement settlement address\r\n      * @param payback amount of settlement will payback \r\n      */\r\n    function _transferPaybackAndFee(address payable recieptor,address settlement,uint256 payback,uint256 feeType)internal{\r\n        if (payback == 0){\r\n            return;\r\n        }\r\n        uint256 fee = FeeRates[feeType]*payback/1000;\r\n        _transferPayback(recieptor,settlement,payback-fee);\r\n        _addTransactionFee(settlement,fee);\r\n    }\r\n    /**\r\n      * @dev  transfer settlement payback amount;\r\n      * @param recieptor payback recieptor\r\n      * @param settlement settlement address\r\n      * @param payback amount of settlement will payback \r\n      */\r\n    function _transferPayback(address payable recieptor,address settlement,uint256 payback)internal{\r\n        if (payback == 0){\r\n            return;\r\n        }\r\n        if (settlement == address(0)){\r\n            recieptor.transfer(payback);\r\n        }else{\r\n            IERC20 collateralToken = IERC20(settlement);\r\n            uint256 preBalance = collateralToken.balanceOf(address(this));\r\n            SafeERC20.safeTransfer(collateralToken,recieptor,payback);\r\n            //collateralToken.transfer(recieptor,payback);\r\n            uint256 afterBalance = collateralToken.balanceOf(address(this));\r\n            require(preBalance - afterBalance == payback,\"settlement token transfer error!\");\r\n        }\r\n        emit TransferPayback(recieptor,settlement,payback);\r\n    }\r\n}\r\n\r\n// File: contracts\\CollateralPool\\CollateralPool.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @title collateral pool contract with coin and necessary storage data.\r\n * @dev A smart-contract which stores user's deposited collateral.\r\n *\r\n */\r\ncontract CollateralPool is TransactionFee{\r\n    using SafeMath for uint256;\r\n    using SafeInt256 for int256;\r\n    constructor(address optionsPool)public{\r\n        _optionsPool = IOptionsPool(optionsPool);\r\n    }\r\n    /**\r\n     * @dev Transfer colleteral from manager contract to this contract.\r\n     *  Only manager contract can invoke this function.\r\n     */\r\n    function () external payable onlyManager{\r\n\r\n    }\r\n    function initialize() onlyOwner public {\r\n        TransactionFee.initialize();\r\n    }\r\n    function update() onlyOwner public{\r\n    }\r\n    /**\r\n     * @dev An interface for add transaction fee.\r\n     *  Only manager contract can invoke this function.\r\n     * @param collateral collateral address, also is the coin for fee.\r\n     * @param amount total transaction amount.\r\n     * @param feeType transaction fee type. see TransactionFee contract\r\n     */\r\n    function addTransactionFee(address collateral,uint256 amount,uint256 feeType)public onlyManager returns (uint256) {\r\n        uint256 fee = FeeRates[feeType]*amount/1000;\r\n        _addTransactionFee(collateral,fee);\r\n        return fee;\r\n    }\r\n    /**\r\n     * @dev Retrieve user's cost of collateral, priced in USD.\r\n     * @param user input retrieved account \r\n     */\r\n    function getUserPayingUsd(address user)public view returns (uint256){\r\n        return userCollateralPaying[user];\r\n    }\r\n    /**\r\n     * @dev Retrieve user's amount of the specified collateral.\r\n     * @param user input retrieved account \r\n     * @param collateral input retrieved collateral coin address \r\n     */\r\n    function getUserInputCollateral(address user,address collateral)public view returns (uint256){\r\n        return userInputCollateral[user][collateral];\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve collateral balance data.\r\n     * @param collateral input retrieved collateral coin address \r\n     */\r\n    function getCollateralBalance(address collateral)public view returns (uint256){\r\n        return collateralBalances[collateral];\r\n    }\r\n    /**\r\n     * @dev Opterator user paying data, priced in USD. Only manager contract can modify database.\r\n     * @param user input user account which need add paying amount.\r\n     * @param amount the input paying amount.\r\n     */\r\n    function addUserPayingUsd(address user,uint256 amount)public onlyManager{\r\n        userCollateralPaying[user] = userCollateralPaying[user].add(amount);\r\n    }\r\n    /**\r\n     * @dev Opterator user input collateral data. Only manager contract can modify database.\r\n     * @param user input user account which need add input collateral.\r\n     * @param collateral the collateral address.\r\n     * @param amount the input collateral amount.\r\n     */\r\n    function addUserInputCollateral(address user,address collateral,uint256 amount)public onlyManager{\r\n        userInputCollateral[user][collateral] = userInputCollateral[user][collateral].add(amount);\r\n        collateralBalances[collateral] = collateralBalances[collateral].add(amount);\r\n        netWorthBalances[collateral] = netWorthBalances[collateral].add(int256(amount));\r\n    }\r\n    /**\r\n     * @dev Opterator net worth balance data. Only manager contract can modify database.\r\n     * @param whiteList available colleteral address list.\r\n     * @param newNetworth collateral net worth list.\r\n     */\r\n    function addNetWorthBalances(address[] memory whiteList,int256[] memory newNetworth)internal{\r\n        for (uint i=0;i<newNetworth.length;i++){\r\n            netWorthBalances[whiteList[i]] = netWorthBalances[whiteList[i]].add(newNetworth[i]);\r\n        }\r\n    }\r\n    /**\r\n     * @dev Opterator net worth balance data. Only manager contract can modify database.\r\n     * @param collateral available colleteral address.\r\n     * @param amount collateral net worth increase amount.\r\n     */\r\n    function addNetWorthBalance(address collateral,int256 amount)public onlyManager{\r\n        netWorthBalances[collateral] = netWorthBalances[collateral].add(amount);\r\n    }\r\n    /**\r\n     * @dev Opterator collateral balance data. Only manager contract can modify database.\r\n     * @param collateral available colleteral address.\r\n     * @param amount collateral colleteral increase amount.\r\n     */\r\n    function addCollateralBalance(address collateral,uint256 amount)public onlyManager{\r\n        collateralBalances[collateral] = collateralBalances[collateral].add(amount);\r\n    }\r\n    /**\r\n     * @dev Substract user paying data,priced in USD. Only manager contract can modify database.\r\n     * @param user user's account.\r\n     * @param amount user's decrease amount.\r\n     */\r\n    function subUserPayingUsd(address user,uint256 amount)public onlyManager{\r\n        userCollateralPaying[user] = userCollateralPaying[user].sub(amount);\r\n    }\r\n    /**\r\n     * @dev Substract user's collateral balance. Only manager contract can modify database.\r\n     * @param user user's account.\r\n     * @param collateral collateral address.\r\n     * @param amount user's decrease amount.\r\n     */\r\n    function subUserInputCollateral(address user,address collateral,uint256 amount)public onlyManager{\r\n        userInputCollateral[user][collateral] = userInputCollateral[user][collateral].sub(amount);\r\n    }\r\n    /**\r\n     * @dev Substract net worth balance. Only manager contract can modify database.\r\n     * @param collateral collateral address.\r\n     * @param amount the decrease amount.\r\n     */\r\n    function subNetWorthBalance(address collateral,int256 amount)public onlyManager{\r\n        netWorthBalances[collateral] = netWorthBalances[collateral].sub(amount);\r\n    }\r\n    /**\r\n     * @dev Substract collateral balance. Only manager contract can modify database.\r\n     * @param collateral collateral address.\r\n     * @param amount the decrease amount.\r\n     */\r\n    function subCollateralBalance(address collateral,uint256 amount)public onlyManager{\r\n        collateralBalances[collateral] = collateralBalances[collateral].sub(amount);\r\n    }\r\n    /**\r\n     * @dev set user paying data,priced in USD. Only manager contract can modify database.\r\n     * @param user user's account.\r\n     * @param amount user's new amount.\r\n     */\r\n    function setUserPayingUsd(address user,uint256 amount)public onlyManager{\r\n        userCollateralPaying[user] = amount;\r\n    }\r\n    /**\r\n     * @dev set user's collateral balance. Only manager contract can modify database.\r\n     * @param user user's account.\r\n     * @param collateral collateral address.\r\n     * @param amount user's new amount.\r\n     */\r\n    function setUserInputCollateral(address user,address collateral,uint256 amount)public onlyManager{\r\n        userInputCollateral[user][collateral] = amount;\r\n    }\r\n    /**\r\n     * @dev set net worth balance. Only manager contract can modify database.\r\n     * @param collateral collateral address.\r\n     * @param amount the new amount.\r\n     */\r\n    function setNetWorthBalance(address collateral,int256 amount)public onlyManager{\r\n        netWorthBalances[collateral] = amount;\r\n    }\r\n    /**\r\n     * @dev set collateral balance. Only manager contract can modify database.\r\n     * @param collateral collateral address.\r\n     * @param amount the new amount.\r\n     */\r\n    function setCollateralBalance(address collateral,uint256 amount)public onlyManager{\r\n        collateralBalances[collateral] = amount;\r\n    }\r\n    /**\r\n     * @dev Operation for transfer user's payback and deduct transaction fee. Only manager contract can invoke this function.\r\n     * @param recieptor the recieptor account.\r\n     * @param settlement the settlement coin address.\r\n     * @param payback the payback amount\r\n     * @param feeType the transaction fee type. see transactionFee contract\r\n     */\r\n    function transferPaybackAndFee(address payable recieptor,address settlement,uint256 payback,\r\n            uint256 feeType)public onlyManager{\r\n        _transferPaybackAndFee(recieptor,settlement,payback,feeType);\r\n        netWorthBalances[settlement] = netWorthBalances[settlement].sub(int256(payback));\r\n    }\r\n        /**\r\n     * @dev Operation for transfer user's payback. Only manager contract can invoke this function.\r\n     * @param recieptor the recieptor account.\r\n     * @param allPay the payback amount\r\n     */\r\n    function buyOptionsPayfor(address payable recieptor,address settlement,uint256 settlementAmount,uint256 allPay)public onlyManager{\r\n        uint256 fee = addTransactionFee(settlement,allPay,0);\r\n        require(settlementAmount>=allPay+fee,\"settlement asset is insufficient!\");\r\n        settlementAmount = settlementAmount-(allPay+fee);\r\n        if (settlementAmount > 0){\r\n            _transferPayback(recieptor,settlement,settlementAmount);\r\n        }\r\n    }\r\n    /**\r\n     * @dev Operation for transfer user's payback. Only manager contract can invoke this function.\r\n     * @param recieptor the recieptor account.\r\n     * @param settlement the settlement coin address.\r\n     * @param payback the payback amount\r\n     */\r\n    function transferPayback(address payable recieptor,address settlement,uint256 payback)public onlyManager{\r\n        _transferPayback(recieptor,settlement,payback);\r\n    }\r\n    /**\r\n     * @dev Operation for transfer user's payback and deduct transaction fee for multiple settlement Coin.\r\n     *       Specially used for redeem collateral.Only manager contract can invoke this function.\r\n     * @param account the recieptor account.\r\n     * @param redeemWorth the redeem worth, priced in USD.\r\n     * @param tmpWhiteList the settlement coin white list\r\n     * @param colBalances the Collateral balance based for user's input collateral.\r\n     * @param PremiumBalances the premium collateral balance if redeem worth is exceeded user's input collateral.\r\n     * @param prices the collateral prices list.\r\n     */\r\n    function transferPaybackBalances(address payable account,uint256 redeemWorth,address[] memory tmpWhiteList,uint256[] memory colBalances,\r\n        uint256[] memory PremiumBalances,uint256[] memory prices)public onlyManager {\r\n        uint256 ln = tmpWhiteList.length;\r\n        uint256[] memory PaybackBalances = new uint256[](ln);\r\n        uint256 i=0;\r\n        uint256 amount;\r\n        for(; i<ln && redeemWorth>0;i++){\r\n            //address addr = tmpWhiteList[i];\r\n            if (colBalances[i] > 0){\r\n                amount = redeemWorth/prices[i];\r\n                if (amount < colBalances[i]){\r\n                    redeemWorth = 0;\r\n                }else{\r\n                    amount = colBalances[i];\r\n                    redeemWorth = redeemWorth - colBalances[i]*prices[i];\r\n                }\r\n                PaybackBalances[i] = amount;\r\n                amount = amount * userInputCollateral[account][tmpWhiteList[i]]/colBalances[i];\r\n                userInputCollateral[account][tmpWhiteList[i]] =userInputCollateral[account][tmpWhiteList[i]].sub(amount);\r\n                collateralBalances[tmpWhiteList[i]] = collateralBalances[tmpWhiteList[i]].sub(amount);\r\n\r\n            }\r\n        }\r\n        if (redeemWorth>0) {\r\n           amount = 0;\r\n            for (i=0; i<ln;i++){\r\n                amount = amount.add(PremiumBalances[i]*prices[i]);\r\n            }\r\n//            require(amount >= redeemWorth ,\"redeem collateral is insufficient\");\r\n            if (amount<redeemWorth){\r\n                amount = redeemWorth;\r\n            }\r\n            for (i=0; i<ln;i++){\r\n                PaybackBalances[i] = PaybackBalances[i].add(PremiumBalances[i].mul(redeemWorth)/amount);\r\n            }\r\n        }\r\n        for (i=0;i<ln;i++){ \r\n            transferPaybackAndFee(account,tmpWhiteList[i],PaybackBalances[i],redeemColFee);\r\n        } \r\n    }\r\n    /**\r\n     * @dev calculate user's input collateral balance and premium collateral balance.\r\n     *      Specially used for user's redeem collateral.\r\n     * @param account the recieptor account.\r\n     * @param userTotalWorth the user's total FPTCoin worth, priced in USD.\r\n     * @param tmpWhiteList the settlement coin white list\r\n     * @param _RealBalances the real Collateral balance.\r\n     * @param prices the collateral prices list.\r\n     */\r\n    function getCollateralAndPremiumBalances(address account,uint256 userTotalWorth,address[] memory tmpWhiteList,\r\n        uint256[] memory _RealBalances,uint256[] memory prices) public view returns(uint256[] memory,uint256[] memory){\r\n//        uint256 ln = tmpWhiteList.length;\r\n        uint256[] memory colBalances = new uint256[](tmpWhiteList.length);\r\n        uint256[] memory PremiumBalances = new uint256[](tmpWhiteList.length);\r\n        uint256 totalWorth = 0;\r\n        uint256 PremiumWorth = 0;\r\n        uint256 i=0;\r\n        for(; i<tmpWhiteList.length;i++){\r\n            (colBalances[i],PremiumBalances[i]) = calUserNetWorthBalanceRate(tmpWhiteList[i],account,_RealBalances[i]);\r\n            totalWorth = totalWorth.add(prices[i]*colBalances[i]);\r\n            PremiumWorth = PremiumWorth.add(prices[i]*PremiumBalances[i]);\r\n        }\r\n        if (totalWorth >= userTotalWorth){\r\n            for (i=0; i<tmpWhiteList.length;i++){\r\n                colBalances[i] = colBalances[i].mul(userTotalWorth)/totalWorth;\r\n            }\r\n        }else if (PremiumWorth>0){\r\n            userTotalWorth = userTotalWorth - totalWorth;\r\n            for (i=0; i<tmpWhiteList.length;i++){\r\n                PremiumBalances[i] = PremiumBalances[i].mul(userTotalWorth)/PremiumWorth;\r\n            }\r\n        }\r\n        return (colBalances,PremiumBalances);\r\n    } \r\n    /**\r\n     * @dev calculate user's input collateral balance.\r\n     *      Specially used for user's redeem collateral.\r\n     * @param settlement the settlement coin address.\r\n     * @param user the recieptor account.\r\n     * @param netWorthBalance the settlement coin real balance\r\n     */\r\n    function calUserNetWorthBalanceRate(address settlement,address user,uint256 netWorthBalance)internal view returns(uint256,uint256){\r\n        uint256 collateralBalance = collateralBalances[settlement];\r\n        uint256 amount = userInputCollateral[user][settlement];\r\n        if (collateralBalance > 0){\r\n            uint256 curAmount = netWorthBalance.mul(amount)/collateralBalance;\r\n            return (curAmount,netWorthBalance.sub(curAmount));\r\n        }else{\r\n            return (0,netWorthBalance);\r\n        }\r\n    }\r\n    function getAllRealBalance(address[] memory whiteList)public view returns(int256[] memory){\r\n        uint256 len = whiteList.length;\r\n        int256[] memory realBalances = new int256[](len); \r\n        for (uint i = 0;i<len;i++){\r\n            int256 latestWorth = _optionsPool.getNetWrothLatestWorth(whiteList[i]);\r\n            realBalances[i] = netWorthBalances[whiteList[i]].add(latestWorth);\r\n        }\r\n        return realBalances;\r\n    }\r\n        /**\r\n     * @dev Retrieve the balance of collateral, the auxiliary function for the total collateral calculation. \r\n     */\r\n    function getRealBalance(address settlement)public view returns(int256){\r\n        int256 latestWorth = _optionsPool.getNetWrothLatestWorth(settlement);\r\n        return netWorthBalances[settlement].add(latestWorth);\r\n    }\r\n    function getNetWorthBalance(address settlement)public view returns(uint256){\r\n        int256 latestWorth = _optionsPool.getNetWrothLatestWorth(settlement);\r\n        int256 netWorth = netWorthBalances[settlement].add(latestWorth);\r\n        if (netWorth>0){\r\n            return uint256(netWorth);\r\n        }\r\n        return 0;\r\n    }\r\n        /**\r\n     * @dev  The foundation operator want to add some coin to netbalance, which can increase the FPTCoin net worth.\r\n     * @param settlement the settlement coin address which the foundation operator want to transfer in this contract address.\r\n     * @param amount the amount of the settlement coin which the foundation operator want to transfer in this contract address.\r\n     */\r\n    function addNetBalance(address settlement,uint256 amount) public payable {\r\n        amount = getPayableAmount(settlement,amount);\r\n        netWorthBalances[settlement] = netWorthBalances[settlement].add(int256(amount));\r\n    }\r\n        /**\r\n     * @dev the auxiliary function for getting user's transer\r\n     */\r\n    function getPayableAmount(address settlement,uint256 settlementAmount) internal returns (uint256) {\r\n        if (settlement == address(0)){\r\n            settlementAmount = msg.value;\r\n        }else if (settlementAmount > 0){\r\n            IERC20 oToken = IERC20(settlement);\r\n            uint256 preBalance = oToken.balanceOf(address(this));\r\n            oToken.transferFrom(msg.sender, address(this), settlementAmount);\r\n            uint256 afterBalance = oToken.balanceOf(address(this));\r\n            require(afterBalance-preBalance==settlementAmount,\"settlement token transfer error!\");\r\n        }\r\n        return settlementAmount;\r\n    }\r\n        /**\r\n     * @dev Calculate the collateral pool shared worth.\r\n     * The foundation operator will invoke this function frequently\r\n     */\r\n    function calSharedPayment(address[] memory _whiteList) public onlyOperatorIndex(0) {\r\n        (uint256 firstOption,int256[] memory latestShared) = _optionsPool.getNetWrothCalInfo(_whiteList);\r\n        uint256 lastOption = _optionsPool.getOptionInfoLength();\r\n        (int256[] memory newNetworth,uint256[] memory sharedBalance,uint256 newFirst) =\r\n                     _optionsPool.calRangeSharedPayment(lastOption,firstOption,lastOption,_whiteList);\r\n        int256[] memory fallBalance = _optionsPool.calculatePhaseOptionsFall(lastOption,newFirst,lastOption,_whiteList);\r\n        for (uint256 i= 0;i<fallBalance.length;i++){\r\n            fallBalance[i] = int256(sharedBalance[i]).sub(latestShared[i]).add(fallBalance[i]);\r\n        }\r\n        setSharedPayment(_whiteList,newNetworth,fallBalance,newFirst);\r\n    }\r\n    /**\r\n     * @dev Set the calculation results of the collateral pool shared worth.\r\n     * The foundation operator will invoke this function frequently\r\n     * @param newNetworth Current expired options' net worth \r\n     * @param sharedBalances All unexpired options' shared balance distributed by time.\r\n     * @param firstOption The new first unexpired option's index.\r\n     */\r\n    function setSharedPayment(address[] memory _whiteList,int256[] memory newNetworth,int256[] memory sharedBalances,uint256 firstOption) public onlyOperatorIndex(0){\r\n        _optionsPool.setSharedState(firstOption,sharedBalances,_whiteList);\r\n        addNetWorthBalances(_whiteList,newNetworth);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"optionsPool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payback\",\"type\":\"uint256\"}],\"name\":\"AddFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recieptor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payback\",\"type\":\"uint256\"}],\"name\":\"RedeemFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recieptor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payback\",\"type\":\"uint256\"}],\"name\":\"TransferPayback\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addCollateralBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addNetBalance\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"addNetWorthBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeType\",\"type\":\"uint256\"}],\"name\":\"addTransactionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addUserInputCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addUserPayingUsd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recieptor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"settlementAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allPay\",\"type\":\"uint256\"}],\"name\":\"buyOptionsPayfor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_whiteList\",\"type\":\"address[]\"}],\"name\":\"calSharedPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tmpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"}],\"name\":\"checkAddressPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllFeeBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"whiteList\",\"type\":\"address[]\"}],\"name\":\"getAllRealBalance\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userTotalWorth\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tmpWhiteList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_RealBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"name\":\"getCollateralAndPremiumBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"name\":\"getCollateralBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"}],\"name\":\"getFeeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeType\",\"type\":\"uint256\"}],\"name\":\"getFeeRate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeRateAll\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"}],\"name\":\"getNetWorthBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperator\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOptionsPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"}],\"name\":\"getRealBalance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"name\":\"getUserInputCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserPayingUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWhiteList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tmpAddress\",\"type\":\"address\"}],\"name\":\"isEligibleAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"permission\",\"type\":\"uint256\"}],\"name\":\"modifyPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeAddress\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeAddress\",\"type\":\"address\"}],\"name\":\"removeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setCollateralBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"halt\",\"type\":\"bool\"}],\"name\":\"setHalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"managerAddress\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"setNetWorthBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addAddress\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setOperators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"optionsPool\",\"type\":\"address\"}],\"name\":\"setOptionsPoolAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_whiteList\",\"type\":\"address[]\"},{\"internalType\":\"int256[]\",\"name\":\"newNetworth\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"sharedBalances\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"firstOption\",\"type\":\"uint256\"}],\"name\":\"setSharedPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeType\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"thousandth\",\"type\":\"uint32\"}],\"name\":\"setTransactionFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setUserInputCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setUserPayingUsd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subCollateralBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"subNetWorthBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subUserInputCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subUserPayingUsd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recieptor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payback\",\"type\":\"uint256\"}],\"name\":\"transferPayback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recieptor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settlement\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payback\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeType\",\"type\":\"uint256\"}],\"name\":\"transferPaybackAndFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemWorth\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tmpWhiteList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"colBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"PremiumBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"name\":\"transferPaybackBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CollateralPool","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e12a03aea96dc56fb8007ec54fcfbdd61965d925","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://23298f84927f6310dfb8c6fea09588ca66229ec2254e5bb819ce481eb3355cf2"}]}