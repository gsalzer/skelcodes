{"status":"1","message":"OK","result":[{"SourceCode":"{\"ChainlinkReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.3;\\r\\nimport {\\r\\n    IERC20,\\r\\n    ISafeMath,\\r\\n    IChainlinkOracle,\\r\\n    IKladeDiffToken\\r\\n} from \\\"./Interfaces.sol\\\";\\r\\n\\r\\n\\r\\ncontract ChainlinkReceiver {\\r\\n    uint256 constant multiple = 10**7;\\r\\n    uint256 constant initial_factor = 1396984; // initial_factor =  600 * 10^13 / 2^32 rounded to nearest whole number\\r\\n    // factor = block_reward * seconds_per_block * Hashes_per_second * WBTC_adjustment_factor / constant\\r\\n    // Formula for Earnings Per Block in BTC = block_reward * 600 * hash_rate / (2^32 * difficulty)\\r\\n    uint256 constant Q3_end_unix = 1632960000;\\r\\n\\r\\n    uint256 constant secondsInDay = 86400; // Number of seconds in a day\\r\\n    uint256 constant blocksBetweenHalvings = 210000; // Number of blocks between each bitcoin block reward halving ie 12.5 BTC/block -\\u003e 6.25 BTC/block\\r\\n    uint256 constant initialBlockReward = 5000000000; // Initial bitcoin block reward in satoshis\\r\\n    uint256 constant numBlockBetweenDiffChanges = 2016; // Number of Blocks between each BTC difficulty adjustment(~2 weeks or 2016 blocks)\\r\\n\\r\\n    //Static Variable used to check validity of data given by the chainlink oracle\\r\\n                                          \\r\\n    uint256 constant minValidDifficulty = 500000000000; // Minimum valid difficulty for Q32021\\r\\n    uint256 constant maxValidDifficulty = 600000000000000; // Maximum valid difficulty for Q32021\\r\\n\\r\\n    uint256 constant minValidBlockNum = 663904; // Minimum valid block number for Q32021\\r\\n    uint256 constant maxValidBlockNum = 1000000; // Maximum valid block number for Q32021\\r\\n    uint256 constant maxValidBlockNumberIncrease = 10000; // Maximum valid block number between Chainlink Updates\\r\\n\\r\\n    uint256 immutable factor;\\r\\n\\r\\n    address public immutable KladeAddress1;\\r\\n    address public immutable KladeAddress2;\\r\\n    ISafeMath public immutable safemath;\\r\\n\\r\\n    struct ChainlinkUpdate {\\r\\n        uint256 block_number;\\r\\n        uint256 difficulty;\\r\\n        uint80 blocknum_roundID;\\r\\n        uint80 diff_roundID;\\r\\n    }\\r\\n\\r\\n    struct quarter_details {\\r\\n        IKladeDiffToken alpha_token;\\r\\n        IKladeDiffToken omega_token;\\r\\n        IChainlinkOracle chainlink_diff_oracle;\\r\\n        IChainlinkOracle chainlink_blocknum_oracle;\\r\\n        uint256 required_collateral;\\r\\n        uint256 hedged_revenue;\\r\\n        uint256 end_unix;\\r\\n        uint256 intermediateActualMinerEarnings;\\r\\n        uint256 number_of_updates;\\r\\n    }\\r\\n\\r\\n    quarter_details public Q3_details;\\r\\n    bool public Q3_set;\\r\\n    mapping(uint256 =\\u003e ChainlinkUpdate) public chainlink_data;\\r\\n\\r\\n    constructor(\\r\\n        address klade_address1,\\r\\n        address klade_address2,\\r\\n        ISafeMath safemath_contract\\r\\n    ) {\\r\\n        KladeAddress1 = klade_address1;\\r\\n        KladeAddress2 = klade_address2;\\r\\n        safemath = safemath_contract;\\r\\n        factor = safemath_contract.mul(initial_factor, multiple);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set basic quarter details for Chainlink Receiver\\r\\n     * @param alpha_token_contract IKladeDiffToken - Klade Alpha Token Contract\\r\\n     * @param omega_token_contract IKladeDifFToken - Klade Omega Token Contract\\r\\n     * @param chainlink_diff_oracle IChainlinkOracle - Chainlink oracle contract that provides difficulty information\\r\\n     * @param chainlink_blocknum_oracle IChainlinkOracle - Chainlink oracle contract that provides difficulty information\\r\\n     * @param required_collateral uint - required collateral to mint a single pair of Klade Alpha/Omega tokens\\r\\n     * @param hedged_revenue uint - hedged revenue for bitcoin miners for single pair of tokens\\r\\n     * @param miner_earnings uint - miner earnings for single pair of tokens\\r\\n     */\\r\\n    function set_quarter_details(\\r\\n        IKladeDiffToken alpha_token_contract,\\r\\n        IKladeDiffToken omega_token_contract,\\r\\n        IChainlinkOracle chainlink_diff_oracle,\\r\\n        IChainlinkOracle chainlink_blocknum_oracle,\\r\\n        uint256 required_collateral,\\r\\n        uint256 hedged_revenue,\\r\\n        uint256 miner_earnings\\r\\n    ) external {\\r\\n        require(\\r\\n            msg.sender == KladeAddress1 || msg.sender == KladeAddress2,\\r\\n            \\\"Only Klade can set quarter details\\\"\\r\\n        );\\r\\n        require(Q3_set == false, \\\"Quarter details already set\\\");\\r\\n        Q3_details = quarter_details(\\r\\n            alpha_token_contract,\\r\\n            omega_token_contract,\\r\\n            chainlink_diff_oracle,\\r\\n            chainlink_blocknum_oracle,\\r\\n            required_collateral,\\r\\n            hedged_revenue,\\r\\n            Q3_end_unix,\\r\\n            miner_earnings,\\r\\n            0\\r\\n        );\\r\\n        Q3_set = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * At the call to getChainlinkUpdate at the beginning or end of the quarter, the current_block_number should\\r\\n     * be passed in as the block number at the beginning or end of the quarter.\\r\\n     * On all other calls, current_block_number should be fed as the block number\\r\\n     * at the most recent time the Oracle has updated its data\\r\\n     */\\r\\n    function getChainlinkUpdate() external returns (bool updated) {\\r\\n        require(Q3_set, \\\"Quarter details not set yet\\\");\\r\\n        uint256 i = Q3_details.number_of_updates;\\r\\n        require(i \\u003c 13, \\\"All datapoints for the quarter have been collected\\\");\\r\\n\\r\\n        ChainlinkUpdate memory current_update =\\r\\n            read_chainlink(\\r\\n                Q3_details.chainlink_blocknum_oracle,\\r\\n                Q3_details.chainlink_diff_oracle\\r\\n            );\\r\\n        require(\\r\\n            check_reasonable_values(current_update),\\r\\n            \\\"Unreasonable Chainlink Data\\\"\\r\\n        );\\r\\n        if (\\r\\n            (i == 0) ||\\r\\n            new_chainlink_data(\\r\\n                chainlink_data[safemath.sub(i, 1)],\\r\\n                current_update\\r\\n            )\\r\\n        ) {\\r\\n            chainlink_data[i] = current_update;\\r\\n            Q3_details.number_of_updates = safemath.add(\\r\\n                Q3_details.number_of_updates,\\r\\n                1\\r\\n            );\\r\\n            if (i \\u003e 0) {\\r\\n                Q3_details.intermediateActualMinerEarnings = safemath.add(\\r\\n                    Q3_details.intermediateActualMinerEarnings,\\r\\n                    additional_miner_earnings(\\r\\n                        chainlink_data[safemath.sub(i, 1)],\\r\\n                        current_update\\r\\n                    )\\r\\n                );\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Checks if the current_update has updated difficulty and block_number values\\r\\n     * compared to last_update. If either the difficulty or the block_number has\\r\\n     * not been updated by Chainlink, this returns false.\\r\\n     * @param last_update ChainlinkUpdate - previous update data returned by Chainlink Oracle\\r\\n     * @param current_update ChainlinkUpdate - most recent update data returned by Chainlink Oracle\\r\\n     */\\r\\n    function new_chainlink_data(\\r\\n        ChainlinkUpdate memory last_update,\\r\\n        ChainlinkUpdate memory current_update\\r\\n    ) internal pure returns (bool new_data) {\\r\\n        bool new_difficulty_data =\\r\\n            current_update.diff_roundID != last_update.diff_roundID;\\r\\n        bool new_blocknum_data =\\r\\n            current_update.blocknum_roundID != last_update.blocknum_roundID;\\r\\n        return new_difficulty_data \\u0026\\u0026 new_blocknum_data;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calls Chainlink\\u0027s Oracles, gets the latest data, and returns it.\\r\\n     * @param blocknum_oracle IChainlinkOracle - Chainlink block number oracle\\r\\n     * @param diff_oracle IChainlinkOracle - Chainlink difficulty number oracle\\r\\n     */\\r\\n    function read_chainlink(\\r\\n        IChainlinkOracle blocknum_oracle,\\r\\n        IChainlinkOracle diff_oracle\\r\\n    ) internal view returns (ChainlinkUpdate memory latest) {\\r\\n        uint80 updated_roundID_diff;\\r\\n        int256 current_diff;\\r\\n        uint256 startedAt;\\r\\n        uint256 updatedAt;\\r\\n        uint80 answeredInRound;\\r\\n        int256 current_blocknum;\\r\\n        uint80 updated_roundID_blocknum;\\r\\n\\r\\n        (\\r\\n            updated_roundID_blocknum,\\r\\n            current_blocknum,\\r\\n            startedAt,\\r\\n            updatedAt,\\r\\n            answeredInRound\\r\\n        ) = blocknum_oracle.latestRoundData();\\r\\n\\r\\n        (\\r\\n            updated_roundID_diff,\\r\\n            current_diff,\\r\\n            startedAt,\\r\\n            updatedAt,\\r\\n            answeredInRound\\r\\n        ) = diff_oracle.latestRoundData();\\r\\n\\r\\n        return\\r\\n            ChainlinkUpdate(\\r\\n                uint256(current_blocknum),\\r\\n                uint256(current_diff),\\r\\n                updated_roundID_blocknum,\\r\\n                updated_roundID_diff\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Revenue (in WBTC base units) for 10 TH/s over the blocks from startBlock to endBlock\\r\\n     * does not account for if there is a halving in between a difficulty update.\\r\\n     * should not be relevant for Q3 2021\\r\\n     * @param last_update ChainlinkUpdate - previous update data returned by Chainlink Oracle\\r\\n     * @param current_update ChainlinkUpdate - most recent update data returned by Chainlink Oracle\\r\\n     */\\r\\n    function additional_miner_earnings(\\r\\n        ChainlinkUpdate memory last_update,\\r\\n        ChainlinkUpdate memory current_update\\r\\n    ) internal view returns (uint256 earnings) {\\r\\n        uint256 startBlock = last_update.block_number;\\r\\n        uint256 startDiff = last_update.difficulty;\\r\\n        uint256 endBlock = current_update.block_number;\\r\\n        uint256 endDiff = current_update.difficulty;\\r\\n\\r\\n        require(\\r\\n            endBlock \\u003e= startBlock,\\r\\n            \\\"Latest Block Number is less than last block number\\\"\\r\\n        );\\r\\n        uint256 last_diff_update_block = get_last_diff_update(endBlock);\\r\\n        if (last_diff_update_block \\u003c= startBlock) {\\r\\n            return\\r\\n                safemath.mul(\\r\\n                    safemath.sub(endBlock, startBlock),\\r\\n                    earnings_on_block(endDiff, startBlock)\\r\\n                );\\r\\n        } else {\\r\\n            uint256 total =\\r\\n                safemath.mul(\\r\\n                    safemath.sub(last_diff_update_block, startBlock),\\r\\n                    earnings_on_block(startDiff, startBlock)\\r\\n                );\\r\\n            total = safemath.add(\\r\\n                total,\\r\\n                safemath.mul(\\r\\n                    safemath.sub(endBlock, last_diff_update_block),\\r\\n                    earnings_on_block(endDiff, endBlock)\\r\\n                )\\r\\n            );\\r\\n            return total;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the Bitcoin block number when difficulty was last updated prior to the given block_num\\r\\n     * @param block_num uint - bitcoin block number\\r\\n     */\\r\\n    function get_last_diff_update(uint256 block_num)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            safemath.sub(\\r\\n                block_num,\\r\\n                safemath.mod(block_num, numBlockBetweenDiffChanges)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns earnings in WBTC base units\\r\\n     * @param difficulty uint - bitcoin network difficulty\\r\\n     * @param block_number uint - bitcoin block number\\r\\n     */\\r\\n    function earnings_on_block(uint256 difficulty, uint256 block_number)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 numerator =\\r\\n            safemath.mul(factor, block_reward_on_block(block_number));\\r\\n        return safemath.div(numerator, difficulty);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns bitcoin block reward in WBTC base units\\r\\n     * @param block_number uint - bitcoin block number\\r\\n     */\\r\\n    function block_reward_on_block(uint256 block_number)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 divisor =\\r\\n            2**(safemath.div(block_number, blocksBetweenHalvings));\\r\\n        return safemath.div(initialBlockReward, divisor);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Check that the values that are trying to be added to the ChainlinkData \\r\\n     * for a quarter actually makes sense. \\r\\n     * Returns True if the update seems reasonable and returns false if the update\\r\\n     * values seems unreasonable\\r\\n     * Very generous constraints that are just sanity checks.\\r\\n     * @param update ChainlinkUpdate - A chainlink update with block number and difficulty data\\r\\n     */\\r\\n    function check_reasonable_values(ChainlinkUpdate memory update)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool reasonable)\\r\\n    {\\r\\n        uint256 update_diff = update.difficulty;\\r\\n        uint256 update_block_number = update.block_number;\\r\\n        uint256 number_of_updates = Q3_details.number_of_updates;\\r\\n        if (\\r\\n            (update_diff \\u003e maxValidDifficulty) ||\\r\\n            (update_diff \\u003c minValidDifficulty)\\r\\n        ) {\\r\\n            return false;\\r\\n        }\\r\\n        if (\\r\\n            (update_block_number \\u003e maxValidBlockNum) ||\\r\\n            (update_block_number \\u003c minValidBlockNum)\\r\\n        ) {\\r\\n            return false;\\r\\n        }\\r\\n        if (number_of_updates \\u003e 0) {\\r\\n            uint256 last_update_block_number =\\r\\n                chainlink_data[safemath.sub(number_of_updates, 1)].block_number;\\r\\n            if (update_block_number \\u003c= last_update_block_number) {\\r\\n                return false;\\r\\n            }\\r\\n            if (\\r\\n                update_block_number \\u003e\\r\\n                safemath.add(\\r\\n                    last_update_block_number,\\r\\n                    maxValidBlockNumberIncrease\\r\\n                )\\r\\n            ) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // payouts are set in WBTC base units for 1.0 tokens\\r\\n    function set_payouts() public {\\r\\n        require(\\r\\n            Q3_details.number_of_updates == 13,\\r\\n            \\\"Need 13 datapoints before setting payout\\\"\\r\\n        );\\r\\n        require(\\r\\n            (block.timestamp \\u003e= Q3_details.end_unix),\\r\\n            \\\"You cannot set a payout yet\\\"\\r\\n        );\\r\\n\\r\\n        uint256 hedged_revenue = Q3_details.hedged_revenue;\\r\\n        uint256 required_collateral = Q3_details.required_collateral;\\r\\n\\r\\n        uint256 miner_revenue =\\r\\n            safemath.div(Q3_details.intermediateActualMinerEarnings, multiple);\\r\\n        if ((hedged_revenue \\u003e miner_revenue)) {\\r\\n            uint256 alpha_token_payout =\\r\\n                safemath.min(\\r\\n                    safemath.sub(hedged_revenue, miner_revenue),\\r\\n                    required_collateral\\r\\n                );\\r\\n            uint256 omega_token_payout =\\r\\n                safemath.sub(required_collateral, alpha_token_payout);\\r\\n            Q3_details.alpha_token.set_payout(alpha_token_payout);\\r\\n            Q3_details.omega_token.set_payout(omega_token_payout);\\r\\n        } else {\\r\\n            Q3_details.alpha_token.set_payout(0);\\r\\n            Q3_details.omega_token.set_payout(required_collateral);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // If any address accidentally sends any ERC20 token to this address,\\r\\n    // they can contact us. Off-chain we will verify that the address did\\r\\n    // in fact accidentally send tokens and return them.\\r\\n    function anyTokenTransfer(\\r\\n        IERC20 token,\\r\\n        uint256 num,\\r\\n        address to\\r\\n    ) external returns (bool success) {\\r\\n        require(\\r\\n            (msg.sender == KladeAddress1 || msg.sender == KladeAddress2),\\r\\n            \\\"Only Klade can recover tokens\\\"\\r\\n        );\\r\\n        return token.transfer(to, num);\\r\\n    }\\r\\n}\\r\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.3;\\r\\nimport { ITokenManager, IERC20, ISafeMath } from \\u0027./Interfaces.sol\\u0027;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// Implementation of ERC20 Standard\\r\\n// ----------------------------------------------------------------------------\\r\\ncontract ERC20 is IERC20 {\\r\\n    string public _symbol;\\r\\n    string public _name;\\r\\n    uint8 public _decimals;\\r\\n    uint public _totalSupply;\\r\\n\\r\\n    // For each person map between their address and the number of tokens they have\\r\\n    mapping(address =\\u003e uint) balances;\\r\\n    // To transfer erc20 token, give contract permission to transfer. Maps from your address to address of transfer target and amount to transfer.\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\r\\n\\r\\n    ISafeMath immutable public safemath;\\r\\n\\r\\n    constructor(string memory symbol, string memory name, uint8 decimals, uint total_supply, ISafeMath safemath_contract) {\\r\\n        _symbol = symbol;\\r\\n        _name = name;\\r\\n        _decimals = decimals;\\r\\n        _totalSupply = total_supply;\\r\\n        safemath = safemath_contract;\\r\\n    }\\r\\n\\r\\n    //Returns decimals that this token uses.\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n\\r\\n    //Returns the token name\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n\\r\\n    //Returns the symbol\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Return total supply\\r\\n    function totalSupply() public override view returns (uint) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Return the token balance for account tokenOwner\\r\\n    function balanceOf(address _token_owner) public override view returns (uint balance) {\\r\\n        return balances[_token_owner];\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Transfer the balance from token owner\\u0027s account to to account\\r\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\r\\n    // - 0 value transfers are allowed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transfer(address _to, uint _num_tokens) public override returns (bool success) {\\r\\n        require(_num_tokens \\u003c= balances[msg.sender], \\\"You are trying to transfer more tokens than you have\\\");\\r\\n\\r\\n        balances[msg.sender] = safemath.sub(balances[msg.sender], _num_tokens);\\r\\n        balances[_to] = safemath.add(balances[_to], _num_tokens);\\r\\n        emit Transfer(msg.sender, _to, _num_tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Token owner can approve for spender to transferFrom(...) tokens\\r\\n    // from the token owner\\u0027s account\\r\\n    //\\r\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\r\\n    // recommends that there are no checks for the approval double-spend attack\\r\\n    // as this should be implemented in user interfaces\\r\\n    // ------------------------------------------------------------------------\\r\\n    function approve(address spender, uint tokens) public override returns (bool success) {\\r\\n        allowed[msg.sender][spender] = tokens;\\r\\n        emit Approval(msg.sender, spender, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Non-standard approval function that takes care of the potential double-spend issue\\r\\n    // If a user wants to ensure that the double spend issue doesn\\u0027t become a problem, they can choose\\r\\n    // to use this function instead of the standard approve function.\\r\\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool success) {\\r\\n        uint oldValue = allowed[msg.sender][_spender];\\r\\n        allowed[msg.sender][_spender] = safemath.add(oldValue, _addedValue);\\r\\n        emit Approval(msg.sender, _spender, safemath.add(oldValue, _addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Non-standard approval function that takes care of the potential double-spend issue\\r\\n    // If a user wants to ensure that the double spend issue doesn\\u0027t become a problem, they can choose\\r\\n    // to use this function instead of the standard approve function.\\r\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool success) {\\r\\n        uint oldValue = allowed[msg.sender][_spender];\\r\\n        allowed[msg.sender][_spender] = safemath.sub(oldValue, _subtractedValue);\\r\\n        emit Approval(msg.sender, _spender, safemath.sub(oldValue, _subtractedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Transfer tokens from the from account to the to account\\r\\n    //\\r\\n    // The calling account must already have sufficient tokens approve(...)-d\\r\\n    // for spending from the from account and\\r\\n    // - From account must have sufficient balance to transfer\\r\\n    // - Spender must have sufficient allowance to transfer\\r\\n    // - 0 value transfers are allowed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\\r\\n        balances[from] = safemath.sub(balances[from], tokens);\\r\\n        allowed[from][msg.sender] = safemath.sub(allowed[from][msg.sender], tokens);\\r\\n        balances[to] = safemath.add(balances[to], tokens);\\r\\n        emit Transfer(from, to, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Returns the amount of tokens approved by the owner that can be\\r\\n    // transferred to the spender\\u0027s account\\r\\n    // ------------------------------------------------------------------------\\r\\n    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\\r\\n        return allowed[tokenOwner][spender];\\r\\n    }\\r\\n\\r\\n}\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.3;\\r\\n\\r\\ninterface ITokenManager {\\r\\n    function payout(string calldata quarter, address recipient, uint amount) external returns (bool success);\\r\\n}\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// ERC Token Standard #20 Interface\\r\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\r\\n// ----------------------------------------------------------------------------\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface ISafeMath {\\r\\n    function add(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function sub(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function mul(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function div(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function min(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function mod(uint256 a, uint256 b) external pure returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IKladeDiffToken {\\r\\n    function set_payout(uint payout) external;\\r\\n    function mint_tokens(address token_recipient, uint256 numToMint) external returns (bool success);\\r\\n}\\r\\n\\r\\ninterface IChainlinkOracle {\\r\\n    function latestRoundData() external view returns (\\r\\n          uint80,\\r\\n          int256,\\r\\n          uint256,\\r\\n          uint256,\\r\\n          uint80\\r\\n    );\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"klade_address1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"klade_address2\",\"type\":\"address\"},{\"internalType\":\"contract ISafeMath\",\"name\":\"safemath_contract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"KladeAddress1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"KladeAddress2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Q3_details\",\"outputs\":[{\"internalType\":\"contract IKladeDiffToken\",\"name\":\"alpha_token\",\"type\":\"address\"},{\"internalType\":\"contract IKladeDiffToken\",\"name\":\"omega_token\",\"type\":\"address\"},{\"internalType\":\"contract IChainlinkOracle\",\"name\":\"chainlink_diff_oracle\",\"type\":\"address\"},{\"internalType\":\"contract IChainlinkOracle\",\"name\":\"chainlink_blocknum_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"required_collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hedged_revenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end_unix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"intermediateActualMinerEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number_of_updates\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Q3_set\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"anyTokenTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chainlink_data\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"block_number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"difficulty\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"blocknum_roundID\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"diff_roundID\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainlinkUpdate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"updated\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safemath\",\"outputs\":[{\"internalType\":\"contract ISafeMath\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"set_payouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKladeDiffToken\",\"name\":\"alpha_token_contract\",\"type\":\"address\"},{\"internalType\":\"contract IKladeDiffToken\",\"name\":\"omega_token_contract\",\"type\":\"address\"},{\"internalType\":\"contract IChainlinkOracle\",\"name\":\"chainlink_diff_oracle\",\"type\":\"address\"},{\"internalType\":\"contract IChainlinkOracle\",\"name\":\"chainlink_blocknum_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"required_collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hedged_revenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"miner_earnings\",\"type\":\"uint256\"}],\"name\":\"set_quarter_details\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ChainlinkReceiver","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a61a62352faf6ad883a8d36975cf39cdeb477d25000000000000000000000000e4147a2b5bac2d1b9fa23a1c0d477700af590280000000000000000000000000fd629b1fbc77644b23287f8acd0aea58ac695c35","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f2c287e64a52349e9a690f2b544b78d710907037e80c1f2cc8b07282c1792e72"}]}