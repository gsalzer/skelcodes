{"status":"1","message":"OK","result":[{"SourceCode":"{\"CanReclaimToken.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\npragma experimental SMTChecker;\\n\\n\\nimport \\\"ERC20If.sol\\\";\\nimport \\\"OwnableIf.sol\\\";\\n\\n/// @title CanReclaimToken\\nabstract contract CanReclaimToken is OwnableIf {\\n\\n    function reclaimToken(ERC20If _token) external onlyOwner {\\n        uint256 balance = _token.balanceOf((address)(this));\\n        require(_token.transfer(_owner(), balance));\\n    }\\n\\n}\\n\\n\"},\"Claimable.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\npragma experimental SMTChecker;\\n\\n\\nimport \\\"Ownable.sol\\\";\\n\\n// File: openzeppelin-solidity/contracts/ownership/Claimable.sol\\n\\n/**\\n * @title Claimable\\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\\n * This allows the new owner to accept the transfer.\\n */\\ncontract Claimable is Ownable {\\n    address public pendingOwner;\\n\\n    /**\\n     * @dev Modifier throws if called by any account other than the pendingOwner.\\n     */\\n    modifier onlyPendingOwner() {\\n        require(msg.sender == pendingOwner, \\\"no permission\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to set the pendingOwner address.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) override public onlyOwner {\\n        pendingOwner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Allows the pendingOwner address to finalize the transfer.\\n     */\\n    function claimOwnership() public onlyPendingOwner {\\n        emit OwnershipTransferred(owner, pendingOwner);\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n}\\n\\n\"},\"ERC20If.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\npragma experimental SMTChecker;\\n\\n/// @title ERC20If\\nabstract contract ERC20If {\\n    function totalSupply() virtual public view returns (uint256);\\n\\n    function balanceOf(address _who) virtual public view returns (uint256);\\n\\n    function transfer(address _to, uint256 _value) virtual public returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function allowance(address _owner, address _spender) virtual public view returns (uint256);\\n\\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool);\\n\\n    function approve(address _spender, uint256 _value) virtual public returns (bool);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n\"},\"MemberMgr.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\npragma experimental SMTChecker;\\n\\n\\nimport \\\"MemberMgrIf.sol\\\";\\nimport \\\"Claimable.sol\\\";\\nimport \\\"CanReclaimToken.sol\\\";\\n\\n/// @title MemberMgr - add, delete, suspend and resume merchant and it’s eth address; reset the custodian’s eth address.\\ncontract MemberMgr is Claimable, MemberMgrIf, CanReclaimToken {\\n    address public custodian;\\n    enum MerchantStatus {STOPPED, VALID}\\n    struct MerchantStatusData {\\n        MerchantStatus status;\\n        bool _exist;\\n    }\\n\\n    function getStatusString(MerchantStatusData memory data) internal pure returns (string memory) {\\n        if (!data._exist) return \\\"not-exist\\\";\\n        if (data.status == MerchantStatus.STOPPED) {\\n            return \\\"stopped\\\";\\n        } else if (data.status == MerchantStatus.VALID) {\\n            return \\\"valid\\\";\\n        } else {\\n            return \\\"not-exist\\\";\\n        }\\n    }\\n\\n    mapping(address =\\u003e MerchantStatusData) public merchantStatus;\\n    address[] merchantList;\\n\\n    function getMerchantNumber() public view returns (uint){\\n        return merchantList.length;\\n    }\\n\\n    function getMerchantState(uint index) public view returns (address _addr, string memory _status){\\n        require(index \\u003c merchantList.length, \\\"invalid index\\\");\\n        address addr = merchantList[index];\\n        MerchantStatusData memory data = merchantStatus[addr];\\n        _addr = addr;\\n        _status = getStatusString(data);\\n    }\\n\\n    function requireMerchant(address _who) override public view {\\n        MerchantStatusData memory merchantState = merchantStatus[_who];\\n        require (merchantState._exist, \\\"not a merchant\\\");\\n\\n        require (merchantState.status != MerchantStatus.STOPPED, \\\"merchant has been stopped\\\");\\n\\n        require(merchantState.status == MerchantStatus.VALID, \\\"merchant not valid\\\");\\n    }\\n\\n\\n    function requireCustodian(address _who) override public view {\\n        require(_who == custodian, \\\"not custodian\\\");\\n    }\\n\\n    event CustodianSet(address indexed custodian);\\n\\n    function setCustodian(address _custodian) external onlyOwner returns (bool) {\\n        require(_custodian != address(0), \\\"invalid custodian address\\\");\\n        custodian = _custodian;\\n\\n        emit CustodianSet(_custodian);\\n        return true;\\n    }\\n\\n    event NewMerchant(address indexed merchant);\\n\\n    function addMerchant(address merchant) external onlyOwner returns (bool) {\\n        require(merchant != address(0), \\\"invalid merchant address\\\");\\n        MerchantStatusData memory data = merchantStatus[merchant];\\n        require(!data._exist, \\\"merchant exists\\\");\\n        merchantStatus[merchant] = MerchantStatusData({\\n            status : MerchantStatus.VALID,\\n            _exist : true\\n            });\\n\\n        merchantList.push(merchant);\\n        emit NewMerchant(merchant);\\n        return true;\\n    }\\n\\n    event MerchantStopped(address indexed merchant);\\n\\n    function stopMerchant(address merchant) external onlyOwner returns (bool) {\\n        require(merchant != address(0), \\\"invalid merchant address\\\");\\n        MerchantStatusData memory data = merchantStatus[merchant];\\n        require(data._exist, \\\"merchant not exists\\\");\\n        require(data.status == MerchantStatus.VALID, \\\"invalid status\\\");\\n        merchantStatus[merchant].status = MerchantStatus.STOPPED;\\n\\n        emit MerchantStopped(merchant);\\n        return true;\\n    }\\n\\n    event MerchantResumed(address indexed merchant);\\n\\n    function resumeMerchant(address merchant) external onlyOwner returns (bool) {\\n        require(merchant != address(0), \\\"invalid merchant address\\\");\\n        MerchantStatusData memory data = merchantStatus[merchant];\\n        require(data._exist, \\\"merchant not exists\\\");\\n        require(data.status == MerchantStatus.STOPPED, \\\"invalid status\\\");\\n        merchantStatus[merchant].status = MerchantStatus.VALID;\\n\\n        emit MerchantResumed(merchant);\\n        return true;\\n    }\\n\\n    function isCustodian(address addr) external view returns (bool) {\\n        return (addr == custodian);\\n    }\\n\\n    function isMerchant(address addr) external view returns (bool) {\\n        return merchantStatus[addr]._exist \\u0026\\u0026 merchantStatus[addr].status == MerchantStatus.VALID;\\n    }\\n}\\n\"},\"MemberMgrIf.sol\":{\"content\":\"pragma solidity ^0.7.0;\\npragma experimental SMTChecker;\\n\\n//SPDX-License-Identifier: MIT\\n/// @title MemberMgrIf\\nabstract contract MemberMgrIf {\\n    function requireMerchant(address _who) virtual public view;\\n\\n    function requireCustodian(address _who) virtual public view;\\n}\\n\"},\"Ownable.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\npragma experimental SMTChecker;\\n\\n\\nimport \\\"OwnableIf.sol\\\";\\n\\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable is OwnableIf {\\n    address public owner;\\n\\n    function _owner() view override public returns (address){\\n        return owner;\\n    }\\n\\n    //    event OwnershipRenounced(address indexed previousOwner);\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    //    /**\\n    //     * @dev Throws if called by any account other than the owner.\\n    //     */\\n    //    modifier onlyOwner() {\\n    //        require(msg.sender == owner);\\n    //        _;\\n    //    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    //   function renounceOwnership() public onlyOwner {\\n    //     emit OwnershipRenounced(owner);\\n    //     owner = address(0);\\n    //   }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address _newOwner) virtual public onlyOwner {\\n        _transferOwnership(_newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param _newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address _newOwner) internal {\\n        require(_newOwner != address(0), \\\"invalid _newOwner\\\");\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n}\\n\\n\\n\"},\"OwnableIf.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\npragma experimental SMTChecker;\\n\\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\nabstract contract OwnableIf {\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == _owner(), \\\"not owner......\\\");\\n        _;\\n    }\\n\\n    function _owner() view virtual public returns (address);\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"custodian\",\"type\":\"address\"}],\"name\":\"CustodianSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"}],\"name\":\"MerchantResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"}],\"name\":\"MerchantStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"}],\"name\":\"NewMerchant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"}],\"name\":\"addMerchant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"custodian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMerchantNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getMerchantState\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_status\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isCustodian\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isMerchant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"merchantStatus\",\"outputs\":[{\"internalType\":\"enum MemberMgr.MerchantStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_exist\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20If\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"requireCustodian\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"requireMerchant\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"}],\"name\":\"resumeMerchant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_custodian\",\"type\":\"address\"}],\"name\":\"setCustodian\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"}],\"name\":\"stopMerchant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MemberMgr","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://eb2b839ac2f48051f9536fe9648fbaab08e37b54cf9a2cdb714b409cbaf25d32"}]}