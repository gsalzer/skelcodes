{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOAssetHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nlibrary ACOAssetHelper {\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get if the address is for Ethereum (0x0).\\r\\n     * @param _address Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address _address) internal pure returns(bool) {\\r\\n        return _address == address(0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to approve ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param spender Authorized address.\\r\\n     * @param amount Amount to authorize.\\r\\n     */\\r\\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callApproveERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callTransferERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to call transferFrom on ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param sender Address of the sender.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callTransferFromERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset symbol.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset symbol.\\r\\n     */\\r\\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetSymbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset decimals.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset decimals.\\r\\n     */\\r\\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\\r\\n        if (_isEther(asset)) {\\r\\n            return uint8(18);\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetDecimals\\\");\\r\\n            return abi.decode(returndata, (uint8));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to the asset name.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset name.\\r\\n     */\\r\\n    function _getAssetName(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"Ethereum\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetName\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset balance of an account.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param account Address of the account.\\r\\n     * @return The account balance.\\r\\n     */\\r\\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return account.balance;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetBalanceOf\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset allowance between two addresses.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @return The owner allowance for the spender.\\r\\n     */\\r\\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetAllowance\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer an asset. \\r\\n     * @param asset Address of the asset to be transferred.\\r\\n     * @param to Address of the destination.\\r\\n     * @param amount The amount to be transferred.\\r\\n     */\\r\\n    function _transferAsset(address asset, address to, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            (bool success,) = to.call{value:amount}(new bytes(0));\\r\\n            require(success, \\u0027ACOAssetHelper::_transferAsset\\u0027);\\r\\n        } else {\\r\\n            _callTransferERC20(asset, to, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to receive an asset. \\r\\n     * @param asset Address of the asset to be received.\\r\\n     * @param amount The amount to be received.\\r\\n     */\\r\\n    function _receiveAsset(address asset, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            require(msg.value == amount, \\\"ACOAssetHelper:: Invalid ETH amount\\\");\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"ACOAssetHelper:: Ether is not expected\\\");\\r\\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @param amount Amount to check allowance.\\r\\n     */\\r\\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\\r\\n        if (_getAssetAllowance(asset, owner, spender) \\u003c amount) {\\r\\n            _callApproveERC20(asset, spender, MAX_UINT);\\r\\n        }\\r\\n    }\\r\\n}\"},\"ACOPool2.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./Ownable.sol\\u0027;\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\nimport \\u0027./ACOAssetHelper.sol\\u0027;\\r\\nimport \\u0027./ERC20.sol\\u0027;\\r\\nimport \\u0027./IACOFactory.sol\\u0027;\\r\\nimport \\u0027./IACOAssetConverterHelper.sol\\u0027;\\r\\nimport \\u0027./IACOToken.sol\\u0027;\\r\\nimport \\u0027./IChiToken.sol\\u0027;\\r\\nimport \\u0027./IACOPoolStrategy.sol\\u0027;\\r\\nimport \\u0027./IACOPool2.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title ACOPool2\\r\\n * @dev A pool contract to trade ACO tokens.\\r\\n * \\r\\n * The SC errors are defined as code to shrunk the SC bytes size and work around the EIP170.\\r\\n * The codes are explained in the table below:\\r\\n ********************************************************************************************\\r\\n * CODE | FUNCTION                            | DESCRIPTION\\t\\t\\t\\t\\t\\t            *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E00  | init                                | SC is already initialized                   *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E01  | init                                | Invalid ACO Factory address                 *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E02  | init                                | Invalid Chi Token address                   *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E03  | init                                | Underlying and strike asset are the same    *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E04  | init                                | Invalid underlying address                  *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E05  | init                                | Invalid strike asset address                *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E10  | _deposit                            | Invalid collateral amount                   *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E11  | _deposit                            | Invalid destination address                 *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E12  | _deposit                            | The minimum shares were not satisfied       *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E20  | _withdrawWithLocked                 | Invalid shares amount                       *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E30  | _withdrawNoLocked                   | Invalid shares amount                       *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E31  | _withdrawNoLocked                   | Collateral balance is not sufficient        *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E32  | _withdrawNoLocked                   | The minimum collateral was not satisfied    *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E33  | _withdrawNoLocked                   | Collateral balance is not sufficient        *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E34  | _withdrawNoLocked                   | Collateral balance is not sufficient        *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E40  | _swap                               | Swap deadline reached                       *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E41  | _swap                               | Invalid destination address                 *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E42  | _internalSelling                    | The maximum payment restriction was reached *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E43  | _internalSelling                    | The maximum number of open ACOs was reached *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E50  | _quote                              | Invalid token amount                        *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E51  | _quote                              | Invalid ACO token                           *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E52  | _quote                              | Invalid ACO token expiration                *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E53  | _quote                              | Invalid ACO token strike price              *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E54  | _quote                              | ACO token expired                           *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E55  | _internalQuote                      | Invalid quoted price                        *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E56  | _getSizeData                        | The token amount is too small               *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E57  | _getSizeData                        | Insufficient liquidity                      *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E60  | restoreCollateral                   | No balance to restore                       *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E80  | withdrawStuckToken                  | The token is forbidden to withdraw          *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E81  | _setStrategy                        | Invalid strategy address                    *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E82  | _setBaseVolatility                  | Invalid base volatility                     *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E83  | _setAssetConverter                  | Invalid asset converter address             *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E84  | _setAssetConverter                  | No price on the Oracle                      *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E85  | _setTolerancePriceAbove             | Invalid above tolerance percentage          *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E86  | _setTolerancePriceBelow             | Invalid below tolerance percentage          *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E87  | _setMinExpiration                   | Invalid minimum seconds for expiration      *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E88  | _setMaxExpiration                   | Invalid maximum seconds for expiration      *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E89  | _setFeeDestination                  | Invalid fee destination address             *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E90  | onlyFactory                         | Only the pool factory can call the method   *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E91  | _setFee                             | Invalid fee value                           *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E92  | _setWithdrawOpenPositionPenalty     | Invalid penalty percentage                  *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E93  | _setUnderlyingPriceAdjustPercentage | Invalid underlying price adjust percentage  *\\r\\n *------------------------------------------------------------------------------------------*\\r\\n * E94  | _setMaximumOpenAco                  | Invalid maximum number of open ACOs allowed *\\r\\n ********************************************************************************************\\r\\n */\\r\\ncontract ACOPool2 is Ownable, ERC20, IACOPool2 {\\r\\n    using Address for address;\\r\\n    \\r\\n    uint256 internal constant PERCENTAGE_PRECISION = 100000;\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\r\\n\\t/**\\r\\n     * @dev Emitted when the asset converter address has been changed.\\r\\n     * @param oldAssetConverter Address of the previous asset converter.\\r\\n     * @param newAssetConverter Address of the new asset converter.\\r\\n     */\\r\\n    event SetAssetConverter(address indexed oldAssetConverter, address indexed newAssetConverter);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the above tolerance price has been changed.\\r\\n     * @param oldTolerancePriceAbove Value of the previous above tolerance price.\\r\\n     * @param newTolerancePriceAbove Value of the new above tolerance price.\\r\\n     */\\r\\n    event SetTolerancePriceAbove(uint256 indexed oldTolerancePriceAbove, uint256 indexed newTolerancePriceAbove);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the below tolerance price has been changed.\\r\\n     * @param oldTolerancePriceBelow Value of the previous below tolerance price.\\r\\n     * @param newTolerancePriceBelow Value of the new below tolerance price.\\r\\n     */\\r\\n    event SetTolerancePriceBelow(uint256 indexed oldTolerancePriceBelow, uint256 indexed newTolerancePriceBelow);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the minimum expiration has been changed.\\r\\n     * @param oldMinExpiration Value of the previous minimum expiration.\\r\\n     * @param newMinExpiration Value of the new minimum expiration.\\r\\n     */\\r\\n    event SetMinExpiration(uint256 indexed oldMinExpiration, uint256 indexed newMinExpiration);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the maximum expiration has been changed.\\r\\n     * @param oldMaxExpiration Value of the previous maximum expiration.\\r\\n     * @param newMaxExpiration Value of the new maximum expiration.\\r\\n     */\\r\\n    event SetMaxExpiration(uint256 indexed oldMaxExpiration, uint256 indexed newMaxExpiration);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the penalty percentage on withdrawing open positions has been changed.\\r\\n     * @param oldWithdrawOpenPositionPenalty Value of the previous penalty percentage on withdrawing open positions.\\r\\n     * @param newWithdrawOpenPositionPenalty Value of the new penalty percentage on withdrawing open positions.\\r\\n     */\\r\\n\\tevent SetWithdrawOpenPositionPenalty(uint256 indexed oldWithdrawOpenPositionPenalty, uint256 indexed newWithdrawOpenPositionPenalty);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the underlying price percentage adjust has been changed.\\r\\n     * @param oldUnderlyingPriceAdjustPercentage Value of the previous underlying price percentage adjust.\\r\\n     * @param newUnderlyingPriceAdjustPercentage Value of the new underlying price percentage adjust.\\r\\n     */\\r\\n\\tevent SetUnderlyingPriceAdjustPercentage(uint256 indexed oldUnderlyingPriceAdjustPercentage, uint256 indexed newUnderlyingPriceAdjustPercentage);\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Emitted when the number of maximum open ACOs allowed has been changed.\\r\\n     * @param oldMaximumOpenAco Value of the previous maximum number of open ACOs allowed.\\r\\n     * @param newMaximumOpenAco Value of the new maximum number of open ACOs allowed.\\r\\n     */\\r\\n\\tevent SetMaximumOpenAco(uint256 indexed oldMaximumOpenAco, uint256 indexed newMaximumOpenAco);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the fee has been changed.\\r\\n     * @param oldFee Value of the previous fee.\\r\\n     * @param newFee Value of the new fee.\\r\\n     */\\r\\n    event SetFee(uint256 indexed oldFee, uint256 indexed newFee);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the fee destination has been changed.\\r\\n     * @param oldFeeDestination Address of the previous fee destination.\\r\\n     * @param newFeeDestination Address of the new fee destination.\\r\\n     */\\r\\n    event SetFeeDestination(address indexed oldFeeDestination, address indexed newFeeDestination);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when an valid creator permission has been changed.\\r\\n\\t * @param creator Address of the creator.\\r\\n     * @param previousPermission Value of the previous permission.\\r\\n     * @param newPermission Value of the new permission.\\r\\n     */\\r\\n    event SetValidAcoCreator(address indexed creator, bool indexed previousPermission, bool indexed newPermission);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the strategy address has been changed.\\r\\n     * @param oldStrategy Address of the previous strategy.\\r\\n     * @param newStrategy Address of the new strategy.\\r\\n     */\\r\\n\\tevent SetStrategy(address indexed oldStrategy, address indexed newStrategy);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the base volatility has been changed.\\r\\n     * @param oldBaseVolatility Value of the previous base volatility.\\r\\n     * @param newBaseVolatility Value of the new base volatility.\\r\\n     */\\r\\n    event SetBaseVolatility(uint256 indexed oldBaseVolatility, uint256 indexed newBaseVolatility);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when the collateral has been restored on the pool.\\r\\n     * @param amountOut Amount of the premium sold.\\r\\n     * @param collateralRestored Amount of collateral restored.\\r\\n     */\\r\\n    event RestoreCollateral(uint256 amountOut, uint256 collateralRestored);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when an ACO token has been redeemed.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param valueSold Total amount sold by the pool.\\r\\n     * @param collateralLocked Total amount of collateral locked.\\r\\n     * @param collateralRedeemed Total amount of collateral redeemed.\\r\\n     */\\r\\n\\tevent ACORedeem(address indexed acoToken, uint256 valueSold, uint256 collateralLocked, uint256 collateralRedeemed);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when a collateral has been deposited on the pool.\\r\\n     * @param account Address of the account.\\r\\n\\t * @param shares Amount of the shares minted.\\r\\n     * @param collateralAmount Collateral amount deposited.\\r\\n     */\\r\\n    event Deposit(address indexed account, uint256 shares, uint256 collateralAmount);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when an account has been withdrawn from the pool.\\r\\n     * @param account Address of the account.\\r\\n\\t * @param shares Amount of the shares withdrawn.\\r\\n\\t * @param noLocked TRUE if the withdrawal request is with NO locked collateral, otherwise FALSE.\\r\\n     * @param underlyingWithdrawn Amount of underlying withdrawn.\\r\\n\\t * @param strikeAssetWithdrawn Amount of strike asset withdrawn.\\r\\n\\t * @param acos Array of ACOs addresses with locked collateral transferred.\\r\\n\\t * @param acosAmount Array of amount of ACOs with locked collateral transferred.\\r\\n     */\\r\\n    event Withdraw(\\r\\n\\t\\taddress indexed account, \\r\\n\\t\\tuint256 shares, \\r\\n\\t\\tbool noLocked, \\r\\n\\t\\tuint256 underlyingWithdrawn, \\r\\n\\t\\tuint256 strikeAssetWithdrawn, \\r\\n\\t\\taddress[] acos, \\r\\n\\t\\tuint256[] acosAmount\\r\\n\\t);\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Emitted when an ACO token has been sold by the pool.\\r\\n     * @param account Address of the account that is doing the swap.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens swapped.\\r\\n     * @param price Value of the premium paid in strike asset.\\r\\n     * @param protocolFee Value of the protocol fee paid in strike asset.\\r\\n     * @param underlyingPrice The underlying price in strike asset.\\r\\n\\t * @param volatility The volatility used on the option price calculation.\\r\\n     */\\r\\n\\tevent Swap(\\r\\n        address indexed account, \\r\\n        address indexed acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 price, \\r\\n        uint256 protocolFee,\\r\\n        uint256 underlyingPrice,\\r\\n\\t\\tuint256 volatility\\r\\n    );\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Address of the ACO factory contract.\\r\\n\\t */\\r\\n    IACOFactory public acoFactory;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the Chi gas token.\\r\\n\\t */\\r\\n\\tIChiToken public chiToken;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the underlying asset accepts by the pool.\\r\\n\\t */\\r\\n    address public underlying;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the strike asset accepts by the pool.\\r\\n\\t */\\r\\n    address public strikeAsset;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev True whether the pool accepts CALL options, otherwise the pool accepts only PUT options. \\r\\n\\t */\\r\\n    bool public isCall;\\r\\n    \\r\\n\\t/**\\r\\n\\t * @dev Address of the asset converter helper.\\r\\n\\t */\\r\\n    IACOAssetConverterHelper public assetConverter;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the strategy. \\r\\n\\t */\\r\\n\\tIACOPoolStrategy public strategy;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Address of the protocol fee destination.\\r\\n\\t */\\r\\n\\taddress public feeDestination;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Percentage value for the base volatility. (100000 = 100%) \\r\\n\\t */\\r\\n    uint256 public baseVolatility;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Percentage value for the above tolerance on the current price. Zero is ignored. (100000 = 100%) \\r\\n\\t */\\r\\n    uint256 public tolerancePriceAbove;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Percentage value for the below tolerance on the current price. Zero is ignored. (100000 = 100%) \\r\\n\\t */\\r\\n    uint256 public tolerancePriceBelow;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Minimum expiration seconds after current time to the pool accepts an ACO based on its expiry time. \\r\\n\\t */\\r\\n    uint256 public minExpiration;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Maximum expiration seconds after current time to the pool accepts an ACO based on its expiry time. \\r\\n\\t */\\r\\n    uint256 public maxExpiration;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev The protocol fee percentage. (100000 = 100%)\\r\\n\\t */\\r\\n    uint256 public fee;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Percentage value for the penalty percentage on withdrawing open positions. (100000 = 100%)\\r\\n\\t */\\r\\n\\tuint256 public withdrawOpenPositionPenalty;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Percentage value for the underlying price adjust. (100000 = 100%)\\r\\n\\t */\\r\\n\\tuint256 public underlyingPriceAdjustPercentage;\\r\\n\\r\\n    /**\\r\\n\\t * @dev Maximum number of open ACOs allowed.\\r\\n\\t */\\r\\n\\tuint256 public maximumOpenAco;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Array of ACO tokens negotiated.  \\r\\n\\t */\\r\\n    address[] public acoTokens;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Array of ACO tokens negotiated and currently active.  \\r\\n\\t */\\r\\n    address[] public openAcos;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Mapping for the valid ACO creators allowed by th pool.  \\r\\n\\t */\\r\\n    mapping(address =\\u003e bool) public validAcoCreators;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Mapping for ACO tokens data negotiated.  \\r\\n\\t */\\r\\n    mapping(address =\\u003e AcoData) public acoData;\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Underlying asset precision. (18 decimals = 1000000000000000000)\\r\\n\\t */\\r\\n\\tuint256 internal underlyingPrecision;\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Modifier to apply the Chi gas token and save gas.\\r\\n     */\\r\\n\\tmodifier discountCHI {\\r\\n        uint256 gasStart = gasleft();\\r\\n        _;\\r\\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\\r\\n        chiToken.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\\r\\n    }\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Function to initialize the contract.\\r\\n     * It should be called by the ACO pool factory when creating the pool.\\r\\n     * It must be called only once. The first `require` is to guarantee that behavior.\\r\\n     * @param initData The initialize data.\\r\\n     */\\r\\n    function init(InitData calldata initData) external override {\\r\\n\\t\\trequire(underlying == address(0) \\u0026\\u0026 strikeAsset == address(0), \\\"E00\\\");\\r\\n        \\r\\n        require(initData.acoFactory.isContract(), \\\"E01\\\");\\r\\n        require(initData.chiToken.isContract(), \\\"E02\\\");\\r\\n        require(initData.underlying != initData.strikeAsset, \\\"E03\\\");\\r\\n        require(ACOAssetHelper._isEther(initData.underlying) || initData.underlying.isContract(), \\\"E04\\\");\\r\\n        require(ACOAssetHelper._isEther(initData.strikeAsset) || initData.strikeAsset.isContract(), \\\"E05\\\");\\r\\n        \\r\\n        super.init();\\r\\n\\r\\n        acoFactory = IACOFactory(initData.acoFactory);\\r\\n        chiToken = IChiToken(initData.chiToken);\\r\\n        underlying = initData.underlying;\\r\\n        strikeAsset = initData.strikeAsset;\\r\\n        isCall = initData.isCall;\\r\\n\\t\\t\\r\\n        _setAssetConverter(initData.assetConverter);\\r\\n        _setFee(initData.fee);\\r\\n        _setFeeDestination(initData.feeDestination);\\r\\n\\t\\t_setWithdrawOpenPositionPenalty(initData.withdrawOpenPositionPenalty);\\r\\n\\t\\t_setUnderlyingPriceAdjustPercentage(initData.underlyingPriceAdjustPercentage);\\r\\n        _setMaximumOpenAco(initData.maximumOpenAco);\\r\\n        _setMaxExpiration(initData.maxExpiration);\\r\\n        _setMinExpiration(initData.minExpiration);\\r\\n        _setTolerancePriceAbove(initData.tolerancePriceAbove);\\r\\n        _setTolerancePriceBelow(initData.tolerancePriceBelow);\\r\\n        _setStrategy(initData.strategy);\\r\\n        _setBaseVolatility(initData.baseVolatility);\\r\\n\\t\\t\\r\\n\\t\\tunderlyingPrecision = 10 ** uint256(ACOAssetHelper._getAssetDecimals(initData.underlying));\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the token name.\\r\\n     */\\r\\n    function name() public override view returns(string memory) {\\r\\n        return _name();\\r\\n    }\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Function to get the token symbol, that it is equal to the name.\\r\\n     */\\r\\n\\tfunction symbol() public override view returns(string memory) {\\r\\n        return _name();\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to get the token decimals.\\r\\n     */\\r\\n    function decimals() public override view returns(uint8) {\\r\\n        return ACOAssetHelper._getAssetDecimals(collateral());\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to get the number of ACO tokens negotiated.\\r\\n     */\\r\\n    function numberOfAcoTokensNegotiated() external view override returns(uint256) {\\r\\n        return acoTokens.length;\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to get the number of ACO tokens negotiated and currently active.\\r\\n     */\\r\\n    function numberOfOpenAcoTokens() external view override returns(uint256) {\\r\\n        return openAcos.length;\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to get the pool collateral asset.\\r\\n     */\\r\\n\\tfunction collateral() public view override returns(address) {\\r\\n        if (isCall) {\\r\\n            return underlying;\\r\\n        } else {\\r\\n            return strikeAsset;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to get whether the pool can swap an ACO token.\\r\\n\\t * @param acoToken Address of the ACO token.\\r\\n\\t * @return TRUE whether it is possible, otherwise FALSE.\\r\\n     */\\r\\n    function canSwap(address acoToken) external view override returns(bool) {\\r\\n        (address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime) = acoFactory.acoTokenData(acoToken);\\r\\n\\t\\tif (_acoBasicDataIsValid(acoToken, _underlying, _strikeAsset, _isCall) \\u0026\\u0026 _acoExpirationIsValid(_expiryTime)) {\\r\\n            uint256 price = assetConverter.getPrice(_underlying, _strikeAsset);\\r\\n            return _acoStrikePriceIsValid(_strikePrice, price);\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to quote an ACO token swap.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @return swapPrice The swap price\\r\\n     * protocolFee the protocol fee charged on the swap\\r\\n     * underlyingPrice the underlying price in strike asset \\r\\n     * volatility the volatility used on the option price calculation.\\r\\n     */\\r\\n\\tfunction quote(address acoToken, uint256 tokenAmount) external view override returns(\\r\\n        uint256 swapPrice, \\r\\n        uint256 protocolFee, \\r\\n        uint256 underlyingPrice, \\r\\n        uint256 volatility\\r\\n    ) {\\r\\n        (swapPrice, protocolFee, underlyingPrice, volatility,) = _quote(acoToken, tokenAmount);\\r\\n    }\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Function to get the shares for a collateral amount on deposit.\\r\\n     * @param collateralAmount Amount of collateral to be deposited.\\r\\n     * @return The shares to be received on the deposit.\\r\\n     */\\r\\n\\tfunction getDepositShares(uint256 collateralAmount) external view override returns(uint256) {\\r\\n        return _getDepositShares(collateralAmount);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to get the withdrawal data for a shares amount considering that there is NO locked collateral on the operation.\\r\\n     * @param shares Amount of shares to be withdrawn.\\r\\n     * @return underlyingWithdrawn The underlying amount on the withdraw\\r\\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\\r\\n     * isPossible TRUE whether it is possible to withdraw from that way (NO locked) or FALSE otherwise.\\r\\n     */\\r\\n\\tfunction getWithdrawNoLockedData(uint256 shares) external view override returns(\\r\\n        uint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\tbool isPossible\\r\\n    ) {\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn, isPossible) = _getWithdrawNoLockedData(shares);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to get the withdrawal data for a shares amount considering that there is locked collateral on the operation.\\r\\n     * @param shares Amount of shares to be withdrawn.\\r\\n     * @return underlyingWithdrawn The underlying amount on the withdraw\\r\\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\\r\\n     * acos addresses of the ACOs with locked collateral that will be transferred\\r\\n     * acosAmount the respective ACOs amount to be transferred.\\r\\n     */\\r\\n\\tfunction getWithdrawWithLocked(uint256 shares) external view override returns(\\r\\n        uint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n    ) {\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount) = _getWithdrawWithLocked(shares);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to set the asset converter address.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newAssetConverter Address of the new asset converter.\\r\\n     */\\r\\n    function setAssetConverter(address newAssetConverter) external override {\\r\\n        onlyFactory();\\r\\n        _setAssetConverter(newAssetConverter);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to set the percentage of the below price tolerance.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newTolerancePriceBelow Value of the new below price tolerance.\\r\\n     */\\r\\n    function setTolerancePriceBelow(uint256 newTolerancePriceBelow) external override {\\r\\n        onlyFactory();\\r\\n        _setTolerancePriceBelow(newTolerancePriceBelow);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to set the percentage of the above price tolerance.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newTolerancePriceAbove Value of the new above price tolerance.\\r\\n     */\\r\\n    function setTolerancePriceAbove(uint256 newTolerancePriceAbove) external override {\\r\\n        onlyFactory();\\r\\n        _setTolerancePriceAbove(newTolerancePriceAbove);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to set the minimum expiration seconds after current time to the pool accepts an ACO based on its expiry time.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newMinExpiration Value of the new minimum expiration.\\r\\n     */\\r\\n    function setMinExpiration(uint256 newMinExpiration) external override {\\r\\n        onlyFactory();\\r\\n        _setMinExpiration(newMinExpiration);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to set the maximum expiration seconds after current time to the pool accepts an ACO based on its expiry time.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newMaxExpiration Value of the new maximum expiration.\\r\\n     */\\r\\n    function setMaxExpiration(uint256 newMaxExpiration) external override {\\r\\n        onlyFactory();\\r\\n        _setMaxExpiration(newMaxExpiration);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to set the protocol fee percentage.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newFee Value of the new protocol fee.\\r\\n     */\\r\\n    function setFee(uint256 newFee) external override {\\r\\n        onlyFactory();\\r\\n        _setFee(newFee);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to set the fee destination.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newFeeDestination Value of the new fee destination.\\r\\n     */\\r\\n    function setFeeDestination(address newFeeDestination) external override {\\r\\n        onlyFactory();\\r\\n        _setFeeDestination(newFeeDestination);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to set the penalty percentage on withdrawing open positions.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newWithdrawOpenPositionPenalty Value of the new penalty percentage on withdrawing open positions.\\r\\n     */\\r\\n\\tfunction setWithdrawOpenPositionPenalty(uint256 newWithdrawOpenPositionPenalty) external override {\\r\\n        onlyFactory();\\r\\n\\t\\t_setWithdrawOpenPositionPenalty(newWithdrawOpenPositionPenalty);\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to set the underlying price percentage adjust.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newUnderlyingPriceAdjustPercentage Value of the new underlying price percentage adjust.\\r\\n     */\\r\\n\\tfunction setUnderlyingPriceAdjustPercentage(uint256 newUnderlyingPriceAdjustPercentage) external override {\\r\\n        onlyFactory();\\r\\n\\t\\t_setUnderlyingPriceAdjustPercentage(newUnderlyingPriceAdjustPercentage);\\r\\n\\t}\\r\\n\\t\\r\\n    /**\\r\\n     * @dev Function to set the  maximum number of open ACOs allowed.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newMaximumOpenAco Value of the new maximum number of open ACOs allowed.\\r\\n     */\\r\\n\\tfunction setMaximumOpenAco(uint256 newMaximumOpenAco) external override {\\r\\n        onlyFactory();\\r\\n\\t\\t_setMaximumOpenAco(newMaximumOpenAco);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to set the strategy address.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newStrategy Address of the new strategy address.\\r\\n     */\\r\\n\\tfunction setStrategy(address newStrategy) external override {\\r\\n        onlyFactory();\\r\\n\\t\\t_setStrategy(newStrategy);\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to set the base volatility.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newBaseVolatility Value of the new base volatility.\\r\\n     */\\r\\n\\tfunction setBaseVolatility(uint256 newBaseVolatility) external override {\\r\\n        onlyFactory();\\r\\n\\t\\t_setBaseVolatility(newBaseVolatility);\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to set an valid creator permission.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param newAcoCreator Address of the creator.\\r\\n\\t * @param newPermission Value of the new permission.\\r\\n     */\\r\\n\\tfunction setValidAcoCreator(address newAcoCreator, bool newPermission) external override {\\r\\n        onlyFactory();\\r\\n        _setValidAcoCreator(newAcoCreator, newPermission);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to withdraw a stucked token.\\r\\n\\t * Only can be called by the pool factory.\\r\\n     * @param token Address of the token.\\r\\n\\t * @param destination Address of the token destination.\\r\\n     */\\r\\n    function withdrawStuckToken(address token, address destination) external override {\\r\\n        onlyFactory();\\r\\n        require(token != underlying \\u0026\\u0026 token != strikeAsset \\u0026\\u0026 !acoData[token].open, \\\"E80\\\");\\r\\n        uint256 _balance = ACOAssetHelper._getAssetBalanceOf(token, address(this));\\r\\n        if (_balance \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(token, destination, _balance);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to deposit on the pool.\\r\\n     * @param collateralAmount Amount of collateral to be deposited.\\r\\n     * @param minShares The minimum amount of shares acceptable.\\r\\n     * @param to Address of the destination of the pool token.\\r\\n     * @return The amount of pool tokens minted.\\r\\n     */\\r\\n\\tfunction deposit(uint256 collateralAmount, uint256 minShares, address to) external payable override returns(uint256) {\\r\\n        return _deposit(collateralAmount, minShares, to);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to deposit on the pool using Chi gas token to saving gas.\\r\\n     * @param collateralAmount Amount of collateral to be deposited.\\r\\n     * @param minShares The minimum amount of shares acceptable.\\r\\n     * @param to Address of the destination of the pool token.\\r\\n     * @return The amount of pool tokens minted.\\r\\n     */\\r\\n\\tfunction depositWithGasToken(uint256 collateralAmount, uint256 minShares, address to) discountCHI external payable override returns(uint256) {\\r\\n        return _deposit(collateralAmount, minShares, to);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to withdraw from the pool with NO locked collateral.\\r\\n     * @param shares Amount of the account shares to be withdrawn.\\r\\n     * @param minCollateral The minimum collateral amount acceptable on the withdrawal.\\r\\n     * @param account Address of the account to withdraw.\\r\\n     * @return underlyingWithdrawn The underlying amount on the withdraw\\r\\n     * strikeAssetWithdrawn the strike asset amount on the withdraw.\\r\\n     */\\r\\n\\tfunction withdrawNoLocked(uint256 shares, uint256 minCollateral, address account) external override returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t) {\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn) = _withdrawNoLocked(shares, minCollateral, account);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to withdraw from the pool with NO locked collateral using Chi gas token to save gas.\\r\\n     * @param shares Amount of the account shares to be withdrawn.\\r\\n     * @param minCollateral The minimum collateral amount acceptable on the withdrawal.\\r\\n     * @param account Address of the account to withdraw.\\r\\n     * @return underlyingWithdrawn The underlying amount on the withdraw\\r\\n     * strikeAssetWithdrawn the strike asset amount on the withdraw.\\r\\n     */\\r\\n\\tfunction withdrawNoLockedWithGasToken(uint256 shares, uint256 minCollateral, address account) discountCHI external override returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t) {\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn) = _withdrawNoLocked(shares, minCollateral, account);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to withdraw from the pool and transferring the locked collateral and the obligation to redeem it on the expiration.\\r\\n     * @param shares Amount of the account shares to be withdrawn.\\r\\n     * @param account Address of the account to withdraw.\\r\\n     * @return underlyingWithdrawn The underlying amount on the withdraw\\r\\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\\r\\n     * acos addresses of the ACOs with locked collateral that will be transferred\\r\\n     * acosAmount the respective ACOs amount to be transferred.\\r\\n     */\\r\\n    function withdrawWithLocked(uint256 shares, address account) external override returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t) {\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount) = _withdrawWithLocked(shares, account);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to withdraw from the pool and transferring the locked collateral and the obligation to redeem it on the expiration using Chi gas token to save gas.\\r\\n     * @param shares Amount of the account shares to be withdrawn.\\r\\n     * @param account Address of the account to withdraw.\\r\\n     * @return underlyingWithdrawn The underlying amount on the withdraw\\r\\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\\r\\n     * acos addresses of the ACOs with locked collateral that will be transferred\\r\\n     * acosAmount the respective ACOs amount to be transferred.\\r\\n     */\\r\\n\\tfunction withdrawWithLockedWithGasToken(uint256 shares, address account) discountCHI external override returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t) {\\r\\n        (underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount) = _withdrawWithLocked(shares, account);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to swap an ACO token with the pool.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @param restriction The maximum value to pay on the ACO purchase.\\r\\n     * @param to Address of the destination of the ACO tokens.\\r\\n     * @param deadline UNIX deadline for the swap to be executed.\\r\\n     */\\r\\n\\tfunction swap(\\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 restriction, \\r\\n        address to, \\r\\n        uint256 deadline\\r\\n    ) external override {\\r\\n        _swap(acoToken, tokenAmount, restriction, to, deadline);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to swap an ACO token with the pool using Chi gas token to save gas.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @param restriction The maximum value to pay on the ACO purchase.\\r\\n     * @param to Address of the destination of the ACO tokens.\\r\\n     * @param deadline UNIX deadline for the swap to be executed.\\r\\n     */\\r\\n    function swapWithGasToken(\\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 restriction, \\r\\n        address to, \\r\\n        uint256 deadline\\r\\n    ) discountCHI external override {\\r\\n        _swap(acoToken, tokenAmount, restriction, to, deadline);\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Function to redeem the collateral from the active ACO tokens negotiated on the pool.\\r\\n     * It redeems the collateral only if the respective ACO token is expired.\\r\\n     */\\r\\n    function redeemACOTokens() public override {\\r\\n        for (uint256 i = openAcos.length; i \\u003e 0; --i) {\\r\\n            address acoToken = openAcos[i - 1];\\r\\n            _redeemACOToken(acoToken);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Function to redeem the collateral from an ACO token.\\r\\n     * It redeems the collateral only if the ACO token is expired.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     */\\r\\n\\tfunction redeemACOToken(address acoToken) external override {\\r\\n\\t\\t_redeemACOToken(acoToken);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Function to restore the collateral on the pool by selling the other asset balance.\\r\\n     */\\r\\n\\tfunction restoreCollateral() external override {\\r\\n        address _strikeAsset = strikeAsset;\\r\\n        address _underlying = underlying;\\r\\n        bool _isCall = isCall;\\r\\n        \\r\\n        uint256 balanceOut;\\r\\n        address assetIn;\\r\\n        address assetOut;\\r\\n        if (_isCall) {\\r\\n            balanceOut = _getPoolBalanceOf(_strikeAsset);\\r\\n            assetIn = _underlying;\\r\\n            assetOut = _strikeAsset;\\r\\n        } else {\\r\\n            balanceOut = _getPoolBalanceOf(_underlying);\\r\\n            assetIn = _strikeAsset;\\r\\n            assetOut = _underlying;\\r\\n        }\\r\\n        require(balanceOut \\u003e 0, \\\"E60\\\");\\r\\n        \\r\\n\\t\\tuint256 etherAmount = 0;\\r\\n        if (ACOAssetHelper._isEther(assetOut)) {\\r\\n\\t\\t\\tetherAmount = balanceOut;\\r\\n        }\\r\\n        uint256 collateralRestored = assetConverter.swapExactAmountOut{value: etherAmount}(assetOut, assetIn, balanceOut);\\r\\n\\r\\n        emit RestoreCollateral(balanceOut, collateralRestored);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to deposit on the pool.\\r\\n     * @param collateralAmount Amount of collateral to be deposited.\\r\\n     * @param minShares The minimum amount of shares acceptable.\\r\\n     * @param to Address of the destination of the pool token.\\r\\n     * @return shares The amount of pool tokens minted.\\r\\n     */\\r\\n\\tfunction _deposit(uint256 collateralAmount, uint256 minShares, address to) internal returns(uint256 shares) {\\r\\n        require(collateralAmount \\u003e 0, \\\"E10\\\");\\r\\n        require(to != address(0) \\u0026\\u0026 to != address(this), \\\"E11\\\");\\r\\n\\t\\t\\r\\n\\t\\t(,,uint256 collateralBalance, uint256 collateralOnOpenPosition,) = _getTotalCollateralBalance(true);\\r\\n\\t\\tcollateralBalance = collateralBalance.sub(collateralOnOpenPosition);\\r\\n\\r\\n\\t\\taddress _collateral = collateral();\\r\\n\\t\\tif (ACOAssetHelper._isEther(_collateral)) {\\r\\n            collateralBalance = collateralBalance.sub(msg.value);\\r\\n\\t\\t}\\r\\n        \\r\\n        if (collateralBalance == 0) {\\r\\n            shares = collateralAmount;\\r\\n        } else {\\r\\n            shares = collateralAmount.mul(totalSupply()).div(collateralBalance);\\r\\n        }\\r\\n        require(shares \\u003e= minShares, \\\"E12\\\");\\r\\n\\r\\n        ACOAssetHelper._receiveAsset(_collateral, collateralAmount);\\r\\n\\r\\n        super._mintAction(to, shares);\\r\\n        \\r\\n        emit Deposit(to, shares, collateralAmount);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to get the withdrawal data for a shares amount considering that there is locked collateral on the operation.\\r\\n     * @param shares Amount of shares to be withdrawn.\\r\\n     * @return underlyingWithdrawn The underlying amount on the withdraw\\r\\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\\r\\n     * acos addresses of the ACOs with locked collateral that will be transferred\\r\\n     * acosAmount the respective ACOs amount to be transferred.\\r\\n     */\\r\\n\\tfunction _getWithdrawWithLocked(uint256 shares) internal view returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t) {\\r\\n        uint256 _totalSupply = totalSupply();\\t\\r\\n        if (shares \\u003e 0 \\u0026\\u0026 shares \\u003c= _totalSupply) {\\r\\n        \\r\\n\\t\\t\\tuint256 underlyingBalance = _getPoolBalanceOf(underlying);\\r\\n\\t\\t\\tuint256 strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\\r\\n\\t\\t\\r\\n            acos = new address[](openAcos.length);\\r\\n            acosAmount = new uint256[](openAcos.length);\\r\\n\\t\\t\\tfor (uint256 i = 0; i \\u003c openAcos.length; ++i) {\\r\\n\\t\\t\\t\\taddress acoToken = openAcos[i];\\r\\n\\t\\t\\t\\tuint256 tokens = IACOToken(acoToken).currentCollateralizedTokens(address(this));\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tacos[i] = acoToken;\\r\\n\\t\\t\\t\\tacosAmount[i] = tokens.mul(shares).div(_totalSupply);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(_totalSupply);\\r\\n\\t\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(_totalSupply);\\r\\n\\t\\t}\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get the shares for a collateral amount on deposit.\\r\\n     * @param collateralAmount Amount of collateral to be deposited.\\r\\n     * @return The shares to be received on the deposit.\\r\\n     */\\r\\n\\tfunction _getDepositShares(uint256 collateralAmount) internal view returns(uint256) {\\r\\n        (,,uint256 collateralBalance, uint256 collateralOnOpenPosition,) = _getTotalCollateralBalance(true);\\r\\n\\t\\tcollateralBalance = collateralBalance.sub(collateralOnOpenPosition);\\r\\n\\r\\n        if (collateralBalance == 0) {\\r\\n            return collateralAmount;\\r\\n        } else {\\r\\n            return collateralAmount.mul(totalSupply()).div(collateralBalance);\\r\\n        }\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to get the withdrawal data for a shares amount considering that there is NO locked collateral on the operation.\\r\\n     * @param shares Amount of shares to be withdrawn.\\r\\n     * @return underlyingWithdrawn The underlying amount on the withdraw\\r\\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\\r\\n     * isPossible TRUE whether it is possible to withdraw from that way (NO locked) or FALSE otherwise.\\r\\n     */\\r\\n\\tfunction _getWithdrawNoLockedData(uint256 shares) internal view returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\tbool isPossible\\r\\n\\t) {\\r\\n        uint256 _totalSupply = totalSupply();\\r\\n\\t\\tif (shares \\u003e 0 \\u0026\\u0026 shares \\u003c= _totalSupply) {\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t(uint256 underlyingBalance, \\r\\n             uint256 strikeAssetBalance, \\r\\n             uint256 collateralBalance, \\r\\n             uint256 collateralOnOpenPosition,\\r\\n             uint256 collateralLockedRedeemable) = _getTotalCollateralBalance(false);\\r\\n\\r\\n\\t\\t\\tif (collateralBalance \\u003e collateralOnOpenPosition) {\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tuint256 collateralAmount = shares.mul(collateralBalance.sub(collateralOnOpenPosition)).div(_totalSupply);\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tif (isCall) {\\r\\n\\t\\t\\t\\t\\tif (collateralAmount \\u003c= underlyingBalance.add(collateralLockedRedeemable)) {\\r\\n\\t\\t\\t\\t\\t\\tunderlyingWithdrawn = collateralAmount;\\r\\n\\t\\t\\t\\t\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(_totalSupply);\\r\\n\\t\\t\\t\\t\\t\\tisPossible = true;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t} else if (collateralAmount \\u003c= strikeAssetBalance.add(collateralLockedRedeemable)) {\\r\\n\\t\\t\\t\\t\\tstrikeAssetWithdrawn = collateralAmount;\\r\\n\\t\\t\\t\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(_totalSupply);\\r\\n\\t\\t\\t\\t\\tisPossible = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to withdraw from the pool with NO locked collateral.\\r\\n     * @param shares Amount of the account shares to be withdrawn.\\r\\n     * @param minCollateral The minimum collateral amount acceptable on the withdrawal.\\r\\n     * @param account Address of the account to withdraw.\\r\\n     * @return underlyingWithdrawn The underlying amount on the withdraw\\r\\n     * strikeAssetWithdrawn the strike asset amount on the withdraw.\\r\\n     */\\r\\n    function _withdrawNoLocked(uint256 shares, uint256 minCollateral, address account) internal returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t) {\\r\\n        require(shares \\u003e 0, \\\"E30\\\");\\r\\n        \\r\\n\\t\\tredeemACOTokens();\\r\\n\\t\\t\\r\\n        uint256 _totalSupply = totalSupply();\\r\\n        _callBurn(account, shares);\\r\\n        \\r\\n\\t\\t(uint256 underlyingBalance, \\r\\n         uint256 strikeAssetBalance, \\r\\n         uint256 collateralBalance,\\r\\n         uint256 collateralOnOpenPosition,) = _getTotalCollateralBalance(false);\\r\\n\\t\\trequire(collateralBalance \\u003e collateralOnOpenPosition, \\\"E31\\\");\\r\\n\\r\\n\\t\\tuint256 collateralAmount = shares.mul(collateralBalance.sub(collateralOnOpenPosition)).div(_totalSupply);\\r\\n\\t\\trequire(collateralAmount \\u003e= minCollateral, \\\"E32\\\");\\r\\n\\r\\n        if (isCall) {\\r\\n\\t\\t\\trequire(collateralAmount \\u003c= underlyingBalance, \\\"E33\\\");\\r\\n\\t\\t\\tunderlyingWithdrawn = collateralAmount;\\r\\n\\t\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(_totalSupply);\\r\\n        } else {\\r\\n\\t\\t\\trequire(collateralAmount \\u003c= strikeAssetBalance, \\\"E34\\\");\\r\\n\\t\\t\\tstrikeAssetWithdrawn = collateralAmount;\\r\\n\\t\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(_totalSupply);\\r\\n\\t\\t}\\r\\n        \\r\\n\\t\\tACOAssetHelper._transferAsset(underlying, msg.sender, underlyingWithdrawn);\\r\\n\\t\\tACOAssetHelper._transferAsset(strikeAsset, msg.sender, strikeAssetWithdrawn);\\r\\n\\t\\t\\r\\n        emit Withdraw(account, shares, true, underlyingWithdrawn, strikeAssetWithdrawn, new address[](0), new uint256[](0));\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to withdraw from the pool and transferring the locked collateral and the obligation to redeem it on the expiration.\\r\\n     * @param shares Amount of the account shares to be withdrawn.\\r\\n     * @param account Address of the account to withdraw.\\r\\n     * @return underlyingWithdrawn The underlying amount on the withdraw\\r\\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\\r\\n     * acos addresses of the ACOs with locked collateral that will be transferred\\r\\n     * acosAmount the respective ACOs amount to be transferred.\\r\\n     */\\r\\n\\tfunction _withdrawWithLocked(uint256 shares, address account) internal returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t) {\\r\\n        require(shares \\u003e 0, \\\"E20\\\");\\r\\n        \\r\\n\\t\\tredeemACOTokens();\\r\\n\\t\\t\\r\\n        uint256 _totalSupply = totalSupply();\\r\\n        _callBurn(account, shares);\\r\\n        \\r\\n\\t\\taddress _underlying = underlying;\\r\\n\\t\\taddress _strikeAsset = strikeAsset;\\r\\n\\t\\tuint256 underlyingBalance = _getPoolBalanceOf(_underlying);\\r\\n\\t\\tuint256 strikeAssetBalance = _getPoolBalanceOf(_strikeAsset);\\r\\n\\t\\t\\r\\n\\t\\t(acos, acosAmount) = _transferOpenPositions(shares, _totalSupply);\\r\\n\\t\\t\\r\\n\\t\\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(_totalSupply);\\r\\n\\t\\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(_totalSupply);\\r\\n\\t\\t\\r\\n\\t\\tACOAssetHelper._transferAsset(_underlying, msg.sender, underlyingWithdrawn);\\r\\n\\t\\tACOAssetHelper._transferAsset(_strikeAsset, msg.sender, strikeAssetWithdrawn);\\r\\n\\t\\t\\r\\n        emit Withdraw(account, shares, false, underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to get the total collateral balance from the pool.\\r\\n     * @param isDeposit TRUE whether is a deposit operation, FALSE otherwise it is a withdraw.\\r\\n     * @return underlyingBalance The pool underlying balance\\r\\n     * strikeAssetBalance the pool strike asset balance \\r\\n     * collateralBalance the pool collateral balance considering the available, locked collateral and the open position\\r\\n     * collateralOnOpenPosition the pool collateral on open positions calculated using the options current price\\r\\n     * collateralLockedRedeemable the pool collateral locked that already can be redeem.\\r\\n     */\\r\\n\\tfunction _getTotalCollateralBalance(bool isDeposit) internal view returns(\\r\\n        uint256 underlyingBalance, \\r\\n        uint256 strikeAssetBalance, \\r\\n        uint256 collateralBalance,\\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n\\t\\tunderlyingBalance = _getPoolBalanceOf(underlying);\\r\\n\\t\\tstrikeAssetBalance = _getPoolBalanceOf(strikeAsset);\\r\\n\\t\\t\\r\\n\\t\\tuint256 underlyingPrice = assetConverter.getPrice(underlying, strikeAsset);\\r\\n\\t\\t\\r\\n\\t\\tif (isCall) {\\r\\n\\t\\t\\tcollateralBalance = underlyingBalance;\\r\\n\\t\\t\\tif (isDeposit \\u0026\\u0026 strikeAssetBalance \\u003e 0) {\\r\\n\\t\\t\\t\\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, false); \\r\\n\\t\\t\\t\\tcollateralBalance = collateralBalance.add(strikeAssetBalance.mul(underlyingPrecision).div(priceAdjusted));\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tcollateralBalance = strikeAssetBalance;\\r\\n\\t\\t\\tif (isDeposit \\u0026\\u0026 underlyingBalance \\u003e 0) {\\r\\n\\t\\t\\t\\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, true); \\r\\n\\t\\t\\t\\tcollateralBalance = collateralBalance.add(underlyingBalance.mul(priceAdjusted).div(underlyingPrecision));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n        uint256 collateralLocked;\\r\\n\\t\\t(collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _poolOpenPositionCollateralBalance(underlyingPrice, isDeposit);\\r\\n\\t\\t\\r\\n        collateralBalance = collateralBalance.add(collateralLocked);\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to burn pool tokens.\\r\\n     * @param account Address of the account.\\r\\n     * @param tokenAmount Amount of pool tokens to be burned.\\r\\n     */\\r\\n\\tfunction _callBurn(address account, uint256 tokenAmount) internal {\\r\\n        if (account == msg.sender) {\\r\\n            super._burnAction(account, tokenAmount);\\r\\n        } else {\\r\\n            super._burnFrom(account, tokenAmount);\\r\\n        }\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to swap an ACO token with the pool.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @param restriction The maximum value to pay on the purchase.\\r\\n     * @param to Address of the ACO tokens destination.\\r\\n     * @param deadline UNIX deadline for the swap to be executed.\\r\\n     */\\r\\n\\tfunction _swap(\\r\\n        address acoToken, \\r\\n        uint256 tokenAmount, \\r\\n        uint256 restriction, \\r\\n        address to, \\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        require(block.timestamp \\u003c= deadline, \\\"E40\\\");\\r\\n        require(to != address(0) \\u0026\\u0026 to != acoToken \\u0026\\u0026 to != address(this), \\\"E41\\\");\\r\\n        \\r\\n        (uint256 swapPrice, uint256 protocolFee, uint256 underlyingPrice, uint256 volatility, uint256 collateralAmount) = _quote(acoToken, tokenAmount);\\r\\n        \\r\\n        _internalSelling(to, acoToken, collateralAmount, tokenAmount, restriction, swapPrice, protocolFee);\\r\\n\\r\\n        if (protocolFee \\u003e 0) {\\r\\n            ACOAssetHelper._transferAsset(strikeAsset, feeDestination, protocolFee);\\r\\n        }\\r\\n        \\r\\n        emit Swap(msg.sender, acoToken, tokenAmount, swapPrice, protocolFee, underlyingPrice, volatility);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to quote an ACO token price.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @return swapPrice The quoted price\\r\\n     * protocolFee the protocol fee charged\\r\\n     * underlyingPrice the underlying price\\r\\n     * volatility the volatility used on the calculation\\r\\n     * collateralAmount the collateral amount.\\r\\n     */\\r\\n\\tfunction _quote(address acoToken, uint256 tokenAmount) internal view returns(\\r\\n        uint256 swapPrice, \\r\\n        uint256 protocolFee, \\r\\n        uint256 underlyingPrice, \\r\\n        uint256 volatility, \\r\\n        uint256 collateralAmount\\r\\n    ) {\\r\\n        require(tokenAmount \\u003e 0, \\\"E50\\\");\\r\\n        \\r\\n        (address _underlying, address _strikeAsset, bool _isCall, uint256 strikePrice, uint256 expiryTime) = acoFactory.acoTokenData(acoToken);\\r\\n        \\r\\n\\t\\trequire(_acoBasicDataIsValid(acoToken, _underlying, _strikeAsset, _isCall), \\\"E51\\\");\\r\\n\\t\\trequire(_acoExpirationIsValid(expiryTime), \\\"E52\\\");\\r\\n\\t\\t\\r\\n\\t\\tunderlyingPrice = assetConverter.getPrice(_underlying, _strikeAsset);\\r\\n\\t\\trequire(_acoStrikePriceIsValid(strikePrice, underlyingPrice), \\\"E53\\\");\\r\\n\\r\\n        require(expiryTime \\u003e block.timestamp, \\\"E54\\\");\\r\\n        (swapPrice, protocolFee, volatility, collateralAmount) = _internalQuote(acoToken, tokenAmount, strikePrice, expiryTime, underlyingPrice);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to quote an ACO token price.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n\\t * @param strikePrice ACO strike price.\\r\\n\\t * @param expiryTime ACO expiry time on UNIX.\\r\\n\\t * @param underlyingPrice The current underlying price.\\r\\n     * @return swapPrice The quoted price\\r\\n     * protocolFee the protocol fee charged\\r\\n     * volatility the volatility used on the calculation\\r\\n     * collateralAmount the collateral amount.\\r\\n     */\\r\\n\\tfunction _internalQuote(\\r\\n\\t\\taddress acoToken, \\r\\n\\t\\tuint256 tokenAmount, \\r\\n\\t\\tuint256 strikePrice, \\r\\n\\t\\tuint256 expiryTime, \\r\\n\\t\\tuint256 underlyingPrice\\r\\n\\t) internal view returns(\\r\\n        uint256 swapPrice, \\r\\n        uint256 protocolFee, \\r\\n        uint256 volatility, \\r\\n        uint256 collateralAmount\\r\\n    ) {\\r\\n        uint256 collateralAvailable;\\r\\n        (collateralAmount, collateralAvailable) = _getSizeData(acoToken, tokenAmount);\\r\\n        (swapPrice, volatility) = _strategyQuote(strikePrice, expiryTime, underlyingPrice, collateralAmount, collateralAvailable);\\r\\n        \\r\\n        swapPrice = swapPrice.mul(tokenAmount).div(underlyingPrecision);\\r\\n        \\r\\n        if (fee \\u003e 0) {\\r\\n            protocolFee = swapPrice.mul(fee).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t\\tswapPrice = swapPrice.add(protocolFee);\\r\\n        }\\r\\n        require(swapPrice \\u003e 0, \\\"E55\\\");\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to the size data for a quote.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param tokenAmount Amount of ACO tokens to swap.\\r\\n     * @return collateralAmount The collateral amount \\r\\n     * collateralAvailable the collateral available on the pool.\\r\\n     */\\r\\n    function _getSizeData(address acoToken, uint256 tokenAmount) internal view returns(\\r\\n        uint256 collateralAmount, \\r\\n        uint256 collateralAvailable\\r\\n    ) {\\r\\n        if (isCall) {\\r\\n            collateralAvailable = _getPoolBalanceOf(underlying);\\r\\n            collateralAmount = tokenAmount; \\r\\n        } else {\\r\\n            collateralAvailable = _getPoolBalanceOf(strikeAsset);\\r\\n            collateralAmount = IACOToken(acoToken).getCollateralAmount(tokenAmount);\\r\\n            require(collateralAmount \\u003e 0, \\\"E56\\\");\\r\\n        }\\r\\n        require(collateralAmount \\u003c= collateralAvailable, \\\"E57\\\");\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to quote on the strategy contract.\\r\\n\\t * @param strikePrice ACO token strike price.\\r\\n     * @param expiryTime ACO token expiry time on UNIX.\\r\\n\\t * @param underlyingPrice The current underlying price.\\r\\n     * @param collateralAmount Amount of collateral for the order size.\\r\\n     * @param collateralAvailable Amount of collateral available on the pool.\\r\\n     * @return swapPrice The quoted price\\r\\n     * volatility the volatility used on te option price calculation.\\r\\n     */\\r\\n    function _strategyQuote(\\r\\n        uint256 strikePrice,\\r\\n        uint256 expiryTime,\\r\\n        uint256 underlyingPrice,\\r\\n        uint256 collateralAmount,\\r\\n        uint256 collateralAvailable\\r\\n    ) internal view returns(uint256 swapPrice, uint256 volatility) {\\r\\n        (swapPrice, volatility) = strategy.quote(IACOPoolStrategy.OptionQuote(\\r\\n\\t\\t\\tunderlyingPrice,\\r\\n            underlying, \\r\\n            strikeAsset, \\r\\n            isCall, \\r\\n            strikePrice, \\r\\n            expiryTime, \\r\\n            baseVolatility, \\r\\n            collateralAmount, \\r\\n            collateralAvailable\\r\\n        ));\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to sell ACO tokens.\\r\\n     * @param to Address of the destination of the ACO tokens.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param collateralAmount Order collateral amount.\\r\\n     * @param tokenAmount Order token amount.\\r\\n     * @param maxPayment Maximum value to be paid for the ACO tokens.\\r\\n     * @param swapPrice The swap price quoted.\\r\\n     * @param protocolFee The protocol fee amount.\\r\\n     */\\r\\n    function _internalSelling(\\r\\n        address to,\\r\\n        address acoToken, \\r\\n        uint256 collateralAmount, \\r\\n        uint256 tokenAmount,\\r\\n        uint256 maxPayment,\\r\\n        uint256 swapPrice,\\r\\n        uint256 protocolFee\\r\\n    ) internal {\\r\\n        require(swapPrice \\u003c= maxPayment, \\\"E42\\\");\\r\\n        \\r\\n        ACOAssetHelper._callTransferFromERC20(strikeAsset, msg.sender, address(this), swapPrice);\\r\\n\\r\\n\\t\\taddress _collateral = collateral();\\r\\n        AcoData storage data = acoData[acoToken];\\r\\n\\t\\tif (ACOAssetHelper._isEther(_collateral)) {\\r\\n\\t\\t\\ttokenAmount = IACOToken(acoToken).mintPayable{value: collateralAmount}();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (!data.open) {\\r\\n\\t\\t\\t\\t_setAuthorizedSpender(_collateral, acoToken);    \\r\\n\\t\\t\\t}\\r\\n\\t\\t\\ttokenAmount = IACOToken(acoToken).mint(collateralAmount);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!data.open) {\\r\\n            require(openAcos.length \\u003c maximumOpenAco, \\\"E43\\\");\\r\\n\\t\\t\\tacoData[acoToken] = AcoData(true, swapPrice.sub(protocolFee), collateralAmount, 0, acoTokens.length, openAcos.length);\\r\\n            acoTokens.push(acoToken);    \\r\\n            openAcos.push(acoToken);   \\r\\n        } else {\\r\\n\\t\\t\\tdata.collateralLocked = collateralAmount.add(data.collateralLocked);\\r\\n\\t\\t\\tdata.valueSold = swapPrice.sub(protocolFee).add(data.valueSold);\\r\\n\\t\\t}\\r\\n        \\r\\n        ACOAssetHelper._callTransferERC20(acoToken, to, tokenAmount);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to get the pool colletaral balance from the active ACOs.\\r\\n\\t * @param underlyingPrice The current underlying price.\\r\\n\\t * @param isDeposit TRUE whether it is a deposit operation, otherwise FALSE for a withdraw.\\r\\n\\t * @return collateralLocked Total amount of collateral locked\\r\\n     * collateralOnOpenPosition the total collateral on open positions calculated using the options current price\\r\\n     * collateralLockedRedeemable the pool collateral locked that already can be redeem.\\r\\n     */\\r\\n\\tfunction _poolOpenPositionCollateralBalance(uint256 underlyingPrice, bool isDeposit) internal view returns(\\r\\n        uint256 collateralLocked, \\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n\\t\\tbool _collateralIsUnderlying = isCall;\\r\\n        uint256 _underlyingPrecision = underlyingPrecision;\\r\\n        IACOFactory _acoFactory = acoFactory;\\r\\n\\t\\tfor (uint256 i = 0; i \\u003c openAcos.length; ++i) {\\r\\n\\t\\t\\taddress acoToken = openAcos[i];\\r\\n\\r\\n            (uint256 locked, uint256 openPosition, uint256 lockedRedeemable) = _getOpenPositionCollateralBalance(\\r\\n                acoToken,\\r\\n                underlyingPrice,\\r\\n                _underlyingPrecision,\\r\\n                _acoFactory,\\r\\n                _collateralIsUnderlying\\r\\n            );\\r\\n            \\r\\n            collateralLocked = collateralLocked.add(locked);\\r\\n            collateralOnOpenPosition = collateralOnOpenPosition.add(openPosition);\\r\\n            collateralLockedRedeemable = collateralLockedRedeemable.add(lockedRedeemable);\\r\\n\\t\\t}\\r\\n\\t\\tif (!isDeposit) {\\r\\n\\t\\t\\tcollateralOnOpenPosition = collateralOnOpenPosition.mul(PERCENTAGE_PRECISION.add(withdrawOpenPositionPenalty)).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to get the colletaral balance from the active ACO.\\r\\n     * @param acoToken Address of the ACO.\\r\\n\\t * @param underlyingPrice The current underlying price.\\r\\n\\t * @param _underlyingPrecision The underlying precision.\\r\\n\\t * @param _acoFactory The ACO factory.\\r\\n\\t * @param _collateralIsUnderlying TRUE whether the collateral is the underlying, otherwise FALSE for the strike asset as collateral.\\r\\n\\t * @return collateralLocked Amount of collateral locked\\r\\n     * collateralOnOpenPosition the collateral on open positions calculated using the options current price\\r\\n     * collateralLockedRedeemable the collateral locked that already can be redeem\\r\\n     */\\r\\n    function _getOpenPositionCollateralBalance(\\r\\n        address acoToken,\\r\\n        uint256 underlyingPrice,\\r\\n        uint256 _underlyingPrecision,\\r\\n        IACOFactory _acoFactory,\\r\\n        bool _collateralIsUnderlying\\r\\n    ) internal view returns(\\r\\n        uint256 collateralLocked, \\r\\n        uint256 collateralOnOpenPosition,\\r\\n        uint256 collateralLockedRedeemable\\r\\n    ) {\\r\\n        (,,,uint256 _strikePrice, uint256 _expiryTime) = _acoFactory.acoTokenData(acoToken);\\r\\n\\t\\t\\t\\r\\n        uint256 tokenAmount = IACOToken(acoToken).currentCollateralizedTokens(address(this));\\r\\n        \\r\\n        if (_collateralIsUnderlying) {\\r\\n            collateralLocked = tokenAmount;\\r\\n        } else {\\r\\n            collateralLocked = tokenAmount.mul(_strikePrice).div(_underlyingPrecision);\\r\\n        }\\r\\n\\t\\t\\r\\n        if (_expiryTime \\u003e block.timestamp) {\\r\\n            (uint256 price,) = _strategyQuote(_strikePrice, _expiryTime, underlyingPrice, 0, 1);\\r\\n            if (_collateralIsUnderlying) {\\r\\n                uint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, false); \\r\\n                collateralOnOpenPosition = price.mul(tokenAmount).div(priceAdjusted);\\r\\n            } else {\\r\\n                collateralOnOpenPosition = price.mul(tokenAmount).div(_underlyingPrecision);\\r\\n            }\\r\\n        } else {\\r\\n            collateralLockedRedeemable = collateralLocked;\\r\\n        }\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to transfer the locked position.\\r\\n     * @param shares Amount of shares.\\r\\n\\t * @param _totalSupply The pool total shares.\\r\\n\\t * @return acos Addresses of the ACOs with locked collateral transferred\\r\\n     * acosAmount the respective ACOs amount transferred.\\r\\n     */\\r\\n\\tfunction _transferOpenPositions(uint256 shares, uint256 _totalSupply) internal returns(\\r\\n        address[] memory acos, \\r\\n        uint256[] memory acosAmount\\r\\n    ) {\\r\\n        uint256 size = openAcos.length;\\r\\n        acos = new address[](size);\\r\\n        acosAmount = new uint256[](size);\\r\\n\\t\\tfor (uint256 i = 0; i \\u003c size; ++i) {\\r\\n\\t\\t\\taddress acoToken = openAcos[i];\\r\\n\\t\\t\\tuint256 tokens = IACOToken(acoToken).currentCollateralizedTokens(address(this));\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tacos[i] = acoToken;\\r\\n\\t\\t\\tacosAmount[i] = tokens.mul(shares).div(_totalSupply);\\r\\n\\t\\t\\t\\r\\n            if (acosAmount[i] \\u003e 0) {\\r\\n\\t\\t\\t    IACOToken(acoToken).transferCollateralOwnership(msg.sender, acosAmount[i]);\\r\\n            }\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to get the current underlying price adjusted to consider the Oracle delay to update.\\r\\n     * @param underlyingPrice The current underlying price.\\r\\n\\t * @param isMaximum TRUE whether it is a maximum price, otherwise FALSE for a minimum price.\\r\\n\\t * @return The underlying price adjusted.\\r\\n     */\\r\\n\\tfunction _getUnderlyingPriceAdjusted(uint256 underlyingPrice, bool isMaximum) internal view returns(uint256) {\\r\\n\\t\\tif (isMaximum) {\\r\\n\\t\\t\\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.add(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.sub(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\\r\\n\\t\\t}\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to remove an active ACO token from the array.\\r\\n     * @param data The ACO data for the token.\\r\\n     */\\r\\n    function _removeFromOpenAcos(AcoData storage data) internal {\\r\\n        uint256 lastIndex = openAcos.length - 1;\\r\\n\\t\\tuint256 index = data.openIndex;\\r\\n\\t\\tif (lastIndex != index) {\\r\\n\\t\\t    address last = openAcos[lastIndex];\\r\\n\\t\\t\\topenAcos[index] = last;\\r\\n\\t\\t\\tacoData[last].openIndex = index;\\r\\n\\t\\t}\\r\\n\\t\\tdata.openIndex = 0;\\r\\n        openAcos.pop();\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to redeem the collateral from an ACO token.\\r\\n     * It redeems the collateral only if the ACO token is expired.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n     */\\r\\n\\tfunction _redeemACOToken(address acoToken) internal {\\r\\n\\t\\tAcoData storage data = acoData[acoToken];\\r\\n\\t\\tif (data.open \\u0026\\u0026 IACOToken(acoToken).expiryTime() \\u003c= block.timestamp) {\\r\\n\\t\\t\\t\\r\\n            data.open = false;\\r\\n\\r\\n            if (IACOToken(acoToken).currentCollateralizedTokens(address(this)) \\u003e 0) {\\t\\r\\n\\t\\t\\t    data.collateralRedeemed = IACOToken(acoToken).redeem();\\r\\n            }\\r\\n            \\r\\n\\t\\t\\t_removeFromOpenAcos(data);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\temit ACORedeem(acoToken, data.valueSold, data.collateralLocked, data.collateralRedeemed);\\r\\n\\t\\t}\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to check whether the ACO assets and creator is valid for the pool.\\r\\n     * @param acoToken Address of the ACO token.\\r\\n\\t * @param _underlying Address of the underlying.\\r\\n\\t * @param _strikeAsset Address of the strike asset.\\r\\n\\t * @param _isCall TRUE whether the ACO is a CALL option, FALSE for a PUT option.\\r\\n     * @return TRUE whether it is valid, otherwise FALSE.\\r\\n     */\\r\\n\\tfunction _acoBasicDataIsValid(address acoToken, address _underlying, address _strikeAsset, bool _isCall) internal view returns(bool) {\\r\\n\\t\\treturn _underlying == underlying \\u0026\\u0026 _strikeAsset == strikeAsset \\u0026\\u0026 _isCall == isCall \\u0026\\u0026 validAcoCreators[acoFactory.creators(acoToken)];\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to check whether the ACO expiration is valid for the pool.\\r\\n     * @param _expiryTime ACO expiry time.\\r\\n     * @return TRUE whether it is valid, otherwise FALSE.\\r\\n     */\\r\\n\\tfunction _acoExpirationIsValid(uint256 _expiryTime) internal view returns(bool) {\\r\\n\\t\\treturn _expiryTime \\u003e= block.timestamp.add(minExpiration) \\u0026\\u0026 _expiryTime \\u003c= block.timestamp.add(maxExpiration);\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to check whether the ACO strike asset is valid for the pool.\\r\\n     * @param _strikePrice ACO strike price.\\r\\n     * @param price Current underlying price.\\r\\n     * @return TRUE whether it is valid, otherwise FALSE.\\r\\n     */\\r\\n\\tfunction _acoStrikePriceIsValid(uint256 _strikePrice, uint256 price) internal view returns(bool) {\\r\\n\\t\\tuint256 _tolerancePriceAbove = tolerancePriceAbove;\\r\\n\\t\\tuint256 _tolerancePriceBelow = tolerancePriceBelow;\\r\\n\\t\\treturn (_tolerancePriceBelow == 0 \\u0026\\u0026 _tolerancePriceAbove == 0) ||\\r\\n\\t\\t\\t(_tolerancePriceBelow == 0 \\u0026\\u0026 _strikePrice \\u003e price.mul(PERCENTAGE_PRECISION.add(_tolerancePriceAbove)).div(PERCENTAGE_PRECISION)) ||\\r\\n\\t\\t\\t(_tolerancePriceAbove == 0 \\u0026\\u0026 _strikePrice \\u003c price.mul(PERCENTAGE_PRECISION.sub(_tolerancePriceBelow)).div(PERCENTAGE_PRECISION)) ||\\r\\n\\t\\t\\t(_strikePrice \\u003e= price.mul(PERCENTAGE_PRECISION.sub(_tolerancePriceBelow)).div(PERCENTAGE_PRECISION) \\u0026\\u0026 \\r\\n\\t\\t\\t _strikePrice \\u003c= price.mul(PERCENTAGE_PRECISION.add(_tolerancePriceAbove)).div(PERCENTAGE_PRECISION));\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to infinite authorize the pool assets on the asset converter helper.\\r\\n     * @param _isCall True whether it is a CALL option, otherwise it is PUT.\\r\\n     * @param _assetConverterHelper Address of the asset converter helper.\\r\\n     * @param _underlying Address of the underlying asset.\\r\\n     * @param _strikeAsset Address of the strike asset.\\r\\n     */\\r\\n\\tfunction _approveAssetsOnConverterHelper(\\r\\n        bool _isCall, \\r\\n        address _assetConverterHelper,\\r\\n        address _underlying,\\r\\n        address _strikeAsset\\r\\n    ) internal {\\r\\n        if (_isCall) {\\r\\n            if (!ACOAssetHelper._isEther(_strikeAsset)) {\\r\\n                _setAuthorizedSpender(_strikeAsset, _assetConverterHelper);\\r\\n            }\\r\\n        } else if (!ACOAssetHelper._isEther(_underlying)) {\\r\\n            _setAuthorizedSpender(_underlying, _assetConverterHelper);\\r\\n        }\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to get the pool balance of an asset.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The pool balance.\\r\\n     */\\r\\n\\tfunction _getPoolBalanceOf(address asset) internal view returns(uint256) {\\r\\n        return ACOAssetHelper._getAssetBalanceOf(asset, address(this));\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to infinite authorize a spender on an asset.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param spender Address of the spender to be authorized.\\r\\n     */\\r\\n\\tfunction _setAuthorizedSpender(address asset, address spender) internal {\\r\\n        ACOAssetHelper._callApproveERC20(asset, spender, MAX_UINT);\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to set the strategy address.\\r\\n     * @param newStrategy Address of the new strategy address.\\r\\n     */\\r\\n\\tfunction _setStrategy(address newStrategy) internal {\\r\\n        require(newStrategy.isContract(), \\\"E81\\\");\\r\\n        emit SetStrategy(address(strategy), newStrategy);\\r\\n        strategy = IACOPoolStrategy(newStrategy);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to set the base volatility.\\r\\n     * @param newBaseVolatility Value of the new base volatility.\\r\\n     */\\r\\n    function _setBaseVolatility(uint256 newBaseVolatility) internal {\\r\\n        require(newBaseVolatility \\u003e 0, \\\"E82\\\");\\r\\n        emit SetBaseVolatility(baseVolatility, newBaseVolatility);\\r\\n        baseVolatility = newBaseVolatility;\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to set the asset converter address.\\r\\n     * @param newAssetConverter Address of the new asset converter.\\r\\n     */\\r\\n    function _setAssetConverter(address newAssetConverter) internal {\\r\\n        require(newAssetConverter.isContract(), \\\"E83\\\");\\r\\n\\t\\trequire(IACOAssetConverterHelper(newAssetConverter).getPrice(underlying, strikeAsset) \\u003e 0, \\\"E84\\\");\\r\\n\\t\\t\\r\\n\\t\\t_approveAssetsOnConverterHelper(isCall, newAssetConverter, underlying, strikeAsset);\\r\\n\\t\\t\\r\\n        emit SetAssetConverter(address(assetConverter), newAssetConverter);\\r\\n        assetConverter = IACOAssetConverterHelper(newAssetConverter);\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to set the percentage of the above price tolerance.\\r\\n     * @param newTolerancePriceAbove Value of the new above price tolerance.\\r\\n     */\\r\\n    function _setTolerancePriceAbove(uint256 newTolerancePriceAbove) internal {\\r\\n        require(newTolerancePriceAbove \\u003c PERCENTAGE_PRECISION, \\\"E85\\\");\\r\\n        emit SetTolerancePriceAbove(tolerancePriceAbove, newTolerancePriceAbove);\\r\\n        tolerancePriceAbove = newTolerancePriceAbove;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to set the percentage of the below price tolerance.\\r\\n     * @param newTolerancePriceBelow Value of the new below price tolerance.\\r\\n     */\\r\\n    function _setTolerancePriceBelow(uint256 newTolerancePriceBelow) internal {\\r\\n        require(newTolerancePriceBelow \\u003c PERCENTAGE_PRECISION, \\\"E86\\\");\\r\\n        emit SetTolerancePriceBelow(tolerancePriceBelow, newTolerancePriceBelow);\\r\\n        tolerancePriceBelow = newTolerancePriceBelow;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to set the minimum expiration seconds after current time to the pool accepts an ACO based on its expiry time.\\r\\n     * @param newMinExpiration Value of the new minimum expiration.\\r\\n     */\\r\\n    function _setMinExpiration(uint256 newMinExpiration) internal {\\r\\n        require(newMinExpiration \\u003c= maxExpiration, \\\"E87\\\");\\r\\n        emit SetMinExpiration(minExpiration, newMinExpiration);\\r\\n        minExpiration = newMinExpiration;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to set the maximum expiration seconds after current time to the pool accepts an ACO based on its expiry time.\\r\\n     * @param newMaxExpiration Value of the new maximum expiration.\\r\\n     */\\r\\n    function _setMaxExpiration(uint256 newMaxExpiration) internal {\\r\\n        require(newMaxExpiration \\u003e= minExpiration, \\\"E88\\\");\\r\\n        emit SetMaxExpiration(maxExpiration, newMaxExpiration);\\r\\n        maxExpiration = newMaxExpiration;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to set the fee destination.\\r\\n     * @param newFeeDestination Value of the new fee destination.\\r\\n     */\\r\\n    function _setFeeDestination(address newFeeDestination) internal {\\r\\n        require(newFeeDestination != address(0), \\\"E89\\\");\\r\\n        emit SetFeeDestination(feeDestination, newFeeDestination);\\r\\n        feeDestination = newFeeDestination;\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to set the protocol fee percentage.\\r\\n     * @param newFee Value of the new protocol fee.\\r\\n     */\\r\\n    function _setFee(uint256 newFee) internal {\\r\\n        require(newFee \\u003c= 12500, \\\"E91\\\");\\r\\n        emit SetFee(fee, newFee);\\r\\n        fee = newFee;\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to set the penalty percentage on withdrawing open positions.\\r\\n     * @param newWithdrawOpenPositionPenalty Value of the new penalty percentage on withdrawing open positions.\\r\\n     */\\r\\n    function _setWithdrawOpenPositionPenalty(uint256 newWithdrawOpenPositionPenalty) internal {\\r\\n        require(newWithdrawOpenPositionPenalty \\u003c= PERCENTAGE_PRECISION, \\\"E92\\\");\\r\\n        emit SetWithdrawOpenPositionPenalty(withdrawOpenPositionPenalty, newWithdrawOpenPositionPenalty);\\r\\n        withdrawOpenPositionPenalty = newWithdrawOpenPositionPenalty;\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to set the underlying price percentage adjust.\\r\\n     * @param newUnderlyingPriceAdjustPercentage Value of the new underlying price percentage adjust.\\r\\n     */\\r\\n\\tfunction _setUnderlyingPriceAdjustPercentage(uint256 newUnderlyingPriceAdjustPercentage) internal {\\r\\n        require(newUnderlyingPriceAdjustPercentage \\u003c PERCENTAGE_PRECISION, \\\"E93\\\");\\r\\n        emit SetUnderlyingPriceAdjustPercentage(underlyingPriceAdjustPercentage, newUnderlyingPriceAdjustPercentage);\\r\\n        underlyingPriceAdjustPercentage = newUnderlyingPriceAdjustPercentage;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to set the maximum number of open ACOs allowed.\\r\\n     * @param newMaximumOpenAco Value of the new maximum number of open ACOs allowed.\\r\\n     */\\r\\n\\tfunction _setMaximumOpenAco(uint256 newMaximumOpenAco) internal {\\r\\n        require(newMaximumOpenAco \\u003e 0, \\\"E94\\\");\\r\\n        emit SetMaximumOpenAco(maximumOpenAco, newMaximumOpenAco);\\r\\n        maximumOpenAco = newMaximumOpenAco;\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to set an valid creator permission.\\r\\n     * @param creator Address of the creator.\\r\\n\\t * @param newPermission Value of the new permission.\\r\\n     */\\r\\n    function _setValidAcoCreator(address creator, bool newPermission) internal {\\r\\n        emit SetValidAcoCreator(creator, validAcoCreators[creator], newPermission);\\r\\n        validAcoCreators[creator] = newPermission;\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n     * @dev Internal function to check whether the transaction sender is the pool factory.\\r\\n     */\\r\\n    function onlyFactory() internal view {\\r\\n        require(owner() == msg.sender, \\\"E90\\\");\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n     * @dev Internal function to get the token name.\\r\\n     * The token name is assembled with the token data:\\r\\n     * ACO POOL WRITE UNDERLYING_SYMBOL-STRIKE_ASSET_SYMBOL-TYPE\\r\\n     * @return The token name.\\r\\n     */\\r\\n\\tfunction _name() internal view returns(string memory) {\\r\\n        return string(abi.encodePacked(\\r\\n            \\\"ACO POOL WRITE \\\",\\r\\n            ACOAssetHelper._getAssetSymbol(underlying),\\r\\n            \\\"-\\\",\\r\\n            ACOAssetHelper._getAssetSymbol(strikeAsset),\\r\\n            \\\"-\\\",\\r\\n            (isCall ? \\\"CALL\\\" : \\\"PUT\\\")\\r\\n        ));\\r\\n    }\\r\\n}\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC20\\r\\n * @dev Base implementation of ERC20 token.\\r\\n */\\r\\nabstract contract ERC20 is IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    uint256 private _totalSupply;\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    function name() public view virtual returns(string memory);\\r\\n    function symbol() public view virtual returns(string memory);\\r\\n    function decimals() public view virtual returns(uint8);\\r\\n\\r\\n    function totalSupply() public view override returns(uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns(uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view override returns(uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public override returns(bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns(bool) {\\r\\n        _approveAction(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\r\\n        _transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns(bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 amount) public returns(bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(amount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 amount) public returns(bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(amount));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        _transferAction(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        _approveAction(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    function _burnFrom(address account, uint256 amount) internal {\\r\\n        _approveAction(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\r\\n        _burnAction(account, amount);\\r\\n    }\\r\\n\\r\\n    function _transferAction(address sender, address recipient, uint256 amount) internal {\\r\\n        require(sender != address(0), \\\"ERC20::_transferAction: Invalid sender\\\");\\r\\n        require(recipient != address(0), \\\"ERC20::_transferAction: Invalid recipient\\\");\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount);\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        \\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n    \\r\\n    function _approveAction(address owner, address spender, uint256 amount) internal {\\r\\n        require(owner != address(0), \\\"ERC20::_approveAction: Invalid owner\\\");\\r\\n        require(spender != address(0), \\\"ERC20::_approveAction: Invalid spender\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        \\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    function _mintAction(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20::_mintAction: Invalid account\\\");\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        \\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _burnAction(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20::_burnAction: Invalid account\\\");\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount);\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        \\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n}    \\r\\n\"},\"IACOAssetConverterHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOAssetConverterHelper {\\r\\n    function setPairTolerancePercentage(address baseAsset, address quoteAsset, uint256 tolerancePercentage) external;\\r\\n    function setAggregator(address baseAsset, address quoteAsset, address aggregator) external;\\r\\n    function setUniswapMiddleRoute(address baseAsset, address quoteAsset, address[] calldata uniswapMiddleRoute) external;\\r\\n    function withdrawStuckAsset(address asset, address destination) external;\\r\\n    function hasAggregator(address baseAsset, address quoteAsset) external view returns(bool);\\r\\n    function getPairData(address baseAsset, address quoteAsset) external view returns(address, uint256, uint256, uint256);\\r\\n    function getUniswapMiddleRouteByIndex(address baseAsset, address quoteAsset, uint256 index) external view returns(address);\\r\\n    function getPrice(address baseAsset, address quoteAsset) external view returns(uint256);\\r\\n    function getPriceWithTolerance(address baseAsset, address quoteAsset, bool isMinimumPrice) external view returns(uint256);\\r\\n    function getExpectedAmountOutToSwapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external view returns(uint256);\\r\\n    function getExpectedAmountOutToSwapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external view returns(uint256);\\r\\n    function swapExactAmountOut(address assetToSold, address assetToBuy, uint256 amountToSold) external payable returns(uint256);\\r\\n    function swapExactAmountOutWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 tolerancePercentage) external payable returns(uint256);\\r\\n    function swapExactAmountOutWithMinAmountToReceive(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 minAmountToReceive) external payable returns(uint256);\\r\\n    function swapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external payable returns(uint256);\\r\\n    function swapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external payable returns(uint256);\\r\\n    function swapExactAmountInWithMaxAmountToSold(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 maxAmountToSold) external payable returns(uint256);\\r\\n}\"},\"IACOFactory.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOFactory {\\r\\n\\tfunction init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) external;\\r\\n    function acoFee() external view returns(uint256);\\r\\n    function factoryAdmin() external view returns(address);\\r\\n    function acoTokenImplementation() external view returns(address);\\r\\n    function acoFeeDestination() external view returns(address);\\r\\n    function acoTokenData(address acoToken) external view returns(address, address, bool, uint256, uint256);\\r\\n    function creators(address acoToken) external view returns(address);\\r\\n    function createAcoToken(address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime, uint256 maxExercisedAccounts) external returns(address);\\r\\n    function setFactoryAdmin(address newFactoryAdmin) external;\\r\\n    function setAcoTokenImplementation(address newAcoTokenImplementation) external;\\r\\n    function setAcoFee(uint256 newAcoFee) external;\\r\\n    function setAcoFeeDestination(address newAcoFeeDestination) external;\\r\\n}\"},\"IACOPool2.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\ninterface IACOPool2 is IERC20 {\\r\\n\\r\\n    struct InitData {\\r\\n        address acoFactory;\\r\\n        address chiToken;\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCall; \\r\\n\\t\\taddress assetConverter;\\r\\n        uint256 fee;\\r\\n        address feeDestination;\\r\\n        uint256 withdrawOpenPositionPenalty;\\r\\n        uint256 underlyingPriceAdjustPercentage;\\r\\n\\t\\tuint256 maximumOpenAco;\\r\\n        uint256 tolerancePriceBelow;\\r\\n        uint256 tolerancePriceAbove; \\r\\n        uint256 minExpiration;\\r\\n        uint256 maxExpiration;\\r\\n        address strategy;\\r\\n        uint256 baseVolatility;    \\r\\n    }\\r\\n\\r\\n\\tstruct AcoData {\\r\\n        bool open;\\r\\n        uint256 valueSold;\\r\\n        uint256 collateralLocked;\\r\\n        uint256 collateralRedeemed;\\r\\n        uint256 index;\\r\\n\\t\\tuint256 openIndex;\\r\\n    }\\r\\n    \\r\\n\\tfunction init(InitData calldata initData) external;\\r\\n\\tfunction numberOfAcoTokensNegotiated() external view returns(uint256);\\r\\n    function numberOfOpenAcoTokens() external view returns(uint256);\\r\\n    function collateral() external view returns(address);\\r\\n\\tfunction canSwap(address acoToken) external view returns(bool);\\r\\n\\tfunction quote(address acoToken, uint256 tokenAmount) external view returns(\\r\\n\\t\\tuint256 swapPrice, \\r\\n\\t\\tuint256 protocolFee, \\r\\n\\t\\tuint256 underlyingPrice, \\r\\n\\t\\tuint256 volatility\\r\\n\\t);\\r\\n\\tfunction getDepositShares(uint256 collateralAmount) external view returns(uint256 shares);\\r\\n\\tfunction getWithdrawNoLockedData(uint256 shares) external view returns(\\r\\n\\t\\tuint256 underlyingWithdrawn, \\r\\n\\t\\tuint256 strikeAssetWithdrawn, \\r\\n\\t\\tbool isPossible\\r\\n\\t);\\r\\n\\tfunction getWithdrawWithLocked(uint256 shares) external view returns(\\r\\n\\t\\tuint256 underlyingWithdrawn, \\r\\n\\t\\tuint256 strikeAssetWithdrawn, \\r\\n\\t\\taddress[] memory acos, \\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t);\\r\\n\\tfunction setAssetConverter(address newAssetConverter) external;\\r\\n    function setTolerancePriceBelow(uint256 newTolerancePriceBelow) external;\\r\\n    function setTolerancePriceAbove(uint256 newTolerancePriceAbove) external;\\r\\n    function setMinExpiration(uint256 newMinExpiration) external;\\r\\n    function setMaxExpiration(uint256 newMaxExpiration) external;\\r\\n    function setFee(uint256 newFee) external;\\r\\n    function setFeeDestination(address newFeeDestination) external;\\r\\n\\tfunction setWithdrawOpenPositionPenalty(uint256 newWithdrawOpenPositionPenalty) external;\\r\\n\\tfunction setUnderlyingPriceAdjustPercentage(uint256 newUnderlyingPriceAdjustPercentage) external;\\r\\n\\tfunction setMaximumOpenAco(uint256 newMaximumOpenAco) external;\\r\\n\\tfunction setStrategy(address newStrategy) external;\\r\\n\\tfunction setBaseVolatility(uint256 newBaseVolatility) external;\\r\\n\\tfunction setValidAcoCreator(address newAcoCreator, bool newPermission) external;\\r\\n    function withdrawStuckToken(address token, address destination) external;\\r\\n    function deposit(uint256 collateralAmount, uint256 minShares, address to) external payable returns(uint256 acoPoolTokenAmount);\\r\\n\\tfunction depositWithGasToken(uint256 collateralAmount, uint256 minShares, address to) external payable returns(uint256 acoPoolTokenAmount);\\r\\n\\tfunction withdrawNoLocked(uint256 shares, uint256 minCollateral, address account) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t);\\r\\n\\tfunction withdrawNoLockedWithGasToken(uint256 shares, uint256 minCollateral, address account) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn\\r\\n\\t);\\r\\n    function withdrawWithLocked(uint256 shares, address account) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t);\\r\\n\\tfunction withdrawWithLockedWithGasToken(uint256 shares, address account) external returns (\\r\\n\\t\\tuint256 underlyingWithdrawn,\\r\\n\\t\\tuint256 strikeAssetWithdrawn,\\r\\n\\t\\taddress[] memory acos,\\r\\n\\t\\tuint256[] memory acosAmount\\r\\n\\t);\\r\\n    function swap(address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external;\\r\\n    function swapWithGasToken(address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external;\\r\\n    function redeemACOTokens() external;\\r\\n\\tfunction redeemACOToken(address acoToken) external;\\r\\n    function restoreCollateral() external;\\r\\n}\"},\"IACOPoolStrategy.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IACOPoolStrategy {\\r\\n    \\r\\n    struct OptionQuote {\\r\\n        uint256 underlyingPrice;\\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCallOption;\\r\\n        uint256 strikePrice; \\r\\n        uint256 expiryTime;\\r\\n        uint256 baseVolatility;\\r\\n        uint256 collateralOrderAmount;\\r\\n        uint256 collateralAvailable;\\r\\n    }\\r\\n\\r\\n    function quote(OptionQuote calldata quoteData) external view returns(uint256 optionPrice, uint256 volatility);\\r\\n}\"},\"IACOToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IACOToken is IERC20 {\\r\\n\\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function underlying() external view returns (address);\\r\\n    function strikeAsset() external view returns (address);\\r\\n    function feeDestination() external view returns (address);\\r\\n    function isCall() external view returns (bool);\\r\\n    function strikePrice() external view returns (uint256);\\r\\n    function expiryTime() external view returns (uint256);\\r\\n    function totalCollateral() external view returns (uint256);\\r\\n    function acoFee() external view returns (uint256);\\r\\n\\tfunction maxExercisedAccounts() external view returns (uint256);\\r\\n    function underlyingSymbol() external view returns (string memory);\\r\\n    function strikeAssetSymbol() external view returns (string memory);\\r\\n    function underlyingDecimals() external view returns (uint8);\\r\\n    function strikeAssetDecimals() external view returns (uint8);\\r\\n    function currentCollateral(address account) external view returns(uint256);\\r\\n    function unassignableCollateral(address account) external view returns(uint256);\\r\\n    function assignableCollateral(address account) external view returns(uint256);\\r\\n    function currentCollateralizedTokens(address account) external view returns(uint256);\\r\\n    function unassignableTokens(address account) external view returns(uint256);\\r\\n    function assignableTokens(address account) external view returns(uint256);\\r\\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\\r\\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\\r\\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\\r\\n    function numberOfAccountsWithCollateral() external view returns(uint256);\\r\\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\\r\\n    function collateral() external view returns(address);\\r\\n    function mintPayable() external payable returns(uint256);\\r\\n    function mintToPayable(address account) external payable returns(uint256);\\r\\n    function mint(uint256 collateralAmount) external returns(uint256);\\r\\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\\r\\n    function burn(uint256 tokenAmount) external returns(uint256);\\r\\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\\r\\n    function redeem() external returns(uint256);\\r\\n    function redeemFrom(address account) external returns(uint256);\\r\\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function transferCollateralOwnership(address recipient, uint256 tokenCollateralizedAmount) external;\\r\\n}\"},\"IChiToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\u0027./IERC20.sol\\u0027;\\r\\n\\r\\ninterface IChiToken is IERC20 {\\r\\n    function mint(uint256 value) external;\\r\\n    function computeAddress2(uint256 salt) external view returns(address);\\r\\n    function free(uint256 value) external returns(uint256);\\r\\n    function freeUpTo(uint256 value) external returns(uint256);\\r\\n    function freeFrom(address from, uint256 value) external returns(uint256);\\r\\n    function freeFromUpTo(address from, uint256 value) external returns(uint256);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Adapted from OpenZeppelin\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    function init() internal {\\r\\n        require(_owner == address(0), \\\"Ownable: Contract initialized\\\");\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralLocked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralRedeemed\",\"type\":\"uint256\"}],\"name\":\"ACORedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralRestored\",\"type\":\"uint256\"}],\"name\":\"RestoreCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAssetConverter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAssetConverter\",\"type\":\"address\"}],\"name\":\"SetAssetConverter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldBaseVolatility\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newBaseVolatility\",\"type\":\"uint256\"}],\"name\":\"SetBaseVolatility\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldFeeDestination\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFeeDestination\",\"type\":\"address\"}],\"name\":\"SetFeeDestination\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldMaxExpiration\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newMaxExpiration\",\"type\":\"uint256\"}],\"name\":\"SetMaxExpiration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldMaximumOpenAco\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newMaximumOpenAco\",\"type\":\"uint256\"}],\"name\":\"SetMaximumOpenAco\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldMinExpiration\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newMinExpiration\",\"type\":\"uint256\"}],\"name\":\"SetMinExpiration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldStrategy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"SetStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldTolerancePriceAbove\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newTolerancePriceAbove\",\"type\":\"uint256\"}],\"name\":\"SetTolerancePriceAbove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldTolerancePriceBelow\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newTolerancePriceBelow\",\"type\":\"uint256\"}],\"name\":\"SetTolerancePriceBelow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldUnderlyingPriceAdjustPercentage\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newUnderlyingPriceAdjustPercentage\",\"type\":\"uint256\"}],\"name\":\"SetUnderlyingPriceAdjustPercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"previousPermission\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"newPermission\",\"type\":\"bool\"}],\"name\":\"SetValidAcoCreator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldWithdrawOpenPositionPenalty\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newWithdrawOpenPositionPenalty\",\"type\":\"uint256\"}],\"name\":\"SetWithdrawOpenPositionPenalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"noLocked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"acos\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"acosAmount\",\"type\":\"uint256[]\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"acoData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"valueSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRedeemed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acoFactory\",\"outputs\":[{\"internalType\":\"contract IACOFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"acoTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetConverter\",\"outputs\":[{\"internalType\":\"contract IACOAssetConverterHelper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseVolatility\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"}],\"name\":\"canSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chiToken\",\"outputs\":[{\"internalType\":\"contract IChiToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minShares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minShares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"depositWithGasToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"getDepositShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"getWithdrawNoLockedData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPossible\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"getWithdrawWithLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"acos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"acosAmount\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"acoFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"chiToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"assetConverter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawOpenPositionPenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPriceAdjustPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumOpenAco\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePriceBelow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tolerancePriceAbove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxExpiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseVolatility\",\"type\":\"uint256\"}],\"internalType\":\"struct IACOPool2.InitData\",\"name\":\"initData\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxExpiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumOpenAco\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minExpiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfAcoTokensNegotiated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfOpenAcoTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"openAcos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"}],\"name\":\"redeemACOToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemACOTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restoreCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAssetConverter\",\"type\":\"address\"}],\"name\":\"setAssetConverter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBaseVolatility\",\"type\":\"uint256\"}],\"name\":\"setBaseVolatility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeDestination\",\"type\":\"address\"}],\"name\":\"setFeeDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxExpiration\",\"type\":\"uint256\"}],\"name\":\"setMaxExpiration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaximumOpenAco\",\"type\":\"uint256\"}],\"name\":\"setMaximumOpenAco\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinExpiration\",\"type\":\"uint256\"}],\"name\":\"setMinExpiration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"setStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTolerancePriceAbove\",\"type\":\"uint256\"}],\"name\":\"setTolerancePriceAbove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTolerancePriceBelow\",\"type\":\"uint256\"}],\"name\":\"setTolerancePriceBelow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newUnderlyingPriceAdjustPercentage\",\"type\":\"uint256\"}],\"name\":\"setUnderlyingPriceAdjustPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAcoCreator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"newPermission\",\"type\":\"bool\"}],\"name\":\"setValidAcoCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWithdrawOpenPositionPenalty\",\"type\":\"uint256\"}],\"name\":\"setWithdrawOpenPositionPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"contract IACOPoolStrategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strikeAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restriction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"restriction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapWithGasToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tolerancePriceAbove\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tolerancePriceBelow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingPriceAdjustPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validAcoCreators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawNoLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawNoLockedWithGasToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawOpenPositionPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"withdrawStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawWithLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"acos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"acosAmount\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawWithLockedWithGasToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikeAssetWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"acos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"acosAmount\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOPool2","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://02b61ba615507ce14d680e73cc3c3780fe711c4b3f8d58a33db307db4b0f2085"}]}