{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC1155TokenReceiver.sol\":{\"content\":\"pragma solidity ^0.4.15;\\n\\n/**\\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\\n*/\\ninterface ERC1155TokenReceiver {\\n    /**\\n        @notice Handle the receipt of a single ERC1155 token type.\\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\\n        This function MUST return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\\n        This function MUST revert if it rejects the transfer.\\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\\n        @param _from      The address which previously owned the token\\n        @param _id        The ID of the token being transferred\\n        @param _value     The amount of tokens being transferred\\n        @param _data      Additional data with no specified format\\n        @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n    */\\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes _data) external returns(bytes4);\\n\\n    /**\\n        @notice Handle the receipt of multiple ERC1155 token types.\\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\\n        This function MUST return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\\n        This function MUST revert if it rejects the transfer(s).\\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\\n        @param _from      The address which previously owned the token\\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\\n        @param _data      Additional data with no specified format\\n        @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n    */\\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] _ids, uint256[] _values, bytes _data) external returns(bytes4);\\n}\\n\"},\"MultiSigWallet.sol\":{\"content\":\"pragma solidity ^0.4.15;\\n\\n\\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\\n/// @author Stefan George - \\u003cstefan.george@consensys.net\\u003e\\ncontract MultiSigWallet {\\n\\n    /*\\n     *  Events\\n     */\\n    event Confirmation(address indexed sender, uint indexed transactionId);\\n    event Revocation(address indexed sender, uint indexed transactionId);\\n    event Submission(uint indexed transactionId);\\n    event Execution(uint indexed transactionId);\\n    event ExecutionFailure(uint indexed transactionId);\\n    event Deposit(address indexed sender, uint value);\\n    event OwnerAddition(address indexed owner);\\n    event OwnerRemoval(address indexed owner);\\n    event RequirementChange(uint required);\\n\\n    /*\\n     *  Constants\\n     */\\n    uint constant public MAX_OWNER_COUNT = 50;\\n\\n    /*\\n     *  Storage\\n     */\\n    mapping (uint =\\u003e Transaction) public transactions;\\n    mapping (uint =\\u003e mapping (address =\\u003e bool)) public confirmations;\\n    mapping (address =\\u003e bool) public isOwner;\\n    address[] public owners;\\n    uint public required;\\n    uint public transactionCount;\\n\\n    struct Transaction {\\n        address destination;\\n        uint value;\\n        bytes data;\\n        bool executed;\\n    }\\n\\n    /*\\n     *  Modifiers\\n     */\\n    modifier onlyWallet() {\\n        require(msg.sender == address(this));\\n        _;\\n    }\\n\\n    modifier ownerDoesNotExist(address owner) {\\n        require(!isOwner[owner]);\\n        _;\\n    }\\n\\n    modifier ownerExists(address owner) {\\n        require(isOwner[owner]);\\n        _;\\n    }\\n\\n    modifier transactionExists(uint transactionId) {\\n        require(transactions[transactionId].destination != 0);\\n        _;\\n    }\\n\\n    modifier confirmed(uint transactionId, address owner) {\\n        require(confirmations[transactionId][owner]);\\n        _;\\n    }\\n\\n    modifier notConfirmed(uint transactionId, address owner) {\\n        require(!confirmations[transactionId][owner]);\\n        _;\\n    }\\n\\n    modifier notExecuted(uint transactionId) {\\n        require(!transactions[transactionId].executed);\\n        _;\\n    }\\n\\n    modifier notNull(address _address) {\\n        require(_address != 0);\\n        _;\\n    }\\n\\n    modifier validRequirement(uint ownerCount, uint _required) {\\n        require(ownerCount \\u003c= MAX_OWNER_COUNT\\n            \\u0026\\u0026 _required \\u003c= ownerCount\\n            \\u0026\\u0026 _required != 0\\n            \\u0026\\u0026 ownerCount != 0);\\n        _;\\n    }\\n\\n    /// @dev Fallback function allows to deposit ether.\\n    function()\\n        payable\\n    {\\n        if (msg.value \\u003e 0)\\n            Deposit(msg.sender, msg.value);\\n    }\\n\\n    /*\\n     * Public functions\\n     */\\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\\n    /// @param _owners List of initial owners.\\n    /// @param _required Number of required confirmations.\\n    function MultiSigWallet(address[] _owners, uint _required)\\n        public\\n        validRequirement(_owners.length, _required)\\n    {\\n        for (uint i=0; i\\u003c_owners.length; i++) {\\n            require(!isOwner[_owners[i]] \\u0026\\u0026 _owners[i] != 0);\\n            isOwner[_owners[i]] = true;\\n        }\\n        owners = _owners;\\n        required = _required;\\n    }\\n\\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\\n    /// @param owner Address of new owner.\\n    function addOwner(address owner)\\n        public\\n        onlyWallet\\n        ownerDoesNotExist(owner)\\n        notNull(owner)\\n        validRequirement(owners.length + 1, required)\\n    {\\n        isOwner[owner] = true;\\n        owners.push(owner);\\n        OwnerAddition(owner);\\n    }\\n\\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\\n    /// @param owner Address of owner.\\n    function removeOwner(address owner)\\n        public\\n        onlyWallet\\n        ownerExists(owner)\\n    {\\n        isOwner[owner] = false;\\n        for (uint i=0; i\\u003cowners.length - 1; i++)\\n            if (owners[i] == owner) {\\n                owners[i] = owners[owners.length - 1];\\n                break;\\n            }\\n        owners.length -= 1;\\n        if (required \\u003e owners.length)\\n            changeRequirement(owners.length);\\n        OwnerRemoval(owner);\\n    }\\n\\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\\n    /// @param owner Address of owner to be replaced.\\n    /// @param newOwner Address of new owner.\\n    function replaceOwner(address owner, address newOwner)\\n        public\\n        onlyWallet\\n        ownerExists(owner)\\n        ownerDoesNotExist(newOwner)\\n    {\\n        for (uint i=0; i\\u003cowners.length; i++)\\n            if (owners[i] == owner) {\\n                owners[i] = newOwner;\\n                break;\\n            }\\n        isOwner[owner] = false;\\n        isOwner[newOwner] = true;\\n        OwnerRemoval(owner);\\n        OwnerAddition(newOwner);\\n    }\\n\\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\\n    /// @param _required Number of required confirmations.\\n    function changeRequirement(uint _required)\\n        public\\n        onlyWallet\\n        validRequirement(owners.length, _required)\\n    {\\n        required = _required;\\n        RequirementChange(_required);\\n    }\\n\\n    /// @dev Allows an owner to submit and confirm a transaction.\\n    /// @param destination Transaction target address.\\n    /// @param value Transaction ether value.\\n    /// @param data Transaction data payload.\\n    /// @return Returns transaction ID.\\n    function submitTransaction(address destination, uint value, bytes data)\\n        public\\n        returns (uint transactionId)\\n    {\\n        transactionId = addTransaction(destination, value, data);\\n        confirmTransaction(transactionId);\\n    }\\n\\n    /// @dev Allows an owner to confirm a transaction.\\n    /// @param transactionId Transaction ID.\\n    function confirmTransaction(uint transactionId)\\n        public\\n        ownerExists(msg.sender)\\n        transactionExists(transactionId)\\n        notConfirmed(transactionId, msg.sender)\\n    {\\n        confirmations[transactionId][msg.sender] = true;\\n        Confirmation(msg.sender, transactionId);\\n        executeTransaction(transactionId);\\n    }\\n\\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\\n    /// @param transactionId Transaction ID.\\n    function revokeConfirmation(uint transactionId)\\n        public\\n        ownerExists(msg.sender)\\n        confirmed(transactionId, msg.sender)\\n        notExecuted(transactionId)\\n    {\\n        confirmations[transactionId][msg.sender] = false;\\n        Revocation(msg.sender, transactionId);\\n    }\\n\\n    /// @dev Allows anyone to execute a confirmed transaction.\\n    /// @param transactionId Transaction ID.\\n    function executeTransaction(uint transactionId)\\n        public\\n        ownerExists(msg.sender)\\n        confirmed(transactionId, msg.sender)\\n        notExecuted(transactionId)\\n    {\\n        if (isConfirmed(transactionId)) {\\n            Transaction storage txn = transactions[transactionId];\\n            txn.executed = true;\\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\\n                Execution(transactionId);\\n            else {\\n                ExecutionFailure(transactionId);\\n                txn.executed = false;\\n            }\\n        }\\n    }\\n\\n    // call has been separated into its own function in order to take advantage\\n    // of the Solidity\\u0027s code generator to produce a loop that copies tx.data into memory.\\n    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\\n        bool result;\\n        assembly {\\n            let x := mload(0x40)   // \\\"Allocate\\\" memory for output (0x40 is where \\\"free memory\\\" pointer is stored by convention)\\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\\n            result := call(\\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\\n                destination,\\n                value,\\n                d,\\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\\n                x,\\n                0                  // Output is ignored, therefore the output size is zero\\n            )\\n        }\\n        return result;\\n    }\\n\\n    /// @dev Returns the confirmation status of a transaction.\\n    /// @param transactionId Transaction ID.\\n    /// @return Confirmation status.\\n    function isConfirmed(uint transactionId)\\n        public\\n        constant\\n        returns (bool)\\n    {\\n        uint count = 0;\\n        for (uint i=0; i\\u003cowners.length; i++) {\\n            if (confirmations[transactionId][owners[i]])\\n                count += 1;\\n            if (count == required)\\n                return true;\\n        }\\n    }\\n\\n    /*\\n     * Internal functions\\n     */\\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\\n    /// @param destination Transaction target address.\\n    /// @param value Transaction ether value.\\n    /// @param data Transaction data payload.\\n    /// @return Returns transaction ID.\\n    function addTransaction(address destination, uint value, bytes data)\\n        internal\\n        notNull(destination)\\n        returns (uint transactionId)\\n    {\\n        transactionId = transactionCount;\\n        transactions[transactionId] = Transaction({\\n            destination: destination,\\n            value: value,\\n            data: data,\\n            executed: false\\n        });\\n        transactionCount += 1;\\n        Submission(transactionId);\\n    }\\n\\n    /*\\n     * Web3 call functions\\n     */\\n    /// @dev Returns number of confirmations of a transaction.\\n    /// @param transactionId Transaction ID.\\n    /// @return Number of confirmations.\\n    function getConfirmationCount(uint transactionId)\\n        public\\n        constant\\n        returns (uint count)\\n    {\\n        for (uint i=0; i\\u003cowners.length; i++)\\n            if (confirmations[transactionId][owners[i]])\\n                count += 1;\\n    }\\n\\n    /// @dev Returns total number of transactions after filers are applied.\\n    /// @param pending Include pending transactions.\\n    /// @param executed Include executed transactions.\\n    /// @return Total number of transactions after filters are applied.\\n    function getTransactionCount(bool pending, bool executed)\\n        public\\n        constant\\n        returns (uint count)\\n    {\\n        for (uint i=0; i\\u003ctransactionCount; i++)\\n            if (   pending \\u0026\\u0026 !transactions[i].executed\\n                || executed \\u0026\\u0026 transactions[i].executed)\\n                count += 1;\\n    }\\n\\n    /// @dev Returns list of owners.\\n    /// @return List of owner addresses.\\n    function getOwners()\\n        public\\n        constant\\n        returns (address[])\\n    {\\n        return owners;\\n    }\\n\\n    /// @dev Returns array with owner addresses, which confirmed transaction.\\n    /// @param transactionId Transaction ID.\\n    /// @return Returns array of owner addresses.\\n    function getConfirmations(uint transactionId)\\n        public\\n        constant\\n        returns (address[] _confirmations)\\n    {\\n        address[] memory confirmationsTemp = new address[](owners.length);\\n        uint count = 0;\\n        uint i;\\n        for (i=0; i\\u003cowners.length; i++)\\n            if (confirmations[transactionId][owners[i]]) {\\n                confirmationsTemp[count] = owners[i];\\n                count += 1;\\n            }\\n        _confirmations = new address[](count);\\n        for (i=0; i\\u003ccount; i++)\\n            _confirmations[i] = confirmationsTemp[i];\\n    }\\n\\n    /// @dev Returns list of transaction IDs in defined range.\\n    /// @param from Index start position of transaction array.\\n    /// @param to Index end position of transaction array.\\n    /// @param pending Include pending transactions.\\n    /// @param executed Include executed transactions.\\n    /// @return Returns array of transaction IDs.\\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\\n        public\\n        constant\\n        returns (uint[] _transactionIds)\\n    {\\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\\n        uint count = 0;\\n        uint i;\\n        for (i=0; i\\u003ctransactionCount; i++)\\n            if (   pending \\u0026\\u0026 !transactions[i].executed\\n                || executed \\u0026\\u0026 transactions[i].executed)\\n            {\\n                transactionIdsTemp[count] = i;\\n                count += 1;\\n            }\\n        _transactionIds = new uint[](to - from);\\n        for (i=from; i\\u003cto; i++)\\n            _transactionIds[i - from] = transactionIdsTemp[i];\\n    }\\n}\\n\"},\"MultiSigWalletWithDailyLimit.sol\":{\"content\":\"pragma solidity ^0.4.15;\\nimport \\\"./MultiSigWalletWithERC1155TokenReceiver.sol\\\";\\n\\n\\n/// @title Multisignature wallet with daily limit - Allows an owner to withdraw a daily limit without multisig.\\n/// @author Stefan George - \\u003cstefan.george@consensys.net\\u003e\\ncontract MultiSigWalletWithDailyLimit is MultiSigWalletWithERC1155TokenReceiver {\\n\\n    /*\\n     *  Events\\n     */\\n    event DailyLimitChange(uint dailyLimit);\\n\\n    /*\\n     *  Storage\\n     */\\n    uint public dailyLimit;\\n    uint public lastDay;\\n    uint public spentToday;\\n\\n    /*\\n     * Public functions\\n     */\\n    /// @dev Contract constructor sets initial owners, required number of confirmations and daily withdraw limit.\\n    /// @param _owners List of initial owners.\\n    /// @param _required Number of required confirmations.\\n    /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis.\\n    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\\n        public\\n        MultiSigWalletWithERC1155TokenReceiver(_owners, _required)\\n    {\\n        dailyLimit = _dailyLimit;\\n    }\\n\\n    /// @dev Allows to change the daily limit. Transaction has to be sent by wallet.\\n    /// @param _dailyLimit Amount in wei.\\n    function changeDailyLimit(uint _dailyLimit)\\n        public\\n        onlyWallet\\n    {\\n        dailyLimit = _dailyLimit;\\n        DailyLimitChange(_dailyLimit);\\n    }\\n\\n    /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached.\\n    /// @param transactionId Transaction ID.\\n    function executeTransaction(uint transactionId)\\n        public\\n        ownerExists(msg.sender)\\n        confirmed(transactionId, msg.sender)\\n        notExecuted(transactionId)\\n    {\\n        Transaction storage txn = transactions[transactionId];\\n        bool _confirmed = isConfirmed(transactionId);\\n        if (_confirmed || txn.data.length == 0 \\u0026\\u0026 isUnderLimit(txn.value)) {\\n            txn.executed = true;\\n            if (!_confirmed)\\n                spentToday += txn.value;\\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\\n                Execution(transactionId);\\n            else {\\n                ExecutionFailure(transactionId);\\n                txn.executed = false;\\n                if (!_confirmed)\\n                    spentToday -= txn.value;\\n            }\\n        }\\n    }\\n\\n    /*\\n     * Internal functions\\n     */\\n    /// @dev Returns if amount is within daily limit and resets spentToday after one day.\\n    /// @param amount Amount to withdraw.\\n    /// @return Returns if amount is under daily limit.\\n    function isUnderLimit(uint amount)\\n        internal\\n        returns (bool)\\n    {\\n        if (now \\u003e lastDay + 24 hours) {\\n            lastDay = now;\\n            spentToday = 0;\\n        }\\n        if (spentToday + amount \\u003e dailyLimit || spentToday + amount \\u003c spentToday)\\n            return false;\\n        return true;\\n    }\\n\\n    /*\\n     * Web3 call functions\\n     */\\n    /// @dev Returns maximum withdraw amount.\\n    /// @return Returns amount.\\n    function calcMaxWithdraw()\\n        public\\n        constant\\n        returns (uint)\\n    {\\n        if (now \\u003e lastDay + 24 hours)\\n            return dailyLimit;\\n        if (dailyLimit \\u003c spentToday)\\n            return 0;\\n        return dailyLimit - spentToday;\\n    }\\n}\\n\"},\"MultiSigWalletWithERC1155TokenReceiver.sol\":{\"content\":\"pragma solidity ^0.4.15;\\n\\nimport \\\"./MultiSigWallet.sol\\\";\\n\\ncontract MultiSigWalletWithERC1155TokenReceiver is MultiSigWallet {\\n    /// @dev Contract constructor sets initial owners and required number of confirmations\\n    /// @param _owners List of initial owners.\\n    /// @param _required Number of required confirmations.\\n    function MultiSigWalletWithERC1155TokenReceiver(address[] _owners, uint _required)\\n        public\\n        MultiSigWallet(_owners, _required)\\n    {\\n    }\\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes _data) external returns(bytes4) {\\n        _operator;\\n        _from;\\n        _id;\\n        _value;\\n        _data;\\n        return bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    }\\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] _ids, uint256[] _values, bytes _data) external returns(bytes4) {\\n        _operator;\\n        _from;\\n        _ids;\\n        _values;\\n        _data;\\n        return bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"));\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"confirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcMaxWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionIds\",\"outputs\":[{\"name\":\"_transactionIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"name\":\"_confirmations\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dailyLimit\",\"type\":\"uint256\"}],\"name\":\"changeDailyLimit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spentToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_dailyLimit\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dailyLimit\",\"type\":\"uint256\"}],\"name\":\"DailyLimitChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Submission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"RequirementChange\",\"type\":\"event\"}]","ContractName":"MultiSigWalletWithDailyLimit","CompilerVersion":"v0.4.15+commit.8b45bddb","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000ef4c9177825ae2cf8b33141398aafe9db8d191990000000000000000000000009f921d280fcc94cee0bc8119370eb5bf620025a4","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://340fb0e538c32fc15ba1ccc0dd71815ae643702196a40ea413075264d577c714"}]}