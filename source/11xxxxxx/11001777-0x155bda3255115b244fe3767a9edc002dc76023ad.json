{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\n\n/**\n\nAuthor: CoFiX Core, https://cofix.io\nCommit hash: v0.9.3-0-gd2747b7\nRepository: https://github.com/Computable-Finance/CoFiX\nIssues: https://github.com/Computable-Finance/CoFiX/issues\n\n*/\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\n\n// \ninterface ICoFiXFactory {\n    // All pairs: {ETH <-> ERC20 Token}\n    event PairCreated(address indexed token, address pair, uint256);\n    event NewGovernance(address _new);\n    event NewController(address _new);\n    event NewFeeReceiver(address _new);\n    event NewVaultForLP(address _new);\n    event NewVaultForTrader(address _new);\n    event NewVaultForCNode(address _new);\n\n    /// @dev Create a new token pair for trading\n    /// @param  token the address of token to trade\n    /// @return pair the address of new token pair\n    function createPair(\n        address token\n        )\n        external\n        returns (address pair);\n\n    function getPair(address token) external view returns (address pair);\n    function allPairs(uint256) external view returns (address pair);\n    function allPairsLength() external view returns (uint256);\n\n    function getTradeMiningStatus(address token) external view returns (bool status);\n    function setTradeMiningStatus(address token, bool status) external;\n\n    function setGovernance(address _new) external;\n    function setController(address _new) external;\n    function setFeeReceiver(address _new) external;\n    function setVaultForLP(address _new) external;\n    function setVaultForTrader(address _new) external;\n    function setVaultForCNode(address _new) external;\n    function getController() external view returns (address controller);\n    function getFeeReceiver() external view returns (address feeReceiver);\n    function getVaultForLP() external view returns (address vaultForLP);\n    function getVaultForTrader() external view returns (address vaultForTrader);\n    function getVaultForCNode() external view returns (address vaultForCNode);\n}\n\n// \ninterface ICoFiXController {\n\n    event NewK(address token, int128 K, int128 sigma, uint256 T, uint256 ethAmount, uint256 erc20Amount, uint256 blockNum, uint256 tIdx, uint256 sigmaIdx, int128 K0);\n    event NewGovernance(address _new);\n    event NewOracle(address _priceOracle);\n    event NewKTable(address _kTable);\n    event NewTimespan(uint256 _timeSpan);\n    event NewKRefreshInterval(uint256 _interval);\n    event NewKLimit(int128 maxK0);\n    event NewGamma(int128 _gamma);\n    event NewTheta(address token, uint32 theta);\n\n    function addCaller(address caller) external;\n\n    function queryOracle(address token, uint8 op, bytes memory data) external payable returns (uint256 k, uint256 ethAmount, uint256 erc20Amount, uint256 blockNum, uint256 theta);\n}\n\n// \ninterface ICoFiXERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    // function name() external pure returns (string memory);\n    // function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n\n// \ninterface ICoFiXPair is ICoFiXERC20 {\n\n    struct OraclePrice {\n        uint256 ethAmount;\n        uint256 erc20Amount;\n        uint256 blockNum;\n        uint256 K;\n        uint256 theta;\n    }\n\n    // All pairs: {ETH <-> ERC20 Token}\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, address outToken, uint outAmount, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amountIn,\n        uint amountOut,\n        address outToken,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\n\n    function mint(address to) external payable returns (uint liquidity, uint oracleFeeChange);\n    function burn(address outToken, address to) external payable returns (uint amountOut, uint oracleFeeChange);\n    function swapWithExact(address outToken, address to) external payable returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[4] memory tradeInfo);\n    function swapForExact(address outToken, uint amountOutExact, address to) external payable returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[4] memory tradeInfo);\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address, string memory, string memory) external;\n}\n\n// \n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// \n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// \n// ERC20 token implementation, inherited by CoFiXPair contract, no owner or governance\ncontract CoFiXERC20 is ICoFiXERC20 {\n    using SafeMath for uint;\n\n    string public constant nameForDomain = 'CoFiX Pool Token';\n    uint8 public override constant decimals = 18;\n    uint  public override totalSupply;\n    mapping(address => uint) public override balanceOf;\n    mapping(address => mapping(address => uint)) public override allowance;\n\n    bytes32 public override DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public override constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public override nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() public {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(nameForDomain)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n        require(deadline >= block.timestamp, 'CERC20: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'CERC20: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}\n\n// \n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\n// \n// Pair contract for each trading pair, storing assets and handling settlement\n// No owner or governance\ncontract CoFiXPair is ICoFiXPair, CoFiXERC20 {\n    using SafeMath for uint;\n\n    enum CoFiX_OP { QUERY, MINT, BURN, SWAP_WITH_EXACT, SWAP_FOR_EXACT } // operations in CoFiX\n\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    uint256 constant public K_BASE = 1E8; // K\n    uint256 constant public NAVPS_BASE = 1E18; // NAVPS (Net Asset Value Per Share), need accuracy\n    uint256 constant public THETA_BASE = 1E8; // theta\n\n    string public name;\n    string public symbol;\n\n    address public override factory;\n    address public override token0; // WETH token\n    address public override token1; // any ERC20 token\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n\n    uint private unlocked = 1;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, address outToken, uint outAmount, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amountIn,\n        uint amountOut,\n        address outToken,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    modifier lock() {\n        require(unlocked == 1, \"CPair: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    constructor() public {\n        factory = msg.sender;\n    }\n\n    receive() external payable {}\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1, string memory _name, string memory _symbol) external override {\n        require(msg.sender == factory, \"CPair: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"CPair: TRANSFER_FAILED\");\n    }\n\n    // update reserves\n    function _update(uint balance0, uint balance1) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), \"CPair: OVERFLOW\");\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        emit Sync(reserve0, reserve1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external payable override lock returns (uint liquidity, uint oracleFeeChange) {\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        uint256 _ethBalanceBefore = address(this).balance;\n        { // scope for ethAmount/erc20Amount/blockNum to avoid stack too deep error\n            bytes memory data = abi.encode(msg.sender, to);\n            // query price\n            OraclePrice memory _op;\n            (_op.K, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.theta) = _queryOracle(_token1, CoFiX_OP.MINT, data);\n            uint256 navps = calcNAVPerShareForMint(_reserve0, _reserve1, _op);\n            liquidity = calcLiquidity(amount0, amount1, navps, _op);\n        }\n        oracleFeeChange = msg.value.sub(_ethBalanceBefore.sub(address(this).balance));\n\n        require(liquidity > 0, \"CPair: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1);\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address outToken, address to) external payable override lock returns (uint amountOut, uint oracleFeeChange) {\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        uint256 _ethBalanceBefore = address(this).balance;\n        uint256 fee;\n        {\n            bytes memory data = abi.encode(msg.sender, outToken, to);\n            // query price\n            OraclePrice memory _op;\n            (_op.K, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.theta) = _queryOracle(_token1, CoFiX_OP.BURN, data);\n            if (outToken == _token0) {\n                (amountOut, fee) = calcOutToken0ForBurn(liquidity, _op); // navps calculated\n            } else if (outToken == _token1) {\n                (amountOut, fee) = calcOutToken1ForBurn(liquidity, _op); // navps calculated\n            }  else {\n                revert(\"CPair: wrong outToken\");\n            }\n        }\n        oracleFeeChange = msg.value.sub(_ethBalanceBefore.sub(address(this).balance));\n\n        require(amountOut > 0, \"CPair: INSUFFICIENT_LIQUIDITY_BURNED\");\n        _burn(address(this), liquidity);\n        _safeTransfer(outToken, to, amountOut);\n        if (fee > 0) {\n            if (ICoFiXFactory(factory).getTradeMiningStatus(_token1)) {\n                // only set fee to protocol feeReceiver when trade mining is enabled for this trading pair\n                _safeTransfer(_token0, ICoFiXFactory(factory).getFeeReceiver(), fee); // transfer fee to protocol feeReceiver\n            }\n        }\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1);\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n\n        emit Burn(msg.sender, outToken, amountOut, to);\n    }\n\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swapWithExact(address outToken, address to)\n        external\n        payable override lock\n        returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[4] memory tradeInfo)\n    {\n        // tradeInfo[0]: thetaFee, tradeInfo[1]: x, tradeInfo[2]: y, tradeInfo[3]: navps\n        address _token0 = token0;\n        address _token1 = token1;\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n\n        // uint256 fee;\n        { // scope for ethAmount/erc20Amount/blockNum to avoid stack too deep error\n            uint256 _ethBalanceBefore = address(this).balance;\n            (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n            // calc amountIn\n            if (outToken == _token1) {\n                amountIn = balance0.sub(_reserve0);\n                require(amountIn > 0, \"CPair: wrong amount0In\");\n            } else if (outToken == _token0) {\n                amountIn = balance1.sub(_reserve1);\n                require(amountIn > 0, \"CPair: wrong amount1In\");\n            } else {\n                revert(\"CPair: wrong outToken\");\n            }\n            bytes memory data = abi.encode(msg.sender, outToken, to, amountIn);\n            // query price\n            OraclePrice memory _op;\n            (_op.K, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.theta) = _queryOracle(_token1, CoFiX_OP.SWAP_WITH_EXACT, data);\n            if (outToken == _token1) {\n                (amountOut, tradeInfo[0]) = calcOutToken1(amountIn, _op);\n                tradeInfo[1] = _reserve0; // swap token0 for token1 out\n                tradeInfo[2] = uint256(_reserve1).mul(_op.ethAmount).div(_op.erc20Amount); // _reserve1 value as _reserve0\n            } else if (outToken == _token0) {\n                (amountOut, tradeInfo[0]) = calcOutToken0(amountIn, _op);\n                tradeInfo[1] = uint256(_reserve1).mul(_op.ethAmount).div(_op.erc20Amount); // _reserve1 value as _reserve0\n                tradeInfo[2] = _reserve0; // swap token1 for token0 out\n            }\n            oracleFeeChange = msg.value.sub(_ethBalanceBefore.sub(address(this).balance));\n            tradeInfo[3] = calcNAVPerShare(_reserve0, _reserve1, _op);\n        }\n        \n        require(to != _token0 && to != _token1, \"CPair: INVALID_TO\");\n\n        _safeTransfer(outToken, to, amountOut); // optimistically transfer tokens\n        if (tradeInfo[0] > 0) {\n            if (ICoFiXFactory(factory).getTradeMiningStatus(_token1)) {\n                // only set fee to protocol feeReceiver when trade mining is enabled for this trading pair\n                _safeTransfer(_token0, ICoFiXFactory(factory).getFeeReceiver(), tradeInfo[0]); // transfer fee to protocol feeReceiver\n            } else {\n                tradeInfo[0] = 0; // so router won't go into the trade mining logic (reduce one more call gas cost)\n            }\n        }\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1);\n        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n\n        emit Swap(msg.sender, amountIn, amountOut, outToken, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swapForExact(address outToken, uint amountOutExact, address to)\n        external\n        payable override lock\n        returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[4] memory tradeInfo)\n    {\n        // tradeInfo[0]: thetaFee, tradeInfo[1]: x, tradeInfo[2]: y, tradeInfo[3]: navps\n        address _token0 = token0;\n        address _token1 = token1;\n        OraclePrice memory _op;\n\n        // uint256 fee;\n\n        { // scope for ethAmount/erc20Amount/blockNum to avoid stack too deep error\n            uint256 _ethBalanceBefore = address(this).balance;\n            bytes memory data = abi.encode(msg.sender, outToken, amountOutExact, to);\n            // query price\n            (_op.K, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.theta) = _queryOracle(_token1, CoFiX_OP.SWAP_FOR_EXACT, data);\n            oracleFeeChange = msg.value.sub(_ethBalanceBefore.sub(address(this).balance));\n        }\n\n        { // calc and check amountIn, also outToken\n            uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n            uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n            (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n     \n            if (outToken == _token1) {\n                amountIn = balance0.sub(_reserve0);\n                require(amountIn > 0, \"CPair: wrong amount0In\"); // for different revert reason\n                tradeInfo[1] = _reserve0; // swap token0 for token1 out\n                tradeInfo[2] = uint256(_reserve1).mul(_op.ethAmount).div(_op.erc20Amount); // _reserve1 value as _reserve0\n            } else if (outToken == _token0) {\n                amountIn = balance1.sub(_reserve1);\n                require(amountIn > 0, \"CPair: wrong amount1In\"); // for different revert reason\n                tradeInfo[1] = uint256(_reserve1).mul(_op.ethAmount).div(_op.erc20Amount); // _reserve1 value as _reserve0\n                tradeInfo[2] = _reserve0; // swap token1 for token0 out\n            } else {\n                revert(\"CPair: wrong outToken\");\n            }\n            tradeInfo[3] = calcNAVPerShare(_reserve0, _reserve1, _op);\n        }\n\n        { // split with branch upbove to make code more clear\n            uint _amountInNeeded;\n            uint _amountInLeft;\n            if (outToken == _token1) {\n                (_amountInNeeded, tradeInfo[0]) = calcInNeededToken0(amountOutExact, _op);\n                require(_amountInNeeded <= amountIn, \"CPair: insufficient amount0In\"); // for clear revert reason\n                _amountInLeft = amountIn.sub(_amountInNeeded);\n                if (_amountInLeft > 0) {\n                    _safeTransfer(_token0, to, _amountInLeft); // send back the amount0 token change\n                }\n            } else if (outToken == _token0) {\n                (_amountInNeeded, tradeInfo[0]) = calcInNeededToken1(amountOutExact, _op);\n                require(_amountInNeeded <= amountIn, \"CPair: insufficient wrong amount1In\"); // for clear revert reason\n                _amountInLeft = amountIn.sub(_amountInNeeded);\n                if (_amountInLeft > 0) {\n                    _safeTransfer(_token1, to, _amountInLeft); // send back the amount1 token change\n                }\n            }\n            require(_amountInNeeded > 0, \"CPair: wrong amountIn needed\");\n        }\n        \n        {\n            require(to != _token0 && to != _token1, \"CPair: INVALID_TO\");\n\n            amountOut = amountOutExact;\n            _safeTransfer(outToken, to, amountOut); // optimistically transfer tokens\n            if (tradeInfo[0] > 0) {\n                if (ICoFiXFactory(factory).getTradeMiningStatus(_token1)) {\n                    // only set fee to protocol feeReceiver when trade mining is enabled for this trading pair\n                    _safeTransfer(_token0, ICoFiXFactory(factory).getFeeReceiver(), tradeInfo[0]); // transfer fee to protocol feeReceiver\n                } else {\n                    tradeInfo[0] = 0; // so router won't go into the trade mining logic (reduce one more call gas cost)\n                }\n            }\n            uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n            uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n\n            _update(balance0, balance1);\n            if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n        }\n\n        emit Swap(msg.sender, amountIn, amountOut, outToken, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external override lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external override lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)));\n    }\n\n    // calc Net Asset Value Per Share for mint\n    // use it in this contract, for optimized gas usage\n    function calcNAVPerShareForMint(uint256 balance0, uint256 balance1, OraclePrice memory _op) public view returns (uint256 navps) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            navps = NAVPS_BASE;\n        } else {\n            /*\n            N_{p} &= (A_{u}/P_{s}^{'} + A_{e})/S \\\\\\\\\n                  &= (A_{u}/(P * (1 - K)) + A_{e})/S \\\\\\\\\n                  &= (\\frac{A_{u}}{\\frac{erc20Amount}{ethAmount} * \\frac{(k_{BASE} - k)}{(k_{BASE})}} + A_{e})/S \\\\\\\\\n                  &= (\\frac{A_{u}*ethAmount*k_{BASE}}{erc20Amount*(k_{BASE} - k)}+ A_{e}) / S \\\\\\\\\n                  &= (A_{u}*ethAmount*k_{BASE}+ A_{e}*erc20Amount*(k_{BASE} - k)) / S / (erc20Amount*(k_{BASE} - k)) \\\\\\\\\n            N_{p} &= NAVPS_{BASE}*(A_{u}*ethAmount*k_{BASE}+ A_{e}*erc20Amount*(k_{BASE} - k)) / S / (erc20Amount*(k_{BASE} - k)) \\\\\\\\\n            // navps = NAVPS_BASE * ( (balance1*_op.ethAmount*K_BASE) + (balance0*_op.erc20Amount*(K_BASE-_op.K)) ) / _totalSupply / _op.erc20Amount / (K_BASE-_op.K);\n            */\n            uint256 kbaseSubK = K_BASE.sub(_op.K);\n            uint256 balance1MulEthKbase = balance1.mul(_op.ethAmount).mul(K_BASE);\n            uint256 balance0MulErcKbsk = balance0.mul(_op.erc20Amount).mul(kbaseSubK);\n            navps = NAVPS_BASE.mul( (balance1MulEthKbase).add(balance0MulErcKbsk) ).div(_totalSupply).div(_op.erc20Amount).div(kbaseSubK);\n        }\n    }\n\n    // calc Net Asset Value Per Share for burn\n    // use it in this contract, for optimized gas usage\n    function calcNAVPerShareForBurn(uint256 balance0, uint256 balance1, OraclePrice memory _op) public view returns (uint256 navps) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            navps = NAVPS_BASE;\n        } else {\n            /*\n            N_{p}^{'} &= (A_{u}/P_{b}^{'} + A_{e})/S \\\\\\\\\n                      &= (A_{u}/(P * (1 + K)) + A_{e})/S \\\\\\\\\n                      &= (\\frac{A_{u}}{\\frac{erc20Amount}{ethAmount} * \\frac{(k_{BASE} + k)}{(k_{BASE})}} + A_{e})/S \\\\\\\\\n                      &= (\\frac{A_{u}*ethAmount*k_{BASE}}{erc20Amount*(k_{BASE} + k)}+ A_{e}) / S \\\\\\\\\n                      &= (A_{u}*ethAmount*k_{BASE}+ A_{e}*erc20Amount*(k_{BASE} + k)) / S / (erc20Amount*(k_{BASE} + k)) \\\\\\\\\n            N_{p}^{'} &= NAVPS_{BASE}*(A_{u}*ethAmount*k_{BASE}+ A_{e}*erc20Amount*(k_{BASE} + k)) / S / (erc20Amount*(k_{BASE} + k)) \\\\\\\\\n            // navps = NAVPS_BASE * ( (balance1*_op.ethAmount*K_BASE) + (balance0*_op.erc20Amount*(K_BASE+_op.K)) ) / _totalSupply / _op.erc20Amount / (K_BASE+_op.K);\n            */\n            uint256 kbaseAddK = K_BASE.add(_op.K);\n            uint256 balance1MulEthKbase = balance1.mul(_op.ethAmount).mul(K_BASE);\n            uint256 balance0MulErcKbsk = balance0.mul(_op.erc20Amount).mul(kbaseAddK);\n            navps = NAVPS_BASE.mul( (balance1MulEthKbase).add(balance0MulErcKbsk) ).div(_totalSupply).div(_op.erc20Amount).div(kbaseAddK);\n        }\n    }\n\n    // calc Net Asset Value Per Share (no K)\n    // use it in this contract, for optimized gas usage\n    function calcNAVPerShare(uint256 balance0, uint256 balance1, OraclePrice memory _op) public view returns (uint256 navps) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            navps = NAVPS_BASE;\n        } else {\n            /*\n            N_{p}^{'} &= (A_{u}/P + A_{e})/S \\\\\\\\\n                      &= (\\frac{A_{u}}{\\frac{erc20Amount}{ethAmount}} + A_{e})/S \\\\\\\\\n                      &= (\\frac{A_{u}*ethAmount}{erc20Amount}+ A_{e}) / S \\\\\\\\\n                      &= (A_{u}*ethAmount+ A_{e}*erc20Amount) / S / (erc20Amount) \\\\\\\\\n            N_{p}^{'} &= NAVPS_{BASE}*(A_{u}*ethAmount+ A_{e}*erc20Amount) / S / (erc20Amount) \\\\\\\\\n            // navps = NAVPS_BASE * ( (balance1*_op.ethAmount) + (balance0*_op.erc20Amount) ) / _totalSupply / _op.erc20Amount;\n            */\n            uint256 balance1MulEth = balance1.mul(_op.ethAmount);\n            uint256 balance0MulErc = balance0.mul(_op.erc20Amount);\n            navps = NAVPS_BASE.mul( (balance1MulEth).add(balance0MulErc) ).div(_totalSupply).div(_op.erc20Amount);\n        }\n    }\n\n    // use it in this contract, for optimized gas usage\n    function calcLiquidity(uint256 amount0, uint256 amount1, uint256 navps, OraclePrice memory _op) public pure returns (uint256 liquidity) {\n        /*\n        s_{1} &= a / (N_{p} / NAVPS_{BASE}) \\\\\\\\\n              &= a * NAVPS_{BASE} / N_{p} \\\\\\\\\n        s_{2} &= b / P_{b}^{'} / (N_{p} / NAVPS_{BASE}) \\\\\\\\\n              &= b / (N_{p} / NAVPS_{BASE}) / P_{b}^{'} \\\\\\\\\n              &= b * NAVPS_{BASE} / N_{p} / P_{b}^{'} \\\\\\\\\n              &= b * NAVPS_{BASE} / N_{p} / (\\frac{erc20Amount}{ethAmount} * \\frac{(k_{BASE} + k)}{(k_{BASE})}) \\\\\\\\\n              &= b * NAVPS_{BASE} * ethAmount * k_{BASE} / N_{p} / (erc20Amount * (k_{BASE} + k))\n        s &= s_1 + s_2 \\\\\\\\\n          &= a * NAVPS_{BASE} / N_{p} + b * NAVPS_{BASE} / N_{p} / P_{b}^{'} \\\\\\\\\n          &= a * NAVPS_{BASE} / N_{p} + b * NAVPS_{BASE} * ethAmount * k_{BASE} / N_{p} / (erc20Amount * (k_{BASE} + k)) \\\\\\\\\n        // liquidity = (amount0 * NAVPS_BASE / navps) + (amount1 * NAVPS_BASE * _op.ethAmount * K_BASE / navps / _op.erc20Amount / (K_BASE + _op.K));\n        */\n        uint256 amnt0MulNbaseDivN = amount0.mul(NAVPS_BASE).div(navps);\n        uint256 amnt1MulNbaseEthKbase = amount1.mul(NAVPS_BASE).mul(_op.ethAmount).mul(K_BASE);\n        liquidity = ( amnt0MulNbaseDivN ).add( amnt1MulNbaseEthKbase.div(navps).div(_op.erc20Amount).div(K_BASE.add(_op.K)) );\n    }\n\n    // get Net Asset Value Per Share\n    // only for read, could cost more gas if use it directly in contract\n    function getNAVPerShareForMint(OraclePrice memory _op) public view returns (uint256 navps) {\n        return calcNAVPerShareForMint(reserve0, reserve1, _op);\n    }\n\n    // get Net Asset Value Per Share\n    // only for read, could cost more gas if use it directly in contract\n    function getNAVPerShareForBurn(OraclePrice memory _op) external view returns (uint256 navps) {\n        return calcNAVPerShareForBurn(reserve0, reserve1, _op);\n    }\n\n    // get estimated liquidity amount (it represents the amount of pool tokens will be minted if someone provide liquidity to the pool)\n    // only for read, could cost more gas if use it directly in contract\n    function getLiquidity(uint256 amount0, uint256 amount1, OraclePrice memory _op) external view returns (uint256 liquidity) {\n        uint256 navps = getNAVPerShareForMint(_op);\n        return calcLiquidity(amount0, amount1, navps, _op);\n    }\n\n    // calc amountOut for token0 (WETH) when send liquidity token to pool for burning\n    function calcOutToken0ForBurn(uint256 liquidity, OraclePrice memory _op) public view returns (uint256 amountOut, uint256 fee) {\n        /*\n        e &= c * (N_{p}^{'} / NAVPS_{BASE}) * (THETA_{BASE} - \\theta)/THETA_{BASE} \\\\\\\\\n          &= c * \\frac{N_{p}^{'}}{NAVPS_{BASE}} * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n          &= c * N_{p}^{'} * (THETA_{BASE} - \\theta) / NAVPS_{BASE} / THETA_{BASE} \\\\\\\\\n        // amountOut = liquidity * navps * (THETA_BASE - _op.theta) / NAVPS_BASE / THETA_BASE;\n        */\n        uint256 navps = calcNAVPerShareForBurn(reserve0, reserve1, _op);\n        amountOut = liquidity.mul(navps).mul(THETA_BASE.sub(_op.theta)).div(NAVPS_BASE).div(THETA_BASE);\n        if (_op.theta != 0) {\n            // fee = liquidity * navps * (_op.theta) / NAVPS_BASE / THETA_BASE;\n            fee = liquidity.mul(navps).mul(_op.theta).div(NAVPS_BASE).div(THETA_BASE);\n        }\n        return (amountOut, fee);\n    }\n\n\n    // calc amountOut for token1 (ERC20 token) when send liquidity token to pool for burning\n    function calcOutToken1ForBurn(uint256 liquidity, OraclePrice memory _op) public view returns (uint256 amountOut, uint256 fee) {\n        /*\n        u &= c * (N_{p}^{'} / NAVPS_{BASE}) * P_{s}^{'} * (THETA_{BASE} - \\theta)/THETA_{BASE} \\\\\\\\\n          &= c * \\frac{N_{p}^{'}}{NAVPS_{BASE}} * \\frac{erc20Amount}{ethAmount} * \\frac{(k_{BASE} - k)}{(k_{BASE})} * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n          &= \\frac{c * N_{p}^{'} * erc20Amount * (k_{BASE} - k) * (THETA_{BASE} - \\theta)}{NAVPS_{BASE}*ethAmount*k_{BASE}*THETA_{BASE}}\n        // amountOut = liquidity * navps * _op.erc20Amount * (K_BASE - _op.K) * (THETA_BASE - _op.theta) / NAVPS_BASE / _op.ethAmount / K_BASE / THETA_BASE;\n        */\n        uint256 navps = calcNAVPerShareForBurn(reserve0, reserve1, _op);\n        uint256 liqMulMany = liquidity.mul(navps).mul(_op.erc20Amount).mul(K_BASE.sub(_op.K)).mul(THETA_BASE.sub(_op.theta));\n        amountOut = liqMulMany.div(NAVPS_BASE).div(_op.ethAmount).div(K_BASE).div(THETA_BASE);\n        if (_op.theta != 0) {\n            // fee = liquidity * navps * (_op.theta) / NAVPS_BASE / THETA_BASE;\n            fee = liquidity.mul(navps).mul(_op.theta).div(NAVPS_BASE).div(THETA_BASE);\n        }\n        return (amountOut, fee);\n    }\n\n    // get estimated amountOut for token0 (WETH) when swapWithExact\n    function calcOutToken0(uint256 amountIn, OraclePrice memory _op) public pure returns (uint256 amountOut, uint256 fee) {\n        /*\n        x &= (a/P_{b}^{'})*\\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n          &= a / (\\frac{erc20Amount}{ethAmount} * \\frac{(k_{BASE} + k)}{(k_{BASE})}) * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n          &= \\frac{a*ethAmount*k_{BASE}}{erc20Amount*(k_{BASE} + k)} * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n          &= \\frac{a*ethAmount*k_{BASE}*(THETA_{BASE} - \\theta)}{erc20Amount*(k_{BASE} + k)*THETA_{BASE}} \\\\\\\\\n        // amountOut = amountIn * _op.ethAmount * K_BASE * (THETA_BASE - _op.theta) / _op.erc20Amount / (K_BASE + _op.K) / THETA_BASE;\n        */\n        amountOut = amountIn.mul(_op.ethAmount).mul(K_BASE).mul(THETA_BASE.sub(_op.theta)).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\n        if (_op.theta != 0) {\n            // fee = amountIn * _op.ethAmount * K_BASE * (_op.theta) / _op.erc20Amount / (K_BASE + _op.K) / THETA_BASE;\n            fee = amountIn.mul(_op.ethAmount).mul(K_BASE).mul(_op.theta).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\n        }\n        return (amountOut, fee);\n    }\n\n    // get estimated amountOut for token1 (ERC20 token) when swapWithExact\n    function calcOutToken1(uint256 amountIn, OraclePrice memory _op) public pure returns (uint256 amountOut, uint256 fee) {\n        /*\n        y &= b*P_{s}^{'}*\\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n          &= b * \\frac{erc20Amount}{ethAmount} * \\frac{(k_{BASE} - k)}{(k_{BASE})} * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n          &= \\frac{b*erc20Amount*(k_{BASE} - k)*(THETA_{BASE} - \\theta)}{ethAmount*k_{BASE}*THETA_{BASE}} \\\\\\\\\n        // amountOut = amountIn * _op.erc20Amount * (K_BASE - _op.K) * (THETA_BASE - _op.theta) / _op.ethAmount / K_BASE / THETA_BASE;\n        */\n        amountOut = amountIn.mul(_op.erc20Amount).mul(K_BASE.sub(_op.K)).mul(THETA_BASE.sub(_op.theta)).div(_op.ethAmount).div(K_BASE).div(THETA_BASE);\n        if (_op.theta != 0) {\n            // fee = amountIn * _op.theta / THETA_BASE;\n            fee = amountIn.mul(_op.theta).div(THETA_BASE);\n        }\n        return (amountOut, fee);\n    }\n\n    // get estimate amountInNeeded for token0 (WETH) when swapForExact\n    function calcInNeededToken0(uint256 amountOut, OraclePrice memory _op) public pure returns (uint256 amountInNeeded, uint256 fee) {\n        // inverse of calcOutToken1\n        // amountOut = amountIn.mul(_op.erc20Amount).mul(K_BASE.sub(_op.K)).mul(THETA_BASE.sub(_op.theta)).div(_op.ethAmount).div(K_BASE).div(THETA_BASE);\n        amountInNeeded = amountOut.mul(_op.ethAmount).mul(K_BASE).mul(THETA_BASE).div(_op.erc20Amount).div(K_BASE.sub(_op.K)).div(THETA_BASE.sub(_op.theta));\n        if (_op.theta != 0) {\n            // fee = amountIn * _op.theta / THETA_BASE;\n            fee = amountInNeeded.mul(_op.theta).div(THETA_BASE);\n        }\n        return (amountInNeeded, fee);\n    }\n\n    // get estimate amountInNeeded for token1 (ERC20 token) when swapForExact\n    function calcInNeededToken1(uint256 amountOut, OraclePrice memory _op) public pure returns (uint256 amountInNeeded, uint256 fee) {\n        // inverse of calcOutToken0\n        // amountOut = amountIn.mul(_op.ethAmount).mul(K_BASE).mul(THETA_BASE.sub(_op.theta)).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\n        amountInNeeded = amountOut.mul(_op.erc20Amount).mul(K_BASE.add(_op.K)).mul(THETA_BASE).div(_op.ethAmount).div(K_BASE).div(THETA_BASE.sub(_op.theta));\n        if (_op.theta != 0) {\n            // fee = amountIn * _op.ethAmount * K_BASE * (_op.theta) / _op.erc20Amount / (K_BASE + _op.K) / THETA_BASE;\n            fee = amountInNeeded.mul(_op.ethAmount).mul(K_BASE).mul(_op.theta).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\n        }\n        return (amountInNeeded, fee);\n    }\n\n    function _queryOracle(address token, CoFiX_OP op, bytes memory data) internal returns (uint256, uint256, uint256, uint256, uint256) {\n        return ICoFiXController(ICoFiXFactory(factory).getController()).queryOracle{value: msg.value}(token, uint8(op), data);\n    }\n\n}\n\n// \n// Factory of CoFiX to create new CoFiXPair contract when new pair is created, managed by governance\n// Governance role of this contract should be the `Timelock` contract, which is further managed by a multisig contract\ncontract CoFiXFactory is ICoFiXFactory {\n\n    string constant internal pairNamePrefix = \"XToken \";\n    string constant internal pairSymbolPrefix = \"XT-\";\n\n    mapping(address => address) public override getPair;\n    address[] public override allPairs;\n    address public immutable WETH;\n    address public governance;\n    address public controller;\n    address public feeReceiver;\n\n    address public vaultForLP;\n    address public vaultForTrader;\n    address public vaultForCNode;\n\n    mapping (address => bool) public override getTradeMiningStatus; // token -> bool\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"CFactory: !governance\");\n        _;\n    }\n\n    constructor(address _WETH) public {\n        governance = msg.sender;\n        feeReceiver = msg.sender; // set feeReceiver to a feeReceiver contract later\n        WETH = _WETH;\n    }\n\n    function allPairsLength() external override view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function pairCodeHash() external pure returns (bytes32) {\n        return keccak256(type(CoFiXPair).creationCode);\n    }\n\n    function createPair(address token) external override returns (address pair) {\n        require(token != address(0), 'CFactory: ZERO_ADDRESS');\n        require(getPair[token] == address(0), 'CFactory: PAIR_EXISTS');\n        bytes memory bytecode = type(CoFiXPair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        require(pair != address(0), \"CFactory: Failed on deploy\");\n\n        getPair[token] = pair;\n        allPairs.push(pair);\n\n        uint256 pairLen = allPairs.length;\n        string memory _idx = uint2str(pairLen);\n        string memory _name = append(pairNamePrefix, _idx);\n        string memory _symbol = append(pairSymbolPrefix, _idx);\n        ICoFiXPair(pair).initialize(WETH, token, _name, _symbol);\n\n        ICoFiXController(controller).addCaller(pair);\n        emit PairCreated(token, pair, pairLen);\n    }\n\n    function setGovernance(address _new) external override onlyGovernance {\n        require(_new != address(0), \"CFactory: zero addr\");\n        require(_new != governance, \"CFactory: same addr\");\n        governance = _new;\n        emit NewGovernance(_new);\n    }\n    \n    function setController(address _new) external override onlyGovernance {\n        require(_new != address(0), \"CFactory: zero addr\");\n        require(_new != controller, \"CFactory: same addr\");\n        controller = _new;\n        emit NewController(_new);\n    }\n\n    function setFeeReceiver(address _new) external override onlyGovernance {\n        require(_new != address(0), \"CFactory: zero addr\");\n        require(_new != feeReceiver, \"CFactory: same addr\");\n        feeReceiver = _new;\n        emit NewGovernance(_new);\n    }\n\n    function setVaultForLP(address _new) external override onlyGovernance {\n        require(_new != address(0), \"CFactory: zero addr\");\n        require(_new != vaultForLP, \"CFactory: same addr\");\n        vaultForLP = _new;\n        emit NewVaultForLP(_new);\n    }\n\n    function setVaultForTrader(address _new) external override onlyGovernance {\n        require(_new != address(0), \"CFactory: zero addr\");\n        require(_new != vaultForTrader, \"CFactory: same addr\");\n        vaultForTrader = _new;\n        emit NewVaultForTrader(_new);\n    }\n\n    function setVaultForCNode(address _new) external override onlyGovernance {\n        require(_new != address(0), \"CFactory: zero addr\");\n        require(_new != vaultForCNode, \"CFactory: same addr\");\n        vaultForCNode = _new;\n        emit NewVaultForCNode(_new);\n    }\n\n    function setTradeMiningStatus(address token, bool status) external override onlyGovernance {\n        getTradeMiningStatus[token] = status;\n    }\n\n    function getController() external view override returns (address) {\n        return controller;\n    }\n\n    function getFeeReceiver() external view override returns (address) {\n        return feeReceiver;\n    }\n\n    function getVaultForLP() external view override returns (address) {\n        return vaultForLP;\n    }\n\n    function getVaultForTrader() external view override returns (address) {\n        return vaultForTrader;\n    }\n\n    function getVaultForCNode() external view override returns (address) {\n        return vaultForCNode;\n    }\n\n    // internal helpers\n\n    function append(string memory a, string memory b) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n\n    function uint2str(uint _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + _i % 10));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"NewController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"NewFeeReceiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"NewGovernance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"NewVaultForCNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"NewVaultForLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"NewVaultForTrader\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getTradeMiningStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultForCNode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultForLP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultForTrader\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairCodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setTradeMiningStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setVaultForCNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setVaultForLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setVaultForTrader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultForCNode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultForLP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultForTrader\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CoFiXFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}