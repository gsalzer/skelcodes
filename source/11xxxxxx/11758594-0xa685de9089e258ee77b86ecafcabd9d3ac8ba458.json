{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NISTToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.6;\\r\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\r\\nimport { SafeERC20, SafeMath, IERC20, Address, NitroStaking, UniswapV2Library, IKeep3rV1Mini } from \\\"./NitroStaking.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\r\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\r\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\r\\nimport { UniswapV2OracleLibrary , FixedPoint } from \\\"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\\\";\\r\\n\\r\\n// @dev DegenerateGameTheorist\\r\\ncontract NitroStakingToken is ERC20, NitroStaking, Ownable, Pausable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /// @notice Scale factor for NITRO calculations\\r\\n    uint256 public constant scaleFactor = 1e18;\\r\\n\\r\\n    /// @notice Total supply\\r\\n    uint256 public constant total_supply = 2049 ether;\\r\\n\\r\\n    /// @notice uniswap listing rate\\r\\n    uint256 public constant INITIAL_TOKENS_PER_ETH = 2 * 1 ether;\\r\\n\\r\\n    /// @dev The minimum amount of time an address must be above minimumRewardBalance to receive rewards (1 hour in seconds)\\r\\n    uint256 minimumBalanceHoldingTime = 1 hours;\\r\\n\\r\\n    /// @notice self-explanatory\\r\\n    address public constant uniswapV2Factory = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\\r\\n\\r\\n    address public initialDistributionAddress;\\r\\n\\r\\n    address public presaleContractAddress;\\r\\n\\r\\n    uint256 public presaleInitFunds;\\r\\n\\r\\n    /// @notice liquidity sources (e.g. UniswapV2Router)\\r\\n    mapping(address => bool) public whitelistedSenders;\\r\\n\\r\\n    /// @notice exchange addresses (tokens sent here will count as sell orders in NITRO Protocol)\\r\\n    mapping(address => bool) public exchangeAddresses;\\r\\n\\r\\n    /// @notice uniswap pair for LAMBO/ETH\\r\\n    address public uniswapPair;\\r\\n\\r\\n    /// @notice Whether or not this token is first in uniswap LAMBO<>ETH pair\\r\\n    bool public isThisToken0;\\r\\n\\r\\n    /// @notice last TWAP update time (Short calculation)\\r\\n    uint32 public blockTimestampLast;\\r\\n\\r\\n    /// @notice last TWAP cumulative price (Short calculation)\\r\\n    uint256 public priceCumulativeLast;\\r\\n\\r\\n    /// @notice last TWAP average price (Short calculation)\\r\\n    uint256 public priceAverageLast;\\r\\n\\r\\n    /// @notice last TWAP update time\\r\\n    uint32 public blockTimestampLastLong;\\r\\n\\r\\n    /// @notice last TWAP cumulative price\\r\\n    uint256 public priceCumulativeLastLong;\\r\\n\\r\\n    /// @notice last TWAP average price\\r\\n    uint256 public priceAverageLastLong;\\r\\n\\r\\n    /// @notice TWAP min delta (48-hour)\\r\\n    uint256 public minDeltaTwapLong;\\r\\n\\r\\n    /// @notice TWAP min delta (Short)\\r\\n    uint256 public minDeltaTwapShort;\\r\\n\\r\\n    /// @notice The previous calculated Nitro value for buyers\\r\\n    uint256 public lastBuyNitroPercent;\\r\\n\\r\\n    /// @notice The previous calculated Nitro value for sellers\\r\\n    uint256 public lastSellNitroPercent;\\r\\n\\r\\n    //Lets us check to see if the user account is moving lambo at this address' request\\r\\n    address public uniswapv2RouterAddress;\\r\\n\\r\\n    //The contract describing the LP tokens users can stake\\r\\n    IERC20 public LPTokenContract;\\r\\n\\r\\n    //Emittable Events\\r\\n\\r\\n    event TwapUpdated(uint256 priceCumulativeLast, uint256 blockTimestampLast, uint256 priceAverageLast);\\r\\n\\r\\n    event LongTwapUpdated(uint256 priceCumulativeLastLong, uint256 blockTimestampLastLong, uint256 priceAverageLastLong);\\r\\n\\r\\n    event MaxSellRemovalUpdated(uint256 new_MSR);\\r\\n\\r\\n    event MaxBuyBonusUpdated(uint256 new_MBB);\\r\\n\\r\\n    event ExchangeListUpdated(address exchangeAddress, bool isExchange);\\r\\n\\r\\n//                  ------------------ Contract Start Functions ---------------------                //\\r\\n    constructor(\\r\\n        uint256 _minDeltaTwapLong,\\r\\n        uint256 _minDeltaTwapShort,\\r\\n        address rlrToken\\r\\n    )\\r\\n    public\\r\\n    Ownable()\\r\\n    ERC20(\\\"Nitro Staking Token\\\", \\\"NIST\\\")\\r\\n    {\\r\\n        previousRewardDistributionTimestamp = block.timestamp;\\r\\n        setMinDeltaTwap(_minDeltaTwapLong, _minDeltaTwapShort);\\r\\n        _setMaxBuyBonusPercentage(5*scaleFactor.div(100));\\r\\n        _changeMaxSellRemoval(10*scaleFactor.div(100));\\r\\n        initialDistributionAddress = owner(); //The contract owner handles all initial distribution, except for presale\\r\\n        _distributeTokens();\\r\\n        initPair();\\r\\n        _pause();\\r\\n        setUniswapRouterAddress(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        //Approve uniswap router to spend nist\\r\\n        _approve(address(this), uniswapv2RouterAddress, uint256(-1));\\r\\n        whitelistedSenders[address(this)] = true;//Whitelist the contract itself to swap to eth without burn\\r\\n        RLR = IKeep3rV1Mini(rlrToken);\\r\\n    }\\r\\n\\r\\n    modifier whenNotPausedOrInitialDistribution(address tokensender) { //Only used on transfer function\\r\\n        require(!paused() || msg.sender == initialDistributionAddress || _isWhitelistedSender(msg.sender) || (msg.sender == uniswapv2RouterAddress && tokensender == owner()), \\\"!paused && !initialDistributionAddress !InitialLiquidityProvider\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyInitialDistributionAddress() { //Only used to initialize twap\\r\\n        require(msg.sender == initialDistributionAddress, \\\"!initialDistributionAddress\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _distributeTokens()\\r\\n    internal\\r\\n    {\\r\\n        _mint(address(this), total_supply);\\r\\n        setWhitelistedSender(address(this), true);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Initialize the uniswap pair address to predict it and define it as an exchange address.\\r\\n     */\\r\\n    function initPair() internal {\\r\\n        // Create a uniswap pair for this new token\\r\\n        uniswapPair = IUniswapV2Factory(uniswapV2Factory).createPair(address(this), router.WETH());\\r\\n        setExchangeAddress(uniswapPair, true);\\r\\n        (address token0,) = UniswapV2Library.sortTokens(address(this), router.WETH());\\r\\n        isThisToken0 = (token0 == address(this));\\r\\n    }\\r\\n/*\\r\\n    function _initializePair() internal {\\r\\n        (address token0, address token1) = UniswapV2Library.sortTokens(address(this), address(WETH));\\r\\n        isThisToken0 = (token0 == address(this));\\r\\n        uniswapPair = UniswapV2Library.pairFor(uniswapV2Factory, token0, token1);\\r\\n        setExchangeAddress(uniswapPair, true);\\r\\n    }\\r\\n*/\\r\\n    function setUniswapRouterAddress(address newUniRouterAddy) public onlyOwner {\\r\\n        uniswapv2RouterAddress = newUniRouterAddy;\\r\\n    }\\r\\n\\r\\n    function setLiquidityTokenContract(address LPTokenAddy) public onlyOwner {\\r\\n        LPTokenContract = IERC20(LPTokenAddy);\\r\\n    }\\r\\n\\r\\n//////////////////---------------- Administrative Functions ----------------///////////////\\r\\n    /**\\r\\n     * @dev Unpauses all transfers from the distribution address (initial liquidity pool).\\r\\n     */\\r\\n    function unpause() external virtual onlyOwner {\\r\\n        super._unpause();\\r\\n    }\\r\\n\\r\\n//////////////////----------------Modify Nitro Protocol Variables----------------///////////////\\r\\n\\r\\n    //Modify the maxSellRemoval\\r\\n    function changeMaxSellRemoval(uint256 maxSellRemoval) public onlyOwner {\\r\\n        require(maxSellRemoval < 100, \\\"Max Sell Removal is too high!\\\");\\r\\n        require(maxSellRemoval > 0, \\\"Max Sell Removal is too small!\\\");\\r\\n        //Send it to the NitroProtocol\\r\\n        _changeMaxSellRemoval(maxSellRemoval);\\r\\n\\r\\n        //Emit this transaction\\r\\n        emit MaxSellRemovalUpdated(maxSellRemoval);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Sets the address of the presale contract ; required for project to work properly.\\r\\n     * The presale contract address can only be set one time, to prevent re-sending of the 508 lambo.\\r\\n     */\\r\\n    function setPresaleContractAddress(address presaleContract) public onlyOwner {\\r\\n        //We only want this to fire off once so the dev can't do any shady shit\\r\\n        if(presaleContractAddress==address(0)){\\r\\n            //Store address for posterity\\r\\n            presaleContractAddress = presaleContract;\\r\\n\\r\\n            //Whitelist the presale contract so that it can transfer tokens while contract is paused\\r\\n            setWhitelistedSender(presaleContractAddress, true);\\r\\n\\r\\n            //Send the tokens to the presale contract.\\r\\n            super._transfer(address(this), presaleContractAddress, balanceOf(address(this)));\\r\\n            initialDistributionAddress = presaleContract;\\r\\n            //Transfer ownership to presale contract\\r\\n            transferOwnership(presaleContract);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set the maximum percent order volume of bonus tokens for buyers\\r\\n     */\\r\\n    function setMaxBuyBonusPercentage(uint256 _maxBuyBonus) public onlyOwner {\\r\\n        require(_maxBuyBonus < 100*scaleFactor.div(100), \\\"Max Buy Bonus is too high!\\\");\\r\\n        require(_maxBuyBonus > 0, \\\"Max Buy Bonus is too small!\\\");\\r\\n        _setMaxBuyBonusPercentage(_maxBuyBonus);\\r\\n\\r\\n        //Emit Buy Bonus was updated\\r\\n        emit MaxBuyBonusUpdated(_maxBuyBonus);\\r\\n    }\\r\\n\\r\\n//////////////////----------------Modify Contract Variables----------------///////////////\\r\\n\\r\\n    /**\\r\\n     * @dev Min time elapsed before twap is updated.\\r\\n     */\\r\\n    function setMinDeltaTwap(uint256 _minDeltaTwapLong, uint256 _minDeltaTwapShort) internal {\\r\\n        require(_minDeltaTwapLong > 1 seconds, \\\"Minimum delTWAP (Long) is too small!\\\");\\r\\n        require(_minDeltaTwapShort > 1 seconds, \\\"Minimum delTWAP (Short) is too small!\\\");\\r\\n        require(_minDeltaTwapLong > _minDeltaTwapShort, \\\"Long delta is smaller than short delta!\\\");\\r\\n        minDeltaTwapLong = _minDeltaTwapLong;\\r\\n        minDeltaTwapShort = _minDeltaTwapShort;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a whitelisted sender/receiver (nitro protocol does not apply).\\r\\n     */\\r\\n    function setWhitelistedSender(address _address, bool _whitelisted) public onlyOwner {\\r\\n        whitelistedSenders[_address] = _whitelisted;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a known exchange address (tokens sent from these addresses will count as buy orders, tokens sent to these addresses count as sell orders)\\r\\n     */\\r\\n    function setExchangeAddress(address _address, bool _isexchange) public onlyOwner {\\r\\n        exchangeAddresses[_address] = _isexchange;\\r\\n\\r\\n        emit ExchangeListUpdated(_address, _isexchange);\\r\\n    }\\r\\n\\r\\n\\r\\n    function _isWhitelistedSender(address _sender) internal view returns (bool) {\\r\\n        return whitelistedSenders[_sender];\\r\\n    }\\r\\n\\r\\n    //Public to allow us to easily update exchange addresses in the future\\r\\n    function isExchangeAddress(address _sender) public view returns (bool) {\\r\\n        return exchangeAddresses[_sender];\\r\\n    }\\r\\n\\r\\n    function setRelayerJobAddress(address job) public onlyOwner {\\r\\n        RelayerJob = payable(job);\\r\\n    }\\r\\n\\r\\n//                  ------------------ Nitro Implementation ---------------------                //\\r\\n\\r\\n    function _transfer(address sender, address recipient, uint256 amount)\\r\\n        internal\\r\\n        virtual\\r\\n        override\\r\\n        whenNotPausedOrInitialDistribution(sender)\\r\\n    {\\r\\n        //If this isn't a whitelisted sender(such as, this contract itself, the distribution address, or the router)\\r\\n        if(!_isWhitelistedSender(sender)){\\r\\n            //if msg sender is an exchange, then this was a buy\\r\\n            if(isExchangeAddress(sender)){\\r\\n                _updateTwapsAndNitro();\\r\\n                //Perform the core transaction (exchange address to user)\\r\\n                super._transfer(sender, recipient, amount);\\r\\n                //Calculate how many bonus tokens they've earned\\r\\n                uint256 bonus_tokens_amount = lastBuyNitroPercent.mul(amount).div(scaleFactor);\\r\\n\\r\\n                //Check we can afford it from the Nitro Protocol balance\\r\\n                if(balanceOf(address(this)) > bonus_tokens_amount.add(_totalNistToDist)){\\r\\n                    super._transfer(address(this), recipient, bonus_tokens_amount);\\r\\n                }\\r\\n\\r\\n            //if recipient is an exchange, then this was a sell\\r\\n            }else if(isExchangeAddress(recipient)) {\\r\\n                _updateTwapsAndNitro();\\r\\n                //Calculate how many tokens need to be removed from the order\\r\\n                uint256 removed_tokens_amount = lastSellNitroPercent.mul(amount).div(scaleFactor);\\r\\n                //Remove the tokens from the amount to be sent\\r\\n                amount = amount.sub(removed_tokens_amount,\\\"sellUnderflow\\\");\\r\\n                updateStakingOutputPerSecond(_totalNistToDist.add(removed_tokens_amount.div(2)), remainingNISTToAllocate.add(removed_tokens_amount.div(2)));\\r\\n                //Perform the core transaction (user to exchange address)\\r\\n                super._transfer(sender, recipient, amount);\\r\\n\\r\\n                //Send the nitro tokens to this contract so we can swap them for eth\\r\\n                super._transfer(sender, address(this), removed_tokens_amount);\\r\\n\\r\\n                //Take this opportunity to update staking data for this nonwhitelisted,nonexchange sender\\r\\n                updateStake(sender, balanceOf(sender));\\r\\n            }else {\\r\\n                //Take this opportunity to update staking data for this nonwhitelisted, nonexchange sender\\r\\n                updateStake(sender, balanceOf(sender).sub(amount));\\r\\n                //Perform the core transaction (user to user)\\r\\n                super._transfer(sender, recipient, amount);\\r\\n            }\\r\\n        }else {\\r\\n            //Perform the core transaction (whitelisted to anything)\\r\\n            super._transfer(sender, recipient, amount);\\r\\n        }\\r\\n        //Tell the NitroStaker to update the recipients possible staking balance\\r\\n        if(!_isWhitelistedSender(recipient) && !isExchangeAddress(recipient)) updateStake(recipient, balanceOf(recipient));\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n//                  ------------------ TWAP Functions ---------------------                //\\r\\n\\r\\n    /*\\r\\n     * This function updates the most realtime price you can possibly get, given a short mindeltatwapshort (5-10 minutes)\\r\\n     */\\r\\n    function getCurrentShortTwap() public view returns (uint256) {\\r\\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\\r\\n            UniswapV2OracleLibrary.currentCumulativePrices(uniswapPair);\\r\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\r\\n\\r\\n        uint256 priceCumulative = isThisToken0 ? price1Cumulative : price0Cumulative;\\r\\n\\r\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\\r\\n            uint224((priceCumulative - priceCumulativeLast) / timeElapsed)\\r\\n        );\\r\\n\\r\\n        return FixedPoint.decode144(FixedPoint.mul(priceAverage, 1 ether));\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Use this function to get the current short TWAP\\r\\n     */\\r\\n    function getLastShortTwap() public view returns (uint256) {\\r\\n        return priceAverageLast;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Use this function to get the current 48-hour TWAP\\r\\n     */\\r\\n    function getLastLongTwap() public view returns (uint256) {\\r\\n        return priceAverageLastLong;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice This function updates the short TWAP Given the short TWAP period has passed.\\r\\n     * @dev The Nitro % is also updated given that either TWAP was changed - reducing # of calcs on user transfer\\r\\n     */\\r\\n    function _updateTwapsAndNitro() internal virtual {\\r\\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\\r\\n            UniswapV2OracleLibrary.currentCumulativePrices(uniswapPair);\\r\\n        uint256 priceCumulative = isThisToken0 ? price1Cumulative : price0Cumulative;\\r\\n\\r\\n        uint32 timeElapsedShort = blockTimestamp - blockTimestampLast; // overflow is desired\\r\\n        uint32 timeElapsedLong = blockTimestamp - blockTimestampLastLong;\\r\\n\\r\\n        bool recalculateNitro = false;\\r\\n\\r\\n        if (timeElapsedShort > minDeltaTwapShort) {\\r\\n\\r\\n            // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\r\\n            FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\\r\\n                uint224((priceCumulative - priceCumulativeLast) / timeElapsedShort)\\r\\n            );\\r\\n\\r\\n            priceCumulativeLast = priceCumulative;\\r\\n            blockTimestampLast = blockTimestamp;\\r\\n\\r\\n            priceAverageLast = FixedPoint.decode144(FixedPoint.mul(priceAverage, 1 ether));\\r\\n\\r\\n            recalculateNitro = true;\\r\\n        }\\r\\n\\r\\n        if (timeElapsedLong > minDeltaTwapLong) {\\r\\n\\r\\n            // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\r\\n            FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\\r\\n                uint224((priceCumulative - priceCumulativeLastLong) / timeElapsedLong)\\r\\n            );\\r\\n\\r\\n            priceCumulativeLastLong = priceCumulative;\\r\\n            blockTimestampLastLong = blockTimestamp;\\r\\n\\r\\n            priceAverageLastLong = FixedPoint.decode144(FixedPoint.mul(priceAverage, 1 ether));\\r\\n\\r\\n            recalculateNitro = true;\\r\\n        }\\r\\n        if(recalculateNitro){\\r\\n            (lastBuyNitroPercent, lastSellNitroPercent) = calculateCurrentNitroRate();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the TWAP cumulative values for the burn curve.\\r\\n     */\\r\\n    function initializeTwap() external onlyInitialDistributionAddress {\\r\\n        require(blockTimestampLast == 0, \\\"Both TWAPS already initialized\\\");\\r\\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) =\\r\\n            UniswapV2OracleLibrary.currentCumulativePrices(uniswapPair);\\r\\n\\r\\n        uint256 priceCumulative = isThisToken0 ? price1Cumulative : price0Cumulative;\\r\\n\\r\\n        //Initialize the short TWAP values\\r\\n        blockTimestampLast = blockTimestamp;\\r\\n        priceCumulativeLast = priceCumulative;\\r\\n        priceAverageLast = INITIAL_TOKENS_PER_ETH;\\r\\n\\r\\n        //Initialize the long TWAP values\\r\\n        blockTimestampLastLong = blockTimestamp;\\r\\n        priceCumulativeLastLong = priceCumulative;\\r\\n        priceAverageLastLong = INITIAL_TOKENS_PER_ETH;\\r\\n    }\\r\\n//                  ------------------ User Functions ---------------------                //\\r\\n\\r\\n    /*\\r\\n     * Function if for some reason the predicted trading pair address doesn't match real life trading pair address.\\r\\n     */\\r\\n    function setUniswapPair(address newUniswapPair) public onlyOwner {\\r\\n        setExchangeAddress(uniswapPair, false);\\r\\n\\r\\n        uniswapPair = newUniswapPair;\\r\\n        updateStake(uniswapPair, 0);\\r\\n\\r\\n        setExchangeAddress(uniswapPair, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Changes the minimum auto-payout balance\\r\\n     */\\r\\n    function updateMinimumAutoPayout(uint256 new_min) public onlyOwner {\\r\\n        updateMinimumAutoPayoutBalance(new_min);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the current running % for the Nitro protocol. That is,\\r\\n     *  The percent bonus tokens for any buyers at the current moment\\r\\n     *  The percent tokens removed for any sellers at the current moment\\r\\n     *  This is calculated using the TWAP and the realtimeprice. Calling this DOESN'T Update the TWAP.\\r\\n     *\\r\\n     * @return buyNitro A uint256 of 0.XX * 1 eth units, where XX is the current % for buyers (6% will return 0.06*1ether)\\r\\n     * @return sellNitro A uint256 of 0.XX * 1 eth units, where XX is the current % for sellers (6% will return 0.06*1ether)\\r\\n     */\\r\\n    function calculateCurrentNitroRate() public view returns (uint256 buyNitro, uint256 sellNitro) {\\r\\n        //The units on both of these is tokens per eth\\r\\n        uint256 currentRealTimePrice = getLastShortTwap();\\r\\n        uint256 currentTwap = getLastLongTwap();\\r\\n        uint256 nitro;\\r\\n\\r\\n        //Calculate the Nitro rate based on which is larger to keep it positive\\r\\n        if(currentRealTimePrice > currentTwap){\\r\\n            //Calculation explanation:\\r\\n            //(RTP-TWAP)*scaleFactor/TWAP is typical percent calc but with the scaleFactor moved up b/c uint256\\r\\n            // The *scaleFactor.dv has to cancel out the scaleFactor to get back to fractions of 100, but in units of ether\\r\\n            // nitro = (currentRealTimePrice.sub(currentTwap).mul(scaleFactor).div(currentTwap))*scaleFactor.div(scaleFactor);\\r\\n            nitro = (currentRealTimePrice.sub(currentTwap).mul(scaleFactor).div(currentTwap)); \\r\\n        }\\r\\n        else{\\r\\n            //Simply the above calculation * -1 to offset the negative\\r\\n            nitro = (currentTwap.sub(currentRealTimePrice).mul(scaleFactor).div(currentTwap));\\r\\n        }\\r\\n\\r\\n        //Validate that the nitro value is within the defined bounds and return\\r\\n        buyNitro = (nitro > maxBuyBonus()) ? maxBuyBonus() : nitro;\\r\\n        sellNitro = (nitro.mul(2) > maxSellRemoval()) ? maxSellRemoval() : nitro.mul(2);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NitroStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.6;\\r\\nimport { SafeERC20, SafeMath, IERC20, Address } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\\r\\nimport \\\"./libraries/UniswapV2Library.sol\\\";\\r\\nimport \\\"./interfaces/Uniswap/IUniswapV2Router.sol\\\";\\r\\nimport './interfaces/Relayer/IKeep3rV1Mini.sol';\\r\\n\\r\\ncontract NitroStaking\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256 internal scalefactor = 1e18;\\r\\n\\r\\n    uint256 private _maxSellRemoval;\\r\\n\\r\\n    uint256 private _maxBuyBonus;\\r\\n\\r\\n    uint256 internal _totalNistToDist = 0;\\r\\n\\r\\n    /// @notice Describes the minimum balance required to receive auto-rewards\\r\\n    uint256 public minimumRewardBalance = 1 * 1 ether;\\r\\n\\r\\n    /// @notice The minimum balance required to be eligible for automatic payouts\\r\\n    uint256 public minimumAutoPayoutBalance = 0.1 * 1 ether;\\r\\n\\r\\n    uint256 private totalstakes;\\r\\n\\r\\n    /// @notice Describes the remaining ETH in the contract balance that is unallocated to rewards\\r\\n    //          I.E. The contract may have 20 ETh in it but 10 ETH might already be allocated to existing stakers accruing a balance\\r\\n    uint256 public remainingNISTToAllocate;\\r\\n\\r\\n    /**\\r\\n     * @notice The previous timestamp for reward allocation. Gets set to block.timestamp on reward distribution.\\r\\n     */\\r\\n    uint256 public previousRewardDistributionTimestamp;\\r\\n\\r\\n    /**\\r\\n     * @dev This is instantiated to 48 hours currently.The time over which the entire balance of this contract, if unchanged, would be sent to stakers.\\r\\n     */\\r\\n    uint balance_emission_time = 48 hours;\\r\\n\\r\\n    /**\\r\\n     * @notice The nist output per second in the staking system.\\r\\n     * @dev This is only updated every time the eth balance of the contract increases.\\r\\n     */\\r\\n    uint256 public nist_output_per_second;\\r\\n\\r\\n    /**\\r\\n     * @param stake The amount of NIST staked.\\r\\n     * @param S_init The value of S at the time this stake occured.\\r\\n     * @param owed_rewards Any NIST rewards this user accrued that we want to keep track of for historical reasons.\\r\\n     */\\r\\n    struct StakeData{\\r\\n        uint256 stake;\\r\\n        uint256 S_init;\\r\\n        uint256 owed_rewards;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice The stakes for each stakeholder.\\r\\n    */\\r\\n    mapping(address => StakeData) public _stakes;\\r\\n    /**\\r\\n     * @dev All of the addresses involved in the staking system.\\r\\n     */\\r\\n    address[] internal _stakeholders;\\r\\n\\r\\n    /**\\r\\n     * @dev The running total of eth payout per staked NIST.\\r\\n     */\\r\\n    uint256 public S;\\r\\n    //\\r\\n    IUniswapV2Router router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n\\r\\n    address payable public RelayerJob;\\r\\n\\r\\n    //RLR contract which will add eth credit to the job\\r\\n    IKeep3rV1Mini public RLR;\\r\\n\\r\\n//////////////////----------------Public View Variables----------------///////////////\\r\\n\\r\\n    //Return the maxSellRemoval\\r\\n    function maxSellRemoval() public view returns (uint256) {\\r\\n        return _maxSellRemoval;\\r\\n    }\\r\\n\\r\\n    function maxBuyBonus() public view returns (uint256) {\\r\\n        return _maxBuyBonus;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @notice A method to get the stakeholders as a memory address array\\r\\n    * @return uint256 The list of stakeholders\\r\\n    */\\r\\n    function stakeHolders() public view returns (address[] memory) {\\r\\n        return _stakeholders;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @notice A method to the aggregated stakes from all _stakeholders.\\r\\n    * @return uint256 The aggregated stakes from all _stakeholders.\\r\\n    */\\r\\n   function totalStakes()\\r\\n       public\\r\\n       view\\r\\n       returns(uint256)\\r\\n   {\\r\\n       uint256 _totalStakes = 0;\\r\\n       for (uint256 s = 0; s < _stakeholders.length; s += 1){\\r\\n           _totalStakes = _totalStakes.add(_stakes[_stakeholders[s]].stake);\\r\\n       }\\r\\n       return _totalStakes;\\r\\n   }\\r\\n\\r\\n   /**\\r\\n    * @notice A method to the aggregated rewards from all _stakeholders.\\r\\n    * @return uint256 The aggregated rewards from all _stakeholders.\\r\\n    */\\r\\n   function totalUnclaimedRewards()\\r\\n       public\\r\\n       view\\r\\n       returns(uint256)\\r\\n   {\\r\\n       uint256 _totalRewards = 0;\\r\\n       for (uint256 s = 0; s < _stakeholders.length; s += 1){\\r\\n           _totalRewards = _totalRewards.add(calculateRewardWithFee(_stakeholders[s]));\\r\\n       }\\r\\n       return _totalRewards;\\r\\n   }\\r\\n\\r\\n    function getEligibleCount(uint256 target) internal view returns (uint256 count) {\\r\\n        count = 0;\\r\\n        for (uint256 s = 0; s < _stakeholders.length; s += 1){\\r\\n            if(count >= target && target != 0) return count;\\r\\n            if(calculateRewardWithFee(_stakeholders[s]) > minimumAutoPayoutBalance){\\r\\n                count += 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Returns an iterable list of addresses that qualify for automatic payout\\r\\n    * @dev This is pretty bad to use because it can run out of gas, please supplement with getNextEligibleAddressForAutomaticPayout and\\r\\n    *      try again with a lower numToFind.\\r\\n    * @param numToFind Is the number of addresses to pull from the database; Set to 0 to find all.\\r\\n    * Returns An array that from 0->i has eligible addresses then from i->_stakeholders.length contains empty and total_rewards The total amount of NIST required to be liquidated if these users were paid\\r\\n    * Use static call if you are using scripts to get data \\r\\n    */\\r\\n    function getEligibleAddressesForAutomaticPayout(uint256 numToFind)\\r\\n        public\\r\\n        view\\r\\n        returns(address[] memory eligible_addresses, uint256 total_rewards)\\r\\n    {\\r\\n        (uint256 eligible_count) = getEligibleCount(numToFind);\\r\\n        eligible_addresses = new address[](eligible_count);\\r\\n        uint256 count = 0;\\r\\n        total_rewards = 0;\\r\\n        for (uint256 s = 0; s < _stakeholders.length && count < eligible_addresses.length ; s++){\\r\\n            uint256 reward = calculateRewardWithFee(_stakeholders[s]);\\r\\n            if(reward > minimumAutoPayoutBalance){\\r\\n                eligible_addresses[count] = _stakeholders[s];\\r\\n                total_rewards += reward;\\r\\n                count += 1;\\r\\n            }\\r\\n        }\\r\\n        return (eligible_addresses, total_rewards);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Returns the next address in the list that is available for auto payout\\r\\n    * @dev External iteration required\\r\\n    * @return The next address eligible for auto payout.\\r\\n    */\\r\\n    function getNextEligibleAddressForAutomaticPayout()\\r\\n        public\\r\\n        view\\r\\n        returns(address)\\r\\n    {\\r\\n        for (uint256 s = 0; s < _stakeholders.length; s += 1){\\r\\n            if(calculateRewardWithFee(_stakeholders[s]) > minimumAutoPayoutBalance) return _stakeholders[s];\\r\\n        }\\r\\n        return address(0);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @notice A method to check if an address is a stakeholder.\\r\\n    * @param _address The address to verify.\\r\\n    * @return bool, uint256 Whether the address is a stakeholder,\\r\\n    * and if so its position in the _stakeholders array.\\r\\n    */\\r\\n   function isStakeholder(address _address)\\r\\n       public\\r\\n       view\\r\\n       returns(bool, uint256)\\r\\n   {\\r\\n       for (uint256 s = 0; s < _stakeholders.length; s += 1){\\r\\n           if (_address == _stakeholders[s]) return (true, s);\\r\\n       }\\r\\n       return (false, 0);\\r\\n   }\\r\\n\\r\\n   /**\\r\\n    * @notice A method to retrieve the stake for a stakeholder.\\r\\n    * @param _stakeholder The stakeholder to retrieve the stake for.\\r\\n    * @return uint256 The amount of wei staked.\\r\\n    */\\r\\n   function stakeOf(address _stakeholder)\\r\\n       public\\r\\n       view\\r\\n       returns(uint256)\\r\\n   {\\r\\n       return _stakes[_stakeholder].stake;\\r\\n   }\\r\\n\\r\\n   /**\\r\\n    * @notice A simple method that calculates the rewards for a given stakeholder.\\r\\n    * @param _stakeholder The stakeholder to calculate rewards for.\\r\\n    * @return The amount of ETH owed to this _stakeholder.\\r\\n    */\\r\\n    function calculateRewardWithFee(address _stakeholder)\\r\\n       public\\r\\n       view\\r\\n       returns(uint256)\\r\\n    {\\r\\n        return calculateRewardWithoutFee(_stakeholder).mul(94).div(100);\\r\\n    }\\r\\n\\r\\n    function getNistToETHPath() internal view returns (address[] memory) {\\r\\n        //Create path\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n        return path;\\r\\n    }\\r\\n\\r\\n    function getEstimateAmounts(uint256 nistAmount) internal view returns (uint256[] memory amountarr) {\\r\\n        if(nistAmount <= 0){\\r\\n            amountarr = new uint256[](2);\\r\\n            amountarr[0] = 0;\\r\\n            amountarr[1] = 0;\\r\\n            return amountarr;\\r\\n        }\\r\\n        //Get estimated output\\r\\n        amountarr = UniswapV2Library.getAmountsOut(router.factory(),nistAmount,getNistToETHPath());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Since 5% of earned fees go to RLR worker, the public function removes the fee. For the purposes of calculating, this is the\\r\\n     * function with the true number of tokens earned by the user.\\r\\n     */\\r\\n    function calculateRewardWithoutFee(address _stakeholder)\\r\\n        internal\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        uint256 earned_nist = calculateEarnedNIST(_stakeholder);\\r\\n        return getEstimateAmounts(earned_nist)[1];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the amount of NIST earned in the internal staking system.\\r\\n     * @dev Use this to get the amount of NIST earned before it's converted to ETH.\\r\\n     */\\r\\n    function calculateEarnedNIST(address _stakeholder)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 earned_NIST)\\r\\n    {\\r\\n        //(user's Stake)*(S- S_when_user_joined) + owed_rewards\\r\\n        return ((_stakes[_stakeholder].stake).mul(S.sub(_stakes[_stakeholder].S_init)).div(scalefactor)).add(_stakes[_stakeholder].owed_rewards);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice An approximate value for the NIST introduced into the system assuming price and global staking balance is constant.\\r\\n     * @return The amount of ETH / NIST a user should expect to receive over the next distribution period. \\r\\n     */\\r\\n    function approximateETHPerNISTOutput()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return getEstimateAmounts(remainingNISTToAllocate)[1].div(totalStakes());\\r\\n    }\\r\\n\\r\\n//////////////////----------------Modify Variables, Internal----------------///////////////\\r\\n\\r\\n    modifier onlyRelayerJob() {\\r\\n        require(msg.sender == RelayerJob);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the maximum percent order volume of tokens taken in a sell order\\r\\n     */\\r\\n    function _changeMaxSellRemoval(uint256 new_maxSellRemoval) internal {\\r\\n        _maxSellRemoval = new_maxSellRemoval;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the maximum percent order volume of bonus tokens for buyers\\r\\n     */\\r\\n    function _setMaxBuyBonusPercentage(uint256 new_maxBuyBonus) internal {\\r\\n        _maxBuyBonus = new_maxBuyBonus;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice A method to add a stakeholder.\\r\\n    * @param _stakeholder The stakeholder to add.\\r\\n    */\\r\\n   function addStakeholder(address _stakeholder)\\r\\n       internal\\r\\n   {\\r\\n       (bool _isStakeholder, ) = isStakeholder(_stakeholder);\\r\\n       if(!_isStakeholder) _stakeholders.push(_stakeholder);\\r\\n   }\\r\\n\\r\\n   /**\\r\\n    * @notice A method to remove a stakeholder.\\r\\n    * @param _stakeholder The stakeholder to remove.\\r\\n    */\\r\\n   function removeStakeholder(address _stakeholder)\\r\\n       internal\\r\\n   {\\r\\n       (bool _isStakeholder, uint256 s) = isStakeholder(_stakeholder);\\r\\n       if(_isStakeholder){\\r\\n           _stakeholders[s] = _stakeholders[_stakeholders.length - 1];\\r\\n           _stakeholders.pop();\\r\\n       }\\r\\n   }\\r\\n\\r\\n   /**\\r\\n    * @notice A method for a stakeholder to create a stake.\\r\\n    * @param _stakeholder The address of the stakeholder.\\r\\n    * @dev Every addition resets the stake history. ETH transfer is included to claim the rewards for the user. \\r\\n    */\\r\\n   function updateStake(address _stakeholder, uint256 user_current_balance)\\r\\n       internal\\r\\n   {\\r\\n        (bool _isStakeholder,) = isStakeholder(_stakeholder);\\r\\n        if(user_current_balance >= minimumRewardBalance){\\r\\n            //Possibly add to stakeholder list if not included\\r\\n            addStakeholder(_stakeholder);\\r\\n\\r\\n            //Update the staking data to the current balance\\r\\n            saveRewardData(_stakeholder, user_current_balance);\\r\\n        }else if (_isStakeholder){ // User doesn't qualify for staking but is still included as stakeholder, needs to be removed\\r\\n\\r\\n            //Update the staking data to the current balance\\r\\n            saveRewardData(_stakeholder, user_current_balance);\\r\\n\\r\\n            //Remove from stakeholder list\\r\\n            removeStakeholder(_stakeholder);\\r\\n        }\\r\\n   }\\r\\n\\r\\n    /**\\r\\n     * @notice In the event that a stake is updated, we have to store the staking reward information for later for recall.\\r\\n    *       This saves the data in a way that doesn't destroy previous reward history.\\r\\n     */\\r\\n   function saveRewardData(address _stakeholder, uint256 user_current_balance)\\r\\n        internal\\r\\n    {\\r\\n        //Get the most up-to-date reward distribution\\r\\n        distributeRewards(calcInstantaneousDistributionAmount());\\r\\n        //Update the staking data for this user to the current S value, with the stored IOU rewards\\r\\n        _stakes[_stakeholder] = StakeData(user_current_balance, S, calculateEarnedNIST(_stakeholder));\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @notice A method to allow a stakeholder to withdraw his rewards.\\r\\n    * @dev This one doesn't liquidate the allocated nist for this user\\r\\n    */\\r\\n   function claimRewardsInternal(address _stakeholder)\\r\\n       internal\\r\\n   {\\r\\n        uint256 reward = calculateRewardWithFee(_stakeholder);\\r\\n        if(reward != 0 && address(this).balance >= reward){ //We can't check if it's above minimum auto payout, b/c we sometimes payout even if they don't qualify (like if they update their stake)\\r\\n            //Transfer the owed reward to the user\\r\\n            TransferHelper.safeTransferETH(_stakeholder,reward);\\r\\n\\r\\n            //Reset user's S_init to be current S\\r\\n            _stakes[_stakeholder] = StakeData(_stakes[_stakeholder].stake, S, 0);\\r\\n        }\\r\\n   }\\r\\n\\r\\n    /**\\r\\n     * @notice The public method for claiming rewards, which includes a swap of nist to eth for the tokens needed\\r\\n     */\\r\\n    function claimRewardsPublic(address _stakeholder)\\r\\n        public\\r\\n    {\\r\\n        distributeRewards(calcInstantaneousDistributionAmount());\\r\\n        uint256 num_tokens_to_liquidate = calculateEarnedNIST(_stakeholder);\\r\\n        if(num_tokens_to_liquidate != 0){\\r\\n            swapTokenstoETH(num_tokens_to_liquidate);\\r\\n            claimRewardsInternal(_stakeholder);\\r\\n        }\\r\\n    }\\r\\n\\r\\n// ------------------ Admin functions --------------//\\r\\n    /**\\r\\n    * @notice A method to distribute rewards to all _stakeholders.\\r\\n    * @param r The amount of NIST at this moment in time to be distributed between all stakers when they eventually withdraw.\\r\\n    * @dev Implementing this function with calcInstantaneousDistributionAmount() is how the RLR will perform the distribution job\\r\\n    */\\r\\n    function distributeRewards(uint256 r)\\r\\n    internal\\r\\n    {\\r\\n        uint256 total_stakes = totalStakes();\\r\\n        if(total_stakes != 0 && r <= remainingNISTToAllocate){\\r\\n            S = S.add(r.mul(scalefactor).div(total_stakes));\\r\\n\\r\\n            //Make sure we keep track of how much nist we have left to allocate\\r\\n            remainingNISTToAllocate = remainingNISTToAllocate.sub(r);\\r\\n\\r\\n            //Update the distribution timestamp to keep emissions constant\\r\\n            previousRewardDistributionTimestamp = block.timestamp;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates what the variable r in distributeRewards should be given the current timestamp, last distribution timestamp, and the current rate\\r\\n     * @dev This function will be used as the input to distribute rewards.\\r\\n     * @return The amount of NIST appropriate to be distributed at this moment\\r\\n     */\\r\\n    function calcInstantaneousDistributionAmount()\\r\\n        public\\r\\n        view\\r\\n        returns\\r\\n        (uint256)\\r\\n    {\\r\\n        uint256 initCalc = (block.timestamp.sub(previousRewardDistributionTimestamp)).mul(nist_output_per_second);\\r\\n        //If we've reached the end of the distribution period without a change in the NIST balance of the contract,\\r\\n        //      it will attempt to continue the same rate of distribution. This returns zero in this case\\r\\n        return (initCalc > remainingNISTToAllocate) ? 0 : initCalc;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the emissions rate of the distribution mechanism.\\r\\n     * @dev This currently is used for when the NIST for staking balance changes\\r\\n     */\\r\\n    function updateStakingOutputPerSecond(uint256 newTotalNist, uint256 newAllocNist)\\r\\n        internal\\r\\n    {\\r\\n        _totalNistToDist = newTotalNist;\\r\\n        remainingNISTToAllocate = newAllocNist;\\r\\n        nist_output_per_second = remainingNISTToAllocate.div(balance_emission_time);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        if(RelayerJob != address(0) && msg.sender != RelayerJob) {\\r\\n            //Send 5% of eth to rlr contract to add credit\\r\\n            RLR.addCreditETH{value:msg.value.mul(5).div(100) }(RelayerJob);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function swapTokenstoETH(uint256 numTokens) internal {\\r\\n        //Get estimated output\\r\\n        uint256[] memory amounts = getEstimateAmounts(numTokens);\\r\\n        //swap with eth send to self\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amounts[0],\\r\\n            amounts[1],\\r\\n            getNistToETHPath(),\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        //Update the tracked NIST to distribute\\r\\n        updateStakingOutputPerSecond(_totalNistToDist.sub(amounts[0]), remainingNISTToAllocate.sub(amounts[0]));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    /**\\r\\n     * @notice The primary interface function for hte relayer job to send rewards to eligible _stakeholders\\r\\n     * @dev This needs to be compliant with the RLR protocols\\r\\n     */\\r\\n    function processAutoRewardPayouts(address[] calldata stakers,uint256 tokens_to_liquidate) external onlyRelayerJob\\r\\n    {\\r\\n        require(_totalNistToDist > 0, \\\"!NIST_To_Distribute\\\");\\r\\n        distributeRewards(calcInstantaneousDistributionAmount());\\r\\n        swapTokenstoETH(tokens_to_liquidate);\\r\\n        for(uint i = 0;i<stakers.length;i++)\\r\\n            claimRewardsInternal(stakers[i]);\\r\\n    }\\r\\n\\r\\n\\r\\n    function updateMinimumAutoPayoutBalance(uint256 new_minimum)\\r\\n        internal\\r\\n    {\\r\\n        minimumAutoPayoutBalance = new_minimum;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!_paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(_paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.6;\\r\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\r\\nimport '../interfaces/Uniswap/IUniswapV2Pair.sol';\\r\\n\\r\\nlibrary UniswapV2Library {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\r\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\r\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\r\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\r\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\r\\n    }\\r\\n\\r\\n    // calculates the CREATE2 address for a pair without making any external calls\\r\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\r\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\r\\n        pair = address(uint(keccak256(abi.encodePacked(\\r\\n                hex'ff',\\r\\n                factory,\\r\\n                keccak256(abi.encodePacked(token0, token1)),\\r\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\r\\n            ))));\\r\\n    }\\r\\n\\r\\n    // fetches and sorts the reserves for a pair\\r\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\r\\n        (address token0,) = sortTokens(tokenA, tokenB);\\r\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\r\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n    }\\r\\n\\r\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\r\\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\r\\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\r\\n        amountB = amountA.mul(reserveB) / reserveA;\\r\\n    }\\r\\n\\r\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\r\\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\r\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\r\\n        uint amountInWithFee = amountIn.mul(997);\\r\\n        uint numerator = amountInWithFee.mul(reserveOut);\\r\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\r\\n        amountOut = numerator / denominator;\\r\\n    }\\r\\n\\r\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\r\\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\\r\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\r\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\r\\n        uint denominator = reserveOut.sub(amountOut).mul(997);\\r\\n        amountIn = (numerator / denominator).add(1);\\r\\n    }\\r\\n\\r\\n    // performs chained getAmountOut calculations on any number of pairs\\r\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\r\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\r\\n        amounts = new uint[](path.length);\\r\\n        amounts[0] = amountIn;\\r\\n        for (uint i; i < path.length - 1; i++) {\\r\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\r\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // performs chained getAmountIn calculations on any number of pairs\\r\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\r\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\r\\n        amounts = new uint[](path.length);\\r\\n        amounts[amounts.length - 1] = amountOut;\\r\\n        for (uint i = path.length - 1; i > 0; i--) {\\r\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\r\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/Uniswap/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\nimport './IUniswapV2Router01.sol';\\r\\n\\r\\ninterface IUniswapV2Router is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/Relayer/IKeep3rV1Mini.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.6;\\r\\ninterface IKeep3rV1Mini {\\r\\n    function isKeeper(address) external returns (bool);\\r\\n    function worked(address keeper) external;\\r\\n    function totalBonded() external view returns (uint);\\r\\n    function bonds(address keeper, address credit) external view returns (uint);\\r\\n    function votes(address keeper) external view returns (uint);\\r\\n    function isMinKeeper(address keeper, uint minBond, uint earned, uint age) external returns (bool);\\r\\n    function addCreditETH(address job) external payable;\\r\\n    function credits(address job, address credit) external view returns (uint);\\r\\n    function receipt(address credit, address keeper, uint amount) external;\\r\\n    function ETH() external view returns (address);\\r\\n    function receiptETH(address keeper, uint amount) external;\\r\\n    function addJob(address job) external;\\r\\n    function mint(uint amount) external;\\r\\n    function bond(address bonding, uint amount) external;\\r\\n    function activate(address bonding) external;\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Uniswap/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.6;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/Uniswap/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.4.0;\\n\\nimport './FullMath.sol';\\nimport './Babylonian.sol';\\nimport './BitMath.sol';\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 public constant RESOLUTION = 112;\\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\\n        uint256 z = 0;\\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\\n        return uq144x112(z);\\n    }\\n\\n    // multiply a UQ112x112 by an int and decode, returning an int\\n    // reverts on overflow\\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\\n        require(z < 2**255, 'FixedPoint::muli: overflow');\\n        return y < 0 ? -int256(z) : int256(z);\\n    }\\n\\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\\n    // lossy\\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\n        if (self._x == 0 || other._x == 0) {\\n            return uq112x112(0);\\n        }\\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\\n\\n        // partial products\\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\\n\\n        // so the bit shift does not overflow\\n        require(upper <= uint112(-1), 'FixedPoint::muluq: upper overflow');\\n\\n        // this cannot exceed 256 bits, all values are 224 bits\\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\\n\\n        // so the cast does not overflow\\n        require(sum <= uint224(-1), 'FixedPoint::muluq: sum overflow');\\n\\n        return uq112x112(uint224(sum));\\n    }\\n\\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\\n        if (self._x == other._x) {\\n            return uq112x112(uint224(Q112));\\n        }\\n        if (self._x <= uint144(-1)) {\\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\\n            require(value <= uint224(-1), 'FixedPoint::divuq: overflow');\\n            return uq112x112(uint224(value));\\n        }\\n\\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\\n        require(result <= uint224(-1), 'FixedPoint::divuq: overflow');\\n        return uq112x112(uint224(result));\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // can be lossy\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\n\\n        if (numerator <= uint144(-1)) {\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\n            return uq112x112(uint224(result));\\n        } else {\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\n            return uq112x112(uint224(result));\\n        }\\n    }\\n\\n    // take the reciprocal of a UQ112x112\\n    // reverts on overflow\\n    // lossy\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\\n        return uq112x112(uint224(Q224 / self._x));\\n    }\\n\\n    // square root of a UQ112x112\\n    // lossy between 0/1 and 40 bits\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        if (self._x <= uint144(-1)) {\\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\\n        }\\n\\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\\n        safeShiftBits -= safeShiftBits % 2;\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC-BY-4.0\\npragma solidity >=0.4.0;\\n\\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\\n// license is CC-BY-4.0\\nlibrary FullMath {\\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\\n        uint256 mm = mulmod(x, y, uint256(-1));\\n        l = x * y;\\n        h = mm - l;\\n        if (mm < l) h -= 1;\\n    }\\n\\n    function fullDiv(\\n        uint256 l,\\n        uint256 h,\\n        uint256 d\\n    ) private pure returns (uint256) {\\n        uint256 pow2 = d & -d;\\n        d /= pow2;\\n        l /= pow2;\\n        l += h * ((-pow2) / pow2 + 1);\\n        uint256 r = 1;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        return l * r;\\n    }\\n\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d\\n    ) internal pure returns (uint256) {\\n        (uint256 l, uint256 h) = fullMul(x, y);\\n\\n        uint256 mm = mulmod(x, y, d);\\n        if (mm > l) h -= 1;\\n        l -= mm;\\n\\n        if (h == 0) return l / d;\\n\\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\\n        return fullDiv(l, h, d);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.4.0;\\n\\n// computes square roots using the babylonian method\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\nlibrary Babylonian {\\n    // credit for this implementation goes to\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        if (x == 0) return 0;\\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\\n        // however that code costs significantly more gas\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/BitMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.5.0;\\n\\nlibrary BitMath {\\n    // returns the 0 indexed position of the most significant bit of the input x\\n    // s.t. x >= 2**msb and x < 2**(msb+1)\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\\n\\n        if (x >= 0x100000000000000000000000000000000) {\\n            x >>= 128;\\n            r += 128;\\n        }\\n        if (x >= 0x10000000000000000) {\\n            x >>= 64;\\n            r += 64;\\n        }\\n        if (x >= 0x100000000) {\\n            x >>= 32;\\n            r += 32;\\n        }\\n        if (x >= 0x10000) {\\n            x >>= 16;\\n            r += 16;\\n        }\\n        if (x >= 0x100) {\\n            x >>= 8;\\n            r += 8;\\n        }\\n        if (x >= 0x10) {\\n            x >>= 4;\\n            r += 4;\\n        }\\n        if (x >= 0x4) {\\n            x >>= 2;\\n            r += 2;\\n        }\\n        if (x >= 0x2) r += 1;\\n    }\\n\\n    // returns the 0 indexed position of the least significant bit of the input x\\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\\n\\n        r = 255;\\n        if (x & uint128(-1) > 0) {\\n            r -= 128;\\n        } else {\\n            x >>= 128;\\n        }\\n        if (x & uint64(-1) > 0) {\\n            r -= 64;\\n        } else {\\n            x >>= 64;\\n        }\\n        if (x & uint32(-1) > 0) {\\n            r -= 32;\\n        } else {\\n            x >>= 32;\\n        }\\n        if (x & uint16(-1) > 0) {\\n            r -= 16;\\n        } else {\\n            x >>= 16;\\n        }\\n        if (x & uint8(-1) > 0) {\\n            r -= 8;\\n        } else {\\n            x >>= 8;\\n        }\\n        if (x & 0xf > 0) {\\n            r -= 4;\\n        } else {\\n            x >>= 4;\\n        }\\n        if (x & 0x3 > 0) {\\n            r -= 2;\\n        } else {\\n            x >>= 2;\\n        }\\n        if (x & 0x1 > 0) r -= 1;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minDeltaTwapLong\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDeltaTwapShort\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rlrToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExchange\",\"type\":\"bool\"}],\"name\":\"ExchangeListUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceCumulativeLastLong\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTimestampLastLong\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceAverageLastLong\",\"type\":\"uint256\"}],\"name\":\"LongTwapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_MBB\",\"type\":\"uint256\"}],\"name\":\"MaxBuyBonusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_MSR\",\"type\":\"uint256\"}],\"name\":\"MaxSellRemovalUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceCumulativeLast\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTimestampLast\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceAverageLast\",\"type\":\"uint256\"}],\"name\":\"TwapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INITIAL_TOKENS_PER_ETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LPTokenContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RLR\",\"outputs\":[{\"internalType\":\"contract IKeep3rV1Mini\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RelayerJob\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"S\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"S_init\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"owed_rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approximateETHPerNISTOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimestampLast\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimestampLastLong\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcInstantaneousDistributionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateCurrentNitroRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyNitro\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellNitro\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"}],\"name\":\"calculateEarnedNIST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"earned_NIST\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"}],\"name\":\"calculateRewardWithFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxSellRemoval\",\"type\":\"uint256\"}],\"name\":\"changeMaxSellRemoval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"}],\"name\":\"claimRewardsPublic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangeAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentShortTwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numToFind\",\"type\":\"uint256\"}],\"name\":\"getEligibleAddressesForAutomaticPayout\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"eligible_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"total_rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastLongTwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastShortTwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextEligibleAddressForAutomaticPayout\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialDistributionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeTwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"isExchangeAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isStakeholder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isThisToken0\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBuyNitroPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSellNitroPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellRemoval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDeltaTwapLong\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDeltaTwapShort\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumAutoPayoutBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumRewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nist_output_per_second\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleInitFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousRewardDistributionTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceAverageLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceAverageLastLong\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceCumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceCumulativeLastLong\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"stakers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"tokens_to_liquidate\",\"type\":\"uint256\"}],\"name\":\"processAutoRewardPayouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingNISTToAllocate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaleFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isexchange\",\"type\":\"bool\"}],\"name\":\"setExchangeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"LPTokenAddy\",\"type\":\"address\"}],\"name\":\"setLiquidityTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxBuyBonus\",\"type\":\"uint256\"}],\"name\":\"setMaxBuyBonusPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"presaleContract\",\"type\":\"address\"}],\"name\":\"setPresaleContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"job\",\"type\":\"address\"}],\"name\":\"setRelayerJobAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUniswapPair\",\"type\":\"address\"}],\"name\":\"setUniswapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUniRouterAddy\",\"type\":\"address\"}],\"name\":\"setUniswapRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeHolders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeholder\",\"type\":\"address\"}],\"name\":\"stakeOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUnclaimedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapv2RouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_min\",\"type\":\"uint256\"}],\"name\":\"updateMinimumAutoPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedSenders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"NitroStakingToken","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000a8c0000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000e3ef895c59e7db27214ab5bbf56347ce115a3f4","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}