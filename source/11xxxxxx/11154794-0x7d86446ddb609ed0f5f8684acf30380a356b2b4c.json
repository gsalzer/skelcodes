{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.7\r\n\"\"\"\r\n@title Curve Registry\r\n@license MIT\r\n@author Curve.Fi\r\n\"\"\"\r\n\r\nMAX_COINS: constant(int128) = 8\r\nCALC_INPUT_SIZE: constant(int128) = 100\r\n\r\n\r\nstruct PoolArray:\r\n    location: uint256\r\n    decimals: uint256\r\n    underlying_decimals: uint256\r\n    rate_method_id: bytes32\r\n    base_pool: address\r\n    coins: address[MAX_COINS]\r\n    ul_coins: address[MAX_COINS]\r\n    n_coins: uint256  # [coins, underlying coins] tightly packed as uint128[2]\r\n    has_initial_A: bool\r\n    is_v1: bool\r\n\r\nstruct PoolParams:\r\n    A: uint256\r\n    future_A: uint256\r\n    fee: uint256\r\n    admin_fee: uint256\r\n    future_fee: uint256\r\n    future_admin_fee: uint256\r\n    future_owner: address\r\n    initial_A: uint256\r\n    initial_A_time: uint256\r\n    future_A_time: uint256\r\n\r\n\r\ninterface AddressProvider:\r\n    def admin() -> address: view\r\n\r\ninterface ERC20:\r\n    def balanceOf(_addr: address) -> uint256: view\r\n    def decimals() -> uint256: view\r\n    def totalSupply() -> uint256: view\r\n\r\ninterface CurvePool:\r\n    def A() -> uint256: view\r\n    def future_A() -> uint256: view\r\n    def fee() -> uint256: view\r\n    def admin_fee() -> uint256: view\r\n    def future_fee() -> uint256: view\r\n    def future_admin_fee() -> uint256: view\r\n    def future_owner() -> address: view\r\n    def initial_A() -> uint256: view\r\n    def initial_A_time() -> uint256: view\r\n    def future_A_time() -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n    def underlying_coins(i: uint256) -> address: view\r\n    def balances(i: uint256) -> uint256: view\r\n    def get_virtual_price() -> uint256: view\r\n\r\ninterface CurvePoolV1:\r\n    def coins(i: int128) -> address: view\r\n    def underlying_coins(i: int128) -> address: view\r\n    def balances(i: int128) -> uint256: view\r\n\r\ninterface CurveMetapool:\r\n    def base_pool() -> address: view\r\n\r\ninterface GasEstimator:\r\n    def estimate_gas_used(_pool: address, _from: address, _to: address) -> uint256: view\r\n\r\ninterface LiquidityGauge:\r\n    def lp_token() -> address: view\r\n\r\ninterface GaugeController:\r\n    def gauge_types(gauge: address) -> int128: view\r\n\r\n\r\nevent PoolAdded:\r\n    pool: indexed(address)\r\n    rate_method_id: Bytes[4]\r\n\r\nevent PoolRemoved:\r\n    pool: indexed(address)\r\n\r\n\r\naddress_provider: public(AddressProvider)\r\ngauge_controller: public(address)\r\npool_list: public(address[65536])   # master list of pools\r\npool_count: public(uint256)         # actual length of pool_list\r\n\r\npool_data: HashMap[address, PoolArray]\r\n\r\n# lp token -> pool\r\nget_pool_from_lp_token: public(HashMap[address, address])\r\n\r\n# pool -> lp token\r\nget_lp_token: public(HashMap[address, address])\r\n\r\n# mapping of estimated gas costs for pools and coins\r\n# for a pool the values are [wrapped exchange, underlying exchange]\r\n# for a coin the values are [transfer cost, 0]\r\ngas_estimate_values: HashMap[address, uint256[2]]\r\n\r\n# pool -> gas estimation contract\r\n# used when gas costs for a pool are too complex to be handled by summing\r\n# values in `gas_estimate_values`\r\ngas_estimate_contracts: HashMap[address, address]\r\n\r\n# mapping of coins -> pools for trading\r\n# a mapping key is generated for each pair of addresses via\r\n# `bitwise_xor(convert(a, uint256), convert(b, uint256))`\r\nmarkets: HashMap[uint256, address[65536]]\r\nmarket_counts: HashMap[uint256, uint256]\r\n\r\nliquidity_gauges: HashMap[address, address[10]]\r\n\r\n\r\n@external\r\ndef __init__(_address_provider: address, _gauge_controller: address):\r\n    \"\"\"\r\n    @notice Constructor function\r\n    \"\"\"\r\n    self.address_provider = AddressProvider(_address_provider)\r\n    self.gauge_controller = _gauge_controller\r\n\r\n\r\n# internal functionality for getters\r\n\r\n@view\r\n@internal\r\ndef _unpack_decimals(_packed: uint256, _n_coins: uint256) -> uint256[MAX_COINS]:\r\n    # decimals are tightly packed as a series of uint8 within a little-endian bytes32\r\n    # the packed value is stored as uint256 to simplify unpacking via shift and modulo\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    n_coins: int128 = convert(_n_coins, int128)\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        decimals[i] = shift(_packed, -8 * i) % 256\r\n\r\n    return decimals\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_rates(_pool: address) -> uint256[MAX_COINS]:\r\n    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    if base_pool == ZERO_ADDRESS:\r\n        rate_method_id: Bytes[4] = slice(self.pool_data[_pool].rate_method_id, 28, 4)\r\n\r\n        for i in range(MAX_COINS):\r\n            coin: address = self.pool_data[_pool].coins[i]\r\n            if coin == ZERO_ADDRESS:\r\n                break\r\n            if coin == self.pool_data[_pool].ul_coins[i]:\r\n                rates[i] = 10 ** 18\r\n            else:\r\n                rates[i] = convert(\r\n                    raw_call(coin, rate_method_id, max_outsize=32, is_static_call=True), # dev: bad response\r\n                    uint256\r\n                )\r\n    else:\r\n        base_coin_idx: uint256 = shift(self.pool_data[_pool].n_coins, -128) - 1\r\n        rates[base_coin_idx] = CurvePool(base_pool).get_virtual_price()\r\n        for i in range(MAX_COINS):\r\n            if i == base_coin_idx:\r\n                break\r\n            rates[i] = 10 ** 18\r\n\r\n    return rates\r\n\r\n@view\r\n@internal\r\ndef _get_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    is_v1: bool = self.pool_data[_pool].is_v1\r\n\r\n    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    for i in range(MAX_COINS):\r\n        if self.pool_data[_pool].coins[i] == ZERO_ADDRESS:\r\n            assert i != 0\r\n            break\r\n\r\n        if is_v1:\r\n            balances[i] = CurvePoolV1(_pool).balances(i)\r\n        else:\r\n            balances[i] = CurvePool(_pool).balances(convert(i, uint256))\r\n\r\n    return balances\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_underlying_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    balances: uint256[MAX_COINS] = self._get_balances(_pool)\r\n    rates: uint256[MAX_COINS] = self._get_rates(_pool)\r\n    decimals: uint256 = self.pool_data[_pool].underlying_decimals\r\n    underlying_balances: uint256[MAX_COINS] = balances\r\n    for i in range(MAX_COINS):\r\n        coin: address = self.pool_data[_pool].coins[i]\r\n        if coin == ZERO_ADDRESS:\r\n            break\r\n        ucoin: address = self.pool_data[_pool].ul_coins[i]\r\n        if ucoin == ZERO_ADDRESS:\r\n            continue\r\n        if ucoin != coin:\r\n            underlying_balances[i] = balances[i] * rates[i] / 10**(shift(decimals, -8 * i) % 256)\r\n\r\n    return underlying_balances\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_meta_underlying_balances(_pool: address, _base_pool: address) -> uint256[MAX_COINS]:\r\n    base_coin_idx: uint256 = shift(self.pool_data[_pool].n_coins, -128) - 1\r\n    is_v1: bool = self.pool_data[_base_pool].is_v1\r\n    base_total_supply: uint256 = ERC20(self.get_lp_token[_base_pool]).totalSupply()\r\n\r\n    underlying_balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    ul_balance: uint256 = 0\r\n    underlying_pct: uint256 = 0\r\n    if base_total_supply > 0:\r\n        underlying_pct = CurvePool(_pool).balances(base_coin_idx) * 10**36 / base_total_supply\r\n\r\n    for i in range(MAX_COINS):\r\n        if self.pool_data[_pool].ul_coins[i] == ZERO_ADDRESS:\r\n            break\r\n        if i < base_coin_idx:\r\n            ul_balance = CurvePool(_pool).balances(i)\r\n        else:\r\n            if is_v1:\r\n                ul_balance = CurvePoolV1(_base_pool).balances(convert(i - base_coin_idx, int128))\r\n            else:\r\n                ul_balance = CurvePool(_base_pool).balances(i-base_coin_idx)\r\n            ul_balance = ul_balance * underlying_pct / 10**36\r\n        underlying_balances[i] = ul_balance\r\n\r\n    return underlying_balances\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_coin_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> uint256[3]:\r\n    \"\"\"\r\n    Convert coin addresses to indices for use with pool methods.\r\n    \"\"\"\r\n    # the return value is stored as `uint256[3]` to reduce gas costs\r\n    # from index, to index, is the market underlying?\r\n    result: uint256[3] = empty(uint256[3])\r\n\r\n    found_market: bool = False\r\n\r\n    # check coin markets\r\n    for x in range(MAX_COINS):\r\n        coin: address = self.pool_data[_pool].coins[x]\r\n        if coin == ZERO_ADDRESS:\r\n            # if we reach the end of the coins, reset `found_market` and try again\r\n            # with the underlying coins\r\n            found_market = False\r\n            break\r\n        if coin == _from:\r\n            result[0] = x\r\n        elif coin == _to:\r\n            result[1] = x\r\n        else:\r\n            continue\r\n\r\n        if found_market:\r\n            # the second time we find a match, break out of the loop\r\n            break\r\n        # the first time we find a match, set `found_market` to True\r\n        found_market = True\r\n\r\n    if not found_market:\r\n        # check underlying coin markets\r\n        for x in range(MAX_COINS):\r\n            coin: address = self.pool_data[_pool].ul_coins[x]\r\n            if coin == ZERO_ADDRESS:\r\n                raise \"No available market\"\r\n            if coin == _from:\r\n                result[0] = x\r\n            elif coin == _to:\r\n                result[1] = x\r\n            else:\r\n                continue\r\n\r\n            if found_market:\r\n                result[2] = 1\r\n                break\r\n            found_market = True\r\n\r\n    return result\r\n\r\n\r\n# targetted external getters, optimized for on-chain calls\r\n\r\n@view\r\n@external\r\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\r\n    \"\"\"\r\n    @notice Find an available pool for exchanging two coins\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param i Index value. When multiple pools are available\r\n            this value is used to return the n'th address.\r\n    @return Pool address\r\n    \"\"\"\r\n    key: uint256 = bitwise_xor(convert(_from, uint256), convert(_to, uint256))\r\n    return self.markets[key][i]\r\n\r\n\r\n@view\r\n@external\r\ndef get_n_coins(_pool: address) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Get the number of coins in a pool\r\n    @dev For non-metapools, both returned values are identical\r\n         even when the pool does not use wrapping/lending\r\n    @param _pool Pool address\r\n    @return Number of wrapped coins, number of underlying coins\r\n    \"\"\"\r\n    n_coins: uint256 = self.pool_data[_pool].n_coins\r\n    return [shift(n_coins, -128), n_coins % 2**128]\r\n\r\n\r\n@view\r\n@external\r\ndef get_coins(_pool: address) -> address[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get the coins within a pool\r\n    @dev For pools using lending, these are the wrapped coin addresses\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    n_coins: uint256 = shift(self.pool_data[_pool].n_coins, -128)\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        coins[i] = self.pool_data[_pool].coins[i]\r\n\r\n    return coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_coins(_pool: address) -> address[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get the underlying coins within a pool\r\n    @dev For pools that do not lend, returns the same value as `get_coins`\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    n_coins: uint256 = self.pool_data[_pool].n_coins % 2**128\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        coins[i] = self.pool_data[_pool].ul_coins[i]\r\n\r\n    return coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_decimals(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get decimal places for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin decimal places\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    n_coins: uint256 = shift(self.pool_data[_pool].n_coins, -128)\r\n    return self._unpack_decimals(self.pool_data[_pool].decimals, n_coins)\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_decimals(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get decimal places for each underlying coin within a pool\r\n    @dev For pools that do not lend, returns the same value as `get_decimals`\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    n_coins: uint256 = self.pool_data[_pool].n_coins % 2**128\r\n    return self._unpack_decimals(self.pool_data[_pool].underlying_decimals, n_coins)\r\n\r\n\r\n@view\r\n@external\r\ndef get_rates(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get rates between coins and underlying coins\r\n    @dev For coins where there is no underlying coin, or where\r\n         the underlying coin cannot be swapped, the rate is\r\n         given as 1e18\r\n    @param _pool Pool address\r\n    @return Rates between coins and underlying coins\r\n    \"\"\"\r\n    return self._get_rates(_pool)\r\n\r\n\r\n@view\r\n@external\r\ndef get_gauges(_pool: address) -> (address[10], int128[10]):\r\n    \"\"\"\r\n    @notice Get a list of LiquidityGauge contracts associated with a pool\r\n    @param _pool Pool address\r\n    @return address[10] of gauge addresses, int128[10] of gauge types\r\n    \"\"\"\r\n    liquidity_gauges: address[10] = empty(address[10])\r\n    gauge_types: int128[10] = empty(int128[10])\r\n    gauge_controller: address = self.gauge_controller\r\n    for i in range(10):\r\n        gauge: address = self.liquidity_gauges[_pool][i]\r\n        if gauge == ZERO_ADDRESS:\r\n            break\r\n        liquidity_gauges[i] = gauge\r\n        gauge_types[i] = GaugeController(gauge_controller).gauge_types(gauge)\r\n\r\n    return liquidity_gauges, gauge_types\r\n\r\n\r\n@view\r\n@external\r\ndef get_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get balances for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin balances\r\n    @param _pool Pool address\r\n    @return uint256 list of balances\r\n    \"\"\"\r\n    return self._get_balances(_pool)\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get balances for each underlying coin within a pool\r\n    @dev  For pools that do not lend, returns the same value as `get_balances`\r\n    @param _pool Pool address\r\n    @return uint256 list of underlyingbalances\r\n    \"\"\"\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    if base_pool == ZERO_ADDRESS:\r\n        return self._get_underlying_balances(_pool)\r\n    return self._get_meta_underlying_balances(_pool, base_pool)\r\n\r\n\r\n@view\r\n@external\r\ndef get_virtual_price_from_lp_token(_token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the virtual price of a pool LP token\r\n    @param _token LP token address\r\n    @return uint256 Virtual price\r\n    \"\"\"\r\n    return CurvePool(self.get_pool_from_lp_token[_token]).get_virtual_price()\r\n\r\n\r\n@view\r\n@external\r\ndef get_A(_pool: address) -> uint256:\r\n    return CurvePool(_pool).A()\r\n\r\n\r\n@view\r\n@external\r\ndef get_parameters(_pool: address) -> PoolParams:\r\n    \"\"\"\r\n    @notice Get parameters for a pool\r\n    @dev For older pools where `initial_A` is not public, this value is set to 0\r\n    @param _pool Pool address\r\n    @return Pool amp, future amp, fee, admin fee, future fee, future admin fee,\r\n            future owner, initial amp, initial amp time, future amp time\r\n    \"\"\"\r\n    pool_params: PoolParams = empty(PoolParams)\r\n    pool_params.A = CurvePool(_pool).A()\r\n    pool_params.future_A = CurvePool(_pool).future_A()\r\n    pool_params.fee = CurvePool(_pool).fee()\r\n    pool_params.future_fee = CurvePool(_pool).future_fee()\r\n    pool_params.admin_fee = CurvePool(_pool).admin_fee()\r\n    pool_params.future_admin_fee = CurvePool(_pool).future_admin_fee()\r\n    pool_params.future_owner = CurvePool(_pool).future_owner()\r\n\r\n    if self.pool_data[_pool].has_initial_A:\r\n        pool_params.initial_A = CurvePool(_pool).initial_A()\r\n        pool_params.initial_A_time = CurvePool(_pool).initial_A_time()\r\n        pool_params.future_A_time = CurvePool(_pool).future_A_time()\r\n\r\n    return pool_params\r\n\r\n\r\n@view\r\n@external\r\ndef get_fees(_pool: address) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Get the fees for a pool\r\n    @dev Fees are expressed as integers\r\n    @return Pool fee as uint256 with 1e10 precision\r\n            Admin fee as 1e10 percentage of pool fee\r\n    \"\"\"\r\n    return [CurvePool(_pool).fee(), CurvePool(_pool).admin_fee()]\r\n\r\n\r\n@view\r\n@external\r\ndef get_admin_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get the current admin balances (uncollected fees) for a pool\r\n    @param _pool Pool address\r\n    @return List of uint256 admin balances\r\n    \"\"\"\r\n    balances: uint256[MAX_COINS] = self._get_balances(_pool)\r\n    n_coins: uint256 = shift(self.pool_data[_pool].n_coins, -128)\r\n    for i in range(MAX_COINS):\r\n        coin: address = self.pool_data[_pool].coins[i]\r\n        if i == n_coins:\r\n            break\r\n        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            balances[i] = _pool.balance - balances[i]\r\n        else:\r\n            balances[i] = ERC20(coin).balanceOf(_pool) - balances[i]\r\n\r\n    return balances\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> (int128, int128, bool):\r\n    \"\"\"\r\n    @notice Convert coin addresses to indices for use with pool methods\r\n    @param _from Coin address to be used as `i` within a pool\r\n    @param _to Coin address to be used as `j` within a pool\r\n    @return int128 `i`, int128 `j`, boolean indicating if `i` and `j` are underlying coins\r\n    \"\"\"\r\n    result: uint256[3] = self._get_coin_indices(_pool, _from, _to)\r\n    return convert(result[0], int128), convert(result[1], int128), result[2] > 0\r\n\r\n\r\n@view\r\n@external\r\ndef estimate_gas_used(_pool: address, _from: address, _to: address) -> uint256:\r\n    \"\"\"\r\n    @notice Estimate the gas used in an exchange.\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @return Upper-bound gas estimate, in wei\r\n    \"\"\"\r\n    estimator: address = self.gas_estimate_contracts[_pool]\r\n    if estimator != ZERO_ADDRESS:\r\n        return GasEstimator(estimator).estimate_gas_used(_pool, _from, _to)\r\n\r\n    # here we call `_get_coin_indices` to find out if the exchange involves wrapped\r\n    # or underlying coins, and use the result as an index in `gas_estimate_values`\r\n    # 0 == wrapped   1 == underlying\r\n    idx_underlying: uint256 = self._get_coin_indices(_pool, _from, _to)[2]\r\n\r\n    total: uint256 = self.gas_estimate_values[_pool][idx_underlying]\r\n    assert total != 0  # dev: pool value not set\r\n\r\n    for addr in [_from, _to]:\r\n        _gas: uint256 = self.gas_estimate_values[addr][0]\r\n        assert _gas != 0  # dev: coin value not set\r\n        total += _gas\r\n\r\n    return total\r\n\r\n\r\n# internal functionality used in admin setters\r\n\r\n@internal\r\ndef _add_pool(\r\n    _sender: address,\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _lp_token: address,\r\n    _rate_method_id: bytes32,\r\n    _has_initial_A: bool,\r\n    _is_v1: bool,\r\n):\r\n    assert _sender == self.address_provider.admin()  # dev: admin-only function\r\n    assert _lp_token != ZERO_ADDRESS\r\n    assert self.pool_data[_pool].coins[0] == ZERO_ADDRESS  # dev: pool exists\r\n    assert self.get_pool_from_lp_token[_lp_token] == ZERO_ADDRESS\r\n\r\n    # add pool to pool_list\r\n    length: uint256 = self.pool_count\r\n    self.pool_list[length] = _pool\r\n    self.pool_count = length + 1\r\n    self.pool_data[_pool].location = length\r\n    self.pool_data[_pool].rate_method_id = _rate_method_id\r\n    self.pool_data[_pool].has_initial_A = _has_initial_A\r\n    self.pool_data[_pool].is_v1 = _is_v1\r\n    self.pool_data[_pool].n_coins = _n_coins\r\n\r\n    # update public mappings\r\n    self.get_pool_from_lp_token[_lp_token] = _pool\r\n    self.get_lp_token[_pool] = _lp_token\r\n\r\n    log PoolAdded(_pool, slice(_rate_method_id, 28, 4))\r\n\r\n\r\n@internal\r\ndef _get_new_pool_coins(\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _is_underlying: bool,\r\n    _is_v1: bool\r\n) -> address[MAX_COINS]:\r\n    coin_list: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    coin: address = ZERO_ADDRESS\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n        if _is_underlying:\r\n            if _is_v1:\r\n                coin = CurvePoolV1(_pool).underlying_coins(convert(i, int128))\r\n            else:\r\n                coin = CurvePool(_pool).underlying_coins(i)\r\n            self.pool_data[_pool].ul_coins[i] = coin\r\n        else:\r\n            if _is_v1:\r\n                coin = CurvePoolV1(_pool).coins(convert(i, int128))\r\n            else:\r\n                coin = CurvePool(_pool).coins(i)\r\n            self.pool_data[_pool].coins[i] = coin\r\n        coin_list[i] = coin\r\n\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n\r\n        # add pool to markets\r\n        i2: uint256 = i + 1\r\n        for x in range(i2, i2 + MAX_COINS):\r\n            if x == _n_coins:\r\n                break\r\n\r\n            key: uint256 = bitwise_xor(convert(coin_list[i], uint256), convert(coin_list[x], uint256))\r\n            length: uint256 = self.market_counts[key]\r\n            self.markets[key][length] = _pool\r\n            self.market_counts[key] = length + 1\r\n\r\n    return coin_list\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_new_pool_decimals(_coins: address[MAX_COINS], _n_coins: uint256) -> uint256:\r\n    packed: uint256 = 0\r\n    value: uint256 = 0\r\n\r\n    n_coins: int128 = convert(_n_coins, int128)\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        coin: address = _coins[i]\r\n        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            value = 18\r\n        else:\r\n            value = ERC20(coin).decimals()\r\n            assert value < 256  # dev: decimal overflow\r\n\r\n        packed += shift(value, i * 8)\r\n\r\n    return packed\r\n\r\n\r\n@internal\r\ndef _remove_market(_pool: address, _coina: address, _coinb: address):\r\n    key: uint256 = bitwise_xor(convert(_coina, uint256), convert(_coinb, uint256))\r\n    length: uint256 = self.market_counts[key] - 1\r\n    for i in range(65536):\r\n        if i > length:\r\n            break\r\n        if self.markets[key][i] == _pool:\r\n            if i < length:\r\n                self.markets[key][i] = self.markets[key][length]\r\n            self.markets[key][length] = ZERO_ADDRESS\r\n            self.market_counts[key] = length\r\n            break\r\n\r\n\r\n# admin functions\r\n\r\n@external\r\ndef add_pool(\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _lp_token: address,\r\n    _rate_method_id: bytes32,\r\n    _decimals: uint256,\r\n    _underlying_decimals: uint256,\r\n    _has_initial_A: bool,\r\n    _is_v1: bool,\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to add\r\n    @param _n_coins Number of coins in the pool\r\n    @param _lp_token Pool deposit token address\r\n    @param _rate_method_id Encoded four-byte function signature to query coin rates\r\n    @param _decimals Coin decimal values, tightly packed as uint8 in a little-endian bytes32\r\n    @param _underlying_decimals Underlying coin decimal values, tightly packed\r\n                                as uint8 in a little-endian bytes32\r\n    \"\"\"\r\n    self._add_pool(\r\n        msg.sender,\r\n        _pool,\r\n        _n_coins + shift(_n_coins, 128),\r\n        _lp_token,\r\n        _rate_method_id,\r\n        _has_initial_A,\r\n        _is_v1,\r\n    )\r\n\r\n    coins: address[MAX_COINS] = self._get_new_pool_coins(_pool, _n_coins, False, _is_v1)\r\n    decimals: uint256 = _decimals\r\n    if decimals == 0:\r\n        decimals = self._get_new_pool_decimals(coins, _n_coins)\r\n    self.pool_data[_pool].decimals = decimals\r\n\r\n    coins = self._get_new_pool_coins(_pool, _n_coins, True, _is_v1)\r\n    decimals = _underlying_decimals\r\n    if decimals == 0:\r\n        decimals = self._get_new_pool_decimals(coins, _n_coins)\r\n    self.pool_data[_pool].underlying_decimals = decimals\r\n\r\n\r\n@external\r\ndef add_pool_without_underlying(\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _lp_token: address,\r\n    _rate_method_id: bytes32,\r\n    _decimals: uint256,\r\n    _use_rates: uint256,\r\n    _has_initial_A: bool,\r\n    _is_v1: bool,\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to add\r\n    @param _n_coins Number of coins in the pool\r\n    @param _lp_token Pool deposit token address\r\n    @param _rate_method_id Encoded four-byte function signature to query coin rates\r\n    @param _decimals Coin decimal values, tightly packed as uint8 in a little-endian bytes32\r\n    @param _use_rates Boolean array indicating which coins use lending rates,\r\n                      tightly packed in a little-endian bytes32\r\n    \"\"\"\r\n    self._add_pool(\r\n        msg.sender,\r\n        _pool,\r\n        _n_coins + shift(_n_coins, 128),\r\n        _lp_token,\r\n        _rate_method_id,\r\n        _has_initial_A,\r\n        _is_v1,\r\n    )\r\n\r\n    coins: address[MAX_COINS] = self._get_new_pool_coins(_pool, _n_coins, False, _is_v1)\r\n\r\n    decimals: uint256 = _decimals\r\n    if decimals == 0:\r\n        decimals = self._get_new_pool_decimals(coins, _n_coins)\r\n    self.pool_data[_pool].decimals = decimals\r\n\r\n    udecimals: uint256 = 0\r\n    for i in range(MAX_COINS):\r\n        if i == _n_coins:\r\n            break\r\n        offset: int128 = -8 * convert(i, int128)\r\n        if shift(_use_rates, offset) % 256 == 0:\r\n            self.pool_data[_pool].ul_coins[i] = coins[i]\r\n            udecimals += shift(shift(decimals, offset) % 256, -offset)\r\n\r\n    self.pool_data[_pool].underlying_decimals = udecimals\r\n\r\n\r\n\r\n@external\r\ndef add_metapool(\r\n    _pool: address,\r\n    _n_coins: uint256,\r\n    _lp_token: address,\r\n    _decimals: uint256,\r\n):\r\n    \"\"\"\r\n    @notice Add a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to add\r\n    @param _n_coins Number of coins in the pool\r\n    @param _lp_token Pool deposit token address\r\n    @param _decimals Coin decimal values, tightly packed as uint8 in a little-endian bytes32\r\n    \"\"\"\r\n    base_coin_offset: uint256 = _n_coins - 1\r\n    base_pool: address = CurveMetapool(_pool).base_pool()\r\n    base_n_coins: uint256 = shift(self.pool_data[base_pool].n_coins, -128)\r\n    assert base_n_coins > 0  # dev: base pool unknown\r\n\r\n    self._add_pool(\r\n        msg.sender,\r\n        _pool,\r\n        base_n_coins + base_coin_offset + shift(_n_coins, 128),\r\n        _lp_token,\r\n        EMPTY_BYTES32,\r\n        True,\r\n        False,\r\n    )\r\n\r\n    coins: address[MAX_COINS] = self._get_new_pool_coins(_pool, _n_coins, False, False)\r\n\r\n    decimals: uint256 = _decimals\r\n    if decimals == 0:\r\n        decimals = self._get_new_pool_decimals(coins, _n_coins)\r\n\r\n    self.pool_data[_pool].decimals = decimals\r\n    self.pool_data[_pool].base_pool = base_pool\r\n\r\n    base_coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    coin: address = ZERO_ADDRESS\r\n    for i in range(MAX_COINS):\r\n        if i == base_n_coins + base_coin_offset:\r\n            break\r\n        if i < base_coin_offset:\r\n            coin = coins[i]\r\n        else:\r\n            x: uint256 = i - base_coin_offset\r\n            coin = self.pool_data[base_pool].coins[x]\r\n            base_coins[x] = coin\r\n        self.pool_data[_pool].ul_coins[i] = coin\r\n\r\n    underlying_decimals: uint256 = shift(\r\n        self.pool_data[base_pool].decimals, 8 * convert(base_coin_offset, int128)\r\n    )\r\n    underlying_decimals += decimals % 256 ** base_coin_offset\r\n\r\n    self.pool_data[_pool].underlying_decimals = underlying_decimals\r\n\r\n    for i in range(MAX_COINS):\r\n        if i == base_coin_offset:\r\n            break\r\n        for x in range(MAX_COINS):\r\n            if x == base_n_coins:\r\n                break\r\n            key: uint256 = bitwise_xor(convert(coins[i], uint256), convert(base_coins[x], uint256))\r\n            length: uint256 = self.market_counts[key]\r\n            self.markets[key][length] = _pool\r\n            self.market_counts[key] = length + 1\r\n\r\n\r\n@external\r\ndef remove_pool(_pool: address):\r\n    \"\"\"\r\n    @notice Remove a pool to the registry\r\n    @dev Only callable by admin\r\n    @param _pool Pool address to remove\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n    assert self.pool_data[_pool].coins[0] != ZERO_ADDRESS  # dev: pool does not exist\r\n\r\n\r\n    self.get_pool_from_lp_token[self.get_lp_token[_pool]] = ZERO_ADDRESS\r\n    self.get_lp_token[_pool] = ZERO_ADDRESS\r\n\r\n    # remove _pool from pool_list\r\n    location: uint256 = self.pool_data[_pool].location\r\n    length: uint256 = self.pool_count - 1\r\n\r\n    if location < length:\r\n        # replace _pool with final value in pool_list\r\n        addr: address = self.pool_list[length]\r\n        self.pool_list[location] = addr\r\n        self.pool_data[addr].location = location\r\n\r\n    # delete final pool_list value\r\n    self.pool_list[length] = ZERO_ADDRESS\r\n    self.pool_count = length\r\n\r\n    self.pool_data[_pool].underlying_decimals = 0\r\n    self.pool_data[_pool].decimals = 0\r\n    self.pool_data[_pool].n_coins = 0\r\n    self.pool_data[_pool].base_pool = ZERO_ADDRESS\r\n\r\n    coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    ucoins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n\r\n    for i in range(MAX_COINS):\r\n        coins[i] = self.pool_data[_pool].coins[i]\r\n        ucoins[i] = self.pool_data[_pool].ul_coins[i]\r\n        if ucoins[i] == ZERO_ADDRESS and coins[i] == ZERO_ADDRESS:\r\n            break\r\n        if coins[i] != ZERO_ADDRESS:\r\n            # delete coin address from pool_data\r\n            self.pool_data[_pool].coins[i] = ZERO_ADDRESS\r\n        if ucoins[i] != ZERO_ADDRESS:\r\n            # delete underlying_coin from pool_data\r\n            self.pool_data[_pool].ul_coins[i] = ZERO_ADDRESS\r\n\r\n    for i in range(MAX_COINS):\r\n        coin: address = coins[i]\r\n        ucoin: address = ucoins[i]\r\n        if coin == ZERO_ADDRESS:\r\n            break\r\n\r\n        # remove pool from markets\r\n        i2: uint256 = i + 1\r\n        for x in range(i2, i2 + MAX_COINS):\r\n            ucoinx: address = ucoins[x]\r\n            if ucoinx == ZERO_ADDRESS:\r\n                break\r\n\r\n            coinx: address = coins[x]\r\n            if coinx != ZERO_ADDRESS:\r\n                self._remove_market(_pool, coin, coinx)\r\n\r\n            if coin != ucoin or coinx != ucoinx:\r\n                self._remove_market(_pool, ucoin, ucoinx)\r\n\r\n    log PoolRemoved(_pool)\r\n\r\n\r\n@external\r\ndef set_pool_gas_estimates(_addr: address[5], _amount: uint256[2][5]):\r\n    \"\"\"\r\n    @notice Set gas estimate amounts\r\n    @param _addr Array of pool addresses\r\n    @param _amount Array of gas estimate amounts as `[(wrapped, underlying), ..]`\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    for i in range(5):\r\n        _pool: address = _addr[i]\r\n        if _pool == ZERO_ADDRESS:\r\n            break\r\n        self.gas_estimate_values[_pool] = _amount[i]\r\n\r\n\r\n@external\r\ndef set_coin_gas_estimates(_addr: address[10], _amount: uint256[10]):\r\n    \"\"\"\r\n    @notice Set gas estimate amounts\r\n    @param _addr Array of coin addresses\r\n    @param _amount Array of gas estimate amounts\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    for i in range(10):\r\n        _coin: address = _addr[i]\r\n        if _coin == ZERO_ADDRESS:\r\n            break\r\n        self.gas_estimate_values[_coin][0] = _amount[i]\r\n\r\n\r\n@external\r\ndef set_gas_estimate_contract(_pool: address, _estimator: address):\r\n    \"\"\"\r\n    @notice Set gas estimate contract\r\n    @param _pool Pool address\r\n    @param _estimator GasEstimator address\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    self.gas_estimate_contracts[_pool] = _estimator\r\n\r\n\r\n@external\r\ndef set_liquidity_gauges(_pool: address, _liquidity_gauges: address[10]):\r\n    \"\"\"\r\n    @notice Set liquidity gauge contracts``\r\n    @param _pool Pool address\r\n    @param _liquidity_gauges Liquidity gauge address\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    _lp_token: address = self.get_lp_token[_pool]\r\n    _gauge_controller: address = self.gauge_controller\r\n    for i in range(10):\r\n        _gauge: address = _liquidity_gauges[i]\r\n        if _gauge != ZERO_ADDRESS:\r\n            assert LiquidityGauge(_gauge).lp_token() == _lp_token  # dev: wrong token\r\n            GaugeController(_gauge_controller).gauge_types(_gauge)\r\n            self.liquidity_gauges[_pool][i] = _gauge\r\n        elif self.liquidity_gauges[_pool][i] != ZERO_ADDRESS:\r\n            self.liquidity_gauges[_pool][i] = ZERO_ADDRESS\r\n        else:\r\n            break","ABI":"[{\"name\":\"PoolAdded\",\"inputs\":[{\"type\":\"address\",\"name\":\"pool\",\"indexed\":true},{\"type\":\"bytes\",\"name\":\"rate_method_id\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PoolRemoved\",\"inputs\":[{\"type\":\"address\",\"name\":\"pool\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_address_provider\"},{\"type\":\"address\",\"name\":\"_gauge_controller\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"find_pool_for_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"find_pool_for_coins\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"i\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"get_n_coins\",\"outputs\":[{\"type\":\"uint256[2]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1704},{\"name\":\"get_coins\",\"outputs\":[{\"type\":\"address[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":12285},{\"name\":\"get_underlying_coins\",\"outputs\":[{\"type\":\"address[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":12347},{\"name\":\"get_decimals\",\"outputs\":[{\"type\":\"uint256[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8199},{\"name\":\"get_underlying_decimals\",\"outputs\":[{\"type\":\"uint256[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8261},{\"name\":\"get_rates\",\"outputs\":[{\"type\":\"uint256[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":34780},{\"name\":\"get_gauges\",\"outputs\":[{\"type\":\"address[10]\",\"name\":\"\"},{\"type\":\"int128[10]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":20310},{\"name\":\"get_balances\",\"outputs\":[{\"type\":\"uint256[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":16818},{\"name\":\"get_underlying_balances\",\"outputs\":[{\"type\":\"uint256[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":158953},{\"name\":\"get_virtual_price_from_lp_token\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_token\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2080},{\"name\":\"get_A\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1198},{\"name\":\"get_parameters\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"A\"},{\"type\":\"uint256\",\"name\":\"future_A\"},{\"type\":\"uint256\",\"name\":\"fee\"},{\"type\":\"uint256\",\"name\":\"admin_fee\"},{\"type\":\"uint256\",\"name\":\"future_fee\"},{\"type\":\"uint256\",\"name\":\"future_admin_fee\"},{\"type\":\"address\",\"name\":\"future_owner\"},{\"type\":\"uint256\",\"name\":\"initial_A\"},{\"type\":\"uint256\",\"name\":\"initial_A_time\"},{\"type\":\"uint256\",\"name\":\"future_A_time\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":6458},{\"name\":\"get_fees\",\"outputs\":[{\"type\":\"uint256[2]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1603},{\"name\":\"get_admin_balances\",\"outputs\":[{\"type\":\"uint256[8]\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":36719},{\"name\":\"get_coin_indices\",\"outputs\":[{\"type\":\"int128\",\"name\":\"\"},{\"type\":\"int128\",\"name\":\"\"},{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":27456},{\"name\":\"estimate_gas_used\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":32329},{\"name\":\"add_pool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"uint256\",\"name\":\"_n_coins\"},{\"type\":\"address\",\"name\":\"_lp_token\"},{\"type\":\"bytes32\",\"name\":\"_rate_method_id\"},{\"type\":\"uint256\",\"name\":\"_decimals\"},{\"type\":\"uint256\",\"name\":\"_underlying_decimals\"},{\"type\":\"bool\",\"name\":\"_has_initial_A\"},{\"type\":\"bool\",\"name\":\"_is_v1\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":10196577},{\"name\":\"add_pool_without_underlying\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"uint256\",\"name\":\"_n_coins\"},{\"type\":\"address\",\"name\":\"_lp_token\"},{\"type\":\"bytes32\",\"name\":\"_rate_method_id\"},{\"type\":\"uint256\",\"name\":\"_decimals\"},{\"type\":\"uint256\",\"name\":\"_use_rates\"},{\"type\":\"bool\",\"name\":\"_has_initial_A\"},{\"type\":\"bool\",\"name\":\"_is_v1\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":5590664},{\"name\":\"add_metapool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"uint256\",\"name\":\"_n_coins\"},{\"type\":\"address\",\"name\":\"_lp_token\"},{\"type\":\"uint256\",\"name\":\"_decimals\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":10226976},{\"name\":\"remove_pool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":779646579509},{\"name\":\"set_pool_gas_estimates\",\"outputs\":[],\"inputs\":[{\"type\":\"address[5]\",\"name\":\"_addr\"},{\"type\":\"uint256[2][5]\",\"name\":\"_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":355578},{\"name\":\"set_coin_gas_estimates\",\"outputs\":[],\"inputs\":[{\"type\":\"address[10]\",\"name\":\"_addr\"},{\"type\":\"uint256[10]\",\"name\":\"_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":357165},{\"name\":\"set_gas_estimate_contract\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address\",\"name\":\"_estimator\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37747},{\"name\":\"set_liquidity_gauges\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_pool\"},{\"type\":\"address[10]\",\"name\":\"_liquidity_gauges\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":365793},{\"name\":\"address_provider\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2111},{\"name\":\"gauge_controller\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2141},{\"name\":\"pool_list\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2280},{\"name\":\"pool_count\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2201},{\"name\":\"get_pool_from_lp_token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2446},{\"name\":\"get_lp_token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2476}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000000000000022d53366457f9d5e68ec105046fc43830000000000000000000000002f50d538606fa9edd2b11e2446beb18c9d5846bb","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}