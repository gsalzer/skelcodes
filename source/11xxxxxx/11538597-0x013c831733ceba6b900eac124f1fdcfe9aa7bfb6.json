{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Queue.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\nimport './interfaces/ITrading.sol';\\n\\ncontract Queue {\\n\\n    /* ========== STRUCTS ========== */\\n\\n    struct Order {\\n        address liquidator; // 20 bytes\\n        bytes12 symbol; // 12 bytes\\n        uint64 positionId; // 8 bytes\\n        uint64 margin; // 8 bytes\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // Oracle network primary address\\n    address public oracle;\\n\\n    address public trading;\\n\\n    // ID of the first order in the queue\\n    uint256 public firstOrderId;\\n\\n    // ID of the order to be queued next\\n    uint256 public nextOrderId;\\n\\n    // The order queue. Maps an order ID to its struct\\n    mapping(uint256 => Order) private queue;\\n\\n    address public owner;\\n    bool private initialized;\\n\\n    event NewContracts(address oracle, address trading);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() public {\\n        require(!initialized, '!initialized');\\n        initialized = true;\\n        owner = msg.sender;\\n        firstOrderId = 1;\\n        nextOrderId = 1;\\n    }\\n\\n    /* ========== METHODS CALLED BY GOVERNANCE ========== */\\n\\n    function registerContracts(\\n        address _oracle,\\n        address _trading\\n    ) external onlyOwner {\\n        oracle = _oracle;\\n        trading = _trading;\\n        emit NewContracts(_oracle, _trading);\\n    }\\n\\n    /**\\n     * @notice Update the oracle network primary address.\\n     * @param _oracle The oracle address\\n     */\\n\\n    /* ========== METHODS CALLED EXTERNALLY ========== */\\n\\n    /**\\n     * @notice Called by the oracle network to get queued order symbols.\\n     * @return symbols List of symbols associated with the queued orders\\n     * @return firstId The (queue) ID of the first order in the queue\\n     * @return lastId The (queue) ID of the next order in the queue\\n     */\\n    function getQueuedOrders() external view returns (\\n        bytes32[] memory symbols,\\n        uint256 firstId,\\n        uint256 lastId\\n    ) {\\n\\n        uint256 _queueLength = queueLength();\\n\\n        // Initialize return arrays\\n        symbols = new bytes32[](_queueLength);\\n\\n        if (_queueLength > 0) {\\n\\n            uint256 mFirstOrderId = firstOrderId;\\n            uint256 mNextOrderId = nextOrderId;\\n\\n            for (uint256 i = mFirstOrderId; i < mNextOrderId; i++) {\\n                symbols[i - mFirstOrderId] = bytes12(queue[i].symbol);\\n            }\\n\\n        }\\n\\n        return (\\n            symbols,\\n            firstOrderId,\\n            nextOrderId\\n        );\\n\\n    }\\n\\n    /**\\n     * @notice Called by Trading contract to queue an order for processing.\\n     * @param symbol Unique identifier of the product to trade\\n     * @param margin Margin associated with the order\\n     * @param positionId Target position ID if this order is updating an existing position\\n     * @param liquidator Liquidator's address\\n     * @return id The newly generated ID of the queued order\\n     */\\n    function queueOrder(\\n        bytes32 symbol,\\n        uint256 margin,\\n        uint256 positionId,\\n        address liquidator\\n    ) external onlyTrading returns (uint256 id) {\\n\\n        uint256 mNextOrderId = nextOrderId;\\n        require(mNextOrderId - firstOrderId < maxQueueSize(), '!full');\\n\\n        Order storage order = queue[mNextOrderId];\\n        nextOrderId = mNextOrderId + 1;\\n\\n        order.symbol = bytes12(symbol);\\n\\n        // Position update (close or liquidation)\\n        if (positionId > 0) {\\n            order.positionId = uint64(positionId);\\n            if (liquidator != address(0)) {\\n                order.liquidator = liquidator;\\n            } else {\\n                order.margin = uint64(margin);\\n            }\\n        }\\n\\n        return mNextOrderId;\\n\\n    }\\n\\n    /**\\n     * @notice Called by the oracle network to set prices and process orders in the queue.\\n     * @param prices Array of prices mapping to each order in the queue\\n     * @param firstId First ID of corresponding order in the queue\\n     * @param lastId Last ID of corresponding order in the queue\\n     */\\n    function setPricesAndProcessQueue(\\n        uint256[] calldata prices,\\n        uint256 firstId,\\n        uint256 lastId\\n    ) external onlyOracle {\\n\\n        require(firstId < lastId, '!range');\\n        require(prices.length > 0 && prices.length == (lastId - firstId), '!incompatible');\\n        require(firstId == firstOrderId, '!first_id');\\n        require(lastId <= nextOrderId, '!last_id');\\n        \\n        firstOrderId = lastId;\\n\\n        uint256 i = 0;\\n        while (firstId < lastId) {\\n\\n            Order memory order = queue[firstId];\\n            delete queue[firstId];\\n            \\n            processOrder(\\n                firstId,\\n                order,\\n                prices[i]\\n            );\\n\\n            i++;\\n            firstId++;\\n\\n        }\\n\\n    }\\n\\n    /* ========== METHODS CALLED INTERNALLY ========== */\\n\\n    /**\\n     * @notice Called internally to process an order.\\n     * @param id Position ID\\n     * @param order Order struct\\n     * @param price Price set by oracle network\\n     */\\n    function processOrder(\\n        uint256 id,\\n        Order memory order,\\n        uint256 price\\n    ) internal {\\n\\n        if (price != 0) {\\n\\n            // Price was provided by the oracle network, attempt to execute trade\\n\\n            try ITrading(trading).processOrder(\\n                id,\\n                order.symbol,\\n                price,\\n                order.margin,\\n                order.positionId,\\n                order.liquidator\\n            ) {} catch Error(string memory reason) {\\n                ITrading(trading).cancelOrder(\\n                    id,\\n                    order.positionId,\\n                    order.liquidator,\\n                    reason\\n                );\\n            } catch (bytes memory /*lowLevelData*/) {\\n                ITrading(trading).cancelOrder(\\n                    id,\\n                    order.positionId,\\n                    order.liquidator,\\n                    '!failed'\\n                );\\n            }\\n\\n        } else {\\n            // Market is closed or oracle network price is unavailable\\n            ITrading(trading).cancelOrder(\\n                id,\\n                order.positionId,\\n                order.liquidator,\\n                '!unavailable'\\n            );\\n        }\\n\\n    }\\n\\n    /* Helpers */\\n\\n    function queueLength() public view returns (uint256 length) {\\n        return nextOrderId - firstOrderId;\\n    }\\n\\n    function processedOrdersCount() external view returns (uint256 count) {\\n        return firstOrderId;\\n    }\\n\\n    function maxQueueSize() internal pure virtual returns (uint256 maxSize) {\\n        return 60;\\n    }\\n\\n    /* Modifiers */\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, '!authorized');\\n        _;\\n    }\\n\\n    modifier onlyTrading() {\\n        require(msg.sender == trading, '!authorized');\\n        _;\\n    }\\n\\n    modifier onlyOracle() {\\n        require(msg.sender == oracle, '!authorized');\\n        _;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITrading.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\ninterface ITrading {\\n\\n    function processOrder(uint256 id, bytes32 symbol, uint256 price, uint256 margin, uint256 positionId, address liquidator) external;\\n    function cancelOrder(uint256 id, uint256 positionId, address liquidator, string calldata reason) external;\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trading\",\"type\":\"address\"}],\"name\":\"NewContracts\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"firstOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQueuedOrders\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"symbols\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"firstId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processedOrdersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queueLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"queueOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trading\",\"type\":\"address\"}],\"name\":\"registerContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"firstId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastId\",\"type\":\"uint256\"}],\"name\":\"setPricesAndProcessQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trading\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Queue","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}