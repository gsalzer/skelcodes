{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*\\n*/\\npragma solidity \\u003e=0.7;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\n\\ninterface IERC20 {\\n\\n    // Optional functions\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"IUniswapV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Copied from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol\\npragma solidity \\u003e=0.7;\\n\\ninterface IUniswapV2 {\\n\\n        function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n                external payable returns (uint[] memory amounts);\\n\\n        function getAmountsIn(uint amountOut, address[] memory path)\\n                external view returns (uint[] memory amounts);\\n\\n        function getAmountsOut(uint amountIn, address[] memory path)\\n                external view returns (uint[] memory amounts);\\n        \\n        function WETH() external pure returns (address);\\n}\"},\"MarketMaker.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity \\u003e=0.7;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IUniswapV2.sol\\\";\\n\\ncontract MarketMaker is Ownable {\\n\\n    using SafeMath for uint256;\\n\\n    address public base;  // ERC-20 currency\\n    address public token; // ERC-20 share token\\n\\n    address public copyright;\\n    uint8 public licenseFeeBps; // only charged on sales, max 1% i.e. 100\\n\\n    uint256 private price; // current offer price, without drift\\n    uint256 public increment; // increment\\n\\n    uint256 public driftStart;\\n    uint256 public timeToDrift; // seconds until drift pushes price by one drift increment\\n    int256 public driftIncrement;\\n\\n    bool public buyingEnabled = true;\\n    bool public sellingEnabled = true;\\n\\n    IUniswapV2 constant uniswap = IUniswapV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n    address public weth;\\n\\n    event Trade(address indexed token, address who, bytes ref, int amount, address base, uint totPrice, uint fee, uint newprice);\\n\\n    function initialize(address baseCurrency, address shareToken) public {\\n        require(token == address(0), \\\"Already initialized.\\\");\\n        base = baseCurrency;\\n        token = shareToken;\\n        weth = uniswap.WETH();\\n        copyright = 0x29Fe8914e76da5cE2d90De98a64d0055f199d06D; // Aktionariat AG\\n        driftStart = block.timestamp;\\n    }\\n\\n    function setPrice(uint256 newPrice, uint256 newIncrement) public onlyOwner {\\n        anchorPrice(newPrice);\\n        increment = newIncrement;\\n    }\\n\\n    function hasDrift() public view returns (bool) {\\n        return timeToDrift != 0;\\n    }\\n\\n    // secondsPerStep should be negative for downwards drift\\n    function setDrift(uint256 secondsPerStep, int256 newDriftIncrement) public onlyOwner {\\n        anchorPrice(getPrice());\\n        timeToDrift = secondsPerStep;\\n        driftIncrement = newDriftIncrement;\\n    }\\n\\n    function anchorPrice(uint256 currentPrice) private {\\n        price = currentPrice;\\n        driftStart = block.timestamp;\\n    }\\n\\n    function getPrice() public view returns (uint256) {\\n        return getPrice(block.timestamp);\\n    }\\n\\n    function getPrice(uint256 timestamp) public view returns (uint256) {\\n        if (hasDrift()){\\n            uint256 passed = timestamp - driftStart;\\n            int256 drifted = int256(passed / timeToDrift) * driftIncrement;\\n            int256 driftedPrice = int256(price) + drifted;\\n            if (driftedPrice \\u003c 0){\\n                return 0;\\n            } else {\\n                return uint256(driftedPrice);\\n            }\\n        } else {\\n            return price;\\n        }\\n    }\\n\\n    function getPriceInEther(uint256 shares) public view returns (uint256) {\\n        uint256 totPrice = getBuyPrice(shares);\\n        address[] memory path = new address[](2);\\n        path[0] = weth;\\n        path[1] = base;\\n        return uniswap.getAmountsIn(totPrice, path)[0];\\n    }\\n\\n    function buyWithEther(uint256 shares, bytes calldata ref) public payable returns (uint256) {\\n        require(buyingEnabled);\\n        uint256 totPrice = getBuyPrice(shares);\\n        uint256 totPriceEth = getPriceInEther(shares);\\n        address[] memory path = new address[](2);\\n        path[0] = weth;\\n        path[1] = base;\\n        uint256[] memory amounts = uniswap.swapETHForExactTokens{value: totPriceEth}(totPrice, path, address(this), block.timestamp);\\n        assert(totPrice == amounts[1]);\\n        _buy(msg.sender, msg.sender, shares, amounts[1], ref);\\n        uint256 contractEtherBalance = address(this).balance;\\n        if (contractEtherBalance \\u003e 0){\\n            msg.sender.transfer(contractEtherBalance);\\n        }\\n        return amounts[0];\\n    }\\n\\n    function buy(uint256 numberOfSharesToBuy, bytes calldata ref) public returns (uint256) {\\n        require(buyingEnabled);\\n        return buy(msg.sender, numberOfSharesToBuy, ref);\\n    }\\n\\n    function buy(address recipient, uint256 numberOfSharesToBuy, bytes calldata ref) public returns (uint256) {\\n        require(buyingEnabled);\\n        return _buy(msg.sender, recipient, numberOfSharesToBuy, 0, ref);\\n    }\\n\\n    function _buy(address paying, address recipient, uint256 shares, uint256 alreadyPaid, bytes calldata ref) internal returns (uint256) {\\n        uint256 totPrice = getBuyPrice(shares);\\n        IERC20 baseToken = IERC20(base);\\n        if (totPrice \\u003e alreadyPaid){\\n            require(baseToken.transferFrom(paying, address(this), totPrice - alreadyPaid));\\n        } else if (totPrice \\u003c alreadyPaid){\\n            // caller paid to much, return excess amount\\n            require(baseToken.transfer(paying, alreadyPaid - totPrice));\\n        }\\n        IERC20 shareToken = IERC20(token);\\n        require(shareToken.transfer(recipient, shares));\\n        price = price.add(shares.mul(increment));\\n        emit Trade(token, paying, ref, int256(shares), base, totPrice, 0, price);\\n        return totPrice;\\n    }\\n\\n    function _notifyMoneyReceived(address from, uint256 amount, bytes calldata ref) internal {\\n        uint shares = getShares(amount);\\n        _buy(from, from, shares, amount, ref);\\n    }\\n\\n    function sell(uint256 tokens, bytes calldata ref) public returns (uint256){\\n        require(sellingEnabled);\\n        return sell(msg.sender, tokens, ref);\\n    }\\n\\n    function sell(address recipient, uint256 tokens, bytes calldata ref) public returns (uint256){\\n        require(sellingEnabled);\\n        return _sell(msg.sender, recipient, tokens, ref);\\n    }\\n\\n    function _sell(address seller, address recipient, uint256 shares, bytes calldata ref) internal returns (uint256) {\\n        IERC20 shareToken = IERC20(token);\\n        require(shareToken.transferFrom(seller, address(this), shares));\\n        return _notifyTokensReceived(recipient, shares, ref);\\n    }\\n\\n    // ERC-677 recipient\\n    function onTokenTransfer(address from, uint256 amount, bytes calldata ref) public returns (bool success) {\\n        require(msg.sender == token || msg.sender == base);\\n        if (msg.sender == token){\\n            require(sellingEnabled);\\n            _notifyTokensReceived(from, amount, ref);\\n        } else if (msg.sender == base){\\n            require(buyingEnabled);\\n            _notifyMoneyReceived(from, amount, ref);\\n        } else {\\n            require(false);\\n        }\\n        return true;\\n    }\\n\\n    function _notifyTokensReceived(address recipient, uint256 amount, bytes calldata ref) internal returns (uint256) {\\n        uint256 totPrice = getSellPrice(amount);\\n        IERC20 baseToken = IERC20(base);\\n        uint256 fee = getSaleFee(totPrice);\\n        if (fee \\u003e 0){\\n            require(baseToken.transfer(copyright, fee));\\n        }\\n        require(baseToken.transfer(recipient, totPrice - fee));\\n        price = price.sub(amount.mul(increment));\\n        emit Trade(token, recipient, ref, -int256(amount), base, totPrice, fee, price);\\n        return totPrice;\\n    }\\n\\n    function getSaleFee(uint256 totalPrice) public view returns (uint256) {\\n        return totalPrice.mul(licenseFeeBps).div(10000);\\n    }\\n\\n    function getSaleProceeds(uint256 shares) public view returns (uint256) {\\n        uint256 total = getSellPrice(shares);\\n        return total - getSaleFee(total);\\n    }\\n\\n    function getSellPrice(uint256 shares) public view returns (uint256) {\\n        return getPrice(getPrice().sub(shares.mul(increment)), shares);\\n    }\\n\\n    function getBuyPrice(uint256 shares) public view returns (uint256) {\\n        return getPrice(getPrice(), shares);\\n    }\\n\\n    function getPrice(uint256 lowest, uint256 shares) internal view returns (uint256){\\n        require(shares \\u003e= 1);\\n        uint256 highest = lowest + (shares - 1).mul(increment);\\n        return (lowest.add(highest) / 2).mul(shares);\\n    }\\n\\n    function getShares(uint256 money) public view returns (uint256) {\\n        return getShares(money, price);\\n    }\\n\\n    function getShares(uint256 money, uint256 current) internal view returns (uint256) {\\n        if (money \\u003c current){\\n            return 0;\\n        } else {\\n            uint atleast = money / (current - 1);\\n            uint newPrice = current - atleast * increment;\\n            uint paid = getPrice(newPrice, atleast);\\n            return atleast + getShares(money - paid, newPrice);\\n        }\\n    }\\n\\n    function setCopyright(address newOwner) public {\\n        require(msg.sender == copyright);\\n        copyright = newOwner;\\n    }\\n\\n    function setLicenseFee(uint8 bps) public {\\n        require(msg.sender == copyright);\\n        require(bps \\u003c= 100);\\n        licenseFeeBps = bps;\\n    }\\n\\n    function withdraw(address ercAddress, address to, uint256 amount) public onlyOwner() {\\n        IERC20 erc20 = IERC20(ercAddress);\\n        require(erc20.transfer(to, amount), \\\"Transfer failed\\\");\\n    }\\n\\n    function setEnabled(bool newBuyingEnabled, bool newSellingEnabled) public onlyOwner() {\\n        buyingEnabled = newBuyingEnabled;\\n        sellingEnabled = newSellingEnabled;\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n//\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n//\\n// Modifications:\\n// - Replaced Context._msgSender() with msg.sender\\n// - Added possibility to modify itself for multisig setup\\n// - Made leaner\\n\\npragma solidity \\u003e=0.7;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"not owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*/\\npragma solidity \\u003e=0.7;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\n\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n        return a / b;\\n    }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"ref\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newprice\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"base\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfSharesToBuy\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ref\",\"type\":\"bytes\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numberOfSharesToBuy\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ref\",\"type\":\"bytes\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ref\",\"type\":\"bytes\"}],\"name\":\"buyWithEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"copyright\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"driftIncrement\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"driftStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"getBuyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"getPriceInEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"}],\"name\":\"getSaleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"getSaleProceeds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"getSellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"getShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasDrift\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"increment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseCurrency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"shareToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"licenseFeeBps\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ref\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ref\",\"type\":\"bytes\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ref\",\"type\":\"bytes\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setCopyright\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsPerStep\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"newDriftIncrement\",\"type\":\"int256\"}],\"name\":\"setDrift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newBuyingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"newSellingEnabled\",\"type\":\"bool\"}],\"name\":\"setEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bps\",\"type\":\"uint8\"}],\"name\":\"setLicenseFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newIncrement\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToDrift\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ercAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MarketMaker","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://709630cbd26bed5b4d8dfc969e387f6f75120cb941a2723f266752e56b2c0175"}]}