{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Ownable: Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address transferOwner) public onlyOwner {\r\n        require(transferOwner != newOwner);\r\n        newOwner = transferOwner;\r\n    }\r\n\r\n    function acceptOwnership() virtual public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface INimbusReferralProgram {\r\n    function userSponsorByAddress(address user) external view returns (uint);\r\n    function userIdByAddress(address user) external view returns (uint);\r\n    function userSponsorAddressByAddress(address user) external view returns (address);\r\n}\r\n\r\ninterface INimbusStakingPool {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface INimbusRouter {\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external  view returns (uint[] memory amounts);\r\n}\r\n\r\ncontract NimbusReferralProgram is INimbusReferralProgram, Ownable {\r\n    using SafeMath for uint;\r\n\r\n    uint public lastUserId;\r\n    mapping(address => uint) public override userIdByAddress;\r\n    mapping(uint => address) public userAddressById;\r\n\r\n    uint[] public levels;\r\n    uint public maxLevel;\r\n    uint public maxLevelDepth;\r\n    uint public minTokenAmountForCheck;\r\n\r\n    mapping(uint => uint) private _userSponsor;\r\n    mapping(address => mapping(uint => uint)) private _undistributedFees;\r\n    mapping(uint => uint[]) private _userReferrals;\r\n    mapping(uint => bool) private _networkBonus;\r\n    mapping(address => uint) private _recordedBalances;\r\n    mapping(uint => mapping(uint => uint)) private _legacyBalances;\r\n    mapping(uint => mapping(uint => bool)) private _legacyBalanceStatus;\r\n\r\n    bytes32 public immutable DOMAIN_SEPARATOR;\r\n    // keccak256(\"UpdateUserAddressBySig(uint256 id,address user,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant UPDATE_ADDRESS_TYPEHASH = 0x965f73b57f3777233e641e140ef6fc17fb3dd7594d04c94df9e3bc6f8531614b;\r\n    // keccak256(\"UpdateUserDataBySig(uint256 id,address user,bytes32 refHash,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant UPDATE_DATA_TYPEHASG = 0x48b1ff889c9b587c3e7ddba4a9f57008181c3ed75eabbc6f2fefb3a62e987e95;\r\n    mapping(address => uint) public nonces;\r\n\r\n    IERC20 public immutable NBU;\r\n    INimbusRouter public swapRouter;                \r\n    INimbusStakingPool[] public stakingPools; \r\n    address public migrator;\r\n    address public specialReserveFund;\r\n    address public swapToken;                       \r\n    uint public swapTokenAmountForFeeDistributionThreshold;\r\n\r\n    event DistributeFees(address token, uint userId, uint amount);\r\n    event DistributeFeesForUser(address token, uint recipientId, uint amount);\r\n    event ClaimEarnedFunds(address token, uint userId, uint unclaimedAmount);\r\n    event TransferToNimbusSpecialReserveFund(address token, uint fromUserId, uint undistributedAmount);\r\n    event UpdateLevels(uint[] newLevels);\r\n    event UpdateSpecialReserveFund(address newSpecialReserveFund);\r\n    event MigrateUserBySign(address signatory, uint userId, address userAddress, uint nonce);\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, 'Nimbus: LOCKED');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    constructor(address migratorAddress, address nbu)  {\r\n        migrator = migratorAddress;\r\n        levels = [40, 20, 13, 10, 10, 7];\r\n        maxLevel = 6;\r\n        NBU = IERC20(nbu);\r\n\r\n        minTokenAmountForCheck = 10 * 10 ** 18;\r\n        maxLevelDepth = 25;\r\n\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(\"NimbusReferralProgram\")),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    receive() payable external {\r\n        revert();\r\n    }\r\n\r\n    modifier onlyMigrator() {\r\n        require(msg.sender == migrator, \"Nimbus Referral: caller is not the migrator\");\r\n        _;\r\n    }\r\n\r\n    function userSponsorByAddress(address user) external override view returns (uint) {\r\n        return _userSponsor[userIdByAddress[user]];\r\n    }\r\n\r\n    function userSponsor(uint user) external view returns (uint) {\r\n        return _userSponsor[user];\r\n    }\r\n\r\n    function userSponsorAddressByAddress(address user) external override view returns (address) {\r\n        uint sponsorId = _userSponsor[userIdByAddress[user]];\r\n        if (sponsorId < 1000000001) return address(0);\r\n        else return userAddressById[sponsorId];\r\n    }\r\n\r\n    function getUserReferrals(uint userId) external view returns (uint[] memory) {\r\n        return _userReferrals[userId];\r\n    }\r\n\r\n    function getUserReferrals(address user) external view returns (uint[] memory) {\r\n        return _userReferrals[userIdByAddress[user]];\r\n    }\r\n\r\n    function getLegacyBalance(uint id) external view returns (uint NBU_USDT, uint GNBU_USDT) {\r\n        NBU_USDT = _legacyBalances[id][0];\r\n        GNBU_USDT = _legacyBalances[id][1];\r\n    }\r\n\r\n    function getLegacyBalanceProcessStatus(uint id) external view returns (bool NBU_USDT, bool GNBU_USDT) {\r\n        NBU_USDT = _legacyBalanceStatus[id][0];\r\n        GNBU_USDT = _legacyBalanceStatus[id][1];\r\n    }\r\n\r\n    function undistributedFees(address token, uint userId) external view returns (uint) {\r\n        return _undistributedFees[token][userId];\r\n    }\r\n\r\n\r\n\r\n\r\n    function registerBySponsorAddress(address sponsorAddress) external returns (uint) { \r\n        return registerBySponsorId(userIdByAddress[sponsorAddress]);\r\n    }\r\n\r\n    function register() public returns (uint) {\r\n        return registerBySponsorId(1000000001);\r\n    }\r\n\r\n    function registerBySponsorId(uint sponsorId) public returns (uint) {\r\n        require(userIdByAddress[msg.sender] == 0, \"Nimbus Referral: Already registered\");\r\n        require(_userSponsor[sponsorId] != 0, \"Nimbus Referral: No such sponsor\");\r\n        \r\n        uint id = ++lastUserId; //gas saving\r\n        userIdByAddress[msg.sender] = id;\r\n        userAddressById[id] = msg.sender;\r\n        _userSponsor[id] = sponsorId;\r\n        _userReferrals[sponsorId].push(id);\r\n        return id;\r\n    }\r\n\r\n    function recordFee(address token, address recipient, uint amount) external lock { \r\n        uint actualBalance = IERC20(token).balanceOf(address(this));\r\n        require(actualBalance - amount >= _recordedBalances[token], \"Nimbus Referral: Balance check failed\");\r\n        uint uiserId = userIdByAddress[recipient];\r\n        if (_userSponsor[uiserId] == 0) uiserId = 0;\r\n        _undistributedFees[token][uiserId] = _undistributedFees[token][uiserId].add(amount);\r\n        _recordedBalances[token] = actualBalance;\r\n    }\r\n\r\n    function distributeEarnedFees(address token, uint userId) external {\r\n        distributeFees(token, userId);\r\n        uint callerId = userIdByAddress[msg.sender];\r\n        if (_undistributedFees[token][callerId] > 0) distributeFees(token, callerId);\r\n    }\r\n\r\n    function distributeEarnedFees(address token, uint[] memory userIds) external {\r\n        for (uint i; i < userIds.length; i++) {\r\n            distributeFees(token, userIds[i]);\r\n        }\r\n        \r\n        uint callerId = userIdByAddress[msg.sender];\r\n        if (_undistributedFees[token][callerId] > 0) distributeFees(token, callerId);\r\n    }\r\n\r\n    function distributeEarnedFees(address[] memory tokens, uint userId) external {\r\n        uint callerId = userIdByAddress[msg.sender];\r\n        for (uint i; i < tokens.length; i++) {\r\n            distributeFees(tokens[i], userId);\r\n            if (_undistributedFees[tokens[i]][callerId] > 0) distributeFees(tokens[i], callerId);\r\n        }\r\n    }\r\n    \r\n    function distributeFees(address token, uint userId) private {\r\n        require(_undistributedFees[token][userId] > 0, \"Undistributed fee is 0\");\r\n        uint amount = _undistributedFees[token][userId];\r\n        uint level = transferToSponsor(token, userId, amount, 0, 0); \r\n\r\n        if (level < maxLevel) {\r\n            uint undistributedPercentage;\r\n            for (uint ii = level; ii < maxLevel; ii++) {\r\n                undistributedPercentage += levels[ii];\r\n            }\r\n            uint undistributedAmount = amount * undistributedPercentage / 100;\r\n            _undistributedFees[token][0] = _undistributedFees[token][0].add(undistributedAmount);\r\n            emit TransferToNimbusSpecialReserveFund(token, userId, undistributedAmount);\r\n        }\r\n\r\n        emit DistributeFees(token, userId, amount);\r\n        _undistributedFees[token][userId] = 0;\r\n    }\r\n\r\n    function transferToSponsor(address token, uint userId, uint amount, uint level, uint levelGuard) private returns (uint) {\r\n        if (level >= maxLevel) return maxLevel;\r\n        if (levelGuard > maxLevelDepth) return level;\r\n        uint sponsorId = _userSponsor[userId];\r\n        if (sponsorId < 1000000001) return level;\r\n        address sponsorAddress = userAddressById[sponsorId];\r\n        if (isUserBalanceEnough(sponsorAddress)) {\r\n            uint bonusAmount = amount.mul(levels[level]) / 100;\r\n            TransferHelper.safeTransfer(token, sponsorAddress, bonusAmount);\r\n            _recordedBalances[token] = _recordedBalances[token].sub(bonusAmount);\r\n            emit DistributeFeesForUser(token, sponsorId, bonusAmount);\r\n            return transferToSponsor(token, sponsorId, amount, ++level, ++levelGuard);\r\n        } else {\r\n            return transferToSponsor(token, sponsorId, amount, level, ++levelGuard);\r\n        }            \r\n    }\r\n\r\n    function isUserBalanceEnough(address user) public view returns (bool) {\r\n        if (user == address(0)) return false;\r\n        uint amount = NBU.balanceOf(user);\r\n        for (uint i; i < stakingPools.length; i++) {\r\n            amount = amount.add(stakingPools[i].balanceOf(user));\r\n        }\r\n        if (amount < minTokenAmountForCheck) return false;\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(NBU);\r\n        path[1] = swapToken;\r\n        uint tokenAmount = swapRouter.getAmountsOut(amount, path)[1];\r\n        return tokenAmount >= swapTokenAmountForFeeDistributionThreshold;\r\n    }\r\n\r\n    function claimSpecialReserveFundBatch(address[] memory tokens) external {\r\n        for (uint i; i < tokens.length; i++) {\r\n            claimSpecialReserveFund(tokens[i]);\r\n        }\r\n    }\r\n\r\n    function claimSpecialReserveFund(address token) public {\r\n        uint amount = _undistributedFees[token][0]; \r\n        require(amount > 0, \"Nimbus Referral: No unclaimed funds for selected token\");\r\n        TransferHelper.safeTransfer(token, specialReserveFund, amount);\r\n        _recordedBalances[token] = _recordedBalances[token].sub(amount);\r\n        _undistributedFees[token][0] = 0;\r\n    }\r\n\r\n\r\n\r\n\r\n    function migrateUsers(uint[] memory ids, uint[] memory sponsorId, address[] memory userAddress, uint[] memory nbuUsdt) external onlyMigrator {\r\n        require(lastUserId == 0, \"Nimbus Referral: Basic migration is finished\"); \r\n        require(ids.length == sponsorId.length, \"Nimbus Referral: Different array lengths\");     \r\n        for (uint i; i < ids.length; i++) {\r\n            uint id = ids[i];\r\n            _userSponsor[id] = sponsorId[i];\r\n            if (userAddress[i] != address(0)) {\r\n                userIdByAddress[userAddress[i]] = id;\r\n                userAddressById[id] = userAddress[i];\r\n            }\r\n            if (nbuUsdt[i] > 0) _legacyBalances[id][0] = nbuUsdt[i];\r\n        }\r\n    } \r\n\r\n    function updateUserLegacyBalances(uint currencyId, uint[] memory ids, uint[] memory balances) external onlyMigrator {\r\n        require(ids.length == balances.length, \"Nimbus Referral: Different array lengths\");     \r\n        for (uint i; i < ids.length; i++) {\r\n            _legacyBalances[ids[i]][currencyId] = balances[i];\r\n        }\r\n    }\r\n\r\n    function updateUserLegacyBalanceStatuses(uint currencyId, uint[] memory ids, bool[] memory status) external onlyMigrator {\r\n        require(ids.length == status.length, \"Nimbus Referral: Different array lengths\");     \r\n        for (uint i; i < ids.length; i++) {\r\n            _legacyBalanceStatus[ids[i]][currencyId] = status[i];\r\n        }\r\n    }\r\n\r\n    function updateUserAddress(uint id, address userAddress) external onlyMigrator {\r\n        require(userAddress != address(0), \"Nimbus Referral: Address is zero\");\r\n        require(_userSponsor[id] < 1000000001, \"Nimbus Referral: No such user\");\r\n        require(userIdByAddress[userAddress] == 0, \"Nimbus Referral: Address is already in the system\");\r\n        userIdByAddress[userAddress] = id;\r\n        userAddressById[id] = userAddress;\r\n    }\r\n\r\n    function updateUserAddressBySig(uint id, address userAddress, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(block.timestamp <= deadline, \"Nimbus Referral: signature expired\");\r\n        require(userIdByAddress[userAddress] == 0, \"Nimbus Referral: Address is already in the system\");\r\n        uint nonce = nonces[userAddress]++;\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(UPDATE_ADDRESS_TYPEHASH, id, userAddress, nonce, deadline))\r\n            )\r\n        );\r\n        \r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == migrator, 'Nimbus: INVALID_SIGNATURE');\r\n        userIdByAddress[userAddress] = id;\r\n        userAddressById[id] = userAddress;\r\n        emit MigrateUserBySign(recoveredAddress, id, userAddress, nonce);\r\n    }\r\n\r\n    function updateUserDataBySig(uint id, address userAddress, uint[] memory referrals, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(block.timestamp <= deadline, \"Nimbus Referral: signature expired\");\r\n        uint nonce = nonces[userAddress]++;\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(UPDATE_DATA_TYPEHASG, id, userAddress, keccak256(abi.encodePacked(referrals)), nonce, deadline))\r\n            )\r\n        );\r\n        \r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == migrator, 'Nimbus: INVALID_SIGNATURE');\r\n        userIdByAddress[userAddress] = id;\r\n        userAddressById[id] = userAddress;\r\n        _userReferrals[id] = referrals;\r\n        emit MigrateUserBySign(recoveredAddress, id, userAddress, nonce);\r\n    }\r\n\r\n    function updateUserReferralsBySig(uint id, address userAddress, uint[] memory referrals, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(block.timestamp <= deadline, \"Nimbus Referral: signature expired\");\r\n        uint nonce = nonces[userAddress]++;\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(UPDATE_DATA_TYPEHASG, id, userAddress, keccak256(abi.encodePacked(referrals)), nonce, deadline))\r\n            )\r\n        );\r\n        \r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == migrator, 'Nimbus: INVALID_SIGNATURE');\r\n        userIdByAddress[userAddress] = id;\r\n        userAddressById[id] = userAddress;\r\n        for (uint i; i < referrals.length; i++) {\r\n            _userReferrals[id].push(referrals[i]);\r\n        }\r\n        emit MigrateUserBySign(recoveredAddress, id, userAddress, nonce);\r\n    }\r\n\r\n    function updateUserReferrals(uint id, uint[] memory referrals) external onlyMigrator {\r\n        _userReferrals[id] = referrals;\r\n        for (uint i; i < referrals.length; i++) {\r\n            _userReferrals[id].push(referrals[i]);\r\n        }\r\n    }\r\n\r\n    function updateMigrator(address newMigrator) external onlyMigrator {\r\n        require(newMigrator != address(0), \"Nimbus Referral: Address is zero\");\r\n        migrator = newMigrator;\r\n    }\r\n\r\n    function finishBasicMigration(uint userId) external onlyMigrator {\r\n        lastUserId = userId;\r\n    }\r\n\r\n\r\n\r\n\r\n    function updateSwapRouter(address newSwapRouter) external onlyOwner {\r\n        require(newSwapRouter != address(0), \"Address is zero\");\r\n        swapRouter = INimbusRouter(newSwapRouter);\r\n    }\r\n\r\n    function updateSwapToken(address newSwapToken) external onlyOwner {\r\n        require(newSwapToken != address(0), \"Address is zero\");\r\n        swapToken = newSwapToken;\r\n    }\r\n\r\n    function updateSwapTokenAmountForFeeDistributionThreshold(uint threshold) external onlyOwner {\r\n        swapTokenAmountForFeeDistributionThreshold = threshold;\r\n    }\r\n\r\n    function updateMaxLevelDepth(uint newMaxLevelDepth) external onlyOwner {\r\n        maxLevelDepth = newMaxLevelDepth;\r\n    }\r\n\r\n    function updateMinTokenAmountForCheck(uint newMinTokenAmountForCheck) external onlyOwner {\r\n        minTokenAmountForCheck = newMinTokenAmountForCheck;\r\n    }\r\n\r\n    \r\n\r\n    function updateStakingPoolAdd(address newStakingPool) external onlyOwner {\r\n        for (uint i; i < stakingPools.length; i++) {\r\n            require (address(stakingPools[i]) != newStakingPool, \"Pool exists\");\r\n        }\r\n        stakingPools.push(INimbusStakingPool(newStakingPool));\r\n    }\r\n\r\n    function updateStakingPoolRemove(uint poolIndex) external onlyOwner {\r\n        stakingPools[poolIndex] = stakingPools[stakingPools.length - 1];\r\n        stakingPools.pop();\r\n    }\r\n    \r\n    function updateSpecialReserveFund(address newSpecialReserveFund) external onlyOwner {\r\n        require(newSpecialReserveFund != address(0), \"Nimbus Referral: Address is zero\");\r\n        specialReserveFund = newSpecialReserveFund;\r\n        emit UpdateSpecialReserveFund(newSpecialReserveFund);\r\n    }\r\n\r\n    function updateLevels(uint[] memory newLevels) external onlyOwner {\r\n        uint checkSum;\r\n        for (uint i; i < newLevels.length; i++) {\r\n            checkSum += newLevels[i];\r\n        }\r\n        require(checkSum == 100, \"Nimbus Referral: Wrong levels amounts\");\r\n        levels = newLevels;\r\n        maxLevel = newLevels.length;\r\n        emit UpdateLevels(newLevels);\r\n    }\r\n}\r\n\r\n//helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        //bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        //bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        //bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"migratorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nbu\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unclaimedAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimEarnedFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recipientId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeFeesForUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"MigrateUserBySign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromUserId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"undistributedAmount\",\"type\":\"uint256\"}],\"name\":\"TransferToNimbusSpecialReserveFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"newLevels\",\"type\":\"uint256[]\"}],\"name\":\"UpdateLevels\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSpecialReserveFund\",\"type\":\"address\"}],\"name\":\"UpdateSpecialReserveFund\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NBU\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPDATE_ADDRESS_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPDATE_DATA_TYPEHASG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimSpecialReserveFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"claimSpecialReserveFundBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"userIds\",\"type\":\"uint256[]\"}],\"name\":\"distributeEarnedFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"distributeEarnedFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"distributeEarnedFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"finishBasicMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getLegacyBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"NBU_USDT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"GNBU_USDT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getLegacyBalanceProcessStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"NBU_USDT\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"GNBU_USDT\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"getUserReferrals\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserReferrals\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserBalanceEnough\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLevelDepth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sponsorId\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"userAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nbuUsdt\",\"type\":\"uint256[]\"}],\"name\":\"migrateUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokenAmountForCheck\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recordFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"register\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsorAddress\",\"type\":\"address\"}],\"name\":\"registerBySponsorAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sponsorId\",\"type\":\"uint256\"}],\"name\":\"registerBySponsorId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialReserveFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingPools\",\"outputs\":[{\"internalType\":\"contract INimbusStakingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract INimbusRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokenAmountForFeeDistributionThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"undistributedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"newLevels\",\"type\":\"uint256[]\"}],\"name\":\"updateLevels\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxLevelDepth\",\"type\":\"uint256\"}],\"name\":\"updateMaxLevelDepth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMigrator\",\"type\":\"address\"}],\"name\":\"updateMigrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinTokenAmountForCheck\",\"type\":\"uint256\"}],\"name\":\"updateMinTokenAmountForCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSpecialReserveFund\",\"type\":\"address\"}],\"name\":\"updateSpecialReserveFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStakingPool\",\"type\":\"address\"}],\"name\":\"updateStakingPoolAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolIndex\",\"type\":\"uint256\"}],\"name\":\"updateStakingPoolRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSwapRouter\",\"type\":\"address\"}],\"name\":\"updateSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSwapToken\",\"type\":\"address\"}],\"name\":\"updateSwapToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokenAmountForFeeDistributionThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"updateUserAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"updateUserAddressBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"referrals\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"updateUserDataBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"status\",\"type\":\"bool[]\"}],\"name\":\"updateUserLegacyBalanceStatuses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"name\":\"updateUserLegacyBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"referrals\",\"type\":\"uint256[]\"}],\"name\":\"updateUserReferrals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"referrals\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"updateUserReferralsBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userIdByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"user\",\"type\":\"uint256\"}],\"name\":\"userSponsor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userSponsorAddressByAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userSponsorByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"NimbusReferralProgram","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"00000000000000000000000097c4f6190042feb02daca6026aec5c06ff235f43000000000000000000000000eb58343b36c7528f23caae63a150240241310049","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f02fa63223540570d3b7d0236123c2af5bc64b63f2b9a1c28ca4307c49ae2364"}]}