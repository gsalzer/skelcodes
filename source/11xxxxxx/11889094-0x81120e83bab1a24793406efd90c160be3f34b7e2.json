{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\n\ninterface ERC20 {\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns(bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface UniswapV2Pair {\n    function token0() external returns(address _token0);\n    function token1() external returns(address _token1);\n    function mint(address to) external returns (uint liquidity);\n}\n\ncontract UniOAP {\n    \n    address owner;\n    mapping(address => bool) public authorized;\n    \n     modifier onlyAuth() {\n        require(authorized[msg.sender] == true, \"Sender must be authorized.\");\n        _;\n    }\n    \n    constructor() \n        public \n    {\n        authorized[msg.sender] = true;\n    }\n\n    function() public payable {\n       revert(\"Invalid Transaction\");\n    }\n    \n    function mintProxy(address _uniPair) onlyAuth external{\n\n        UniswapV2Pair pair = UniswapV2Pair(_uniPair);\n\n        ERC20 tokenA = ERC20(pair.token0() );\n        ERC20 tokenB = ERC20(pair.token1() );\n        \n        tokenA.transfer(_uniPair, tokenA.balanceOf(address(this)));\n        tokenB.transfer(_uniPair, tokenB.balanceOf(address(this)));\n        \n        pair.mint(msg.sender);\n        \n    }\n    \n     function failSafe(address _toUser, uint _amount) public returns (bool) {\n        require(_toUser != address(0), \"Invalid Address\");\n        require(address(this).balance >= _amount, \"Insufficient balance\");\n        (_toUser).transfer(_amount);\n        return true;\n    }\n    \n     function claimTokens(address _toUser, address _token) public {\n        if (_token == address(0)) {\n            address(uint160(_toUser)).transfer(address(this).balance);\n            return;\n        }\n        ERC20 _erc20token = ERC20(_token);\n        uint256 balance = _erc20token.balanceOf(address(this));\n        _erc20token.transfer(_toUser, balance);\n    }\n    \n    function addAuth(address _newowner, bool status) onlyAuth public  {\n       authorized[_newowner] = status;\n    }\n}\n\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_uniPair\",\"type\":\"address\"}],\"name\":\"mintProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toUser\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"failSafe\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toUser\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newowner\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"addAuth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"UniOAP","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}