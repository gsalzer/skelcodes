{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/root/oe7/contracts/OrionVaultInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\ncontract OrionVaultInterface {\\n  function getLockedStakeBalance(address user) public view returns (uint64) {\\n  }\\n  function seizeFromStake(address user, address receiver, uint64 amount) external {\\n  }\\n}\\n\"\r\n    },\r\n    \"/root/oe7/contracts/PriceOracleInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\ncontract PriceOracleInterface {\\n    struct PriceDataOut {\\n        uint64 price;\\n        uint64 timestamp;\\n    }\\n    mapping(address => PriceDataOut) public assetPrices;\\n    function givePrices(address[] calldata assetAddresses) external view returns (PriceDataOut[] memory) {\\n    }\\n}\\n\"\r\n    },\r\n    \"/root/oe7/contracts/libs/MarginalFunctionality.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\nimport \\\"../PriceOracleInterface.sol\\\";\\nimport \\\"../OrionVaultInterface.sol\\\";\\n\\n\\nlibrary MarginalFunctionality {\\n\\n    struct Liability {\\n        address asset;\\n        uint64 timestamp;\\n        uint192 outstandingAmount;\\n    }\\n\\n    enum PositionState {\\n        POSITIVE,\\n        NEGATIVE, // weighted position below 0\\n        OVERDUE,  // liability is not returned for too long\\n        NOPRICE,  // some assets has no price or expired\\n        INCORRECT // some of the basic requirements are not met:\\n                  // too many liabilities, no locked stake, etc\\n    }\\n    struct Position {\\n        PositionState state;\\n        int256 weightedPosition;\\n        int256 totalPosition;\\n        int256 totalLiabilities;\\n    }\\n\\n    function uint8Percent(int192 _a, uint8 b) internal pure returns (int192) {\\n        int a = int256(_a);\\n        int d = 255;\\n        int192 c = int192((a>65536) ? (a/d)*b : a*b/d );\\n\\n        return c;\\n    }\\n\\n    struct UsedConstants {\\n      address user;\\n      address _oracleAddress;\\n      address _orionVaultContractAddress;\\n      address _orionTokenAddress;\\n      uint64 positionOverdue;\\n      uint64 priceOverdue;\\n      uint8 stakeRisk;\\n      uint8 liquidationPremium;\\n    }\\n\\n    function calcAssets(address[] storage collateralAssets,\\n                        mapping(address => mapping(address => int192)) storage assetBalances,\\n                        mapping(address => uint8) storage assetRisks,\\n                        UsedConstants memory constants)\\n             internal view returns\\n        (bool outdated, int192 weightedPosition, int192 totalPosition) {\\n        for(uint8 i = 0; i < collateralAssets.length; i++) {\\n          address asset = collateralAssets[i];\\n          if(assetBalances[constants.user][asset]<0)\\n              continue; // will be calculated in calcLiabilities\\n          (uint64 price, uint64 timestamp) = (1e8, 0xfffffff000000000);\\n\\n          if(asset != constants._orionTokenAddress) {\\n            (price, timestamp) = PriceOracleInterface(constants._oracleAddress).assetPrices(asset);//TODO givePrices\\n          }\\n\\n          // balance: i192, price u64 => balance*price fits i256\\n          // since generally balance <= N*maxInt112 (where N is number operations with it),\\n          // assetValue <= N*maxInt112*maxUInt64/1e8.\\n          // That is if N<= 2**17 *1e8 = 1.3e13  we can neglect overflows here\\n          int192 assetValue = int192(int256(assetBalances[constants.user][asset])*price/1e8);\\n          // Overflows logic holds here as well, except that N is the number of\\n          // operations for all assets\\n          if(assetValue>0) {\\n            weightedPosition += uint8Percent(assetValue, assetRisks[asset]);\\n            totalPosition += assetValue;\\n            // if assetValue == 0  ignore outdated price\\n            outdated = outdated ||\\n                            ((timestamp + constants.priceOverdue) < block.timestamp);\\n          }\\n        }\\n        return (outdated, weightedPosition, totalPosition);\\n    }\\n\\n    function calcLiabilities(mapping(address => Liability[]) storage liabilities,\\n                             mapping(address => mapping(address => int192)) storage assetBalances,\\n                             UsedConstants memory constants\\n                             )\\n             internal view returns\\n        (bool outdated, bool overdue, int192 weightedPosition, int192 totalPosition) {\\n        for(uint8 i = 0; i < liabilities[constants.user].length; i++) {\\n          Liability storage liability = liabilities[constants.user][i];\\n          (uint64 price, uint64 timestamp) = PriceOracleInterface(constants._oracleAddress).assetPrices(liability.asset);//TODO givePrices\\n          // balance: i192, price u64 => balance*price fits i256\\n          // since generally balance <= N*maxInt112 (where N is number operations with it),\\n          // assetValue <= N*maxInt112*maxUInt64/1e8.\\n          // That is if N<= 2**17 *1e8 = 1.3e13  we can neglect overflows here\\n          int192 liabilityValue = int192(\\n                                         int256(assetBalances[constants.user][liability.asset])\\n                                         *price/1e8\\n                                        );\\n          weightedPosition += liabilityValue; //already negative since balance is negative\\n          totalPosition += liabilityValue;\\n          overdue = overdue || ((liability.timestamp + constants.positionOverdue) < block.timestamp);\\n          outdated = outdated ||\\n                          ((timestamp + constants.priceOverdue) < block.timestamp);\\n        }\\n\\n        return (outdated, overdue, weightedPosition, totalPosition);\\n    }\\n\\n    function calcPosition(\\n                        address[] storage collateralAssets,\\n                        mapping(address => Liability[]) storage liabilities,\\n                        mapping(address => mapping(address => int192)) storage assetBalances,\\n                        mapping(address => uint8) storage assetRisks,\\n                        UsedConstants memory constants\\n                        )\\n             public view returns (Position memory) {\\n        (bool outdatedPrice, int192 weightedPosition, int192 totalPosition) =\\n          calcAssets(collateralAssets,\\n                     assetBalances,\\n                     assetRisks,\\n                     constants);\\n        (bool _outdatedPrice, bool overdue, int192 _weightedPosition, int192 _totalPosition) =\\n           calcLiabilities(liabilities,\\n                           assetBalances,\\n                           constants\\n                           );\\n        uint64 lockedAmount = OrionVaultInterface(constants._orionVaultContractAddress)\\n                                  .getLockedStakeBalance(constants.user);\\n        int192 weightedStake = uint8Percent(int192(lockedAmount), constants.stakeRisk);\\n        weightedPosition += weightedStake;\\n        totalPosition += lockedAmount;\\n\\n        weightedPosition += _weightedPosition;\\n        totalPosition += _totalPosition;\\n        outdatedPrice = outdatedPrice || _outdatedPrice;\\n        bool incorrect = (liabilities[constants.user].length > 3) ||\\n                         ((liabilities[constants.user].length>0) && (lockedAmount==0));\\n        Position memory result;\\n        if(_totalPosition<0) {\\n          result.totalLiabilities = _totalPosition;\\n        }\\n        if(weightedPosition<0) {\\n          result.state = PositionState.NEGATIVE;\\n        }\\n        if(outdatedPrice) {\\n          result.state = PositionState.NOPRICE;\\n        }\\n        if(overdue) {\\n          result.state = PositionState.OVERDUE;\\n        }\\n        if(incorrect) {\\n          result.state = PositionState.INCORRECT;\\n        }\\n        result.weightedPosition = weightedPosition;\\n        result.totalPosition = totalPosition;\\n        return result;\\n    }\\n\\n    function removeLiability(address user,\\n                             address asset,\\n                             mapping(address => Liability[]) storage liabilities)\\n        public      {\\n        bool shift = false;\\n        uint8 i;\\n        for(; i<liabilities[user].length-1; i++) {\\n          if(liabilities[user][i].asset == asset) {\\n            shift = true;\\n          }\\n          if(shift)\\n            liabilities[user][i] = liabilities[user][i+1];\\n        }\\n        if(liabilities[user][i].asset == asset) {\\n            shift = true;\\n        }\\n        if(shift)\\n          liabilities[user].pop();\\n    }\\n\\n    function updateLiability(address user,\\n                             address asset,\\n                             mapping(address => Liability[]) storage liabilities,\\n                             uint112 depositAmount,\\n                             int192 currentBalance)\\n        public      {\\n        uint8 i;\\n        for(; i<liabilities[user].length-1; i++) {\\n            if(liabilities[user][i].asset == asset)\\n              break;\\n          }\\n        Liability storage liability = liabilities[user][i];\\n        if(depositAmount>=liability.outstandingAmount) {\\n          if(currentBalance>=0) {\\n            removeLiability(user,asset,liabilities);\\n          }\\n          else {\\n            liability.outstandingAmount = uint192(-currentBalance);\\n            liability.timestamp = uint64(block.timestamp);\\n          }\\n        } else {\\n            liability.outstandingAmount -= depositAmount;\\n        }\\n    }\\n\\n    function partiallyLiquidate(address[] storage collateralAssets,\\n                                mapping(address => Liability[]) storage liabilities,\\n                                mapping(address => mapping(address => int192)) storage assetBalances,\\n                                mapping(address => uint8) storage assetRisks,\\n                                UsedConstants memory constants,\\n                                address redeemedAsset,\\n                                uint112 amount) public {\\n        //Note: constants.user - is broker who will be liquidated\\n        Position memory initialPosition = calcPosition(collateralAssets,\\n                                           liabilities,\\n                                           assetBalances,\\n                                           assetRisks,\\n                                           constants);\\n        require(initialPosition.state == PositionState.NEGATIVE ||\\n                initialPosition.state == PositionState.OVERDUE  , \\\"E7\\\");\\n        address liquidator = msg.sender;\\n        require(assetBalances[liquidator][redeemedAsset]>=amount,\\\"E8\\\");\\n        assetBalances[liquidator][redeemedAsset] -= amount;\\n        assetBalances[constants.user][redeemedAsset] += amount;\\n        (uint64 price, uint64 timestamp) = PriceOracleInterface(constants._oracleAddress).assetPrices(redeemedAsset);\\n        require((timestamp + constants.priceOverdue) > block.timestamp, \\\"E9\\\"); //Price is outdated\\n\\n        int64 orionAmount = reimburseLiquidator(amount, price, liquidator, assetBalances, constants);\\n        assetBalances[liquidator][constants._orionTokenAddress] += orionAmount;\\n        Position memory finalPosition = calcPosition(collateralAssets,\\n                                           liabilities,\\n                                           assetBalances,\\n                                           assetRisks,\\n                                           constants);\\n        require( int(finalPosition.state)<3 && //POSITIVE,NEGATIVE or OVERDUE\\n                 (finalPosition.weightedPosition>initialPosition.weightedPosition),\\n                 \\\"E10\\\");//Incorrect state position after liquidation\\n       if(finalPosition.state == PositionState.POSITIVE)\\n         require (finalPosition.weightedPosition<10e8,\\\"Can not liquidate to very positive state\\\");\\n\\n    }\\n\\n    function reimburseLiquidator(\\n                       uint112 amount,\\n                       uint64 price,\\n                       address liquidator,\\n                       mapping(address => mapping(address => int192)) storage assetBalances,\\n                       UsedConstants memory constants)\\n             internal\\n             returns (int64 orionAmount) {\\n        int192 _orionAmount = int192(int256(amount)*price/1e8);\\n        _orionAmount += uint8Percent(_orionAmount,constants.liquidationPremium); //Liquidation premium\\n        require(_orionAmount == int64(_orionAmount), \\\"E11\\\");\\n        orionAmount = int64(_orionAmount);\\n        // There is only 100m Orion tokens, fits i64\\n        int64 onBalanceOrion = int64(assetBalances[constants.user][constants._orionTokenAddress]);\\n        (int64 fromBalance, int64 fromStake) = (onBalanceOrion>orionAmount)?\\n                                                 (orionAmount, 0) :\\n                                                 (onBalanceOrion>0)?\\n                                                   (onBalanceOrion, orionAmount-onBalanceOrion) :\\n                                                   (0, orionAmount);\\n\\n        if(fromBalance>0) {\\n          assetBalances[constants.user][constants._orionTokenAddress] -= int192(fromBalance);\\n        }\\n        if(fromStake>0) {\\n          OrionVaultInterface(constants._orionVaultContractAddress).seizeFromStake(constants.user, liquidator, uint64(orionAmount));\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[]","ContractName":"MarginalFunctionality","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}