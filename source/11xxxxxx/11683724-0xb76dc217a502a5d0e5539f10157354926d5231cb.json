{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NestDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"./lib/SafeMath.sol\\\";\\nimport \\\"./lib/TransferHelper.sol\\\";\\nimport \\\"./lib/ReentrancyGuard.sol\\\";\\n\\n\\nimport \\\"./iface/INestMining.sol\\\";\\nimport \\\"./iface/INToken.sol\\\";\\nimport \\\"./iface/INestPool.sol\\\";\\nimport \\\"./iface/INestDAO.sol\\\";\\nimport \\\"./iface/INestStaking.sol\\\";\\nimport \\\"./iface/INestQuery.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\n/// @dev The contract is for redeeming nest token and getting ETH in return\\ncontract NestDAO is INestDAO, ReentrancyGuard {\\n\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE ============== */\\n\\n    uint8 public flag; \\n\\n    /// @dev the block height where DAO was started\\n    uint32  public startedBlock;\\n    uint32  public lastCollectingBlock;\\n    uint184 private _reserved;\\n\\n    uint8 constant DAO_FLAG_UNINITIALIZED    = 0;\\n    uint8 constant DAO_FLAG_INITIALIZED      = 1;\\n    uint8 constant DAO_FLAG_ACTIVE           = 2;\\n    uint8 constant DAO_FLAG_NO_STAKING       = 3;\\n    uint8 constant DAO_FLAG_PAUSED           = 4;\\n    uint8 constant DAO_FLAG_SHUTDOWN         = 127;\\n\\n    struct Ledger {\\n        uint128 rewardedAmount;\\n        uint128 redeemedAmount;\\n        uint128 quotaAmount;\\n        uint32  lastBlock;\\n        uint96  _reserved;\\n    }\\n\\n    /// @dev Mapping from ntoken => amount (of ntokens owned by DAO)\\n    mapping(address => Ledger) public ntokenLedger;\\n\\n    /// @dev Mapping from ntoken => amount (of ethers owned by DAO)\\n    mapping(address => uint256) public ethLedger;\\n\\n    /* ========== PARAMETERS ============== */\\n\\n    uint256 public ntokenRepurchaseThreshold;\\n    uint256 public collectInterval;\\n\\n    uint256 constant DAO_REPURCHASE_PRICE_DEVIATION = 5;  // price deviation < 5% \\n    uint256 constant DAO_REPURCHASE_NTOKEN_TOTALSUPPLY = 5_000_000;  // total supply > 5 million \\n\\n    uint256 constant DAO_COLLECT_INTERVAL = 5_760;  // 24 hour * 60 min * 4 block/min ~= 1 day\\n\\n    uint256 constant _ethFee = 0.01 ether;\\n\\n    /* ========== ADDRESSES ============== */\\n\\n    address public governance;\\n\\n    address private C_NestPool;\\n    address private C_NestToken;\\n    address private C_NestMining;\\n    address private C_NestStaking;\\n    address private C_NestQuery;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    receive() external payable {}\\n\\n    // NOTE: to support open-zeppelin/upgrades, leave it blank\\n    constructor() public { }\\n\\n    /// @dev It is called by the proxy (open-zeppelin/upgrades), only ONCE!\\n    function initialize(address NestPool) external \\n    {\\n        require(flag == DAO_FLAG_UNINITIALIZED, \\\"Nest:DAO:!flag\\\");\\n        governance = msg.sender;\\n        flag = DAO_FLAG_INITIALIZED;\\n        C_NestPool = NestPool;\\n        ntokenRepurchaseThreshold = DAO_REPURCHASE_NTOKEN_TOTALSUPPLY;\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyGovernance() \\n    {\\n        require(msg.sender == governance, \\\"Nest:DAO:!governance\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovOrBy(address _contract) \\n    {\\n        require(msg.sender == governance || msg.sender == _contract, \\\"Nest:DAO:!sender\\\");\\n        _;\\n    }\\n\\n    modifier whenActive() \\n    {\\n        require(flag == DAO_FLAG_ACTIVE, \\\"Nest:DAO:!flag\\\");\\n        _;\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    /// @dev Ensure that all governance-addresses be consistent with each other\\n    function loadGovernance() override external \\n    { \\n        governance = INestPool(C_NestPool).governance();\\n    }\\n\\n    /// @dev The function loads all nest-contracts, it is supposed to be called by NestPool\\n    function loadContracts() override external onlyGovOrBy(C_NestPool)\\n    {\\n        C_NestToken = INestPool(C_NestPool).addrOfNestToken();\\n        C_NestStaking = INestPool(C_NestPool).addrOfNestStaking();\\n        C_NestQuery = INestPool(C_NestPool).addrOfNestQuery();\\n        C_NestMining = INestPool(C_NestPool).addrOfNestMining();\\n    }\\n\\n    function start() override external onlyGovernance\\n    {  \\n        require(flag == DAO_FLAG_INITIALIZED, \\\"Nest:DAO:!flag\\\");\\n        ERC20(C_NestToken).approve(C_NestStaking, uint(-1));\\n        startedBlock = uint32(block.number);\\n        lastCollectingBlock = uint32(block.number);\\n        flag = DAO_FLAG_ACTIVE;\\n        collectInterval = DAO_COLLECT_INTERVAL;\\n        emit FlagSet(address(msg.sender), uint256(DAO_FLAG_ACTIVE));\\n    }\\n\\n    /// @dev Stop service for emergency\\n    function pause() external onlyGovernance\\n    {\\n        require(flag == DAO_FLAG_ACTIVE, \\\"Nest:DAO:!flag\\\");\\n        flag = DAO_FLAG_PAUSED;\\n        emit FlagSet(address(msg.sender), uint256(DAO_FLAG_PAUSED));\\n    }\\n\\n    /// @dev Resume service \\n    function resume() external onlyGovernance\\n    {\\n        require(flag == DAO_FLAG_ACTIVE || flag == DAO_FLAG_PAUSED, \\\"Nest:DAO:!flag\\\");\\n        flag = DAO_FLAG_ACTIVE;\\n        emit FlagSet(address(msg.sender), uint256(DAO_FLAG_ACTIVE));\\n    }\\n\\n    function setParams(uint256 _ntokenRepurchaseThreshold, uint256 _collectInterval) external onlyGovernance\\n    {\\n        emit ParamsSetup(address(msg.sender), ntokenRepurchaseThreshold, _ntokenRepurchaseThreshold);\\n        ntokenRepurchaseThreshold = _ntokenRepurchaseThreshold;\\n        emit ParamsSetup(address(msg.sender), collectInterval, _collectInterval);\\n        collectInterval = _collectInterval;\\n    }\\n\\n    function totalETHRewards(address ntoken)\\n        external view returns (uint256) \\n    {\\n       return  ethLedger[ntoken];\\n    }\\n\\n    /// @notice Migrate ethers to a new NestDAO\\n    /// @param newDAO_ The address of the new contract\\n    /// @param ntokenL_ The list of ntokens whose ethers are going to be migrated\\n    function migrateTo(address newDAO_, address[] memory ntokenL_) external onlyGovernance\\n    {\\n        require(flag == DAO_FLAG_PAUSED, \\\"Nest:DAO:!flag\\\");\\n        uint256 _len = ntokenL_.length;\\n        for (uint256 i; i < _len; i++) {\\n            address _ntoken = ntokenL_[i];\\n            uint256 _blncs = ethLedger[_ntoken];\\n\\n            INestDAO(newDAO_).addETHReward{value:_blncs}(_ntoken);\\n            \\n            ethLedger[_ntoken] = 0;\\n\\n            uint256 _staked = INestStaking(C_NestStaking).stakedBalanceOf(_ntoken, address(this));\\n            if (_staked > 0) {\\n                INestStaking(C_NestStaking).unstake(_ntoken, _staked);\\n            }\\n\\n            uint256 _ntokenAmount = ERC20(_ntoken).balanceOf(address(this));\\n\\n            if (_ntokenAmount > 0) {\\n                ERC20(_ntoken).transfer(newDAO_, _ntokenAmount);\\n\\n            }\\n        }\\n    }\\n\\n    /// @dev The function shall be called when ethers are taken from Nestv3.0\\n    function initEthLedger(address ntoken, uint256 amount) \\n        override external\\n        onlyGovernance \\n    {\\n        require (flag == DAO_FLAG_INITIALIZED, \\\"Nest:DAO:!flag\\\");\\n        ethLedger[ntoken] = amount;\\n\\n    }\\n\\n    /* ========== MAIN ========== */\\n\\n    /// @notice Pump eth rewards to NestDAO for repurchasing `ntoken`\\n    /// @param ntoken The address of ntoken in the ether Ledger\\n    function addETHReward(address ntoken) \\n        override\\n        external\\n        payable\\n    {\\n        ethLedger[ntoken] = ethLedger[ntoken].add(msg.value);\\n    }\\n\\n    /// @dev Called by NestMining\\n    function addNestReward(uint256 amount) \\n        override \\n        external \\n        onlyGovOrBy(C_NestMining)\\n    {\\n        Ledger storage it = ntokenLedger[C_NestToken];\\n        it.rewardedAmount = uint128(uint256(it.rewardedAmount).add(amount));\\n    }\\n\\n    /// @dev Collect ethers from NestPool\\n    function collectNestReward() public returns(uint256)\\n    {\\n        // withdraw NEST from NestPool (mined by miners)\\n        uint256 nestAmount = INestPool(C_NestPool).balanceOfTokenInPool(address(this), C_NestToken);\\n        if (nestAmount == 0) {\\n            return 0;\\n        }\\n\\n        INestPool(C_NestPool).withdrawNest(address(this), nestAmount);\\n\\n        return nestAmount;\\n    }\\n\\n\\n    /// @dev Collect ethers from NestStaking\\n    function collectETHReward(address ntoken) public returns (uint256)\\n    {\\n        // check if ntoken is a NTOKEN\\n        address _ntoken = INestPool(C_NestPool).getNTokenFromToken(ntoken);\\n        require (_ntoken == ntoken, \\\"Nest:DAO:!ntoken\\\");\\n\\n        uint256 ntokenAmount = ERC20(ntoken).balanceOf(address(this));\\n\\n        // if (ntokenAmount == 0) {\\n        //     return 0;\\n        // }\\n        // // stake new NEST/NTOKENs into StakingPool\\n        // INestStaking(C_NestStaking).stake(ntoken, ntokenAmount);\\n\\n        if (ntokenAmount != 0) {\\n            // stake new NEST/NTOKENs into StakingPool\\n            INestStaking(C_NestStaking).stake(ntoken, ntokenAmount);\\n        }\\n\\n        // claim rewards from StakingPool \\n        uint256 _rewards = INestStaking(C_NestStaking).claim(ntoken);\\n        ethLedger[ntoken] = ethLedger[ntoken].add(_rewards);\\n\\n        return _rewards;\\n    }\\n\\n    function _collect(address ntoken) internal\\n    {\\n        if (block.number < uint256(lastCollectingBlock).add(collectInterval)) {\\n            return;\\n        }\\n\\n        uint256 ethAmount = collectETHReward(ntoken);\\n        \\n        uint256 nestAmount = collectNestReward();\\n        \\n        lastCollectingBlock = uint32(block.number);\\n        emit AssetsCollected(address(msg.sender), ethAmount, nestAmount);\\n    }\\n\\n    /// @dev Redeem ntokens for ethers\\n    function redeem(address ntoken, uint256 amount) \\n        external payable nonReentrant whenActive\\n    {\\n        // check if ntoken is a NTOKEN\\n        address _ntoken = INestPool(C_NestPool).getNTokenFromToken(ntoken);\\n        require (_ntoken == ntoken, \\\"Nest:DAO:!ntoken\\\");\\n\\n        require (msg.value >= _ethFee, \\\"Nest:DAO:!ethFee\\\");\\n\\n        require(INToken(ntoken).totalSupply() >= ntokenRepurchaseThreshold, \\\"Nest:DAO:!total\\\");\\n\\n        // check if there is sufficient ethers for repurchase\\n        uint256 bal = ethLedger[ntoken];\\n        require(bal > 0, \\\"Nest:DAO:!bal\\\");\\n\\n        // check the repurchasing quota\\n        uint256 quota = quotaOf(ntoken);\\n\\n        // check if the price is steady\\n        uint256 price;\\n        bool isDeviated;\\n        \\n        \\n        {\\n            (uint256 ethAmount, uint256 tokenAmount,) = INestMining(C_NestMining).latestPriceOf(ntoken);\\n            (, uint256 avg, ,) = INestMining(C_NestMining).priceAvgAndSigmaOf(ntoken);\\n            price = tokenAmount.mul(1e18).div(ethAmount);\\n\\n            uint256 diff = price > avg? (price - avg) : (avg - price);\\n            isDeviated = (diff.mul(100) < avg.mul(DAO_REPURCHASE_PRICE_DEVIATION))? false : true;\\n\\n            if(msg.value > _ethFee){\\n                TransferHelper.safeTransferETH(msg.sender, msg.value.sub(_ethFee));\\n            }\\n            this.addETHReward{value:_ethFee}(address(ntoken));\\n\\n        }\\n\\n        require(isDeviated == false, \\\"Nest:DAO:!price\\\");\\n\\n        // check if there is sufficient quota for repurchase\\n        require (amount <= quota, \\\"Nest:DAO:!quota\\\");\\n        // amount.mul(1e18).div(price) < bal\\n        require (amount.mul(1e18) <= bal.mul(price), \\\"Nest:DAO:!bal2\\\");\\n\\n        // update the ledger\\n        Ledger memory it = ntokenLedger[ntoken];\\n\\n        it.redeemedAmount = uint128(amount.add(it.redeemedAmount));\\n        it.quotaAmount = uint128(quota.sub(amount));\\n        it.lastBlock = uint32(block.number);\\n        ntokenLedger[ntoken] = it;\\n\\n        // transactions\\n        ethLedger[ntoken] = ethLedger[ntoken].sub(amount.mul(1e18).div(price));\\n\\n        ERC20(ntoken).transferFrom(address(msg.sender), address(this), amount);\\n        TransferHelper.safeTransferETH(msg.sender, amount.mul(1e18).div(price));\\n\\n        _collect(ntoken); \\n    }\\n\\n    // function _price(address ntoken) internal view \\n    //     returns (uint256 price, uint256 avg, bool isDeviated)\\n    // {\\n    //     (price, avg, , ) = \\n    //         INestQuery(C_NestQuery).queryPriceAvgVola(ntoken, );\\n    //     uint256 diff = price > avg? (price - avg) : (avg - price);\\n    //     isDeviated = (diff.mul(100) < avg.mul(DAO_REPURCHASE_PRICE_DEVIATION))? false : true;\\n    // }\\n\\n    function _quota(address ntoken) internal view returns (uint256 quota) \\n    {\\n        if (INToken(ntoken).totalSupply() < ntokenRepurchaseThreshold) {\\n            return 0;\\n        }\\n\\n        //  calculate the accumulated amount of NEST/NTOKEN available to repurchasing\\n        Ledger memory it = ntokenLedger[ntoken];\\n        uint256 _acc;\\n        uint256 n;\\n        if(ntoken == C_NestToken){\\n             n = 1000;\\n            uint256 intv = (it.lastBlock == 0) ? \\n                (block.number).sub(startedBlock) : (block.number).sub(uint256(it.lastBlock));\\n            _acc = (n * intv > 300_000)? 300_000 : (n * intv);\\n        }else{\\n            n = 10;\\n            uint256 intv = (it.lastBlock == 0) ? \\n                (block.number).sub(startedBlock) : (block.number).sub(uint256(it.lastBlock));\\n            _acc = (n * intv > 3000)? 3000 : (n * intv);\\n        }\\n\\n        uint256 total;\\n         total = _acc.mul(1e18).add(it.quotaAmount);\\n        if(ntoken == C_NestToken){\\n            if(total > uint256(300_000).mul(1e18)){\\n                quota = uint256(300_000).mul(1e18);\\n            }else{\\n                quota = total;\\n            }   \\n        }else{\\n            if(total > uint256(3000).mul(1e18)){\\n                quota = uint256(3000).mul(1e18);\\n            }else{\\n                quota = total;\\n            }   \\n        }\\n        \\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function quotaOf(address ntoken) public view returns (uint256 quota) \\n    {\\n       // check if ntoken is a NTOKEN\\n        address _ntoken = INestPool(C_NestPool).getNTokenFromToken(ntoken);\\n        require (_ntoken == ntoken, \\\"Nest:DAO:!ntoken\\\");\\n\\n        return _quota(ntoken);\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n\\n    function div(uint x, uint y) internal pure returns (uint z) {\\n        require(y > 0, \\\"ds-math-div-zero\\\");\\n        z = x / y;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/// @dev The non-empty constructor is conflict with upgrades-openzeppelin. \\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n\\n    // NOTE: _NOT_ENTERED is set to ZERO such that it needn't constructor\\n    uint256 private constant _NOT_ENTERED = 0;\\n    uint256 private constant _ENTERED = 1;\\n\\n    uint256 private _status;\\n\\n    // constructor () internal {\\n    //     _status = _NOT_ENTERED;\\n    // }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\"\r\n    },\r\n    \"contracts/iface/INestMining.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\n\\n\\ninterface INestMining {\\n    \\n    struct Params {\\n        uint8    miningEthUnit;     // = 10;\\n        uint32   nestStakedNum1k;   // = 1;\\n        uint8    biteFeeRate;       // = 1; \\n        uint8    miningFeeRate;     // = 10;\\n        uint8    priceDurationBlock; \\n        uint8    maxBiteNestedLevel; // = 3;\\n        uint8    biteInflateFactor;\\n        uint8    biteNestInflateFactor;\\n    }\\n\\n    function priceOf(address token) external view returns(uint256 ethAmount, uint256 tokenAmount, uint256 bn);\\n    \\n    function priceListOfToken(address token, uint8 num) external view returns(uint128[] memory data, uint256 bn);\\n\\n    // function priceOfTokenAtHeight(address token, uint64 atHeight) external view returns(uint256 ethAmount, uint256 tokenAmount, uint64 bn);\\n\\n    function latestPriceOf(address token) external view returns (uint256 ethAmount, uint256 tokenAmount, uint256 bn);\\n\\n    function priceAvgAndSigmaOf(address token) \\n        external view returns (uint128, uint128, int128, uint32);\\n\\n    function minedNestAmount() external view returns (uint256);\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n    \\n    function loadGovernance() external;\\n\\n    function upgrade() external;\\n\\n    function setup(uint32   genesisBlockNumber, uint128  latestMiningHeight, uint128  minedNestTotalAmount, Params calldata initParams) external;\\n\\n    function setParams1(uint128  latestMiningHeight, uint128  minedNestTotalAmount) external;\\n}\"\r\n    },\r\n    \"contracts/iface/INToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\ninterface INToken {\\n    // mint ntoken for value\\n    function mint(uint256 amount, address account) external;\\n\\n    // the block height where the ntoken was created\\n    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\\n    // the owner (auction winner) of the ntoken\\n    function checkBidder() external view returns(address);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INestPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"../lib/SafeERC20.sol\\\";\\n\\ninterface INestPool {\\n\\n    // function getNTokenFromToken(address token) view external returns (address);\\n    // function setNTokenToToken(address token, address ntoken) external; \\n\\n    function addNest(address miner, uint256 amount) external;\\n    function addNToken(address contributor, address ntoken, uint256 amount) external;\\n\\n    function depositEth(address miner) external payable;\\n    function depositNToken(address miner,  address from, address ntoken, uint256 amount) external;\\n\\n    function freezeEth(address miner, uint256 ethAmount) external; \\n    function unfreezeEth(address miner, uint256 ethAmount) external;\\n\\n    function freezeNest(address miner, uint256 nestAmount) external;\\n    function unfreezeNest(address miner, uint256 nestAmount) external;\\n\\n    function freezeToken(address miner, address token, uint256 tokenAmount) external; \\n    function unfreezeToken(address miner, address token, uint256 tokenAmount) external;\\n\\n    function freezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n    function unfreezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n\\n    function getNTokenFromToken(address token) external view returns (address); \\n    function setNTokenToToken(address token, address ntoken) external; \\n\\n    function withdrawEth(address miner, uint256 ethAmount) external;\\n    function withdrawToken(address miner, address token, uint256 tokenAmount) external;\\n\\n    function withdrawNest(address miner, uint256 amount) external;\\n    function withdrawEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\\n    // function withdrawNToken(address miner, address ntoken, uint256 amount) external;\\n    function withdrawNTokenAndTransfer(address miner, address ntoken, uint256 amount, address to) external;\\n\\n\\n    function balanceOfNestInPool(address miner) external view returns (uint256);\\n    function balanceOfEthInPool(address miner) external view returns (uint256);\\n    function balanceOfTokenInPool(address miner, address token)  external view returns (uint256);\\n\\n    function addrOfNestToken() external view returns (address);\\n    function addrOfNestMining() external view returns (address);\\n    function addrOfNTokenController() external view returns (address);\\n    function addrOfNNRewardPool() external view returns (address);\\n    function addrOfNNToken() external view returns (address);\\n    function addrOfNestStaking() external view returns (address);\\n    function addrOfNestQuery() external view returns (address);\\n    function addrOfNestDAO() external view returns (address);\\n\\n    function addressOfBurnedNest() external view returns (address);\\n\\n    function setGovernance(address _gov) external; \\n    function governance() external view returns(address);\\n    function initNestLedger(uint256 amount) external;\\n    function drainNest(address to, uint256 amount, address gov) external;\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INestDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\ninterface INestDAO {\\n\\n    function addETHReward(address ntoken) external payable; \\n\\n    function addNestReward(uint256 amount) external;\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external;\\n    \\n    /// @dev Only for governance\\n    function start() external; \\n\\n    function initEthLedger(address ntoken, uint256 amount) external;\\n\\n    event NTokenRedeemed(address ntoken, address user, uint256 amount);\\n\\n    event AssetsCollected(address user, uint256 ethAmount, uint256 nestAmount);\\n\\n    event ParamsSetup(address gov, uint256 oldParam, uint256 newParam);\\n\\n    event FlagSet(address gov, uint256 flag);\\n\\n}\"\r\n    },\r\n    \"contracts/iface/INestStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n\\ninterface INestStaking {\\n    // Views\\n\\n    /// @dev How many stakingToken (XToken) deposited into to this reward pool (staking pool)\\n    /// @param  ntoken The address of NToken\\n    /// @return The total amount of XTokens deposited in this staking pool\\n    function totalStaked(address ntoken) external view returns (uint256);\\n\\n    /// @dev How many stakingToken (XToken) deposited by the target account\\n    /// @param  ntoken The address of NToken\\n    /// @param  account The target account\\n    /// @return The total amount of XToken deposited in this staking pool\\n    function stakedBalanceOf(address ntoken, address account) external view returns (uint256);\\n\\n\\n    // Mutative\\n    /// @dev Stake/Deposit into the reward pool (staking pool)\\n    /// @param  ntoken The address of NToken\\n    /// @param  amount The target amount\\n    function stake(address ntoken, uint256 amount) external;\\n\\n    function stakeFromNestPool(address ntoken, uint256 amount) external;\\n\\n    /// @dev Withdraw from the reward pool (staking pool), get the original tokens back\\n    /// @param  ntoken The address of NToken\\n    /// @param  amount The target amount\\n    function unstake(address ntoken, uint256 amount) external;\\n\\n    /// @dev Claim the reward the user earned\\n    /// @param ntoken The address of NToken\\n    /// @return The amount of ethers as rewards\\n    function claim(address ntoken) external returns (uint256);\\n\\n    /// @dev Add ETH reward to the staking pool\\n    /// @param ntoken The address of NToken\\n    function addETHReward(address ntoken) external payable;\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external; \\n\\n    function pause() external;\\n\\n    function resume() external;\\n\\n    //function setParams(uint8 dividendShareRate) external;\\n\\n    /* ========== EVENTS ========== */\\n\\n    // Events\\n    event RewardAdded(address ntoken, address sender, uint256 reward);\\n    event NTokenStaked(address ntoken, address indexed user, uint256 amount);\\n    event NTokenUnstaked(address ntoken, address indexed user, uint256 amount);\\n    event SavingWithdrawn(address ntoken, address indexed to, uint256 amount);\\n    event RewardClaimed(address ntoken, address indexed user, uint256 reward);\\n\\n    event FlagSet(address gov, uint256 flag);\\n}\"\r\n    },\r\n    \"contracts/iface/INestQuery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.6.12;\\n\\n/// @title The interface of NestQuery\\n/// @author Inf Loop - <inf-loop@nestprotocol.org>\\n/// @author Paradox  - <paradox@nestprotocol.org>\\ninterface INestQuery {\\n\\n    /// @notice Activate a pay-per-query defi client with NEST tokens\\n    /// @dev No contract is allowed to call it\\n    /// @param defi The addres of client (DeFi DApp)\\n    function activate(address defi) external;\\n\\n    /// @notice Deactivate a pay-per-query defi client\\n    /// @param defi The address of a client (DeFi DApp)\\n    function deactivate(address defi) external;\\n\\n    /// @notice Query for PPQ (pay-per-query) clients\\n    /// @dev Consider that if a user call a DeFi that queries NestQuery, DeFi should\\n    ///     pass the user's wallet address to query() as `payback`.\\n    /// @param token The address of token contract\\n    /// @param payback The address of change\\n    function query(address token, address payback) \\n        external payable returns (uint256, uint256, uint256);\\n\\n    /// @notice Query for PPQ (pay-per-query) clients\\n    /// @param token The address of token contract\\n    /// @param payback The address of change\\n    /// @return ethAmount The amount of ETH in pair (ETH, TOKEN)\\n    /// @return tokenAmount The amount of TOKEN in pair (ETH, TOKEN)\\n    /// @return avgPrice The average of last 50 prices \\n    /// @return vola The volatility of prices \\n    /// @return bn The block number when (ETH, TOKEN) takes into effective\\n    function queryPriceAvgVola(address token, address payback) \\n        external payable returns (uint256, uint256, uint128, int128, uint256);\\n\\n    /// @notice The main function called by DeFi clients, compatible to Nest Protocol v3.0 \\n    /// @dev  The payback address is ZERO, so the changes are kept in this contract\\n    ///         The ABI keeps consist with Nest v3.0\\n    /// @param tokenAddress The address of token contract address\\n    /// @return ethAmount The amount of ETH in price pair (ETH, ERC20)\\n    /// @return erc20Amount The amount of ERC20 in price pair (ETH, ERC20)\\n    /// @return blockNum The block.number where the price is being in effect\\n    function updateAndCheckPriceNow(address tokenAddress) \\n        external payable returns (uint256, uint256, uint256);\\n\\n    /// @notice A non-free function for querying price \\n    /// @param token  The address of the token contract\\n    /// @param num    The number of price sheets in the list\\n    /// @param payback The address for change\\n    /// @return The array of prices, each of which is (blockNnumber, ethAmount, tokenAmount)\\n    function queryPriceList(address token, uint8 num, address payback) \\n        external payable returns (uint128[] memory);\\n\\n    /// @notice A view function returning the historical price list from the current block\\n    /// @param token  The address of the token contract\\n    /// @param num    The number of price sheets in the list\\n    /// @return The array of prices, each of which is (blockNnumber, ethAmount, tokenAmount)\\n    function priceList(address token, uint8 num) \\n        external view returns (uint128[] memory);\\n\\n    /// @notice A view function returning the latestPrice\\n    /// @param token  The address of the token contract\\n    function latestPrice(address token)\\n    external view returns (uint256 ethAmount, uint256 tokenAmount, uint128 avgPrice, int128 vola, uint256 bn) ;\\n\\n    /// @dev Only for governance\\n    function loadContracts() external; \\n\\n    /// @dev Only for governance\\n    function loadGovernance() external; \\n\\n\\n    event ClientActivated(address, uint256, uint256);\\n    // event ClientRenewed(address, uint256, uint256, uint256);\\n    event PriceQueried(address client, address token, uint256 ethAmount, uint256 tokenAmount, uint256 bn);\\n    event PriceAvgVolaQueried(address client, address token, uint256 bn, uint128 avgPrice, int128 vola);\\n\\n    event PriceListQueried(address client, address token, uint256 bn, uint8 num);\\n\\n    // governance events\\n    event ParamsSetup(address gov, uint256 oldParams, uint256 newParams);\\n    event FlagSet(address gov, uint256 flag);\\n}\"\r\n    },\r\n    \"contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\ninterface ERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/lib/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n        (bool success, ) = recipient.call{value:amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nestAmount\",\"type\":\"uint256\"}],\"name\":\"AssetsCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gov\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"}],\"name\":\"FlagSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NTokenRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gov\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldParam\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newParam\",\"type\":\"uint256\"}],\"name\":\"ParamsSetup\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"addETHReward\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addNestReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"collectETHReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectNestReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethLedger\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"initEthLedger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"NestPool\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCollectingBlock\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loadContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loadGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDAO_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"ntokenL_\",\"type\":\"address[]\"}],\"name\":\"migrateTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ntokenLedger\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"rewardedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"redeemedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"quotaAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"_reserved\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ntokenRepurchaseThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"quotaOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quota\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ntokenRepurchaseThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collectInterval\",\"type\":\"uint256\"}],\"name\":\"setParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startedBlock\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ntoken\",\"type\":\"address\"}],\"name\":\"totalETHRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"NestDAO","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}