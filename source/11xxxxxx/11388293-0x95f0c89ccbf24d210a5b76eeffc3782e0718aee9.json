{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-11-30\r\n*/\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\ninterface IERC20 {\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function increaseApproval (address _spender, uint _addedValue) external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n}\r\n\r\n// File: contracts/interfaces/IERC165.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IDebtStatus.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\ninterface IDebtStatus {\r\n    enum Status {\r\n        NULL,\r\n        ONGOING,\r\n        PAID,\r\n        DESTROYED, // Deprecated, used in basalt version\r\n        ERROR\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/Model.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n\r\n\r\n/**\r\n    The abstract contract Model defines the whole lifecycle of a debt on the DebtEngine.\r\n\r\n    Models can be used without previous approbation, this is meant\r\n    to avoid centralization on the development of RCN; this implies that not all models are secure.\r\n    Models can have back-doors, bugs and they have not guarantee of being autonomous.\r\n\r\n    The DebtEngine is meant to be the User of this model,\r\n    so all the methods with the ability to perform state changes should only be callable by the DebtEngine.\r\n\r\n    All models should implement the 0xaf498c35 interface.\r\n\r\n    @author Agustin Aguilar <agustin@ripiocredit.network>  & Victor Fage <victor.fage@ripiocredit.network>\r\n*/\r\nabstract contract Model is IERC165, IDebtStatus {\r\n    // ///\r\n    // Events\r\n    // ///\r\n\r\n    /**\r\n        @dev This emits when create a new debt.\r\n    */\r\n    event Created(bytes32 indexed _id);\r\n\r\n    /**\r\n        @dev This emits when the status of debt change.\r\n\r\n        @param _timestamp Timestamp of the registry\r\n        @param _status New status of the registry\r\n    */\r\n    event ChangedStatus(bytes32 indexed _id, uint256 _timestamp, uint256 _status);\r\n\r\n    /**\r\n        @dev This emits when the obligation of debt change.\r\n\r\n        @param _timestamp Timestamp of the registry\r\n        @param _debt New debt of the registry\r\n    */\r\n    event ChangedObligation(bytes32 indexed _id, uint256 _timestamp, uint256 _debt);\r\n\r\n    /**\r\n        @dev This emits when the frequency of debt change.\r\n\r\n        @param _timestamp Timestamp of the registry\r\n        @param _frequency New frequency of each installment\r\n    */\r\n    event ChangedFrequency(bytes32 indexed _id, uint256 _timestamp, uint256 _frequency);\r\n\r\n    /**\r\n        @param _timestamp Timestamp of the registry\r\n    */\r\n    event ChangedDueTime(bytes32 indexed _id, uint256 _timestamp, uint256 _status);\r\n\r\n    /**\r\n        @param _timestamp Timestamp of the registry\r\n        @param _dueTime New dueTime of each installment\r\n    */\r\n    event ChangedFinalTime(bytes32 indexed _id, uint256 _timestamp, uint64 _dueTime);\r\n\r\n    /**\r\n        @dev This emits when the call addDebt function.\r\n\r\n        @param _amount New amount of the debt, old amount plus added\r\n    */\r\n    event AddedDebt(bytes32 indexed _id, uint256 _amount);\r\n\r\n    /**\r\n        @dev This emits when the call addPaid function.\r\n\r\n        If the registry is fully paid on the call and the amount parameter exceeds the required\r\n            payment amount, the event emits the real amount paid on the payment.\r\n\r\n        @param _paid Real amount paid\r\n    */\r\n    event AddedPaid(bytes32 indexed _id, uint256 _paid);\r\n\r\n    // Model interface selector\r\n    bytes4 internal constant MODEL_INTERFACE = 0xaf498c35;\r\n\r\n    // ///\r\n    // Meta\r\n    // ///\r\n\r\n    /**\r\n        @return Identifier of the model\r\n    */\r\n    function modelId() external view virtual returns (bytes32);\r\n\r\n    /**\r\n        Returns the address of the contract used as Descriptor of the model\r\n\r\n        @dev The descriptor contract should follow the ModelDescriptor.sol scheme\r\n\r\n        @return Address of the descriptor\r\n    */\r\n    function descriptor() external view virtual returns (address);\r\n\r\n    /**\r\n        If called for any address with the ability to modify the state of the model registries,\r\n            this method should return True.\r\n\r\n        @dev Some contracts may check if the DebtEngine is\r\n            an operator to know if the model is operative or not.\r\n\r\n        @param operator Address of the target request operator\r\n\r\n        @return canOperate True if operator is able to modify the state of the model\r\n    */\r\n    function isOperator(address operator) external view virtual returns (bool canOperate);\r\n\r\n    /**\r\n        Validates the data for the creation of a new registry, if returns True the\r\n            same data should be compatible with the create method.\r\n\r\n        @dev This method can revert the call or return false, and both meant an invalid data.\r\n\r\n        @param data Data to validate\r\n\r\n        @return isValid True if the data can be used to create a new registry\r\n    */\r\n    function validate(bytes calldata data) external view virtual returns (bool isValid);\r\n\r\n    // ///\r\n    // Getters\r\n    // ///\r\n\r\n    /**\r\n        Exposes the current status of the registry. The possible values are:\r\n\r\n        1: Ongoing - The debt is still ongoing and waiting to be paid\r\n        2: Paid - The debt is already paid and\r\n        4: Error - There was an Error with the registry\r\n\r\n        @dev This method should always be called by the DebtEngine\r\n\r\n        @param id Id of the registry\r\n\r\n        @return status The current status value\r\n    */\r\n    function getStatus(bytes32 id) external view virtual returns (Status status);\r\n\r\n    /**\r\n        Returns the total paid amount on the registry.\r\n\r\n        @dev it should equal to the sum of all real addPaid\r\n\r\n        @param id Id of the registry\r\n\r\n        @return paid Total paid amount(without debt engine fee)\r\n    */\r\n    function getPaid(bytes32 id) external view virtual returns (uint256 paid);\r\n\r\n    /**\r\n        If the returned amount does not depend on any interactions and only on the model logic,\r\n            the defined flag will be True; if the amount is an estimation of the future debt,\r\n            the flag will be set to False.\r\n\r\n        If timestamp equals the current moment, the defined flag should always be True.\r\n\r\n        @dev This can be a gas-intensive method to call, consider calling the run method before.\r\n\r\n        @param id Id of the registry\r\n        @param timestamp Timestamp of the obligation query\r\n\r\n        @return amount Amount(with debt engine fee) pending to pay on the given timestamp\r\n        @return defined True If the amount returned is fixed and can't change\r\n    */\r\n    function getObligation(bytes32 id, uint64 timestamp) external view virtual returns (uint256 amount, bool defined);\r\n\r\n    /**\r\n        The amount required to fully paid a registry.\r\n\r\n        All registries should be payable in a single time, even when it has multiple installments.\r\n\r\n        If the registry discounts interest for early payment, those discounts should be\r\n            taken into account in the returned amount.\r\n\r\n        @dev This can be a gas-intensive method to call, consider calling the run method before.\r\n\r\n        @param id Id of the registry\r\n\r\n        @return amount Amount(with debt engine fee) required to fully paid the loan on the current timestamp\r\n    */\r\n    function getClosingObligation(bytes32 id) external view virtual returns (uint256 amount);\r\n\r\n    /**\r\n        The timestamp of the next required payment.\r\n\r\n        After this moment, if the payment goal is not met the debt will be considered overdue.\r\n\r\n            The getObligation method can be used to know the required payment on the future timestamp.\r\n\r\n        @param id Id of the registry\r\n\r\n        @return timestamp The timestamp of the next due time\r\n    */\r\n    function getDueTime(bytes32 id) external view virtual returns (uint256 timestamp);\r\n\r\n    // ///\r\n    // Metadata\r\n    // ///\r\n\r\n    /**\r\n        If the loan has multiple installments returns the duration of each installment in seconds,\r\n            if the loan has not installments it should return 1.\r\n\r\n        @param id Id of the registry\r\n\r\n        @return frequency Frequency of each installment\r\n    */\r\n    function getFrequency(bytes32 id) external view virtual returns (uint256 frequency);\r\n\r\n    /**\r\n        If the loan has multiple installments returns the total of installments,\r\n            if the loan has not installments it should return 1.\r\n\r\n        @param id Id of the registry\r\n\r\n        @return installments Total of installments\r\n    */\r\n    function getInstallments(bytes32 id) external view virtual returns (uint256 installments);\r\n\r\n    /**\r\n        The registry could be paid before or after the date, but the debt will always be\r\n            considered overdue if paid after this timestamp.\r\n\r\n        This is the estimated final payment date of the debt if it's always paid on each exact dueTime.\r\n\r\n        @param id Id of the registry\r\n\r\n        @return timestamp Timestamp of the final due time\r\n    */\r\n    function getFinalTime(bytes32 id) external view virtual returns (uint256 timestamp);\r\n\r\n    /**\r\n        Similar to getFinalTime returns the expected payment remaining if paid always on the exact dueTime.\r\n\r\n        If the model has no interest discounts for early payments,\r\n            this method should return the same value as getClosingObligation.\r\n\r\n        @param id Id of the registry\r\n\r\n        @return amount Expected payment amount(with debt engine fee)\r\n    */\r\n    function getEstimateObligation(bytes32 id) external view virtual returns (uint256 amount);\r\n\r\n    // ///\r\n    // State interface\r\n    // ///\r\n\r\n    /**\r\n        Creates a new registry using the provided data and id, it should fail if the id already exists\r\n            or if calling validate(data) returns false or throws.\r\n\r\n        @dev This method should only be callable by an operator\r\n\r\n        @param id Id of the registry to create\r\n        @param data Data to construct the new registry\r\n\r\n        @return success True if the registry was created\r\n    */\r\n    function create(bytes32 id, bytes calldata data) external virtual returns (bool success);\r\n\r\n    /**\r\n        If the registry is fully paid on the call and the amount parameter exceeds the required\r\n            payment amount, the method returns the real amount used on the payment.\r\n\r\n        The payment taken should always be the same as the requested unless the registry\r\n            is fully paid on the process.\r\n\r\n        @dev This method should only be callable by an operator\r\n\r\n        @param id If of the registry\r\n        @param amount Amount to pay(without debt engine fee)\r\n\r\n        @return real Real amount paid\r\n    */\r\n    function addPaid(bytes32 id, uint256 amount) external virtual returns (uint256 real);\r\n\r\n    /**\r\n        Adds a new amount(without debt engine fee) to be paid on the debt model,\r\n            each model can handle the addition of more debt freely.\r\n\r\n        @dev This method should only be callable by an operator\r\n\r\n        @param id Id of the registry\r\n        @param amount Debt amount(without debt engine fee) to add to the registry\r\n\r\n        @return added True if the debt was added\r\n    */\r\n    function addDebt(bytes32 id, uint256 amount) external virtual returns (bool added);\r\n\r\n    // ///\r\n    // Utils\r\n    // ///\r\n\r\n    /**\r\n        Runs the internal clock of a registry, this is used to compute the last changes on the state.\r\n            It can make transactions cheaper by avoiding multiple calculations when calling views.\r\n\r\n        Not all models have internal clocks, a model without an internal clock should always return false.\r\n\r\n        Calls to this method should be possible from any address,\r\n            multiple calls to run shouldn't affect the internal calculations of the model.\r\n\r\n        @dev If the call had no effect the method would return False,\r\n            that is no sign of things going wrong, and the call shouldn't be wrapped on a require\r\n\r\n        @param id If of the registry\r\n\r\n        @return effect True if the run performed a change on the state\r\n    */\r\n    function run(bytes32 id) external virtual returns (bool effect);\r\n}\r\n\r\n// File: contracts/interfaces/RateOracle.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n\r\n/**\r\n    @dev Defines the interface of a standard Diaspore RCN Oracle,\r\n\r\n    The contract should also implement it's ERC165 interface: 0xa265d8e0\r\n\r\n    @notice Each oracle can only support one currency\r\n\r\n    @author Agustin Aguilar\r\n*/\r\nabstract contract RateOracle is IERC165 {\r\n    uint256 public constant VERSION = 5;\r\n    bytes4 internal constant RATE_ORACLE_INTERFACE = 0xa265d8e0;\r\n\r\n    /**\r\n        3 or 4 letters symbol of the currency, Ej: ETH\r\n    */\r\n    function symbol() external view virtual returns (string memory);\r\n\r\n    /**\r\n        Descriptive name of the currency, Ej: Ethereum\r\n    */\r\n    function name() external view virtual returns (string memory);\r\n\r\n    /**\r\n        The number of decimals of the currency represented by this Oracle,\r\n            it should be the most common number of decimal places\r\n    */\r\n    function decimals() external view virtual returns (uint256);\r\n\r\n    /**\r\n        The base token on which the sample is returned\r\n            should be the RCN Token address.\r\n    */\r\n    function token() external view virtual returns (address);\r\n\r\n    /**\r\n        The currency symbol encoded on a UTF-8 Hex\r\n    */\r\n    function currency() external view virtual returns (bytes32);\r\n\r\n    /**\r\n        The name of the Individual or Company in charge of this Oracle\r\n    */\r\n    function maintainer() external view virtual returns (string memory);\r\n\r\n    /**\r\n        Returns the url where the oracle exposes a valid \"oracleData\" if needed\r\n    */\r\n    function url() external view virtual returns (string memory);\r\n\r\n    /**\r\n        Returns a sample on how many token() are equals to how many currency()\r\n    */\r\n    function readSample(bytes calldata _data) external virtual returns (uint256 _tokens, uint256 _equivalent);\r\n}\r\n\r\n// File: contracts/utils/IsContract.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\nlibrary IsContract {\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(_addr) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SafeMath.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\nlibrary SafeMath {\r\n    using SafeMath for uint256;\r\n\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        uint256 z = x + y;\r\n        require(z >= x, \"Add overflow\");\r\n        return z;\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(x >= y, \"Sub overflow\");\r\n        return x - y;\r\n    }\r\n\r\n    function mult(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 z = x * y;\r\n        require(z/x == y, \"Mult overflow\");\r\n        return z;\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"Div by zero\");\r\n        return x / y;\r\n    }\r\n\r\n    function multdiv(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {\r\n        require(z != 0, \"div by zero\");\r\n        return x.mult(y) / z;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/ERC165.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\r\n    /**\r\n    * 0x01ffc9a7 ===\r\n    *   bytes4(keccak256('supportsInterface(bytes4)'))\r\n    */\r\n\r\n    /**\r\n    * @dev a mapping of interface id to whether or not it's supported\r\n    */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n    * @dev A contract implementing SupportsInterfaceWithLookup\r\n    * implement ERC165 itself\r\n    */\r\n    constructor()\r\n        internal\r\n    {\r\n        _registerInterface(_InterfaceId_ERC165);\r\n    }\r\n\r\n    /**\r\n    * @dev implement supportsInterface(bytes4) using a lookup table\r\n    */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n    * @dev internal method for registering an interface\r\n    */\r\n    function _registerInterface(bytes4 interfaceId)\r\n        internal\r\n    {\r\n        require(interfaceId != 0xffffffff, \"Can't register 0xffffffff\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/ERC721Base.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n\r\n\r\n\r\ninterface URIProvider {\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\ncontract ERC721Base is ERC165 {\r\n    using SafeMath for uint256;\r\n    using IsContract for address;\r\n\r\n    mapping(uint256 => address) private _holderOf;\r\n\r\n    // Owner to array of assetId\r\n    mapping(address => uint256[]) private _assetsOf;\r\n    // AssetId to index on array in _assetsOf mapping\r\n    mapping(uint256 => uint256) private _indexOfAsset;\r\n\r\n    mapping(address => mapping(address => bool)) private _operators;\r\n    mapping(uint256 => address) private _approval;\r\n\r\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\r\n    bytes4 private constant ERC721_RECEIVED_LEGACY = 0xf0b9e5ba;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    bytes4 private constant ERC_721_INTERFACE = 0x80ac58cd;\r\n    bytes4 private constant ERC_721_METADATA_INTERFACE = 0x5b5e139f;\r\n    bytes4 private constant ERC_721_ENUMERATION_INTERFACE = 0x780e9d63;\r\n\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol\r\n    ) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        _registerInterface(ERC_721_INTERFACE);\r\n        _registerInterface(ERC_721_METADATA_INTERFACE);\r\n        _registerInterface(ERC_721_ENUMERATION_INTERFACE);\r\n    }\r\n\r\n    // ///\r\n    // ERC721 Metadata\r\n    // ///\r\n\r\n    /// ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n    /// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n    /// Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\n\r\n    event SetURIProvider(address _uriProvider);\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    URIProvider private _uriProvider;\r\n\r\n    // @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    // @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n    * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    *  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    *  Metadata JSON Schema\".\r\n    */\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\r\n        require(_holderOf[_tokenId] != address(0), \"Asset does not exist\");\r\n        URIProvider provider = _uriProvider;\r\n        return address(provider) == address(0) ? \"\" : provider.tokenURI(_tokenId);\r\n    }\r\n\r\n    function _setURIProvider(URIProvider _provider) internal returns (bool) {\r\n        emit SetURIProvider(address(_provider));\r\n        _uriProvider = _provider;\r\n        return true;\r\n    }\r\n\r\n    // ///\r\n    // ERC721 Enumeration\r\n    // ///\r\n\r\n    ///  ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n    ///  See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n    ///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\n\r\n    uint256[] private _allTokens;\r\n\r\n    /**\r\n     * @dev Gets the total of assets stored by the contract\r\n     *      Warning: this method can consume all the gas of the transaction, it should not be\r\n     *               called from another contract, it should only be used in external calls\r\n     * @return an array with total assets\r\n     */\r\n    function allTokens() external view returns (uint256[] memory) {\r\n        return _allTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total of assets of the owner\r\n     *      Warning: this method can consume all the gas of the transaction, it should not be\r\n     *               called from another contract, it should only be used in external calls\r\n     * @param _owner the address of owner\r\n     * @return an array with total assets of owner\r\n     */\r\n    function assetsOf(address _owner) external view returns (uint256[] memory) {\r\n        return _assetsOf[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of assets stored by the contract\r\n     * @return uint256 representing the total amount of assets\r\n     */\r\n    function totalSupply() external view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n    * @notice Enumerate valid NFTs\r\n    * @dev Throws if `_index` >= `totalSupply()`.\r\n    * @param _index A counter less than `totalSupply()`\r\n    * @return The token identifier for the `_index` of the NFT,\r\n    *  (sort order not specified)\r\n    */\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_index < _allTokens.length, \"Index out of bounds\");\r\n        return _allTokens[_index];\r\n    }\r\n\r\n    /**\r\n    * @notice Enumerate NFTs assigned to an owner\r\n    * @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    *  `_owner` is the zero address, representing invalid NFTs.\r\n    * @param _owner An address where we are interested in NFTs owned by them\r\n    * @param _index A counter less than `balanceOf(_owner)`\r\n    * @return The token identifier for the `_index` of the NFT assigned to `_owner`,\r\n    *   (sort order not specified)\r\n    */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n        require(_owner != address(0), \"0x0 Is not a valid owner\");\r\n        require(_index < _balanceOf(_owner), \"Index out of bounds\");\r\n        return _assetsOf[_owner][_index];\r\n    }\r\n\r\n    //\r\n    // Asset-centric getter functions\r\n    //\r\n\r\n    /**\r\n     * @dev Queries what address owns an asset. This method does not throw.\r\n     * In order to check if the asset exists, use the `exists` function or check if the\r\n     * return value of this call is `0`.\r\n     * @return uint256 the assetId\r\n     */\r\n    function ownerOf(uint256 _assetId) external view returns (address) {\r\n        return _ownerOf(_assetId);\r\n    }\r\n\r\n    function _ownerOf(uint256 _assetId) internal view returns (address) {\r\n        return _holderOf[_assetId];\r\n    }\r\n\r\n    //\r\n    // Holder-centric getter functions\r\n    //\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param _owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        return _balanceOf(_owner);\r\n    }\r\n\r\n    function _balanceOf(address _owner) internal view returns (uint256) {\r\n        return _assetsOf[_owner].length;\r\n    }\r\n\r\n    //\r\n    // Authorization getters\r\n    //\r\n\r\n    /**\r\n     * @dev Query whether an address has been authorized to move any assets on behalf of someone else\r\n     * @param _operator the address that might be authorized\r\n     * @param _assetHolder the address that provided the authorization\r\n     * @return bool true if the operator has been authorized to move any assets\r\n     */\r\n    function isApprovedForAll(\r\n        address _operator,\r\n        address _assetHolder\r\n    ) external view returns (bool) {\r\n        return _isApprovedForAll(_operator, _assetHolder);\r\n    }\r\n\r\n    function _isApprovedForAll(\r\n        address _operator,\r\n        address _assetHolder\r\n    ) internal view returns (bool) {\r\n        return _operators[_assetHolder][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Query what address has been particularly authorized to move an asset\r\n     * @param _assetId the asset to be queried for\r\n     * @return bool true if the asset has been approved by the holder\r\n     */\r\n    function getApproved(uint256 _assetId) external view returns (address) {\r\n        return _getApproved(_assetId);\r\n    }\r\n\r\n    function _getApproved(uint256 _assetId) internal view returns (address) {\r\n        return _approval[_assetId];\r\n    }\r\n\r\n    /**\r\n     * @dev Query if an operator can move an asset.\r\n     * @param _operator the address that might be authorized\r\n     * @param _assetId the asset that has been `approved` for transfer\r\n     * @return bool true if the asset has been approved by the holder\r\n     */\r\n    function isAuthorized(address _operator, uint256 _assetId) external view returns (bool) {\r\n        return _isAuthorized(_operator, _assetId);\r\n    }\r\n\r\n    function _isAuthorized(address _operator, uint256 _assetId) internal view returns (bool) {\r\n        require(_operator != address(0), \"0x0 is an invalid operator\");\r\n        address owner = _ownerOf(_assetId);\r\n\r\n        return _operator == owner || _isApprovedForAll(_operator, owner) || _getApproved(_assetId) == _operator;\r\n    }\r\n\r\n    //\r\n    // Authorization\r\n    //\r\n\r\n    /**\r\n     * @dev Authorize a third party operator to manage (send) msg.sender's asset\r\n     * @param _operator address to be approved\r\n     * @param _authorized bool set to true to authorize, false to withdraw authorization\r\n     */\r\n    function setApprovalForAll(address _operator, bool _authorized) external {\r\n        if (_operators[msg.sender][_operator] != _authorized) {\r\n            _operators[msg.sender][_operator] = _authorized;\r\n            emit ApprovalForAll(msg.sender, _operator, _authorized);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Authorize a third party operator to manage one particular asset\r\n     * @param _operator address to be approved\r\n     * @param _assetId asset to approve\r\n     */\r\n    function approve(address _operator, uint256 _assetId) external {\r\n        address holder = _ownerOf(_assetId);\r\n        require(msg.sender == holder || _isApprovedForAll(msg.sender, holder), \"msg.sender can't approve\");\r\n        if (_getApproved(_assetId) != _operator) {\r\n            _approval[_assetId] = _operator;\r\n            emit Approval(holder, _operator, _assetId);\r\n        }\r\n    }\r\n\r\n    //\r\n    // Internal Operations\r\n    //\r\n\r\n    function _addAssetTo(address _to, uint256 _assetId) private {\r\n        // Store asset owner\r\n        _holderOf[_assetId] = _to;\r\n\r\n        // Store index of the asset\r\n        uint256 length = _balanceOf(_to);\r\n        _assetsOf[_to].push(_assetId);\r\n        _indexOfAsset[_assetId] = length;\r\n\r\n        // Save main enumerable\r\n        _allTokens.push(_assetId);\r\n    }\r\n\r\n    function _transferAsset(address _from, address _to, uint256 _assetId) private {\r\n        uint256 assetIndex = _indexOfAsset[_assetId];\r\n        uint256 lastAssetIndex = _balanceOf(_from).sub(1);\r\n\r\n        if (assetIndex != lastAssetIndex) {\r\n            // Replace current asset with last asset\r\n            uint256 lastAssetId = _assetsOf[_from][lastAssetIndex];\r\n            // Insert the last asset into the position previously occupied by the asset to be removed\r\n            _assetsOf[_from][assetIndex] = lastAssetId;\r\n            _indexOfAsset[lastAssetId] = assetIndex;\r\n        }\r\n\r\n        // Resize the array\r\n        _assetsOf[_from][lastAssetIndex] = 0;\r\n        _assetsOf[_from].pop();\r\n\r\n        // Change owner\r\n        _holderOf[_assetId] = _to;\r\n\r\n        // Update the index of positions of the asset\r\n        uint256 length = _balanceOf(_to);\r\n        _assetsOf[_to].push(_assetId);\r\n        _indexOfAsset[_assetId] = length;\r\n    }\r\n\r\n    function _clearApproval(address _holder, uint256 _assetId) private {\r\n        if (_approval[_assetId] != address(0)) {\r\n            _approval[_assetId] = address(0);\r\n            emit Approval(_holder, address(0), _assetId);\r\n        }\r\n    }\r\n\r\n    //\r\n    // Supply-altering functions\r\n    //\r\n\r\n    function _generate(uint256 _assetId, address _beneficiary) internal {\r\n        require(_holderOf[_assetId] == address(0), \"Asset already exists\");\r\n\r\n        _addAssetTo(_beneficiary, _assetId);\r\n\r\n        emit Transfer(address(0), _beneficiary, _assetId);\r\n    }\r\n\r\n    //\r\n    // Transaction related operations\r\n    //\r\n\r\n    modifier onlyAuthorized(uint256 _assetId) {\r\n        require(_isAuthorized(msg.sender, _assetId), \"msg.sender Not authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier isCurrentOwner(address _from, uint256 _assetId) {\r\n        require(_ownerOf(_assetId) == _from, \"Not current owner\");\r\n        _;\r\n    }\r\n\r\n    modifier addressDefined(address _target) {\r\n        require(_target != address(0), \"Target can't be 0x0\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Alias of `safeTransferFrom(from, to, assetId, '')`\r\n     *\r\n     * @param _from address that currently owns an asset\r\n     * @param _to address to receive the ownership of the asset\r\n     * @param _assetId uint256 ID of the asset to be transferred\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _assetId) external {\r\n        return _doTransferFrom(\r\n            _from,\r\n            _to,\r\n            _assetId,\r\n            \"\",\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Securely transfers the ownership of a given asset from one address to\r\n     * another address, calling the method `onNFTReceived` on the target address if\r\n     * there's code associated with it\r\n     *\r\n     * @param _from address that currently owns an asset\r\n     * @param _to address to receive the ownership of the asset\r\n     * @param _assetId uint256 ID of the asset to be transferred\r\n     * @param _userData bytes arbitrary user information to attach to this transfer\r\n     */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _assetId,\r\n        bytes calldata _userData\r\n    ) external {\r\n        return _doTransferFrom(\r\n            _from,\r\n            _to,\r\n            _assetId,\r\n            _userData,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given asset from one address to another address\r\n     * Warning! This function does not attempt to verify that the target address can send\r\n     * tokens.\r\n     *\r\n     * @param _from address sending the asset\r\n     * @param _to address to receive the ownership of the asset\r\n     * @param _assetId uint256 ID of the asset to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _assetId) external {\r\n        return _doTransferFrom(\r\n            _from,\r\n            _to,\r\n            _assetId,\r\n            \"\",\r\n            false\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Internal function that moves an asset from one holder to another\r\n     */\r\n    function _doTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _assetId,\r\n        bytes memory _userData,\r\n        bool _doCheck\r\n    )\r\n        internal\r\n        onlyAuthorized(_assetId)\r\n        addressDefined(_to)\r\n        isCurrentOwner(_from, _assetId)\r\n    {\r\n        address holder = _holderOf[_assetId];\r\n        _clearApproval(holder, _assetId);\r\n        _transferAsset(holder, _to, _assetId);\r\n\r\n        if (_doCheck && _to.isContract()) {\r\n            // Call dest contract\r\n            // Perform check with the new safe call\r\n            // onERC721Received(address,address,uint256,bytes)\r\n            (bool success, bytes4 result) = _noThrowCall(\r\n                _to,\r\n                abi.encodeWithSelector(\r\n                    ERC721_RECEIVED,\r\n                    msg.sender,\r\n                    holder,\r\n                    _assetId,\r\n                    _userData\r\n                )\r\n            );\r\n\r\n            if (!success || result != ERC721_RECEIVED) {\r\n                // Try legacy safe call\r\n                // onERC721Received(address,uint256,bytes)\r\n                (success, result) = _noThrowCall(\r\n                    _to,\r\n                    abi.encodeWithSelector(\r\n                        ERC721_RECEIVED_LEGACY,\r\n                        holder,\r\n                        _assetId,\r\n                        _userData\r\n                    )\r\n                );\r\n\r\n                require(\r\n                    success && result == ERC721_RECEIVED_LEGACY,\r\n                    \"Contract rejected the token\"\r\n                );\r\n            }\r\n        }\r\n\r\n        emit Transfer(holder, _to, _assetId);\r\n    }\r\n\r\n    //\r\n    // Utilities\r\n    //\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\r\n     * relaxing the requirement on the return value\r\n     *\r\n     * @param _contract The contract that receives the ERC721\r\n     * @param _data The call data\r\n     *\r\n     * @return success True if the call not reverts\r\n     * @return result the result of the call\r\n    */\r\n    function _noThrowCall(\r\n        address _contract,\r\n        bytes memory _data\r\n    ) internal returns (bool success, bytes4 result) {\r\n        bytes memory returnData;\r\n        (success, returnData) = _contract.call(_data);\r\n\r\n        if (returnData.length > 0)\r\n            result = abi.decode(returnData, (bytes4));\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IERC173.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n/**\r\n* @title ERC-173 Contract Ownership Standard\r\n* @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\r\n* Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n*/\r\ninterface IERC173 {\r\n    /**\r\n     * @dev This emits when ownership of a contract changes.\r\n     */\r\n    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\r\n\r\n    /**\r\n     * @notice Get the address of the owner\r\n     * @return The address of the owner.\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * @notice Set the address of the new owner of the contract\r\n     * @param _newOwner The address of the new owner of the contract\r\n     */\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n\r\n// File: contracts/utils/Ownable.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n\r\ncontract Ownable is IERC173 {\r\n    address internal _owner;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"The owner should be the sender\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0x0), msg.sender);\r\n    }\r\n\r\n    function owner() external view override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n        @dev Transfers the ownership of the contract.\r\n\r\n        @param _newOwner Address of the new owner\r\n    */\r\n    function transferOwnership(address _newOwner) external override onlyOwner {\r\n        require(_newOwner != address(0), \"0x0 Is not a valid owner\");\r\n        emit OwnershipTransferred(_owner, _newOwner);\r\n        _owner = _newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/DebtEngine.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DebtEngine is ERC721Base, Ownable, IDebtStatus {\r\n    using IsContract for address;\r\n\r\n    event Created(\r\n        bytes32 indexed _id,\r\n        uint256 _nonce,\r\n        bytes _data\r\n    );\r\n\r\n    event Created2(\r\n        bytes32 indexed _id,\r\n        uint256 _salt,\r\n        bytes _data\r\n    );\r\n\r\n    event Created3(\r\n        bytes32 indexed _id,\r\n        uint256 _salt,\r\n        bytes _data\r\n    );\r\n\r\n    event Paid(\r\n        bytes32 indexed _id,\r\n        address _sender,\r\n        address _origin,\r\n        uint256 _requested,\r\n        uint256 _requestedTokens,\r\n        uint256 _paid,\r\n        uint256 _tokens\r\n    );\r\n\r\n    event ChargeBurnFee(\r\n        bytes32 indexed _id,\r\n        uint256 _amount\r\n    );\r\n\r\n    event ReadedOracleBatch(\r\n        address _oracle,\r\n        uint256 _count,\r\n        uint256 _tokens,\r\n        uint256 _equivalent\r\n    );\r\n\r\n    event ReadedOracle(\r\n        bytes32 indexed _id,\r\n        uint256 _tokens,\r\n        uint256 _equivalent\r\n    );\r\n\r\n    event PayBatchError(\r\n        bytes32 indexed _id,\r\n        address _targetOracle\r\n    );\r\n\r\n    event Withdrawn(\r\n        bytes32 indexed _id,\r\n        address _sender,\r\n        address _to,\r\n        uint256 _amount\r\n    );\r\n\r\n    event Error(\r\n        bytes32 indexed _id,\r\n        address _sender,\r\n        uint256 _value,\r\n        uint256 _gasLeft,\r\n        uint256 _gasLimit,\r\n        bytes _callData\r\n    );\r\n\r\n    event ErrorRecover(\r\n        bytes32 indexed _id,\r\n        address _sender,\r\n        uint256 _value,\r\n        uint256 _gasLeft,\r\n        uint256 _gasLimit,\r\n        bytes32 _result,\r\n        bytes _callData\r\n    );\r\n\r\n    event SetBurner(address indexed _burner);\r\n    event SetFee(uint128 _fee);\r\n\r\n    IERC20 public immutable token;\r\n    address public burner;\r\n    uint128 public fee; // Fee is calculated FEE/BASE EX: 100/10000= 0.01 = 1%\r\n\r\n    uint256 public constant BASE = 10000;\r\n    uint256 private constant UINT_128_OVERFLOW = 340282366920938463463374607431768211456;\r\n\r\n    mapping(bytes32 => Debt) public debts;\r\n    mapping(address => uint256) public nonces;\r\n\r\n    struct Debt {\r\n        bool error;\r\n        uint128 balance;\r\n        uint128 fee;\r\n        Model model;\r\n        address creator;\r\n        address oracle;\r\n    }\r\n\r\n    constructor (\r\n        IERC20 _token,\r\n        address _burner,\r\n        uint128 _fee\r\n    ) public ERC721Base(\"RCN Debt Record\", \"RDR\") {\r\n        // Sanity checks\r\n        require(_burner != address(0), \"Burner 0x0 is not valid\");\r\n        require(address(_token).isContract(), \"Token should be a contract\");\r\n        require(_fee <= 100, \"The fee should be lower or equal than 1%\");\r\n\r\n        token = _token;\r\n        burner = _burner;\r\n        fee = _fee;\r\n        emit SetBurner(_burner);\r\n        emit SetFee(_fee);\r\n    }\r\n\r\n    function setBurner(address _burner) external onlyOwner {\r\n        require(_burner != address(0), \"Burner 0x0 is not valid\");\r\n\r\n        burner = _burner;\r\n        emit SetBurner(_burner);\r\n    }\r\n\r\n    function setFee(uint128 _fee) external onlyOwner {\r\n        require(_fee <= 100, \"The fee should be lower or equal than 1%\");\r\n\r\n        fee = _fee;\r\n        emit SetFee(_fee);\r\n    }\r\n\r\n    function setURIProvider(URIProvider _provider) external onlyOwner {\r\n        _setURIProvider(_provider);\r\n    }\r\n\r\n    function create(\r\n        Model _model,\r\n        address _owner,\r\n        address _oracle,\r\n        bytes calldata _data\r\n    ) external returns (bytes32 id) {\r\n        uint256 nonce = nonces[msg.sender]++; // Overflow when a user create (2**256)-1 debts\r\n        id = keccak256(\r\n            abi.encodePacked(\r\n                uint8(1),\r\n                address(this),\r\n                msg.sender,\r\n                nonce\r\n            )\r\n        );\r\n\r\n        debts[id] = Debt({\r\n            error: false,\r\n            balance: 0,\r\n            fee: fee,\r\n            creator: msg.sender,\r\n            model: _model,\r\n            oracle: _oracle\r\n        });\r\n\r\n        _generate(uint256(id), _owner);\r\n        require(_model.create(id, _data), \"Error creating debt in model\");\r\n\r\n        emit Created({\r\n            _id: id,\r\n            _nonce: nonce,\r\n            _data: _data\r\n        });\r\n    }\r\n\r\n    function create2(\r\n        Model _model,\r\n        address _owner,\r\n        address _oracle,\r\n        uint256 _salt,\r\n        bytes calldata _data\r\n    ) external returns (bytes32 id) {\r\n        id = keccak256(\r\n            abi.encodePacked(\r\n                uint8(2),\r\n                address(this),\r\n                msg.sender,\r\n                _model,\r\n                _oracle,\r\n                _salt,\r\n                _data\r\n            )\r\n        );\r\n\r\n        debts[id] = Debt({\r\n            error: false,\r\n            balance: 0,\r\n            fee: fee,\r\n            creator: msg.sender,\r\n            model: _model,\r\n            oracle: _oracle\r\n        });\r\n\r\n        _generate(uint256(id), _owner);\r\n        require(_model.create(id, _data), \"Error creating debt in model\");\r\n\r\n        emit Created2({\r\n            _id: id,\r\n            _salt: _salt,\r\n            _data: _data\r\n        });\r\n    }\r\n\r\n    function create3(\r\n        Model _model,\r\n        address _owner,\r\n        address _oracle,\r\n        uint256 _salt,\r\n        bytes calldata _data\r\n    ) external returns (bytes32 id) {\r\n        id = keccak256(\r\n            abi.encodePacked(\r\n                uint8(3),\r\n                address(this),\r\n                msg.sender,\r\n                _salt\r\n            )\r\n        );\r\n\r\n        debts[id] = Debt({\r\n            error: false,\r\n            balance: 0,\r\n            fee: fee,\r\n            creator: msg.sender,\r\n            model: _model,\r\n            oracle: _oracle\r\n        });\r\n\r\n        _generate(uint256(id), _owner);\r\n        require(_model.create(id, _data), \"Error creating debt in model\");\r\n\r\n        emit Created3({\r\n            _id: id,\r\n            _salt: _salt,\r\n            _data: _data\r\n        });\r\n    }\r\n\r\n    function buildId(\r\n        address _creator,\r\n        uint256 _nonce\r\n    ) external view returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                uint8(1),\r\n                address(this),\r\n                _creator,\r\n                _nonce\r\n            )\r\n        );\r\n    }\r\n\r\n    function buildId2(\r\n        address _creator,\r\n        address _model,\r\n        address _oracle,\r\n        uint256 _salt,\r\n        bytes calldata _data\r\n    ) external view returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                uint8(2),\r\n                address(this),\r\n                _creator,\r\n                _model,\r\n                _oracle,\r\n                _salt,\r\n                _data\r\n            )\r\n        );\r\n    }\r\n\r\n    function buildId3(\r\n        address _creator,\r\n        uint256 _salt\r\n    ) external view returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                uint8(3),\r\n                address(this),\r\n                _creator,\r\n                _salt\r\n            )\r\n        );\r\n    }\r\n\r\n    function pay(\r\n        bytes32 _id,\r\n        uint256 _amountToPay,\r\n        address _origin,\r\n        bytes calldata _oracleData\r\n    ) external returns (uint256 paid, uint256 paidToken, uint256 burnToken) {\r\n        Debt storage debt = debts[_id];\r\n\r\n        // Paid only required amount\r\n        paid = _safePay(_id, debt.model, _amountToPay);\r\n\r\n        if (debt.error)\r\n            return (0, 0, 0);\r\n\r\n        require(paid <= _amountToPay, \"Paid can't be more than requested\");\r\n\r\n        RateOracle oracle = RateOracle(debt.oracle);\r\n        if (address(oracle) != address(0)) {\r\n            // Convert\r\n            (uint256 tokens, uint256 equivalent) = oracle.readSample(_oracleData);\r\n            emit ReadedOracle(_id, tokens, equivalent);\r\n            paidToken = _toToken(paid, tokens, equivalent);\r\n        } else {\r\n            paidToken = paid;\r\n        }\r\n\r\n        // Pull tokens from payer\r\n        require(token.transferFrom(msg.sender, address(this), paidToken), \"Error pulling payment tokens\");\r\n\r\n        burnToken = _chargeBurnFee(_id, debt.fee, paidToken);\r\n\r\n        // Add balance to the debt\r\n        uint256 newBalance = paidToken.add(debt.balance);\r\n        require(newBalance < UINT_128_OVERFLOW, \"uint128 Overflow\");\r\n        debt.balance = uint128(newBalance);\r\n\r\n        // Emit pay event\r\n        emit Paid({\r\n            _id: _id,\r\n            _sender: msg.sender,\r\n            _origin: _origin,\r\n            _requested: _amountToPay,\r\n            _requestedTokens: 0,\r\n            _paid: paid,\r\n            _tokens: paidToken\r\n        });\r\n    }\r\n\r\n    function payToken(\r\n        bytes32 id,\r\n        uint256 amount,\r\n        address origin,\r\n        bytes calldata oracleData\r\n    ) external returns (uint256 paid, uint256 paidToken, uint256 burnToken) {\r\n        Debt storage debt = debts[id];\r\n        // Read storage\r\n        RateOracle oracle = RateOracle(debt.oracle);\r\n\r\n        uint256 available;\r\n\r\n        {\r\n            uint256 equivalent;\r\n            uint256 tokens;\r\n\r\n            // Get available <currency> amount\r\n            if (address(oracle) != address(0)) {\r\n                (tokens, equivalent) = oracle.readSample(oracleData);\r\n                emit ReadedOracle(id, tokens, equivalent);\r\n                available = _fromToken(amount, tokens, equivalent);\r\n            } else {\r\n                available = amount;\r\n            }\r\n\r\n            // Call addPaid on model\r\n            paid = _safePay(id, debt.model, available);\r\n\r\n            if (debt.error)\r\n                return (0, 0, 0);\r\n\r\n            require(paid <= available, \"Paid can't exceed available\");\r\n\r\n            // Convert back to required pull amount\r\n            if (address(oracle) != address(0)) {\r\n                paidToken = _toToken(paid, tokens, equivalent);\r\n                require(paidToken <= amount, \"Paid can't exceed requested\");\r\n            } else {\r\n                paidToken = paid;\r\n            }\r\n        }\r\n\r\n        // Pull tokens from payer\r\n        require(token.transferFrom(msg.sender, address(this), paidToken), \"Error pulling tokens\");\r\n\r\n        burnToken = _chargeBurnFee(id, debt.fee, paidToken);\r\n\r\n        // Add balance to the debt\r\n        // WARNING: Reusing variable **available**\r\n        available = paidToken.add(debt.balance);\r\n        require(available < UINT_128_OVERFLOW, \"uint128 Overflow\");\r\n        debt.balance = uint128(available);\r\n\r\n        // Emit pay event\r\n        emit Paid({\r\n            _id: id,\r\n            _sender: msg.sender,\r\n            _origin: origin,\r\n            _requested: 0,\r\n            _requestedTokens: amount,\r\n            _paid: paid,\r\n            _tokens: paidToken\r\n        });\r\n    }\r\n\r\n    function payBatch(\r\n        bytes32[] calldata _ids,\r\n        uint256[] calldata _amounts,\r\n        address _origin,\r\n        address _oracle,\r\n        bytes calldata _oracleData\r\n    ) external returns (uint256[] memory paid, uint256[] memory paidTokens) {\r\n        uint256 count = _ids.length;\r\n        require(count == _amounts.length, \"_ids and _amounts should have the same length\");\r\n\r\n        uint256 tokens;\r\n        uint256 equivalent;\r\n        if (_oracle != address(0)) {\r\n            (tokens, equivalent) = RateOracle(_oracle).readSample(_oracleData);\r\n            emit ReadedOracleBatch(_oracle, count, tokens, equivalent);\r\n        }\r\n\r\n        paid = new uint256[](count);\r\n        paidTokens = new uint256[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            uint256 amount = _amounts[i];\r\n            (paid[i], paidTokens[i],) = _pay(_ids[i], _oracle, amount, tokens, equivalent);\r\n\r\n            emit Paid({\r\n                _id: _ids[i],\r\n                _sender: msg.sender,\r\n                _origin: _origin,\r\n                _requested: amount,\r\n                _requestedTokens: 0,\r\n                _paid: paid[i],\r\n                _tokens: paidTokens[i]\r\n            });\r\n        }\r\n    }\r\n\r\n    function payTokenBatch(\r\n        bytes32[] calldata _ids,\r\n        uint256[] calldata _tokenAmounts,\r\n        address _origin,\r\n        address _oracle,\r\n        bytes calldata _oracleData\r\n    ) external returns (uint256[] memory paid, uint256[] memory paidTokens) {\r\n        uint256 count = _ids.length;\r\n        require(count == _tokenAmounts.length, \"_ids and _amounts should have the same length\");\r\n\r\n        uint256 tokens;\r\n        uint256 equivalent;\r\n        if (_oracle != address(0)) {\r\n            (tokens, equivalent) = RateOracle(_oracle).readSample(_oracleData);\r\n            emit ReadedOracleBatch(_oracle, count, tokens, equivalent);\r\n        }\r\n\r\n        paid = new uint256[](count);\r\n        paidTokens = new uint256[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            uint256 tokenAmount = _tokenAmounts[i];\r\n            (paid[i], paidTokens[i],) = _pay(\r\n                _ids[i],\r\n                _oracle,\r\n                _oracle != address(0) ? _fromToken(tokenAmount, tokens, equivalent) : tokenAmount,\r\n                tokens,\r\n                equivalent\r\n            );\r\n            require(paidTokens[i] <= tokenAmount, \"Paid can't exceed requested\");\r\n\r\n            emit Paid({\r\n                _id: _ids[i],\r\n                _sender: msg.sender,\r\n                _origin: _origin,\r\n                _requested: 0,\r\n                _requestedTokens: tokenAmount,\r\n                _paid: paid[i],\r\n                _tokens: paidTokens[i]\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n        Internal method to pay a loan, during a payment batch context\r\n\r\n        @param _id Pay identifier\r\n        @param _oracle Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\r\n        @param _amount Amount to pay, in currency\r\n        @param _tokens How many tokens\r\n        @param _equivalent How much currency _tokens equivales\r\n\r\n        @return paid and paidTokens, similar to external pay\r\n    */\r\n    function _pay(\r\n        bytes32 _id,\r\n        address _oracle,\r\n        uint256 _amount,\r\n        uint256 _tokens,\r\n        uint256 _equivalent\r\n    ) internal returns (uint256 paid, uint256 paidToken, uint256 burnToken){\r\n        Debt storage debt = debts[_id];\r\n\r\n        if (_oracle != debt.oracle) {\r\n            emit PayBatchError(\r\n                _id,\r\n                _oracle\r\n            );\r\n\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        // Paid only required amount\r\n        paid = _safePay(_id, debt.model, _amount);\r\n\r\n        if (debt.error)\r\n            return (0, 0, 0);\r\n\r\n        require(paid <= _amount, \"Paid can't be more than requested\");\r\n\r\n        // Get token amount to use as payment\r\n        paidToken = _oracle != address(0) ? _toToken(paid, _tokens, _equivalent) : paid;\r\n\r\n        // Pull tokens from payer\r\n        require(token.transferFrom(msg.sender, address(this), paidToken), \"Error pulling payment tokens\");\r\n\r\n        burnToken = _chargeBurnFee(_id, debt.fee, paidToken);\r\n\r\n        // Add balance to debt\r\n        uint256 newBalance = paidToken.add(debt.balance);\r\n        require(newBalance < UINT_128_OVERFLOW, \"uint128 Overflow\");\r\n        debt.balance = uint128(newBalance);\r\n    }\r\n\r\n    function _chargeBurnFee(bytes32 _id, uint128 _fee, uint256 _amount) internal returns (uint256 burnToken) {\r\n        if (_fee == 0)\r\n            return 0;\r\n\r\n        // Get burn token amount from fee percentage\r\n        burnToken = _amount.multdiv(_fee, BASE);\r\n\r\n        if (burnToken == 0)\r\n            return 0;\r\n\r\n        // Pull tokens from payer to Burner\r\n        require(token.transferFrom(msg.sender, burner, burnToken), \"Error pulling fee tokens\");\r\n\r\n        emit ChargeBurnFee(_id, burnToken);\r\n    }\r\n\r\n    function _safePay(\r\n        bytes32 _id,\r\n        Model _model,\r\n        uint256 _available\r\n    ) internal returns (uint256) {\r\n        require(_model != Model(0), \"Debt does not exist\");\r\n\r\n        (bool success, bytes32 paid) = _safeGasCall(\r\n            address(_model),\r\n            abi.encodeWithSelector(\r\n                _model.addPaid.selector,\r\n                _id,\r\n                _available\r\n            )\r\n        );\r\n\r\n        if (success) {\r\n            if (debts[_id].error) {\r\n                emit ErrorRecover({\r\n                    _id: _id,\r\n                    _sender: msg.sender,\r\n                    _value: 0,\r\n                    _gasLeft: gasleft(),\r\n                    _gasLimit: block.gaslimit,\r\n                    _result: paid,\r\n                    _callData: msg.data\r\n                });\r\n\r\n                delete debts[_id].error;\r\n            }\r\n\r\n            return uint256(paid);\r\n        } else {\r\n            emit Error({\r\n                _id: _id,\r\n                _sender: msg.sender,\r\n                _value: msg.value,\r\n                _gasLeft: gasleft(),\r\n                _gasLimit: block.gaslimit,\r\n                _callData: msg.data\r\n            });\r\n            debts[_id].error = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n        Converts an amount in the rate currency to an amount in token\r\n\r\n        @param _amount Amount to convert in rate currency\r\n        @param _tokens How many tokens\r\n        @param _equivalent How much currency _tokens equivales\r\n\r\n        @return _result Amount in tokens\r\n    */\r\n    function _toToken(\r\n        uint256 _amount,\r\n        uint256 _tokens,\r\n        uint256 _equivalent\r\n    ) internal pure returns (uint256 _result) {\r\n        require(_tokens != 0 && _equivalent != 0, \"Oracle provided invalid rate\");\r\n        uint256 aux = _tokens.mult(_amount);\r\n        _result = aux / _equivalent;\r\n        if (aux % _equivalent > 0) {\r\n            _result = _result.add(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n        Converts an amount in token to the rate currency\r\n\r\n        @param _amount Amount to convert in token\r\n        @param _tokens How many tokens\r\n        @param _equivalent How much currency _tokens equivales\r\n\r\n        @return Amount in rate currency\r\n    */\r\n    function _fromToken(\r\n        uint256 _amount,\r\n        uint256 _tokens,\r\n        uint256 _equivalent\r\n    ) internal pure returns (uint256) {\r\n        require(_tokens != 0 && _equivalent != 0, \"Oracle provided invalid rate\");\r\n        return _amount.mult(_equivalent) / _tokens;\r\n    }\r\n\r\n    function run(bytes32 _id) external returns (bool) {\r\n        Debt storage debt = debts[_id];\r\n        require(debt.model != Model(0), \"Debt does not exist\");\r\n\r\n        (bool success, bytes32 result) = _safeGasCall(\r\n            address(debt.model),\r\n            abi.encodeWithSelector(\r\n                debt.model.run.selector,\r\n                _id\r\n            )\r\n        );\r\n\r\n        if (success) {\r\n            if (debt.error) {\r\n                emit ErrorRecover({\r\n                    _id: _id,\r\n                    _sender: msg.sender,\r\n                    _value: 0,\r\n                    _gasLeft: gasleft(),\r\n                    _gasLimit: block.gaslimit,\r\n                    _result: result,\r\n                    _callData: msg.data\r\n                });\r\n\r\n                delete debt.error;\r\n            }\r\n\r\n            return result == bytes32(uint256(1));\r\n        } else {\r\n            emit Error({\r\n                _id: _id,\r\n                _sender: msg.sender,\r\n                _value: 0,\r\n                _gasLeft: gasleft(),\r\n                _gasLimit: block.gaslimit,\r\n                _callData: msg.data\r\n            });\r\n            debt.error = true;\r\n        }\r\n    }\r\n\r\n    function withdraw(bytes32 _id, address _to) external returns (uint256 amount) {\r\n        require(_to != address(0x0), \"_to should not be 0x0\");\r\n        require(_isAuthorized(msg.sender, uint256(_id)), \"Sender not authorized\");\r\n        Debt storage debt = debts[_id];\r\n        amount = debt.balance;\r\n        debt.balance = 0;\r\n        require(token.transfer(_to, amount), \"Error sending tokens\");\r\n        emit Withdrawn({\r\n            _id: _id,\r\n            _sender: msg.sender,\r\n            _to: _to,\r\n            _amount: amount\r\n        });\r\n    }\r\n\r\n    function withdrawPartial(bytes32 _id, address _to, uint256 _amount) external returns (bool success) {\r\n        require(_to != address(0x0), \"_to should not be 0x0\");\r\n        require(_isAuthorized(msg.sender, uint256(_id)), \"Sender not authorized\");\r\n        Debt storage debt = debts[_id];\r\n        debt.balance = uint128(uint256(debt.balance).sub(_amount));\r\n        require(token.transfer(_to, _amount), \"Error sending tokens\");\r\n        emit Withdrawn({\r\n            _id: _id,\r\n            _sender: msg.sender,\r\n            _to: _to,\r\n            _amount: _amount\r\n        });\r\n        success = true;\r\n    }\r\n\r\n    function withdrawBatch(bytes32[] calldata _ids, address _to) external returns (uint256 total) {\r\n        require(_to != address(0x0), \"_to should not be 0x0\");\r\n        bytes32 target;\r\n        uint256 balance;\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            target = _ids[i];\r\n            if (_isAuthorized(msg.sender, uint256(target))) {\r\n                balance = debts[target].balance;\r\n                debts[target].balance = 0;\r\n                total += balance;\r\n                emit Withdrawn({\r\n                    _id: target,\r\n                    _sender: msg.sender,\r\n                    _to: _to,\r\n                    _amount: balance\r\n                });\r\n            }\r\n        }\r\n        require(token.transfer(_to, total), \"Error sending tokens\");\r\n    }\r\n\r\n    function getStatus(bytes32 _id) external view returns (Status) {\r\n        Debt storage debt = debts[_id];\r\n        if (debt.error) {\r\n            return Status.ERROR;\r\n        } else {\r\n            (bool success, uint256 result) = _safeGasStaticCall(\r\n                address(debt.model),\r\n                abi.encodeWithSelector(\r\n                    debt.model.getStatus.selector,\r\n                    _id\r\n                )\r\n            );\r\n            return success ? Status(result) : Status.ERROR;\r\n        }\r\n    }\r\n\r\n    function getFeeAmount(\r\n        bytes32 _id,\r\n        uint256 _amountToPay,\r\n        bytes calldata _oracleData\r\n    ) external view returns (uint256 feeAmount) {\r\n        Debt storage debt = debts[_id];\r\n\r\n        if (debt.fee == 0)\r\n            return 0;\r\n\r\n        uint256 paidToken;\r\n        RateOracle oracle = RateOracle(debt.oracle);\r\n\r\n        if (address(oracle) == address(0)) {\r\n            paidToken = _amountToPay;\r\n        } else {\r\n            // Static convert\r\n            ( bool success, bytes memory returnData ) = address(oracle).staticcall(\r\n                abi.encodeWithSelector(\r\n                    oracle.readSample.selector,\r\n                    _oracleData\r\n                )\r\n            );\r\n\r\n            require(success, \"getFeeAmount: error static reading oracle\");\r\n\r\n            ( uint256 tokens, uint256 equivalent ) = abi.decode(returnData, (uint256, uint256));\r\n\r\n            paidToken = _toToken(_amountToPay, tokens, equivalent);\r\n        }\r\n\r\n        feeAmount = paidToken.multdiv(debt.fee, BASE);\r\n    }\r\n\r\n    function toFee(\r\n        bytes32 _id,\r\n        uint256 _amount\r\n    ) external view returns (uint256 feeAmount) {\r\n        Debt storage debt = debts[_id];\r\n\r\n        if (debt.fee == 0)\r\n            return 0;\r\n\r\n        feeAmount = _amount.multdiv(debt.fee, BASE);\r\n    }\r\n\r\n    function _safeGasStaticCall(\r\n        address _contract,\r\n        bytes memory _data\r\n    ) internal view returns (bool success, uint256 result) {\r\n        bytes memory returnData;\r\n        uint256 _gas = (block.gaslimit * 80) / 100;\r\n\r\n        (success, returnData) = _contract.staticcall{ gas: gasleft() < _gas ? gasleft() : _gas }(_data);\r\n\r\n        if (returnData.length > 0)\r\n            result = abi.decode(returnData, (uint256));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\r\n     * relaxing the requirement on the return value\r\n     *\r\n     * @param _contract The contract that receives the call\r\n     * @param _data The call data\r\n     *\r\n     * @return success True if the call not reverts\r\n     * @return result the result of the call\r\n     */\r\n    function _safeGasCall(\r\n        address _contract,\r\n        bytes memory _data\r\n    ) internal returns (bool success, bytes32 result) {\r\n        bytes memory returnData;\r\n        uint256 _gas = (block.gaslimit * 80) / 100; // Cant overflow, the gas limit * 80 is lower than (2**256)-1\r\n\r\n        (success, returnData) = _contract.call{ gas: gasleft() < _gas ? gasleft() : _gas }(_data);\r\n\r\n        if (returnData.length > 0)\r\n            result = abi.decode(returnData, (bytes32));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_burner\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_fee\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ChargeBurnFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"Created2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"Created3\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasLeft\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_callData\",\"type\":\"bytes\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasLeft\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_result\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_callData\",\"type\":\"bytes\"}],\"name\":\"ErrorRecover\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requestedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_paid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Paid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_targetOracle\",\"type\":\"address\"}],\"name\":\"PayBatchError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_equivalent\",\"type\":\"uint256\"}],\"name\":\"ReadedOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_equivalent\",\"type\":\"uint256\"}],\"name\":\"ReadedOracleBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_burner\",\"type\":\"address\"}],\"name\":\"SetBurner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"_fee\",\"type\":\"uint128\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_uriProvider\",\"type\":\"address\"}],\"name\":\"SetURIProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"assetsOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"buildId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_model\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"buildId2\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"buildId3\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Model\",\"name\":\"_model\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Model\",\"name\":\"_model\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"create2\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Model\",\"name\":\"_model\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"create3\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"debts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"error\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"balance\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"fee\",\"type\":\"uint128\"},{\"internalType\":\"contract Model\",\"name\":\"model\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amountToPay\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_oracleData\",\"type\":\"bytes\"}],\"name\":\"getFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"enum IDebtStatus.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assetHolder\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amountToPay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_oracleData\",\"type\":\"bytes\"}],\"name\":\"pay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paidToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnToken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_ids\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_oracleData\",\"type\":\"bytes\"}],\"name\":\"payBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"paid\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"paidTokens\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"oracleData\",\"type\":\"bytes\"}],\"name\":\"payToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paidToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnToken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_ids\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_oracleData\",\"type\":\"bytes\"}],\"name\":\"payTokenBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"paid\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"paidTokens\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"run\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_userData\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_authorized\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_burner\",\"type\":\"address\"}],\"name\":\"setBurner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_fee\",\"type\":\"uint128\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract URIProvider\",\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"setURIProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"toFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_ids\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPartial\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DebtEngine","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000099393c9df0d0b3a76d5ce80a21549cff0da160d1000000000000000000000000000000000000000000000000000000000000000f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e5b60a53a467d2d9258c09b4c9d51ababb7e450622e6878ac1ea2c377f6ec063"}]}