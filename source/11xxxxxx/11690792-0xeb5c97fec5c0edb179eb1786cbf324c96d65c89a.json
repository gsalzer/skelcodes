{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Relay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Initializable.sol\\\";\\n\\nimport \\\"./Blake2b.sol\\\";\\nimport \\\"./common/Ownable.sol\\\";\\nimport \\\"./common/Pausable.sol\\\";\\nimport \\\"./common/ECDSA.sol\\\";\\nimport \\\"./common/Hash.sol\\\";\\nimport \\\"./common/SafeMath.sol\\\";\\nimport \\\"./common/Input.sol\\\";\\nimport \\\"./common/Bytes.sol\\\";\\nimport \\\"./MMR.sol\\\";\\nimport \\\"./common/Scale.sol\\\";\\nimport \\\"./SimpleMerkleProof.sol\\\";\\n\\n\\npragma experimental ABIEncoderV2;\\n\\ncontract Relay is Ownable, Pausable, Initializable {\\n    using Bytes for bytes;\\n\\n    event SetRootEvent(address relayer, bytes32 root, uint256 index);\\n    event SetAuthoritiesEvent(uint32 nonce, address[] authorities, bytes32 beneficiary);\\n    event ResetRootEvent(address owner, bytes32 root, uint256 index);\\n    event ResetAuthoritiesEvent(uint32 nonce, address[] authorities);\\n\\n    ///\\n    /// Function: updateRelayer(bytes message, bytes[] signatures, bytes32 benefit)\\n    /// MethodID: 0xb4bcf497\\n    ///\\n    /// Function: appendRoot(bytes memory message,bytes[] memory signatures)\\n    /// MethodID: 0x479fbdf9\\n    /// \\n\\n    struct Relayers {\\n        // Each time the relay set is updated, the nonce is incremented\\n        // After the first \\\"updateRelayer\\\" call, the nonce value is equal to 1, \\n        // which is different from the field \\\"Term\\\" at the node.\\n        address[] member;\\n        uint32 nonce;\\n        uint8 threshold;\\n    }\\n\\n    Relayers relayers;\\n\\n    // 'Crab', 'Darwinia', 'Pangolin'\\n    bytes private networkPrefix;\\n\\n    // index => mmr root\\n    // In the Darwinia Network, the mmr root of block 1000 \\n    // needs to be queried in Log-Other of block 1001.\\n    mapping(uint32 => bytes32) public mmrRootPool;\\n\\n    // _MMRIndex - mmr index or block number corresponding to mmr root\\n    // _genesisMMRRoot - mmr root\\n    // _relayers - Keep the same as the \\\"ethereumRelayAuthorities\\\" module in darwinia network\\n    // _nonce - To prevent replay attacks\\n    // _threshold - The threshold for a given level can be set to any number from 0-100. This threshold is the amount of signature weight required to authorize an operation at that level.\\n    // _prefix - The known values are: \\\"Pangolin\\\", \\\"Crab\\\", \\\"Darwinia\\\"\\n    function initialize(\\n        uint32 _MMRIndex,\\n        bytes32 _genesisMMRRoot,\\n        address[] memory _relayers,\\n        uint32 _nonce,\\n        uint8 _threshold,\\n        bytes memory _prefix\\n    ) public initializer {\\n        ownableConstructor();\\n        pausableConstructor();\\n        \\n        _appendRoot(_MMRIndex, _genesisMMRRoot);\\n        _resetRelayer(_nonce, _relayers);\\n        _setNetworkPrefix(_prefix);\\n        _setRelayThreshold(_threshold);\\n    }\\n\\n    /// ==== Getters ==== \\n    function getRelayerCount() public view returns (uint256) {\\n        return relayers.member.length;\\n    }\\n\\n    function getRelayerNonce() public view returns (uint32) {\\n        return relayers.nonce;\\n    }\\n\\n    function getRelayer() public view returns (address[] memory) {\\n        return relayers.member;\\n    }\\n\\n    function getNetworkPrefix() public view returns (bytes memory) {\\n        return networkPrefix;\\n    }\\n\\n    function getRelayerThreshold() public view returns (uint8) {\\n        return relayers.threshold;\\n    }\\n\\n    function getMMRRoot(uint32 index) public view returns (bytes32) {\\n        return mmrRootPool[index];\\n    }\\n\\n    function getLockTokenReceipt(bytes32 root, bytes memory eventsProofStr, bytes memory key)\\n        public\\n        view\\n        whenNotPaused\\n        returns (bytes memory)\\n    {\\n        Input.Data memory data = Input.from(eventsProofStr);\\n\\n        bytes[] memory proofs = Scale.decodeReceiptProof(data);\\n        bytes memory result = SimpleMerkleProof.getEvents(root, key, proofs);\\n        \\n        return result;\\n    }\\n\\n    function isRelayer(address addr) public view returns (bool) {\\n        for (uint256 i = 0; i < relayers.member.length; i++) {\\n            if (addr == relayers.member[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function checkNetworkPrefix(bytes memory prefix) view public returns (bool) {\\n        return getNetworkPrefix().equals(prefix);\\n    }\\n\\n    function checkRelayerNonce(uint32 nonce) view public returns (bool) {\\n      return nonce == getRelayerNonce();\\n    }\\n\\n    /// ==== Setters ==== \\n\\n    // When the darwinia network authorities set is updated, bridger or other users need to submit the new authorities set to the reporter contract by calling this method.\\n    // message - prefix + nonce + [...relayers]\\n    // struct{vec<u8>, u32, vec<EthereumAddress>}\\n    // signatures - signed by personal_sign\\n    // beneficiary - Keeping the authorities set up-to-date is advocated between the relay contract contract and the darwinia network, and the darwinia network will give partial rewards to the benifit account. benifit is the public key of a darwinia network account\\n    function updateRelayer(\\n        bytes memory message,\\n        bytes[] memory signatures,\\n        bytes32 beneficiary\\n    ) public whenNotPaused {\\n        // verify hash, signatures (The number of signers must be greater than _threshold)\\n        require( \\n            _checkSignature(message, signatures),\\n            \\\"Relay: Bad relayer signature\\\"\\n        );\\n\\n        // decode message, check nonce and relayer\\n        Input.Data memory data = Input.from(message);\\n        (bytes memory prefix, bytes4 methodID, uint32 nonce, address[] memory authorities) = Scale.decodeAuthorities(\\n            data\\n        );\\n        \\n        require(checkNetworkPrefix(prefix), \\\"Relay: Bad network prefix\\\");\\n        require(methodID == hex\\\"b4bcf497\\\", \\\"Relay: Bad method ID\\\");\\n        require(checkRelayerNonce(nonce), \\\"Relay: Bad relayer set nonce\\\");\\n\\n        // update nonce,relayer\\n        _updateRelayer(nonce, authorities, beneficiary);\\n    }\\n\\n    // Add a mmr root to the mmr root pool\\n    // message - bytes4 prefix + uint32 mmr-index + bytes32 mmr-root\\n    // struct{vec<u8>, u32, H256}\\n    // encode by scale codec\\n    // signatures - The signature for message\\n    // https://github.com/darwinia-network/darwinia-common/pull/381\\n    function appendRoot(\\n        bytes memory message,\\n        bytes[] memory signatures\\n    ) public whenNotPaused {\\n        // verify hash, signatures\\n        require(\\n            _checkSignature(message, signatures),\\n            \\\"Relay: Bad relayer signature\\\"\\n        );\\n\\n        // decode message, check nonce and relayer\\n        Input.Data memory data = Input.from(message);\\n        (bytes memory prefix, bytes4 methodID, uint32 index, bytes32 root) = Scale.decodeMMRRoot(data);\\n\\n        require(checkNetworkPrefix(prefix), \\\"Relay: Bad network prefix\\\");\\n        require(methodID == hex\\\"479fbdf9\\\", \\\"Relay: Bad method ID\\\");\\n\\n        // append index, root\\n        _appendRoot(index, root);\\n    }\\n\\n    function verifyRootAndDecodeReceipt(\\n        bytes32 root,\\n        uint32 MMRIndex,\\n        uint32 blockNumber,\\n        bytes memory blockHeader,\\n        bytes32[] memory peaks,\\n        bytes32[] memory siblings,\\n        bytes memory eventsProofStr,\\n        bytes memory key\\n    ) public view whenNotPaused returns (bytes memory){\\n        // verify block proof\\n        require(\\n            verifyBlockProof(root, MMRIndex, blockNumber, blockHeader, peaks, siblings),\\n            \\\"Relay: Block header proof varification failed\\\"\\n        );\\n\\n        // get state root\\n        bytes32 stateRoot = Scale.decodeStateRootFromBlockHeader(blockHeader);\\n\\n        return getLockTokenReceipt(stateRoot, eventsProofStr, key);\\n    }\\n\\n    function verifyBlockProof(\\n        bytes32 root,\\n        uint32 MMRIndex,\\n        uint32 blockNumber,\\n        bytes memory blockHeader,\\n        bytes32[] memory peaks,\\n        bytes32[] memory siblings\\n    ) public view whenNotPaused returns (bool) {\\n        require(\\n            getMMRRoot(MMRIndex) != bytes32(0),\\n            \\\"Relay: Not registered under this index\\\"\\n        );\\n        require(\\n            getMMRRoot(MMRIndex) == root,\\n            \\\"Relay: Root is different from the root pool\\\"\\n        );\\n\\n        return MMR.inclusionProof(root, MMRIndex + 1, blockNumber, blockHeader, peaks, siblings);\\n    }\\n\\n\\n    /// ==== onlyOwner ==== \\n    function resetRoot(uint32 index, bytes32 root) public onlyOwner {\\n        _setRoot(index, root);\\n        emit ResetRootEvent(_msgSender(), root, index);\\n    }\\n\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    function resetNetworkPrefix(bytes memory _prefix) public onlyOwner {\\n        _setNetworkPrefix(_prefix);\\n    }\\n\\n    function resetRelayerThreshold(uint8 _threshold) public onlyOwner {\\n        _setRelayThreshold(_threshold);\\n    }\\n\\n    function resetRelayer(uint32 nonce, address[] memory accounts) public onlyOwner {\\n        _resetRelayer(nonce, accounts);\\n    }\\n\\n    /// ==== Internal ==== \\n    function _updateRelayer(uint32 nonce, address[] memory accounts, bytes32 beneficiary) internal {\\n        require(accounts.length > 0, \\\"Relay: accounts is empty\\\");\\n\\n        emit SetAuthoritiesEvent(nonce, accounts, beneficiary);\\n\\n        relayers.member = accounts;\\n        relayers.nonce = getRelayerNonce() + 1;    \\n    }\\n\\n    function _resetRelayer(uint32 nonce, address[] memory accounts) internal {\\n        require(accounts.length > 0, \\\"Relay: accounts is empty\\\");\\n        relayers.member = accounts;\\n        relayers.nonce = nonce;\\n\\n        emit ResetAuthoritiesEvent(nonce, accounts);\\n    }\\n\\n    function _appendRoot(uint32 index, bytes32 root) internal {\\n        require(getMMRRoot(index) == bytes32(0), \\\"Relay: Index has been set\\\");\\n\\n        _setRoot(index, root);\\n    }\\n\\n    function _setRoot(uint32 index, bytes32 root) internal {\\n        mmrRootPool[index] = root;\\n        emit SetRootEvent(_msgSender(), root, index);\\n    }\\n\\n    function _setNetworkPrefix(bytes memory prefix) internal {\\n        networkPrefix = prefix;\\n    }\\n\\n    function _setRelayThreshold(uint8 _threshold) internal {\\n        require(_threshold > 0, \\\"Relay:: _setRelayThreshold: _threshold equal to 0\\\");\\n        relayers.threshold = _threshold;\\n    }\\n\\n    // This method verifies the content of msg by verifying the existing authority collection in the contract. \\n    // Ecdsa.recover can recover the signer’s address. \\n    // If the signer is matched \\\"isRelayer\\\", it will be counted as a valid signature \\n    // and all signatures will be restored. \\n    // If the number of qualified signers is greater than Equal to threshold, \\n    // the verification is considered successful, otherwise it fails\\n    function _checkSignature(\\n        bytes memory message,\\n        bytes[] memory signatures\\n    ) internal view returns (bool) {\\n        require(signatures.length != 0, \\\"Relay:: _checkSignature: signatures is empty\\\");\\n        bytes32 hash = keccak256(message);\\n        uint256 count;\\n        address[] memory signers = new address[](signatures.length);\\n        bytes32 ethSignedMessageHash = ECDSA.toEthSignedMessageHash(hash);\\n\\n        for (uint256 i = 0; i < signatures.length; i++) {\\n            address signer = ECDSA.recover(ethSignedMessageHash, signatures[i]);\\n            signers[i] = signer;\\n        }\\n\\n        require(!hasDuplicate(signers), \\\"Relay:: hasDuplicate: Duplicate entries in list\\\");\\n        \\n        for (uint256 i = 0; i < signatures.length; i++) {\\n            if (isRelayer(signers[i])) {\\n               count++;\\n            }\\n        }\\n        \\n        uint8 threshold = uint8(\\n            SafeMath.div(SafeMath.mul(count, 100), getRelayerCount())\\n        );\\n\\n        return threshold >= getRelayerThreshold();\\n    }\\n\\n    /**\\n    * Returns whether or not there's a duplicate. Runs in O(n^2).\\n    * @param A Array to search\\n    * @return Returns true if duplicate, false otherwise\\n    */\\n    function hasDuplicate(address[] memory A) internal pure returns (bool) {\\n        if (A.length == 0) {\\n            return false;\\n        }\\n        for (uint256 i = 0; i < A.length - 1; i++) {\\n            for (uint256 j = i + 1; j < A.length; j++) {\\n                if (A[i] == A[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n * \\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n * \\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        address self = address(this);\\n        uint256 cs;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { cs := extcodesize(self) }\\n        return cs == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Blake2b.sol\": {\r\n      \"content\": \"/*\\n * Blake2b library in Solidity using EIP-152\\n *\\n * Copyright (C) 2019 Alex Beregszaszi\\n *\\n * License: Apache 2.0\\n */\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Blake2b {\\n    struct Instance {\\n        // This is a bit misleadingly called state as it not only includes the Blake2 state,\\n        // but every field needed for the \\\"blake2 f function precompile\\\".\\n        //\\n        // This is a tightly packed buffer of:\\n        // - rounds: 32-bit BE\\n        // - h: 8 x 64-bit LE\\n        // - m: 16 x 64-bit LE\\n        // - t: 2 x 64-bit LE\\n        // - f: 8-bit\\n        bytes state;\\n        // Expected output hash length. (Used in `finalize`.)\\n        uint out_len;\\n        // Data passed to \\\"function F\\\".\\n        // NOTE: this is limited to 24 bits.\\n        uint input_counter;\\n    }\\n\\n    // Initialise the state with a given `key` and required `out_len` hash length.\\n    function init(bytes memory key, uint out_len)\\n        internal\\n        view\\n        returns (Instance memory instance)\\n    {\\n        // Safety check that the precompile exists.\\n        // TODO: remove this?\\n        // assembly {\\n        //    if eq(extcodehash(0x09), 0) { revert(0, 0) }\\n        //}\\n\\n        reset(instance, key, out_len);\\n    }\\n\\n    // Initialise the state with a given `key` and required `out_len` hash length.\\n    function reset(Instance memory instance, bytes memory key, uint out_len)\\n        internal\\n        view\\n    {\\n        instance.out_len = out_len;\\n        instance.input_counter = 0;\\n\\n        // This is entire state transmitted to the precompile.\\n        // It is byteswapped for the encoding requirements, additionally\\n        // the IV has the initial parameter block 0 XOR constant applied, but\\n        // not the key and output length.\\n        instance.state = hex\\\"0000000c08c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\\";\\n        bytes memory state = instance.state;\\n\\n        // Update parameter block 0 with key length and output length.\\n        uint key_len = key.length;\\n        assembly {\\n            let ptr := add(state, 36)\\n            let tmp := mload(ptr)\\n            let p0 := or(shl(240, key_len), shl(248, out_len))\\n            tmp := xor(tmp, p0)\\n            mstore(ptr, tmp)\\n        }\\n\\n        // TODO: support salt and personalization\\n\\n        if (key_len > 0) {\\n            require(key_len == 64);\\n            // FIXME: the key must be zero padded\\n            assert(key.length == 128);\\n            update(instance, key, key_len);\\n        }\\n    }\\n\\n    // This calls the blake2 precompile (\\\"function F of the spec\\\").\\n    // It expects the state was updated with the next block. Upon returning the state will be updated,\\n    // but the supplied block data will not be cleared.\\n    function call_function_f(Instance memory instance)\\n        private\\n        view\\n    {\\n        bytes memory state = instance.state;\\n        assembly {\\n            let state_ptr := add(state, 32)\\n            if iszero(staticcall(not(0), 0x09, state_ptr, 0xd5, add(state_ptr, 4), 0x40)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    // This function will split blocks correctly and repeatedly call the precompile.\\n    // NOTE: this is dumb right now and expects `data` to be 128 bytes long and padded with zeroes,\\n    //       hence the real length is indicated with `data_len`\\n    function update_loop(Instance memory instance, bytes memory data, uint data_len, bool last_block)\\n        private\\n        view\\n    {\\n        bytes memory state = instance.state;\\n        uint input_counter = instance.input_counter;\\n\\n        // This is the memory location where the \\\"data block\\\" starts for the precompile.\\n        uint state_ptr;\\n        assembly {\\n            // The `rounds` field is 4 bytes long and the `h` field is 64-bytes long.\\n            // Also adjust for the size of the bytes type.\\n            state_ptr := add(state, 100)\\n        }\\n\\n        // This is the memory location where the input data resides.\\n        uint data_ptr;\\n        assembly {\\n            data_ptr := add(data, 32)\\n        }\\n\\n        uint len = data.length;\\n        while (len > 0) {\\n            if (len >= 128) {\\n                assembly {\\n                    mstore(state_ptr, mload(data_ptr))\\n                    data_ptr := add(data_ptr, 32)\\n\\n                    mstore(add(state_ptr, 32), mload(data_ptr))\\n                    data_ptr := add(data_ptr, 32)\\n\\n                    mstore(add(state_ptr, 64), mload(data_ptr))\\n                    data_ptr := add(data_ptr, 32)\\n\\n                    mstore(add(state_ptr, 96), mload(data_ptr))\\n                    data_ptr := add(data_ptr, 32)\\n                }\\n\\n                len -= 128;\\n                // FIXME: remove this once implemented proper padding\\n                if (data_len < 128) {\\n                    input_counter += data_len;\\n                } else {\\n                    data_len -= 128;\\n                    input_counter += 128;\\n                }\\n            } else {\\n                // FIXME: implement support for smaller than 128 byte blocks\\n                revert();\\n            }\\n\\n            // Set length field (little-endian) for maximum of 24-bits.\\n            assembly {\\n                mstore8(add(state, 228), and(input_counter, 0xff))\\n                mstore8(add(state, 229), and(shr(8, input_counter), 0xff))\\n                mstore8(add(state, 230), and(shr(16, input_counter), 0xff))\\n            }\\n\\n            // Set the last block indicator.\\n            // Only if we've processed all input.\\n            if (len == 0) {\\n                assembly {\\n                    // Writing byte 212 here.\\n                    mstore8(add(state, 244), last_block)\\n                }\\n            }\\n\\n            // Call the precompile\\n            call_function_f(instance);\\n        }\\n\\n        instance.input_counter = input_counter;\\n    }\\n\\n    // Update the state with a non-final block.\\n    // NOTE: the input must be complete blocks.\\n    function update(Instance memory instance, bytes memory data, uint data_len)\\n        internal\\n        view\\n    {\\n        require((data.length % 128) == 0);\\n        update_loop(instance, data, data_len, false);\\n    }\\n\\n    // Update the state with a final block and return the hash.\\n    function finalize(Instance memory instance, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory output)\\n    {\\n        // FIXME: support incomplete blocks (zero pad them)\\n        uint input_length = data.length;\\n        if (input_length == 0 || (input_length % 128) != 0) {\\n            data = concat(data, new bytes(128 - (input_length % 128)));\\n        }\\n        assert((data.length % 128) == 0);\\n        update_loop(instance, data, input_length, true);\\n\\n        // FIXME: support other lengths\\n        // assert(instance.out_len == 64);\\n\\n        bytes memory state = instance.state;\\n        output = new bytes(instance.out_len);\\n        if(instance.out_len == 32) {\\n            assembly {\\n                mstore(add(output, 32), mload(add(state, 36)))\\n            }\\n        } else {\\n            assembly {\\n                mstore(add(output, 32), mload(add(state, 36)))\\n                mstore(add(output, 64), mload(add(state, 68)))\\n            }\\n        }\\n    }\\n\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/common/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function ownableConstructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\ncontract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function pausableConstructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!_paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(_paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\"\r\n    },\r\n    \"contracts/common/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\"\r\n    },\r\n    \"contracts/common/Hash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\n// import \\\"./Memory.sol\\\";\\nimport \\\"../Blake2b.sol\\\";\\n\\nlibrary Hash {\\n\\n    using Blake2b for Blake2b.Instance;\\n\\n    // function hash(bytes memory src) internal view returns (bytes memory des) {\\n    //     return Memory.toBytes(keccak256(src));\\n        // Blake2b.Instance memory instance = Blake2b.init(hex\\\"\\\", 32);\\n        // return instance.finalize(src);\\n    // }\\n\\n    function blake2bHash(bytes memory src) internal view returns (bytes32 des) {\\n        // return keccak256(src);\\n        Blake2b.Instance memory instance = Blake2b.init(hex\\\"\\\", 32);\\n        return abi.decode(instance.finalize(src), (bytes32));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/SafeMath.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/common/Input.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"./Bytes.sol\\\";\\n\\nlibrary Input {\\n    using Bytes for bytes;\\n\\n    struct Data {\\n        uint256 offset;\\n        bytes raw;\\n    }\\n\\n    function from(bytes memory data) internal pure returns (Data memory) {\\n        return Data({offset: 0, raw: data});\\n    }\\n\\n    modifier shift(Data memory data, uint256 size) {\\n        require(data.raw.length >= data.offset + size, \\\"Input: Out of range\\\");\\n        _;\\n        data.offset += size;\\n    }\\n\\n    function shiftBytes(Data memory data, uint256 size) internal pure {\\n        require(data.raw.length >= data.offset + size, \\\"Input: Out of range\\\");\\n        data.offset += size;\\n    }\\n\\n    function finished(Data memory data) internal pure returns (bool) {\\n        return data.offset == data.raw.length;\\n    }\\n\\n    function peekU8(Data memory data) internal pure returns (uint8 v) {\\n        return uint8(data.raw[data.offset]);\\n    }\\n\\n    function decodeU8(Data memory data)\\n        internal\\n        pure\\n        shift(data, 1)\\n        returns (uint8 value)\\n    {\\n        value = uint8(data.raw[data.offset]);\\n    }\\n\\n    function decodeU16(Data memory data) internal pure returns (uint16 value) {\\n        value = uint16(decodeU8(data));\\n        value |= (uint16(decodeU8(data)) << 8);\\n    }\\n\\n    function decodeU32(Data memory data) internal pure returns (uint32 value) {\\n        value = uint32(decodeU16(data));\\n        value |= (uint32(decodeU16(data)) << 16);\\n    }\\n\\n    function decodeBytesN(Data memory data, uint256 N)\\n        internal\\n        pure\\n        shift(data, N)\\n        returns (bytes memory value)\\n    {\\n        value = data.raw.substr(data.offset, N);\\n    }\\n\\n    function decodeBytes4(Data memory data) internal pure shift(data, 4) returns(bytes4 value) {\\n        bytes memory raw = data.raw;\\n        uint256 offset = data.offset;\\n\\n        assembly {\\n            value := mload(add(add(raw, 32), offset))\\n        }\\n    }\\n\\n    function decodeBytes32(Data memory data) internal pure shift(data, 32) returns(bytes32 value) {\\n        bytes memory raw = data.raw;\\n        uint256 offset = data.offset;\\n\\n        assembly {\\n            value := mload(add(add(raw, 32), offset))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Bytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport {Memory} from \\\"./Memory.sol\\\";\\n\\nlibrary Bytes {\\n    uint256 internal constant BYTES_HEADER_SIZE = 32;\\n\\n    // Checks if two `bytes memory` variables are equal. This is done using hashing,\\n    // which is much more gas efficient then comparing each byte individually.\\n    // Equality means that:\\n    //  - 'self.length == other.length'\\n    //  - For 'n' in '[0, self.length)', 'self[n] == other[n]'\\n    function equals(bytes memory self, bytes memory other) internal pure returns (bool equal) {\\n        if (self.length != other.length) {\\n            return false;\\n        }\\n        uint addr;\\n        uint addr2;\\n        assembly {\\n            addr := add(self, /*BYTES_HEADER_SIZE*/32)\\n            addr2 := add(other, /*BYTES_HEADER_SIZE*/32)\\n        }\\n        equal = Memory.equals(addr, addr2, self.length);\\n    }\\n\\n    // Copies a section of 'self' into a new array, starting at the provided 'startIndex'.\\n    // Returns the new copy.\\n    // Requires that 'startIndex <= self.length'\\n    // The length of the substring is: 'self.length - startIndex'\\n    function substr(bytes memory self, uint256 startIndex)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(startIndex <= self.length);\\n        uint256 len = self.length - startIndex;\\n        uint256 addr = Memory.dataPtr(self);\\n        return Memory.toBytes(addr + startIndex, len);\\n    }\\n\\n    // Copies 'len' bytes from 'self' into a new array, starting at the provided 'startIndex'.\\n    // Returns the new copy.\\n    // Requires that:\\n    //  - 'startIndex + len <= self.length'\\n    // The length of the substring is: 'len'\\n    function substr(\\n        bytes memory self,\\n        uint256 startIndex,\\n        uint256 len\\n    ) internal pure returns (bytes memory) {\\n        require(startIndex + len <= self.length);\\n        if (len == 0) {\\n            return \\\"\\\";\\n        }\\n        uint256 addr = Memory.dataPtr(self);\\n        return Memory.toBytes(addr + startIndex, len);\\n    }\\n\\n    // Combines 'self' and 'other' into a single array.\\n    // Returns the concatenated arrays:\\n    //  [self[0], self[1], ... , self[self.length - 1], other[0], other[1], ... , other[other.length - 1]]\\n    // The length of the new array is 'self.length + other.length'\\n    function concat(bytes memory self, bytes memory other)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory ret = new bytes(self.length + other.length);\\n        uint256 src;\\n        uint256 srcLen;\\n        (src, srcLen) = Memory.fromBytes(self);\\n        uint256 src2;\\n        uint256 src2Len;\\n        (src2, src2Len) = Memory.fromBytes(other);\\n        uint256 dest;\\n        (dest, ) = Memory.fromBytes(ret);\\n        uint256 dest2 = dest + srcLen;\\n        Memory.copy(src, dest, srcLen);\\n        Memory.copy(src2, dest2, src2Len);\\n        return ret;\\n    }\\n\\n    function toBytes32(bytes memory self)\\n        internal\\n        pure\\n        returns (bytes32 out)\\n    {\\n        require(self.length >= 32, \\\"Bytes:: toBytes32: data is to short.\\\");\\n        assembly {\\n            out := mload(add(self, 32))\\n        }\\n    }\\n\\n    function toBytes16(bytes memory self, uint256 offset)\\n        internal\\n        pure\\n        returns (bytes16 out)\\n    {\\n        for (uint i = 0; i < 16; i++) {\\n            out |= bytes16(byte(self[offset + i]) & 0xFF) >> (i * 8);\\n        }\\n    }\\n\\n    function toBytes4(bytes memory self, uint256 offset)\\n        internal\\n        pure\\n        returns (bytes4)\\n    {\\n        bytes4 out;\\n\\n        for (uint256 i = 0; i < 4; i++) {\\n            out |= bytes4(self[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    function toBytes2(bytes memory self, uint256 offset)\\n        internal\\n        pure\\n        returns (bytes2)\\n    {\\n        bytes2 out;\\n\\n        for (uint256 i = 0; i < 2; i++) {\\n            out |= bytes2(self[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MMR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport { Hash } from \\\"./common/Hash.sol\\\";\\n\\n/**\\n * @title Merkle Mountain Range solidity library\\n *\\n * @dev The index of this MMR implementation starts from 1 not 0.\\n *      And it uses Blake2bHash for its hash function instead of blake2b\\n */\\nlibrary MMR {\\n    function bytes32Concat(bytes32 b1, bytes32 b2) public pure returns (bytes memory)\\n    {\\n        bytes memory result = new bytes(64);\\n        assembly {\\n            mstore(add(result, 32), b1)\\n            mstore(add(result, 64), b2)\\n        }\\n        return result;\\n    }\\n\\n    function getSize(uint width) public pure returns (uint256) {\\n        return (width << 1) - numOfPeaks(width);\\n    }\\n\\n    function peakBagging(bytes32[] memory peaks) view public returns (bytes32) {\\n        // peaks may be merged\\n        // require(numOfPeaks(width) == peaks.length, \\\"Received invalid number of peaks\\\");\\n        bytes32 mergeHash = peaks[0];\\n        for(uint i = peaks.length-1; i >= 1; i = i - 1) {\\n            bytes32 r;\\n            if(i == peaks.length-1) {\\n                r = peaks[i];\\n            } else {\\n                r = mergeHash;\\n            }\\n            bytes32 l = peaks[i-1];\\n            mergeHash = hashBranch(r, l);\\n        }\\n\\n        return mergeHash;\\n    }\\n\\n    /** Pure functions */\\n\\n    /**\\n     * @dev It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\\n     */\\n    function inclusionProof(\\n        bytes32 root,\\n        uint256 width,\\n        uint256 blockNumber,\\n        bytes memory value,\\n        bytes32[] memory peaks,\\n        bytes32[] memory siblings\\n    ) view internal returns (bool) {\\n        require(width >= blockNumber + 1, \\\"blockNumber is out of range\\\");\\n        uint index = getSize(blockNumber) + 1;\\n        // Check the root equals the peak bagging hash\\n        require(root == peakBagging(peaks), \\\"Invalid root hash from the peaks\\\");\\n\\n        // Find the mountain where the target index belongs to\\n        uint256 cursor;\\n        bytes32 targetPeak;\\n        uint256[] memory peakIndexes = getPeakIndexes(width);\\n        for (uint i = 0; i < peakIndexes.length; i++) {\\n            if (peakIndexes[i] >= index) {\\n                targetPeak = peaks[i];\\n                cursor = peakIndexes[i];\\n                break;\\n            }\\n        }\\n        require(targetPeak != bytes32(0), \\\"Target is not found\\\");\\n\\n        // Find the path climbing down\\n        uint256[] memory path = new uint256[](siblings.length + 1);\\n        uint256 left;\\n        uint256 right;\\n        uint8 height = uint8(siblings.length) + 1;\\n        while (height > 0) {\\n            // Record the current cursor and climb down\\n            path[--height] = cursor;\\n            if (cursor == index) {\\n                // On the leaf node. Stop climbing down\\n                break;\\n            } else {\\n                // On the parent node. Go left or right\\n                (left, right) = getChildren(cursor);\\n                cursor = index > left ? right : left;\\n                continue;\\n            }\\n        }\\n\\n        // Calculate the summit hash climbing up again\\n        bytes32 node;\\n        while (height < path.length) {\\n            // Move cursor\\n            cursor = path[height];\\n            if (height == 0) {\\n                // cursor is on the leaf\\n                node = hashLeaf(value);\\n                // node = valueHash;\\n            } else if (cursor - 1 == path[height - 1]) {\\n                // cursor is on a parent and a sibling is on the left\\n                node = hashBranch(siblings[height - 1], node);\\n            } else {\\n                // cursor is on a parent and a sibling is on the right\\n                node = hashBranch(node, siblings[height - 1]);\\n            }\\n            // Climb up\\n            height++;\\n        }\\n\\n        // Computed hash value of the summit should equal to the target peak hash\\n        require(node == targetPeak, \\\"Hashed peak is invalid\\\");\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev It returns the hash a parent node with hash(M | Left child | Right child)\\n     *      M is the index of the node\\n     */\\n    function hashBranch(bytes32 left, bytes32 right) view public returns (bytes32) {\\n        // return Blake2bHash(abi.encodePacked(index, left, right));\\n        return Hash.blake2bHash(bytes32Concat(left, right));\\n    }\\n\\n    /**\\n     * @dev it returns the hash of a leaf node with hash(M | DATA )\\n     *      M is the index of the node\\n     */\\n    function hashLeaf(bytes memory data) view public returns (bytes32) {\\n        return Hash.blake2bHash(data);\\n        // return Blake2bHash(abi.encodePacked(index, dataHash));\\n    }\\n\\n    /**\\n     * @dev It returns the height of the highest peak\\n     */\\n    function mountainHeight(uint256 size) internal pure returns (uint8) {\\n        uint8 height = 1;\\n        while (uint256(1) << height <= size + height) {\\n            height++;\\n        }\\n        return height - 1;\\n    }\\n\\n    /**\\n     * @dev It returns the height of the index\\n     */\\n    function heightAt(uint256 index) public pure returns (uint8 height) {\\n        uint256 reducedIndex = index;\\n        uint256 peakIndex;\\n        // If an index has a left mountain subtract the mountain\\n        while (reducedIndex > peakIndex) {\\n            reducedIndex -= (uint256(1) << height) - 1;\\n            height = mountainHeight(reducedIndex);\\n            peakIndex = (uint256(1) << height) - 1;\\n        }\\n        // Index is on the right slope\\n        height = height - uint8((peakIndex - reducedIndex));\\n    }\\n\\n    /**\\n     * @dev It returns the children when it is a parent node\\n     */\\n    function getChildren(uint256 index) public pure returns (uint256 left, uint256 right) {\\n        left = 0;\\n        right = 0;\\n        left = index - (uint256(1) << (heightAt(index) - 1));\\n        right = index - 1;\\n        require(left != right, \\\"Not a parent\\\");\\n        return (left, right);\\n    }\\n\\n    /**\\n     * @dev It returns all peaks of the smallest merkle mountain range tree which includes\\n     *      the given index(size)\\n     */\\n    function getPeakIndexes(uint256 width) public pure returns (uint256[] memory peakIndexes) {\\n        peakIndexes = new uint256[](numOfPeaks(width));\\n        uint count;\\n        uint size;\\n        for(uint i = 255; i > 0; i--) {\\n            if(width & (1 << (i - 1)) != 0) {\\n                // peak exists\\n                size = size + (1 << i) - 1;\\n                peakIndexes[count++] = size;\\n            }\\n        }\\n        require(count == peakIndexes.length, \\\"Invalid bit calculation\\\");\\n    }\\n\\n    function numOfPeaks(uint256 width) public pure returns (uint num) {\\n        uint256 bits = width;\\n        while(bits > 0) {\\n            if(bits % 2 == 1) num++;\\n            bits = bits >> 1;\\n        }\\n        return num;\\n    }\\n}\"\r\n    },\r\n    \"contracts/common/Scale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"./Input.sol\\\";\\nimport \\\"./Bytes.sol\\\";\\nimport { ScaleStruct } from \\\"./Scale.struct.sol\\\";\\n\\npragma experimental ABIEncoderV2;\\n\\nlibrary Scale {\\n    using Input for Input.Data;\\n    using Bytes for bytes;\\n\\n    // Vec<Event>    Event = <index, Data>   Data = {accountId, EthereumAddress, types, Balance}\\n    // bytes memory hexData = hex\\\"102403d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27ddac17f958d2ee523a2206206994597c13d831ec700000e5fa31c00000000000000000000002404d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27ddac17f958d2ee523a2206206994597c13d831ec70100e40b5402000000000000000000000024038eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48b20bd5d04be54f870d5c0d3ca85d82b34b8364050000d0b72b6a000000000000000000000024048eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48b20bd5d04be54f870d5c0d3ca85d82b34b8364050100c817a8040000000000000000000000\\\";\\n    function decodeLockEvents(Input.Data memory data)\\n        internal\\n        pure\\n        returns (ScaleStruct.LockEvent[] memory)\\n    {\\n        uint32 len = decodeU32(data);\\n        ScaleStruct.LockEvent[] memory events = new ScaleStruct.LockEvent[](len);\\n\\n        for(uint i = 0; i < len; i++) {\\n            events[i] = ScaleStruct.LockEvent({\\n                index: data.decodeBytesN(2).toBytes2(0),\\n                sender: decodeAccountId(data),\\n                recipient: decodeEthereumAddress(data),\\n                token: decodeEthereumAddress(data),\\n                value: decodeBalance(data)\\n            });\\n        }\\n\\n        return events;\\n    }\\n\\n    /** Header */\\n    // export interface Header extends Struct {\\n    //     readonly parentHash: Hash;\\n    //     readonly number: Compact<BlockNumber>;\\n    //     readonly stateRoot: Hash;\\n    //     readonly extrinsicsRoot: Hash;\\n    //     readonly digest: Digest;\\n    // }\\n    function decodeStateRootFromBlockHeader(\\n        bytes memory header\\n    ) internal pure returns (bytes32 root) {\\n        uint8 offset = decodeCompactU8aOffset(header[32]);\\n        assembly {\\n            root := mload(add(add(header, 0x40), offset))\\n        }\\n        return root;\\n    }\\n\\n    function decodeBlockNumberFromBlockHeader(\\n        bytes memory header\\n    ) internal pure returns (uint32 blockNumber) {\\n        Input.Data memory data = Input.from(header);\\n        \\n        // skip parentHash(Hash)\\n        data.shiftBytes(32);\\n\\n        blockNumber = decodeU32(data);\\n    }\\n\\n    // little endian\\n    function decodeMMRRoot(Input.Data memory data) \\n        internal\\n        pure\\n        returns (bytes memory prefix, bytes4 methodID, uint32 width, bytes32 root)\\n    {\\n        prefix = decodePrefix(data);\\n        methodID = data.decodeBytes4();\\n        width = decodeU32(data);\\n        root = data.decodeBytes32();\\n    }\\n\\n    function decodeAuthorities(Input.Data memory data)\\n        internal\\n        pure\\n        returns (bytes memory prefix, bytes4 methodID, uint32 nonce, address[] memory authorities)\\n    {\\n        prefix = decodePrefix(data);\\n        methodID = data.decodeBytes4();\\n        nonce = decodeU32(data);\\n\\n        uint authoritiesLength = decodeU32(data);\\n\\n        authorities = new address[](authoritiesLength);\\n        for(uint i = 0; i < authoritiesLength; i++) {\\n            authorities[i] = decodeEthereumAddress(data);\\n        }\\n    }\\n\\n    // decode authorities prefix\\n    // (crab, darwinia)\\n    function decodePrefix(Input.Data memory data) \\n        internal\\n        pure\\n        returns (bytes memory prefix) \\n    {\\n        prefix = decodeByteArray(data);\\n    }\\n\\n    // decode Ethereum address\\n    function decodeEthereumAddress(Input.Data memory data) \\n        internal\\n        pure\\n        returns (address addr) \\n    {\\n        bytes memory bys = data.decodeBytesN(20);\\n        assembly {\\n            addr := mload(add(bys,20))\\n        } \\n    }\\n\\n    // decode Balance\\n    function decodeBalance(Input.Data memory data) \\n        internal\\n        pure\\n        returns (uint128) \\n    {\\n        bytes memory balance = data.decodeBytesN(16);\\n        return uint128(reverseBytes16(balance.toBytes16(0)));\\n    }\\n\\n    // decode darwinia network account Id\\n    function decodeAccountId(Input.Data memory data) \\n        internal\\n        pure\\n        returns (bytes32 accountId) \\n    {\\n        accountId = data.decodeBytes32();\\n    }\\n\\n    // decodeReceiptProof receives Scale Codec of Vec<Vec<u8>> structure, \\n    // the Vec<u8> is the proofs of mpt\\n    // returns (bytes[] memory proofs)\\n    function decodeReceiptProof(Input.Data memory data) \\n        internal\\n        pure\\n        returns (bytes[] memory proofs) \\n    {\\n        proofs = decodeVecBytesArray(data);\\n    }\\n\\n    // decodeVecBytesArray accepts a Scale Codec of type Vec<Bytes> and returns an array of Bytes\\n    function decodeVecBytesArray(Input.Data memory data)\\n        internal\\n        pure\\n        returns (bytes[] memory v) \\n    {\\n        uint32 vecLenght = decodeU32(data);\\n        v = new bytes[](vecLenght);\\n        for(uint i = 0; i < vecLenght; i++) {\\n            uint len = decodeU32(data);\\n            v[i] = data.decodeBytesN(len);\\n        }\\n        return v;\\n    }\\n\\n    // decodeByteArray accepts a byte array representing a SCALE encoded byte array and performs SCALE decoding\\n    // of the byte array\\n    function decodeByteArray(Input.Data memory data)\\n        internal\\n        pure\\n        returns (bytes memory v)\\n    {\\n        uint32 len = decodeU32(data);\\n        if (len == 0) {\\n            return v;\\n        }\\n        v = data.decodeBytesN(len);\\n        return v;\\n    }\\n\\n    // decodeU32 accepts a byte array representing a SCALE encoded integer and performs SCALE decoding of the smallint\\n    function decodeU32(Input.Data memory data) internal pure returns (uint32) {\\n        uint8 b0 = data.decodeU8();\\n        uint8 mode = b0 & 3;\\n        require(mode <= 2, \\\"scale decode not support\\\");\\n        if (mode == 0) {\\n            return uint32(b0) >> 2;\\n        } else if (mode == 1) {\\n            uint8 b1 = data.decodeU8();\\n            uint16 v = uint16(b0) | (uint16(b1) << 8);\\n            return uint32(v) >> 2;\\n        } else if (mode == 2) {\\n            uint8 b1 = data.decodeU8();\\n            uint8 b2 = data.decodeU8();\\n            uint8 b3 = data.decodeU8();\\n            uint32 v = uint32(b0) |\\n                (uint32(b1) << 8) |\\n                (uint32(b2) << 16) |\\n                (uint32(b3) << 24);\\n            return v >> 2;\\n        }\\n    }\\n\\n    // encodeByteArray performs the following:\\n    // b -> [encodeInteger(len(b)) b]\\n    function encodeByteArray(bytes memory src)\\n        internal\\n        pure\\n        returns (bytes memory des, uint256 bytesEncoded)\\n    {\\n        uint256 n;\\n        (des, n) = encodeU32(uint32(src.length));\\n        bytesEncoded = n + src.length;\\n        des = abi.encodePacked(des, src);\\n    }\\n\\n    // encodeU32 performs the following on integer i:\\n    // i  -> i^0...i^n where n is the length in bits of i\\n    // if n < 2^6 write [00 i^2...i^8 ] [ 8 bits = 1 byte encoded  ]\\n    // if 2^6 <= n < 2^14 write [01 i^2...i^16] [ 16 bits = 2 byte encoded  ]\\n    // if 2^14 <= n < 2^30 write [10 i^2...i^32] [ 32 bits = 4 byte encoded  ]\\n    function encodeU32(uint32 i) internal pure returns (bytes memory, uint256) {\\n        // 1<<6\\n        if (i < 64) {\\n            uint8 v = uint8(i) << 2;\\n            bytes1 b = bytes1(v);\\n            bytes memory des = new bytes(1);\\n            des[0] = b;\\n            return (des, 1);\\n            // 1<<14\\n        } else if (i < 16384) {\\n            uint16 v = uint16(i << 2) + 1;\\n            bytes memory des = new bytes(2);\\n            des[0] = bytes1(uint8(v));\\n            des[1] = bytes1(uint8(v >> 8));\\n            return (des, 2);\\n            // 1<<30\\n        } else if (i < 1073741824) {\\n            uint32 v = uint32(i << 2) + 2;\\n            bytes memory des = new bytes(4);\\n            des[0] = bytes1(uint8(v));\\n            des[1] = bytes1(uint8(v >> 8));\\n            des[2] = bytes1(uint8(v >> 16));\\n            des[3] = bytes1(uint8(v >> 24));\\n            return (des, 4);\\n        } else {\\n            revert(\\\"scale encode not support\\\");\\n        }\\n    }\\n\\n    // convert BigEndian to LittleEndian \\n    function reverseBytes16(bytes16 input) internal pure returns (bytes16 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000) >> 32) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n        // swap 8-byte long pairs\\n        v = (v >> 64) | (v << 64);\\n    }\\n\\n    function decodeCompactU8aOffset(bytes1 input0) public pure returns (uint8) {\\n        bytes1 flag = input0 & bytes1(hex\\\"03\\\");\\n        if (flag == hex\\\"00\\\") {\\n            return 1;\\n        } else if (flag == hex\\\"01\\\") {\\n            return 2;\\n        } else if (flag == hex\\\"02\\\") {\\n            return 4;\\n        }\\n        uint8 offset = (uint8(input0) >> 2) + 4 + 1;\\n        return offset;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SimpleMerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./common/Input.sol\\\";\\nimport \\\"./common/Bytes.sol\\\";\\nimport \\\"./common/Hash.sol\\\";\\nimport \\\"./common/Nibble.sol\\\";\\nimport \\\"./common/Node.sol\\\";\\n\\n/**\\n * @dev Simple Verification of compact proofs for Modified Merkle-Patricia tries.\\n */\\nlibrary SimpleMerkleProof {\\n    using Bytes for bytes;\\n    using Input for Input.Data;\\n\\n    uint8 internal constant NODEKIND_NOEXT_EMPTY = 0;\\n    uint8 internal constant NODEKIND_NOEXT_LEAF = 1;\\n    uint8 internal constant NODEKIND_NOEXT_BRANCH_NOVALUE = 2;\\n    uint8 internal constant NODEKIND_NOEXT_BRANCH_WITHVALUE = 3;\\n\\n    struct Item {\\n        bytes32 key;\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns `values` if `keys` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, is a sequence of the subset\\n     * of nodes in the trie traversed while performing lookups on all keys.\\n     */\\n    function verify(\\n        bytes32 root,\\n        bytes[] memory proof,\\n        bytes[] memory keys\\n    ) internal view returns (bytes[] memory) {\\n        require(proof.length > 0, \\\"no proof\\\");\\n        require(keys.length > 0, \\\"no keys\\\");\\n        Item[] memory db = new Item[](proof.length);\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes memory v = proof[i];\\n            Item memory item = Item({key: Hash.blake2bHash(v), value: v});\\n            db[i] = item;\\n        }\\n        return verify_proof(root, keys, db);\\n    }\\n\\n    /**\\n     * @dev Returns `values` if `keys` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, is a sequence of the subset\\n     * of nodes in the trie traversed while performing lookups on all keys.\\n     */\\n    function getEvents(\\n        bytes32 root,\\n        bytes memory key,\\n        bytes[] memory proof\\n    ) internal view returns (bytes memory value) {\\n        bytes memory k = Nibble.keyToNibbles(key);\\n\\n        Item[] memory db = new Item[](proof.length);\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes memory v = proof[i];\\n            Item memory item = Item({key: Hash.blake2bHash(v), value: v});\\n            db[i] = item;\\n        }\\n\\n        value = lookUp(root, k, db);\\n    }\\n\\n    function verify_proof(\\n        bytes32 root,\\n        bytes[] memory keys,\\n        Item[] memory db\\n    ) internal pure returns (bytes[] memory values) {\\n        values = new bytes[](keys.length);\\n        for (uint256 i = 0; i < keys.length; i++) {\\n            bytes memory k = Nibble.keyToNibbles(keys[i]);\\n            bytes memory v = lookUp(root, k, db);\\n            values[i] = v;\\n        }\\n        return values;\\n    }\\n\\n    /// Look up the given key. the value returns if it is found\\n    function lookUp(\\n        bytes32 root,\\n        bytes memory key,\\n        Item[] memory db\\n    ) internal pure returns (bytes memory v) {\\n        bytes32 hash = root;\\n        bytes memory partialKey = key;\\n        while (true) {\\n            bytes memory nodeData = getNodeData(hash, db);\\n            if (nodeData.length == 0) {\\n                return hex\\\"\\\";\\n            }\\n            while (true) {\\n                Input.Data memory data = Input.from(nodeData);\\n                uint8 header = data.decodeU8();\\n                uint8 kind = header >> 6;\\n                if (kind == NODEKIND_NOEXT_LEAF) {\\n                    //Leaf\\n                    Node.Leaf memory leaf = Node.decodeLeaf(data, header);\\n                    if (leaf.key.equals(partialKey)) {\\n                        return leaf.value;\\n                    } else {\\n                        return hex\\\"\\\";\\n                    }\\n                } else if (\\n                    kind == NODEKIND_NOEXT_BRANCH_NOVALUE ||\\n                    kind == NODEKIND_NOEXT_BRANCH_WITHVALUE\\n                ) {\\n                    //BRANCH_WITHOUT_MASK_NO_EXT  BRANCH_WITH_MASK_NO_EXT\\n                    Node.Branch memory branch = Node.decodeBranch(data, header);\\n                    uint256 sliceLen = branch.key.length;\\n                    if (startsWith(partialKey, branch.key)) {\\n                        if (partialKey.length == sliceLen) {\\n                            return branch.value;\\n                        } else {\\n                            uint8 index = uint8(partialKey[sliceLen]);\\n                            Node.NodeHandle memory child = branch\\n                                .children[index];\\n                            if (child.exist) {\\n                                partialKey = partialKey.substr(sliceLen + 1);\\n                                if (child.isInline) {\\n                                    nodeData = child.data;\\n                                } else {\\n                                    hash = abi.decode(child.data, (bytes32));\\n                                    break;\\n                                }\\n                            } else {\\n                                return hex\\\"\\\";\\n                            }\\n                        }\\n                    } else {\\n                        return hex\\\"\\\";\\n                    }\\n                } else if (kind == NODEKIND_NOEXT_EMPTY) {\\n                    return hex\\\"\\\";\\n                } else {\\n                    revert(\\\"not support node type\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function getNodeData(bytes32 hash, Item[] memory db)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        for (uint256 i = 0; i < db.length; i++) {\\n            Item memory item = db[i];\\n            if (hash == item.key) {\\n                return item.value;\\n            }\\n        }\\n        return hex\\\"\\\";\\n    }\\n\\n    function startsWith(bytes memory a, bytes memory b)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (a.length < b.length) {\\n            return false;\\n        }\\n        for (uint256 i = 0; i < b.length; i++) {\\n            if (a[i] != b[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Memory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nlibrary Memory {\\n\\n    uint internal constant WORD_SIZE = 32;\\n\\n\\t// Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\\n    // bytes starting at 'addr2'.\\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\\n    function equals(uint addr, uint addr2, uint len) internal pure returns (bool equal) {\\n        assembly {\\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\\n        }\\n    }\\n\\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\\n    // the first 'len' bytes will be compared.\\n    // Requires that 'bts.length >= len'\\n\\n    function equals(uint addr, uint len, bytes memory bts) internal pure returns (bool equal) {\\n        require(bts.length >= len);\\n        uint addr2;\\n        assembly {\\n            addr2 := add(bts, /*BYTES_HEADER_SIZE*/32)\\n        }\\n        return equals(addr, addr2, len);\\n    }\\n\\t// Returns a memory pointer to the data portion of the provided bytes array.\\n\\tfunction dataPtr(bytes memory bts) internal pure returns (uint addr) {\\n\\t\\tassembly {\\n\\t\\t\\taddr := add(bts, /*BYTES_HEADER_SIZE*/32)\\n\\t\\t}\\n\\t}\\n\\n\\t// Creates a 'bytes memory' variable from the memory address 'addr', with the\\n\\t// length 'len'. The function will allocate new memory for the bytes array, and\\n\\t// the 'len bytes starting at 'addr' will be copied into that new memory.\\n\\tfunction toBytes(uint addr, uint len) internal pure returns (bytes memory bts) {\\n\\t\\tbts = new bytes(len);\\n\\t\\tuint btsptr;\\n\\t\\tassembly {\\n\\t\\t\\tbtsptr := add(bts, /*BYTES_HEADER_SIZE*/32)\\n\\t\\t}\\n\\t\\tcopy(addr, btsptr, len);\\n\\t}\\n\\t\\n\\t// Copies 'self' into a new 'bytes memory'.\\n\\t// Returns the newly created 'bytes memory'\\n\\t// The returned bytes will be of length '32'.\\n\\tfunction toBytes(bytes32 self) internal pure returns (bytes memory bts) {\\n\\t\\tbts = new bytes(32);\\n\\t\\tassembly {\\n\\t\\t\\tmstore(add(bts, /*BYTES_HEADER_SIZE*/32), self)\\n\\t\\t}\\n\\t}\\n\\n\\t// Copy 'len' bytes from memory address 'src', to address 'dest'.\\n\\t// This function does not check the or destination, it only copies\\n\\t// the bytes.\\n\\tfunction copy(uint src, uint dest, uint len) internal pure {\\n\\t\\t// Copy word-length chunks while possible\\n\\t\\tfor (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tmstore(dest, mload(src))\\n\\t\\t\\t}\\n\\t\\t\\tdest += WORD_SIZE;\\n\\t\\t\\tsrc += WORD_SIZE;\\n\\t\\t}\\n\\n\\t\\t// Copy remaining bytes\\n\\t\\tuint mask = 256 ** (WORD_SIZE - len) - 1;\\n\\t\\tassembly {\\n\\t\\t\\tlet srcpart := and(mload(src), not(mask))\\n\\t\\t\\tlet destpart := and(mload(dest), mask)\\n\\t\\t\\tmstore(dest, or(destpart, srcpart))\\n\\t\\t}\\n\\t}\\n\\n\\t// This function does the same as 'dataPtr(bytes memory)', but will also return the\\n\\t// length of the provided bytes array.\\n\\tfunction fromBytes(bytes memory bts) internal pure returns (uint addr, uint len) {\\n\\t\\tlen = bts.length;\\n\\t\\tassembly {\\n\\t\\t\\taddr := add(bts, /*BYTES_HEADER_SIZE*/32)\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/common/Scale.struct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nlibrary ScaleStruct {\\n    struct LockEvent {\\n        bytes2 index;\\n        bytes32 sender;\\n        address recipient;\\n        address token;\\n        uint128 value;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Nibble.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nlibrary Nibble {\\n    // keyToNibbles turns bytes into nibbles, assumes they are already ordered in LE\\n    function keyToNibbles(bytes memory src)\\n        internal\\n        pure\\n        returns (bytes memory des)\\n    {\\n        if (src.length == 0) {\\n            return des;\\n        } else if (src.length == 1 && uint8(src[0]) == 0) {\\n            return hex\\\"0000\\\";\\n        }\\n        uint256 l = src.length * 2;\\n        des = new bytes(l);\\n        for (uint256 i = 0; i < src.length; i++) {\\n            des[2 * i] = bytes1(uint8(src[i]) / 16);\\n            des[2 * i + 1] = bytes1(uint8(src[i]) % 16);\\n        }\\n    }\\n\\n    // nibblesToKeyLE turns a slice of nibbles w/ length k into a little endian byte array, assumes nibbles are already LE\\n    function nibblesToKeyLE(bytes memory src)\\n        internal\\n        pure\\n        returns (bytes memory des)\\n    {\\n        uint256 l = src.length;\\n        if (l % 2 == 0) {\\n            des = new bytes(l / 2);\\n            for (uint256 i = 0; i < l; i += 2) {\\n                uint8 a = uint8(src[i]);\\n                uint8 b = uint8(src[i + 1]);\\n                des[i / 2] = bytes1(((a << 4) & 0xF0) | (b & 0x0F));\\n            }\\n        } else {\\n            des = new bytes(l / 2 + 1);\\n            des[0] = src[0];\\n            for (uint256 i = 2; i < l; i += 2) {\\n                uint8 a = uint8(src[i - 1]);\\n                uint8 b = uint8(src[i]);\\n                des[i / 2] = bytes1(((a << 4) & 0xF0) | (b & 0x0F));\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Node.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\nimport \\\"./Input.sol\\\";\\nimport \\\"./Nibble.sol\\\";\\nimport \\\"./Bytes.sol\\\";\\nimport \\\"./Hash.sol\\\";\\nimport \\\"./Scale.sol\\\";\\n\\nlibrary Node {\\n    using Input for Input.Data;\\n    using Bytes for bytes;\\n\\n    uint8 internal constant NODEKIND_NOEXT_LEAF = 1;\\n    uint8 internal constant NODEKIND_NOEXT_BRANCH_NOVALUE = 2;\\n    uint8 internal constant NODEKIND_NOEXT_BRANCH_WITHVALUE = 3;\\n\\n    struct NodeHandle {\\n        bytes data;\\n        bool exist;\\n        bool isInline;\\n    }\\n\\n    struct Branch {\\n        bytes key; //partialkey\\n        NodeHandle[16] children;\\n        bytes value;\\n    }\\n\\n    struct Leaf {\\n        bytes key; //partialkey\\n        bytes value;\\n    }\\n\\n    // decodeBranch decodes a byte array into a branch node\\n    function decodeBranch(Input.Data memory data, uint8 header)\\n        internal\\n        pure\\n        returns (Branch memory)\\n    {\\n        Branch memory b;\\n        b.key = decodeNodeKey(data, header);\\n        uint8[2] memory bitmap;\\n        bitmap[0] = data.decodeU8();\\n        bitmap[1] = data.decodeU8();\\n        uint8 nodeType = header >> 6;\\n        if (nodeType == NODEKIND_NOEXT_BRANCH_WITHVALUE) {\\n            //BRANCH_WITH_MASK_NO_EXT\\n            b.value = Scale.decodeByteArray(data);\\n        }\\n        for (uint8 i = 0; i < 16; i++) {\\n            if (((bitmap[i / 8] >> (i % 8)) & 1) == 1) {\\n                bytes memory childData = Scale.decodeByteArray(data);\\n                bool isInline = true;\\n                if (childData.length == 32) {\\n                    isInline = false;\\n                }\\n                b.children[i] = NodeHandle({\\n                    data: childData,\\n                    isInline: isInline,\\n                    exist: true\\n                });\\n            }\\n        }\\n        return b;\\n    }\\n\\n    // decodeLeaf decodes a byte array into a leaf node\\n    function decodeLeaf(Input.Data memory data, uint8 header)\\n        internal\\n        pure\\n        returns (Leaf memory)\\n    {\\n        Leaf memory l;\\n        l.key = decodeNodeKey(data, header);\\n        l.value = Scale.decodeByteArray(data);\\n        return l;\\n    }\\n\\n    function decodeNodeKey(Input.Data memory data, uint8 header)\\n        internal\\n        pure\\n        returns (bytes memory key)\\n    {\\n        uint256 keyLen = header & 0x3F;\\n        if (keyLen == 0x3f) {\\n            while (keyLen < 65536) {\\n                uint8 nextKeyLen = data.decodeU8();\\n                keyLen += uint256(nextKeyLen);\\n                if (nextKeyLen < 0xFF) {\\n                    break;\\n                }\\n                require(\\n                    keyLen < 65536,\\n                    \\\"Size limit reached for a nibble slice\\\"\\n                );\\n            }\\n        }\\n        if (keyLen != 0) {\\n            key = data.decodeBytesN(keyLen / 2 + (keyLen % 2));\\n            key = Nibble.keyToNibbles(key);\\n            if (keyLen % 2 == 1) {\\n                key = key.substr(1);\\n            }\\n        }\\n        return key;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"authorities\",\"type\":\"address[]\"}],\"name\":\"ResetAuthoritiesEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ResetRootEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"authorities\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"beneficiary\",\"type\":\"bytes32\"}],\"name\":\"SetAuthoritiesEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"SetRootEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"appendRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"prefix\",\"type\":\"bytes\"}],\"name\":\"checkNetworkPrefix\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"}],\"name\":\"checkRelayerNonce\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"eventsProofStr\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"}],\"name\":\"getLockTokenReceipt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"getMMRRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNetworkPrefix\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRelayer\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRelayerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRelayerNonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRelayerThreshold\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_MMRIndex\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_genesisMMRRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"_relayers\",\"type\":\"address[]\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_prefix\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isRelayer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"mmrRootPool\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_prefix\",\"type\":\"bytes\"}],\"name\":\"resetNetworkPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"resetRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"}],\"name\":\"resetRelayerThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"resetRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32\",\"name\":\"beneficiary\",\"type\":\"bytes32\"}],\"name\":\"updateRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"MMRIndex\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"blockHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"peaks\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"name\":\"verifyBlockProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"MMRIndex\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"blockHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"peaks\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"eventsProofStr\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"}],\"name\":\"verifyRootAndDecodeReceipt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Relay","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}