{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\interfaces\\IAvnStorage.sol\n\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.5;\r\n\r\ninterface IAvnStorage {\r\n  event LogStoragePermissionUpdated(address indexed publisher, bool status);\r\n\r\n  function setStoragePermission(address publisher, bool status) external;\r\n  function storeT2TransactionId(uint256 _t2TransactionId) external;\r\n  function storeT2TransactionIdAndRoot(uint256 _t2TransactionId, bytes32 rootHash) external;\r\n  function confirmLeaf(bytes32 leafHash, bytes32[] memory merklePath) external view returns (bool);\r\n}\n\n// File: contracts\\interfaces\\IAvnFTScalingManager.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\ninterface IAvnFTScalingManager {\r\n  event LogLifted(address indexed token, address indexed t1Address, bytes32 indexed t2PublicKey, uint256 amount, uint256 nonce);\r\n  event LogLowered(address indexed token, address indexed t1Address, bytes32 indexed t2PublicKey, uint256 amount,\r\n    bytes32 leafHash);\r\n\r\n  function disableLift(bool _isDisabled) external;\r\n  function lift(address erc20Contract, bytes32 t2PublicKey, uint256 amount) external;\r\n  function lower(bytes calldata encodedLeaf, bytes32[] calldata merklePath) external;\r\n  function confirmT2Transaction(bytes32 leafHash, bytes32[] memory merklePath) external view returns (bool);\r\n  function retire() external;\r\n}\n\n// File: contracts\\interfaces\\IAvnFTTreasury.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\ninterface IAvnFTTreasury {\r\n  event LogFTTreasuryPermissionUpdated(address indexed treasurer, bool status);\r\n\r\n  function setTreasurerPermission(address treasurer, bool status) external;\r\n  function getTreasurers() external view returns(address[] memory);\r\n  function unlockERC777Tokens(address token, uint256 amount, bytes calldata data) external;\r\n  function unlockERC20Tokens(address token, uint256 amount) external;\r\n}\n\n// File: contracts\\interfaces\\IERC20.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\n// As described in https://eips.ethereum.org/EIPS/eip-20\r\ninterface IERC20 {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function name() external view returns (string memory); // optional method - see eip spec\r\n  function symbol() external view returns (string memory); // optional method - see eip spec\r\n  function decimals() external view returns (uint8); // optional method - see eip spec\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address owner) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n}\n\n// File: contracts\\interfaces\\IERC777.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\n// As defined in https://eips.ethereum.org/EIPS/eip-777\r\ninterface IERC777 {\r\n  event Sent(address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data,\r\n      bytes operatorData);\r\n  event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n  event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n  event AuthorizedOperator(address indexed operator,address indexed holder);\r\n  event RevokedOperator(address indexed operator, address indexed holder);\r\n\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address holder) external view returns (uint256);\r\n  function granularity() external view returns (uint256);\r\n  function defaultOperators() external view returns (address[] memory);\r\n  function isOperatorFor(address operator, address holder) external view returns (bool);\r\n  function authorizeOperator(address operator) external;\r\n  function revokeOperator(address operator) external;\r\n  function send(address to, uint256 amount, bytes calldata data) external;\r\n  function operatorSend(address from, address to, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\r\n  function burn(uint256 amount, bytes calldata data) external;\r\n  function operatorBurn( address from, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\r\n}\n\n// File: contracts\\thirdParty\\interfaces\\IERC1820Registry.sol\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/introspection/IERC1820Registry.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     *  @param account Address of the contract for which to update the cache.\r\n     *  @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\r\n     *  If the result is not cached a direct lookup on the contract address is performed.\r\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     *  {updateERC165Cache} with the contract address.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\n\n// File: contracts\\thirdParty\\SafeMath.sol\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\n\n// File: contracts\\Owned.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\ncontract Owned {\r\n\r\n  address public owner = msg.sender;\r\n\r\n  event LogOwnershipTransferred(address indexed owner, address indexed newOwner);\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner, \"Only owner\");\r\n    _;\r\n  }\r\n\r\n  function setOwner(address _owner)\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(_owner != address(0), \"Owner cannot be zero address\");\r\n    emit LogOwnershipTransferred(owner, _owner);\r\n    owner = _owner;\r\n  }\r\n}\n\n// File: ..\\contracts\\AvnFTScalingManager.sol\n\n\r\npragma solidity 0.7.5;\r\r\r\r\r\r\r\r\r\n\r\ncontract AvnFTScalingManager is IAvnFTScalingManager, Owned {\r\n  using SafeMath for uint256;\r\n\r\n  struct LeafData {\r\n    bytes t2Data;\r\n    bytes abiEncodedT2Data;\r\n  }\r\n\r\n  struct T1LowerData {\r\n    address token;\r\n    bytes32 fromT2PublicKey;\r\n    bytes32 toT2PublicKey;\r\n    uint256 amount;\r\n    address t1LowerAddress;\r\n  }\r\n\r\n  // Universal address as defined in Registry Contract Address section of https://eips.ethereum.org/EIPS/eip-1820\r\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n  // keccak256(\"ERC777Token\")\r\n  bytes32 constant internal ERC777_TOKEN_HASH = 0xac7fbab5f54a3ca8194167523c6753bfeb96a445279294b6125b68cce2177054;\r\n  // keccak256(\"ERC777TokensRecipient\")\r\n  bytes32 constant internal ERC777_TOKENS_RECIPIENT_HASH = 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\r\n\r\n  bytes32 constant internal T2_BURN_PUBLIC_KEY = 0x000000000000000000000000000000000000000000000000000000000000dead;\r\n  uint256 constant internal LIFT_LIMIT = type(uint128).max;\r\n\r\n  IAvnStorage immutable public avnStorage;\r\n  IAvnFTTreasury immutable public avnFTTreasury;\r\n\r\n  uint256 public liftNonce;\r\n  bool public liftDisabled;\r\n\r\n  mapping (bytes32 => bool) public hasLowered;\r\n\r\n  constructor(IAvnStorage _avnStorage, IAvnFTTreasury _avnFTTreasury)\r\n  {\r\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), ERC777_TOKENS_RECIPIENT_HASH, address(this));\r\n    avnStorage = _avnStorage;\r\n    avnFTTreasury = _avnFTTreasury;\r\n  }\r\n\r\n  modifier onlyWhenLiftEnabled() {\r\n    require(!liftDisabled, \"Lifting currently disabled\");\r\n    _;\r\n  }\r\n\r\n  function disableLift(bool _isDisabled)\r\n    onlyOwner\r\n    external\r\n    override\r\n  {\r\n    liftDisabled = _isDisabled;\r\n  }\r\n\r\n  function lift(address _erc20Contract, bytes32 _t2PublicKey, uint256 _amount)\r\n    onlyWhenLiftEnabled\r\n    external\r\n    override\r\n  {\r\n    require(_amount > 0, \"Cannot lift zero ERC20 tokens\");\r\n    require(IERC20(_erc20Contract).balanceOf(address(avnFTTreasury)).add(_amount) <= LIFT_LIMIT, \"Exceeds ERC20 lift limit\");\r\n    lockERC20TokensInTreasury(_erc20Contract, _amount);\r\n    emit LogLifted(_erc20Contract, msg.sender, _t2PublicKey, _amount, ++liftNonce);\r\n  }\r\n\r\n  function lower(bytes calldata _encodedLeaf, bytes32[] calldata _merklePath)\r\n    external\r\n    override\r\n  {\r\n    bytes32 leafHash = keccak256(_encodedLeaf);\r\n    require(avnStorage.confirmLeaf(leafHash, _merklePath), \"Leaf or path invalid\");\r\n    require(!hasLowered[leafHash], \"Already lowered\");\r\n    hasLowered[leafHash] = true;\r\n\r\n    LeafData memory leafData;\r\n    (leafData.t2Data, leafData.abiEncodedT2Data) = abi.decode(_encodedLeaf, (bytes, bytes));\r\n    T1LowerData memory t1Data;\r\n    (t1Data.token, t1Data.fromT2PublicKey, t1Data.toT2PublicKey, t1Data.amount, t1Data.t1LowerAddress) =\r\n        abi.decode(leafData.abiEncodedT2Data, (address, bytes32, bytes32, uint256, address));\r\n    require(t1Data.toT2PublicKey == T2_BURN_PUBLIC_KEY, \"Must have burned to lower\");\r\n\r\n    if (ERC1820_REGISTRY.getInterfaceImplementer(t1Data.token, ERC777_TOKEN_HASH) == t1Data.token)\r\n      unlockERC777TokensFromTreasury(t1Data.token, t1Data.t1LowerAddress, t1Data.amount, _encodedLeaf);\r\n    else\r\n      unlockERC20TokensFromTreasury(t1Data.token, t1Data.t1LowerAddress, t1Data.amount);\r\n\r\n    emit LogLowered(t1Data.token, t1Data.t1LowerAddress, t1Data.fromT2PublicKey, t1Data.amount, leafHash);\r\n  }\r\n\r\n  function tokensReceived(address _operator, address _from, address _to, uint256 _amount, bytes calldata _data,\r\n      bytes calldata /* _operatorData */)\r\n    onlyWhenLiftEnabled\r\n    external\r\n  {\r\n    if (_operator == address(this)) return; // This is an ERC20 lift operation - ignore\r\n    if (_operator == address(avnFTTreasury)) return; // These are funds being unlocked by the treasury - ignore\r\n    require(_amount > 0, \"Cannot lift zero ERC777 tokens\");\r\n    require(_to == address(this), \"Tokens must be sent to this contract\");\r\n    require(ERC1820_REGISTRY.getInterfaceImplementer(msg.sender, ERC777_TOKEN_HASH) == msg.sender, \"Token must be registered\");\r\n    require(IERC777(msg.sender).balanceOf(address(avnFTTreasury)).add(_amount) <= LIFT_LIMIT, \"Exceeds ERC777 lift limit\");\r\n\r\n    // this locks the tokens in the treasury\r\n    IERC777(msg.sender).send(address(avnFTTreasury), _amount, _data);\r\n    emit LogLifted(msg.sender, _from, abi.decode(_data, (bytes32)), _amount, ++liftNonce);\r\n  }\r\n\r\n  function confirmT2Transaction(bytes32 _leafHash, bytes32[] memory _merklePath)\r\n    external\r\n    view\r\n    override\r\n    returns (bool)\r\n  {\r\n    return avnStorage.confirmLeaf(_leafHash, _merklePath);\r\n  }\r\n\r\n  function retire()\r\n    onlyOwner\r\n    external\r\n    override\r\n  {\r\n    selfdestruct(payable(owner));\r\n  }\r\n\r\n  function unlockERC777TokensFromTreasury(address _erc777Contract, address _recipient, uint256 _amount, bytes memory _data)\r\n    private\r\n  {\r\n    IAvnFTTreasury(avnFTTreasury).unlockERC777Tokens(_erc777Contract, _amount, _data);\r\n    IERC777(_erc777Contract).send(_recipient, _amount, _data);\r\n  }\r\n\r\n  function unlockERC20TokensFromTreasury(address _erc20Contract, address _recipient, uint256 _amount)\r\n    private\r\n  {\r\n    IAvnFTTreasury(avnFTTreasury).unlockERC20Tokens(_erc20Contract, _amount);\r\n    assert(IERC20(_erc20Contract).transfer(_recipient, _amount));\r\n  }\r\n\r\n  function lockERC20TokensInTreasury(address _erc20Contract, uint256 _amount)\r\n    private\r\n  {\r\n    IERC20 erc20Contract = IERC20(_erc20Contract);\r\n    assert(erc20Contract.transferFrom(msg.sender, address(this), _amount));\r\n    // locks the tokens in the treasury\r\n    assert(erc20Contract.transfer(address(avnFTTreasury), _amount));\r\n  }\r\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAvnStorage\",\"name\":\"_avnStorage\",\"type\":\"address\"},{\"internalType\":\"contract IAvnFTTreasury\",\"name\":\"_avnFTTreasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"t1Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"LogLifted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"t1Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"leafHash\",\"type\":\"bytes32\"}],\"name\":\"LogLowered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogOwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"avnFTTreasury\",\"outputs\":[{\"internalType\":\"contract IAvnFTTreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avnStorage\",\"outputs\":[{\"internalType\":\"contract IAvnStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_leafHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merklePath\",\"type\":\"bytes32[]\"}],\"name\":\"confirmT2Transaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isDisabled\",\"type\":\"bool\"}],\"name\":\"disableLift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hasLowered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_t2PublicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liftDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liftNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_encodedLeaf\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merklePath\",\"type\":\"bytes32[]\"}],\"name\":\"lower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retire\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AvnFTScalingManager","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000aa0304f6e2426119bbe10870df3edb867d5ec10100000000000000000000000073fe91d082b3604b8261de321086333e78ab1112","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}