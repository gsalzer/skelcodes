// SPDX-License-Identifier: MIT
// Modified from https://github.com/iearn-finance/audit/blob/master/contracts/yGov/YearnGovernanceBPT.sol

pragma solidity ^0.5.16;

import {IERC20} from "../token/IERC20.sol";

import {SafeMath} from "../lib/SafeMath.sol";
import {SafeERC20} from "../lib/SafeERC20.sol";

/**
 * @title Accrual is an abstract contract which allows users of some
 *        distribution to claim a portion of tokens based on their share.
 */
contract Accrual {

    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public accrualToken;

    uint256 public accruedIndex = 0; // previously accumulated index
    uint256 public accruedBalance = 0; // previous calculated balance

    mapping(address => uint256) public supplyIndex;

    constructor(
        address _accrualToken
    )
        public
    {
        accrualToken = IERC20(_accrualToken);
    }

    function getUserBalance(
        address owner
    )
        public
        view
        returns (uint256);

    function getTotalBalance()
        public
        view
        returns (uint256);

    function updateFees()
        public
    {
        if (getTotalBalance() == 0) {
            return;
        }

        uint256 contractBalance = accrualToken.balanceOf(address(this));

        if (contractBalance == 0) {
            return;
        }

        // Find the difference since the last balance stored in the contract
        uint256 difference = contractBalance.sub(accruedBalance);

        if (difference == 0) {
            return;
        }

        // Use the difference to calculate a ratio
        uint256 ratio = difference.mul(1e18).div(getTotalBalance());

        if (ratio == 0) {
            return;
        }

        // Update the index by adding the existing index to the ratio index
        accruedIndex = accruedIndex.add(ratio);

        // Update the accrued balance
        accruedBalance = contractBalance;
    }

    function claimFees()
        public
    {
        claimFor(msg.sender);
    }

    function claimFor(
        address recipient
    )
        public
    {
        updateFees();

        uint256 userBalance = getUserBalance(recipient);

        if (userBalance == 0) {
            supplyIndex[recipient] = accruedIndex;
            return;
        }

        // Store the existing user's index before updating it
        uint256 existingIndex = supplyIndex[recipient];

        // Update the user's index to the current one
        supplyIndex[recipient] = accruedIndex;

        // Calculate the difference between the current index and the old one
        // The difference here is what the user will be able to claim against
        uint256 delta = accruedIndex.sub(existingIndex);

        require(
            delta > 0,
            "TokenAccrual: no tokens available to claim"
        );

        // Get the user's current balance and multiply with their index delta
        uint256 share = userBalance.mul(delta).div(1e18);

        // Transfer the tokens to the user
        accrualToken.safeTransfer(recipient, share);

        // Update the accrued balance
        accruedBalance = accrualToken.balanceOf(address(this));
    }

}

