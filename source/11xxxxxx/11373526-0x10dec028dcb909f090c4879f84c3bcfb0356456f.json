{"status":"1","message":"OK","result":[{"SourceCode":"# Created by interfinex.io\r\n# - The Greeks\r\n\r\n@internal\r\ndef safeTransferFrom(_token: address, _from: address, _to: address, _value: uint256) -> bool:\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transferFrom(address,address,uint256)\"),\r\n            convert(_from, bytes32),\r\n            convert(_to, bytes32),\r\n            convert(_value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Token transferFrom failed!\"\r\n\r\n    return True\r\n\r\n@internal\r\ndef safeApprove(_token: address, _spender: address, _value: uint256) -> bool:\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"approve(address,uint256)\"),\r\n            convert(_spender, bytes32),\r\n            convert(_value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Token approval failed!\"\r\n\r\n    return True\r\n\r\n@internal\r\ndef safeTransfer(_token: address, _to: address, _value: uint256) -> bool:\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_to, bytes32),\r\n            convert(_value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Token approval failed!\"\r\n\r\n    return True\r\n\r\ninterface SwapFactory:\r\n    def create_exchange(\r\n        base_token: address, \r\n        asset_token: address, \r\n        base_token_amount: uint256, \r\n        asset_token_amount: uint256, \r\n        ifex_token_amount: uint256\r\n    ): nonpayable\r\n    def pair_to_exchange(token0: address, token1: address) -> address: nonpayable\r\n\r\ninterface ERC20:\r\n    def approve(_spender : address, _value : uint256) -> bool: nonpayable\r\n    def transferFrom(_from : address, _to : address, _value : uint256) -> bool: nonpayable    \r\n    def allowance(_owner: address, _spender: address) -> uint256: view\r\n    def balanceOf(_account: address) -> uint256: view\r\n    def transfer(_to: address, _value: uint256): nonpayable\r\n\r\ninterface WrappedEther:\r\n    def deposit(): payable\r\n    def withdraw(wad: uint256): nonpayable\r\n\r\ninterface SwapExchange:\r\n    def liquidity_token() -> address: view\r\n    def burn_liquidity(liquidity_token_amount: uint256, deadline: uint256): nonpayable\r\n    def mint_liquidity(\r\n        input_token: address,\r\n        base_token_amount: uint256, \r\n        min_asset_token_amount: uint256, \r\n        max_asset_token_amount: uint256, \r\n        recipient: address, \r\n        deadline: uint256\r\n    ): nonpayable\r\n    def swap(\r\n        input_token: address,\r\n        input_token_amount: uint256,\r\n        recipient: address,\r\n        min_output_token_amount: uint256,\r\n        max_output_token_amount: uint256,\r\n        deadline: uint256,\r\n        referral: address,\r\n        useIfex: bool\r\n    ) -> uint256: nonpayable\r\n\r\nwrappedEtherContract: public(address)\r\nswapFactoryContract: public(address)\r\nifexTokenContract: public(address)\r\n\r\nisInitialised: public(bool)\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    return\r\n\r\n@external\r\ndef initialize(_wrappedEtherContract: address, _swapFactoryContract: address, _ifexTokenContract: address):\r\n    assert self.isInitialised == False, \"Already initialised\"\r\n    self.isInitialised = True\r\n    self.wrappedEtherContract = _wrappedEtherContract\r\n    self.swapFactoryContract = _swapFactoryContract\r\n    self.ifexTokenContract = _ifexTokenContract\r\n    self.safeApprove(self.wrappedEtherContract, self.swapFactoryContract, MAX_UINT256)\r\n    self.safeApprove(self.ifexTokenContract, self.swapFactoryContract, MAX_UINT256)\r\n\r\n@internal\r\ndef approveContract(tokenContract: address, exchangeContract: address):\r\n    assetAllowance: uint256 = ERC20(tokenContract).allowance(self, exchangeContract)\r\n    if assetAllowance < MAX_UINT256 / 2:\r\n        ERC20(tokenContract).approve(exchangeContract, MAX_UINT256)\r\n\r\n@external\r\n@payable\r\ndef create_exchange(\r\n    assetTokenContract: address, \r\n    assetTokenAmount: uint256, \r\n    ifexTokenAmount: uint256\r\n):\r\n    self.safeTransferFrom(assetTokenContract, msg.sender, self, assetTokenAmount)\r\n    self.safeTransferFrom(self.ifexTokenContract, msg.sender, self, ifexTokenAmount)\r\n    WrappedEther(self.wrappedEtherContract).deposit(value=msg.value)\r\n\r\n    self.approveContract(assetTokenContract, self.swapFactoryContract)\r\n    SwapFactory(self.swapFactoryContract).create_exchange(\r\n        self.wrappedEtherContract, \r\n        assetTokenContract, \r\n        msg.value, \r\n        assetTokenAmount, \r\n        ifexTokenAmount\r\n    )\r\n\r\n    newExchangeContract: address = SwapFactory(self.swapFactoryContract).pair_to_exchange(\r\n        assetTokenContract, \r\n        self.wrappedEtherContract\r\n    )\r\n\r\n    exchangeLiquidityTokenContract: address = SwapExchange(newExchangeContract).liquidity_token()\r\n    mintedLiquidityTokens: uint256 = ERC20(exchangeLiquidityTokenContract).balanceOf(self)\r\n    ERC20(exchangeLiquidityTokenContract).transfer(msg.sender, mintedLiquidityTokens)\r\n\r\n    if assetTokenContract != self.ifexTokenContract:\r\n        ifexAssetExchange: address = SwapFactory(self.swapFactoryContract).pair_to_exchange(assetTokenContract, self.ifexTokenContract)\r\n        ifexAssetLiquidityTokenContract: address = SwapExchange(ifexAssetExchange).liquidity_token()\r\n        ifexAssetMintedLiquidityTokens: uint256 = ERC20(ifexAssetLiquidityTokenContract).balanceOf(self)\r\n        ERC20(ifexAssetLiquidityTokenContract).transfer(msg.sender, ifexAssetMintedLiquidityTokens)\r\n\r\n        wethIfexExchange: address = SwapFactory(self.swapFactoryContract).pair_to_exchange(self.ifexTokenContract, self.wrappedEtherContract)\r\n        wethIfexLiquidityTokenContract: address = SwapExchange(wethIfexExchange).liquidity_token()\r\n        wethIfexMintedLiquidityTokens: uint256 = ERC20(wethIfexLiquidityTokenContract).balanceOf(self)\r\n        ERC20(wethIfexLiquidityTokenContract).transfer(msg.sender, wethIfexMintedLiquidityTokens)\r\n\r\n\r\n@external\r\n@payable\r\ndef mint_liquidity(\r\n    assetTokenContract: address,\r\n    minAssetTokenAmount: uint256, \r\n    maxAssetTokenAmount: uint256, \r\n    recipient: address, \r\n    deadline: uint256\r\n):\r\n    WrappedEther(self.wrappedEtherContract).deposit(value=msg.value)\r\n    self.safeTransferFrom(assetTokenContract, msg.sender, self, maxAssetTokenAmount)\r\n\r\n    exchangeContract: address = SwapFactory(self.swapFactoryContract).pair_to_exchange(\r\n        assetTokenContract, \r\n        self.wrappedEtherContract\r\n    )\r\n\r\n    self.approveContract(assetTokenContract, exchangeContract)\r\n    self.approveContract(self.wrappedEtherContract, exchangeContract)\r\n\r\n    SwapExchange(exchangeContract).mint_liquidity(\r\n        self.wrappedEtherContract,\r\n        msg.value, \r\n        minAssetTokenAmount, \r\n        maxAssetTokenAmount, \r\n        recipient, \r\n        deadline\r\n    )\r\n\r\n\r\n@external\r\n@payable\r\ndef burn_liquidity(\r\n    assetTokenContract: address,\r\n    liquidityTokenAmount: uint256,\r\n    deadline: uint256\r\n):\r\n    exchangeContract: address = SwapFactory(self.swapFactoryContract).pair_to_exchange(\r\n        assetTokenContract, \r\n        self.wrappedEtherContract\r\n    )\r\n    liquidityTokenContract: address = SwapExchange(exchangeContract).liquidity_token()\r\n\r\n    self.safeTransferFrom(liquidityTokenContract, msg.sender, self, liquidityTokenAmount)\r\n    self.approveContract(liquidityTokenContract, exchangeContract)\r\n\r\n    SwapExchange(exchangeContract).burn_liquidity(\r\n        liquidityTokenAmount, \r\n        deadline\r\n    )\r\n\r\n    self.safeTransfer(assetTokenContract, msg.sender, ERC20(assetTokenContract).balanceOf(self))\r\n\r\n    wethBalance: uint256 = ERC20(self.wrappedEtherContract).balanceOf(self)\r\n    WrappedEther(self.wrappedEtherContract).withdraw(wethBalance)\r\n\r\n    send(msg.sender, self.balance)\r\n\r\n@external\r\n@payable\r\ndef swap(\r\n    assetTokenContract: address,\r\n    inputTokenContract: address,\r\n    _inputTokenAmount: uint256,\r\n    recipient: address,\r\n    minOutputTokenAmount: uint256,\r\n    maxOutputTokenAmount: uint256,\r\n    deadline: uint256,\r\n    referral: address,\r\n    useIfex: bool\r\n) -> uint256:\r\n    exchangeContract: address = SwapFactory(self.swapFactoryContract).pair_to_exchange(\r\n        assetTokenContract, \r\n        self.wrappedEtherContract\r\n    )\r\n    self.approveContract(inputTokenContract, exchangeContract)\r\n\r\n    inputTokenAmount: uint256 = _inputTokenAmount\r\n    if inputTokenContract == self.wrappedEtherContract:\r\n        inputTokenAmount = msg.value\r\n        WrappedEther(self.wrappedEtherContract).deposit(value=msg.value)\r\n    else:\r\n        self.safeTransferFrom(assetTokenContract, msg.sender, self, inputTokenAmount)\r\n\r\n    swappedAmount: uint256 = SwapExchange(exchangeContract).swap(\r\n        inputTokenContract,\r\n        inputTokenAmount,\r\n        self,\r\n        minOutputTokenAmount,\r\n        maxOutputTokenAmount,\r\n        deadline,\r\n        referral,\r\n        useIfex\r\n    )\r\n\r\n    if inputTokenContract == self.wrappedEtherContract:\r\n        self.safeTransfer(assetTokenContract, recipient, ERC20(assetTokenContract).balanceOf(self))\r\n    else:\r\n        wethBalance: uint256 = ERC20(self.wrappedEtherContract).balanceOf(self)\r\n        WrappedEther(self.wrappedEtherContract).withdraw(wethBalance)\r\n        send(msg.sender, self.balance)\r\n\r\n    return swappedAmount","ABI":"[{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"name\":\"initialize\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_wrappedEtherContract\"},{\"type\":\"address\",\"name\":\"_swapFactoryContract\"},{\"type\":\"address\",\"name\":\"_ifexTokenContract\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":154264},{\"name\":\"create_exchange\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"assetTokenContract\"},{\"type\":\"uint256\",\"name\":\"assetTokenAmount\"},{\"type\":\"uint256\",\"name\":\"ifexTokenAmount\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":71382},{\"name\":\"mint_liquidity\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"assetTokenContract\"},{\"type\":\"uint256\",\"name\":\"minAssetTokenAmount\"},{\"type\":\"uint256\",\"name\":\"maxAssetTokenAmount\"},{\"type\":\"address\",\"name\":\"recipient\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":52485},{\"name\":\"burn_liquidity\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"assetTokenContract\"},{\"type\":\"uint256\",\"name\":\"liquidityTokenAmount\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":56306},{\"name\":\"swap\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"assetTokenContract\"},{\"type\":\"address\",\"name\":\"inputTokenContract\"},{\"type\":\"uint256\",\"name\":\"_inputTokenAmount\"},{\"type\":\"address\",\"name\":\"recipient\"},{\"type\":\"uint256\",\"name\":\"minOutputTokenAmount\"},{\"type\":\"uint256\",\"name\":\"maxOutputTokenAmount\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"address\",\"name\":\"referral\"},{\"type\":\"bool\",\"name\":\"useIfex\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":84821},{\"name\":\"wrappedEtherContract\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1421},{\"name\":\"swapFactoryContract\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1451},{\"name\":\"ifexTokenContract\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1481},{\"name\":\"isInitialised\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1511}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}