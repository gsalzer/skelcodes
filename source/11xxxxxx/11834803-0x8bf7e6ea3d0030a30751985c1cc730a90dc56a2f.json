{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract Ethershark {\r\n    using BoringMath for uint256;\r\n\r\n    struct Investor {\r\n        address referrer;\r\n        uint256 amount;\r\n        uint256 lastSettledTime;\r\n        uint256 incomeLimitLeft;\r\n        uint256 directPartners;\r\n        uint256 directReferralIncome;\r\n        uint256 roiReferralIncome;\r\n        uint256 topInvestorIncome;\r\n        uint256 topSponsorIncome;\r\n        uint256 superIncome;\r\n    }\r\n\r\n    struct Leaderboard {\r\n        uint256 amt;\r\n        address addr;\r\n    }\r\n\r\n    enum WithdrawTypes {\r\n        ROIIncome,\r\n        directReferralIncome,\r\n        ROIMatchingIncome,\r\n        topInvestorIncome,\r\n        topSponsorIncome,\r\n        superIncome,\r\n        allBonuses\r\n    }\r\n\r\n    mapping(address => Investor) public investors;\r\n\r\n    mapping(uint256 => mapping(address => uint256))\r\n        private _referrerRoundVolume;\r\n    mapping(uint256 => address[]) private _roundInvestors;\r\n    uint8[10] private _DIRECT_REFERRAL_BONUS = [5, 1, 1, 1, 1, 1, 1, 1, 1, 1];\r\n    uint8[10] private _ROI_MATCHING_BONUS = [10, 2, 2, 2, 2, 2, 2, 2, 2, 2];\r\n    uint8[5] private _DAILY_POOL_AWARD_PERCENTAGE = [40, 30, 15, 10, 5];\r\n    uint8 private constant _PASSIVE_ROI_PERCENT = 5;\r\n    uint256 private constant _DIVIDER = 1000;\r\n    uint256 private constant _POOL_TIME = 1 days;\r\n    uint256 private constant _PASSIVE_ROI_INTERVAL = 1 minutes;\r\n    uint256 private constant _MAX_ROI = 175; // Max ROI percent\r\n    uint256 private immutable _START;\r\n    uint256 private _lastDistributionTime;\r\n    uint256 private _totalWithdrawn;\r\n    uint256 private _totalInvested = 1 ether;\r\n    uint256 private _totalInvestors = 1;\r\n    uint256 private _rewardPool;\r\n    address private _owner;\r\n\r\n    /****************************  EVENTS   *****************************************/\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    event Investment(\r\n        address indexed investor,\r\n        address indexed referrer,\r\n        uint256 indexed round,\r\n        uint256 amount\r\n    );\r\n    event Withdraw(\r\n        address indexed investor,\r\n        uint256 amount,\r\n        WithdrawTypes withdrawType\r\n    );\r\n    event DailyTopIncome(\r\n        address indexed investor,\r\n        uint256 amount,\r\n        uint256 indexed round,\r\n        uint256 prize\r\n    );\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _START = block.timestamp;\r\n        _lastDistributionTime = block.timestamp;\r\n        _setOwner(msg.sender);\r\n    }\r\n\r\n    // If someone accidently sends ETH to contract address\r\n    receive() external payable {\r\n        if (msg.sender != _owner) {\r\n            _invest(msg.sender, msg.value, _getCurrentRound());\r\n        }\r\n    }\r\n\r\n    fallback() external payable {}\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0x0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function invest(address _referrer) external payable {\r\n        address referrer =\r\n            _referrer != address(0x0) && _referrer != msg.sender\r\n                ? _referrer\r\n                : _owner;\r\n\r\n        require(\r\n            investors[referrer].referrer != address(0x0),\r\n            \"Invalid referrer\"\r\n        );\r\n\r\n        require(\r\n            msg.value % 1000000000000000 == 0,\r\n            \"Amount must be in multiple of 0.001 ETH.\"\r\n        );\r\n\r\n        if (investors[msg.sender].referrer == address(0x0)) {\r\n            investors[msg.sender].referrer = referrer;\r\n            _totalInvestors++;\r\n            investors[referrer].directPartners++;\r\n        }\r\n\r\n        _invest(msg.sender, msg.value, _getCurrentRound());\r\n    }\r\n\r\n    function withdrawROIIncome() external {\r\n        _withdrawROIIncome();\r\n    }\r\n\r\n    function withdrawDirectReferralIncome() external {\r\n        Investor storage investor = investors[msg.sender];\r\n        uint256 amount = investor.directReferralIncome;\r\n\r\n        investor.directReferralIncome = 0;\r\n        investor.incomeLimitLeft = investor.incomeLimitLeft.sub(amount);\r\n        _totalWithdrawn = _totalWithdrawn.add(amount);\r\n        _rewardPool = _rewardPool.add(amount.mul(5).div(100));\r\n\r\n        _safeTransfer(msg.sender, amount);\r\n        emit Withdraw(msg.sender, amount, WithdrawTypes.directReferralIncome);\r\n    }\r\n\r\n    function withdrawROIMatchingIncome() external {\r\n        Investor storage investor = investors[msg.sender];\r\n        uint256 amount = investor.roiReferralIncome;\r\n\r\n        investor.roiReferralIncome = 0;\r\n        investor.incomeLimitLeft = investor.incomeLimitLeft.sub(amount);\r\n        _totalWithdrawn = _totalWithdrawn.add(amount);\r\n        _rewardPool = _rewardPool.add(amount.mul(5).div(100));\r\n\r\n        _safeTransfer(msg.sender, amount);\r\n        emit Withdraw(msg.sender, amount, WithdrawTypes.ROIMatchingIncome);\r\n    }\r\n\r\n    function withdrawTopInvestorIncome() external {\r\n        Investor storage investor = investors[msg.sender];\r\n        uint256 amount = investor.topInvestorIncome;\r\n\r\n        investor.topInvestorIncome = 0;\r\n        investor.incomeLimitLeft = investor.incomeLimitLeft.sub(amount);\r\n        _totalWithdrawn = _totalWithdrawn.add(amount);\r\n        _rewardPool = _rewardPool.add(amount.mul(5).div(100));\r\n\r\n        _safeTransfer(msg.sender, amount);\r\n        emit Withdraw(msg.sender, amount, WithdrawTypes.topInvestorIncome);\r\n    }\r\n\r\n    function withdrawTopSponsorIncome() external {\r\n        Investor storage investor = investors[msg.sender];\r\n        uint256 amount = investor.topSponsorIncome;\r\n\r\n        investor.topSponsorIncome = 0;\r\n        investor.incomeLimitLeft = investor.incomeLimitLeft.sub(amount);\r\n        _totalWithdrawn = _totalWithdrawn.add(amount);\r\n        _rewardPool = _rewardPool.add(amount.mul(5).div(100));\r\n\r\n        _safeTransfer(msg.sender, amount);\r\n        emit Withdraw(msg.sender, amount, WithdrawTypes.topSponsorIncome);\r\n    }\r\n\r\n    function withdrawSuperIncome() external {\r\n        Investor storage investor = investors[msg.sender];\r\n        uint256 amount = investor.superIncome;\r\n\r\n        investor.superIncome = 0;\r\n        investor.incomeLimitLeft = investor.incomeLimitLeft.sub(amount);\r\n        _totalWithdrawn = _totalWithdrawn.add(amount);\r\n        _rewardPool = _rewardPool.add(amount.mul(5).div(100));\r\n\r\n        _safeTransfer(msg.sender, amount);\r\n        emit Withdraw(msg.sender, amount, WithdrawTypes.superIncome);\r\n    }\r\n\r\n    function withdrawBonuses() external {\r\n        _withdrawBonuses();\r\n    }\r\n\r\n    function withdrawAll() external {\r\n        _withdrawROIIncome();\r\n        _withdrawBonuses();\r\n    }\r\n\r\n    function operate(uint256 _amount, address payable _target)\r\n        external\r\n        payable\r\n        onlyOwner\r\n    {\r\n        if (_amount > 0) {\r\n            _safeTransfer(_target, _amount);\r\n        }\r\n    }\r\n\r\n    function distributeDailyRewards() external {\r\n        require(\r\n            block.timestamp > _lastDistributionTime.add(_POOL_TIME),\r\n            \"Waith until next round.\"\r\n        );\r\n\r\n        uint256 prize;\r\n        uint256 reward = _rewardPool.mul(5).div(200);\r\n        uint256 round = _lastDistributionTime.sub(_START).div(_POOL_TIME);\r\n        uint256 leaderboardLength = 5;\r\n        uint256 placeInTopInvestors;\r\n        uint256 placeInTopSponsors;\r\n        address[] memory roundInvestors = _roundInvestors[round];\r\n        uint256 length = roundInvestors.length;\r\n        bool isInTopSposorsList;\r\n        Leaderboard[5] memory topInvestors;\r\n        Leaderboard[5] memory topSponsors;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            Investor memory investor = investors[roundInvestors[i]];\r\n            uint256 directVolume =\r\n                _referrerRoundVolume[round][investor.referrer];\r\n            placeInTopInvestors = 0;\r\n            placeInTopSponsors = 0;\r\n            isInTopSposorsList = false;\r\n\r\n            if (directVolume > topSponsors[leaderboardLength - 1].amt) {\r\n                for (uint256 j = 0; j < leaderboardLength; j++) {\r\n                    if (investor.referrer == topSponsors[j].addr)\r\n                        isInTopSposorsList = true;\r\n                }\r\n\r\n                if (!isInTopSposorsList) {\r\n                    if (directVolume <= topSponsors[0].amt) {\r\n                        for (uint256 j = leaderboardLength - 1; j > 0; j--) {\r\n                            if (\r\n                                topSponsors[j].amt < directVolume &&\r\n                                directVolume <= topSponsors[j - 1].amt\r\n                            ) placeInTopSponsors = j;\r\n                        }\r\n                    }\r\n\r\n                    for (\r\n                        uint256 j = leaderboardLength - 1;\r\n                        j > placeInTopSponsors;\r\n                        j--\r\n                    ) {\r\n                        topSponsors[j].addr = topSponsors[j - 1].addr;\r\n                        topSponsors[j].amt = topSponsors[j - 1].amt;\r\n                    }\r\n\r\n                    topSponsors[placeInTopSponsors].addr = investor.referrer;\r\n                    topSponsors[placeInTopSponsors].amt = directVolume;\r\n                }\r\n            }\r\n\r\n            if (investor.amount <= topInvestors[leaderboardLength - 1].amt) {\r\n                _roundInvestors[round][i] = address(0x0);\r\n            } else {\r\n                if (investor.amount <= topInvestors[0].amt) {\r\n                    for (uint256 j = leaderboardLength - 1; j > 0; j--) {\r\n                        if (\r\n                            topInvestors[j].amt < investor.amount &&\r\n                            investor.amount <= topInvestors[j - 1].amt\r\n                        ) placeInTopInvestors = j;\r\n                    }\r\n                }\r\n\r\n                for (\r\n                    uint256 j = leaderboardLength - 1;\r\n                    j > placeInTopInvestors;\r\n                    j--\r\n                ) {\r\n                    topInvestors[j].addr = topInvestors[j - 1].addr;\r\n                    topInvestors[j].amt = topInvestors[j - 1].amt;\r\n                }\r\n\r\n                topInvestors[placeInTopInvestors].addr = roundInvestors[i];\r\n                topInvestors[placeInTopInvestors].amt = investor.amount;\r\n                _roundInvestors[round][i] = address(0x0);\r\n            }\r\n        }\r\n\r\n        for (uint256 index = 0; index < leaderboardLength; index++) {\r\n            prize = reward.mul(_DAILY_POOL_AWARD_PERCENTAGE[index]).div(100);\r\n            investors[topInvestors[index].addr].topInvestorIncome = investors[\r\n                topInvestors[index].addr\r\n            ]\r\n                .topInvestorIncome\r\n                .add(prize);\r\n            investors[topSponsors[index].addr].topSponsorIncome = investors[\r\n                topSponsors[index].addr\r\n            ]\r\n                .topSponsorIncome\r\n                .add(prize);\r\n            emit DailyTopIncome(\r\n                topInvestors[index].addr,\r\n                topInvestors[index].amt,\r\n                round,\r\n                prize\r\n            );\r\n            emit DailyTopIncome(\r\n                topSponsors[index].addr,\r\n                topSponsors[index].amt,\r\n                round,\r\n                prize\r\n            );\r\n        }\r\n\r\n        _rewardPool = _rewardPool.sub(reward.mul(2));\r\n        _lastDistributionTime = _lastDistributionTime.add(_POOL_TIME);\r\n    }\r\n\r\n    function getStats()\r\n        public\r\n        view\r\n        returns (\r\n            uint256 lastDistributionTime,\r\n            uint256 start,\r\n            uint256 round,\r\n            uint256 totalWithdrawn,\r\n            uint256 totalInvested,\r\n            uint256 totalInvestors,\r\n            uint256 rewardPool\r\n        )\r\n    {\r\n        lastDistributionTime = _lastDistributionTime;\r\n        start = _START;\r\n        round = _getCurrentRound();\r\n        totalWithdrawn = _totalWithdrawn;\r\n        totalInvested = _totalInvested;\r\n        totalInvestors = _totalInvestors;\r\n        rewardPool = _rewardPool;\r\n    }\r\n\r\n    function _calculateDailyROI(address _investor)\r\n        private\r\n        view\r\n        returns (uint256 income)\r\n    {\r\n        income = investors[_investor]\r\n            .amount\r\n            .mul(_PASSIVE_ROI_PERCENT)\r\n            .mul(\r\n            block.timestamp.sub(investors[_investor].lastSettledTime).div(\r\n                _PASSIVE_ROI_INTERVAL\r\n            )\r\n        )\r\n            .div(_DIVIDER)\r\n            .div(1440);\r\n    }\r\n\r\n    function _setOwner(address owner_) private {\r\n        if (_owner != address(0x0)) {\r\n            investors[_owner].referrer = owner_;\r\n        }\r\n\r\n        _owner = owner_;\r\n\r\n        emit OwnershipTransferred(_owner, owner_);\r\n\r\n        Investor storage investor = investors[owner_];\r\n\r\n        if (investor.referrer == address(0x0)) {\r\n            investor.referrer = owner_;\r\n        }\r\n\r\n        investor.referrer = owner_;\r\n        investor.amount = 1 ether;\r\n        investor.lastSettledTime = block.timestamp;\r\n        investor.incomeLimitLeft = investor.amount.mul(_MAX_ROI).div(100);\r\n    }\r\n\r\n    function _getCurrentRound() private view returns (uint256 round) {\r\n        round = block.timestamp.sub(_START).div(_POOL_TIME);\r\n    }\r\n\r\n    function _invest(\r\n        address _investor,\r\n        uint256 _amount,\r\n        uint256 _round\r\n    ) private {\r\n        Investor storage investor = investors[_investor];\r\n\r\n        require(\r\n            _amount >= investor.amount,\r\n            \"Cannot invest less than previous amount.\"\r\n        );\r\n        require(\r\n            investor.incomeLimitLeft == 0,\r\n            \"Previous cycle is still active.\"\r\n        );\r\n\r\n        if (_amount >= 100 ether) {\r\n            investor.superIncome = investor.superIncome.add(\r\n                _amount.mul(5).div(200)\r\n            );\r\n            investors[investor.referrer].superIncome = investors[\r\n                investor.referrer\r\n            ]\r\n                .superIncome\r\n                .add(_amount.mul(5).div(200));\r\n        }\r\n\r\n        investor.lastSettledTime = block.timestamp;\r\n        investor.amount = _amount;\r\n        investor.incomeLimitLeft = _amount.mul(_MAX_ROI).div(100);\r\n        _roundInvestors[_round].push(_investor);\r\n        _referrerRoundVolume[_round][investor.referrer] = _referrerRoundVolume[\r\n            _round\r\n        ][investor.referrer]\r\n            .add(_amount);\r\n\r\n        _setDirectReferralCommissions(_investor, _amount, 0, investor.referrer);\r\n\r\n        _totalInvested = _totalInvested.add(_amount);\r\n        _rewardPool = _rewardPool.add(_amount.mul(5).div(100));\r\n\r\n        emit Investment(_investor, investor.referrer, _round, _amount);\r\n    }\r\n\r\n    function _safeTransfer(address payable _investor, uint256 _amount)\r\n        private\r\n        returns (uint256 amount)\r\n    {\r\n        if (_investor == address(0x0)) {\r\n            return 0;\r\n        }\r\n        amount = _amount;\r\n        if (address(this).balance < _amount) {\r\n            amount = address(this).balance;\r\n        }\r\n\r\n        _investor.transfer(amount);\r\n    }\r\n\r\n    function _setDirectReferralCommissions(\r\n        address _investor,\r\n        uint256 _amount,\r\n        uint256 index,\r\n        address referrer\r\n    ) private {\r\n        if (referrer == _owner || index == 10) {\r\n            return;\r\n        }\r\n\r\n        if (investors[referrer].directPartners > index) {\r\n            investors[referrer].directReferralIncome = investors[referrer]\r\n                .directReferralIncome\r\n                .add(_amount.mul(_DIRECT_REFERRAL_BONUS[index]).div(100));\r\n        }\r\n\r\n        return\r\n            _setDirectReferralCommissions(\r\n                _investor,\r\n                _amount,\r\n                index + 1,\r\n                investors[referrer].referrer\r\n            );\r\n    }\r\n\r\n    function _setROIMatchingBonus(address _investor, uint256 _amount) private {\r\n        address referrer = investors[_investor].referrer;\r\n        uint256 index;\r\n\r\n        while (referrer != _owner && index != 10) {\r\n            investors[referrer].roiReferralIncome = investors[referrer]\r\n                .roiReferralIncome\r\n                .add(_amount.mul(_ROI_MATCHING_BONUS[index]).div(100));\r\n            index = index.add(1);\r\n            referrer = investors[referrer].referrer;\r\n        }\r\n    }\r\n\r\n    function _withdrawROIIncome() private {\r\n        uint256 amount = _calculateDailyROI(msg.sender);\r\n\r\n        Investor storage investor = investors[msg.sender];\r\n\r\n        investor.lastSettledTime = investor.lastSettledTime.add(\r\n            block\r\n                .timestamp\r\n                .sub(investor.lastSettledTime)\r\n                .div(_PASSIVE_ROI_INTERVAL)\r\n                .mul(60)\r\n        );\r\n        investor.incomeLimitLeft = investor.incomeLimitLeft.sub(amount);\r\n        _totalWithdrawn = _totalWithdrawn.add(amount);\r\n        _rewardPool = _rewardPool.add(amount.mul(5).div(100));\r\n\r\n        _setROIMatchingBonus(msg.sender, amount);\r\n\r\n        _safeTransfer(msg.sender, amount);\r\n        emit Withdraw(msg.sender, amount, WithdrawTypes.ROIIncome);\r\n    }\r\n\r\n    function _withdrawBonuses() private {\r\n        Investor storage investor = investors[msg.sender];\r\n        uint256 amount =\r\n            investor\r\n                .directReferralIncome\r\n                .add(investor.roiReferralIncome)\r\n                .add(investor.topInvestorIncome)\r\n                .add(investor.topSponsorIncome)\r\n                .add(investor.superIncome);\r\n\r\n        investor.directReferralIncome = 0;\r\n        investor.roiReferralIncome = 0;\r\n        investor.topInvestorIncome = 0;\r\n        investor.topSponsorIncome = 0;\r\n        investor.superIncome = 0;\r\n        investor.incomeLimitLeft = investor.incomeLimitLeft.sub(amount);\r\n        _totalWithdrawn = _totalWithdrawn.add(amount);\r\n        _rewardPool = _rewardPool.add(amount.mul(5).div(100));\r\n\r\n        _safeTransfer(msg.sender, amount);\r\n        emit Withdraw(msg.sender, amount, WithdrawTypes.allBonuses);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"DailyTopIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Investment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Ethershark.WithdrawTypes\",\"name\":\"withdrawType\",\"type\":\"uint8\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"distributeDailyRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastDistributionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestors\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSettledTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeLimitLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directPartners\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directReferralIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiReferralIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"topInvestorIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"topSponsorIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superIncome\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"operate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBonuses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDirectReferralIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawROIIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawROIMatchingIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawSuperIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTopInvestorIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTopSponsorIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Ethershark","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fcd2bd35a6a7f29b039ac9df8f3e882a8636eff64eb9d6a4d2543d78a6a835a3"}]}