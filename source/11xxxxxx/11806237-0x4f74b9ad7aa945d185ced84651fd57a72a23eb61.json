{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\liquidity-mining\\ILiquidityMiningFactory.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.6;\r\n\r\ninterface ILiquidityMiningFactory {\r\n\r\n    event ExtensionCloned(address indexed);\r\n\r\n    function feePercentageInfo() external view returns (uint256, address);\r\n    function liquidityMiningDefaultExtension() external view returns(address);\r\n    function cloneLiquidityMiningDefaultExtension() external returns(address);\r\n    function getLiquidityFarmTokenCollectionURI() external view returns (string memory);\r\n    function getLiquidityFarmTokenURI() external view returns (string memory);\r\n}\r\n\r\n// File: contracts\\amm-aggregator\\common\\AMMData.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\n\r\nstruct LiquidityPoolData {\r\n    address liquidityPoolAddress;\r\n    uint256 amount;\r\n    address tokenAddress;\r\n    bool amountIsLiquidityPool;\r\n    bool involvingETH;\r\n    address receiver;\r\n}\r\n\r\nstruct SwapData {\r\n    bool enterInETH;\r\n    bool exitInETH;\r\n    address[] liquidityPoolAddresses;\r\n    address[] path;\r\n    address inputToken;\r\n    uint256 amount;\r\n    address receiver;\r\n}\r\n\r\n// File: contracts\\liquidity-mining\\LiquidityMiningData.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\n\r\n\r\nstruct LiquidityMiningSetupConfiguration {\r\n    bool add;\r\n    uint256 index;\r\n    LiquidityMiningSetup data;\r\n}\r\n\r\n// liquidity mining setup struct\r\nstruct LiquidityMiningSetup {\r\n    address ammPlugin; // amm plugin address used for this setup (eg. uniswap amm plugin address).\r\n    uint256 objectId; // items object id for the liquidity pool token.\r\n    address liquidityPoolTokenAddress; // address of the liquidity pool token\r\n    address mainTokenAddress; // eg. buidl address.\r\n    uint256 startBlock; // liquidity mining setup start block (used only if free is false).\r\n    uint256 endBlock; // liquidity mining setup end block (used only if free is false).\r\n    uint256 rewardPerBlock; // liquidity mining setup reward per single block.\r\n    uint256 currentRewardPerBlock; // liquidity mining setup current reward per single block.\r\n    uint256 totalSupply; // current liquidity added in this setup (used only if free is true).\r\n    uint256 lastBlockUpdate; // number of the block where an update was triggered.\r\n    uint256 maximumLiquidity; // maximum liquidity stakeable in the contract (used only if free is false).\r\n    uint256 currentStakedLiquidity; // currently staked liquidity (used only if free is false).\r\n    bool free; // if the setup is a free liquidity mining setup or a locked one.\r\n    uint256 renewTimes; // if the locked setup is renewable or if it's one time (used only if free is false).\r\n    uint256 penaltyFee; // fee paid when the user exits a still active locked liquidity mining setup (used only if free is false).\r\n    bool involvingETH; // if the setup involves ETH or not.\r\n}\r\n\r\n// position struct\r\nstruct LiquidityMiningPosition {\r\n    address uniqueOwner; // address representing the extension address, address(0) if objectId is populated.\r\n    uint256 setupIndex; // the setup index.\r\n    uint256 setupStartBlock; // liquidity mining setup start block (used only if free is false).\r\n    uint256 setupEndBlock; // liquidity mining setup end block (used only if free is false).\r\n    bool free; // if the setup is a free liquidity mining setup or a locked one.\r\n    // LiquidityPoolData liquidityPoolData; // amm liquidity pool data.\r\n    uint256 liquidityPoolTokenAmount;\r\n    uint256 reward; // position reward.\r\n    uint256 lockedRewardPerBlock; // position locked reward per block.\r\n    uint256 creationBlock; // block when this position was created.\r\n}\r\n\r\n// stake data struct\r\nstruct LiquidityMiningPositionRequest {\r\n    uint256 setupIndex; // index of the chosen setup.\r\n    uint256 amount; // amount of main token or liquidity pool token.\r\n    bool amountIsLiquidityPool; //true if user wants to directly share the liquidity pool token amount, false to add liquidity to AMM\r\n    address positionOwner; // position extension or address(0) [msg.sender].\r\n}\r\n\r\n// File: contracts\\liquidity-mining\\ILiquidityMiningExtension.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\npragma abicoder v2;\r\n\r\n\r\ninterface ILiquidityMiningExtension {\r\n\r\n    function init(bool byMint, address host) external;\r\n\r\n    function setHost(address host) external;\r\n\r\n    function data() external view returns(address liquidityMiningContract, bool byMint, address host, address rewardTokenAddress);\r\n\r\n    function transferTo(uint256 amount, address recipient) external;\r\n    function backToYou(uint256 amount) external payable;\r\n\r\n    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) external;\r\n}\r\n\r\n// File: contracts\\amm-aggregator\\common\\IAMM.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\n//pragma abicoder v2;\r\n\r\n\r\ninterface IAMM {\r\n\r\n    event NewLiquidityPoolAddress(address indexed);\r\n\r\n    function info() external view returns(string memory name, uint256 version);\r\n\r\n    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\r\n\r\n    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\r\n\r\n    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\r\n\r\n    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\r\n\r\n    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\r\n\r\n    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\r\n\r\n    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\r\n\r\n    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\r\n\r\n    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\r\n    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\r\n\r\n    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\r\n    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\r\n\r\n    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\r\n\r\n    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\r\n    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\r\n}\r\n\r\n// File: contracts\\liquidity-mining\\util\\IERC20.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function safeApprove(address spender, uint256 amount) external;\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: contracts\\liquidity-mining\\util\\IEthItemOrchestrator.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\ninterface IEthItemOrchestrator {\r\n    function createNative(bytes calldata modelInitPayload, string calldata ens)\r\n        external\r\n        returns (address newNativeAddress, bytes memory modelInitCallResponse);\r\n}\r\n\r\n// File: contracts\\liquidity-mining\\util\\IERC1155.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\ninterface IERC1155 {\r\n\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts\\liquidity-mining\\util\\IEthItemInteroperableInterface.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\n\r\ninterface IEthItemInteroperableInterface is IERC20 {\r\n\r\n    function mainInterface() external view returns (address);\r\n\r\n    function objectId() external view returns (uint256);\r\n\r\n    function mint(address owner, uint256 amount) external;\r\n\r\n    function burn(address owner, uint256 amount) external;\r\n\r\n    function permitNonce(address sender) external view returns(uint256);\r\n\r\n    function permit(address owner, address spender, uint value, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    function interoperableInterfaceVersion() external pure returns(uint256 ethItemInteroperableInterfaceVersion);\r\n}\r\n\r\n// File: contracts\\liquidity-mining\\util\\IEthItem.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\n\r\n\r\ninterface IEthItem is IERC1155 {\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalSupply(uint256 objectId) external view returns (uint256);\r\n\r\n    function name(uint256 objectId) external view returns (string memory);\r\n\r\n    function symbol(uint256 objectId) external view returns (string memory);\r\n\r\n    function decimals(uint256 objectId) external view returns (uint256);\r\n\r\n    function uri(uint256 objectId) external view returns (string memory);\r\n\r\n    function mainInterfaceVersion() external pure returns(uint256 ethItemInteroperableVersion);\r\n\r\n    function toInteroperableInterfaceAmount(uint256 objectId, uint256 ethItemAmount) external view returns (uint256 interoperableInterfaceAmount);\r\n\r\n    function toMainInterfaceAmount(uint256 objectId, uint256 erc20WrapperAmount) external view returns (uint256 mainInterfaceAmount);\r\n\r\n    function interoperableInterfaceModel() external view returns (address, uint256);\r\n\r\n    function asInteroperable(uint256 objectId) external view returns (IEthItemInteroperableInterface);\r\n\r\n    function emitTransferSingleEvent(address sender, address from, address to, uint256 objectId, uint256 amount) external;\r\n\r\n    function mint(uint256 amount, string calldata partialUri)\r\n        external\r\n        returns (uint256, address);\r\n\r\n    function burn(\r\n        uint256 objectId,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function burnBatch(\r\n        uint256[] calldata objectIds,\r\n        uint256[] calldata amounts\r\n    ) external;\r\n}\r\n\r\n// File: contracts\\liquidity-mining\\util\\INativeV1.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\n\r\ninterface INativeV1 is IEthItem {\r\n\r\n    function init(string calldata name, string calldata symbol, bool hasDecimals, string calldata collectionUri, address extensionAddress, bytes calldata extensionInitPayload) external returns(bytes memory extensionInitCallResponse);\r\n    function extension() external view returns (address extensionAddress);\r\n    function canMint(address operator) external view returns (bool result);\r\n    function isEditable(uint256 objectId) external view returns (bool result);\r\n    function releaseExtension() external;\r\n    function uri() external view returns (string memory);\r\n    function decimals() external view returns (uint256);\r\n    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri, bool editable) external returns (uint256 objectId, address tokenAddress);\r\n    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri) external returns (uint256 objectId, address tokenAddress);\r\n    function mint(uint256 objectId, uint256 amount) external;\r\n    function makeReadOnly(uint256 objectId) external;\r\n    function setUri(string calldata newUri) external;\r\n    function setUri(uint256 objectId, string calldata newUri) external;\r\n}\r\n\r\n// File: contracts\\liquidity-mining\\util\\ERC1155Receiver.sol\r\n\r\n// File: contracts/usd-v2/util/ERC1155Receiver.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\nabstract contract ERC1155Receiver {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor() {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n        _registerInterface(\r\n            ERC1155Receiver(0).onERC1155Received.selector ^\r\n            ERC1155Receiver(0).onERC1155BatchReceived.selector\r\n        );\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        virtual\r\n        returns(bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        virtual\r\n        returns(bytes4);\r\n}\r\n\r\n// File: contracts\\liquidity-mining\\ILiquidityMining.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\n//pragma abicoder v2;\r\n\r\n\r\ninterface ILiquidityMining {\r\n\r\n    function _rewardTokenAddress() external view returns(address);\r\n    function setups() external view returns (LiquidityMiningSetup[] memory);\r\n    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) external;\r\n    \r\n}\r\n\r\n// File: contracts\\liquidity-mining\\LiquidityMining.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\n//pragma abicoder v2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LiquidityMining is ILiquidityMining, ERC1155Receiver {\r\n\r\n    uint256 public constant ONE_HUNDRED = 1e18;\r\n\r\n    // event that tracks liquidity mining contracts deployed\r\n    event RewardToken(address indexed rewardTokenAddress);\r\n    // new liquidity mining position event\r\n    event Transfer(uint256 indexed positionId, address indexed from, address indexed to);\r\n    // event that tracks involved tokens for this contract\r\n    event SetupToken(address indexed mainToken, address indexed involvedToken);\r\n    // event that tracks farm tokens\r\n    event FarmToken(uint256 indexed objectId, address indexed liquidityPoolToken, uint256 setupIndex, uint256 endBlock);\r\n\r\n    // factory address that will create clones of this contract\r\n    address public _factory;\r\n    // address of the extension of this contract\r\n    address public _extension;\r\n    // address of the reward token\r\n    address public override _rewardTokenAddress;\r\n    // liquidity farm token collection\r\n    address public _liquidityFarmTokenCollection;\r\n    // array containing all the currently available liquidity mining setups\r\n    LiquidityMiningSetup[] private _setups;\r\n    // mapping containing all the positions\r\n    mapping(uint256 => LiquidityMiningPosition) public _positions;\r\n    // mapping containing the reward per token per setup per block\r\n    mapping(uint256 => mapping(uint256 => uint256)) public _rewardPerTokenPerSetupPerBlock;\r\n    // mapping containing all the blocks where an update has been triggered\r\n    mapping(uint256 => uint256[]) public _setupUpdateBlocks;\r\n    // mapping containing whether a liquidity mining position has been redeemed or not\r\n    mapping(uint256 => bool) public _positionRedeemed;\r\n    // mapping containing whether a liquidity mining position has been partially reedemed or not\r\n    mapping(uint256 => uint256) public _partiallyRedeemed;\r\n    // mapping containing whether a locked setup has ended or not and has been used for the rebalance\r\n    mapping(uint256 => bool) public _finishedLockedSetups;\r\n    // mapping containing object id to setup index\r\n    mapping(uint256 => uint256) private _objectIdSetup;\r\n    // pinned setup index\r\n    bool public _hasPinned;\r\n    uint256 public _pinnedSetupIndex;\r\n\r\n    /** Modifiers. */\r\n\r\n    /** @dev byExtension modifier used to check for unauthorized changes. */\r\n    modifier byExtension() {\r\n        require(msg.sender == _extension, \"Unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /** @dev byPositionOwner modifier used to check for unauthorized accesses. */\r\n    modifier byPositionOwner(uint256 positionId) {\r\n        require(_positions[positionId].uniqueOwner == msg.sender, \"Not owned\");\r\n        _;\r\n    }\r\n\r\n    /** Public extension methods. */\r\n\r\n    /** @dev initializes the liquidity mining contract.\r\n      * @param extension extension address.\r\n      * @param extensionInitData lm extension init payload.\r\n      * @param orchestrator address of the eth item orchestrator.\r\n      * @param rewardTokenAddress address of the reward token.\r\n      * @param liquidityMiningSetupsBytes array containing all the liquidity mining setups as bytes.\r\n      * @param setPinned true if we're setting a pinned setup during initialization, false otherwise.\r\n      * @param pinnedIndex index of the pinned setup.\r\n      * @return extensionReturnCall result of the extension initialization function, if it was called.  \r\n     */\r\n    function init(address extension, bytes memory extensionInitData, address orchestrator, address rewardTokenAddress, bytes memory liquidityMiningSetupsBytes, bool setPinned, uint256 pinnedIndex) public returns(bytes memory extensionReturnCall) {\r\n        require(_factory == address(0), \"Already initialized\");\r\n        require((_extension = extension) != address(0), \"extension\");\r\n        _factory = msg.sender;\r\n        emit RewardToken(_rewardTokenAddress = rewardTokenAddress);\r\n        if (keccak256(extensionInitData) != keccak256(\"\")) {\r\n            extensionReturnCall = _call(_extension, extensionInitData);\r\n        }\r\n        (_liquidityFarmTokenCollection,) = IEthItemOrchestrator(orchestrator).createNative(abi.encodeWithSignature(\"init(string,string,bool,string,address,bytes)\", \"Covenants Farming\", \"cFARM\", true, ILiquidityMiningFactory(_factory).getLiquidityFarmTokenCollectionURI(), address(this), \"\"), \"\");\r\n        _initLiquidityMiningSetups(liquidityMiningSetupsBytes, setPinned, pinnedIndex);\r\n    }\r\n\r\n    /** @dev allows this contract to receive eth. */\r\n    receive() external payable { }\r\n\r\n    /** @dev returns the liquidity mining setups.\r\n      * @return array containing all the liquidity mining setups.\r\n     */\r\n    function setups() view public override returns (LiquidityMiningSetup[] memory) {\r\n        return _setups;\r\n    }\r\n\r\n    /** @dev returns the liquidity mining position associated with the input id.\r\n      * @param id liquidity mining position id.\r\n      * @return liquidity mining position stored at the given id.\r\n     */\r\n    function position(uint256 id) public view returns(LiquidityMiningPosition memory) {\r\n        return _positions[id];\r\n    }\r\n\r\n    /** @dev returns the reward per token for the setup index at the given block number.\r\n      * @param setupIndex index of the setup.\r\n      * @param blockNumber block that wants to be inspected.\r\n      * @return reward per token.\r\n     */\r\n    function rewardPerToken(uint256 setupIndex, uint256 blockNumber) public view returns(uint256) {\r\n        return _rewardPerTokenPerSetupPerBlock[setupIndex][blockNumber];\r\n    }\r\n\r\n    /** @dev allows the extension to set the liquidity mining setups.\r\n      * @param liquidityMiningSetups liquidity mining setups to set.\r\n      * @param setPinned if we're updating the pinned setup or not.\r\n      * @param pinnedIndex new pinned setup index.\r\n      */\r\n    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) public override byExtension {\r\n        for (uint256 i = 0; i < liquidityMiningSetups.length; i++) {\r\n            _setOrAddLiquidityMiningSetup(liquidityMiningSetups[i].data, liquidityMiningSetups[i].add, liquidityMiningSetups[i].index);\r\n        }\r\n        _pinnedSetup(clearPinned, setPinned, pinnedIndex);\r\n        // rebalance the pinned setup\r\n        rebalancePinnedSetup();\r\n    }\r\n\r\n    /** Public methods. */\r\n\r\n    /** @dev function called by external users to open a new liquidity mining position.\r\n      * @param request Liquidity Mining input data.\r\n    */\r\n    function openPosition(LiquidityMiningPositionRequest memory request) public payable returns(uint256 positionId) {\r\n        require(request.setupIndex < _setups.length, \"Invalid setup index\");\r\n        // retrieve the setup\r\n        LiquidityMiningSetup storage chosenSetup = _setups[request.setupIndex];\r\n        require(chosenSetup.free || (block.number >= chosenSetup.startBlock && block.number < chosenSetup.endBlock), \"Setup not available\");\r\n        (IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount, bool involvingETH) = _transferToMeAndCheckAllowance(chosenSetup, request);\r\n        // retrieve the unique owner\r\n        address uniqueOwner = (request.positionOwner != address(0)) ? request.positionOwner : msg.sender;\r\n        LiquidityPoolData memory liquidityPoolData = LiquidityPoolData(\r\n            chosenSetup.liquidityPoolTokenAddress,\r\n            request.amountIsLiquidityPool ? liquidityPoolAmount : mainTokenAmount,\r\n            chosenSetup.mainTokenAddress,\r\n            request.amountIsLiquidityPool,\r\n            involvingETH,\r\n            address(this)\r\n        );\r\n\r\n        if (!liquidityPoolData.amountIsLiquidityPool) {\r\n            // retrieve the poolTokenAmount from the amm\r\n            if(liquidityPoolData.involvingETH) {\r\n                (liquidityPoolData.amount,,) = amm.addLiquidity{value : msg.value}(liquidityPoolData);\r\n            } else {\r\n                (liquidityPoolData.amount,,) = amm.addLiquidity(liquidityPoolData);\r\n            }\r\n            liquidityPoolData.amountIsLiquidityPool = true;\r\n        } else {\r\n            require(msg.value == 0, \"ETH not involved\");\r\n        }\r\n        // create the position id\r\n        positionId = uint256(keccak256(abi.encode(uniqueOwner, request.setupIndex, block.number)));\r\n        // calculate the reward\r\n        uint256 reward;\r\n        uint256 lockedRewardPerBlock;\r\n        if (!chosenSetup.free) {\r\n            (reward, lockedRewardPerBlock) = calculateLockedLiquidityMiningSetupReward(request.setupIndex, mainTokenAmount, false, 0);\r\n            require(reward > 0 && lockedRewardPerBlock > 0, \"Insufficient staked amount\");\r\n            ILiquidityMiningExtension(_extension).transferTo(reward, address(this));\r\n            chosenSetup.currentRewardPerBlock += lockedRewardPerBlock;\r\n            chosenSetup.currentStakedLiquidity += mainTokenAmount;\r\n            _mintLiquidity(uniqueOwner, liquidityPoolData.amount, request.setupIndex);\r\n        }\r\n        _positions[positionId] = LiquidityMiningPosition({\r\n            uniqueOwner: uniqueOwner,\r\n            setupIndex : request.setupIndex,\r\n            setupStartBlock : chosenSetup.startBlock,\r\n            setupEndBlock : chosenSetup.endBlock,\r\n            free : chosenSetup.free,\r\n            liquidityPoolTokenAmount: liquidityPoolData.amount,\r\n            reward: reward,\r\n            lockedRewardPerBlock: lockedRewardPerBlock,\r\n            creationBlock: block.number\r\n        });\r\n        if (chosenSetup.free) {\r\n            _rebalanceRewardPerToken(request.setupIndex, liquidityPoolData.amount, false);\r\n        } else {\r\n            if (_hasPinned && _setups[_pinnedSetupIndex].free) {\r\n                _rebalanceRewardPerBlock(_pinnedSetupIndex, (chosenSetup.rewardPerBlock * (mainTokenAmount * 1e18 / chosenSetup.maximumLiquidity)) / 1e18, false);\r\n            }\r\n        }\r\n\r\n        emit Transfer(positionId, address(0), uniqueOwner);\r\n    }\r\n\r\n    /** @dev adds liquidity to the liquidity mining position at the given positionId using the given lpData.\r\n      * @param positionId id of the liquidity mining position.\r\n      * @param request update position request.\r\n      */\r\n    function addLiquidity(uint256 positionId, LiquidityMiningPositionRequest memory request) public payable byPositionOwner(positionId) {\r\n        // retrieve liquidity mining position\r\n        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\r\n        // check if liquidity mining position is valid\r\n        require(liquidityMiningPosition.free, \"Invalid add liquidity\");\r\n        LiquidityMiningSetup memory chosenSetup = _setups[liquidityMiningPosition.setupIndex];\r\n        (IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount, bool involvingETH) = _transferToMeAndCheckAllowance(chosenSetup, request);\r\n\r\n        LiquidityPoolData memory liquidityPoolData = LiquidityPoolData(\r\n            chosenSetup.liquidityPoolTokenAddress,\r\n            request.amountIsLiquidityPool ? liquidityPoolAmount : mainTokenAmount,\r\n            chosenSetup.mainTokenAddress,\r\n            request.amountIsLiquidityPool,\r\n            involvingETH,\r\n            address(this)\r\n        );\r\n\r\n        if (!liquidityPoolData.amountIsLiquidityPool) {\r\n            // retrieve the poolTokenAmount from the amm\r\n            if(liquidityPoolData.involvingETH) {\r\n                (liquidityPoolData.amount,,) = amm.addLiquidity{value : msg.value}(liquidityPoolData);\r\n            } else {\r\n                (liquidityPoolData.amount,,) = amm.addLiquidity(liquidityPoolData);\r\n            }\r\n            liquidityPoolData.amountIsLiquidityPool = true;\r\n        } else {\r\n            require(msg.value == 0, \"ETH not involved\");\r\n        }\r\n        // rebalance the reward per token\r\n        _rebalanceRewardPerToken(liquidityMiningPosition.setupIndex, 0, false);\r\n        // calculate reward before adding liquidity pool data to the position\r\n        uint256 newReward = calculateFreeLiquidityMiningSetupReward(positionId, false);\r\n        // update the liquidity pool token amount\r\n        liquidityMiningPosition.liquidityPoolTokenAmount += liquidityPoolData.amount;\r\n        if (newReward > 0) {\r\n            // transfer the reward\r\n            ILiquidityMiningExtension(_extension).transferTo(newReward, msg.sender);\r\n        }\r\n        // update the creation block to avoid blocks before the new add liquidity\r\n        liquidityMiningPosition.creationBlock = block.number;\r\n        // rebalance the reward per token\r\n        _rebalanceRewardPerToken(liquidityMiningPosition.setupIndex, liquidityPoolData.amount, false);\r\n    }\r\n\r\n    /** @dev this function allows a wallet to update the extension of the given liquidity mining position.\r\n      * @param to address of the new extension.\r\n      * @param positionId id of the liquidity mining position.\r\n     */\r\n    function transfer(address to, uint256 positionId) public byPositionOwner(positionId) {\r\n        // retrieve liquidity mining position\r\n        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\r\n        require(\r\n            to != address(0) &&\r\n            liquidityMiningPosition.setupStartBlock == _setups[liquidityMiningPosition.setupIndex].startBlock &&\r\n            liquidityMiningPosition.setupEndBlock == _setups[liquidityMiningPosition.setupIndex].endBlock,\r\n            \"Invalid position\"\r\n        );\r\n        liquidityMiningPosition.uniqueOwner = to;\r\n        emit Transfer(positionId, msg.sender, to);\r\n    }\r\n\r\n    /** @dev this function allows a extension to unlock its locked liquidity mining position receiving back its tokens or the lpt amount.\r\n      * @param positionId liquidity mining position id.\r\n      * @param unwrapPair if the caller wants to unwrap his pair from the liquidity pool token or not.\r\n      */\r\n    function unlock(uint256 positionId, bool unwrapPair) public payable byPositionOwner(positionId) {\r\n        // retrieve liquidity mining position\r\n        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\r\n        // require(liquidityMiningPosition.liquidityPoolData.liquidityPoolAddress != address(0), \"Invalid position\");\r\n        require(!liquidityMiningPosition.free && liquidityMiningPosition.setupEndBlock >= block.number, \"Invalid unlock\");\r\n        require(!_positionRedeemed[positionId], \"Already redeemed\");\r\n        uint256 rewardToGiveBack = _partiallyRedeemed[positionId];\r\n        // must pay a penalty fee\r\n        rewardToGiveBack += _setups[liquidityMiningPosition.setupIndex].penaltyFee == 0 ? 0 : (liquidityMiningPosition.reward * ((_setups[liquidityMiningPosition.setupIndex].penaltyFee * 1e18) / ONE_HUNDRED) / 1e18);\r\n        if (rewardToGiveBack > 0) {\r\n            // has partially redeemed, must pay a penalty fee\r\n            if(_rewardTokenAddress != address(0)) {\r\n                _safeTransferFrom(_rewardTokenAddress, msg.sender, address(this), rewardToGiveBack);\r\n                _safeApprove(_rewardTokenAddress, _extension, rewardToGiveBack);\r\n                ILiquidityMiningExtension(_extension).backToYou(rewardToGiveBack);\r\n            } else {\r\n                require(msg.value == rewardToGiveBack, \"Invalid sent amount\");\r\n                ILiquidityMiningExtension(_extension).backToYou{value : rewardToGiveBack}(rewardToGiveBack);\r\n            }\r\n        }\r\n        _burnLiquidity(_setups[liquidityMiningPosition.setupIndex].objectId, liquidityMiningPosition.liquidityPoolTokenAmount);\r\n        _removeLiquidity(positionId, _setups[liquidityMiningPosition.setupIndex].objectId, liquidityMiningPosition.setupIndex, unwrapPair, liquidityMiningPosition.liquidityPoolTokenAmount, true);\r\n    }\r\n\r\n    /** @dev this function allows a user to withdraw the reward.\r\n      * @param positionId liquidity mining position id.\r\n     */\r\n    function withdrawReward(uint256 positionId) public byPositionOwner(positionId) {\r\n        // retrieve liquidity mining position\r\n        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\r\n        // check if liquidity mining position is valid\r\n        // require(liquidityMiningPosition.liquidityPoolData.liquidityPoolAddress != address(0), \"Invalid position\");\r\n        uint256 reward = liquidityMiningPosition.reward;\r\n        if (!liquidityMiningPosition.free) {\r\n            // check if reward is available\r\n            require(liquidityMiningPosition.reward > 0, \"No reward\");\r\n            // check if it's a partial reward or not\r\n            if (liquidityMiningPosition.setupEndBlock >= block.number) {\r\n            // calculate the reward from the liquidity mining position creation block to the current block multiplied by the reward per block\r\n                (reward,) = calculateLockedLiquidityMiningSetupReward(0, 0, true, positionId);\r\n            }\r\n            require(reward <= liquidityMiningPosition.reward, \"Reward is bigger than expected\");\r\n            // remove the partial reward from the liquidity mining position total reward\r\n            liquidityMiningPosition.reward = liquidityMiningPosition.reward - reward;\r\n        } else {\r\n            // rebalance setup\r\n            _rebalanceRewardPerToken(liquidityMiningPosition.setupIndex, 0, true);\r\n            reward = calculateFreeLiquidityMiningSetupReward(positionId, false);\r\n            require(reward > 0, \"No reward?\");\r\n        }\r\n        // transfer the reward\r\n        if (reward > 0) {\r\n            if(!liquidityMiningPosition.free) {\r\n                _rewardTokenAddress != address(0) ? _safeTransfer(_rewardTokenAddress, liquidityMiningPosition.uniqueOwner, reward) : payable(liquidityMiningPosition.uniqueOwner).transfer(reward);\r\n            } else {\r\n                ILiquidityMiningExtension(_extension).transferTo(reward, liquidityMiningPosition.uniqueOwner);\r\n            }\r\n        }\r\n        // update the creation block for the position\r\n        liquidityMiningPosition.creationBlock = block.number;\r\n        if (!liquidityMiningPosition.free) {\r\n            if (liquidityMiningPosition.reward == 0) {\r\n                // close the locked position after withdrawing all the reward\r\n                _positions[positionId] = _positions[0x0];\r\n            } else {\r\n                // set the partially redeemed amount\r\n                _partiallyRedeemed[positionId] += reward;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev allows the withdrawal of the liquidity from a position or from the item tokens.\r\n      * @param positionId id of the position.\r\n      * @param objectId object id of the item token to burn.\r\n      * @param unwrapPair if the liquidity pool tokens will be unwrapped or not.\r\n      * @param removedLiquidity amount of liquidity to remove.\r\n     */\r\n    function withdrawLiquidity(uint256 positionId, uint256 objectId, bool unwrapPair, uint256 removedLiquidity) public {\r\n        // retrieve liquidity mining position\r\n        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\r\n        uint256 setupIndex = objectId != 0 ? getObjectIdSetupIndex(objectId) : liquidityMiningPosition.setupIndex;\r\n        require(positionId != 0 || (_setups[setupIndex].objectId == objectId || _finishedLockedSetups[objectId]), \"Invalid position\");\r\n        // current owned liquidity\r\n        require(\r\n            (\r\n                liquidityMiningPosition.free && \r\n                removedLiquidity <= liquidityMiningPosition.liquidityPoolTokenAmount &&\r\n                !_positionRedeemed[positionId] &&\r\n                liquidityMiningPosition.uniqueOwner == msg.sender\r\n            ) || (positionId == 0 && INativeV1(_liquidityFarmTokenCollection).balanceOf(msg.sender, objectId) >= removedLiquidity), \"Invalid withdraw\");\r\n        // check if liquidity mining position is valid\r\n        require(liquidityMiningPosition.free || (_setups[setupIndex].endBlock <= block.number || _finishedLockedSetups[objectId]), \"Invalid withdraw\");\r\n        // burn the liquidity in the locked setup\r\n        if (positionId == 0) {\r\n            _burnLiquidity(objectId, removedLiquidity);\r\n        } else {\r\n            _positionRedeemed[positionId] = removedLiquidity == liquidityMiningPosition.liquidityPoolTokenAmount;\r\n            withdrawReward(positionId);\r\n            _setups[liquidityMiningPosition.setupIndex].totalSupply -= removedLiquidity;\r\n        }\r\n        _removeLiquidity(positionId, objectId, setupIndex, unwrapPair, removedLiquidity, false);\r\n    }\r\n\r\n    /** @dev this function allows any user to rebalance the pinned setup. */\r\n    function rebalancePinnedSetup() public {\r\n        // if (!_hasPinned || !_setups[_pinnedSetupIndex].free) return;\r\n        uint256 amount;\r\n        for (uint256 i = 0; i < _setups.length; i++) {\r\n            if (_setups[i].free) continue;\r\n            // this is a locked setup that it's currently active or it's a new one\r\n            if (block.number >= _setups[i].startBlock && block.number < _setups[i].endBlock) {\r\n                // the amount to add to the pinned is given by the difference between the reward per block and currently locked one\r\n                // in the case of a new setup, the currentRewardPerBlock is 0 so the difference is the whole rewardPerBlock\r\n                amount += _setups[i].rewardPerBlock - ((_setups[i].rewardPerBlock * (_setups[i].currentStakedLiquidity * 1e18 / _setups[i].maximumLiquidity)) / 1e18);\r\n            // this is a locked setup that has expired\r\n            } else if (block.number >= _setups[i].endBlock) {\r\n                _finishedLockedSetups[_setups[i].objectId] = true;\r\n                // check if the setup is renewable\r\n                if (_setups[i].renewTimes > 0) {\r\n                    _setups[i].renewTimes -= 1;\r\n                    // if it is, we renew it and add the reward per block\r\n                    _renewSetup(i);\r\n                    amount += _setups[i].rewardPerBlock;\r\n                }\r\n            }\r\n        }\r\n        if (_hasPinned && _setups[_pinnedSetupIndex].free) {\r\n            _setups[_pinnedSetupIndex].rewardPerBlock = _setups[_pinnedSetupIndex].currentRewardPerBlock;\r\n            _rebalanceRewardPerBlock(_pinnedSetupIndex, amount, true);\r\n        }\r\n    }\r\n\r\n    /** @dev function used to calculate the reward in a locked liquidity mining setup.\r\n      * @param setupIndex liquidity mining setup index.\r\n      * @param mainTokenAmount amount of main token.\r\n      * @param isPartial if we're calculating a partial reward.\r\n      * @param positionId id of the position (used for the partial reward).\r\n      * @return reward total reward for the liquidity mining position extension.\r\n      * @return relativeRewardPerBlock returned for the pinned free setup balancing.\r\n     */\r\n    function calculateLockedLiquidityMiningSetupReward(uint256 setupIndex, uint256 mainTokenAmount, bool isPartial, uint256 positionId) public view returns(uint256 reward, uint256 relativeRewardPerBlock) {\r\n        if (isPartial) {\r\n            // retrieve the position\r\n            LiquidityMiningPosition memory liquidityMiningPosition = _positions[positionId];\r\n            // calculate the reward\r\n            reward = (block.number >= liquidityMiningPosition.setupEndBlock) ? liquidityMiningPosition.reward : ((block.number - liquidityMiningPosition.creationBlock) * liquidityMiningPosition.lockedRewardPerBlock);\r\n        } else {\r\n            LiquidityMiningSetup memory setup = _setups[setupIndex];\r\n            // check if main token amount is less than the stakeable liquidity\r\n            require(mainTokenAmount <= setup.maximumLiquidity - setup.currentStakedLiquidity, \"Invalid liquidity\");\r\n            uint256 remainingBlocks = block.number > setup.endBlock ? 0 : setup.endBlock - block.number;\r\n            // get amount of remaining blocks\r\n            require(remainingBlocks > 0, \"Setup ended\");\r\n            // get total reward still available (= 0 if rewardPerBlock = 0)\r\n            require(setup.rewardPerBlock * remainingBlocks > 0, \"No rewards\");\r\n            // calculate relativeRewardPerBlock\r\n            relativeRewardPerBlock = (setup.rewardPerBlock * ((mainTokenAmount * 1e18) / setup.maximumLiquidity)) / 1e18;\r\n            // check if rewardPerBlock is greater than 0\r\n            require(relativeRewardPerBlock > 0, \"Invalid rpb\");\r\n            // calculate reward by multiplying relative reward per block and the remaining blocks\r\n            reward = relativeRewardPerBlock * remainingBlocks;\r\n            // check if the reward is still available\r\n        }\r\n    }\r\n\r\n    /** @dev function used to calculate the reward in a free liquidity mining setup.\r\n      * @param positionId liquidity mining position id.\r\n      * @return reward total reward for the liquidity mining position extension.\r\n     */\r\n    function calculateFreeLiquidityMiningSetupReward(uint256 positionId, bool isExt) public view returns(uint256 reward) {\r\n        LiquidityMiningPosition memory liquidityMiningPosition = _positions[positionId];\r\n        for (uint256 i = 0; i < _setupUpdateBlocks[liquidityMiningPosition.setupIndex].length; i++) {\r\n            if (liquidityMiningPosition.creationBlock < _setupUpdateBlocks[liquidityMiningPosition.setupIndex][i]) {\r\n                reward += (_rewardPerTokenPerSetupPerBlock[liquidityMiningPosition.setupIndex][_setupUpdateBlocks[liquidityMiningPosition.setupIndex][i]] * liquidityMiningPosition.liquidityPoolTokenAmount) / 1e18;\r\n            }\r\n        }\r\n        if (isExt) {\r\n            uint256 rpt = (((block.number - _setups[liquidityMiningPosition.setupIndex].lastBlockUpdate + 1) * _setups[liquidityMiningPosition.setupIndex].rewardPerBlock) * 1e18) / _setups[liquidityMiningPosition.setupIndex].totalSupply;\r\n            reward += (rpt * liquidityMiningPosition.liquidityPoolTokenAmount) / 1e18;\r\n        }\r\n    }\r\n\r\n    /** @dev returns the setup index for the given objectId.\r\n      * @param objectId farm token object id.\r\n      * @return setupIndex index of the setup.\r\n     */\r\n    function getObjectIdSetupIndex(uint256 objectId) public view returns (uint256 setupIndex) {\r\n        require(address(INativeV1(_liquidityFarmTokenCollection).asInteroperable(objectId)) != address(0), \"Invalid objectId\");\r\n        setupIndex = _objectIdSetup[objectId];\r\n    }\r\n\r\n    /** Private methods. */\r\n\r\n    /** @dev initializes the liquidity mining setups during the contract initialization.\r\n      * @param liquidityMiningSetupsBytes array of liquidity mining setups as bytes.\r\n      * @param setPinned if we are setting the pinned setup or not.\r\n      * @param pinnedIndex the pinned setup index.\r\n     */\r\n    function _initLiquidityMiningSetups(bytes memory liquidityMiningSetupsBytes, bool setPinned, uint256 pinnedIndex) private {\r\n        LiquidityMiningSetup[] memory liquidityMiningSetups = abi.decode(liquidityMiningSetupsBytes, (LiquidityMiningSetup[]));\r\n        require(liquidityMiningSetups.length > 0, \"Invalid length\");\r\n        for(uint256 i = 0; i < liquidityMiningSetups.length; i++) {\r\n            _setOrAddLiquidityMiningSetup(liquidityMiningSetups[i], true, 0);\r\n        }\r\n        _pinnedSetup(false, setPinned, pinnedIndex);\r\n        // rebalance the pinned setup\r\n        rebalancePinnedSetup();\r\n    }\r\n\r\n    /** @dev helper method that given a liquidity mining setup adds it to the _setups array or updates it.\r\n      * @param data new or updated liquidity mining setup.\r\n      * @param add if we are adding the setup or updating it.\r\n      * @param index liquidity mining setup index.\r\n     */\r\n    function _setOrAddLiquidityMiningSetup(LiquidityMiningSetup memory data, bool add, uint256 index) private {\r\n        LiquidityMiningSetup memory liquidityMiningSetup = add ? data : _setups[index];\r\n        require(\r\n            data.ammPlugin != address(0) &&\r\n            (\r\n                (data.free && data.liquidityPoolTokenAddress != address(0)) ||\r\n                (!data.free && data.liquidityPoolTokenAddress != address(0) && data.startBlock < data.endBlock)\r\n            ),\r\n            \"Invalid setup configuration\"\r\n        );\r\n        require(!add || liquidityMiningSetup.ammPlugin != address(0), \"Invalid setup index\");\r\n        address mainTokenAddress = add ? data.mainTokenAddress : liquidityMiningSetup.mainTokenAddress;\r\n        address ammPlugin = add ? data.ammPlugin : liquidityMiningSetup.ammPlugin;\r\n        (,,address[] memory tokenAddresses) = IAMM(ammPlugin).byLiquidityPool(data.liquidityPoolTokenAddress);\r\n        bool found = false;\r\n        for(uint256 z = 0; z < tokenAddresses.length; z++) {\r\n            if(tokenAddresses[z] == mainTokenAddress) {\r\n                found = true;\r\n            } else {\r\n                emit SetupToken(mainTokenAddress, tokenAddresses[z]);\r\n            }\r\n        }\r\n        require(found, \"No main token\");\r\n        if (add) {\r\n            data.totalSupply = 0;\r\n            data.currentRewardPerBlock = data.free ? data.rewardPerBlock : 0;\r\n            // adding new liquidity mining setup\r\n            _setups.push(data);\r\n        } else {\r\n            if (liquidityMiningSetup.free) {\r\n                // update free liquidity mining setup reward per block\r\n                if (data.rewardPerBlock - liquidityMiningSetup.rewardPerBlock < 0) {\r\n                    _rebalanceRewardPerBlock(index, liquidityMiningSetup.rewardPerBlock - data.rewardPerBlock, false);\r\n                } else {\r\n                    _rebalanceRewardPerBlock(index, data.rewardPerBlock - liquidityMiningSetup.rewardPerBlock, true);\r\n                }\r\n                _setups[index].rewardPerBlock = data.rewardPerBlock;\r\n                _setups[index].currentRewardPerBlock = data.rewardPerBlock;\r\n            } else {\r\n                // update locked liquidity mining setup\r\n                _setups[index].rewardPerBlock = data.rewardPerBlock;\r\n                _setups[index].renewTimes = data.renewTimes;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev helper function used to update or set the pinned free setup.\r\n      * @param clearPinned if we're clearing the pinned setup or not.\r\n      * @param setPinned if we're setting the pinned setup or not.\r\n      * @param pinnedIndex new pinned setup index.\r\n     */\r\n    function _pinnedSetup(bool clearPinned, bool setPinned, uint256 pinnedIndex) private {\r\n        // if we're clearing the pinned setup we must also remove the excess reward per block\r\n        if (clearPinned && _hasPinned) {\r\n            _hasPinned = false;\r\n            _rebalanceRewardPerToken(_pinnedSetupIndex, 0, false);\r\n            _setups[_pinnedSetupIndex].rewardPerBlock = _setups[_pinnedSetupIndex].currentRewardPerBlock;\r\n        }\r\n        // check if we're updating the pinned setup\r\n        if (!clearPinned && setPinned) {\r\n            require(_setups[pinnedIndex].free, \"Invalid pinned free setup\");\r\n            uint256 oldBalancedRewardPerBlock;\r\n            // check if we already have a free pinned setup\r\n            if (_hasPinned && _setups[_pinnedSetupIndex].free) {\r\n                // calculate the old balanced reward by subtracting from the current pinned reward per block the starting reward per block (aka currentRewardPerBlock)\r\n                oldBalancedRewardPerBlock = _setups[_pinnedSetupIndex].rewardPerBlock - _setups[_pinnedSetupIndex].currentRewardPerBlock;\r\n                // remove it from the current pinned setup\r\n                _rebalanceRewardPerBlock(_pinnedSetupIndex, oldBalancedRewardPerBlock, false);\r\n            }\r\n            // update pinned setup index\r\n            _hasPinned = true;\r\n            _pinnedSetupIndex = pinnedIndex;\r\n        }\r\n    }\r\n\r\n    /** @dev this function performs the transfer of the tokens that will be staked, interacting with the AMM plugin.\r\n      * @param setup the chosen setup.\r\n      * @param request new open position request.\r\n      * @return amm AMM plugin interface.\r\n      * @return liquidityPoolAmount amount of liquidity pool token.\r\n      * @return mainTokenAmount amount of main token staked.\r\n      * @return involvingETH if the inputed flag is consistent.\r\n     */\r\n    function _transferToMeAndCheckAllowance(LiquidityMiningSetup memory setup, LiquidityMiningPositionRequest memory request) private returns(IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount, bool involvingETH) {\r\n        require(request.amount > 0, \"No amount\");\r\n        involvingETH = request.amountIsLiquidityPool && setup.involvingETH;\r\n        // retrieve the values\r\n        amm = IAMM(setup.ammPlugin);\r\n        liquidityPoolAmount = request.amountIsLiquidityPool ? request.amount : 0;\r\n        mainTokenAmount = request.amountIsLiquidityPool ? 0 : request.amount;\r\n        address[] memory tokens;\r\n        uint256[] memory tokenAmounts;\r\n        // if liquidity pool token amount is provided, the position is opened by liquidity pool token amount\r\n        if(request.amountIsLiquidityPool) {\r\n            _safeTransferFrom(setup.liquidityPoolTokenAddress, msg.sender, address(this), liquidityPoolAmount);\r\n            (tokenAmounts, tokens) = amm.byLiquidityPoolAmount(setup.liquidityPoolTokenAddress, liquidityPoolAmount);\r\n        } else {\r\n            // else it is opened by the tokens amounts\r\n            (liquidityPoolAmount, tokenAmounts, tokens) = amm.byTokenAmount(setup.liquidityPoolTokenAddress, setup.mainTokenAddress, mainTokenAmount);\r\n        }\r\n\r\n        // check if the eth is involved in the request\r\n        address ethAddress = address(0); \r\n        if(setup.involvingETH) {\r\n            (ethAddress,,) = amm.data();\r\n        }\r\n        // iterate the tokens and perform the transferFrom and the approve\r\n        for(uint256 i = 0; i < tokens.length; i++) {\r\n            if(tokens[i] == setup.mainTokenAddress) {\r\n                mainTokenAmount = tokenAmounts[i];\r\n                if(request.amountIsLiquidityPool) {\r\n                    break;\r\n                }\r\n            }\r\n            if(request.amountIsLiquidityPool) {\r\n                continue;\r\n            }\r\n            if(setup.involvingETH && ethAddress == tokens[i]) {\r\n                involvingETH = true;\r\n                require(msg.value == tokenAmounts[i], \"Incorrect eth value\");\r\n            } else {\r\n                _safeTransferFrom(tokens[i], msg.sender, address(this), tokenAmounts[i]);\r\n                _safeApprove(tokens[i], setup.ammPlugin, tokenAmounts[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev mints a new PositionToken inside the collection for the given wallet.\r\n      * @param uniqueOwner liquidityMiningPosition token extension.\r\n      * @param amount amount of to mint for a farm token.\r\n      * @param setupIndex index of the setup.\r\n      * @return objectId new liquidityMiningPosition token object id.\r\n     */\r\n    function _mintLiquidity(address uniqueOwner, uint256 amount, uint256 setupIndex) private returns(uint256 objectId) {\r\n        if (_setups[setupIndex].objectId == 0) {\r\n            (objectId,) = INativeV1(_liquidityFarmTokenCollection).mint(amount, string(abi.encodePacked(\"Farming LP \", _toString(_setups[setupIndex].liquidityPoolTokenAddress))), \"fLP\", ILiquidityMiningFactory(_factory).getLiquidityFarmTokenURI(), true);\r\n            emit FarmToken(objectId, _setups[setupIndex].liquidityPoolTokenAddress, setupIndex, _setups[setupIndex].endBlock);\r\n            _objectIdSetup[objectId] = setupIndex;\r\n            _setups[setupIndex].objectId = objectId;\r\n        } else {\r\n            INativeV1(_liquidityFarmTokenCollection).mint(_setups[setupIndex].objectId, amount);\r\n        }\r\n        INativeV1(_liquidityFarmTokenCollection).safeTransferFrom(address(this), uniqueOwner, _setups[setupIndex].objectId, amount, \"\");\r\n    }\r\n\r\n    function _toString(address _addr) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\r\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    /** @dev burns a farm token from the collection.\r\n      * @param objectId object id where to burn liquidity.\r\n      * @param amount amount of liquidity to burn.\r\n      */\r\n    function _burnLiquidity(uint256 objectId, uint256 amount) private {\r\n        INativeV1 tokenCollection = INativeV1(_liquidityFarmTokenCollection);\r\n        // transfer the liquidity mining farm token to this contract\r\n        tokenCollection.safeTransferFrom(msg.sender, address(this), objectId, amount, \"\");\r\n        // burn the liquidity mining farm token\r\n        tokenCollection.burn(objectId, amount);\r\n    }\r\n\r\n    /** @dev helper function used to remove liquidity from a free position or to burn item liquidity tokens and retrieve their content.\r\n      * @param positionId id of the position.\r\n      * @param objectId object id related to the item liquidity tokens to burn.\r\n      * @param setupIndex index of the setup related to the item liquidity tokens.\r\n      * @param unwrapPair whether to unwrap the liquidity pool tokens or not.\r\n      * @param isUnlock if we're removing liquidity from an unlock method or not.\r\n     */\r\n    function _removeLiquidity(uint256 positionId, uint256 objectId, uint256 setupIndex, bool unwrapPair, uint256 removedLiquidity, bool isUnlock) private {\r\n        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\r\n        LiquidityPoolData memory lpData = LiquidityPoolData(\r\n            _setups[setupIndex].liquidityPoolTokenAddress,\r\n            removedLiquidity,\r\n            _setups[setupIndex].mainTokenAddress,\r\n            true,\r\n            _setups[setupIndex].involvingETH,\r\n            msg.sender\r\n        );\r\n        uint256 remainingLiquidity;\r\n        // we are removing liquidity using the setup items\r\n        if (liquidityMiningPosition.free && positionId != 0) {\r\n            // update the setup index\r\n            setupIndex = liquidityMiningPosition.setupIndex;\r\n            remainingLiquidity = liquidityMiningPosition.liquidityPoolTokenAmount - removedLiquidity;\r\n        }\r\n        // retrieve fee stuff\r\n        (uint256 exitFeePercentage, address exitFeeWallet) = ILiquidityMiningFactory(_factory).feePercentageInfo();\r\n        // pay the fees!\r\n        if (exitFeePercentage > 0) {\r\n            uint256 fee = (lpData.amount * ((exitFeePercentage * 1e18) / ONE_HUNDRED)) / 1e18;\r\n            _safeTransfer(_setups[setupIndex].liquidityPoolTokenAddress, exitFeeWallet, fee);\r\n            lpData.amount = lpData.amount - fee;\r\n        }\r\n        // check if the user wants to unwrap its pair or not\r\n        if (unwrapPair) {\r\n            // remove liquidity using AMM\r\n            address ammPlugin = _setups[setupIndex].ammPlugin;\r\n            _safeApprove(lpData.liquidityPoolAddress, ammPlugin, lpData.amount);\r\n            (, uint256[] memory amounts, address[] memory tokens) = IAMM(ammPlugin).removeLiquidity(lpData);\r\n            if (isUnlock) {\r\n                for (uint256 i = 0; i < tokens.length; i++) {\r\n                    if (tokens[i] == _setups[setupIndex].mainTokenAddress) {\r\n                        _setups[setupIndex].currentStakedLiquidity -= amounts[0];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // send back the liquidity pool token amount without the fee\r\n            _safeTransfer(lpData.liquidityPoolAddress, lpData.receiver, lpData.amount);\r\n        }\r\n        // rebalance the setup if not free\r\n        if (!_setups[setupIndex].free && !_finishedLockedSetups[objectId]) {\r\n            // check if the setup has been updated or not\r\n            if (objectId == _setups[setupIndex].objectId) {\r\n                // check if it's finished (this is a withdraw) or not (a unlock)\r\n                if (!isUnlock) {\r\n                    // the locked setup must be considered finished only if it's not renewable\r\n                    _finishedLockedSetups[objectId] = true;\r\n                    if (_hasPinned && _setups[_pinnedSetupIndex].free) {\r\n                        _rebalanceRewardPerBlock(\r\n                            _pinnedSetupIndex, \r\n                            _setups[setupIndex].rewardPerBlock - ((_setups[setupIndex].rewardPerBlock * (_setups[setupIndex].currentStakedLiquidity * 1e18 / _setups[setupIndex].maximumLiquidity)) / 1e18),\r\n                            false\r\n                        );\r\n                    }\r\n                    if (_setups[setupIndex].renewTimes > 0) {\r\n                        _setups[setupIndex].renewTimes -= 1;\r\n                        // renew the setup if renewable\r\n                        _renewSetup(setupIndex);\r\n                    }\r\n                } else {\r\n                    // this is an unlock, so we just need to provide back the reward per block\r\n                    if (_hasPinned && _setups[_pinnedSetupIndex].free) {\r\n                        _rebalanceRewardPerBlock(\r\n                            _pinnedSetupIndex, \r\n                            _setups[setupIndex].rewardPerBlock * ((removedLiquidity * 1e18 / _setups[setupIndex].maximumLiquidity) / 1e18), \r\n                            true\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (liquidityMiningPosition.free && positionId != 0) {\r\n            // delete the liquidity mining position after the withdraw\r\n            if (remainingLiquidity == 0) {\r\n                _positions[positionId] = _positions[0x0];\r\n            } else {\r\n                // update the creation block and amount\r\n                liquidityMiningPosition.creationBlock = block.number;\r\n                liquidityMiningPosition.liquidityPoolTokenAmount = remainingLiquidity;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev Renews the setup with the given index.\r\n      * @param setupIndex index of the setup to renew.\r\n     */\r\n    function _renewSetup(uint256 setupIndex) private {\r\n        uint256 duration = _setups[setupIndex].endBlock - _setups[setupIndex].startBlock;\r\n        _setups[setupIndex].startBlock = block.number + 1;\r\n        _setups[setupIndex].endBlock = block.number + 1 + duration;\r\n        _setups[setupIndex].currentRewardPerBlock = 0;\r\n        _setups[setupIndex].currentStakedLiquidity = 0;\r\n        _setups[setupIndex].objectId = 0;\r\n    }\r\n\r\n    /** @dev function used to rebalance the reward per block in the given free liquidity mining setup.\r\n      * @param setupIndex setup to rebalance.\r\n      * @param lockedRewardPerBlock new liquidity mining position locked reward per block that must be subtracted from the given free liquidity mining setup reward per block.\r\n      * @param fromExit if the rebalance is caused by an exit from the locked liquidity mining position or not.\r\n      */\r\n    function _rebalanceRewardPerBlock(uint256 setupIndex, uint256 lockedRewardPerBlock, bool fromExit) private {\r\n        LiquidityMiningSetup storage setup = _setups[setupIndex];\r\n        _rebalanceRewardPerToken(setupIndex, 0, fromExit);\r\n        fromExit ? setup.rewardPerBlock += lockedRewardPerBlock : setup.rewardPerBlock -= lockedRewardPerBlock;\r\n    }\r\n\r\n    /** @dev function used to rebalance the reward per token in a free liquidity mining setup.\r\n      * @param setupIndex index of the setup to rebalance.\r\n      * @param liquidityPoolTokenAmount amount of liquidity pool token being added.\r\n      * @param fromExit if the rebalance is caused by an exit from the free liquidity mining position or not.\r\n     */\r\n    function _rebalanceRewardPerToken(uint256 setupIndex, uint256 liquidityPoolTokenAmount, bool fromExit) private {\r\n        LiquidityMiningSetup storage setup = _setups[setupIndex];\r\n        if(setup.lastBlockUpdate > 0 && setup.totalSupply > 0) {\r\n            // add the block to the setup update blocks\r\n            _setupUpdateBlocks[setupIndex].push(block.number);\r\n            // update the reward token\r\n            _rewardPerTokenPerSetupPerBlock[setupIndex][block.number] = (((block.number - setup.lastBlockUpdate) * setup.rewardPerBlock) * 1e18) / setup.totalSupply;\r\n        }\r\n        // update the last block update variable\r\n        setup.lastBlockUpdate = block.number;\r\n        // update total supply in the setup AFTER the reward calculation - to let previous liquidity mining position holders to calculate the correct value\r\n        fromExit ? setup.totalSupply -= liquidityPoolTokenAmount : setup.totalSupply += liquidityPoolTokenAmount;\r\n    }\r\n\r\n    /** @dev function used to safely approve ERC20 transfers.\r\n      * @param erc20TokenAddress address of the token to approve.\r\n      * @param to receiver of the approval.\r\n      * @param value amount to approve for.\r\n     */\r\n    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal virtual {\r\n        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\r\n    }\r\n\r\n    /** @dev function used to safe transfer ERC20 tokens.\r\n      * @param erc20TokenAddress address of the token to transfer.\r\n      * @param to receiver of the tokens.\r\n      * @param value amount of tokens to transfer.\r\n     */\r\n    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal virtual {\r\n        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\r\n    }\r\n\r\n    /** @dev this function safely transfers the given ERC20 value from an address to another.\r\n      * @param erc20TokenAddress erc20 token address.\r\n      * @param from address from.\r\n      * @param to address to.\r\n      * @param value amount to transfer.\r\n     */\r\n    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) private {\r\n        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\r\n    }\r\n\r\n    /** @dev calls the contract at the given location using the given payload and returns the returnData.\r\n      * @param location location to call.\r\n      * @param payload call payload.\r\n      * @return returnData call return data.\r\n     */\r\n    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\r\n        assembly {\r\n            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\r\n            let size := returndatasize()\r\n            returnData := mload(0x40)\r\n            mstore(returnData, size)\r\n            let returnDataPayloadStart := add(returnData, 0x20)\r\n            returndatacopy(returnDataPayloadStart, 0, size)\r\n            mstore(0x40, add(returnDataPayloadStart, size))\r\n            switch result case 0 {revert(returnDataPayloadStart, size)}\r\n        }\r\n    }\r\n\r\n    /** @dev function used to receive batch of erc1155 tokens. */\r\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public view override returns(bytes4) {\r\n        require(_liquidityFarmTokenCollection == msg.sender, \"Invalid sender\");\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    /** @dev function used to receive erc1155 tokens. */\r\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public view override returns(bytes4) {\r\n        require(_liquidityFarmTokenCollection == msg.sender, \"Invalid sender\");\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityPoolToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"}],\"name\":\"FarmToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"}],\"name\":\"RewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mainToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"involvedToken\",\"type\":\"address\"}],\"name\":\"SetupToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ONE_HUNDRED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_extension\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_finishedLockedSetups\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_hasPinned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityFarmTokenCollection\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_partiallyRedeemed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pinnedSetupIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_positionRedeemed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_positions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"uniqueOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setupStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setupEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"free\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidityPoolTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedRewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_rewardPerTokenPerSetupPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_setupUpdateBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"amountIsLiquidityPool\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"positionOwner\",\"type\":\"address\"}],\"internalType\":\"struct LiquidityMiningPositionRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExt\",\"type\":\"bool\"}],\"name\":\"calculateFreeLiquidityMiningSetupReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mainTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPartial\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"calculateLockedLiquidityMiningSetupReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relativeRewardPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"}],\"name\":\"getObjectIdSetupIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extensionInitData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"orchestrator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"liquidityMiningSetupsBytes\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"setPinned\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pinnedIndex\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"extensionReturnCall\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"amountIsLiquidityPool\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"positionOwner\",\"type\":\"address\"}],\"internalType\":\"struct LiquidityMiningPositionRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"openPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"position\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"uniqueOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setupStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setupEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"free\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidityPoolTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedRewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct LiquidityMiningPosition\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalancePinnedSetup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ammPlugin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"liquidityPoolTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mainTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentRewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlockUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentStakedLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"free\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"renewTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"involvingETH\",\"type\":\"bool\"}],\"internalType\":\"struct LiquidityMiningSetup\",\"name\":\"data\",\"type\":\"tuple\"}],\"internalType\":\"struct LiquidityMiningSetupConfiguration[]\",\"name\":\"liquidityMiningSetups\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"clearPinned\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"setPinned\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pinnedIndex\",\"type\":\"uint256\"}],\"name\":\"setLiquidityMiningSetups\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setups\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"ammPlugin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"liquidityPoolTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mainTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentRewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlockUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentStakedLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"free\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"renewTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"involvingETH\",\"type\":\"bool\"}],\"internalType\":\"struct LiquidityMiningSetup[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrapPair\",\"type\":\"bool\"}],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrapPair\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"removedLiquidity\",\"type\":\"uint256\"}],\"name\":\"withdrawLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LiquidityMining","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://860bca02a08f66d46dd62ea69dca13730448e1901cd41b2d832d2534ba632b44"}]}