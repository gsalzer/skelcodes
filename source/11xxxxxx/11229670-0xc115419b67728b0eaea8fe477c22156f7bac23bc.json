{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\n/// 必须是owners发起取款，auditor进行确认\r\n/// 一个合约最多支持10000人\r\n// MvpLockedWallet\r\ncontract MultiSigWalletV3 {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event TransactionNotAllowed(address indexed destination);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event BalanceNotEnough(address indexed owner, uint indexed withdrawValue, uint indexed balance);\r\n    event BalanceAddition(address indexed owner, uint indexed changeValue, uint indexed balance);\r\n    event BalanceSubtraction(address indexed owner, uint indexed changeValue, uint indexed balance);\r\n\r\n    uint constant public MAX_OWNER_COUNT = 100000000;\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping(uint => Transaction) public transactions;\r\n    mapping(uint => mapping(address => bool)) public confirmations;\r\n    mapping(address => bool) public isOwner;\r\n    mapping(address => uint) public tokenBalance;\r\n    address[] public owners;\r\n    address public auditor;\r\n    address public contractAddress;\r\n    uint public transactionCount;\r\n    // for web use\r\n    uint public required = 2;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n        bool multiSig;\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier onlyWallet() {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        require(!isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        require(transactions[transactionId].destination != 0);\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        require(!confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != 0);\r\n        _;\r\n    }\r\n\r\n    modifier validAuditor(address _address) {\r\n        require(_address != 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n    public\r\n    payable\r\n    {\r\n        if (msg.value > 0)\r\n            emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners.\r\n    /// @param _owners List of initial owners.\r\n    constructor(address _auditor, address[] _owners, address _contractAddress)\r\n    public\r\n    validAuditor(_auditor)\r\n    {\r\n        for (uint i = 0; i < _owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\r\n            isOwner[_owners[i]] = true;\r\n            tokenBalance[_owners[i]] = 0;\r\n        }\r\n        owners = _owners;\r\n        auditor = _auditor;\r\n        contractAddress = _contractAddress;\r\n    }\r\n\r\n    function bytesToUint(bytes b)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 number;\r\n        for (uint i = 0; i < b.length; i++) {\r\n            number = number + uint(b[i]) * (2 ** (8 * (b.length - (i + 1))));\r\n        }\r\n        return number;\r\n    }\r\n\r\n    /// GET balance of owner\r\n    function getBalance(address owner)\r\n    public\r\n    view\r\n    ownerExists(owner)\r\n    returns (uint)\r\n    {\r\n        return tokenBalance[owner];\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n    public\r\n    returns (uint transactionId)\r\n    {\r\n        if (destination != contractAddress && destination != address(this)) {\r\n            emit TransactionNotAllowed(destination);\r\n            return;\r\n        }\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    transactionExists(transactionId)\r\n    notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    confirmed(transactionId, msg.sender)\r\n    notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    confirmed(transactionId, msg.sender)\r\n    notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data)) {\r\n                // contract transfer\r\n                if (txn.destination == contractAddress) {\r\n                    (bool isTransfer, address to, uint v) = decodeTransferData(txn.data);\r\n                    if (isTransfer) {\r\n                        if (address(this) != to) {// transfer to lock address\r\n                            tokenBalance[to] = tokenBalance[to] - v;\r\n                            emit BalanceSubtraction(to, v, tokenBalance[to]);\r\n                        }\r\n                    }\r\n                    (bool isTransferFrom,  address from2, address to2, uint v2) = decodeTransferFromData(txn.data);\r\n                    if (isTransferFrom && address(this) == to2) {\r\n                        tokenBalance[from2] = tokenBalance[from2] + v2;\r\n                        emit BalanceAddition(from2, v2, tokenBalance[from2]);\r\n                        if (!isOwner[from2] && msg.sender == auditor) {\r\n                            // it is not owner add it\r\n                            isOwner[from2] = true;\r\n                            owners.push(from2);\r\n                            emit OwnerAddition(from2);\r\n                        }\r\n                    }\r\n                }\r\n                emit Execution(transactionId);\r\n            } else {\r\n                emit ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function decodeMethod(bytes data)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        if (data .length > 4) {\r\n            bytes memory method = new bytes(4);\r\n            for (uint j = 0; j < 4; j++) {\r\n                method[j] = data[j];\r\n            }\r\n            return bytesToUint(method);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function decodeTransferData(bytes data)\r\n    internal\r\n    pure\r\n    returns (bool isTransfer, address to, uint v)\r\n    {\r\n        if (data.length >= 36) {\r\n            uint256 iMethod = decodeMethod(data);\r\n            if (iMethod == 2835717307) {// Transfer\r\n                bytes memory toAddress = new bytes(20);\r\n                for (uint k = 16; k < 36; k++) {\r\n                    toAddress[k - 16] = data[k];\r\n                }\r\n                to = address(bytesToUint(toAddress));\r\n                bytes memory value = new bytes(20);\r\n                for (k = 48; k < 68; k++) {\r\n                    value[k - 48] = data[k];\r\n                }\r\n                v = bytesToUint(value);\r\n                isTransfer = true;\r\n            } else {\r\n                isTransfer = false;\r\n            }\r\n        } else {\r\n            isTransfer = false;\r\n        }\r\n    }\r\n\r\n    function decodeTransferFromData(bytes data)\r\n    internal\r\n    pure\r\n    returns (bool isTransferFrom, address from, address to, uint v)\r\n    {\r\n        if (data.length >= 100) {\r\n            uint256 iMethod = decodeMethod(data);\r\n            if (iMethod == 599290589) {// TransferFrom\r\n                bytes memory fromAddress = new bytes(20);\r\n                for (uint k = 16; k < 36; k++) {\r\n                    fromAddress[k - 16] = data[k];\r\n                }\r\n                from = address(bytesToUint(fromAddress));\r\n                bytes memory toAddress = new bytes(20);\r\n                for (k = 48; k < 68; k++) {\r\n                    toAddress[k - 48] = data[k];\r\n                }\r\n                to = address(bytesToUint(toAddress));\r\n                bytes memory value = new bytes(20);\r\n                for (k = 80; k < 100; k++) {\r\n                    value[k - 80] = data[k];\r\n                }\r\n                v = bytesToUint(value);\r\n                isTransferFrom = true;\r\n            } else {\r\n                isTransferFrom = false;\r\n            }\r\n        } else {\r\n            isTransferFrom = false;\r\n        }\r\n    }\r\n\r\n    // call has been separated into its own function in order to take advantage\r\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n    function external_call(address destination, uint value, uint dataLength, bytes data)\r\n    internal\r\n    returns (bool)\r\n    {\r\n        bool result;\r\n        assembly {\r\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n            sub(gas, 34710), // 34710 is the value that solidity is currently emitting\r\n            // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n            // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n            destination,\r\n            value,\r\n            d,\r\n            dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\r\n            x,\r\n            0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n    public\r\n    returns (bool)\r\n    {\r\n        Transaction storage txn = transactions[transactionId];\r\n        (bool isTransfer, address to, uint v) = decodeTransferData(txn.data);\r\n        if (!transactions[transactionId].multiSig) {\r\n            if (txn.destination == contractAddress) {\r\n                if (isTransfer) {\r\n                    to;\r\n                    v;\r\n                    return true;\r\n                }\r\n                (bool isTransferFrom,  address from2, address to2, uint v2) = decodeTransferFromData(txn.data);\r\n                if (isTransferFrom) {\r\n                    from2;\r\n                    to2;\r\n                    v2;\r\n                    return true;\r\n                }\r\n            }\r\n            if (msg.sender == auditor) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (txn.destination == contractAddress) {\r\n                // withdraw check balance if transfer to other address from contract address\r\n                if (isTransfer && to != address(this)) {\r\n                    if (v > tokenBalance[to]) {\r\n                        emit BalanceNotEnough(to, v, tokenBalance[to]);\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            uint count = 0;\r\n            for (uint i = 0; i < owners.length; i++) {\r\n                if (confirmations[transactionId][owners[i]])\r\n                    count += 1;\r\n            }\r\n            if (count >= 2 && msg.sender == auditor) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n    internal\r\n    notNull(destination)\r\n    returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        Transaction memory txn = Transaction({\r\n            destination : destination,\r\n            value : value,\r\n            data : data,\r\n            executed : false,\r\n            multiSig : true\r\n            });\r\n\r\n        // if the method is add remove replace and change daily not need multi sig\r\n        uint256 iMethod = decodeMethod(data);\r\n        // check method\r\n        if (iMethod == 1885719368) {// add owner\r\n            txn.multiSig = false;\r\n        }\r\n        if (destination == contractAddress) {\r\n            (bool isTransfer, address to, uint v) = decodeTransferData(data);\r\n            if (isTransfer) {\r\n                // not need multiSig if to contract\r\n                if (address(this) == to) {\r\n                    txn.multiSig = false;\r\n                    v;\r\n                }\r\n            }\r\n            (bool isTransferFrom,  address from2, address to2, uint v2) = decodeTransferFromData(data);\r\n            if (isTransferFrom) {\r\n                // not need multiSig if to contract\r\n                if (address(this) == to2) {\r\n                    txn.multiSig = false;\r\n                    from2;\r\n                    v2;\r\n                }\r\n            }\r\n        }\r\n        transactions[transactionId] = txn;\r\n        transactionCount += 1;\r\n        emit Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n    {\r\n        for (uint i = 0; i < owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n    {\r\n        for (uint i = 0; i < transactionCount; i++)\r\n            if (pending && !transactions[i].executed\r\n            || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n    public\r\n    constant\r\n    returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n    public\r\n    constant\r\n    returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i = 0; i < owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i = 0; i < count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i = 0; i < transactionCount; i++)\r\n            if (pending && !transactions[i].executed\r\n            || executed && transactions[i].executed) {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i = from; i < to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"bytesToUint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"confirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auditor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"multiSig\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionIds\",\"outputs\":[{\"name\":\"_transactionIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"name\":\"_confirmations\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_auditor\",\"type\":\"address\"},{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Submission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"TransactionNotAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"withdrawValue\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"BalanceNotEnough\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"changeValue\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"BalanceAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"changeValue\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"BalanceSubtraction\",\"type\":\"event\"}]","ContractName":"MultiSigWalletV3","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000057aba82d9ed8dbdcb64515426e1d0dbb5dac43a30000000000000000000000000000000000000000000000000000000000000060000000000000000000000000432a2c54de2dde941a36d2eb8c424ed666f74aef000000000000000000000000000000000000000000000000000000000000000100000000000000000000000057aba82d9ed8dbdcb64515426e1d0dbb5dac43a3","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d91c8e83d99a793c485d411f201ea711a7bd7785a5374791a2c657a6a71063e5"}]}