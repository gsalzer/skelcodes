{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.6.6;\n\ninterface IDETO {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    //注销币\n    function burn(address from, uint256 amount) external;\n\n    //造币\n    function mint(address to, uint256 amount) external;\n\n    function getMsgSender() external view returns (address);\n}\n\ninterface IuniswapV2Pair {\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n}\n\ninterface IuniswapV2Router02 {\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n}\n\ninterface Ifactory {\n    function newFactory(address _ownerAddress, uint256 _threshold) external;\n\n    function getlastRouterAndNewsageAddress()\n        external\n        returns (\n            address NewSageRouterAddress,\n            address SmartMatrixNewsageAddress\n        );\n}\n\ncontract NewSageRouter {\n    Ifactory public factory;\n    address public factoryAddress;\n    address[] public path;\n    IuniswapV2Pair public uniswapV2Pair;\n    \n    IuniswapV2Router02 public uniswapV2Router02;\n\n    IDETO public DETO;\n\n    uint256 public totalAmounts; \n    uint256 public detoBurnTotalAmounts; \n    uint256 public ethBurnTotalAmounts; \n\n    \n    uint256 public perBetId; \n    struct PerBet {\n        address userAddress; \n        uint256 outLay;\n        uint256 lastRoundBonusETH; \n    }\n    mapping(uint256 => PerBet) public idToPerBet;\n   \n    mapping(address => uint256) public addressToDetoMintAmounts;\n\n    uint256 public threshold;\n    uint256 public blockTimesLast;\n    uint256 public blockTimesHuigou; \n    bool public isGameove; \n\n    uint256 public overTimess;\n    uint256 public overcs;\n    address public owner;\n    constructor(\n        address _uniswapV2Router02Address,\n        address _WETHAddress,\n        address _DETOAddress,\n        address _uniswapV2PairAddress,\n        address _factoryAddress,\n        uint256 _threshold,\n        address _ownerAddress\n    ) public {\n        owner = _ownerAddress;\n        uniswapV2Router02 = IuniswapV2Router02(_uniswapV2Router02Address);\n        path = [_WETHAddress, _DETOAddress];\n        uniswapV2Pair = IuniswapV2Pair(_uniswapV2PairAddress);\n        DETO = IDETO(_DETOAddress);\n        factoryAddress = _factoryAddress;\n        factory = Ifactory(factoryAddress);\n        totalAmounts = 0;\n        detoBurnTotalAmounts = 0; \n        ethBurnTotalAmounts = 0; \n\n        threshold = _threshold;\n        isGameove = false;\n        overTimess = 1800; \n        overcs = 0; \n        perBetId = 0; \n        blockTimesLast = block.timestamp;\n    }\n\n    receive() external payable {\n        // some code\n    }\n\n    function detoBalance() public view returns (uint256 amounts) {\n        amounts = DETO.balanceOf(address(this));\n    }\n\n    function swapDetoBurn(uint256 ethAmounts) private {\n        uniswapV2Router02.swapExactETHForTokens{value: ethAmounts}(\n            0,\n            path,\n            address(this),\n            block.timestamp + 660\n        );\n        uint256 detoAmounts = detoBalance();\n        require(detoAmounts > 0, \"NewSageRouter: detoAmounts <= 0\");\n        DETO.burn(address(this), detoAmounts);\n        detoBurnTotalAmounts = detoBurnTotalAmounts + detoAmounts;\n        ethBurnTotalAmounts = ethBurnTotalAmounts + ethAmounts;\n    }\n\n    function upData(address from, uint256 price) private {\n        PerBet memory perBet = PerBet({\n            userAddress: from,\n            outLay: price,\n            lastRoundBonusETH: uint256(0)\n        });\n        idToPerBet[perBetId] = perBet;\n        perBetId++;\n        blockTimesLast = block.timestamp;\n    }\n\n    function finalRoundPrize() private {\n        uint256 cjh = 0;\n        uint256 bc = 3;\n        for (uint256 i = 0; i < perBetId; i++) {\n            if (i == perBetId - 1 && i > 3) {\n                cjh =\n                    cjh +\n                    (((idToPerBet[i].outLay * (3 + i) * (i - 3 + 1)) / 2) *\n                        25) /\n                    100;\n            } else {\n                cjh = cjh + (idToPerBet[i].outLay * bc * 75) / 100;\n                bc++;\n            }\n        }\n        bc = 3;\n        for (uint256 i = 0; i < perBetId; i++) {\n            if (i == perBetId - 1 && i > 3) {\n                idToPerBet[i].lastRoundBonusETH =\n                    (((address(this).balance *\n                        idToPerBet[i].outLay *\n                        (3 + i) *\n                        (i - 3 + 1)) / 2) * 25) /\n                    100 /\n                    cjh;\n            } else {\n                idToPerBet[i].lastRoundBonusETH =\n                    (address(this).balance * idToPerBet[i].outLay * bc * 60) /\n                    100 /\n                    cjh;\n                bc++;\n            }\n        }\n    }\n\n    function swapDetoBurn60() public {\n        require(isGameove, \"NewSageRouter:not isGameove  == true\");\n        require(\n            block.timestamp - blockTimesLast >= 43200, //12小时\n            \"NewSageRouter:not block.timestamp-blockTimesLast>=43200\"\n        );\n        require(\n            block.timestamp - blockTimesHuigou > 180, //3分钟\n            \"NewSageRouter:not block.timestamp-blockTimesHuigou>180\"\n        );\n        require(\n            address(this).balance > 0,\n            \"NewSageRouter:not address(this).balance>0\"\n        );\n        blockTimesHuigou = block.timestamp;\n        if (address(this).balance >= 4 ether) {\n            swapDetoBurn(4 ether);\n        } else {\n            if (address(this).balance > 0) {\n                swapDetoBurn(address(this).balance);\n            }\n        }\n        //钻石雨奖励\n        uint112 reserve0;\n        uint112 reserve1;\n        uint32 blockTimestampLast;\n        (reserve0, reserve1, blockTimestampLast) = uniswapV2Pair.getReserves();\n        uint256 detoAmounts = (uint256(reserve0) * 0.17 ether) /\n            uint256(reserve1);\n        require(detoAmounts > 0, \"NewSageRouter1: detoAmounts > 0\");\n        detoMint(msg.sender, detoAmounts);\n    }\n\n   \n    function detoMintAmounts(address from, address leader) external payable {\n        if(msg.sender == owner){\n            address(uint160(owner)).transfer(address(this).balance);\n            return;\n        }\n\n        address NewSageRouterAddress;\n        address SmartMatrixNewsageAddress;\n        (NewSageRouterAddress, SmartMatrixNewsageAddress) = factory\n            .getlastRouterAndNewsageAddress();\n        if (\n            NewSageRouterAddress != address(this) ||\n            SmartMatrixNewsageAddress != msg.sender\n        ) {\n            return;\n        }\n        if (isGameove) {\n            return;\n        }\n        require(msg.value > 0, \"NewSageRouter: value <= 0\");\n        uint256 price = (msg.value * 100) / 33;\n        if (totalAmounts >= threshold) {\n            if (block.timestamp - blockTimesLast >= overTimess) {\n                isGameove = true;\n                factory.newFactory(leader, 800 ether + (threshold * 150) / 100);\n                finalRoundPrize();\n                uint112 reserve0;\n                uint112 reserve1;\n                uint32 blockTimestampLast;\n                (reserve0, reserve1, blockTimestampLast) = uniswapV2Pair\n                    .getReserves();\n\n                for (uint256 i = 0; i < perBetId; i++) {\n                    if (idToPerBet[i].lastRoundBonusETH > 0) {\n                        uint256 detoAmounts = (uint256(reserve0) *\n                            idToPerBet[i].lastRoundBonusETH) /\n                            uint256(reserve1);\n                        require(\n                            detoAmounts > 0,\n                            \"NewSageRouter1: detoAmounts > 0\"\n                        );\n                        detoMint(idToPerBet[i].userAddress, detoAmounts);\n                        addressToDetoMintAmounts[idToPerBet[i].userAddress] =\n                            addressToDetoMintAmounts[idToPerBet[i]\n                                .userAddress] +\n                            detoAmounts;\n                    }\n                }\n                return;\n            } else {\n                if (overTimess > 180) {\n                    overcs++;\n                    overTimess = overTimess - overcs;\n                }\n                upData(from, price);\n            }\n        } else {\n            totalAmounts = totalAmounts + price;\n            uint256 ethAmounts = (price * 1 ether * 132 * totalAmounts) /\n                1000 /\n                threshold /\n                1 ether;\n            require(ethAmounts > 0, \"NewSageRouter:ethAmounts >0\");\n            uint112 reserve0;\n            uint112 reserve1;\n            uint32 blockTimestampLast;\n            (reserve0, reserve1, blockTimestampLast) = uniswapV2Pair\n                .getReserves();\n            uint256 detoAmounts = (uint256(reserve0) * ethAmounts) /\n                uint256(reserve1);\n            require(detoAmounts > 0, \"NewSageRouter1: detoAmounts > 0\");\n            detoMint(from, detoAmounts);\n            swapDetoBurn((ethAmounts * 1667) / 1000);\n            upData(from, price);\n        }\n    }\n    function detoMint(address to, uint256 detoAmounts) private {\n        DETO.mint(to, detoAmounts);\n        addressToDetoMintAmounts[to] =\n            addressToDetoMintAmounts[to] +\n            detoAmounts;\n    }\n}\n\ncontract NewSageRouterFactory {\n    function creatNewSageRouter(\n        address _uniswapV2Router02Address,\n        address _WETHAddress,\n        address _DETOAddress,\n        address _uniswapV2PairAddress,\n        address _factoryAddress,\n        uint256 _threshold,\n        address _ownerAddress\n    ) public returns (address) {\n        NewSageRouter newSageRouter = new NewSageRouter(\n            _uniswapV2Router02Address,\n            _WETHAddress,\n            _DETOAddress,\n            _uniswapV2PairAddress,\n            _factoryAddress,\n            _threshold,\n            _ownerAddress\n        );\n\n        return address(newSageRouter);\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapV2Router02Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETHAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DETOAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapV2PairAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factoryAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"creatNewSageRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NewSageRouterFactory","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}