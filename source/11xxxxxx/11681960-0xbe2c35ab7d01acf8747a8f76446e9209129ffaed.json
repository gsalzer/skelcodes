{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Trading.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\n\\nimport './interfaces/IProducts.sol';\\nimport './interfaces/IQueue.sol';\\nimport './interfaces/IToken.sol';\\nimport './interfaces/ITreasury.sol';\\n\\nimport './libraries/Permit.sol';\\nimport './libraries/SafeMathExt.sol';\\nimport './libraries/UintSet.sol';\\n\\ncontract Trading {\\n\\n    /* Libraries */\\n\\n    using SafeMath for uint256;\\n    using SafeMathExt for uint256;\\n    using UintSet for UintSet.Set;\\n\\n    /* Structs */\\n\\n    struct Position {\\n        address sender; // 20 bytes\\n        bytes12 symbol; // 12 bytes\\n        uint64 margin; // 8 bytes\\n        uint64 leverage; // 8 bytes\\n        uint64 price; // 8 bytes\\n        uint48 block; // 7 bytes\\n        bool isBuy; // 1 byte\\n        uint256 id; // not stored\\n    }\\n\\n    /* Variables */\\n\\n    address private products;\\n    address private queue;\\n    address private treasury;\\n\\n    // DAI\\n    address public currency;\\n\\n    // minimum margin to open a position\\n    uint256 public minimumMargin;\\n\\n    // 10^18 for DAI\\n    uint256 public currencyUnit;\\n\\n    // user => balance\\n    mapping(address => uint256) public freeMargins;\\n\\n    // id => Position\\n    mapping(uint256 => Position) public positions;\\n\\n    // user => position ids\\n    mapping(address => UintSet.Set) private userPositionIds;\\n\\n    // positions being liquidated\\n    mapping(uint256 => bool) public liquidatingIds;\\n\\n    // user => bool\\n    mapping(address => uint256) public pausedUsers;\\n\\n    // liquidator reward %\\n    uint256 public liquidatorReward;\\n\\n    address public owner;\\n    bool private initialized;\\n    bool public paused;\\n\\n    /* Events */\\n    event NewContracts(address products, address queue, address treasury);\\n    event NewMinimum(uint256 amount);\\n    event NewLiquidatorReward(uint256 amount);\\n    event Deposited(uint256 amount);\\n    event Withdrew(uint256 amount);\\n\\n    event OrderSubmitted(\\n        uint256 id,\\n        address indexed sender,\\n        bool isBuy,\\n        bytes32 symbol,\\n        uint256 margin,\\n        uint256 leverage,\\n        uint256 positionId\\n    );\\n\\n    event OrderCancelled(\\n        uint256 id,\\n        uint256 positionId,\\n        address indexed sender,\\n        string reason\\n    );\\n\\n    event PositionOpened(\\n        uint256 positionId,\\n        address indexed sender,\\n        bool isBuy,\\n        bytes32 symbol,\\n        uint256 margin,\\n        uint256 leverage,\\n        uint256 price\\n    );\\n\\n    event PositionLiquidated(\\n        uint256 positionId,\\n        address indexed sender,\\n        address indexed liquidator,\\n        uint256 marginLiquidated\\n    );\\n\\n    event PositionClosed(\\n        uint256 positionId,\\n        address indexed sender,\\n        uint256 marginClosed,\\n        uint256 amountToReturn,\\n        uint256 entryPrice,\\n        uint256 price,\\n        uint256 leverage\\n    );\\n\\n    event LiquidationSubmitted(\\n        uint256 id,\\n        uint256 positionId,\\n        address indexed sender\\n    );\\n\\n    /* Initializer (called only once) */\\n\\n    function initialize(address _currency) public {\\n        require(!initialized, '!initialized');\\n        initialized = true;\\n        owner = msg.sender;\\n        liquidatorReward = 10;\\n        currency = _currency;\\n        currencyUnit = SafeMathExt.base10pow(IToken(_currency).decimals());\\n    }\\n\\n    /* Methods called by governance */\\n\\n    function registerContracts(\\n        address _products,\\n        address _queue,\\n        address _treasury\\n    ) external onlyOwner {\\n        products = _products;\\n        queue = _queue;\\n        treasury = _treasury;\\n        emit NewContracts(_products, _queue, _treasury);\\n    }\\n\\n    function setCurrencyMin(uint256 _amount) external onlyOwner {\\n        minimumMargin = _amount;\\n        emit NewMinimum(_amount);\\n    }\\n\\n    function setLiquidatorReward(uint256 _amount) external onlyOwner {\\n        require(_amount <= 100, '!percent');\\n        liquidatorReward = _amount;\\n        emit NewLiquidatorReward(_amount);\\n    }\\n\\n    function pauseUsers(address[] calldata users) external onlyOwner {\\n        for (uint256 i = 0; i < users.length; i++) {\\n            pausedUsers[users[i]] = block.number;\\n        }\\n    }\\n\\n    function unpauseUsers(address[] calldata users) external onlyOwner {\\n        for (uint256 i = 0; i < users.length; i++) {\\n            pausedUsers[users[i]] = 0;\\n        }\\n    }\\n\\n    // TODO review\\n    function capUserBalance(\\n        address user,\\n        uint256 newBalanceCap\\n    ) external onlyOwner {\\n        // user must be blocked in a previous transaction before we can cap the balance\\n        uint256 pauseBlockNumber = pausedUsers[user];\\n        require(pauseBlockNumber > 0 && pauseBlockNumber < block.number, '!user_not_paused');\\n        uint256 treasuryBalance = ITreasury(treasury).getUserBalance(user);\\n        // trading balance and newBalance are 8 decimals, treasuryBalance 18 decimals (in most cases)\\n        require(newBalanceCap.mulDecimal8(currencyUnit) >= treasuryBalance, '!too_low');\\n        if (freeMargins[user] > newBalanceCap) {\\n            freeMargins[user] = newBalanceCap;\\n        }\\n    }\\n\\n    function pause() external onlyOwner {\\n        paused = true;\\n    }\\n\\n    function unpause() external onlyOwner {\\n        paused = false;\\n    }\\n\\n    /* Methods called by the client */\\n\\n    function deposit(\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external whenNotPaused {\\n        uint256 amt = amount.mulDecimal8(currencyUnit);\\n        Permit.permit(currency, amt, msg.sender, treasury, deadline, v, r, s);\\n        ITreasury(treasury).userDeposit(msg.sender, amt);\\n        freeMargins[msg.sender] = freeMargins[msg.sender].add(amount);\\n        emit Deposited(amount);\\n    }\\n\\n    function withdraw(\\n        uint256 amount\\n    ) external whenNotPaused whenNotUserPaused(msg.sender) {\\n        freeMargins[msg.sender] = freeMargins[msg.sender].sub(amount, '!balance');\\n        ITreasury(treasury).userWithdraw(msg.sender, amount.mulDecimal8(currencyUnit));\\n        emit Withdrew(amount);\\n    }\\n\\n    function submitOrder(\\n        bool isBuy,\\n        bytes32 symbol,\\n        uint256 margin,\\n        uint256 leverage\\n    ) external whenNotPaused whenNotUserPaused(msg.sender) {\\n        require(margin >= minimumMargin, '!margin');\\n        require(leverage >= SafeMathExt.UNIT8, '!leverage');\\n        uint256 maxLeverage = IProducts(products).getMaxLeverage(symbol, true);\\n        require(maxLeverage > 0, '!symbol');\\n        require(leverage <= maxLeverage, '!max_leverage');\\n        freeMargins[msg.sender] = freeMargins[msg.sender].sub(margin, '!balance');\\n        uint256 id = _queueOrder(isBuy, symbol, margin, leverage, 0, address(0));\\n        positions[id] = Position({isBuy: isBuy, margin: SafeMathExt.safeUint64(margin), leverage: SafeMathExt.safeUint64(leverage), sender: msg.sender, symbol: bytes12(''), price: 0, block: 0, id: 0});\\n    }\\n\\n    function submitOrderUpdate(\\n        uint256 positionId,\\n        uint256 margin\\n    ) external whenNotPaused {\\n        Position storage position = positions[positionId];\\n        require(position.price > 0, '!found');\\n        require(position.sender == msg.sender, '!authorized');\\n        // partial or full close\\n        require(margin <= uint256(position.margin), '!margin');\\n        _queueOrder(!position.isBuy, bytes32(position.symbol), margin, uint256(position.leverage), positionId, address(0));\\n    }\\n\\n    function liquidatePositions(uint256[] calldata positionIds) external {\\n        uint256 length = positionIds.length;\\n        require(length < 6, '!too_many');\\n        for (uint256 i = 0; i < length; i++) {\\n            uint256 positionId = positionIds[i];\\n            Position storage position = positions[positionId];\\n            if (position.price > 0 && !liquidatingIds[positionId]) {\\n                liquidatingIds[positionId] = true;\\n                _queueOrder(!position.isBuy, bytes32(position.symbol), 0, 0, positionId, msg.sender);\\n            }\\n        }\\n    }\\n\\n    function getUserPositions(address user) external view returns(Position[] memory _positions) {\\n        uint256 length = userPositionIds[user].length();\\n        _positions = new Position[](length);\\n        for (uint256 i=0; i < length; i++) {\\n            uint256 id = userPositionIds[user].at(i);\\n            Position memory positionWithId = positions[id];\\n            positionWithId.id = id;\\n            _positions[i] = positionWithId;\\n        }\\n        return _positions;\\n    }\\n\\n    function getUserFreeMargin(address user) external view returns(uint256) {\\n        return freeMargins[user];\\n    }\\n\\n    /* Queue methods */\\n\\n    function processOrder(\\n        uint256 id,\\n        bytes32 symbol,\\n        uint256 price,\\n        uint256 margin,\\n        uint256 positionId,\\n        address liquidator\\n    ) external whenNotPaused onlyQueue {\\n        if (positionId > 0) {\\n            if (liquidator != address(0)) {\\n                delete liquidatingIds[positionId];\\n                Position memory position = positions[positionId];\\n                require(position.price > 0, '!found');\\n                uint256 positionMargin = uint256(position.margin);\\n                (uint256 pnl, bool isPnlNegative) = _calculatePnl(position, positionMargin, price);\\n                if (isPnlNegative && pnl >= positionMargin) {\\n                    _processLiquidation(liquidator, positionId, positionMargin, position.sender);\\n                }\\n            } else {\\n                _processClose(margin, price, positionId);\\n            }\\n        } else {\\n            _processOpen(id, symbol, price);\\n        }\\n    }\\n\\n    function cancelOrder(\\n        uint256 id,\\n        uint256 positionId,\\n        address liquidator,\\n        string calldata reason\\n    ) external onlyQueue {\\n        if (positionId == 0) {\\n            // cancelling a new order\\n            Position storage position = positions[id];\\n            address sender = position.sender;\\n            uint256 margin = uint256(position.margin);\\n            delete positions[id];\\n            // release margin back to user\\n            freeMargins[sender] = freeMargins[sender].add(margin);\\n            emit OrderCancelled(id, id, sender, reason);\\n        } else if (liquidator != address(0)) {\\n            // cancelling a liquidation request\\n            delete liquidatingIds[id];\\n            emit OrderCancelled(id, positionId, liquidator, reason);\\n        } else {\\n            // cancelling a full or partial close order (sender could be address zero)\\n            emit OrderCancelled(id, positionId, positions[positionId].sender, reason);\\n        }\\n    }\\n\\n    /* Internal methods */\\n\\n    function _queueOrder(\\n        bool isBuy,\\n        bytes32 symbol,\\n        uint256 margin,\\n        uint256 leverage,\\n        uint256 positionId,\\n        address liquidator\\n    ) internal returns (uint256 id) {\\n        id = IQueue(queue).queueOrder(symbol, margin, positionId, liquidator);\\n\\n        if (liquidator != address(0)) {\\n            emit LiquidationSubmitted(id, positionId, msg.sender);\\n        } else {\\n            emit OrderSubmitted(id, msg.sender, isBuy, symbol, margin, leverage, positionId);\\n        }\\n        return id;\\n    }\\n\\n    function _processOpen(\\n        uint256 id,\\n        bytes32 symbol,\\n        uint256 price\\n    ) internal {\\n        Position storage position = positions[id];\\n        bool isBuy = position.isBuy;\\n        uint256 margin = uint256(position.margin);\\n        uint256 leverage = uint256(position.leverage);\\n        address sender = position.sender;\\n        // calculate execution price\\n        uint256 spread = IProducts(products).getSpread(symbol);\\n        if (isBuy) {\\n            price = price.mulDecimal8(SafeMathExt.UNIT8.add(spread));\\n        } else {\\n            price = price.mulDecimal8(SafeMathExt.UNIT8.sub(spread));\\n        }\\n        // complete the Position struct started in submitOrder\\n        position.symbol = bytes12(symbol);\\n        position.price = SafeMathExt.safeUint64(price);\\n        position.block = uint48(block.number);\\n        // user to position ID\\n        userPositionIds[sender].add(id);\\n        // event\\n        emit PositionOpened(id, sender, isBuy, symbol, margin, leverage, price);\\n    }\\n\\n    function _processClose(\\n        uint256 margin,\\n        uint256 price,\\n        uint256 positionId\\n    ) internal {\\n        Position memory mPosition = positions[positionId];\\n        uint256 positionMargin = uint256(mPosition.margin);\\n        require(margin <= positionMargin, '!margin');\\n        uint256 spread = IProducts(products).getSpread(bytes32(mPosition.symbol));\\n        // execution price\\n        if (mPosition.isBuy) {\\n            price = price.mulDecimal8(SafeMathExt.UNIT8.sub(spread));\\n        } else {\\n            price = price.mulDecimal8(SafeMathExt.UNIT8.add(spread));\\n        }\\n        // pnl\\n        (uint256 pnl, bool isPnlNegative) = _calculatePnl(mPosition, margin, price);\\n        uint256 amountToReturn;\\n        if (isPnlNegative && pnl >= margin) {\\n            // position is liquidated\\n            delete positions[positionId];\\n            userPositionIds[mPosition.sender].remove(positionId);\\n            // transfer user margin to surplus\\n            ITreasury(treasury).collectFromUser(mPosition.sender, positionMargin.mulDecimal8(currencyUnit));\\n        } else {\\n            if (margin < positionMargin) {\\n                // partial close, update position margin\\n                Position storage position = positions[positionId];\\n                position.margin = SafeMathExt.safeUint64(positionMargin.sub(margin));\\n            } else {\\n                // full close, remove from mappings\\n                delete positions[positionId];\\n                userPositionIds[mPosition.sender].remove(positionId);\\n            }\\n            if (isPnlNegative) {\\n                amountToReturn = margin.sub(pnl);\\n                // return amountToReturn to free margin\\n                freeMargins[mPosition.sender] = freeMargins[mPosition.sender].add(amountToReturn);\\n                // collect pnl\\n                ITreasury(treasury).collectFromUser(mPosition.sender, pnl.mulDecimal8(currencyUnit));\\n            } else {\\n                amountToReturn = margin.add(pnl);\\n                freeMargins[mPosition.sender] = freeMargins[mPosition.sender].add(amountToReturn);\\n            }\\n        }\\n        emit PositionClosed(positionId, mPosition.sender, margin, amountToReturn, mPosition.price, price, mPosition.leverage);\\n    }\\n\\n    function _processLiquidation(\\n        address liquidator,\\n        uint256 positionId,\\n        uint256 positionMargin,\\n        address positionSender\\n    ) internal {\\n        delete positions[positionId];\\n        userPositionIds[positionSender].remove(positionId);\\n        // collect margin from user\\n        ITreasury(treasury).collectFromUser(positionSender, positionMargin.mulDecimal8(currencyUnit));\\n        // pay liquidatorReward % of margin to liquidator\\n        uint256 liquidatorMargin = positionMargin.mul(liquidatorReward).div(100);\\n        freeMargins[liquidator] = freeMargins[liquidator].add(liquidatorMargin);\\n        emit PositionLiquidated(positionId, positionSender, liquidator, positionMargin);\\n    }\\n\\n    /* Helpers */\\n\\n    function _calculatePnl(\\n        Position memory position,\\n        uint256 margin,\\n        uint256 price\\n    ) internal view returns (uint256 pnl, bool isPnlNegative) {\\n        uint256 positionLeverage = uint256(position.leverage);\\n        uint256 positionPrice = uint256(position.price);\\n        if (position.isBuy) {\\n            if (price >= position.price) {\\n                pnl = margin.mul(positionLeverage).mul(price.sub(positionPrice)).div(positionPrice).div(SafeMathExt.UNIT8);\\n            } else {\\n                pnl = margin.mul(positionLeverage).mul(positionPrice.sub(price)).div(positionPrice).div(SafeMathExt.UNIT8);\\n                isPnlNegative = true;\\n            }\\n        } else {\\n            if (price > position.price) {\\n                pnl = margin.mul(positionLeverage).mul(price.sub(positionPrice)).div(positionPrice).div(SafeMathExt.UNIT8);\\n                isPnlNegative = true;\\n            } else {\\n                pnl = margin.mul(positionLeverage).mul(positionPrice.sub(price)).div(positionPrice).div(SafeMathExt.UNIT8);\\n            }\\n        }\\n        // Calculate funding to apply on this position\\n        uint256 fundingToApply = margin.mul(positionLeverage).mul(block.number.sub(uint256(position.block))).mul(IProducts(products).getFundingRate(bytes32(position.symbol))).div(1e16);\\n        // Subtract funding from pnl\\n        if (isPnlNegative) {\\n            pnl = pnl.add(fundingToApply);\\n        } else if (fundingToApply > pnl) {\\n            isPnlNegative = true;\\n            pnl = fundingToApply.sub(pnl);\\n        } else {\\n            pnl = pnl.sub(fundingToApply);\\n        }\\n        return (pnl, isPnlNegative);\\n    }\\n\\n    /* Modifiers */\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, '!authorized');\\n        _;\\n    }\\n\\n    modifier onlyQueue() {\\n        require(msg.sender == queue, '!authorized');\\n        _;\\n    }\\n\\n    modifier whenNotUserPaused(address user) {\\n        require(pausedUsers[user] == 0, '!pausedUser');\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!paused, '!paused');\\n        _;\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProducts.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\ninterface IProducts {\\n\\n\\tfunction getMaxLeverage(bytes32 symbol, bool checkDisabled) external view returns (uint256);\\n\\tfunction getFundingRate(bytes32 symbol) external view returns (uint256);\\n\\tfunction getSpread(bytes32 symbol) external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IQueue.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\ninterface IQueue {\\n\\n    function firstOrderId() external view returns (uint256);\\n    function nextOrderId() external view returns (uint256);\\n    function processedOrdersCount() external view returns (uint256);\\n\\n    function queueOrder(bytes32 symbol, uint256 margin, uint256 positionId, address liquidator) external returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\nimport './IEIP712.sol';\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IToken is IERC20, IEIP712 {\\n\\n    /* ========== OPTIONAL VIEWS ========== */\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /* ========== VIEWS ========== */\\n\\n    function paused() external view returns (bool);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function initialize(address synthTrading, string memory _name, string memory _symbol) external;\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    function mint(address to, uint256 amount) external;\\n    function burn(uint256 amount) external;\\n    function burnFrom(address account, uint256 amount) external;\\n\\n    function pause() external;\\n    function unpause() external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\ninterface ITreasury {\\n\\n    function userDeposit(address user, uint256 amount) external;\\n    function userWithdraw(address user, uint256 amount) external;\\n    function collectFromUser(address user, uint256 amount) external;\\n    function payToUser(address user, uint256 amount) external;\\n    \\n    function getUserBalance(address user) external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/libraries/Permit.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\nimport '../interfaces/IToken.sol';\\nimport '../interfaces/IEIP712_DAI.sol';\\n\\nlibrary Permit {\\n\\n\\tfunction permit(\\n\\t\\taddress currency,\\n\\t\\tuint256 amount,\\n\\t\\taddress sender,\\n\\t\\taddress spender,\\n\\t\\tuint256 deadline,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) internal {\\n\\t\\tif (IToken(currency).allowance(sender, spender) < amount) {\\n\\t\\t    if (keccak256(bytes(IToken(currency).symbol())) == 0xa5e92f3efb6826155f1f728e162af9d7cda33a574a1153b58f03ea01cc37e568) {\\n\\t\\t        // DAI has a custom permit method\\n\\t\\t        uint256 nonce = IToken(currency).nonces(sender);\\n\\t\\t        IEIP712_DAI(currency).permit(sender, spender, nonce, deadline, true, v, r, s);\\n\\t\\t    }/* else {\\n\\t\\t        IToken(currency).permit(sender, spender, uint256(-1), deadline, v, r, s);\\n\\t\\t    }*/\\n\\t\\t}\\n\\t}\\n\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeMathExt.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\n\\nlibrary SafeMathExt {\\n\\n    using SafeMath for uint256;\\n\\n    uint256 public constant UNIT8 = 1e8;\\n    uint256 public constant UNIT18 = 1e18;\\n\\n    function base10pow(uint8 exponent) internal pure returns (uint256) {\\n        // very common\\n        if (exponent == 18) return 1e18;\\n        if (exponent == 6) return 1e6;\\n\\n        uint256 result = 1;\\n\\n        while (exponent >= 10) {\\n            result = result.mul(uint256(1e10));\\n            exponent -= 10;\\n        }\\n\\n        while (exponent > 0) {\\n            result = result.mul(uint256(10));\\n            exponent--;\\n        }\\n\\n        return result;\\n    }\\n\\n    function mulDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x.mul(y) / UNIT18;\\n    }\\n\\n    function divDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x.mul(UNIT18).div(y);\\n    }\\n\\n    function mulDecimal8(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x.mul(y) / UNIT8;\\n    }\\n\\n    function divDecimal8(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x.mul(UNIT8).div(y);\\n    }\\n\\n    function safeUint64(uint256 x) internal pure returns (uint64) {\\n        require(x <= uint64(-1), 'SafeMath: cast overflow');\\n        return uint64(x);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/libraries/UintSet.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\nlibrary UintSet {\\n\\n    struct Set {\\n        uint256[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0 means a value is not in the set\\n        mapping (uint256 => uint256) _indexes;\\n    }\\n\\n    function add(Set storage set, uint256 value) internal returns (bool) {\\n        if (!contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function remove(Set storage set, uint256 value) internal returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            uint256 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function contains(Set storage set, uint256 value) internal view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function length(Set storage set) internal view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function at(Set storage set, uint256 index) internal view returns (uint256) {\\n        require(set._values.length > index, 'UintEnumerableSet: OUT_OF_BOUNDS');\\n        return set._values[index];\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEIP712.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\ninterface IEIP712 {\\n\\n    /* ========== OPTIONAL VIEWS ========== */\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external view returns (bytes32);\\n    function nonces(address wallet) external view returns (uint256);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEIP712_DAI.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.3;\\n\\ninterface IEIP712_DAI {\\n\\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"LiquidationSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"products\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"queue\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"NewContracts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewLiquidatorReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewMinimum\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"OrderSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marginClosed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToReturn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"}],\"name\":\"PositionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marginLiquidated\",\"type\":\"uint256\"}],\"name\":\"PositionLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PositionOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrew\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newBalanceCap\",\"type\":\"uint256\"}],\"name\":\"capUserBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currencyUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"freeMargins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserFreeMargin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserPositions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"symbol\",\"type\":\"bytes12\"},{\"internalType\":\"uint64\",\"name\":\"margin\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"leverage\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint48\",\"name\":\"block\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Trading.Position[]\",\"name\":\"_positions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"positionIds\",\"type\":\"uint256[]\"}],\"name\":\"liquidatePositions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidatingIds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidatorReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumMargin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"pauseUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausedUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"symbol\",\"type\":\"bytes12\"},{\"internalType\":\"uint64\",\"name\":\"margin\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"leverage\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint48\",\"name\":\"block\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"processOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_products\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_queue\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"registerContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setCurrencyMin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setLiquidatorReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"}],\"name\":\"submitOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"}],\"name\":\"submitOrderUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"unpauseUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Trading","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}