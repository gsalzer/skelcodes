{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-10-22\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^ 0.6.6;\r\n\r\ncontract RugPull{\r\n\t\r\n\tPyramid public PiZZa;\r\n\tRugToken public Rugs;\r\n\tuint public carpetBags = 25000;\r\n\taddress public RugChallenger;\r\n\tuint public RugChallengerHP;\r\n\taddress public CARPET_KING;\r\n\tuint public carpet_dynasty_generation;\r\n\taddress public DEV;\r\n\tERC20 public Resolve;\r\n\taddress payable address0 = address(0);\r\n\tmapping(address => address) public gateway;\r\n\tmapping(address => bool) public initiated;\r\n\tmapping(address => uint) public pocket;\r\n\tmapping(address => uint) public thanks;\r\n\r\n\tconstructor() public{\r\n\t\tPiZZa = Pyramid(0x91683899ed812C1AC49590779cb72DA6BF7971fE);\r\n\t\tRugs = new RugToken();\r\n\t\tDEV = msg.sender;\r\n\t\tCARPET_KING = DEV;\r\n\t\tRugChallenger = DEV;\r\n\t\tResolve = PiZZa.resolveToken();\r\n\t\tgateway[CARPET_KING] = CARPET_KING;\r\n\t\tinitiated[DEV] = true;\r\n\t}\r\n\r\n\tfunction weight(address addr) public view returns(uint){\r\n\t\treturn Resolve.balanceOf(addr);\r\n\t}\r\n\r\n\tfunction buy(address _gateway, uint _red, uint _green, uint _blue) public payable returns(uint bondsCreated){\r\n\t\taddress sender = msg.sender;\r\n\t\tif( !initiated[sender] ){\r\n\t\t\tif( initiated[_gateway] ){\r\n\t\t\t\tgateway[sender] = _gateway;\r\n\t\t\t}else{\r\n\t\t\t\tgateway[sender] = RugChallenger;\r\n\t\t\t}\r\n\t\t\tinitiated[sender] = true;\r\n\t\t}\r\n\r\n\r\n\t\tif(_red>1e18) _red = 1e18;\r\n\t\tif(_green>1e18) _green = 1e18;\r\n\t\tif(_blue>1e18) _blue = 1e18;\r\n\r\n\t\tuint[] memory UINTs = new uint[](4);\r\n\t\tUINTs[0] = msg.value * 3 / 100;\r\n\t\tUINTs[1] = msg.value * 2 / 100;\r\n\t\tUINTs[2] = msg.value * 1 / 100;\r\n\t\tUINTs[3] = msg.value * 6 / 1000;\r\n\t\tuint eth4PiZZa = msg.value - UINTs[0] - UINTs[1] - UINTs[2] - UINTs[3];\r\n\r\n\r\n\t\taddress lvl1 = gateway[sender];\r\n\t\tif( weight(lvl1) > weight(sender) ){\r\n\t\t\tpocket[ lvl1 ] += UINTs[0];\r\n\t\t}else{\r\n\t\t\tsplitForKingAndRugChallenger(UINTs[0]);\r\n\t\t\temit ReffSnatch(RugChallenger, gateway[sender]);\r\n\t\t\tgateway[sender] = RugChallenger;\r\n\t\t}\r\n\r\n\t\taddress lvl2 = gateway[lvl1];\r\n\t\tif( weight(lvl2) > weight(sender) ){\r\n\t\t\tpocket[ lvl2 ] += UINTs[1];\r\n\t\t}else{\r\n\t\t\tsplitForKingAndRugChallenger(UINTs[1]);\r\n\t\t\temit ReffSnatch(sender, gateway[lvl1]);\r\n\t\t\tgateway[lvl1] = sender;\r\n\t\t}\r\n\r\n\t\taddress lvl3 = gateway[lvl2];\r\n\t\tif( weight(lvl3) > weight(sender) ){\r\n\t\t\tpocket[ lvl3 ] += UINTs[2];\r\n\t\t}else{\r\n\t\t\tsplitForKingAndRugChallenger(UINTs[2]);\r\n\t\t\temit ReffSnatch(sender, gateway[lvl2]);\r\n\t\t\tgateway[lvl2] = sender;\r\n\t\t}\r\n\r\n\t\tpocket[ CARPET_KING ] += UINTs[3];\r\n\t\t\r\n\r\n\t\tuint createdPiZZa = PiZZa.buy{value: eth4PiZZa}(sender, _red, _green, _blue);\r\n\r\n\t\tif(RugChallenger != sender){\r\n\t\t\tif( RugChallengerHP <= weight(sender) ){\r\n\t\t\t\tRugChallenger = sender;\t\r\n\t\t\t\tRugChallengerHP = weight(sender);\r\n\t\t\t\temit RugPulled(sender, RugChallenger, RugChallengerHP);\r\n\t\t\t}else{\r\n\t\t\t\tuint damage = weight(sender);\r\n\t\t\t\tif(damage>0){\r\n\t\t\t\t\tRugChallengerHP -= damage;\r\n\t\t\t\t\temit Damaged( RugChallenger, damage );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif( RugChallengerHP < weight(sender) && msg.value > 0.001 ether)\r\n\t\t\t\tRugChallengerHP = weight(sender);\r\n\t\t}\r\n\r\n\t\tif(carpetBags > 0 && msg.value > 0.001 ether){\r\n\t\t\tcarpetBags -= 1;\r\n\t\t\tRugs.mint(sender, createdPiZZa);\r\n\t\t}\r\n\r\n\t\treturn createdPiZZa;\r\n\t}\r\n\tevent RugPulled(address winner, address loser, uint HP);\r\n\tevent Damaged(address RugChallenger, uint damage);\r\n\tevent ReffSnatch(address snatcher, address slacker);\r\n\tevent SplitForKingAndRugChallenger(address king, address buyer);\r\n\tfunction splitForKingAndRugChallenger(uint ETH) internal{\r\n\t\tpocket[CARPET_KING] += ETH/2;\r\n\t\tpocket[RugChallenger] += ETH - ETH/2;\r\n\t\temit SplitForKingAndRugChallenger(CARPET_KING, RugChallenger);\r\n\t}\r\n\r\n\tevent Withdraw(address account, uint amount);\r\n\tfunction withdraw() public{\r\n\t\taddress sender = msg.sender;\r\n\t\tuint amount = pocket[sender];\r\n\t\tif( amount>0 ){\r\n\t\t\tpocket[sender] = 0;\r\n\t\t\t(bool success, ) = sender.call{value:amount}(\"\");\r\n\t\t\temit Withdraw(sender, amount);\r\n\t        require(success, \"Transfer failed.\");\r\n        }else{\r\n        \trevert();\r\n        }\r\n\t}\r\n\r\n\tevent RechargeMagicLamp( address indexed addr, uint256 amountStaked );\r\n\tfunction tokenFallback(address from, uint value, bytes calldata _data) external{\r\n\t\tif(msg.sender == address(Resolve) ){\r\n\t\t\taddress THIS = address(this);\r\n\t\t\tif(carpetBags == 0){\r\n\t\t\t\tcarpetBags += value / 1e16; //100 per resolve token\r\n\t\t\t\tCARPET_KING = from;\r\n\t\t\t\t//takes the resolve tokens used to recharge the magic lamp and it stakes those\r\n\t\t\t\t//only the original dev benefits from these resolves being staked\r\n\t\t\t\t//the address that recharged the lamp benefits as CARPET_KING\r\n\t\t\t\t//only every 6th generation stakes resolves. waits for first 6\r\n\t\t\t\tif(carpet_dynasty_generation % 6 == 0){\r\n\t\t\t\t\tuint earnings = PiZZa.resolveEarnings( THIS );\r\n\t\t\t\t\tif(earnings > 0){\r\n\t\t\t\t\t\tPiZZa.withdraw(earnings);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t(bool success, ) = DEV.call{value:earnings}(\"\");\r\n\t\t\t\t\t\trequire(success, \"Transfer failed.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tResolve.transfer( address(PiZZa), Resolve.balanceOf(THIS) );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcarpet_dynasty_generation += 1;\r\n\t\t\t\temit RechargeMagicLamp(from, carpetBags);\r\n\t\t\t}else{\r\n\t\t\t\tthanks[from] += value; //literally, this is it\r\n\t\t\t\tResolve.transfer( address(PiZZa), value);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\trevert(\"no want\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nabstract contract Pyramid{\r\n    function buy(address addr, uint _red, uint _green, uint _blue) public virtual payable returns(uint createdBonds);\r\n    function resolveToken() public view virtual returns(ERC20);\r\n    function resolveEarnings(address _owner) public view virtual returns (uint256 amount);\r\n    function withdraw(uint amount) public virtual returns(uint);\r\n}\r\n\r\nabstract contract ERC20{\r\n\tfunction balanceOf(address _owner) public view virtual returns (uint256 balance);\r\n\tfunction transfer(address _to, uint _value) public virtual returns (bool);\r\n}\r\n\r\ncontract RugToken{\r\n\r\n\tstring public name = \"Rug Token\";\r\n    string public symbol = \"RUG\";\r\n    uint8 constant public decimals = 18;\r\n\taddress public owner;\r\n\r\n\tconstructor() public{\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier ownerOnly{\r\n\t  require(msg.sender == owner);\r\n\t  _;\r\n    }\r\n\r\n\tevent Mint(\r\n\t\taddress indexed addr,\r\n\t\tuint256 amount\r\n\t);\r\n\r\n\tfunction mint(address _address, uint _value) external ownerOnly(){\r\n\t\tbalances[_address] += _value;\r\n\t\t_totalSupply += _value;\r\n\t\temit Mint(_address, _value);\r\n\t}\r\n\r\n\tmapping(address => uint256) public balances;\r\n\r\n\tuint public _totalSupply;\r\n\r\n\tmapping(address => mapping(address => uint)) approvals;\r\n\r\n\tevent Transfer(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 amount,\r\n\t\tbytes data\r\n\t);\r\n\tevent Transfer(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 amount\r\n\t);\r\n\t\r\n\tfunction totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n\t// Function that is called when a user or another contract wants to transfer funds.\r\n\tfunction transfer(address _to, uint _value, bytes memory _data) public virtual returns (bool) {\r\n\t\tif( isContract(_to) ){\r\n\t\t\treturn transferToContract(_to, _value, _data);\r\n\t\t}else{\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Standard function transfer similar to ERC20 transfer with no _data.\r\n\t// Added due to backwards compatibility reasons .\r\n\tfunction transfer(address _to, uint _value) public virtual returns (bool) {\r\n\t\t//standard function transfer similar to ERC20 transfer with no _data\r\n\t\t//added due to backwards compatibility reasons\r\n\t\tbytes memory empty;\r\n\t\tif(isContract(_to)){\r\n\t\t\treturn transferToContract(_to, _value, empty);\r\n\t\t}else{\r\n\t\t\treturn transferToAddress(_to, _value, empty);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//function that is called when transaction target is an address\r\n\tfunction transferToAddress(address _to, uint _value, bytes memory _data) private returns (bool) {\r\n\t\tmoveTokens(msg.sender, _to, _value);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//function that is called when transaction target is a contract\r\n\tfunction transferToContract(address _to, uint _value, bytes memory _data) private returns (bool) {\r\n\t\tmoveTokens(msg.sender, _to, _value);\r\n\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n\t\treceiver.tokenFallback(msg.sender, _value, _data);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction moveTokens(address _from, address _to, uint _amount) internal virtual{\r\n\t\trequire( _amount <= balances[_from] );\r\n\r\n\t\t//update balances\r\n\t\tbalances[_from] -= _amount;\r\n\t\tbalances[_to] += _amount;\r\n\t}\r\n\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return approvals[src][guy];\r\n    }\r\n  \t\r\n    function transferFrom(address src, address dst, uint amount) public returns (bool){\r\n        address sender = msg.sender;\r\n        require(approvals[src][sender] >=  amount);\r\n        require(balances[src] >= amount);\r\n        approvals[src][sender] -= amount;\r\n        moveTokens(src,dst,amount);\r\n        bytes memory empty;\r\n        emit Transfer(sender, dst, amount, empty);\r\n        emit Transfer(sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    event Approval(address indexed src, address indexed guy, uint amount);\r\n    function approve(address guy, uint amount) public returns (bool) {\r\n        address sender = msg.sender;\r\n        approvals[sender][guy] = amount;\r\n\r\n        emit Approval( sender, guy, amount );\r\n        return true;\r\n    }\r\n\r\n    function isContract(address _addr) public view returns (bool is_contract) {\r\n\t\tuint length;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\tif(length>0) {\r\n\t\t\treturn true;\r\n\t\t}else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nabstract contract ERC223ReceivingContract{\r\n    function tokenFallback(address _from, uint _value, bytes calldata _data) external virtual;\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"RugChallenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"damage\",\"type\":\"uint256\"}],\"name\":\"Damaged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"}],\"name\":\"RechargeMagicLamp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"snatcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"slacker\",\"type\":\"address\"}],\"name\":\"ReffSnatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"HP\",\"type\":\"uint256\"}],\"name\":\"RugPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"king\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"SplitForKingAndRugChallenger\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CARPET_KING\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PiZZa\",\"outputs\":[{\"internalType\":\"contract Pyramid\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Resolve\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RugChallenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RugChallengerHP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Rugs\",\"outputs\":[{\"internalType\":\"contract RugToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_red\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_green\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blue\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bondsCreated\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"carpetBags\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"carpet_dynasty_generation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"initiated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pocket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"thanks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RugPull","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3f95f53dd247f2723ef34ff688a8c32c4c5e34bd878bea7eb470490d4b5772fa"}]}