{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\r\n*/\r\n \r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n  function ceil(uint a, uint m) internal pure returns (uint r) {\r\n    return (a + m - 1) / m * m;\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// ----------------------------------------------------------------------------\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\r\n    function transfer(address payable to, uint256 tokens) external returns (bool success);\r\n    function approve(address spender, uint256 tokens) external returns (bool success);\r\n    function transferFrom(address from, address payable to, uint256 tokens) external returns (bool success);\r\n}\r\n\r\ncontract lpEvent{\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    address payable public fundsReceiver = 0x9F2742e7427E26DeC6beD359F0B4b5bff6A41bB3;\r\n    \r\n    uint256 public totalFundsReceived; \r\n    uint256 public lpEventEndDate;\r\n    bool public claimOpen = false;\r\n    \r\n    uint256 pointMultiplier = 1e18;\r\n    uint256 public unitShare = 0;\r\n    uint256 public unclaimedLps = 0;\r\n    uint256 public totalLpTokens = 0;\r\n    address public lpTokenAddress;\r\n    \r\n    struct Investor{\r\n        uint256 investment;\r\n        uint256 lpTokensGained;\r\n    }\r\n    mapping(address => Investor) public investors;\r\n    \r\n    modifier onlyFundsReceiver{\r\n        require(msg.sender == fundsReceiver);\r\n        _;\r\n    }\r\n    \r\n    constructor() public{\r\n        lpEventEndDate = block.timestamp.add(3 days); \r\n    }\r\n\r\n    receive() external payable{\r\n        deposit();\r\n    }\r\n    \r\n    function deposit() public payable{\r\n        require(block.timestamp <= lpEventEndDate, \"Lp Event is closed\");\r\n        totalFundsReceived = totalFundsReceived.add(msg.value);\r\n        investors[msg.sender].investment = investors[msg.sender].investment.add(msg.value);\r\n        fundsReceiver.transfer(msg.value);\r\n    }\r\n    \r\n    function addLpTokens(address _lpTokenAddress, uint256 lpTokens) external onlyFundsReceiver{\r\n        require(block.timestamp > lpEventEndDate, \"Lp event is running\");\r\n        require(_lpTokenAddress != address(0), \"Invalid token address\");\r\n        require(!claimOpen, \"Cannot add more, claim is already open\");\r\n        require(IERC20(_lpTokenAddress).transferFrom(msg.sender, address(this), lpTokens), \"Could not transfer lp tokens from sender\");\r\n        totalLpTokens = lpTokens;\r\n        unclaimedLps = lpTokens;\r\n        lpTokenAddress = _lpTokenAddress;\r\n        disburse(lpTokens);\r\n        claimOpen = true;\r\n    }\r\n    \r\n    function disburse(uint256 amount) internal{\r\n        uint256 unnormalized = amount.mul(pointMultiplier);\r\n        unitShare = unitShare.add(unnormalized.div(totalFundsReceived)); // un-normalized\r\n    }\r\n    \r\n    function lpShare(address _user) public view returns(uint256){\r\n        uint256 owing = unitShare.mul(investors[_user].investment);\r\n        owing = owing.div(pointMultiplier);\r\n        owing = owing.sub(investors[_user].lpTokensGained);\r\n        return owing;\r\n    }\r\n    \r\n    function claimLpTokens() external {\r\n        require(claimOpen, \"Claim is not opened yet\");\r\n        uint256 owing = lpShare(msg.sender);\r\n        require(owing > 0, \"No pending lp tokens\");\r\n        require(IERC20(lpTokenAddress).transfer(msg.sender, owing));\r\n        unclaimedLps = unclaimedLps.sub(owing);\r\n        investors[msg.sender].lpTokensGained = investors[msg.sender].lpTokensGained.add(owing);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"}],\"name\":\"addLpTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLpTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundsReceiver\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokensGained\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpEventEndDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"lpShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFundsReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLpTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unclaimedLps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unitShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"lpEvent","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://689a90ad8ea48e221f04586e854411390b99ea93373583961d05be4903c21e49"}]}