{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at BscScan.com on 2021-03-08\r\n*/\r\n\r\n// File: contracts/interfaces/marketManagerInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's market manager interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface marketManagerInterface  {\r\n\tfunction setBreakerTable(address _target, bool _status) external returns (bool);\r\n\r\n\tfunction getCircuitBreaker() external view returns (bool);\r\n\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\r\n\r\n\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address, string memory);\r\n\r\n\tfunction handlerRegister(uint256 handlerID, address tokenHandlerAddr) external returns (bool);\r\n\r\n\tfunction applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external returns (uint256, uint256, uint256, uint256, uint256, uint256);\r\n\r\n\tfunction getTokenHandlerPrice(uint256 handlerID) external view returns (uint256);\r\n\tfunction getTokenHandlerBorrowLimit(uint256 handlerID) external view returns (uint256);\r\n\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\r\n\r\n\tfunction getTokenHandlersLength() external view returns (uint256);\r\n\tfunction setTokenHandlersLength(uint256 _tokenHandlerLength) external returns (bool);\r\n\r\n\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\r\n\tfunction getTokenHandlerMarginCallLimit(uint256 handlerID) external view returns (uint256);\r\n\r\n\tfunction getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserTotalIntraCreditAsset(address payable userAddr) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserLimitIntraAsset(address payable userAddr) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserCollateralizableAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\r\n\r\n\tfunction getUserExtraLiquidityAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\r\n\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 liquidateHandlerID, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\r\n\r\n\tfunction getMaxLiquidationReward(address payable delinquentBorrower, uint256 liquidateHandlerID, uint256 liquidateAmount, uint256 rewardHandlerID, uint256 rewardRatio) external view returns (uint256);\r\n\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 rewardAmount, address payable liquidator, uint256 handlerID) external returns (uint256);\r\n\r\n\tfunction setLiquidationManager(address liquidationManagerAddr) external returns (bool);\r\n\r\n\tfunction rewardClaimAll(address payable userAddr) external returns (uint256);\r\n\r\n\tfunction updateRewardParams(address payable userAddr) external returns (bool);\r\n\tfunction interestUpdateReward() external returns (bool);\r\n\tfunction getGlobalRewardInfo() external view returns (uint256, uint256, uint256);\r\n\r\n\tfunction setOracleProxy(address oracleProxyAddr) external returns (bool);\r\n\r\n\tfunction rewardUpdateOfInAction(address payable userAddr, uint256 callerID) external returns (bool);\r\n\tfunction ownerRewardTransfer(uint256 _amount) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfacesForManager/managerDataStorageInterfaceForManager.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's manager data storage interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface managerDataStorageInterfaceForManager  {\r\n\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address);\r\n\r\n\tfunction getRewardParamUpdated() external view returns (uint256);\r\n\tfunction setRewardParamUpdated(uint256 _rewardParamUpdated) external returns (bool);\r\n\r\n\tfunction getGlobalRewardPerBlock() external view returns (uint256);\r\n\tfunction getGlobalRewardDecrement() external view returns (uint256);\r\n\tfunction getGlobalRewardTotalAmount() external view returns (uint256);\r\n\tfunction getRewardParamUpdateRewardPerBlock() external view returns (uint256);\r\n\r\n\tfunction getTokenHandlerAddr(uint256 handlerID) external view returns (address);\r\n\tfunction getLiquidationManagerAddr() external view returns (address);\r\n\r\n\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\r\n\tfunction setLiquidationManagerAddr(address _liquidationManagerAddr) external returns (bool);\r\n\r\n\tfunction getInterestRewardUpdated() external view returns (uint256);\r\n\tfunction setInterestRewardUpdated(uint256 _interestRewardLastUpdated) external returns (bool);\r\n\r\n\tfunction getInterestUpdateRewardPerblock() external view returns (uint256);\r\n\r\n\tfunction getAlphaRate() external view returns (uint256);\r\n\r\n\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\r\n\r\n\tfunction getTokenHandlerExist(uint256 handlerID) external view returns (bool);\r\n\tfunction setTokenHandlerSupport(uint256 handlerID, bool support) external returns (bool);\r\n\r\n\tfunction setTokenHandler(uint256 handlerID, address handlerAddr) external returns (bool);\r\n\r\n\tfunction setGlobalRewardPerBlock(uint256 _globalRewardPerBlock) external returns (bool);\r\n\tfunction setGlobalRewardDecrement(uint256 _globalRewardDecrement) external returns (bool);\r\n\tfunction setGlobalRewardTotalAmount(uint256 _globalRewardTotalAmount) external returns (bool);\r\n\r\n\t/* unused in marketManager (for savig function signature)\r\n\tfunction setAlphaRate(uint256 _alphaRate) external returns (bool);\r\n\r\n\tfunction getAlphaLastUpdated() external view returns (uint256);\r\n\tfunction setAlphaLastUpdated(uint256 _alphaLastUpdated) external returns (bool);\r\n\r\n\tfunction setRewardParamUpdateRewardPerBlock(uint256 _rewardParamUpdateRewardPerBlock) external returns (bool);\r\n\r\n\tfunction setInterestUpdateRewardPerblock(uint256 _interestUpdateRewardPerblock) external returns (bool);\r\n\r\n\tfunction setTokenHandlerAddr(uint256 handlerID, address handlerAddr) external returns (bool);\r\n\tfunction setTokenHandlerExist(uint256 handlerID, bool exist) external returns (bool);\r\n\r\n\tfunction setManagerAddr(address _managerAddr) external returns (bool);\r\n\t*/\r\n}\r\n\r\n// File: contracts/interfacesForManager/oracleProxyInterfaceForManager.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's oracle proxy interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface oracleProxyInterfaceForManager  {\r\n\tfunction getTokenPrice(uint256 tokenID) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/liquidationManagerInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's liquidation manager interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface liquidationManagerInterface  {\r\n\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\r\n\tfunction partialLiquidation(address payable delinquentBorrower, uint256 targetHandler, uint256 liquidateAmount, uint256 receiveHandler) external returns (uint256);\r\n\tfunction checkLiquidation(address payable userAddr) external view returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/proxyContractInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's proxy interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface proxyContractInterface  {\r\n\tfunction handlerProxy(bytes memory data) external returns (bool, bytes memory);\r\n\tfunction handlerViewProxy(bytes memory data) external view returns (bool, bytes memory);\r\n\tfunction siProxy(bytes memory data) external returns (bool, bytes memory);\r\n\tfunction siViewProxy(bytes memory data) external view returns (bool, bytes memory);\r\n}\r\n\r\n// File: contracts/interfaces/tokenInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external ;\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external ;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/Errors.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ncontract Modifier {\r\n    string internal constant ONLY_OWNER = \"O\";\r\n    string internal constant ONLY_MANAGER = \"M\";\r\n    string internal constant CIRCUIT_BREAKER = \"emergency\";\r\n}\r\n\r\ncontract ManagerModifier is Modifier {\r\n    string internal constant ONLY_HANDLER = \"H\";\r\n    string internal constant ONLY_LIQUIDATION_MANAGER = \"LM\";\r\n    string internal constant ONLY_BREAKER = \"B\";\r\n}\r\n\r\ncontract HandlerDataStorageModifier is Modifier {\r\n    string internal constant ONLY_BIFI_CONTRACT = \"BF\";\r\n}\r\n\r\ncontract SIDataStorageModifier is Modifier {\r\n    string internal constant ONLY_SI_HANDLER = \"SI\";\r\n}\r\n\r\ncontract HandlerErrors is Modifier {\r\n    string internal constant USE_VAULE = \"use value\";\r\n    string internal constant USE_ARG = \"use arg\";\r\n    string internal constant EXCEED_LIMIT = \"exceed limit\";\r\n    string internal constant NO_LIQUIDATION = \"no liquidation\";\r\n    string internal constant NO_LIQUIDATION_REWARD = \"no enough reward\";\r\n    string internal constant NO_EFFECTIVE_BALANCE = \"not enough balance\";\r\n    string internal constant TRANSFER = \"err transfer\";\r\n}\r\n\r\ncontract SIErrors is Modifier { }\r\n\r\ncontract InterestErrors is Modifier { }\r\n\r\ncontract LiquidationManagerErrors is Modifier {\r\n    string internal constant NO_DELINQUENT = \"not delinquent\";\r\n}\r\n\r\ncontract ManagerErrors is ManagerModifier {\r\n    string internal constant REWARD_TRANSFER = \"RT\";\r\n    string internal constant UNSUPPORTED_TOKEN = \"UT\";\r\n}\r\n\r\ncontract OracleProxyErrors is Modifier {\r\n    string internal constant ZERO_PRICE = \"price zero\";\r\n}\r\n\r\ncontract RequestProxyErrors is Modifier { }\r\n\r\ncontract ManagerDataStorageErrors is ManagerModifier {\r\n    string internal constant NULL_ADDRESS = \"err addr null\";\r\n}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @title BiFi's safe-math Contract\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\nlibrary SafeMath {\r\n  uint256 internal constant unifiedPoint = 10 ** 18;\r\n\t/******************** Safe Math********************/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"a\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _sub(a, b, \"s\");\r\n\t}\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _mul(a, b);\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(a, b, \"d\");\r\n\t}\r\n\r\n\tfunction _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b <= a, errorMessage);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction _mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tif (a == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a* b;\r\n\t\trequire((c / a) == b, \"m\");\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b > 0, errorMessage);\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\tfunction unifiedDiv(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(_mul(a, unifiedPoint), b, \"d\");\r\n\t}\r\n\r\n\tfunction unifiedMul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _div(_mul(a, b), unifiedPoint, \"m\");\r\n\t}\r\n}\r\n\r\n// File: contracts/interfaces/observerInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's observer interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface observerInterface {\r\n    function getAlphaBaseAsset() external view returns (uint256[] memory);\r\n    function setChainGlobalRewardPerblock(uint256 _idx, uint256 globalRewardPerBlocks) external returns (bool);\r\n    function updateChainMarketInfo(uint256 _idx, uint256 chainDeposit, uint256 chainBorrow) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/marketHandlerInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's market handler interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface marketHandlerInterface  {\r\n\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\r\n\tfunction setCircuitBreakWithOwner(bool _emergency) external returns (bool);\r\n\r\n\tfunction getTokenName() external view returns (string memory);\r\n\r\n\tfunction ownershipTransfer(address payable newOwner) external returns (bool);\r\n\r\n\tfunction deposit(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\r\n\tfunction withdraw(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\r\n\tfunction borrow(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\r\n\tfunction repay(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\r\n\r\n\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\r\n\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 liquidationAmountWithReward, address payable liquidator) external returns (uint256);\r\n\r\n\tfunction getTokenHandlerLimit() external view returns (uint256, uint256);\r\n    function getTokenHandlerBorrowLimit() external view returns (uint256);\r\n\tfunction getTokenHandlerMarginCallLimit() external view returns (uint256);\r\n\tfunction setTokenHandlerBorrowLimit(uint256 borrowLimit) external returns (bool);\r\n\tfunction setTokenHandlerMarginCallLimit(uint256 marginCallLimit) external returns (bool);\r\n\r\n\tfunction getUserAmountWithInterest(address payable userAddr) external view returns (uint256, uint256);\r\n\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\r\n\r\n\tfunction getUserMaxBorrowAmount(address payable userAddr) external view returns (uint256);\r\n\tfunction getUserMaxWithdrawAmount(address payable userAddr) external view returns (uint256);\r\n\tfunction getUserMaxRepayAmount(address payable userAddr) external view returns (uint256);\r\n\r\n\tfunction checkFirstAction() external returns (bool);\r\n\tfunction applyInterest(address payable userAddr) external returns (uint256, uint256);\r\n\r\n\tfunction reserveDeposit(uint256 unifiedTokenAmount) external payable returns (bool);\r\n\tfunction reserveWithdraw(uint256 unifiedTokenAmount) external returns (bool);\r\n\r\n\tfunction getDepositTotalAmount() external view returns (uint256);\r\n\tfunction getBorrowTotalAmount() external view returns (uint256);\r\n\r\n\tfunction getSIRandBIR() external view returns (uint256, uint256);\r\n}\r\n\r\n// File: contracts/interfaces/SIInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title BiFi's si interface\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ninterface SIInterface  {\r\n\tfunction setCircuitBreakWithOwner(bool emergency) external returns (bool);\r\n\tfunction setCircuitBreaker(bool emergency) external returns (bool);\r\n\r\n\tfunction updateRewardPerBlockLogic(uint256 _rewardPerBlock) external returns (bool);\r\n\tfunction updateRewardLane(address payable userAddr) external returns (bool);\r\n\r\n\tfunction getBetaRateBaseTotalAmount() external view returns (uint256);\r\n\tfunction getBetaRateBaseUserAmount(address payable userAddr) external view returns (uint256);\r\n\r\n\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\r\n\r\n\tfunction getUserRewardInfo(address payable userAddr) external view returns (uint256, uint256, uint256);\r\n\r\n\tfunction claimRewardAmountUser(address payable userAddr) external returns (uint256);\r\n}\r\n\r\n// File: contracts/marketManager/tokenManager.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n* @title Bifi's marketManager contract\r\n* @notice Implement business logic and manage handlers\r\n* @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n*/\r\ncontract etherManager is marketManagerInterface, ManagerErrors {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public owner;\r\n\tmapping(address => bool) operators;\r\n\tmapping(address => Breaker) internal breakerTable;\r\n\r\n\tbool public emergency = false;\r\n\r\n\tmanagerDataStorageInterfaceForManager internal dataStorageInstance;\r\n\toracleProxyInterfaceForManager internal oracleProxy;\r\n\r\n\t/* feat: manager reward token instance*/\r\n\tIERC20 internal rewardErc20Instance;\r\n\r\n\tobserverInterface public observer;\r\n\r\n\tuint256 public tokenHandlerLength;\r\n\r\n\tevent HandlerRewardUpdate(uint256 handlerID, uint256 alphaBaseAsset, uint256 rewardPerBlocks);\r\n\tevent ChainRewardUpdate(uint256 chainID, uint256 alphaBaseAsset, uint256 rewardPerBlocks);\r\n\r\n\tstruct UserAssetsInfo {\r\n\t\tuint256 depositAssetSum;\r\n\t\tuint256 borrowAssetSum;\r\n\t\tuint256 marginCallLimitSum;\r\n\t\tuint256 depositAssetBorrowLimitSum;\r\n\t\tuint256 depositAsset;\r\n\t\tuint256 borrowAsset;\r\n\t\tuint256 price;\r\n\t\tuint256 callerPrice;\r\n\t\tuint256 depositAmount;\r\n\t\tuint256 borrowAmount;\r\n\t\tuint256 borrowLimit;\r\n\t\tuint256 marginCallLimit;\r\n\t\tuint256 callerBorrowLimit;\r\n\t\tuint256 userBorrowableAsset;\r\n\t\tuint256 withdrawableAsset;\r\n\t}\r\n\r\n\tstruct Breaker {\r\n\t\tbool auth;\r\n\t\tbool tried;\r\n\t}\r\n\r\n\tstruct ContractInfo {\r\n\t\tbool support;\r\n\t\taddress addr;\r\n\r\n\t\tproxyContractInterface tokenHandler;\r\n\t\tbytes data;\r\n\r\n\t\tmarketHandlerInterface handlerFunction;\r\n\t\tSIInterface siFunction;\r\n\r\n\t\toracleProxyInterfaceForManager oracleProxy;\r\n\t\tmanagerDataStorageInterfaceForManager managerDataStorage;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == owner, ONLY_OWNER);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyHandler(uint256 handlerID) {\r\n\t\t_isHandler(handlerID);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyOperators {\r\n\t\taddress payable sender = msg.sender;\r\n\t\trequire(operators[sender] || sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction _isHandler(uint256 handlerID) internal view {\r\n\t\taddress msgSender = msg.sender;\r\n\t\trequire((msgSender == dataStorageInstance.getTokenHandlerAddr(handlerID)) || (msgSender == owner), ONLY_HANDLER);\r\n\t}\r\n\r\n\tmodifier onlyLiquidationManager {\r\n\t\t_isLiquidationManager();\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction _isLiquidationManager() internal view {\r\n\t\taddress msgSender = msg.sender;\r\n\t\trequire((msgSender == dataStorageInstance.getLiquidationManagerAddr()) || (msgSender == owner), ONLY_LIQUIDATION_MANAGER);\r\n\t}\r\n\r\n\tmodifier circuitBreaker {\r\n\t\t_isCircuitBreak();\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction _isCircuitBreak() internal view {\r\n\t\trequire((!emergency) || (msg.sender == owner), CIRCUIT_BREAKER);\r\n\t}\r\n\r\n\tmodifier onlyBreaker {\r\n\t\t_isBreaker();\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction _isBreaker() internal view {\r\n\t\trequire(breakerTable[msg.sender].auth, ONLY_BREAKER);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Constructor for marketManager\r\n\t* @param managerDataStorageAddr The address of the manager storage contract\r\n\t* @param oracleProxyAddr The address of oracle proxy contract (e.g., price feeds)\r\n\t* @param breaker The address of default circuit breaker\r\n\t* @param erc20Addr The address of reward token (ERC-20)\r\n\t*/\r\n\tconstructor (address managerDataStorageAddr, address oracleProxyAddr, address breaker, address erc20Addr) public\r\n\t{\r\n\t\towner = msg.sender;\r\n\t\tdataStorageInstance = managerDataStorageInterfaceForManager(managerDataStorageAddr);\r\n\t\toracleProxy = oracleProxyInterfaceForManager(oracleProxyAddr);\r\n\t\trewardErc20Instance = IERC20(erc20Addr);\r\n\t\tbreakerTable[owner].auth = true;\r\n\t\tbreakerTable[breaker].auth = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfer ownership\r\n\t* @param _owner the address of the new owner\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction ownershipTransfer(address payable _owner) onlyOwner public returns (bool)\r\n\t{\r\n\t\towner = _owner;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setOperator(address payable adminAddr, bool flag) onlyOwner external returns (bool) {\r\n\t\toperators[adminAddr] = flag;\r\n\t\treturn flag;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Set the address of oracleProxy contract\r\n\t* @param oracleProxyAddr The address of oracleProxy contract\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setOracleProxy(address oracleProxyAddr) onlyOwner external override returns (bool)\r\n\t{\r\n\t\toracleProxy = oracleProxyInterfaceForManager(oracleProxyAddr);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Set the address of BiFi reward token contract\r\n\t* @param erc20Addr The address of BiFi reward token contract\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setRewardErc20(address erc20Addr) onlyOwner public returns (bool)\r\n\t{\r\n\t\trewardErc20Instance = IERC20(erc20Addr);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Authorize admin user for circuitBreaker\r\n\t* @param _target The address of the circuitBreaker admin user.\r\n\t* @param _status The boolean status of circuitBreaker (on/off)\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setBreakerTable(address _target, bool _status) onlyOwner external override returns (bool)\r\n\t{\r\n\t\tbreakerTable[_target].auth = _status;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Set circuitBreak to freeze/unfreeze all handlers\r\n\t* @param _emergency The boolean status of circuitBreaker (on/off)\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setCircuitBreaker(bool _emergency) onlyBreaker external override returns (bool)\r\n\t{\r\n\t\tfor (uint256 handlerID = 0; handlerID < tokenHandlerLength; handlerID++)\r\n\t\t{\r\n\t\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\r\n\r\n\t\t\t// use delegate call via handler proxy\r\n\t\t\t// for token handlers\r\n\t\t\tbytes memory callData = abi.encodeWithSelector(\r\n\t\t\t\tmarketHandlerInterface\r\n\t\t\t\t.setCircuitBreaker.selector,\r\n\t\t\t\t_emergency\r\n\t\t\t);\r\n\r\n\t\t\ttokenHandler.handlerProxy(callData);\r\n\t\t\ttokenHandler.siProxy(callData);\r\n\t\t}\r\n\r\n\t\tliquidationManagerInterface liquidationManager = liquidationManagerInterface(dataStorageInstance.getLiquidationManagerAddr());\r\n\t\tliquidationManager.setCircuitBreaker(_emergency);\r\n\t\temergency = _emergency;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the circuitBreak status\r\n\t* @return The circuitBreak status\r\n\t*/\r\n\tfunction getCircuitBreaker() external view override returns (bool)\r\n\t{\r\n\t\treturn emergency;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get information for a handler\r\n\t* @param handlerID Handler ID\r\n\t* @return (success or failure, handler address, handler name)\r\n\t*/\r\n\tfunction getTokenHandlerInfo(uint256 handlerID) external view override returns (bool, address, string memory)\r\n\t{\r\n\t\tbool support;\r\n\t\taddress tokenHandlerAddr;\r\n\t\tstring memory tokenName;\r\n\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\r\n\t\t{\r\n\t\t\ttokenHandlerAddr = dataStorageInstance.getTokenHandlerAddr(handlerID);\r\n\t\t\tproxyContractInterface tokenHandler = proxyContractInterface(tokenHandlerAddr);\r\n\t\t\tbytes memory data;\r\n\t\t\t(, data) = tokenHandler.handlerViewProxy(\r\n\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\tmarketHandlerInterface\r\n\t\t\t\t\t.getTokenName.selector\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t\ttokenName = abi.decode(data, (string));\r\n\t\t\tsupport = true;\r\n\t\t}\r\n\r\n\t\treturn (support, tokenHandlerAddr, tokenName);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Register a handler\r\n\t* @param handlerID Handler ID and address\r\n\t* @param tokenHandlerAddr The handler address\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction handlerRegister(uint256 handlerID, address tokenHandlerAddr) onlyOwner external override returns (bool)\r\n\t{\r\n    \tdataStorageInstance.setTokenHandler(handlerID, tokenHandlerAddr);\r\n\t\ttokenHandlerLength = tokenHandlerLength + 1;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Set a liquidation manager contract\r\n\t* @param liquidationManagetAddr The address of liquidiation manager\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setLiquidationManager(address liquidationManagetAddr) onlyOwner external override returns (bool)\r\n\t{\r\n\t\tdataStorageInstance.setLiquidationManagerAddr(liquidationManagetAddr);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Update the (SI) rewards for a user\r\n\t* @param userAddr The address of the user\r\n\t* @param callerID The handler ID\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction rewardUpdateOfInAction(address payable userAddr, uint256 callerID) external override returns (bool)\r\n\t{\r\n\t\tContractInfo memory handlerInfo;\r\n\t\t(handlerInfo.support, handlerInfo.addr) = dataStorageInstance.getTokenHandlerInfo(callerID);\r\n\t\tif (handlerInfo.support)\r\n\t\t{\r\n\t\t\tproxyContractInterface tokenHandler;\r\n\t\t\ttokenHandler = proxyContractInterface(handlerInfo.addr);\r\n\t\t\ttokenHandler.siProxy(\r\n\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\tSIInterface\r\n\t\t\t\t\t.updateRewardLane.selector,\r\n\t\t\t\t\tuserAddr\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Update interest of a user for a handler (internal)\r\n\t* @param userAddr The user address\r\n\t* @param callerID The handler ID\r\n\t* @param allFlag Flag for the full calculation mode (calculting for all handlers)\r\n\t* @return (uint256, uint256, uint256, uint256, uint256, uint256)\r\n\t*/\r\n\tfunction applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external override returns (uint256, uint256, uint256, uint256, uint256, uint256)\r\n\t{\r\n\t\tUserAssetsInfo memory userAssetsInfo;\r\n\t\tContractInfo memory handlerInfo;\r\n\t\thandlerInfo.oracleProxy = oracleProxy;\r\n\t\thandlerInfo.managerDataStorage = dataStorageInstance;\r\n\r\n\t\t/* From all handlers, get the token price, margin call limit, borrow limit */\r\n\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\r\n\t\t{\r\n\t\t\t(handlerInfo.support, handlerInfo.addr) = handlerInfo.managerDataStorage.getTokenHandlerInfo(handlerID);\r\n\t\t\tif (handlerInfo.support)\r\n\t\t\t{\r\n\t\t\t\thandlerInfo.tokenHandler = proxyContractInterface(handlerInfo.addr);\r\n\r\n\t\t\t\t/* If the full-calculation mode is not set, work on the given handler only */\r\n\t\t\t\tif ((handlerID == callerID) || allFlag)\r\n\t\t\t\t{\r\n\t\t\t\t\thandlerInfo.tokenHandler.siProxy(\r\n\t\t\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\t\t\thandlerInfo.siFunction\r\n\t\t\t\t\t\t\t.updateRewardLane.selector,\r\n\t\t\t\t\t\t\tuserAddr\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t\t(, handlerInfo.data) = handlerInfo.tokenHandler.handlerProxy(\r\n\t\t\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\t\t\thandlerInfo.handlerFunction\r\n\t\t\t\t\t\t\t.applyInterest.selector,\r\n\t\t\t\t\t\t\tuserAddr\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t(userAssetsInfo.depositAmount, userAssetsInfo.borrowAmount) = abi.decode(handlerInfo.data, (uint256, uint256));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t/* Get the deposit and borrow amount for the user */\r\n\t\t\t\t\t(, handlerInfo.data) = handlerInfo.tokenHandler.handlerViewProxy(\r\n\t\t\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\t\t\thandlerInfo.handlerFunction\r\n\t\t\t\t\t\t\t.getUserAmount.selector,\r\n\t\t\t\t\t\t\tuserAddr\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t\t(userAssetsInfo.depositAmount, userAssetsInfo.borrowAmount) = abi.decode(handlerInfo.data, (uint256, uint256));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t(, handlerInfo.data) = handlerInfo.tokenHandler.handlerViewProxy(\r\n\t\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\t\thandlerInfo.handlerFunction\r\n\t\t\t\t\t\t.getTokenHandlerLimit.selector\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t\t(userAssetsInfo.borrowLimit, userAssetsInfo.marginCallLimit) = abi.decode(handlerInfo.data, (uint256, uint256));\r\n\r\n\t\t\t\t/* Get the token price */\r\n\t\t\t\tif (handlerID == callerID)\r\n\t\t\t\t{\r\n\t\t\t\t\tuserAssetsInfo.price = handlerInfo.oracleProxy.getTokenPrice(handlerID);\r\n\t\t\t\t\tuserAssetsInfo.callerPrice = userAssetsInfo.price;\r\n\t\t\t\t\tuserAssetsInfo.callerBorrowLimit = userAssetsInfo.borrowLimit;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* If the user has no balance, the token handler can be ignored.*/\r\n\t\t\t\tif ((userAssetsInfo.depositAmount > 0) || (userAssetsInfo.borrowAmount > 0))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (handlerID != callerID)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuserAssetsInfo.price = handlerInfo.oracleProxy.getTokenPrice(handlerID);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* Compute the deposit parameters */\r\n\t\t\t\t\tif (userAssetsInfo.depositAmount > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuserAssetsInfo.depositAsset = userAssetsInfo.depositAmount.unifiedMul(userAssetsInfo.price);\r\n\t\t\t\t\t\tuserAssetsInfo.depositAssetBorrowLimitSum = userAssetsInfo.depositAssetBorrowLimitSum.add(userAssetsInfo.depositAsset.unifiedMul(userAssetsInfo.borrowLimit));\r\n\t\t\t\t\t\tuserAssetsInfo.marginCallLimitSum = userAssetsInfo.marginCallLimitSum.add(userAssetsInfo.depositAsset.unifiedMul(userAssetsInfo.marginCallLimit));\r\n\t\t\t\t\t\tuserAssetsInfo.depositAssetSum = userAssetsInfo.depositAssetSum.add(userAssetsInfo.depositAsset);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* Compute the borrow parameters */\r\n\t\t\t\t\tif (userAssetsInfo.borrowAmount > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tuserAssetsInfo.borrowAsset = userAssetsInfo.borrowAmount.unifiedMul(userAssetsInfo.price);\r\n\t\t\t\t\t\tuserAssetsInfo.borrowAssetSum = userAssetsInfo.borrowAssetSum.add(userAssetsInfo.borrowAsset);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif (userAssetsInfo.depositAssetBorrowLimitSum > userAssetsInfo.borrowAssetSum)\r\n\t\t{\r\n\t\t\t/* Set the amount that the user can borrow from the borrow limit and previous borrows. */\r\n\t\t\tuserAssetsInfo.userBorrowableAsset = userAssetsInfo.depositAssetBorrowLimitSum.sub(userAssetsInfo.borrowAssetSum);\r\n\r\n\t\t\t/* Set the allowed amount that the user can withdraw based on the user borrow */\r\n\t\t\tuserAssetsInfo.withdrawableAsset = userAssetsInfo.depositAssetBorrowLimitSum.sub(userAssetsInfo.borrowAssetSum).unifiedDiv(userAssetsInfo.callerBorrowLimit);\r\n\t\t}\r\n\r\n\t\t/* Return the calculated parameters */\r\n\t\treturn (userAssetsInfo.userBorrowableAsset.unifiedDiv(userAssetsInfo.callerPrice), userAssetsInfo.withdrawableAsset.unifiedDiv(userAssetsInfo.callerPrice), userAssetsInfo.marginCallLimitSum, userAssetsInfo.depositAssetSum, userAssetsInfo.borrowAssetSum, userAssetsInfo.callerPrice);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Reward the user (msg.sender) with the reward token after calculating interest.\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction interestUpdateReward() external override returns (bool)\r\n\t{\r\n\t\tuint256 thisBlock = block.number;\r\n\t\tuint256 interestRewardUpdated = dataStorageInstance.getInterestRewardUpdated();\r\n\t\tuint256 delta = thisBlock - interestRewardUpdated;\r\n\t\tif (delta == 0)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tdataStorageInstance.setInterestRewardUpdated(thisBlock);\r\n\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\r\n\t\t{\r\n\t\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\r\n\t\t\tbytes memory data;\r\n\t\t\t(, data) = tokenHandler.handlerProxy(\r\n\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\tmarketHandlerInterface\r\n\t\t\t\t\t.checkFirstAction.selector\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t/* transfer reward tokens */\r\n\t\treturn _rewardTransfer(msg.sender, delta.mul(dataStorageInstance.getInterestUpdateRewardPerblock()));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev (Update operation) update the rewards parameters.\r\n\t* @param userAddr The address of operator\r\n\t* @return Whether or not the operation succeed\r\n\t*/\r\n\tfunction updateRewardParams(address payable userAddr) onlyOperators external override returns (bool)\r\n\t{\r\n\t\tif (_determineRewardParams(userAddr))\r\n\t\t{\r\n\t\t\treturn _calcRewardParams(userAddr);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Claim all rewards for the user\r\n\t* @param userAddr The user address\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction rewardClaimAll(address payable userAddr) external override returns (uint256)\r\n\t{\r\n\t\tuint256 handlerID;\r\n\t\tuint256 claimAmountSum;\r\n\t\tfor (handlerID; handlerID < tokenHandlerLength; handlerID++)\r\n\t\t{\r\n\t\t\tclaimAmountSum = claimAmountSum.add(_claimHandlerRewardAmount(handlerID, userAddr));\r\n\t\t}\r\n\t\trequire(_rewardTransfer(userAddr, claimAmountSum));\r\n\t\treturn claimAmountSum;\r\n\t}\r\n\r\n\t/* TODO: comment */\r\n\tfunction claimHandlerReward(uint256 handlerID, address payable userAddr) external returns (uint256) {\r\n\t\tuint256 amount = _claimHandlerRewardAmount(handlerID, userAddr);\r\n\r\n\t\trequire(_rewardTransfer(userAddr, amount));\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n\t/* TODO: comment */\r\n\tfunction _claimHandlerRewardAmount(uint256 handlerID, address payable userAddr) internal returns (uint256) {\r\n\t\tbytes memory data;\r\n\r\n\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\r\n\t\ttokenHandler.siProxy(\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\tSIInterface\r\n\t\t\t\t.updateRewardLane.selector,\r\n\t\t\t\tuserAddr\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t\t/* Claim reward for a token handler */\r\n\t\t(, data) = tokenHandler.siProxy(\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\tSIInterface.claimRewardAmountUser.selector,\r\n\t\t\t\tuserAddr\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn abi.decode(data, (uint256));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfer reward tokens to owner (for administration)\r\n\t* @param _amount The amount of the reward token\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction ownerRewardTransfer(uint256 _amount) onlyOwner external override returns (bool)\r\n\t{\r\n\t\treturn _rewardTransfer(address(uint160(owner)), _amount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfer reward tokens to a user\r\n\t* @param userAddr The address of recipient\r\n\t* @param _amount The amount of the reward token\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction _rewardTransfer(address payable userAddr, uint256 _amount) internal returns (bool)\r\n\t{\r\n\t\tIERC20 _rewardERC20 = rewardErc20Instance;\r\n\r\n\t\tif(address(_rewardERC20) != address(0x0)) {\r\n\t\t\tuint256 beforeBalance = _rewardERC20.balanceOf(userAddr);\r\n\t\t\t_rewardERC20.transfer(userAddr, _amount);\r\n\t\t\trequire(_amount == _rewardERC20.balanceOf(userAddr).sub(beforeBalance), REWARD_TRANSFER);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* @dev (Update operation) update the rewards parameters (by using alpha- and\r\n\t  beta-score).\r\n\t* @param userAddr The address of the operator\r\n\t* @return Whether or not this process succeed\r\n\t*/\r\n\tfunction _determineRewardParams(address payable userAddr) internal returns (bool)\r\n\t{\r\n\t\tuint256 thisBlockNum = block.number;\r\n\t\tmanagerDataStorageInterfaceForManager _dataStorage = dataStorageInstance;\r\n\t\t/* The inactive period (delta) since the last action happens */\r\n\t\tuint256 delta = thisBlockNum - _dataStorage.getRewardParamUpdated();\r\n\t\t_dataStorage.setRewardParamUpdated(thisBlockNum);\r\n\t\tif (delta == 0)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* Rewards assigned for a block */\r\n\t\tuint256 globalRewardPerBlock = _dataStorage.getGlobalRewardPerBlock();\r\n\t\t/* Rewards decrement for a block. (Rewards per block monotonically decreases) */\r\n\t\tuint256 globalRewardDecrement = _dataStorage.getGlobalRewardDecrement();\r\n\t\t/* Total amount of rewards */\r\n\t\tuint256 globalRewardTotalAmount = _dataStorage.getGlobalRewardTotalAmount();\r\n\r\n\t\t/* Remaining periods for reward distribution */\r\n\t\tuint256 remainingPeriod = globalRewardPerBlock.unifiedDiv(globalRewardDecrement);\r\n\r\n\t\tif (remainingPeriod >= delta.mul(SafeMath.unifiedPoint))\r\n\t\t{\r\n\t\t\tremainingPeriod = remainingPeriod.sub(delta.mul(SafeMath.unifiedPoint));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn _epilogueOfDetermineRewardParams(_dataStorage, userAddr, delta, 0, globalRewardDecrement, 0);\r\n\t\t}\r\n\r\n\t\tif (globalRewardTotalAmount >= globalRewardPerBlock.mul(delta))\r\n\t\t{\r\n\t\t\tglobalRewardTotalAmount = globalRewardTotalAmount - globalRewardPerBlock.mul(delta);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn _epilogueOfDetermineRewardParams(_dataStorage, userAddr, delta, 0, globalRewardDecrement, 0);\r\n\t\t}\r\n\r\n\t\tglobalRewardPerBlock = globalRewardTotalAmount.mul(2).unifiedDiv(remainingPeriod.add(SafeMath.unifiedPoint));\r\n\t\t/* To incentivze the update operation, the operator get paid with the\r\n\t\treward token */\r\n\t\treturn _epilogueOfDetermineRewardParams(_dataStorage, userAddr, delta, globalRewardPerBlock, globalRewardDecrement, globalRewardTotalAmount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Epilogue of _determineRewardParams for code-size savings\r\n\t* @param _dataStorage interface of Manager Data Storage\r\n\t* @param userAddr User Address for Reward token transfer\r\n\t* @param _delta The inactive period (delta) since the last action happens\r\n\t* @param _globalRewardPerBlock Reward per block\r\n\t* @param _globalRewardDecrement Rewards decrement for a block\r\n\t* @param _globalRewardTotalAmount Total amount of rewards\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction _epilogueOfDetermineRewardParams(\r\n\t\tmanagerDataStorageInterfaceForManager _dataStorage,\r\n\t\taddress payable userAddr,\r\n\t\tuint256 _delta,\r\n\t\tuint256 _globalRewardPerBlock,\r\n\t\tuint256 _globalRewardDecrement,\r\n\t\tuint256 _globalRewardTotalAmount\r\n\t) internal returns (bool) {\r\n    // Set the reward model parameters\r\n    _dataStorage.setGlobalRewardPerBlock(_globalRewardPerBlock);\r\n\t\t_dataStorage.setGlobalRewardDecrement(_globalRewardDecrement);\r\n\t\t_dataStorage.setGlobalRewardTotalAmount(_globalRewardTotalAmount);\r\n\r\n\t\tuint256 rewardAmount = _delta.mul(_dataStorage.getRewardParamUpdateRewardPerBlock());\r\n\t\t/* To incentivze the update operation, the operator get paid with the\r\n\t\treward token */\r\n\t\t_rewardTransfer(userAddr, rewardAmount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Update rewards paramters of token handlers.\r\n\t* @param userAddr The address of operator\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction _calcRewardParams(address payable userAddr) internal returns (bool)\r\n\t{\r\n\t\tuint256 handlerLength = tokenHandlerLength;\r\n\t\tbytes memory data;\r\n\t\tuint256[] memory handlerAlphaRateBaseAsset = new uint256[](handlerLength);\r\n\t\tuint256[] memory chainAlphaRateBaseAsset;\r\n\t\tuint256 handlerID;\r\n\t\tuint256 alphaRateBaseGlobalAssetSum;\r\n\t\tfor (handlerID; handlerID < handlerLength; handlerID++)\r\n\t\t{\r\n\t\t\thandlerAlphaRateBaseAsset[handlerID] = _getAlphaBaseAsset(handlerID);\r\n\t\t\talphaRateBaseGlobalAssetSum = alphaRateBaseGlobalAssetSum.add(handlerAlphaRateBaseAsset[handlerID]);\r\n\t\t}\r\n\r\n\t\tchainAlphaRateBaseAsset = observer.getAlphaBaseAsset();\r\n\t\thandlerID = 0;\r\n\t\tfor (;handlerID < chainAlphaRateBaseAsset.length; handlerID++) {\r\n\t\t\talphaRateBaseGlobalAssetSum = alphaRateBaseGlobalAssetSum.add(chainAlphaRateBaseAsset[handlerID]);\r\n\t\t}\r\n\r\n\t\thandlerID = 0;\r\n\t\tuint256 globalRewardPerBlocks = dataStorageInstance.getGlobalRewardPerBlock();\r\n\r\n\t\tfor (handlerID; handlerID < handlerLength; handlerID++)\r\n\t\t{\r\n\t\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\r\n\t\t\t(, data) = tokenHandler.siProxy(\r\n\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\tSIInterface\r\n\t\t\t\t\t.updateRewardLane.selector,\r\n\t\t\t\t\tuserAddr\r\n\t\t\t\t)\r\n\t\t\t);\r\n\r\n\t\t\t/* Update reward parameter for the token handler */\r\n\t\t\tuint256 rewardPerBlocks = globalRewardPerBlocks\r\n\t\t\t\t\t\t\t\t.unifiedMul(\r\n\t\t\t\t\t\t\t\thandlerAlphaRateBaseAsset[handlerID]\r\n\t\t\t\t\t\t\t\t.unifiedDiv(alphaRateBaseGlobalAssetSum)\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\tdata = abi.encodeWithSelector(\r\n\t\t\t\tSIInterface.updateRewardPerBlockLogic.selector,\r\n\t\t\t\trewardPerBlocks\r\n\t\t\t);\r\n\t\t\t(, data) = tokenHandler.siProxy(data);\r\n\r\n\t\t\temit HandlerRewardUpdate(handlerID, handlerAlphaRateBaseAsset[handlerID], rewardPerBlocks);\r\n\t\t}\r\n\r\n\t\thandlerID = 0;\r\n\t\tfor (;handlerID < chainAlphaRateBaseAsset.length; handlerID++) {\r\n\t\t\tuint256 rewardPerBlocks = chainAlphaRateBaseAsset[handlerID]\r\n\t\t\t\t\t\t\t\t\t\t.unifiedDiv(alphaRateBaseGlobalAssetSum)\r\n\t\t\t\t\t\t\t\t\t\t.unifiedMul(globalRewardPerBlocks);\r\n\r\n\t\t\tobserver.setChainGlobalRewardPerblock(\r\n\t\t\t\thandlerID,\r\n\t\t\t\trewardPerBlocks\r\n\t\t\t);\r\n\t\t\temit ChainRewardUpdate(handlerID, chainAlphaRateBaseAsset[handlerID], rewardPerBlocks);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Calculate the alpha-score for the handler (in USD price)\r\n\t* @param _handlerID The handler ID\r\n\t* @return The alpha-score of the handler\r\n\t*/\r\n\tfunction _getAlphaBaseAsset(uint256 _handlerID) internal view returns (uint256)\r\n\t{\r\n\t\tbytes memory data;\r\n\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(_handlerID));\r\n\r\n    // TODO merge call\r\n\t\t(, data) = tokenHandler.handlerViewProxy(\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\tmarketHandlerInterface\r\n\t\t\t\t.getDepositTotalAmount.selector\r\n\t\t\t)\r\n\t\t);\r\n\t\tuint256 _depositAmount = abi.decode(data, (uint256));\r\n\r\n\t\t(, data) = tokenHandler.handlerViewProxy(\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\tmarketHandlerInterface\r\n\t\t\t\t.getBorrowTotalAmount.selector\r\n\t\t\t)\r\n\t\t);\r\n\t\tuint256 _borrowAmount = abi.decode(data, (uint256));\r\n\r\n\t\treturn _calcAlphaBaseAmount(\r\n              dataStorageInstance.getAlphaRate(),\r\n              _depositAmount,\r\n              _borrowAmount\r\n            )\r\n            .unifiedMul(_getTokenHandlerPrice(_handlerID));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Calculate the alpha-score for the handler (in token amount)\r\n\t* @param _alpha The alpha parameter\r\n\t* @param _depositAmount The total amount of deposit\r\n\t* @param _borrowAmount The total amount of borrow\r\n\t* @return The alpha-score of the handler (in token amount)\r\n\t*/\r\n\tfunction _calcAlphaBaseAmount(uint256 _alpha, uint256 _depositAmount, uint256 _borrowAmount) internal pure returns (uint256)\r\n\t{\r\n\t\treturn _depositAmount.unifiedMul(_alpha).add(_borrowAmount.unifiedMul(SafeMath.unifiedPoint.sub(_alpha)));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the token price of the handler\r\n\t* @param handlerID The handler ID\r\n\t* @return The token price of the handler\r\n\t*/\r\n\tfunction getTokenHandlerPrice(uint256 handlerID) external view override returns (uint256)\r\n\t{\r\n\t\treturn _getTokenHandlerPrice(handlerID);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the margin call limit of the handler (external)\r\n\t* @param handlerID The handler ID\r\n\t* @return The margin call limit\r\n\t*/\r\n\tfunction getTokenHandlerMarginCallLimit(uint256 handlerID) external view override returns (uint256)\r\n\t{\r\n\t\treturn _getTokenHandlerMarginCallLimit(handlerID);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the margin call limit of the handler (internal)\r\n\t* @param handlerID The handler ID\r\n\t* @return The margin call limit\r\n\t*/\r\n\tfunction _getTokenHandlerMarginCallLimit(uint256 handlerID) internal view returns (uint256)\r\n\t{\r\n\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\r\n\t\tbytes memory data;\r\n\t\t(, data) = tokenHandler.handlerViewProxy(\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\tmarketHandlerInterface\r\n\t\t\t\t.getTokenHandlerMarginCallLimit.selector\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn abi.decode(data, (uint256));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the borrow limit of the handler (external)\r\n\t* @param handlerID The handler ID\r\n\t* @return The borrow limit\r\n\t*/\r\n\tfunction getTokenHandlerBorrowLimit(uint256 handlerID) external view override returns (uint256)\r\n\t{\r\n\t\treturn _getTokenHandlerBorrowLimit(handlerID);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the borrow limit of the handler (internal)\r\n\t* @param handlerID The handler ID\r\n\t* @return The borrow limit\r\n\t*/\r\n\tfunction _getTokenHandlerBorrowLimit(uint256 handlerID) internal view returns (uint256)\r\n\t{\r\n\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\r\n\r\n\t\tbytes memory data;\r\n\t\t(, data) = tokenHandler.handlerViewProxy(\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\tmarketHandlerInterface\r\n\t\t\t\t.getTokenHandlerBorrowLimit.selector\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn abi.decode(data, (uint256));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the handler status of whether the handler is supported or not.\r\n\t* @param handlerID The handler ID\r\n\t* @return Whether the handler is supported or not\r\n\t*/\r\n\tfunction getTokenHandlerSupport(uint256 handlerID) external view override returns (bool)\r\n\t{\r\n\t\treturn dataStorageInstance.getTokenHandlerSupport(handlerID);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Set the length of the handler list\r\n\t* @param _tokenHandlerLength The length of the handler list\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setTokenHandlersLength(uint256 _tokenHandlerLength) onlyOwner external override returns (bool)\r\n\t{\r\n\t\ttokenHandlerLength = _tokenHandlerLength;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the length of the handler list\r\n\t* @return the length of the handler list\r\n\t*/\r\n\tfunction getTokenHandlersLength() external view override returns (uint256)\r\n\t{\r\n\t\treturn tokenHandlerLength;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the handler ID at the index in the handler list\r\n\t* @param index The index of the handler list (array)\r\n\t* @return The handler ID\r\n\t*/\r\n\tfunction getTokenHandlerID(uint256 index) external view override returns (uint256)\r\n\t{\r\n\t\treturn dataStorageInstance.getTokenHandlerID(index);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the amount of token that the user can borrow more\r\n\t* @param userAddr The address of user\r\n\t* @param handlerID The handler ID\r\n\t* @return The amount of token that user can borrow more\r\n\t*/\r\n\tfunction getUserExtraLiquidityAmount(address payable userAddr, uint256 handlerID) external view override returns (uint256)\r\n\t{\r\n\t\tuint256 depositCredit;\r\n\t\tuint256 borrowCredit;\r\n\t\t(depositCredit, borrowCredit) = _getUserTotalIntraCreditAsset(userAddr);\r\n\t\tif (depositCredit == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tif (depositCredit > borrowCredit)\r\n\t\t{\r\n\t\t\treturn depositCredit.sub(borrowCredit).unifiedDiv(_getTokenHandlerPrice(handlerID));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the deposit and borrow amount of the user with interest added\r\n\t* @param userAddr The address of user\r\n\t* @param handlerID The handler ID\r\n\t* @return The deposit and borrow amount of the user with interest\r\n\t*/\r\n\t/* about user market Information function*/\r\n\tfunction getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) external view override returns (uint256, uint256)\r\n\t{\r\n\t\treturn _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the depositTotalCredit and borrowTotalCredit\r\n\t* @param userAddr The address of the user\r\n\t* @return depositTotalCredit The amount that users can borrow (i.e. deposit * borrowLimit)\r\n\t* @return borrowTotalCredit The sum of borrow amount for all handlers\r\n\t*/\r\n\tfunction getUserTotalIntraCreditAsset(address payable userAddr) external view override returns (uint256, uint256)\r\n\t{\r\n\t\treturn _getUserTotalIntraCreditAsset(userAddr);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the borrow and margin call limits of the user for all handlers\r\n\t* @param userAddr The address of the user\r\n\t* @return userTotalBorrowLimitAsset the sum of borrow limit for all handlers\r\n\t* @return userTotalMarginCallLimitAsset the sume of margin call limit for handlers\r\n\t*/\r\n\tfunction getUserLimitIntraAsset(address payable userAddr) external view override returns (uint256, uint256)\r\n\t{\r\n\t\tuint256 userTotalBorrowLimitAsset;\r\n\t\tuint256 userTotalMarginCallLimitAsset;\r\n\r\n\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\r\n\t\t{\r\n\t\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\r\n\t\t\t{\r\n\t\t\t\tuint256 depositHandlerAsset;\r\n\t\t\t\tuint256 borrowHandlerAsset;\r\n\t\t\t\t(depositHandlerAsset, borrowHandlerAsset) = _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\r\n\t\t\t\tuint256 borrowLimit = _getTokenHandlerBorrowLimit(handlerID);\r\n\t\t\t\tuint256 marginCallLimit = _getTokenHandlerMarginCallLimit(handlerID);\r\n\t\t\t\tuint256 userBorrowLimitAsset = depositHandlerAsset.unifiedMul(borrowLimit);\r\n\t\t\t\tuint256 userMarginCallLimitAsset = depositHandlerAsset.unifiedMul(marginCallLimit);\r\n\t\t\t\tuserTotalBorrowLimitAsset = userTotalBorrowLimitAsset.add(userBorrowLimitAsset);\r\n\t\t\t\tuserTotalMarginCallLimitAsset = userTotalMarginCallLimitAsset.add(userMarginCallLimitAsset);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn (userTotalBorrowLimitAsset, userTotalMarginCallLimitAsset);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Get the maximum allowed amount to borrow of the user from the given handler\r\n\t* @param userAddr The address of the user\r\n\t* @param callerID The target handler to borrow\r\n\t* @return extraCollateralAmount The maximum allowed amount to borrow from\r\n\t  the handler.\r\n\t*/\r\n\tfunction getUserCollateralizableAmount(address payable userAddr, uint256 callerID) external view override returns (uint256)\r\n\t{\r\n\t\tuint256 userTotalBorrowAsset;\r\n\t\tuint256 depositAssetBorrowLimitSum;\r\n\t\tuint256 depositHandlerAsset;\r\n\t\tuint256 borrowHandlerAsset;\r\n\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\r\n\t\t{\r\n\t\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\r\n\t\t\t{\r\n\r\n\t\t\t\t(depositHandlerAsset, borrowHandlerAsset) = _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\r\n\t\t\t\tuserTotalBorrowAsset = userTotalBorrowAsset.add(borrowHandlerAsset);\r\n\t\t\t\tdepositAssetBorrowLimitSum = depositAssetBorrowLimitSum\r\n\t\t\t\t\t\t\t\t\t\t\t\t.add(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdepositHandlerAsset\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t.unifiedMul( _getTokenHandlerBorrowLimit(handlerID) )\r\n\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (depositAssetBorrowLimitSum > userTotalBorrowAsset)\r\n\t\t{\r\n\t\t\treturn depositAssetBorrowLimitSum\r\n\t\t\t\t\t.sub(userTotalBorrowAsset)\r\n\t\t\t\t\t.unifiedDiv( _getTokenHandlerBorrowLimit(callerID) )\r\n\t\t\t\t\t.unifiedDiv( _getTokenHandlerPrice(callerID) );\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Partial liquidation for a user\r\n\t* @param delinquentBorrower The address of the liquidation target\r\n\t* @param liquidateAmount The amount to liquidate\r\n\t* @param liquidator The address of the liquidator (liquidation operator)\r\n\t* @param liquidateHandlerID The hander ID of the liquidating asset\r\n\t* @param rewardHandlerID The handler ID of the reward token for the liquidator\r\n\t* @return (uint256, uint256, uint256)\r\n\t*/\r\n\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 liquidateHandlerID, uint256 rewardHandlerID) onlyLiquidationManager external override returns (uint256, uint256, uint256)\r\n\t{\r\n\t\taddress tokenHandlerAddr = dataStorageInstance.getTokenHandlerAddr(liquidateHandlerID);\r\n\t\tproxyContractInterface tokenHandler = proxyContractInterface(tokenHandlerAddr);\r\n\t\tbytes memory data;\r\n\r\n\t\tdata = abi.encodeWithSelector(\r\n\t\t\tmarketHandlerInterface\r\n\t\t\t.partialLiquidationUser.selector,\r\n\r\n\t\t\tdelinquentBorrower,\r\n\t\t\tliquidateAmount,\r\n\t\t\tliquidator,\r\n\t\t\trewardHandlerID\r\n\t\t);\r\n\t\t(, data) = tokenHandler.handlerProxy(data);\r\n\r\n\t\treturn abi.decode(data, (uint256, uint256, uint256));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the maximum liquidation reward by checking sufficient reward\r\n\t  amount for the liquidator.\r\n\t* @param delinquentBorrower The address of the liquidation target\r\n\t* @param liquidateHandlerID The hander ID of the liquidating asset\r\n\t* @param liquidateAmount The amount to liquidate\r\n\t* @param rewardHandlerID The handler ID of the reward token for the liquidator\r\n\t* @param rewardRatio delinquentBorrowAsset / delinquentDepositAsset\r\n\t* @return The maximum reward token amount for the liquidator\r\n\t*/\r\n\tfunction getMaxLiquidationReward(address payable delinquentBorrower, uint256 liquidateHandlerID, uint256 liquidateAmount, uint256 rewardHandlerID, uint256 rewardRatio) external view override returns (uint256)\r\n\t{\r\n\t\tuint256 liquidatePrice = _getTokenHandlerPrice(liquidateHandlerID);\r\n\t\tuint256 rewardPrice = _getTokenHandlerPrice(rewardHandlerID);\r\n\t\tuint256 delinquentBorrowerRewardDeposit;\r\n\t\t(delinquentBorrowerRewardDeposit, ) = _getHandlerAmount(delinquentBorrower, rewardHandlerID);\r\n\t\tuint256 rewardAsset = delinquentBorrowerRewardDeposit.unifiedMul(rewardPrice).unifiedMul(rewardRatio);\r\n\t\tif (liquidateAmount.unifiedMul(liquidatePrice) > rewardAsset)\r\n\t\t{\r\n\t\t\treturn rewardAsset.unifiedDiv(liquidatePrice);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn liquidateAmount;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Reward the liquidator\r\n\t* @param delinquentBorrower The address of the liquidation target\r\n\t* @param rewardAmount The amount of reward token\r\n\t* @param liquidator The address of the liquidator (liquidation operator)\r\n\t* @param handlerID The handler ID of the reward token for the liquidator\r\n\t* @return The amount of reward token\r\n\t*/\r\n\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 rewardAmount, address payable liquidator, uint256 handlerID) onlyLiquidationManager external override returns (uint256)\r\n\t{\r\n\t\taddress tokenHandlerAddr = dataStorageInstance.getTokenHandlerAddr(handlerID);\r\n\t\tproxyContractInterface tokenHandler = proxyContractInterface(tokenHandlerAddr);\r\n\t\tbytes memory data;\r\n\t\tdata = abi.encodeWithSelector(\r\n\t\t\tmarketHandlerInterface\r\n\t\t\t.partialLiquidationUserReward.selector,\r\n\r\n\t\t\tdelinquentBorrower,\r\n\t\t\trewardAmount,\r\n\t\t\tliquidator\r\n\t\t);\r\n\t\t(, data) = tokenHandler.handlerProxy(data);\r\n\r\n\t\treturn abi.decode(data, (uint256));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the deposit and borrow amount of the user for the handler (internal)\r\n\t* @param userAddr The address of user\r\n\t* @param handlerID The handler ID\r\n\t* @return The deposit and borrow amount\r\n\t*/\r\n\tfunction _getHandlerAmount(address payable userAddr, uint256 handlerID) internal view returns (uint256, uint256)\r\n\t{\r\n\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\r\n\t\tbytes memory data;\r\n\t\t(, data) = tokenHandler.handlerViewProxy(\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\tmarketHandlerInterface\r\n\t\t\t\t.getUserAmount.selector,\r\n\t\t\t\tuserAddr\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn abi.decode(data, (uint256, uint256));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Set the support stauts for the handler\r\n\t* @param handlerID the handler ID\r\n\t* @param support the support status (boolean)\r\n\t* @return true (TODO: validate results)\r\n\t*/\r\n\tfunction setHandlerSupport(uint256 handlerID, bool support) onlyOwner public returns (bool)\r\n\t{\r\n\t\trequire(!dataStorageInstance.getTokenHandlerExist(handlerID), UNSUPPORTED_TOKEN);\r\n\t\t/* activate or inactivate anyway*/\r\n\t\tdataStorageInstance.setTokenHandlerSupport(handlerID, support);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get owner's address of the manager contract\r\n\t* @return The address of owner\r\n\t*/\r\n\tfunction getOwner() public view returns (address)\r\n\t{\r\n\t\treturn owner;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the deposit and borrow amount of the user with interest added\r\n\t* @param userAddr The address of user\r\n\t* @param handlerID The handler ID\r\n\t* @return The deposit and borrow amount of the user with interest\r\n\t*/\r\n\tfunction _getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) internal view returns (uint256, uint256)\r\n\t{\r\n\t\tuint256 price = _getTokenHandlerPrice(handlerID);\r\n\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\r\n\t\tuint256 depositAmount;\r\n\t\tuint256 borrowAmount;\r\n\r\n\t\tbytes memory data;\r\n\t\t(, data) = tokenHandler.handlerViewProxy(\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\tmarketHandlerInterface.getUserAmountWithInterest.selector,\r\n\t\t\t\tuserAddr\r\n\t\t\t)\r\n\t\t);\r\n\t\t(depositAmount, borrowAmount) = abi.decode(data, (uint256, uint256));\r\n\r\n\t\tuint256 depositAsset = depositAmount.unifiedMul(price);\r\n\t\tuint256 borrowAsset = borrowAmount.unifiedMul(price);\r\n\t\treturn (depositAsset, borrowAsset);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the depositTotalCredit and borrowTotalCredit\r\n\t* @param userAddr The address of the user\r\n\t* @return depositTotalCredit The amount that users can borrow (i.e. deposit * borrowLimit)\r\n\t* @return borrowTotalCredit The sum of borrow amount for all handlers\r\n\t*/\r\n\tfunction _getUserTotalIntraCreditAsset(address payable userAddr) internal view returns (uint256, uint256)\r\n\t{\r\n\t\tuint256 depositTotalCredit;\r\n\t\tuint256 borrowTotalCredit;\r\n\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\r\n\t\t{\r\n\t\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\r\n\t\t\t{\r\n\t\t\t\tuint256 depositHandlerAsset;\r\n\t\t\t\tuint256 borrowHandlerAsset;\r\n\t\t\t\t(depositHandlerAsset, borrowHandlerAsset) = _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\r\n\t\t\t\tuint256 borrowLimit = _getTokenHandlerBorrowLimit(handlerID);\r\n\t\t\t\tuint256 depositHandlerCredit = depositHandlerAsset.unifiedMul(borrowLimit);\r\n\t\t\t\tdepositTotalCredit = depositTotalCredit.add(depositHandlerCredit);\r\n\t\t\t\tborrowTotalCredit = borrowTotalCredit.add(borrowHandlerAsset);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn (depositTotalCredit, borrowTotalCredit);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the token price for the handler\r\n\t* @param handlerID The handler id\r\n\t* @return The token price of the handler\r\n\t*/\r\n\tfunction _getTokenHandlerPrice(uint256 handlerID) internal view returns (uint256)\r\n\t{\r\n\t\treturn (oracleProxy.getTokenPrice(handlerID));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the address of reward token\r\n\t* @return The address of reward token\r\n\t*/\r\n\tfunction getRewardErc20() public view returns (address)\r\n\t{\r\n\t\treturn address(rewardErc20Instance);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the reward parameters\r\n\t* @return (uint256,uint256,uint256) rewardPerBlock, rewardDecrement, rewardTotalAmount\r\n\t*/\r\n\tfunction getGlobalRewardInfo() external view override returns (uint256, uint256, uint256)\r\n\t{\r\n\t\tmanagerDataStorageInterfaceForManager _dataStorage = dataStorageInstance;\r\n\t\treturn (_dataStorage.getGlobalRewardPerBlock(), _dataStorage.getGlobalRewardDecrement(), _dataStorage.getGlobalRewardTotalAmount());\r\n\t}\r\n\r\n\tfunction setObserverAddr(address observerAddr) onlyOwner external returns (bool) {\r\n\t\tobserver = observerInterface( observerAddr );\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"managerDataStorageAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleProxyAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"breaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc20Addr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"alphaBaseAsset\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlocks\",\"type\":\"uint256\"}],\"name\":\"ChainRewardUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"alphaBaseAsset\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlocks\",\"type\":\"uint256\"}],\"name\":\"HandlerRewardUpdate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"callerID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allFlag\",\"type\":\"bool\"}],\"name\":\"applyInterestHandlers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"claimHandlerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCircuitBreaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalRewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"delinquentBorrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidateHandlerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidateAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardHandlerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRatio\",\"type\":\"uint256\"}],\"name\":\"getMaxLiquidationReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardErc20\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"getTokenHandlerBorrowLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getTokenHandlerID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"getTokenHandlerInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"getTokenHandlerMarginCallLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"getTokenHandlerPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"getTokenHandlerSupport\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenHandlersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"callerID\",\"type\":\"uint256\"}],\"name\":\"getUserCollateralizableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"getUserExtraLiquidityAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"getUserIntraHandlerAssetWithInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"getUserLimitIntraAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"getUserTotalIntraCreditAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenHandlerAddr\",\"type\":\"address\"}],\"name\":\"handlerRegister\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestUpdateReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"observer\",\"outputs\":[{\"internalType\":\"contract observerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ownerRewardTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ownershipTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"delinquentBorrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidateAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidateHandlerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardHandlerID\",\"type\":\"uint256\"}],\"name\":\"partialLiquidationUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"delinquentBorrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"}],\"name\":\"partialLiquidationUserReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"rewardClaimAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"callerID\",\"type\":\"uint256\"}],\"name\":\"rewardUpdateOfInAction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setBreakerTable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_emergency\",\"type\":\"bool\"}],\"name\":\"setCircuitBreaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"handlerID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"setHandlerSupport\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidationManagetAddr\",\"type\":\"address\"}],\"name\":\"setLiquidationManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"observerAddr\",\"type\":\"address\"}],\"name\":\"setObserverAddr\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adminAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleProxyAddr\",\"type\":\"address\"}],\"name\":\"setOracleProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Addr\",\"type\":\"address\"}],\"name\":\"setRewardErc20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenHandlerLength\",\"type\":\"uint256\"}],\"name\":\"setTokenHandlersLength\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenHandlerLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"updateRewardParams\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"etherManager","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000034e45203669aadd0d6ac342538aa7b62c9128f4a0000000000000000000000006ba1ddd63a5680b7c666b74a50be28b24d507beb000000000000000000000000d297c9a45ac9851003448c52c2b2b72c116884650000000000000000000000002791bfd60d232150bff86b39b7146c0eaaa2ba81","EVMVersion":"Default","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5b17f2d7aec20100e632ecc23720dce84f4b8db86f7dc69d35b5636fe9869f65"}]}