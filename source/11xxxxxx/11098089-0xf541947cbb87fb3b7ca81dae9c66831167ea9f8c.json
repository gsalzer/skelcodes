{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.12;\n\n\n// \n// TODO: Needs testing to make sure math is correct and overflow/underflows are caught in all cases\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= b, \"BoringMath: Overflow\"); return c; }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"BoringMath: Underflow\"); return a - b; }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n        { if (a == 0) {return 0;} uint256 c = a * b; require(c / a == b, \"BoringMath: Overflow\"); return c; }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b > 0, \"BoringMath: Div by 0\"); return a / b; }\r\n}\n\n// \ninterface IOracle {\r\n    // Each oracle should have a set function. The first parameter will be 'address pair' and any parameters can come after.\r\n    // Setting should only be allowed ONCE for each pair.\r\n\r\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\r\n    function get(address pair) external returns (bool, uint256);\r\n\r\n    // Check the last exchange rate without any state changes\r\n    function peek(address pair) external view returns (uint256);\r\n}\n\n// \n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n// Edited by BoringCrypto\n// - removed GSN context\n// - removed comments (we all know this contract)\n// - updated solidity version\n// - made _owner public and renamed to owner\n// - simplified code\n// - onlyOwner modifier removed. Just copy the one line. Cheaper in gas, better readability and better error message.\n// TODO: Consider using the version that requires acceptance from new owner\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\n\n// \n// solium-disable security/no-inline-assembly\n// solium-disable security/no-low-level-calls\ninterface IPair {\r\n    function init(address vault_, address tokenCollateral, address tokenAsset, address oracle_, bytes calldata oracleData) external;\r\n}\n\ninterface IFlashLoaner {\r\n    function executeOperation(address token, uint256 amount, uint256 fee, bytes calldata params) external;\r\n}\n\ncontract Vault is Ownable {\r\n    using BoringMath for uint256;\r\n\r\n    event PairContractSet(address indexed pairContract, bool enabled);\r\n    event SwapperSet(address swapper, bool enabled);\r\n    event PairCreated(address indexed pairContract, address indexed tokenCollateral, address indexed tokenAsset, address oracle, address clone_address);\r\n    event FlashLoan(address indexed user, address indexed token, uint256 amount, uint256 fee);\r\n\r\n    mapping(address => bool) public pairContracts;\r\n    mapping(address => bool) public swappers;\r\n    mapping(address => bool) public isPair;\r\n    mapping(address => uint256) public feesPending;\r\n    address public feeTo;\r\n    address public dev = 0x9e6e344f94305d36eA59912b0911fE2c9149Ed3E;\r\n\r\n    function setPairContract(address pairContract, bool enabled) public onlyOwner() {\r\n        pairContracts[pairContract] = enabled;\r\n        emit PairContractSet(pairContract, enabled);\r\n    }\r\n\r\n    function setSwapper(address swapper, bool enabled) public onlyOwner() {\r\n        swappers[swapper] = enabled;\r\n        emit SwapperSet(swapper, enabled);\r\n    }\r\n\r\n    function setFeeTo(address newFeeTo) public onlyOwner {\r\n        feeTo = newFeeTo;\r\n    }\r\n\r\n    function setDev(address newDev) public {\r\n        require(msg.sender == dev, 'BentoBox: Not dev');\r\n        dev = newDev;\r\n    }\r\n\r\n    function deploy(address pairContract, address tokenCollateral, address tokenAsset, address oracle, bytes calldata oracleData) public {\r\n        require(pairContracts[pairContract], 'BentoBox: Pair Contract not whitelisted');\r\n        bytes20 targetBytes = bytes20(pairContract);\r\n        address clone_address;\r\n\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            clone_address := create(0, clone, 0x37)\r\n        }\r\n\r\n        IPair(clone_address).init(address(this), tokenCollateral, tokenAsset, oracle, oracleData);\r\n        isPair[clone_address] = true;\r\n\r\n        emit PairCreated(pairContract, tokenCollateral, tokenAsset, oracle, clone_address);\r\n    }\r\n\r\n    function transfer(address token, address to, uint256 amount) public {\r\n        require(isPair[msg.sender], \"BentoBox: Only pair contracts can transfer\");\r\n\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BentoBox: Transfer failed at ERC20\");\r\n    }\r\n\r\n    function transferFrom(address token, address from, uint256 amount) public {\r\n        require(isPair[msg.sender], \"BentoBox: Only pair contracts can transferFrom\");\r\n\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BentoBox: TransferFrom failed at ERC20\");\r\n    }\r\n\r\n    function flashLoan(address user, address token, uint256 amount, bytes calldata params) public {\r\n        transfer(token, user, amount);\r\n\r\n        uint256 fee = amount.mul(8).div(10000);\r\n\r\n        IFlashLoaner(user).executeOperation(token, amount, fee, params);\r\n\r\n        transferFrom(token, user, amount.add(fee));\r\n        feesPending[token] = feesPending[token].add(fee);\r\n        emit FlashLoan(user, token, amount, fee);\r\n    }\r\n\r\n    function withdrawFees(address token) public {\r\n        uint256 fees = feesPending[token].sub(1);\r\n        uint256 devFee = fees.div(10);\r\n        feesPending[token] = 1;  // Don't set it to 0 as that would increase the gas cost for the next accrue called by a user.\r\n        transfer(token, feeTo, fees.sub(devFee));\r\n        transfer(token, dev, devFee);\r\n    }\r\n}\n\n// \ncontract ERC20 {\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping (address => uint256)) allowance;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool success) {\r\n        if (balanceOf[msg.sender] >= amount && amount > 0 && balanceOf[to] + amount > balanceOf[to]) {\r\n            balanceOf[msg.sender] -= amount;\r\n            balanceOf[to] += amount;\r\n            emit Transfer(msg.sender, to, amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public returns (bool success) {\r\n        if (balanceOf[from] >= amount && allowance[from][msg.sender] >= amount && amount > 0 && balanceOf[to] + amount > balanceOf[to]) {\r\n            balanceOf[from] -= amount;\r\n            allowance[from][msg.sender] -= amount;\r\n            balanceOf[to] += amount;\r\n            emit Transfer(from, to, amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool success) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n}\n\n// \n// Copyright 2020 BoringCrypto - All rights reserved\n// WARNING!!! DO NOT USE!!! NOT YET TESTED + NOT YET SECURITY CONSIDERED + DEF. NOT YET AUDITED!!!\n// FOR CONCEPT TESTING ONLY!\n// solium-disable security/no-low-level-calls\ninterface IDelegateSwapper {\r\n    // Withdraws amountFrom 'from tokens' from the vault, turns it into at least amountToMin 'to tokens' and transfers those into the vault.\r\n    // Returns amount of tokens added to the vault.\r\n    function swap(address swapper, address from, address to, uint256 amountFrom, uint256 amountToMin) external returns (uint256);\r\n}\n\ninterface ISwapper {\r\n    function swap(address from, address to, uint256 amountFrom, uint256 amountTo, address profitTo) external;\r\n}\n\ninterface IERC20 {\r\n    function decimals() external returns (uint8);\r\n}\n\n// Special thanks to:\n// https://twitter.com/burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n// TODO: check all reentrancy paths\n// TODO: what to do when the entire pool is underwater?\n// TODO: ensure BoringMath is always used\n// We do allow supplying assets and borrowing, but the asset does NOT provide collateral as it's just silly and no UI should allow this\ncontract Pair is ERC20 {\r\n    using BoringMath for uint256;\r\n\r\n    // Keep at the top in this order for delegate calls to be able to access them\r\n    Vault public vault;\r\n    address public tokenCollateral;\r\n    address public tokenAsset;\r\n\r\n    mapping(address => uint256) public userCollateralShare;\r\n    // userAssetShare = balanceOf - the asset share is the token.\r\n    mapping(address => uint256) public userBorrowShare;\r\n\r\n    IOracle public oracle;\r\n\r\n    uint256 exchangeRate;\r\n\r\n    uint256 public lastBlockAccrued;\r\n\r\n    uint256 public totalCollateral;\r\n    uint256 public totalAsset; // Includes totalBorrow\r\n    uint256 public totalBorrow; // Total units of asset borrowed\r\n\r\n    uint256 public totalCollateralShare; // Total amount of shares in the collateral pool\r\n    // totalAssetShare = totalSupply - Total amount of shares in the asset pool\r\n    uint256 public totalBorrowShare;\r\n\r\n    uint256 public interestPerBlock;\r\n    uint256 public lastInterestBlock;\r\n\r\n    uint256 public colRate;     // Collateral rate used to calculate if the protocol can liquidate\r\n    uint256 public openColRate; // Collateral rate used to calculate if ANYONE can liquidate\r\n    uint256 public liqMultiplier;\r\n    uint256 public feesPending;\r\n\r\n    string public constant symbol = \"BENTO LP\";\r\n    string public constant name = \"Bento LP\";\r\n    uint8 public decimals;\r\n\r\n    event NewExchangeRate(uint256 rate);\r\n    event AddCollateral(address indexed user, uint256 amount, uint256 share);\r\n    event AddAsset(address indexed user, uint256 amount, uint256 share);\r\n    event AddBorrow(address indexed user, uint256 amount, uint256 share);\r\n    event RemoveCollateral(address indexed user, uint256 amount, uint256 share);\r\n    event RemoveAsset(address indexed user, uint256 amount, uint256 share);\r\n    event RemoveBorrow(address indexed user, uint256 amount, uint256 share);\r\n\r\n    function init(Vault vault_, address collateral_address, address asset_address, IOracle oracle_address, bytes calldata oracleData) public {\r\n        require(address(vault) == address(0), 'BentoBox: already initialized');\r\n        vault = vault_;\r\n        tokenCollateral = collateral_address;\r\n        tokenAsset = asset_address;\r\n        oracle = oracle_address;\r\n        (bool success,) = address(oracle).call(oracleData);\r\n        require(success, 'BentoBox: oracle init failed.');\r\n        lastInterestBlock = block.number;\r\n\r\n        interestPerBlock = 4566210045;  // 1% APR, with 1e18 being 100%\r\n\r\n        colRate = 75000; // 75%\r\n        openColRate = 77000; // 77%\r\n        liqMultiplier = 112000; // 12% more tokenCollateral\r\n\r\n        decimals = IERC20(asset_address).decimals();\r\n    }\r\n\r\n    function accrue() public {\r\n        uint256 blocks = block.number - lastBlockAccrued;\r\n        if (blocks == 0) {return;}\r\n        // The first time lastBlockAccrued will be 0, but also borrowed will be 0, so all good\r\n        uint256 extraAmount = totalBorrow.mul(interestPerBlock).mul(block.number - lastBlockAccrued).div(1e18);\r\n        uint256 feeAmount = extraAmount.div(10); // 10% of interest paid goes to fee\r\n        totalAsset = totalAsset.add(extraAmount.sub(feeAmount));\r\n        totalBorrow = totalBorrow.add(extraAmount);\r\n        feesPending = feesPending.add(feeAmount);\r\n        lastBlockAccrued = block.number;\r\n    }\r\n\r\n    function withdrawFees() public {\r\n        accrue();\r\n        uint256 fees = feesPending.sub(1);\r\n        uint256 devFee = fees.div(10);\r\n        feesPending = 1; // Don't set it to 0 as that would increase the gas cost for the next accrue called by a user.\r\n        vault.transfer(tokenAsset, vault.feeTo(), fees.sub(devFee));\r\n        vault.transfer(tokenAsset, vault.dev(), devFee);\r\n    }\r\n\r\n    function isSolvent(address user, bool open) public view returns (bool) {\r\n        // accrue must have already been called!\r\n        if (userBorrowShare[user] == 0) return true;\r\n        if (totalCollateralShare == 0) return false;\r\n\r\n        uint256 collateral = userCollateralShare[user].mul(totalCollateral).div(totalCollateralShare);\r\n        uint256 borrow = userBorrowShare[user].mul(totalBorrow).div(totalBorrowShare);\r\n\r\n        return collateral.mul(open ? openColRate : colRate).div(1e5) >= borrow.mul(exchangeRate).div(1e18);\r\n    }\r\n\r\n    // Gets the exchange rate. How much collateral to buy 1e18 asset.\r\n    function updateExchangeRate() public returns (uint256) {\r\n        (bool success, uint256 rate) = oracle.get(address(this));\r\n\r\n        // TODO: How to deal with unsuccessful fetch\r\n        if (success) {\r\n            exchangeRate = rate;\r\n            emit NewExchangeRate(rate);\r\n        }\r\n        return exchangeRate;\r\n    }\r\n\r\n    function updateInterestRate() public {\r\n        if (totalAsset == 0) {return;}\r\n        uint256 minimumInterest = 1141552511;    // 0.25% APR\r\n        uint256 maximumInterest = 4566210045000; // 1000% APR\r\n        uint256 targetMinUse = 700000000000000000; // 70%\r\n        uint256 targetMaxUse = 800000000000000000; // 80%\r\n\r\n        uint256 blocks = block.number - lastInterestBlock;\r\n        if (blocks == 0) {return;}\r\n        uint256 utilization = totalBorrow.mul(1e18).div(totalAsset);\r\n        uint256 newInterestPerBlock;\r\n        if (utilization < targetMinUse) {\r\n            uint256 underFactor = targetMinUse.sub(utilization).mul(1e18).div(targetMinUse);\r\n            uint256 scale = uint256(2000e36).add(underFactor.mul(underFactor).mul(blocks));\r\n            newInterestPerBlock = interestPerBlock.mul(2000e36).div(scale);\r\n            if (newInterestPerBlock < minimumInterest) {\r\n                newInterestPerBlock = minimumInterest;\r\n            }\r\n        } else if (utilization > targetMaxUse) {\r\n            uint256 overFactor = utilization.sub(targetMaxUse).mul(1e18).div(uint256(1e18).sub(targetMaxUse));\r\n            uint256 scale = uint256(2000e36).add(overFactor.mul(overFactor).mul(blocks));\r\n\r\n            newInterestPerBlock = interestPerBlock.mul(scale).div(2000e36);\r\n            if (newInterestPerBlock > maximumInterest) {\r\n                newInterestPerBlock = maximumInterest;\r\n            }\r\n        } else {return;}\r\n\r\n        interestPerBlock = newInterestPerBlock;\r\n        lastInterestBlock = block.number;\r\n    }\r\n\r\n    function _addCollateral(address user, uint256 amount) private {\r\n        uint256 newShare = totalCollateralShare == 0 ? amount : amount.mul(totalCollateralShare).div(totalCollateral);\r\n        userCollateralShare[user] = userCollateralShare[user].add(newShare);\r\n        totalCollateralShare = totalCollateralShare.add(newShare);\r\n        totalCollateral = totalCollateral.add(amount);\r\n        emit AddCollateral(msg.sender, amount, newShare);\r\n    }\r\n\r\n    function _addAsset(address user, uint256 amount) private {\r\n        uint256 newShare = totalSupply == 0 ? amount : amount.mul(totalSupply).div(totalAsset);\r\n        balanceOf[user] = balanceOf[user].add(newShare);\r\n        totalSupply = totalSupply.add(newShare);\r\n        totalAsset = totalAsset.add(amount);\r\n        emit AddAsset(msg.sender, amount, newShare);\r\n    }\r\n\r\n    function _addBorrow(address user, uint256 amount) private {\r\n        uint256 newShare = totalBorrowShare == 0 ? amount : amount.mul(totalBorrowShare).div(totalBorrow);\r\n        userBorrowShare[user] = userBorrowShare[user].add(newShare);\r\n        totalBorrowShare = totalBorrowShare.add(newShare);\r\n        totalBorrow = totalBorrow.add(amount);\r\n        emit AddBorrow(msg.sender, amount, newShare);\r\n    }\r\n\r\n    function _removeCollateralShare(address user, uint256 share) private returns (uint256) {\r\n        userCollateralShare[user] = userCollateralShare[user].sub(share);\r\n        uint256 amount = share.mul(totalCollateral).div(totalCollateralShare);\r\n        totalCollateralShare = totalCollateralShare.sub(share);\r\n        totalCollateral = totalCollateral.sub(amount);\r\n        emit RemoveCollateral(msg.sender, amount, share);\r\n        return amount;\r\n    }\r\n\r\n    function _removeAssetShare(address user, uint256 share) private returns (uint256) {\r\n        balanceOf[user] = balanceOf[user].sub(share);\r\n        uint256 amount = share.mul(totalAsset).div(totalSupply);\r\n        totalSupply = totalSupply.sub(share);\r\n        totalAsset = totalAsset.sub(amount);\r\n        emit RemoveAsset(msg.sender, amount, share);\r\n        return amount;\r\n    }\r\n\r\n    function _removeBorrowShare(address user, uint256 share) private returns (uint256) {\r\n        userBorrowShare[user] = userBorrowShare[user].sub(share);\r\n        uint256 amount = share.mul(totalBorrow).div(totalBorrowShare);\r\n        totalBorrowShare = totalBorrowShare.sub(share);\r\n        totalBorrow = totalBorrow.sub(amount);\r\n        emit RemoveBorrow(msg.sender, amount, share);\r\n        return amount;\r\n    }\r\n\r\n    function addCollateral(uint256 amount) public {\r\n        _addCollateral(msg.sender, amount);\r\n        vault.transferFrom(tokenCollateral, msg.sender, amount);\r\n    }\r\n\r\n    function addAsset(uint256 amount) public {\r\n        accrue();\r\n        updateInterestRate();\r\n        _addAsset(msg.sender, amount);\r\n        vault.transferFrom(tokenAsset, msg.sender, amount);\r\n    }\r\n\r\n    function removeCollateral(uint256 share, address to) public {\r\n        accrue();\r\n        uint256 amount = _removeCollateralShare(msg.sender, share);\r\n        require(isSolvent(msg.sender, false), 'BentoBox: user insolvent');\r\n        vault.transfer(tokenCollateral, to, amount);\r\n    }\r\n\r\n    function removeAsset(uint256 share, address to) public {\r\n        accrue();\r\n        updateInterestRate();\r\n        uint256 amount = _removeAssetShare(msg.sender, share);\r\n        vault.transfer(tokenAsset, to, amount);\r\n    }\r\n\r\n    function borrow(uint256 amount, address to) public {\r\n        require(amount <= totalAsset.sub(totalBorrow), 'BentoBox: not enough liquidity');\r\n        accrue();\r\n        updateInterestRate();\r\n        _addBorrow(msg.sender, amount);\r\n        require(isSolvent(msg.sender, false), 'BentoBox: user insolvent');\r\n        vault.transfer(tokenAsset, to, amount);\r\n    }\r\n\r\n    function repay(uint256 share) public {\r\n        accrue();\r\n        updateInterestRate();\r\n        uint256 amount = _removeBorrowShare(msg.sender, share);\r\n        vault.transferFrom(tokenAsset, msg.sender, amount);\r\n    }\r\n\r\n    function short(address swapper, uint256 amountAsset, uint256 minAmountCollateral) public {\r\n        require(amountAsset <= totalAsset.sub(totalBorrow), 'BentoBox: not enough liquidity');\r\n\r\n        require(vault.swappers(swapper), 'BentoBox: Invalid swapper');\r\n        accrue();\r\n        updateInterestRate();\r\n        _addBorrow(msg.sender, amountAsset);\r\n\r\n        (bool success, bytes memory result) = swapper.delegatecall(\r\n            abi.encodeWithSignature(\"swap(address,address,address,uint256,uint256)\", swapper, tokenAsset, tokenCollateral, amountAsset, minAmountCollateral));\r\n        require(success, 'BentoBox: Swap failed');\r\n        uint256 amountCollateral = abi.decode(result, (uint256));\r\n        _addCollateral(msg.sender, amountCollateral);\r\n\r\n        require(isSolvent(msg.sender, false), 'BentoBox: user insolvent');\r\n    }\r\n\r\n    function unwind(address swapper, uint256 borrowShare, uint256 maxAmountCollateral) public {\r\n        require(vault.swappers(swapper), 'BentoBox: Invalid swapper');\r\n        accrue();\r\n        updateInterestRate();\r\n\r\n        uint256 borrowAmount = _removeBorrowShare(msg.sender, borrowShare);\r\n\r\n        (bool success, bytes memory result) = swapper.delegatecall(\r\n            abi.encodeWithSignature(\"swapExact(address,address,address,uint256,uint256)\", swapper, tokenCollateral, tokenAsset, maxAmountCollateral, borrowAmount));\r\n        require(success, 'BentoBox: Swap failed');\r\n        _removeCollateralShare(msg.sender, abi.decode(result, (uint256)).mul(totalCollateralShare).div(totalCollateral));\r\n\r\n        require(isSolvent(msg.sender, false), 'BentoBox: user insolvent');\r\n    }\r\n\r\n    function liquidate(address[] calldata users, uint256[] calldata borrowShares, address to, address swapper, bool open) public {\r\n        accrue();\r\n        updateExchangeRate();\r\n        updateInterestRate();\r\n\r\n        uint256 allCollateralAmount;\r\n        uint256 allCollateralShare;\r\n        uint256 allBorrowAmount;\r\n        uint256 allBorrowShare;\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            address user = users[i];\r\n            if (!isSolvent(user, open)) {\r\n                uint256 borrowShare = borrowShares[i];\r\n                uint256 borrowAmount = borrowShare.mul(totalBorrow).div(totalBorrowShare);\r\n                uint256 collateralAmount = borrowAmount.mul(1e13).mul(liqMultiplier).div(exchangeRate);\r\n                uint256 collateralShare = collateralAmount.mul(totalCollateralShare).div(totalCollateral);\r\n\r\n                userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);\r\n                userBorrowShare[user] = userBorrowShare[user].sub(borrowShare);\r\n                emit RemoveCollateral(user, collateralAmount, collateralShare);\r\n                emit RemoveBorrow(user, borrowAmount, borrowShare);\r\n\r\n                // Keep totals\r\n                allCollateralAmount = allCollateralAmount.add(collateralAmount);\r\n                allCollateralShare = allCollateralShare.add(collateralShare);\r\n                allBorrowAmount = allBorrowAmount.add(borrowAmount);\r\n                allBorrowShare = allBorrowShare.add(borrowShare);\r\n            }\r\n        }\r\n        require(allBorrowAmount != 0, 'BentoBox: all users are solvent');\r\n        totalBorrow = totalBorrow.sub(allBorrowAmount);\r\n        totalBorrowShare = totalBorrowShare.sub(allBorrowShare);\r\n        totalCollateral = totalCollateral.sub(allCollateralAmount);\r\n        totalCollateralShare = totalCollateralShare.add(allCollateralShare);\r\n\r\n        if (!open) {\r\n            // Closed liquidation using a pre-approved swapper for the benefit of the LPs\r\n            require(vault.swappers(swapper), 'BentoBox: Invalid swapper');\r\n\r\n            (bool success, bytes memory result) = swapper.delegatecall(\r\n                abi.encodeWithSignature(\"swap(address,address,address,uint256,uint256)\", swapper, tokenCollateral, tokenAsset, allCollateralAmount, allBorrowAmount));\r\n            require(success, 'BentoBox: Swap failed');\r\n            uint256 extraAsset = abi.decode(result, (uint256)).sub(allBorrowAmount);\r\n\r\n            // The extra asset gets added to the pool\r\n            uint256 feeAmount = extraAsset.div(10); // 10% of profit goes to fee\r\n            feesPending = feesPending.add(feeAmount);\r\n\r\n            totalAsset = totalAsset.add(extraAsset.sub(feeAmount));\r\n            emit AddAsset(address(0), extraAsset, 0);\r\n        } else if (swapper == address(0)) {\r\n            vault.transferFrom(tokenAsset, to, allBorrowAmount);\r\n            vault.transfer(tokenCollateral, to, allCollateralAmount);\r\n        } else {\r\n            // Open (flash) liquidation: get proceeds first and provide the borrow after\r\n            vault.transfer(tokenCollateral, swapper, allCollateralAmount);\r\n            ISwapper(swapper).swap(tokenCollateral, tokenAsset, allCollateralAmount, allBorrowAmount, to);\r\n            vault.transferFrom(tokenAsset, swapper, allBorrowAmount);\r\n        }\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"AddAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"AddBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"AddCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"NewExchangeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"RemoveAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"RemoveBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"RemoveCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accrue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"colRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset_address\",\"type\":\"address\"},{\"internalType\":\"contract IOracle\",\"name\":\"oracle_address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"oracleData\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"isSolvent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBlockAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastInterestBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liqMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"borrowShares\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openColRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"removeAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"removeCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountCollateral\",\"type\":\"uint256\"}],\"name\":\"short\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCollateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrowShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollateralShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountCollateral\",\"type\":\"uint256\"}],\"name\":\"unwind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateInterestRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBorrowShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userCollateralShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Pair","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}