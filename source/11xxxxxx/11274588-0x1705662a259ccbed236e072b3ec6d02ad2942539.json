{"status":"1","message":"OK","result":[{"SourceCode":"{\"Enum.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0 \\u003c0.7.0;\\n\\n\\n/// @title Enum - Collection of enums\\n/// @author Richard Meissner - \\u003crichard@gnosis.pm\\u003e\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\"},\"Executor.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0 \\u003c0.7.0;\\nimport \\\"./Enum.sol\\\";\\n\\n\\n/// @title Executor - A contract that can execute transactions\\n/// @author Richard Meissner - \\u003crichard@gnosis.pm\\u003e\\ncontract Executor {\\n\\n    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\\n        internal\\n        returns (bool success)\\n    {\\n        if (operation == Enum.Operation.Call)\\n            success = executeCall(to, value, data, txGas);\\n        else if (operation == Enum.Operation.DelegateCall)\\n            success = executeDelegateCall(to, data, txGas);\\n        else\\n            success = false;\\n    }\\n\\n    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\\n        internal\\n        returns (bool success)\\n    {\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\\n        }\\n    }\\n\\n    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\\n        internal\\n        returns (bool success)\\n    {\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\\n        }\\n    }\\n}\\n\"},\"MasterCopy.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0 \\u003c0.7.0;\\nimport \\\"./SelfAuthorized.sol\\\";\\n\\n\\n/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\\n/// @author Richard Meissner - \\u003crichard@gnosis.io\\u003e\\ncontract MasterCopy is SelfAuthorized {\\n\\n    event ChangedMasterCopy(address masterCopy);\\n\\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\\n    // It should also always be ensured that the address is stored alone (uses a full word)\\n    address private masterCopy;\\n\\n    /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\\n    /// @param _masterCopy New contract address.\\n    function changeMasterCopy(address _masterCopy)\\n        public\\n        authorized\\n    {\\n        // Master copy address cannot be null.\\n        require(_masterCopy != address(0), \\\"Invalid master copy address provided\\\");\\n        masterCopy = _masterCopy;\\n        emit ChangedMasterCopy(_masterCopy);\\n    }\\n}\\n\"},\"Module.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0 \\u003c0.7.0;\\nimport \\\"./MasterCopy.sol\\\";\\nimport \\\"./ModuleManager.sol\\\";\\n\\n\\n/// @title Module - Base class for modules.\\n/// @author Stefan George - \\u003cstefan@gnosis.pm\\u003e\\n/// @author Richard Meissner - \\u003crichard@gnosis.pm\\u003e\\ncontract Module is MasterCopy {\\n\\n    ModuleManager public manager;\\n\\n    modifier authorized() override {\\n        require(msg.sender == address(manager), \\\"Method can only be called from manager\\\");\\n        _;\\n    }\\n\\n    function setManager()\\n        internal\\n    {\\n        // manager can only be 0 at initalization of contract.\\n        // Check ensures that setup function can only be called once.\\n        require(address(manager) == address(0), \\\"Manager has already been set\\\");\\n        manager = ModuleManager(msg.sender);\\n    }\\n}\\n\"},\"ModuleManager.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0 \\u003c0.7.0;\\nimport \\\"./Enum.sol\\\";\\nimport \\\"./SelfAuthorized.sol\\\";\\nimport \\\"./Executor.sol\\\";\\nimport \\\"./Module.sol\\\";\\n\\n\\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\\n/// @author Stefan George - \\u003cstefan@gnosis.pm\\u003e\\n/// @author Richard Meissner - \\u003crichard@gnosis.pm\\u003e\\ncontract ModuleManager is SelfAuthorized, Executor {\\n\\n    event EnabledModule(Module module);\\n    event DisabledModule(Module module);\\n    event ExecutionFromModuleSuccess(address indexed module);\\n    event ExecutionFromModuleFailure(address indexed module);\\n\\n    address internal constant SENTINEL_MODULES = address(0x1);\\n\\n    mapping (address =\\u003e address) internal modules;\\n\\n    function setupModules(address to, bytes memory data)\\n        internal\\n    {\\n        require(modules[SENTINEL_MODULES] == address(0), \\\"Modules have already been initialized\\\");\\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\\n        if (to != address(0))\\n            // Setup has to complete successfully or transaction fails.\\n            require(executeDelegateCall(to, data, gasleft()), \\\"Could not finish initialization\\\");\\n    }\\n\\n    /// @dev Allows to add a module to the whitelist.\\n    ///      This can only be done via a Safe transaction.\\n    /// @notice Enables the module `module` for the Safe.\\n    /// @param module Module to be whitelisted.\\n    function enableModule(Module module)\\n        public\\n        authorized\\n    {\\n        // Module address cannot be null or sentinel.\\n        require(address(module) != address(0) \\u0026\\u0026 address(module) != SENTINEL_MODULES, \\\"Invalid module address provided\\\");\\n        // Module cannot be added twice.\\n        require(modules[address(module)] == address(0), \\\"Module has already been added\\\");\\n        modules[address(module)] = modules[SENTINEL_MODULES];\\n        modules[SENTINEL_MODULES] = address(module);\\n        emit EnabledModule(module);\\n    }\\n\\n    /// @dev Allows to remove a module from the whitelist.\\n    ///      This can only be done via a Safe transaction.\\n    /// @notice Disables the module `module` for the Safe.\\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\\n    /// @param module Module to be removed.\\n    function disableModule(Module prevModule, Module module)\\n        public\\n        authorized\\n    {\\n        // Validate module address and check that it corresponds to module index.\\n        require(address(module) != address(0) \\u0026\\u0026 address(module) != SENTINEL_MODULES, \\\"Invalid module address provided\\\");\\n        require(modules[address(prevModule)] == address(module), \\\"Invalid prevModule, module pair provided\\\");\\n        modules[address(prevModule)] = modules[address(module)];\\n        modules[address(module)] = address(0);\\n        emit DisabledModule(module);\\n    }\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\\n        public\\n        returns (bool success)\\n    {\\n        // Only whitelisted modules are allowed.\\n        require(msg.sender != SENTINEL_MODULES \\u0026\\u0026 modules[msg.sender] != address(0), \\\"Method can only be called from an enabled module\\\");\\n        // Execute transaction without further confirmations.\\n        success = execute(to, value, data, operation, gasleft());\\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\\n        else emit ExecutionFromModuleFailure(msg.sender);\\n    }\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\\n        public\\n        returns (bool success, bytes memory returnData)\\n    {\\n        success = execTransactionFromModule(to, value, data, operation);\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            // Load free memory location\\n            let ptr := mload(0x40)\\n            // We allocate memory for the return data by setting the free memory location to\\n            // current free memory location + data size + 32 bytes for data size value\\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\\n            // Store the size\\n            mstore(ptr, returndatasize())\\n            // Store the data\\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\\n            // Point the return data to the correct memory location\\n            returnData := ptr\\n        }\\n    }\\n\\n    /// @dev Returns if an module is enabled\\n    /// @return True if the module is enabled\\n    function isModuleEnabled(Module module)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return SENTINEL_MODULES != address(module) \\u0026\\u0026 modules[address(module)] != address(0);\\n    }\\n\\n    /// @dev Returns array of first 10 modules.\\n    /// @return Array of modules.\\n    function getModules()\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\\n        return array;\\n    }\\n\\n    /// @dev Returns array of modules.\\n    /// @param start Start of the page.\\n    /// @param pageSize Maximum number of modules that should be returned.\\n    /// @return array Array of modules.\\n    function getModulesPaginated(address start, uint256 pageSize)\\n        public\\n        view\\n        returns (address[] memory array, address next)\\n    {\\n        // Init array with max page size\\n        array = new address[](pageSize);\\n\\n        // Populate return array\\n        uint256 moduleCount = 0;\\n        address currentModule = modules[start];\\n        while(currentModule != address(0x0) \\u0026\\u0026 currentModule != SENTINEL_MODULES \\u0026\\u0026 moduleCount \\u003c pageSize) {\\n            array[moduleCount] = currentModule;\\n            currentModule = modules[currentModule];\\n            moduleCount++;\\n        }\\n        next = currentModule;\\n        // Set correct size of returned array\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            mstore(array, moduleCount)\\n        }\\n    }\\n}\\n\"},\"SelfAuthorized.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0 \\u003c0.7.0;\\n\\n\\n/// @title SelfAuthorized - authorizes current contract to perform actions\\n/// @author Richard Meissner - \\u003crichard@gnosis.pm\\u003e\\ncontract SelfAuthorized {\\n    modifier authorized() virtual {\\n        require(msg.sender == address(this), \\\"Method can only be called from this contract\\\");\\n        _;\\n    }\\n}\\n\"},\"VaultLiquidationProtectionModule.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity \\u003e=0.6.0 \\u003c0.7.0;\\n\\nimport \\\"./Enum.sol\\\";\\nimport \\\"./Module.sol\\\";\\n\\ncontract VaultLiquidationProtectionModule is Module{\\n\\n    string public constant NAME = \\\"Vault Liquidation Protection Module\\\";\\n    string public constant VERSION = \\\"0.1.0\\\";\\n\\n    address public immutable maker_vat_vault; // vat contract, Maker Vault core contract\\n    address public immutable cdp_owner; // also called urn in the vat contract\\n    address public immutable maker_dai_bridge; // DAI adapter contract of Maker DAO used to interact with vat contract\\n    address public immutable maker_collateral_token_bridge; // Collateral Token Adapter contract, also called gem\\n    bytes32 public immutable maker_collateral_token_id; // Collateral Token ID in Maker DAO system, also called ILK\\n    address public immutable operator; // EOA used to interact with this module\\n\\n    modifier onlyOperator {\\n        require(msg.sender == operator, \\\"Only the operator can call this function\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _maker_vat_vault, \\n        address _cdp_owner, \\n        address _maker_dai_bridge, \\n        address _maker_collateral_token_bridge, \\n        bytes32 _maker_collateral_token_id, \\n        address _manager,\\n        address _operator\\n    ) public {\\n        maker_vat_vault                 = _maker_vat_vault;\\n        cdp_owner                       = _cdp_owner;\\n        maker_dai_bridge                = _maker_dai_bridge;\\n        maker_collateral_token_bridge   = _maker_collateral_token_bridge;\\n        maker_collateral_token_id       = _maker_collateral_token_id;\\n        manager                         = ModuleManager(_manager);\\n        operator                        = _operator;\\n    }\\n\\n    function increase_cdp_collateralisation(\\n        int256 collateral_amount, int256 dai_amount\\n    ) public onlyOperator {\\n\\n        // This two checks prevent accidentally decreasing collateralization in the CDP and cause a liquidation\\n        // In theory it\\u0027s assumed that the safe used for this module shouldn\\u0027t be the owner of the CDP\\n        // But this prevents liquidation in case the safe it\\u0027s the owner\\n        require(collateral_amount \\u003e= 0, \\\"Collateral amount must increase collateralization\\\");\\n        require(dai_amount \\u003c= 0, \\\"DAI amount must decrease CDP debt\\\");\\n        \\n        if(collateral_amount != 0){\\n            // Collateral has to be moved first into the Maker system\\n            // Reference: https://github.com/makerdao/dss/blob/1.1.2/src/join.sol#L89\\n            bytes memory collateral_join_data = abi.encodeWithSignature(\\n                \\\"join(address,uint256)\\\", \\n                manager, \\n                uint256(collateral_amount)\\n            );\\n\\n            require(\\n                manager.execTransactionFromModule(\\n                    maker_collateral_token_bridge, \\n                    0, \\n                    collateral_join_data, \\n                    Enum.Operation.Call\\n                ), \\\"Could not execute collateral transfer\\\"\\n            );\\n        }\\n\\n        if(dai_amount != 0){\\n\\n            // DAI has to be moved first into the Maker system\\n            // Reference: https://github.com/makerdao/dss/blob/1.1.2/src/join.sol#L129\\n            bytes memory dai_join_data = abi.encodeWithSignature(\\n                \\\"join(address,uint256)\\\", \\n                manager, \\n                uint256(-dai_amount)\\n            );\\n\\n            require(\\n                manager.execTransactionFromModule(\\n                    maker_dai_bridge, \\n                    0, \\n                    dai_join_data,\\n                    Enum.Operation.Call\\n                ), \\\"Could not execute DAI transfer\\\"\\n            );\\n        }\\n\\n        // frob function modifies debt and collateral amounts in the DAI CDP\\n        // Reference: https://github.com/makerdao/dss/blob/1.1.2/src/vat.sol#L165\\n        bytes memory cdp_deposit_data = abi.encodeWithSignature(\\n            \\\"frob(bytes32,address,address,address,int256,int256)\\\", \\n            maker_collateral_token_id,\\n            cdp_owner,\\n            manager,\\n            manager,\\n            collateral_amount,\\n            dai_amount\\n        );\\n        require(\\n            manager.execTransactionFromModule(\\n                    maker_vat_vault, \\n                    0, \\n                    cdp_deposit_data,\\n                    Enum.Operation.Call\\n                ), \\\"Could not execute CDP Deposit\\\"\\n        );\\n\\n\\n    }\\n\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_maker_vat_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cdp_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_maker_dai_bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_maker_collateral_token_bridge\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_maker_collateral_token_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"masterCopy\",\"type\":\"address\"}],\"name\":\"ChangedMasterCopy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cdp_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterCopy\",\"type\":\"address\"}],\"name\":\"changeMasterCopy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"collateral_amount\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dai_amount\",\"type\":\"int256\"}],\"name\":\"increase_cdp_collateralisation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maker_collateral_token_bridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maker_collateral_token_id\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maker_dai_bridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maker_vat_vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract ModuleManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VaultLiquidationProtectionModule","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000035d1b3f3d7966a1dfe207aa4514c12a259a0492b000000000000000000000000b585bb7893e0d29ab7a41d49d941b399ae69e50d0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000002f0b23f53734252bda2277357e97e1517d6b042a4554482d41000000000000000000000000000000000000000000000000000000000000000000000000000000a84962deb082d4e628e1fee1c96efe09f56f0bb6000000000000000000000000167b60c484678c7b781290069c19b9f29a4fa54e","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ae49264f84221414a8a5fb10bbfe8da2bae4180bcf964e761622781f5252bb31"}]}