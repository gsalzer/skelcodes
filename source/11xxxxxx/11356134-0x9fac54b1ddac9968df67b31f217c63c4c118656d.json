{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/balancer-core/BConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\ncontract BConst {\\n    uint public constant BONE              = 10**18;\\n\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\n    uint public constant MAX_BOUND_TOKENS  = 9;\\n\\n    uint public constant MIN_FEE           = BONE / 10**6;\\n    uint public constant MAX_FEE           = BONE / 10;\\n\\n    uint public constant MIN_WEIGHT        = 1000000000;\\n    uint public constant MAX_WEIGHT        = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\\n    uint public constant MIN_BALANCE       = BONE / 10**12;\\n\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"contracts/balancer-core/BNum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./BConst.sol\\\";\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n      require(b > 0, \\\"ERR_DIV_ZERO\\\");\\n      return a / b;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = bfloor(exp);\\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom\\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/balancer-core/BMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./BNum.sol\\\";\\nimport \\\"../interfaces/BMathInterface.sol\\\";\\n\\ncontract BMath is BConst, BNum, BMathInterface {\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint spotPrice)\\n    {\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint ratio = bdiv(numer, denom);\\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\\n        return  (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcOutGivenIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n        uint adjustedIn = bsub(BONE, swapFee);\\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n        uint foo = bpow(y, weightRatio);\\n        uint bar = bsub(BONE, foo);\\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcInGivenOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure override\\n        returns (uint tokenAmountIn)\\n    {\\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\\n        uint y = bdiv(tokenBalanceOut, diff);\\n        uint foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        tokenAmountIn = bsub(BONE, swapFee);\\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint poolAmountOut)\\n    {\\n        // Charge the trading fee for the proportion of tokenAi\\n        ///  which is implicitly traded to the other pool tokens.\\n        // That proportion is (1- weightTokenIn)\\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\\n        return poolAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n        uint boo = bdiv(BONE, normalizedWeight);\\n        uint tokenInRatio = bpow(poolRatio, boo);\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      //       pS - pAi        \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        uint newPoolSupply = bsub(poolSupply, poolAmountIn);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\n\\n        // charge swap fee on the output token side\\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight                                                                          //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint poolAmountIn)\\n    {\\n\\n        // charge swap fee on the output token side\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n        uint zoo = bsub(BONE, normalizedWeight);\\n        uint zar = bmul(zoo, swapFee);\\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        uint poolAmountIn = bsub(poolSupply, newPoolSupply);\\n        return poolAmountIn;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BMathInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface BMathInterface {\\n  function calcInGivenOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) external pure returns (uint256 tokenAmountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BPoolInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./BMathInterface.sol\\\";\\n\\ninterface BPoolInterface is IERC20, BMathInterface {\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n  function swapExactAmountIn(\\n    address,\\n    uint256,\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256, uint256);\\n\\n  function swapExactAmountOut(\\n    address,\\n    uint256,\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256, uint256);\\n\\n  function joinswapExternAmountIn(\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256);\\n\\n  function joinswapPoolAmountOut(\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256);\\n\\n  function exitswapPoolAmountIn(\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256);\\n\\n  function exitswapExternAmountOut(\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256);\\n\\n  function getDenormalizedWeight(address) external view returns (uint256);\\n\\n  function getBalance(address) external view returns (uint256);\\n\\n  function getSwapFee() external view returns (uint256);\\n\\n  function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n  function getCommunityFee()\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      address\\n    );\\n\\n  function calcAmountWithCommunityFee(\\n    uint256,\\n    uint256,\\n    address\\n  ) external view returns (uint256, uint256);\\n\\n  function getRestrictions() external view returns (address);\\n\\n  function isPublicSwap() external view returns (bool);\\n\\n  function isFinalized() external view returns (bool);\\n\\n  function isBound(address t) external view returns (bool);\\n\\n  function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n  function getFinalTokens() external view returns (address[] memory tokens);\\n\\n  function setSwapFee(uint256) external;\\n\\n  function setCommunityFeeAndReceiver(\\n    uint256,\\n    uint256,\\n    uint256,\\n    address\\n  ) external;\\n\\n  function setController(address) external;\\n\\n  function setPublicSwap(bool) external;\\n\\n  function finalize() external;\\n\\n  function bind(\\n    address,\\n    uint256,\\n    uint256\\n  ) external;\\n\\n  function rebind(\\n    address,\\n    uint256,\\n    uint256\\n  ) external;\\n\\n  function unbind(address) external;\\n\\n  function callVoting(\\n    address voting,\\n    bytes4 signature,\\n    bytes calldata args,\\n    uint256 value\\n  ) external;\\n\\n  function getMinWeight() external view returns (uint256);\\n\\n  function getMaxBoundTokens() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/PowerIndexPoolInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./BPoolInterface.sol\\\";\\n\\ninterface PowerIndexPoolInterface is BPoolInterface {\\n  function bind(\\n    address,\\n    uint256,\\n    uint256,\\n    uint256,\\n    uint256\\n  ) external;\\n\\n  function setDynamicWeight(\\n    address token,\\n    uint256 targetDenorm,\\n    uint256 fromTimestamp,\\n    uint256 targetTimestamp\\n  ) external;\\n\\n  function getDynamicWeightSettings(address token)\\n    external\\n    view\\n    returns (\\n      uint256 fromTimestamp,\\n      uint256 targetTimestamp,\\n      uint256 fromDenorm,\\n      uint256 targetDenorm\\n    );\\n\\n  function getMinWeight() external view override returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/PowerIndexPoolActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/PowerIndexPoolInterface.sol\\\";\\nimport \\\"./interfaces/PowerIndexPoolFactoryInterface.sol\\\";\\n\\ncontract PowerIndexPoolActions {\\n  struct Args {\\n    uint256 minWeightPerSecond;\\n    uint256 maxWeightPerSecond;\\n    uint256 swapFee;\\n    uint256 communitySwapFee;\\n    uint256 communityJoinFee;\\n    uint256 communityExitFee;\\n    address communityFeeReceiver;\\n    bool finalize;\\n  }\\n\\n  struct TokenConfig {\\n    address token;\\n    uint256 balance;\\n    uint256 targetDenorm;\\n    uint256 fromTimestamp;\\n    uint256 targetTimestamp;\\n  }\\n\\n  function create(\\n    PowerIndexPoolFactoryInterface factory,\\n    string calldata name,\\n    string calldata symbol,\\n    Args calldata args,\\n    TokenConfig[] calldata tokens\\n  ) external returns (PowerIndexPoolInterface pool) {\\n    pool = factory.newPool(name, symbol, args.minWeightPerSecond, args.maxWeightPerSecond);\\n    pool.setSwapFee(args.swapFee);\\n    pool.setCommunityFeeAndReceiver(\\n      args.communitySwapFee,\\n      args.communityJoinFee,\\n      args.communityExitFee,\\n      args.communityFeeReceiver\\n    );\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      TokenConfig memory tokenConfig = tokens[i];\\n      IERC20 token = IERC20(tokenConfig.token);\\n      require(token.transferFrom(msg.sender, address(this), tokenConfig.balance), \\\"ERR_TRANSFER_FAILED\\\");\\n      if (token.allowance(address(this), address(pool)) > 0) {\\n        token.approve(address(pool), 0);\\n      }\\n      token.approve(address(pool), tokenConfig.balance);\\n      pool.bind(\\n        tokenConfig.token,\\n        tokenConfig.balance,\\n        tokenConfig.targetDenorm,\\n        tokenConfig.fromTimestamp,\\n        tokenConfig.targetTimestamp\\n      );\\n    }\\n\\n    if (args.finalize) {\\n      pool.finalize();\\n      require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \\\"ERR_TRANSFER_FAILED\\\");\\n    } else {\\n      pool.setPublicSwap(true);\\n    }\\n\\n    pool.setController(msg.sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/PowerIndexPoolFactoryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./PowerIndexPoolInterface.sol\\\";\\n\\ninterface PowerIndexPoolFactoryInterface {\\n  function newPool(\\n    string calldata name,\\n    string calldata symbol,\\n    uint256 minWeightPerSecond,\\n    uint256 maxWeightPerSecond\\n  ) external returns (PowerIndexPoolInterface);\\n}\\n\"\r\n    },\r\n    \"contracts/PowerIndexPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is disstributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\n// Builds new Power Index Pools, logging their addresses and providing `isPowerIndexPool(address) -> (bool)`\\n\\nimport \\\"./PowerIndexPool.sol\\\";\\nimport \\\"./interfaces/PowerIndexPoolFactoryInterface.sol\\\";\\n\\ncontract PowerIndexPoolFactory is PowerIndexPoolFactoryInterface {\\n  event LOG_NEW_POOL(address indexed caller, address indexed pool);\\n\\n  mapping(address => bool) public isPowerIndexPool;\\n\\n  constructor() public {}\\n\\n  function newPool(\\n    string calldata name,\\n    string calldata symbol,\\n    uint256 minWeightPerSecond,\\n    uint256 maxWeightPerSecond\\n  ) external override returns (PowerIndexPoolInterface) {\\n    PowerIndexPool pool = new PowerIndexPool(name, symbol, minWeightPerSecond, maxWeightPerSecond);\\n    isPowerIndexPool[address(pool)] = true;\\n    emit LOG_NEW_POOL(msg.sender, address(pool));\\n    pool.setController(msg.sender);\\n    return PowerIndexPoolInterface(address(pool));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/PowerIndexPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./balancer-core/BPool.sol\\\";\\nimport \\\"./interfaces/PowerIndexPoolInterface.sol\\\";\\n\\ncontract PowerIndexPool is BPool {\\n  /// @notice The event emitted when a dynamic weight set to token\\n  event SetDynamicWeight(\\n    address indexed token,\\n    uint256 fromDenorm,\\n    uint256 targetDenorm,\\n    uint256 fromTimestamp,\\n    uint256 targetTimestamp\\n  );\\n\\n  /// @notice The event emitted when weight per second bounds set\\n  event SetWeightPerSecondBounds(uint256 minWeightPerSecond, uint256 maxWeightPerSecond);\\n\\n  struct DynamicWeight {\\n    uint256 fromTimestamp;\\n    uint256 targetTimestamp;\\n    uint256 targetDenorm;\\n  }\\n\\n  /// @dev Mapping for storing dynamic weights settings. fromDenorm stored in _records mapping as denorm variable\\n  mapping(address => DynamicWeight) private _dynamicWeights;\\n\\n  /// @dev Min weight per second limit\\n  uint256 private _minWeightPerSecond;\\n  /// @dev Max weight per second limit\\n  uint256 private _maxWeightPerSecond;\\n\\n  constructor(\\n    string memory name,\\n    string memory symbol,\\n    uint256 minWeightPerSecond,\\n    uint256 maxWeightPerSecond\\n  ) public BPool(name, symbol) {\\n    _minWeightPerSecond = minWeightPerSecond;\\n    _maxWeightPerSecond = maxWeightPerSecond;\\n  }\\n\\n  /*** Controller Interface ***/\\n\\n  /**\\n   * @notice Set weight per second bounds by controller\\n   * @param minWeightPerSecond Min weight per second\\n   * @param maxWeightPerSecond Max weight per second\\n   */\\n  function setWeightPerSecondBounds(uint256 minWeightPerSecond, uint256 maxWeightPerSecond) public _logs_ _lock_ {\\n    _onlyController();\\n    _minWeightPerSecond = minWeightPerSecond;\\n    _maxWeightPerSecond = maxWeightPerSecond;\\n\\n    emit SetWeightPerSecondBounds(minWeightPerSecond, maxWeightPerSecond);\\n  }\\n\\n  /**\\n   * @notice Set dynamic weight for token by controller\\n   * @param token Token for change settings\\n   * @param targetDenorm Target weight. fromDenorm will be fetch by current value of _getDenormWeight\\n   * @param fromTimestamp From timestamp of dynamic weight\\n   * @param targetTimestamp Target timestamp of dynamic weight\\n   */\\n  function setDynamicWeight(\\n    address token,\\n    uint256 targetDenorm,\\n    uint256 fromTimestamp,\\n    uint256 targetTimestamp\\n  ) public _logs_ _lock_ {\\n    _onlyController();\\n    _requireTokenIsBound(token);\\n\\n    require(fromTimestamp > block.timestamp, \\\"CANT_SET_PAST_TIMESTAMP\\\");\\n    require(targetTimestamp > fromTimestamp, \\\"TIMESTAMP_INCORRECT_DELTA\\\");\\n    require(targetDenorm >= MIN_WEIGHT && targetDenorm <= MAX_WEIGHT, \\\"TARGET_WEIGHT_BOUNDS\\\");\\n\\n    uint256 fromDenorm = _getDenormWeight(token);\\n    uint256 weightPerSecond = _getWeightPerSecond(fromDenorm, targetDenorm, fromTimestamp, targetTimestamp);\\n    require(weightPerSecond <= _maxWeightPerSecond, \\\"MAX_WEIGHT_PER_SECOND\\\");\\n    require(weightPerSecond >= _minWeightPerSecond, \\\"MIN_WEIGHT_PER_SECOND\\\");\\n\\n    _records[token].denorm = fromDenorm;\\n\\n    _dynamicWeights[token] = DynamicWeight({\\n      fromTimestamp: fromTimestamp,\\n      targetTimestamp: targetTimestamp,\\n      targetDenorm: targetDenorm\\n    });\\n\\n    uint256 denormSum = 0;\\n    uint256 len = _tokens.length;\\n    for (uint256 i = 0; i < len; i++) {\\n      denormSum = badd(denormSum, _dynamicWeights[_tokens[i]].targetDenorm);\\n    }\\n\\n    require(denormSum <= MAX_TOTAL_WEIGHT, \\\"MAX_TARGET_TOTAL_WEIGHT\\\");\\n\\n    emit SetDynamicWeight(token, fromDenorm, targetDenorm, fromTimestamp, targetTimestamp);\\n  }\\n\\n  /**\\n   * @notice Bind and setDynamicWeight at the same time\\n   * @param token Token for bind\\n   * @param balance Initial balance\\n   * @param targetDenorm Target weight\\n   * @param fromTimestamp From timestamp of dynamic weight\\n   * @param targetTimestamp Target timestamp of dynamic weight\\n   */\\n  function bind(\\n    address token,\\n    uint256 balance,\\n    uint256 targetDenorm,\\n    uint256 fromTimestamp,\\n    uint256 targetTimestamp\\n  )\\n    external\\n    _logs_ // _lock_  Bind does not lock because it jumps to `rebind` and `setDynamicWeight`, which does\\n  {\\n    super.bind(token, balance, MIN_WEIGHT);\\n\\n    setDynamicWeight(token, targetDenorm, fromTimestamp, targetTimestamp);\\n  }\\n\\n  /**\\n   * @notice Override parent unbind function\\n   * @param token Token for unbind\\n   */\\n  function unbind(address token) public override {\\n    super.unbind(token);\\n\\n    _dynamicWeights[token] = DynamicWeight(0, 0, 0);\\n  }\\n\\n  /**\\n   * @notice Override parent bind function and disable.\\n   */\\n  function bind(\\n    address,\\n    uint256,\\n    uint256\\n  ) public override {\\n    revert(\\\"DISABLED\\\"); // Only new bind function is allowed\\n  }\\n\\n  /**\\n   * @notice Override parent rebind function. Allowed only for calling from bind function\\n   * @param token Token for rebind\\n   * @param balance Balance for rebind\\n   * @param denorm Weight for rebind\\n   */\\n  function rebind(\\n    address token,\\n    uint256 balance,\\n    uint256 denorm\\n  ) public override {\\n    require(denorm == MIN_WEIGHT && _dynamicWeights[token].fromTimestamp == 0, \\\"ONLY_NEW_TOKENS_ALLOWED\\\");\\n    super.rebind(token, balance, denorm);\\n  }\\n\\n  /*** View Functions ***/\\n\\n  function getDynamicWeightSettings(address token)\\n    external\\n    view\\n    returns (\\n      uint256 fromTimestamp,\\n      uint256 targetTimestamp,\\n      uint256 fromDenorm,\\n      uint256 targetDenorm\\n    )\\n  {\\n    DynamicWeight storage dw = _dynamicWeights[token];\\n    return (dw.fromTimestamp, dw.targetTimestamp, _records[token].denorm, dw.targetDenorm);\\n  }\\n\\n  function getWeightPerSecondBounds() external view returns (uint256 minWeightPerSecond, uint256 maxWeightPerSecond) {\\n    return (_minWeightPerSecond, _maxWeightPerSecond);\\n  }\\n\\n  /*** Internal Functions ***/\\n\\n  function _getDenormWeight(address token) internal view override returns (uint256) {\\n    DynamicWeight memory dw = _dynamicWeights[token];\\n    uint256 fromDenorm = _records[token].denorm;\\n\\n    if (dw.fromTimestamp == 0 || dw.targetDenorm == fromDenorm || block.timestamp <= dw.fromTimestamp) {\\n      return fromDenorm;\\n    }\\n    if (block.timestamp >= dw.targetTimestamp) {\\n      return dw.targetDenorm;\\n    }\\n\\n    uint256 weightPerSecond = _getWeightPerSecond(fromDenorm, dw.targetDenorm, dw.fromTimestamp, dw.targetTimestamp);\\n    uint256 deltaCurrentTime = bsub(block.timestamp, dw.fromTimestamp);\\n    if (dw.targetDenorm > fromDenorm) {\\n      return badd(fromDenorm, deltaCurrentTime * weightPerSecond);\\n    } else {\\n      return bsub(fromDenorm, deltaCurrentTime * weightPerSecond);\\n    }\\n  }\\n\\n  function _getWeightPerSecond(\\n    uint256 fromDenorm,\\n    uint256 targetDenorm,\\n    uint256 fromTimestamp,\\n    uint256 targetTimestamp\\n  ) internal pure returns (uint256) {\\n    uint256 delta = targetDenorm > fromDenorm ? bsub(targetDenorm, fromDenorm) : bsub(fromDenorm, targetDenorm);\\n    return div(delta, bsub(targetTimestamp, fromTimestamp));\\n  }\\n\\n  function _getTotalWeight() internal view override returns (uint256) {\\n    uint256 sum = 0;\\n    uint256 len = _tokens.length;\\n    for (uint256 i = 0; i < len; i++) {\\n      sum = badd(sum, _getDenormWeight(_tokens[i]));\\n    }\\n    return sum;\\n  }\\n\\n  function _addTotalWeight(uint256 _amount) internal virtual override {\\n    // storage total weight don't change, it's calculated only by _getTotalWeight()\\n  }\\n\\n  function _subTotalWeight(uint256 _amount) internal virtual override {\\n    // storage total weight don't change, it's calculated only by _getTotalWeight()\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/balancer-core/BPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\nimport \\\"../interfaces/IPoolRestrictions.sol\\\";\\nimport \\\"../interfaces/BPoolInterface.sol\\\";\\n\\ncontract BPool is BToken, BMath, BPoolInterface {\\n\\n    struct Record {\\n        bool bound;   // is token bound to pool\\n        uint index;   // private\\n        uint denorm;  // denormalized weight\\n        uint balance;\\n    }\\n\\n    event LOG_SWAP(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256         tokenAmountIn,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_JOIN(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint256         tokenAmountIn\\n    );\\n\\n    event LOG_EXIT(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_CALL(\\n        bytes4  indexed sig,\\n        address indexed caller,\\n        bytes           data\\n    ) anonymous;\\n\\n    event LOG_CALL_VOTING(\\n        address indexed voting,\\n        bool    indexed success,\\n        bytes4  indexed inputSig,\\n        bytes           inputData,\\n        bytes           outputData\\n    );\\n\\n    event LOG_COMMUNITY_FEE(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed token,\\n        uint256         tokenAmount\\n    );\\n\\n    modifier _logs_() {\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    modifier _lock_() {\\n        _preventReentrancy();\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        _preventReentrancy();\\n        _;\\n    }\\n\\n    bool private _mutex;\\n\\n    address private _controller; // has CONTROL role\\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\\n\\n    address private _wrapper; // can join, exit and swaps when _wrapperMode is true\\n    bool private _wrapperMode;\\n\\n    IPoolRestrictions private _restrictions;\\n\\n    // `setSwapFee` and `finalize` require CONTROL\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    uint private _swapFee;\\n    uint private _communitySwapFee;\\n    uint private _communityJoinFee;\\n    uint private _communityExitFee;\\n    address private _communityFeeReceiver;\\n    bool private _finalized;\\n\\n    address[] internal _tokens;\\n    mapping(address => Record) internal _records;\\n    uint internal _totalWeight;\\n\\n    mapping(address => uint256) internal _lastSwapBlock;\\n\\n    constructor(string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _controller = msg.sender;\\n        _swapFee = MIN_FEE;\\n        _communitySwapFee = 0;\\n        _communityJoinFee = 0;\\n        _communityExitFee = 0;\\n        _publicSwap = false;\\n        _finalized = false;\\n    }\\n\\n    function isPublicSwap()\\n        external view override\\n        returns (bool)\\n    {\\n        return _publicSwap;\\n    }\\n\\n    function isFinalized()\\n        external view override\\n        returns (bool)\\n    {\\n        return _finalized;\\n    }\\n\\n    function isBound(address t)\\n        external view override\\n        returns (bool)\\n    {\\n        return _records[t].bound;\\n    }\\n\\n    function getNumTokens()\\n        external view\\n        returns (uint)\\n    {\\n        return _tokens.length;\\n    }\\n\\n    function getCurrentTokens()\\n        external view override\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        return _tokens;\\n    }\\n\\n    function getFinalTokens()\\n        external view override\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        _requireContractIsFinalized();\\n        return _tokens;\\n    }\\n\\n    function getDenormalizedWeight(address token)\\n        external view override\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        _requireTokenIsBound(token);\\n        return _getDenormWeight(token);\\n    }\\n\\n    function getTotalDenormalizedWeight()\\n        external view override\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _getTotalWeight();\\n    }\\n\\n    function getNormalizedWeight(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        _requireTokenIsBound(token);\\n        return bdiv(_getDenormWeight(token), _getTotalWeight());\\n    }\\n\\n    function getBalance(address token)\\n        external view override\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        _requireTokenIsBound(token);\\n        return _records[token].balance;\\n    }\\n\\n    function getSwapFee()\\n        external view override\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _swapFee;\\n    }\\n\\n    function getCommunityFee()\\n        external view override\\n        _viewlock_\\n        returns (uint communitySwapFee, uint communityJoinFee, uint communityExitFee, address communityFeeReceiver)\\n    {\\n        return (_communitySwapFee, _communityJoinFee, _communityExitFee, _communityFeeReceiver);\\n    }\\n\\n    function getController()\\n        external view\\n        _viewlock_\\n        returns (address)\\n    {\\n        return _controller;\\n    }\\n\\n    function getWrapper()\\n        external view\\n        _viewlock_\\n        returns (address)\\n    {\\n        return _wrapper;\\n    }\\n\\n    function getWrapperMode()\\n        external view\\n        _viewlock_\\n        returns (bool)\\n    {\\n        return _wrapperMode;\\n    }\\n\\n    function getRestrictions()\\n        external view override\\n        _viewlock_\\n        returns (address)\\n    {\\n        return address(_restrictions);\\n    }\\n\\n    function setSwapFee(uint swapFee)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _requireFeeInBounds(swapFee);\\n        _swapFee = swapFee;\\n    }\\n\\n    function setCommunityFeeAndReceiver(\\n        uint communitySwapFee,\\n        uint communityJoinFee,\\n        uint communityExitFee,\\n        address communityFeeReceiver\\n    )\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _requireFeeInBounds(communitySwapFee);\\n        _requireFeeInBounds(communityJoinFee);\\n        _requireFeeInBounds(communityExitFee);\\n        _communitySwapFee = communitySwapFee;\\n        _communityJoinFee = communityJoinFee;\\n        _communityExitFee = communityExitFee;\\n        _communityFeeReceiver = communityFeeReceiver;\\n    }\\n\\n    function setRestrictions(IPoolRestrictions restrictions)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _restrictions = restrictions;\\n    }\\n\\n    function setController(address manager)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _controller = manager;\\n    }\\n\\n    function setPublicSwap(bool public_)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _requireContractIsNotFinalized();\\n        _onlyController();\\n        _publicSwap = public_;\\n    }\\n\\n    function setWrapper(address wrapper, bool wrapperMode)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _wrapper = wrapper;\\n        _wrapperMode = wrapperMode;\\n    }\\n\\n    function finalize()\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _requireContractIsNotFinalized();\\n        require(_tokens.length >= MIN_BOUND_TOKENS, \\\"MIN_TOKENS\\\");\\n\\n        _finalized = true;\\n        _publicSwap = true;\\n\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    }\\n\\n    function callVoting(address voting, bytes4 signature, bytes calldata args, uint256 value)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        require(_restrictions.isVotingSignatureAllowed(voting, signature), \\\"NOT_ALLOWED_SIG\\\");\\n        _onlyController();\\n\\n        (bool success, bytes memory data) = voting.call{ value: value }(abi.encodePacked(signature, args));\\n        require(success, \\\"NOT_SUCCESS\\\");\\n        emit LOG_CALL_VOTING(voting, success, signature, args, data);\\n    }\\n\\n    function bind(address token, uint balance, uint denorm)\\n        public override\\n        virtual\\n        _logs_\\n        // _lock_  Bind does not lock because it jumps to `rebind`, which does\\n    {\\n        _onlyController();\\n        require(!_records[token].bound, \\\"IS_BOUND\\\");\\n\\n        require(_tokens.length < MAX_BOUND_TOKENS, \\\"MAX_TOKENS\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            index: _tokens.length,\\n            denorm: 0,    // balance and denorm will be validated\\n            balance: 0   // and set by `rebind`\\n        });\\n        _tokens.push(token);\\n        rebind(token, balance, denorm);\\n    }\\n\\n    function rebind(address token, uint balance, uint denorm)\\n        public override\\n        virtual\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _requireTokenIsBound(token);\\n\\n        require(denorm >= MIN_WEIGHT && denorm <= MAX_WEIGHT, \\\"WEIGHT_BOUNDS\\\");\\n        require(balance >= MIN_BALANCE, \\\"MIN_BALANCE\\\");\\n\\n        // Adjust the denorm and totalWeight\\n        uint oldWeight = _records[token].denorm;\\n        if (denorm > oldWeight) {\\n            _addTotalWeight(bsub(denorm, oldWeight));\\n        } else if (denorm < oldWeight) {\\n            _subTotalWeight(bsub(oldWeight, denorm));\\n        }\\n        _records[token].denorm = denorm;\\n\\n        // Adjust the balance record and actual token balance\\n        uint oldBalance = _records[token].balance;\\n        _records[token].balance = balance;\\n        if (balance > oldBalance) {\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n        } else if (balance < oldBalance) {\\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n            _pushUnderlying(token, msg.sender, tokenBalanceWithdrawn);\\n        }\\n    }\\n\\n    function unbind(address token)\\n        public override\\n        virtual\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _requireTokenIsBound(token);\\n\\n        uint tokenBalance = _records[token].balance;\\n\\n        _subTotalWeight(_records[token].denorm);\\n\\n        // Swap the token-to-unbind with the last token,\\n        // then delete the last token\\n        uint index = _records[token].index;\\n        uint last = _tokens.length - 1;\\n        _tokens[index] = _tokens[last];\\n        _records[_tokens[index]].index = index;\\n        _tokens.pop();\\n        _records[token] = Record({\\n            bound: false,\\n            index: 0,\\n            denorm: 0,\\n            balance: 0\\n        });\\n\\n        _pushUnderlying(token, msg.sender, tokenBalance);\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the pool\\n    function gulp(address token)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        _requireTokenIsBound(token);\\n        _records[token].balance = IERC20(token).balanceOf(address(this));\\n    }\\n\\n    function getSpotPrice(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        require(_records[tokenIn].bound && _records[tokenOut].bound, \\\"NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, _getDenormWeight(tokenIn), outRecord.balance, _getDenormWeight(tokenOut), _swapFee);\\n    }\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        _requireTokenIsBound(tokenIn);\\n        _requireTokenIsBound(tokenOut);\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, _getDenormWeight(tokenIn), outRecord.balance, _getDenormWeight(tokenOut), 0);\\n    }\\n\\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _preventSameTxOrigin();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireContractIsFinalized();\\n\\n        uint poolTotal = totalSupply();\\n        uint ratio = bdiv(poolAmountOut, poolTotal);\\n        _requireMathApprox(ratio);\\n\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountIn = bmul(ratio, bal);\\n            _requireMathApprox(tokenAmountIn);\\n            require(tokenAmountIn <= maxAmountsIn[i], \\\"LIMIT_IN\\\");\\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\n        }\\n\\n        (uint poolAmountOutAfterFee, uint poolAmountOutFee) = calcAmountWithCommunityFee(\\n            poolAmountOut,\\n            _communityJoinFee,\\n            msg.sender\\n        );\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOutAfterFee);\\n        _pushPoolShare(_communityFeeReceiver, poolAmountOutFee);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, address(this), poolAmountOutFee);\\n    }\\n\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _preventSameTxOrigin();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireContractIsFinalized();\\n\\n        (uint poolAmountInAfterFee, uint poolAmountInFee) = calcAmountWithCommunityFee(\\n            poolAmountIn,\\n            _communityExitFee,\\n            msg.sender\\n        );\\n\\n        uint poolTotal = totalSupply();\\n        uint ratio = bdiv(poolAmountInAfterFee, poolTotal);\\n        _requireMathApprox(ratio);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _pushPoolShare(_communityFeeReceiver, poolAmountInFee);\\n        _burnPoolShare(poolAmountInAfterFee);\\n\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountOut = bmul(ratio, bal);\\n            _requireMathApprox(tokenAmountOut);\\n            require(tokenAmountOut >= minAmountsOut[i], \\\"LIMIT_OUT\\\");\\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\\n        }\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, address(this), poolAmountInFee);\\n    }\\n\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint minAmountOut,\\n        uint maxPrice\\n    )\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut, uint spotPriceAfter)\\n    {\\n        _preventSameTxOrigin();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenIn);\\n        _requireTokenIsBound(tokenOut);\\n        require(_publicSwap, \\\"NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    _getDenormWeight(tokenIn),\\n                                    outRecord.balance,\\n                                    _getDenormWeight(tokenOut),\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore <= maxPrice, \\\"LIMIT_PRICE\\\");\\n\\n        (uint tokenAmountInAfterFee, uint tokenAmountInFee) = calcAmountWithCommunityFee(\\n                                                                tokenAmountIn,\\n                                                                _communitySwapFee,\\n                                                                msg.sender\\n                                                            );\\n\\n        require(tokenAmountInAfterFee <= bmul(inRecord.balance, MAX_IN_RATIO), \\\"MAX_IN_RATIO\\\");\\n\\n        tokenAmountOut = calcOutGivenIn(\\n                            inRecord.balance,\\n                            _getDenormWeight(tokenIn),\\n                            outRecord.balance,\\n                            _getDenormWeight(tokenOut),\\n                            tokenAmountInAfterFee,\\n                            _swapFee\\n                        );\\n        require(tokenAmountOut >= minAmountOut, \\\"LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountInAfterFee);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                _getDenormWeight(tokenIn),\\n                                outRecord.balance,\\n                                _getDenormWeight(tokenOut),\\n                                _swapFee\\n                            );\\n        require(\\n            spotPriceAfter >= spotPriceBefore &&\\n            spotPriceBefore <= bdiv(tokenAmountInAfterFee, tokenAmountOut),\\n            \\\"MATH_APPROX\\\"\\n        );\\n        require(spotPriceAfter <= maxPrice, \\\"LIMIT_PRICE\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountInAfterFee, tokenAmountOut);\\n\\n        _pullCommunityFeeUnderlying(tokenIn, msg.sender, tokenAmountInFee);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountInAfterFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenIn, tokenAmountInFee);\\n\\n        return (tokenAmountOut, spotPriceAfter);\\n    }\\n\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint maxAmountIn,\\n        address tokenOut,\\n        uint tokenAmountOut,\\n        uint maxPrice\\n    )\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountIn, uint spotPriceAfter)\\n    {\\n        _preventSameTxOrigin();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenIn);\\n        _requireTokenIsBound(tokenOut);\\n        require(_publicSwap, \\\"NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \\\"OUT_RATIO\\\");\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    _getDenormWeight(tokenIn),\\n                                    outRecord.balance,\\n                                    _getDenormWeight(tokenOut),\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore <= maxPrice, \\\"LIMIT_PRICE\\\");\\n\\n        (uint tokenAmountOutAfterFee, uint tokenAmountOutFee) = calcAmountWithCommunityFee(\\n            tokenAmountOut,\\n            _communitySwapFee,\\n            msg.sender\\n        );\\n\\n        tokenAmountIn = calcInGivenOut(\\n                            inRecord.balance,\\n                            _getDenormWeight(tokenIn),\\n                            outRecord.balance,\\n                            _getDenormWeight(tokenOut),\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n        require(tokenAmountIn <= maxAmountIn, \\\"LIMIT_IN\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                _getDenormWeight(tokenIn),\\n                                outRecord.balance,\\n                                _getDenormWeight(tokenOut),\\n                                _swapFee\\n                            );\\n        require(\\n            spotPriceAfter >= spotPriceBefore &&\\n            spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOutAfterFee),\\n            \\\"MATH_APPROX\\\"\\n        );\\n        require(spotPriceAfter <= maxPrice, \\\"LIMIT_PRICE\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOutAfterFee);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOutAfterFee);\\n        _pushUnderlying(tokenOut, _communityFeeReceiver, tokenAmountOutFee);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenOut, tokenAmountOutFee);\\n\\n        return (tokenAmountIn, spotPriceAfter);\\n    }\\n\\n\\n    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint poolAmountOut)\\n\\n    {\\n        _preventSameTxOrigin();\\n        _requireContractIsFinalized();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenIn);\\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"MAX_IN_RATIO\\\");\\n\\n        (uint tokenAmountInAfterFee, uint tokenAmountInFee) = calcAmountWithCommunityFee(\\n            tokenAmountIn,\\n            _communityJoinFee,\\n            msg.sender\\n        );\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\n                            inRecord.balance,\\n                            _getDenormWeight(tokenIn),\\n                            _totalSupply,\\n                            _getTotalWeight(),\\n                            tokenAmountInAfterFee,\\n                            _swapFee\\n                        );\\n\\n        require(poolAmountOut >= minPoolAmountOut, \\\"LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountInAfterFee);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountInAfterFee);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullCommunityFeeUnderlying(tokenIn, msg.sender, tokenAmountInFee);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountInAfterFee);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenIn, tokenAmountInFee);\\n\\n        return poolAmountOut;\\n    }\\n\\n    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountIn)\\n    {\\n        _preventSameTxOrigin();\\n        _requireContractIsFinalized();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenIn);\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        (uint poolAmountOutAfterFee, uint poolAmountOutFee) = calcAmountWithCommunityFee(\\n            poolAmountOut,\\n            _communityJoinFee,\\n            msg.sender\\n        );\\n\\n        tokenAmountIn = calcSingleInGivenPoolOut(\\n                            inRecord.balance,\\n                            _getDenormWeight(tokenIn),\\n                            _totalSupply,\\n                            _getTotalWeight(),\\n                            poolAmountOut,\\n                            _swapFee\\n                        );\\n\\n        _requireMathApprox(tokenAmountIn);\\n        require(tokenAmountIn <= maxAmountIn, \\\"LIMIT_IN\\\");\\n\\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"MAX_IN_RATIO\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOutAfterFee);\\n        _pushPoolShare(_communityFeeReceiver, poolAmountOutFee);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, address(this), poolAmountOutFee);\\n\\n        return tokenAmountIn;\\n    }\\n\\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut)\\n    {\\n        _preventSameTxOrigin();\\n        _requireContractIsFinalized();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenOut);\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\n                            outRecord.balance,\\n                            _getDenormWeight(tokenOut),\\n                            _totalSupply,\\n                            _getTotalWeight(),\\n                            poolAmountIn,\\n                            _swapFee\\n                        );\\n\\n        require(tokenAmountOut >= minAmountOut, \\\"LIMIT_OUT\\\");\\n\\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"OUT_RATIO\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        (uint tokenAmountOutAfterFee, uint tokenAmountOutFee) = calcAmountWithCommunityFee(\\n            tokenAmountOut,\\n            _communityExitFee,\\n            msg.sender\\n        );\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOutAfterFee);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(poolAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOutAfterFee);\\n        _pushUnderlying(tokenOut, _communityFeeReceiver, tokenAmountOutFee);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenOut, tokenAmountOutFee);\\n\\n        return tokenAmountOutAfterFee;\\n    }\\n\\n    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint poolAmountIn)\\n    {\\n        _preventSameTxOrigin();\\n        _requireContractIsFinalized();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenOut);\\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"OUT_RATIO\\\");\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        (uint tokenAmountOutAfterFee, uint tokenAmountOutFee) = calcAmountWithCommunityFee(\\n            tokenAmountOut,\\n            _communityExitFee,\\n            msg.sender\\n        );\\n\\n        poolAmountIn = calcPoolInGivenSingleOut(\\n                            outRecord.balance,\\n                            _getDenormWeight(tokenOut),\\n                            _totalSupply,\\n                            _getTotalWeight(),\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n\\n        _requireMathApprox(poolAmountIn);\\n        require(poolAmountIn <= maxPoolAmountIn, \\\"LIMIT_IN\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOutAfterFee);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(poolAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOutAfterFee);\\n        _pushUnderlying(tokenOut, _communityFeeReceiver, tokenAmountOutFee);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenOut, tokenAmountOutFee);\\n\\n        return poolAmountIn;\\n    }\\n\\n\\n    // ==\\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n\\n    function _pullUnderlying(address erc20, address from, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\\n        require(xfer, \\\"ERC20_FALSE\\\");\\n    }\\n\\n    function _pushUnderlying(address erc20, address to, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transfer(to, amount);\\n        require(xfer, \\\"ERC20_FALSE\\\");\\n    }\\n\\n    function _pullCommunityFeeUnderlying(address erc20, address from, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transferFrom(from, _communityFeeReceiver, amount);\\n        require(xfer, \\\"ERC20_FALSE\\\");\\n    }\\n\\n    function _pullPoolShare(address from, uint amount)\\n        internal\\n    {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint amount)\\n        internal\\n    {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint amount)\\n        internal\\n    {\\n        if(address(_restrictions) != address(0)) {\\n            uint maxTotalSupply = _restrictions.getMaxTotalSupply(address(this));\\n            require(badd(_totalSupply, amount) <= maxTotalSupply, \\\"MAX_SUPPLY\\\");\\n        }\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint amount)\\n        internal\\n    {\\n        _burn(amount);\\n    }\\n\\n    function _requireTokenIsBound(address token)\\n        internal view\\n    {\\n        require(_records[token].bound, \\\"NOT_BOUND\\\");\\n    }\\n\\n    function _onlyController()\\n        internal view\\n    {\\n        require(msg.sender == _controller, \\\"NOT_CONTROLLER\\\");\\n    }\\n\\n    function _requireContractIsNotFinalized()\\n        internal view\\n    {\\n        require(!_finalized, \\\"IS_FINALIZED\\\");\\n    }\\n\\n    function _requireContractIsFinalized()\\n        internal view\\n    {\\n        require(_finalized, \\\"NOT_FINALIZED\\\");\\n    }\\n\\n    function _requireFeeInBounds(uint256 _fee)\\n        internal pure\\n    {\\n        require(_fee >= MIN_FEE && _fee <= MAX_FEE, \\\"FEE_BOUNDS\\\");\\n    }\\n\\n    function _requireMathApprox(uint256 _value)\\n        internal pure\\n    {\\n        require(_value != 0, \\\"MATH_APPROX\\\");\\n    }\\n\\n    function _preventReentrancy()\\n        internal view\\n    {\\n        require(!_mutex, \\\"REENTRY\\\");\\n    }\\n\\n    function _onlyWrapperOrNotWrapperMode()\\n        internal view\\n    {\\n        require(!_wrapperMode || msg.sender == _wrapper, \\\"ONLY_WRAPPER\\\");\\n    }\\n\\n    function _preventSameTxOrigin()\\n      internal\\n    {\\n      require(block.number > _lastSwapBlock[tx.origin], \\\"SAME_TX_ORIGIN\\\");\\n      _lastSwapBlock[tx.origin] = block.number;\\n    }\\n\\n    function _getDenormWeight(address token)\\n        internal view virtual\\n        returns (uint)\\n    {\\n        return _records[token].denorm;\\n    }\\n\\n    function _getTotalWeight()\\n        internal view virtual\\n        returns (uint)\\n    {\\n        return _totalWeight;\\n    }\\n\\n    function _addTotalWeight(uint _amount) internal virtual {\\n        _totalWeight = badd(_totalWeight, _amount);\\n        require(_totalWeight <= MAX_TOTAL_WEIGHT, \\\"MAX_TOTAL_WEIGHT\\\");\\n    }\\n\\n    function _subTotalWeight(uint _amount) internal virtual {\\n        _totalWeight = bsub(_totalWeight, _amount);\\n    }\\n\\n    function calcAmountWithCommunityFee(\\n        uint tokenAmountIn,\\n        uint communityFee,\\n        address operator\\n    )\\n        public view override\\n        returns (uint tokenAmountInAfterFee, uint tokenAmountFee)\\n    {\\n        if (address(_restrictions) != address(0) && _restrictions.isWithoutFee(operator)) {\\n            return (tokenAmountIn, 0);\\n        }\\n        uint adjustedIn = bsub(BONE, communityFee);\\n        tokenAmountInAfterFee = bmul(tokenAmountIn, adjustedIn);\\n        tokenAmountFee = bsub(tokenAmountIn, tokenAmountInAfterFee);\\n        return (tokenAmountInAfterFee, tokenAmountFee);\\n    }\\n\\n    function getMinWeight()\\n        external view override\\n        returns (uint)\\n    {\\n        return MIN_WEIGHT;\\n    }\\n\\n    function getMaxBoundTokens()\\n        external view override\\n        returns (uint)\\n    {\\n      return MAX_BOUND_TOKENS;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/balancer-core/BToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./BNum.sol\\\";\\n\\ncontract BTokenBase is BNum {\\n\\n    mapping(address => uint)                   internal _balance;\\n    mapping(address => mapping(address=>uint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _validateAddress(src);\\n        _validateAddress(dst);\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n\\n    function _validateAddress(address addr) internal {\\n        require(addr != address(0), \\\"ERR_NULL_ADDRESS\\\");\\n    }\\n}\\n\\ncontract BToken is BTokenBase, IERC20 {\\n\\n    string  internal _name;\\n    string  internal _symbol;\\n    uint8   private _decimals = 18;\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns(uint8) {\\n        return _decimals;\\n    }\\n\\n    function allowance(address src, address dst) external override view returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external override view returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public override view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external override returns (bool) {\\n        _validateAddress(dst);\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _validateAddress(dst);\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        _validateAddress(dst);\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external override returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \\\"ERR_BTOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(src, msg.sender, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolRestrictions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IPoolRestrictions {\\n  function getMaxTotalSupply(address _pool) external view returns (uint256);\\n\\n  function isVotingSignatureAllowed(address _votingAddress, bytes4 _signature) external view returns (bool);\\n\\n  function isVotingSenderAllowed(address _votingAddress, address _sender) external view returns (bool);\\n\\n  function isWithoutFee(address _addr) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Reservoir.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract Reservoir is Ownable {\\n  constructor() public Ownable() {}\\n\\n  function setApprove(\\n    address _token,\\n    address _to,\\n    uint256 _amount\\n  ) external onlyOwner {\\n    IERC20(_token).approve(_to, _amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/WrappedPiErc20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface WrappedPiErc20Interface is IERC20 {\\n  function deposit(uint256 _amount) external;\\n\\n  function withdraw(uint256 _amount) external;\\n\\n  function changeRouter(address _newRouter) external;\\n\\n  function approveToken(address _to, uint256 _amount) external;\\n\\n  function callVoting(\\n    address voting,\\n    bytes4 signature,\\n    bytes calldata args,\\n    uint256 value\\n  ) external;\\n\\n  function getWrappedBalance() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface TokenInterface is IERC20 {\\n  function deposit() external payable;\\n\\n  function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMigrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMigrator {\\n  // Perform LP token migration from legacy UniswapV2 to PowerSwap.\\n  // Take the current LP token address and return the new LP token address.\\n  // Migrator should have full access to the caller's LP token.\\n  // Return the new LP token address.\\n  //\\n  // XXX Migrator must have allowance access to UniswapV2 LP tokens.\\n  // PowerSwap must mint EXACTLY the same amount of PowerSwap LP tokens or\\n  // else something bad will happen. Traditional UniswapV2 does not\\n  // do that so be careful!\\n  function migrate(IERC20 token, uint8 poolType) external returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"contracts/balancer-core/BFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is disstributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\n// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\\n\\nimport \\\"./BPool.sol\\\";\\n\\ncontract BFactory {\\n    event LOG_NEW_POOL(\\n        address indexed caller,\\n        address indexed pool\\n    );\\n\\n    mapping(address => bool) public isBPool;\\n\\n    constructor() public { }\\n\\n    function newBPool(string calldata name, string calldata symbol)\\n        external\\n        returns (BPool)\\n    {\\n        BPool bpool = new BPool(name, symbol);\\n        isBPool[address(bpool)] = true;\\n        emit LOG_NEW_POOL(msg.sender, address(bpool));\\n        bpool.setController(msg.sender);\\n        return bpool;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BFactoryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./BPoolInterface.sol\\\";\\n\\ninterface BFactoryInterface {\\n  function newBPool(string calldata name, string calldata symbol) external returns (BPoolInterface);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minWeightPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeightPerSecond\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voting\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"inputSig\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"inputData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"outputData\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL_VOTING\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"LOG_COMMUNITY_FEE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromDenorm\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetDenorm\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"}],\"name\":\"SetDynamicWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minWeightPerSecond\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWeightPerSecond\",\"type\":\"uint256\"}],\"name\":\"SetWeightPerSecondBounds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetDenorm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"calcAmountWithCommunityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountInAfterFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolInGivenSingleOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolOutGivenSingleIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleInGivenPoolOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleOutGivenPoolIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voting\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"signature\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"args\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"callVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPoolAmountIn\",\"type\":\"uint256\"}],\"name\":\"exitswapExternAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"exitswapPoolAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCommunityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"communitySwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityJoinFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityExitFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"communityFeeReceiver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDynamicWeightSettings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fromTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromDenorm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetDenorm\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBoundTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getNormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRestrictions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPriceSansFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeightPerSecondBounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minWeightPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeightPerSecond\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWrapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWrapperMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"gulp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"}],\"name\":\"joinswapPoolAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"rebind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"communitySwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityJoinFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityExitFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"communityFeeReceiver\",\"type\":\"address\"}],\"name\":\"setCommunityFeeAndReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetDenorm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"}],\"name\":\"setDynamicWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"public_\",\"type\":\"bool\"}],\"name\":\"setPublicSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPoolRestrictions\",\"name\":\"restrictions\",\"type\":\"address\"}],\"name\":\"setRestrictions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minWeightPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeightPerSecond\",\"type\":\"uint256\"}],\"name\":\"setWeightPerSecondBounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"wrapperMode\",\"type\":\"bool\"}],\"name\":\"setWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unbind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PowerIndexPool","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000004b3090ab80100000000000000000000000000000000000000000000000000000d287fb79cd10000000000000000000000000000000000000000000000000000000000000016506f77657220496e64657820506f6f6c20546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000045049505400000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}