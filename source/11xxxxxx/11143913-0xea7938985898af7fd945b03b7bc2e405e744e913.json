{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IAuthority.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract IAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\n// File: contracts/DSAuth.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\n/**\r\n * @title DSAuth\r\n * @dev The DSAuth contract is reference implement of https://github.com/dapphub/ds-auth\r\n * But in the isAuthorized method, the src from address(this) is remove for safty concern.\r\n */\r\ncontract DSAuth is DSAuthEvents {\r\n    IAuthority   public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(IAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == owner) {\r\n            return true;\r\n        } else if (authority == IAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/PausableDSAuth.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract PausableDSAuth is DSAuth {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/interfaces/IBurnableERC20.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract IBurnableERC20 {\r\n    function burn(address _from, uint _value) public;\r\n}\r\n\r\n// File: contracts/interfaces/ISettingsRegistry.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract ISettingsRegistry {\r\n    enum SettingsValueTypes { NONE, UINT, STRING, ADDRESS, BYTES, BOOL, INT }\r\n\r\n    function uintOf(bytes32 _propertyName) public view returns (uint256);\r\n\r\n    function stringOf(bytes32 _propertyName) public view returns (string);\r\n\r\n    function addressOf(bytes32 _propertyName) public view returns (address);\r\n\r\n    function bytesOf(bytes32 _propertyName) public view returns (bytes);\r\n\r\n    function boolOf(bytes32 _propertyName) public view returns (bool);\r\n\r\n    function intOf(bytes32 _propertyName) public view returns (int);\r\n\r\n    function setUintProperty(bytes32 _propertyName, uint _value) public;\r\n\r\n    function setStringProperty(bytes32 _propertyName, string _value) public;\r\n\r\n    function setAddressProperty(bytes32 _propertyName, address _value) public;\r\n\r\n    function setBytesProperty(bytes32 _propertyName, bytes _value) public;\r\n\r\n    function setBoolProperty(bytes32 _propertyName, bool _value) public;\r\n\r\n    function setIntProperty(bytes32 _propertyName, int _value) public;\r\n\r\n    function getValueTypeOf(bytes32 _propertyName) public view returns (uint /* SettingsValueTypes */ );\r\n\r\n    event ChangeProperty(bytes32 indexed _propertyName, uint256 _type);\r\n}\r\n\r\n// File: contracts/Issuing.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\ncontract Issuing is PausableDSAuth {\r\n    // claimedToken event\r\n    event ClaimedTokens(\r\n        address indexed token,\r\n        address indexed owner,\r\n        uint256 amount\r\n    );\r\n\r\n    event BurnAndRedeem(\r\n        address indexed token,\r\n        address indexed from,\r\n        uint256 amount,\r\n        bytes receiver\r\n    );\r\n\r\n    ISettingsRegistry public registry;\r\n\r\n    mapping(address => bool) public supportedTokens;\r\n\r\n    constructor(address _registry) public{\r\n        registry = ISettingsRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n     * @dev ERC223 fallback function, make sure to check the msg.sender is from target token contracts\r\n     * @param _from - person who transfer token in for deposits or claim deposit with penalty KTON.\r\n     * @param _amount - amount of token.\r\n     * @param _data - data which indicate the operations.\r\n     */\r\n    function tokenFallback(\r\n        address _from,\r\n        uint256 _amount,\r\n        bytes _data\r\n    ) public whenNotPaused {\r\n        bytes32 darwiniaAddress;\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            darwiniaAddress := mload(add(ptr, 132))\r\n        }\r\n\r\n        //  Only supported tokens can be called\r\n        require(supportedTokens[msg.sender], \"Permission denied\");\r\n        require(\r\n            _data.length == 32,\r\n            \"The address (Darwinia Network) must be in a 32 bytes hexadecimal format\"\r\n        );\r\n        require(\r\n            darwiniaAddress != bytes32(0),\r\n            \"Darwinia Network Address can't be empty\"\r\n        );\r\n\r\n        // SettingIds.UINT_BRIDGE_FEE\r\n        uint256 bridgeFee = registry.uintOf(\r\n            0x55494e545f4252494447455f4645450000000000000000000000000000000000\r\n        );\r\n\r\n        // SettingIds.CONTRACT_BRIDGE_POOL\r\n        address bridgePool = registry.addressOf(\r\n            0x434f4e54524143545f4252494447455f504f4f4c000000000000000000000000\r\n        );\r\n\r\n        // SettingIds.CONTRACT_RING_ERC20_TOKEN\r\n        address ring = registry.addressOf(\r\n            0x434f4e54524143545f52494e475f45524332305f544f4b454e00000000000000\r\n        );\r\n\r\n        // BridgeFee will be paid to the relayer\r\n        if (bridgeFee > 0) {\r\n            require(\r\n                ERC20(ring).transferFrom(_from, bridgePool, bridgeFee),\r\n                \"Error when paying transaction fees\"\r\n            );\r\n        }\r\n\r\n        IBurnableERC20(msg.sender).burn(address(this), _amount);\r\n        emit BurnAndRedeem(msg.sender, _from, _amount, _data);\r\n    }\r\n\r\n    function addSupportedTokens(address _token) public auth {\r\n        supportedTokens[_token] = true;\r\n    }\r\n\r\n    function removeSupportedTokens(address _token) public auth {\r\n        supportedTokens[_token] = false;\r\n    }\r\n\r\n    /// @notice This method can be used by the owner to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public auth {\r\n        if (_token == 0x0) {\r\n            owner.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        ERC20 token = ERC20(_token);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        token.transfer(owner, balance);\r\n\r\n        emit ClaimedTokens(_token, owner, balance);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addSupportedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"removeSupportedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"receiver\",\"type\":\"bytes\"}],\"name\":\"BurnAndRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"Issuing","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b0940772516b69088904564a56d09cfe6bb3d85","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://1f7651ee272bbaf7369ba4fb4d172b3b48ee72e83a63bf5e40badf2833b73b4e"}]}