/*

─██████████████─██████████████─██████████████─██████████─██████████████─██████────────────██████████████───██████████─
─██░░░░░░░░░░██─██░░░░░░░░░░██─██░░░░░░░░░░██─██░░░░░░██─██░░░░░░░░░░██─██░░██────────────██░░░░░░░░░░██───██░░░░░░██─
─██░░██████████─██░░██████░░██─██░░██████████─████░░████─██░░██████░░██─██░░██────────────██░░██████░░██───████░░████─
─██░░██─────────██░░██──██░░██─██░░██───────────██░░██───██░░██──██░░██─██░░██────────────██░░██──██░░██─────██░░██───
─██░░██████████─██░░██──██░░██─██░░██───────────██░░██───██░░██████░░██─██░░██────────────██░░██████░░████───██░░██───
─██░░░░░░░░░░██─██░░██──██░░██─██░░██───────────██░░██───██░░░░░░░░░░██─██░░██────────────██░░░░░░░░░░░░██───██░░██───
─██████████░░██─██░░██──██░░██─██░░██───────────██░░██───██░░██████░░██─██░░██────────────██░░████████░░██───██░░██───
─────────██░░██─██░░██──██░░██─██░░██───────────██░░██───██░░██──██░░██─██░░██────────────██░░██────██░░██───██░░██───
─██████████░░██─██░░██████░░██─██░░██████████─████░░████─██░░██──██░░██─██░░██████████────██░░████████░░██─████░░████─
─██░░░░░░░░░░██─██░░░░░░░░░░██─██░░░░░░░░░░██─██░░░░░░██─██░░██──██░░██─██░░░░░░░░░░██────██░░░░░░░░░░░░██─██░░░░░░██─
─██████████████─██████████████─██████████████─██████████─██████──██████─██████████████────████████████████─██████████─
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

𝟩'𝟩𝟩𝟩.𝟩𝟩𝟩 𝖲𝖡𝖨 | 𝖦𝖾𝗇𝖾𝗋𝖺𝗍𝗂𝗈𝗇 𝗈𝖿 𝗐𝖾𝖺𝗅𝗍𝗁 | 𝖨𝗇𝗏𝖾𝗌𝗍𝗆𝖾𝗇𝗍 𝗂𝗇𝗌𝗎𝗋𝖺𝗇𝖼𝖾 | 𝖥𝗂𝗋𝗌𝗍 𝖲𝖡𝖨 𝖱𝖠𝖥𝖥𝖫𝖤 |
7'777.777 𝘚𝘉𝘐 | 𝘎𝘦𝘯𝘦𝘳𝘢𝘤𝘪𝘰𝘯 𝘥𝘦 𝘳𝘪𝘲𝘶𝘦𝘻𝘢 | 𝘚𝘦𝘨𝘶𝘳𝘰 𝘥𝘦 𝘪𝘯𝘷𝘦𝘳𝘴𝘪𝘰𝘯 | 𝘍𝘪𝘳𝘴𝘵 𝘚𝘉𝘐 𝘙𝘈𝘍𝘍𝘓𝘌 |



██████╗░███████╗░█████╗░███████╗███╗░░██╗████████╗██████╗░░█████╗░██╗░░░░░██╗███████╗███████╗██████╗░
██╔══██╗██╔════╝██╔══██╗██╔════╝████╗░██║╚══██╔══╝██╔══██╗██╔══██╗██║░░░░░██║╚════██║██╔════╝██╔══██╗
██║░░██║█████╗░░██║░░╚═╝█████╗░░██╔██╗██║░░░██║░░░██████╔╝███████║██║░░░░░██║░░███╔═╝█████╗░░██║░░██║
██║░░██║██╔══╝░░██║░░██╗██╔══╝░░██║╚████║░░░██║░░░██╔══██╗██╔══██║██║░░░░░██║██╔══╝░░██╔══╝░░██║░░██║
██████╔╝███████╗╚█████╔╝███████╗██║░╚███║░░░██║░░░██║░░██║██║░░██║███████╗██║███████╗███████╗██████╔╝
╚═════╝░╚══════╝░╚════╝░╚══════╝╚═╝░░╚══╝░░░╚═╝░░░╚═╝░░╚═╝╚═╝░░╚═╝╚══════╝╚═╝╚══════╝╚══════╝╚═════╝░

███████╗██╗███╗░░██╗░█████╗░███╗░░██╗░█████╗░███████╗
██╔════╝██║████╗░██║██╔══██╗████╗░██║██╔══██╗██╔════╝
█████╗░░██║██╔██╗██║███████║██╔██╗██║██║░░╚═╝█████╗░░
██╔══╝░░██║██║╚████║██╔══██║██║╚████║██║░░██╗██╔══╝░░
██║░░░░░██║██║░╚███║██║░░██║██║░╚███║╚█████╔╝███████╗
╚═╝░░░░░╚═╝╚═╝░░╚══╝╚═╝░░╚═╝╚═╝░░╚══╝░╚════╝░╚══════╝


𝘚𝘖𝘊𝘐𝘈𝘓𝘉𝘐 𝘋𝘌𝘊𝘌𝘕𝘛𝘙𝘈𝘓𝘐𝘡𝘌𝘋 𝘍𝘐𝘕𝘈𝘕𝘊𝘌 𝘗𝘓𝘈𝘛𝘍𝘖𝘙𝘔 𝘊𝘖𝘕𝘛𝘙𝘈𝘊𝘛


THIS CONTRACT is effective as of october 28 2020 BY AND BETWEEN:

		BEORUS CORPORATION, a company incorporated under the laws of United States of America, and having its head office at  12550 BISCAYNE BLVD STE 110 MIAMI,
		FL 33181, (hereinafter referred to as “OWNER”) and 
					OF THE FIRST PART
- and -

[SOCIALBI, a decentralized finance platform under the Ethereum Blockchain,
		 (hereinafter referred to as “DEFI”) 	
							OF THE SECOND PART]
-	and –
[ SUB-DISTRIBUTOR , a user incorporated by register at : register, (hereinafter referred to as “SUB-DISTRIBUTOR”

						OF THE THIRD PART]

WHEREAS: 

OWNER is the manufacturer of the platform (as hereinafter defined);

THE OWNER has determined that for the generation of wealth in society it would be advantageous to coordinate its activities with a DEFI that has a wide readily available sales network; and

DEFI wishes to enter into this Agreement with OWNER whereby DEFI will undertake the distribution and sale of tokens on the terms and subject to the conditions contained herein;

NOW THEREFORE THIS AGREEMENT WITNESSES that in consideration of the mutual promises and covenants herein contained and for other good and valuable consideration (the receipt and sufficiency of which are hereby acknowledged) the parties hereby agree as follows:


***********
********
*****
**

→→→ Article 1 – SBI TOKEN 
SBI is the token that originates exclusively and uniquely through this contract, the objective of the token is its valuation, for this the following measures have been implemented:
1.1 The Ethereum blockchain prohibits the creation of new SBI tokens which ensures that the value of the SBI token increases with usability.
1.2 The total amount of SBI tokens in the contract is 7,777,777 (7 times 7), which means that it covers a maximum of 3 times the number of tokens required for the raffle that uses the most tokens, which creates an environment of scarcity, giving an implicit valuation to the token.
1.3 The token has 18 decimal places, which guarantees a complete calculation of the value, allowing a usability of decimal places in the future.

TRANSLATION TO SPANISH
SBI es el token que se origina de forma exclusiva y única por medio de este contrato, el objetivo del token es su valorización, para esto se ha implementado las siguientes medidas: 
1.1 La blockchain de Ethereum prohibe la creación de nuevos tokens SBI lo que garantiza que el valor del token SBI aumente con la usabilidad.
1.2 La cantidad total de tokens SBI del contrato es de 7’777.777 (7 veces 7) lo que significa que cubre como máximo 3 veces el número de los tokens necesarios para la rifa que más tokens utiliza, lo que genera un ambiente de escasez, dando una valoración implícita al token.
1.3 El token tiene 18 decimales, lo que garantiza un cálculo completo del valor, permitiendo una usabilidad de decimales en el futuro.
*/


pragma solidity 0.5.11;


contract SocialBIToken {
address public ownerWallet;
    string public constant name = "SOCIALBI DEFI";
    string public constant symbol = "SBI";
    uint8 public constant decimals = 18; 

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event TransferFromContract(address indexed from, address indexed to, uint tokens,uint status);

    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;
   
    uint256 totalSupply_=7777777000000000000000000;

    using SafeMath for uint256;


   constructor() public { 
       ownerWallet=msg.sender;
        balances[ownerWallet] = totalSupply_;
    } 

    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }
   
    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }
   
    function balanceOfOwner() public view returns (uint) {
        return balances[ownerWallet];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }
   
    function transferFromOwner(address receiver, uint numTokens,uint status) internal returns (bool) {
        numTokens=numTokens*1000000000000000000;
        if(numTokens <= balances[ownerWallet]){
        balances[ownerWallet] = balances[ownerWallet].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit TransferFromContract(ownerWallet, receiver, numTokens,status);
        }
        return true;
    }

    function approve(address delegate, uint numTokens) public returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint numTokens) internal returns (bool) {
        require(numTokens <= balances[owner]);   
        require(numTokens <= allowed[owner][msg.sender]);
   
        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
      assert(b <= a);
      return a - b;
    }
   
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
      uint256 c = a + b;
      assert(c >= a);
      return c;
    }
}

/*
→ → → Article 2 – SYSTEM DISTRIBUTION
SocialBI has a distribution system for SBI tokens under the following parameters:
2.1 The platform's token distribution system will be done by purchasing pack1, pack2 and pack3
2.2 The platform includes a referral system with rewards in ETH and Tokens
2.3 The SBI tokens will be used immediately in 14 contracts related to this contract under the modality of raffles, which from now on will be called SBI RAFFLE.

TRANSLATION TO SPANISH
SocialBI tiene un sistema de distribución de los tokens SBI bajo los siguientes parámetros:
2.1 El sistema de distribución de tokens de la plataforma se lo realizará mediante la compra de los pack1, pack2 y pack3
2.2 La plataforma incluye un sistema de referidos con recompensas en ETH y Tokens
2.3 Los tokens SBI serán utilizadas de forma inmediata en 14 contratos afines a este contrato bajo la modalidad de rifas, que de ahora en adelante serán llamadas SBI RAFFLE.
*/


contract SocialBI is SocialBIToken{
    
     address public ownerWallet;
        uint public currUserID = 0;
        uint public pack1currUserID = 0;
        uint public pack2currUserID = 0;
        uint public pack3currUserID = 0;
        uint public pack1activeUserID = 0;
        uint public pack2activeUserID = 0;
        uint public pack3activeUserID = 0;
        uint public unlimited_level_price=0;
    
      struct UserStruct {
        bool isExist;
        uint id;
        uint referrerID;
        uint referredUsers;
        mapping(uint => uint) levelExpired;
        uint referredUserspack3;
        uint referredUserspack1;
    }
   
 
   
     struct PackUserStruct {
        bool isExist;
        uint id;
        uint payment_received;
        bool firstSBI_raffle;
        address user;
    }
     struct UserRegStruct{
        bool isExist;
        uint userid;
        uint nooftime;
        uint payment_received;
        uint packid;
    }
     mapping (address => UserStruct) public users;
     mapping (uint => address) public userList;
    
     mapping (uint => PackUserStruct) public pack1users;
     mapping (address => UserRegStruct) public pack1userList;
   
     mapping (uint => PackUserStruct) public pack2users;
     mapping (address => UserRegStruct) public pack2userList;
    
     mapping (uint => PackUserStruct) public pack3users;
     mapping (address => UserRegStruct) public pack3userList;
    
     uint counter =0;
     uint pack_payment_amount=0.02 ether;
 
     event getMoneyForPackLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time);
     event regLevelEvent(address indexed _user, address indexed _referrer, uint _time);
     event regPackEntry(address indexed _user,uint _level,   uint _time,uint packid);
     event getPackPayment(address indexed _user,address indexed _receiver, uint _level, uint _time);
     event firstSBIraffle(uint id,address indexed _receiver, uint _level, uint _time);
   
    UserStruct[] public requests;
    
     event Deposite(uint amount,uint time);
    
    
     constructor()SocialBIToken() public {
        ownerWallet = msg.sender;
        UserStruct memory userStruct;
        UserRegStruct memory packuserreg;
       
        currUserID++;

        userStruct = UserStruct({
           isExist: true,
           id: currUserID,
           referrerID: 0,
           referredUsers:0,
           referredUserspack3:0,
           referredUserspack1:0
        });
       
        users[ownerWallet] = userStruct;
       userList[currUserID] = ownerWallet;
      
      
        PackUserStruct memory packuserStruct;

        pack1currUserID++;
        packuserStruct = PackUserStruct({
            isExist:true,
            id:pack1currUserID,
            payment_received:0,
            firstSBI_raffle:false,
            user:msg.sender
        });
        pack1activeUserID=pack1currUserID;
        pack1users[pack1currUserID] = packuserStruct;
        packuserreg = UserRegStruct({
            isExist: true,
            userid: currUserID,
            payment_received:0,
            nooftime:1,
            packid:pack1currUserID
        });
        pack1userList[msg.sender]=packuserreg;
     
       
       
        pack2currUserID++;
        packuserStruct = PackUserStruct({
            isExist:true,
            id:pack2currUserID,
            payment_received:0,
            firstSBI_raffle:false,
            user:msg.sender
        });
        pack2activeUserID=pack2currUserID;
        pack2users[pack2currUserID] = packuserStruct;
        packuserreg = UserRegStruct({
            isExist: true,
            userid: currUserID,
           nooftime:1,
           packid:pack2currUserID,
           payment_received:0
        });
        pack2userList[msg.sender]=packuserreg;
      
      
        pack3currUserID++;
        packuserStruct = PackUserStruct({
            isExist:true,
            id:pack3currUserID,
            payment_received:0,
            firstSBI_raffle:false,
            user:msg.sender
        });
        pack3activeUserID=pack3currUserID;
        pack3users[pack3currUserID] = packuserStruct;
        packuserreg = UserRegStruct({
            isExist: true,
            userid: currUserID,
           nooftime:1,
           packid:pack3currUserID,
           payment_received:0
        });
        pack3userList[msg.sender]=packuserreg;
      
      
     }
     
/*
→ → → Article 3 – SOCIAL
This contract is aimed at generating wealth. This social purpose includes two mechanisms, the first is for the entrepreneur where he does not need any investment and the second is for the investor, providing each of them with the generation of wealth under the following terms.
3.1 Registration to the platform is free.
3.2 When registering, the user receives 1 SBI (Seed of Business) that is credited directly to the Wallet.
3.2 By registering the guests with the user's number, the user earns 2 SBI for each guest.
3.3 If the guest buys a package, the user earns 25% of the ETH value of the package and also receives SBI tokens.

TRANSLATION TO SPANISH
Este contrato tiene como objetivo la generación de riqueza. Esta finalidad social incluye dos mecanismos, el primero es para el emprendedor en donde no necesita ninguna inversión y el segundo es para el inversionista, brindando a cada uno de ellos la generación de riqueza bajo los siguientes términos. 
3.1 El registro a la plataforma es gratuita.
3.2 El usuario al registrarse recibe 1 SBI (semilla del negocio) que se acredita directamente a la Wallet.
3.2 Al registrarse los invitados con el número del usuario, el usuario gana 2 SBI por cada invitado.
3.3 Si el invitado compra algún paquete, el usuario gana el 25% del valor en ETH del paquete y además recibe tokens SBI. 
*/

    
     function regUser(uint _referrerID) public {
      
      require(!users[msg.sender].isExist, "User already exists");
      require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect referral ID');
      
      
      if(!users[msg.sender].isExist)
      {
        UserStruct memory userStruct;
        currUserID++;

        userStruct = UserStruct({
            isExist: true,
            id: currUserID,
            referrerID: _referrerID,
            referredUsers:0,
            referredUserspack3:0,
            referredUserspack1:0
        });
 
   
        users[msg.sender] = userStruct;
        userList[currUserID]=msg.sender;
      
        users[userList[users[msg.sender].referrerID]].referredUsers=users[userList[users[msg.sender].referrerID]].referredUsers+1;
       
        transferFromOwner(msg.sender,1,1);
        payReferral(msg.sender);
        emit regLevelEvent(msg.sender, userList[_referrerID], now);
      }
    }
  
  
     function payReferral( address _user) internal {
        address referer;
        referer = userList[users[_user].referrerID];
        transferFromOwner(referer,2,2);
     }
  
  
  
  
  
     function payPackReferral(uint _level, address _user) internal {
        address referer;
        referer = userList[users[_user].referrerID];
      
         bool sent = false;
            if(_level==1)
            {
                pack_payment_amount=0.05 ether;
            }
            else if(_level==2)
            {
                pack_payment_amount=0.125 ether;
            }
            else
            {
                pack_payment_amount=0.25 ether;
            }
            sent = address(uint160(referer)).send(pack_payment_amount);

            if (sent) {
                emit getMoneyForPackLevelEvent(referer, msg.sender, _level, now);
                if(_level==1)
                {
                    transferFromOwner(referer,20,3);
                }
                else if(_level==2)
                {
                    transferFromOwner(referer,50,4);
                }
                else
                {
                    transferFromOwner(referer,100,5);
                }
           
            }
           
           
            if(_level==1)
            {
                pack_payment_amount=0.05 ether;
            }
            else if(_level==2)
            {
                pack_payment_amount=0.125 ether;
            }
            else
            {
                pack_payment_amount=0.25 ether;
            }
           
           
             if (address(uint160(ownerWallet)).send(pack_payment_amount))
         {
             emit getMoneyForPackLevelEvent(referer, ownerWallet, _level, now);
         }
     }
  
/*
→ → → Article 4  – PACKAGES AND INVESTMENT INSURANCE
Buying packages and distributing SBI tokens works as follows:
4.1 For the purchase of pack1 you receive 200 SBI.
4.2 For the purchase of pack2 you receive 500 SBI
4.3 For the purchase of pack3 you receive 1250 SBI
4.4 All packages have 50% investment insurance, delivered in the form of 20 payments of 0.005 ETH for pack1, 0.0125 ETH for pack2 and 0.025 ETH for pack3.
4.5 Upon completing all payments, the buyer of each package receives a loyalty tokens.

TRANSLATION TO SPANISH
La compra de paquetes y la distribución de tokens SBI funciona de la siguiente forma:
4.1 Por la compra del pack1 recibe 200 SBI.
4.2 Por la compra del pack2 recibe 500 SBI
4.3 Por la compra del pack3 recibe 1250 SBI
4.4 Todos los paquetes tienen un seguro de inversión del 50%, que se entregan en forma de 20 pagos de 0,005 ETH para el pack1, 0,0125 ETH para el pack2 y 0,025 ETH para el pack3.
4.5 Al cumplir todos los pagos el comprador de cada paquete recibe tokens de fidelidad.

*/


     function buyPack1() public payable {
        require(users[msg.sender].isExist, "Register first please");
        require(msg.value == 0.2 ether, 'Error, the amount of ether is 0.2 ether');
   
        PackUserStruct memory userStruct;
        UserRegStruct memory userregStruct;
        pack1currUserID++;
        userStruct = PackUserStruct({
            isExist:true,
            id:pack1currUserID,
            payment_received:0,
            firstSBI_raffle:false,
            user:msg.sender
        });
       pack1users[pack1currUserID] = userStruct;

      
        if(pack1userList[msg.sender].isExist){
            pack1userList[msg.sender].nooftime=pack1userList[msg.sender].nooftime+1;
        }
        else{
        userregStruct=UserRegStruct({
            isExist:true,
            userid:users[msg.sender].id,
            nooftime:1,
            packid:pack1currUserID,
            payment_received:0
        });
        pack1userList[msg.sender]=userregStruct;
        users[userList[users[msg.sender].referrerID]].referredUserspack1=users[userList[users[msg.sender].referrerID]].referredUserspack1+1;
        }
      
        transferFromOwner(msg.sender,200,6);
        payPackReferral(1,msg.sender);
        uint pack1activeUserID_local=pack1activeUserID; 
        uint temp_i=2;
            for (uint i=0; i<2; i++) {
            if((pack1activeUserID_local+i)>pack1currUserID){
              temp_i=i;
              break;
             }
        uint pack1Currentuser=pack1users[pack1activeUserID_local+i].id;
        bool sent = false;
         
        sent = address(uint160(pack1users[pack1Currentuser].user)).send(0.005 ether);

            if (sent) {
                pack1users[pack1Currentuser].payment_received+=1;
                pack1userList[pack1users[pack1Currentuser].user].payment_received+=1;
                if(pack1users[pack1Currentuser].payment_received>=20)
                {
                    pack1activeUserID+=1;
                }
                emit getPackPayment(msg.sender,pack1users[pack1Currentuser].user, 1, now);
                transferFromOwner(pack1users[pack1Currentuser].user,2,9);
                }
      
        }
        if(temp_i<2)
                  {
                  bool s= address(uint160(ownerWallet)).send(0.005 ether * (2-temp_i)); 
                  if(s){}
                    }
        emit regPackEntry(msg.sender, 1, now,pack1currUserID);
             counter=0;
        if(((pack1currUserID-1)%10)==0 && pack1currUserID>=7){
           firstSBIrafflePack1();
           }
      }
   

     function buyPack2() public payable {
        require(pack1userList[msg.sender].isExist, "Need to buy pack 1 first");   
        require(msg.value == 0.5 ether, 'Error, the amount of ether is 0.5 ether');
       
      
        PackUserStruct memory userStruct;
        UserRegStruct memory userregStruct;
       
        pack2currUserID++;
        userStruct = PackUserStruct({
            isExist:true,
            id:pack2currUserID,
            payment_received:0,
            firstSBI_raffle:false,
            user:msg.sender
        });
        pack2users[pack2currUserID] = userStruct;
      
        if(pack2userList[msg.sender].isExist){
            pack2userList[msg.sender].nooftime=pack2userList[msg.sender].nooftime+1;
        }
        else{
            userregStruct=UserRegStruct({
                isExist:true,
                userid:users[msg.sender].id,
                nooftime:1,
                packid:pack2currUserID,
                payment_received:0
            });
            pack2userList[msg.sender]=userregStruct;
        }
      
      
        transferFromOwner(msg.sender,500,7);
        payPackReferral(2,msg.sender);
        uint pack2activeUserID_local=pack2activeUserID;
        uint temp_i=2;
        for (uint i=0; i<2; i++) {
           if((pack2activeUserID_local+i)>pack2currUserID){
                temp_i=i;
               break;
           }
         uint pack2Currentuser=pack2users[pack2activeUserID_local+i].id;
        
        bool sent = false;
        
        sent = address(uint160(pack2users[pack2Currentuser].user)).send(0.0125 ether);

            if (sent) {
                pack2users[pack2Currentuser].payment_received+=1;
                 pack2userList[pack2users[pack2Currentuser].user].payment_received+=1;
                if(pack2users[pack2Currentuser].payment_received>=20)
                {
                    pack2activeUserID+=1;
                }
                emit getPackPayment(msg.sender,pack2users[pack2Currentuser].user, 2, now);
                transferFromOwner(pack2users[pack2Currentuser].user,5,10);
            }
      
          }
        if(temp_i<2)
            {
        bool s= address(uint160(ownerWallet)).send(0.0125 ether * (2-temp_i)); 
        if(s){}
        }
        emit regPackEntry(msg.sender, 2, now,pack2currUserID);
        counter=0;
        if(((pack2currUserID-1)%10)==0 && pack2currUserID>=7){
        firstSBIrafflePack2();
        }
      
     }
     
    
     function buyPack3() public payable {
      require(pack2userList[msg.sender].isExist, "Need to buy pack 1 and 2 first");   
        require(msg.value == 1 ether, 'Error, the amount of ether is 1 ether');
       
      
        PackUserStruct memory userStruct;
        UserRegStruct memory userregStruct;
       
        pack3currUserID++;
        userStruct = PackUserStruct({
            isExist:true,
            id:pack3currUserID,
            payment_received:0,
            firstSBI_raffle:false,
            user:msg.sender
        });
        pack3users[pack3currUserID] = userStruct;
      
         if(pack3userList[msg.sender].isExist){
            pack3userList[msg.sender].nooftime=pack3userList[msg.sender].nooftime+1;
        }
        else{
            userregStruct=UserRegStruct({
                isExist:true,
                userid:users[msg.sender].id,
                nooftime:1,
                packid:pack3currUserID,
                payment_received:0
            });
            pack3userList[msg.sender]=userregStruct;
        }
      
      
        transferFromOwner(msg.sender,1250,8);
        payPackReferral(3,msg.sender);
        uint pack3activeUserID_local=pack3activeUserID;
        uint temp_i=2;
        for (uint i=0; i<2; i++) {
           if((pack3activeUserID_local+i)>pack3currUserID){
                temp_i=i;
               break;
           }
         uint pack3Currentuser=pack3users[pack3activeUserID_local+i].id;
        
        bool sent = false;
        
   
        
        sent = address(uint160(pack3users[pack3Currentuser].user)).send(0.025 ether);

            if (sent) {
                pack3users[pack3Currentuser].payment_received+=1;
                pack3userList[pack3users[pack3Currentuser].user].payment_received+=1;
                if(pack3users[pack3Currentuser].payment_received>=20)
                {
                    pack3activeUserID+=1;
                }
                emit getPackPayment(msg.sender,pack3users[pack3Currentuser].user, 3, now);
                transferFromOwner(pack3users[pack3Currentuser].user,10,11);
            }
      
         }
        if(temp_i<2)
        {
        bool s= address(uint160(ownerWallet)).send(0.025 ether * (2-temp_i)); 
        if(s){}
        }
        emit regPackEntry(msg.sender, 3, now,pack3currUserID);
        counter=0;
        if(((pack3currUserID-1)%10)==0 && pack3currUserID>=7){
        firstSBIrafflePack3();
        }
      
     }
   


/*
→ → →  Article 5  – FIRST SBI RAFFLE

The generation of immediate wealth, which is 200% of the investment, starts automatically for the investor, this consists of a raffle that is executed under the following conditions:
4.1 This raffle is raffled every time the system identifies 10 new purchases of the same package. 
4.2 The winner of the raffle is chosen randomly only from these 10 new purchases.
4.3 The winner of the pack1 raffle receives 0.4 ETH, from pack2 1ETH and from pack3 2ETH, which are credited immediately and directly to the Wallet that bought the package.
4.4 All raffle winners receive extra tokens as an additional prize.

TRANSLATION TO SPANISH
La generación de riqueza inmediata, que es del 200% de la inversión, inicia de forma automática para el inversionista, esta consiste en una rifa que se ejecuta bajo las siguientes condiciones:
4.1 Esta rifa se sortea cada vez que el sistema identifica 10 nuevas compras de un mismo paquete. 4.2 El ganador de la rifa se escoge al azar solo entre estas 10 nuevas compras.
4.3 El ganador de la rifa del pack1 recibe 0.4 ETH, del pack2 1ETH y del pack3  2ETH, que se acreditan de forma inmediata y directamente a la Wallet que compro el paquete.
4.4 Todos los ganadores de las rifas reciben tokens extras como premio adicional.
*/
 
 
   
     function firstSBIrafflePack1() private
     {
        uint lower=pack1activeUserID+6;
        if(pack1currUserID >= 110)
        {
            lower=pack1currUserID-100;
        }
        uint num = (block.timestamp % ((pack1currUserID) - lower + 1)) + lower;
        uint pack1Currentuser=pack1users[num].id;  
        if(pack1users[pack1Currentuser].payment_received==0 && pack1users[pack1Currentuser].firstSBI_raffle==false){
            bool sent = false;
            sent = address(uint160(pack1users[pack1Currentuser].user)).send(0.40 ether);

            if (sent) {
                pack1users[pack1Currentuser].firstSBI_raffle=true;
               emit firstSBIraffle(num,pack1users[pack1Currentuser].user,1,now);
               transferFromOwner(pack1users[pack1Currentuser].user,20,12);
            }
         }
         else
         {
             counter++;
             if(counter<=(pack1currUserID- lower)){
             firstSBIrafflePack1();   
             }
            
         }
    }
   

     function firstSBIrafflePack2() private
     {
        uint lower=pack2activeUserID+6;
        if(pack2currUserID >= 110)
        {
            lower=pack2currUserID-100;
        }
        uint num = (block.timestamp % ((pack2currUserID) - lower + 1)) + lower;
         uint pack2Currentuser=pack2users[num].id; 
        if(pack2users[pack2Currentuser].payment_received==0 && pack2users[pack2Currentuser].firstSBI_raffle==false){
            bool sent = false;
            sent = address(uint160(pack2users[pack2Currentuser].user)).send(1 ether);

            if (sent) {
                pack2users[pack2Currentuser].firstSBI_raffle=true;
               emit firstSBIraffle(num,pack2users[pack2Currentuser].user,2,now);
               transferFromOwner(pack2users[pack2Currentuser].user,50,12);
            }
         }
         else
         {
             counter++;
             if(counter<=(pack2currUserID- lower)){
             firstSBIrafflePack2();   
             }
            
         }
    }
   

     function firstSBIrafflePack3() private
     {
        uint lower=pack3activeUserID+6;
        if(pack3currUserID >= 110)
        {
            lower=pack3currUserID-100;
        }
        uint num = (block.timestamp % ((pack3currUserID) - lower + 1)) + lower;
        uint pack3Currentuser=pack3users[num].id;  
        if(pack3users[pack3Currentuser].payment_received==0 && pack3users[pack3Currentuser].firstSBI_raffle==false){
            bool sent = false;
            sent = address(uint160(pack3users[pack3Currentuser].user)).send(2 ether);

            if (sent) {
                pack3users[pack3Currentuser].firstSBI_raffle=true;
               emit firstSBIraffle(num,pack3users[pack3Currentuser].user,3,now);
               transferFromOwner(pack3users[pack3Currentuser].user,100,12);
            }
         }
         else
         {
             counter++;
             if(counter<=(pack3currUserID- lower)){
             firstSBIrafflePack3();   
             }
         }
     }
   
/*   
→ → →   Article 5  – BEORUS CORPORATION

The company Beorus Corporation through the following functions guarantees the proper functioning of the contract in the following points:
5.1 Control and support of the finance platform.
5.2 Sending the funds for the award ceremony of the SBI RAFFLES contracts
5.3 Administrative payments of finance platform.
TRANSLATION TO SPANISH
La empresa Beorus Corporation por medio de las siguientes funciones garantiza el funcionamiento adecuado del contrato en los siguientes puntos:
5.1 El control y soporte de la plataforma de finanzas.
5.2 El envío de los fondos destinados a la entrega de premios de los contratos SBI RAFFLES 
5.3 Pagos administrativos de plataforma de finanzas.
*/

     function getEthBalance() public view returns(uint) {
        return address(this).balance;
        }
   
     function viewUserReferral(address _user) public view returns(address) {
        return userList[users[_user].referrerID];
        }
   
     function checkUserExist(address _user) public view returns(bool) {
        return users[_user].isExist;
        }
   
     function checkUserPack1Exist(address _user) public view returns(bool) {
        return pack1userList[_user].isExist;
        }
   
     function checkUserPack2Exist(address _user) public view returns(bool) {
        return pack2userList[_user].isExist;
        }
     function checkUserPack3Exist(address _user) public view returns(bool) {
        return pack2userList[_user].isExist;
        }
   
     
     function sendBalance() private
        {
        if(getEthBalance()>0){
          if (!address(uint160(ownerWallet)).send(getEthBalance()))
            {
             }
           }
        }

   
     function depositeFund() public payable
        {
        emit Deposite(msg.value,now);
        }
   
  
     function sendPendingBalance(uint amount) public
        {
         require(msg.sender==ownerWallet, "Beorus Corporation Admin"); 
        if(msg.sender==ownerWallet){
        if(amount>0 && amount<=getEthBalance()){
         if (!address(uint160(ownerWallet)).send(amount))
         {
            
         }
        }
        }
        }
}

/*
FINAL MESSAGE
SocialBI thanks you for the trust placed in our Decentralized Finance (DeFi) platform, as we know this contract cannot be modified and will always respond in the same way, guaranteeing all investors and entrepreneurs solidity and trust that are the best guarantees of working in the Ethereum Blockchain and Beorus Corporation.

TRANSLATION TO SPANISH

SocialBI le agradece la confianza depositada en nuestra plataforma de Finanzas Descentralizada (DeFi), como sabemos este contrato no puede ser modificado y siempre responderá de la misma manera, garantizando a todos los inversionistas y emprendedores solidez y confianza que son las mejores garantías de trabajar en la Blockchain de Ethereum y con Beorus Corporation. 




Social BI©
Website: https://www.socialbi.io/

https://www.facebook.com/socialbiio
https://twitter.com/socialbiio
https://www.instagram.com/socialbiio/

email: info@socialbi.io





██████╗░███████╗░█████╗░██████╗░██╗░░░██╗░██████╗
██╔══██╗██╔════╝██╔══██╗██╔══██╗██║░░░██║██╔════╝
██████╦╝█████╗░░██║░░██║██████╔╝██║░░░██║╚█████╗░
██╔══██╗██╔══╝░░██║░░██║██╔══██╗██║░░░██║░╚═══██╗
██████╦╝███████╗╚█████╔╝██║░░██║╚██████╔╝██████╔╝
╚═════╝░╚══════╝░╚════╝░╚═╝░░╚═╝░╚═════╝░╚═════╝░

░█▀▀█ ░█▀▀▀█ ░█▀▀█ ░█▀▀█ ░█▀▀▀█ ░█▀▀█ ─█▀▀█ ▀▀█▀▀ ▀█▀ ░█▀▀▀█ ░█▄─░█ 
░█─── ░█──░█ ░█▄▄▀ ░█▄▄█ ░█──░█ ░█▄▄▀ ░█▄▄█ ─░█── ░█─ ░█──░█ ░█░█░█ 
░█▄▄█ ░█▄▄▄█ ░█─░█ ░█─── ░█▄▄▄█ ░█─░█ ░█─░█ ─░█── ▄█▄ ░█▄▄▄█ ░█──▀█
Learn more about Beorus Corporation 

Beorus Corporation©
Website: https://beorus.com/
https://www.facebook.com/beoruscorp/
https://twitter.com/beoruscorp
https://www.instagram.com/beoruscorp/



𝔹𝕖𝕠𝕣𝕦𝕤 ℂ𝕠𝕣𝕡𝕠𝕣𝕒𝕥𝕚𝕠𝕟

United States of America
𝙵𝚕𝚘𝚛𝚒𝚍𝚊 𝚁𝚎𝚐𝚒𝚜𝚝𝚛𝚊𝚝𝚒𝚘𝚗 𝚠𝚠𝚠.𝚍𝚘𝚜.𝚜𝚝𝚊𝚝𝚎.𝚏𝚕.𝚞𝚜 𝚁𝚎𝚐𝚒𝚜𝚝𝚛𝚊𝚝𝚒𝚘𝚗 𝙿𝟸𝟶𝟶𝟶𝟶𝟶𝟻𝟺𝟸𝟾𝟿 | 𝙵𝚎𝚍𝚎𝚛𝚊𝚕 𝚃𝚊𝚡 𝙸𝚍𝚎𝚗𝚝𝚒𝚏𝚒𝚌𝚊𝚝𝚒𝚘𝚗 𝙽𝚞𝚖𝚋𝚎𝚛 (𝙴𝙸𝙽) 𝟹𝟸-𝟶𝟼𝟹𝟺𝟷𝟷𝟽
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------
-----------------------------------------------
---------------------------------
----------------------

𝙰𝚕𝚕 𝚁𝚒𝚐𝚑𝚝𝚜 𝚁𝚎𝚜𝚎𝚛𝚟𝚎𝚍.

*/
