{"status":"1","message":"OK","result":[{"SourceCode":"{\"BClaimActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma abicoder v2;\\npragma solidity ^0.7.6;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\ninterface ERC20 {\\n    function approve(address spender, uint amount) external returns (bool);\\n    function transfer(address dst, uint amt) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n    function balanceOf(address whom) external view returns (uint);\\n    function allowance(address, address) external view returns (uint);\\n}\\n\\ninterface AbstractPool is ERC20 {\\n    function setSwapFee(uint swapFee) external virtual;\\n    function setPublicSwap(bool public_) external virtual;\\n    \\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external virtual;\\n    function joinswapExternAmountIn(\\n        address tokenIn, uint tokenAmountIn, uint minPoolAmountOut\\n    ) external returns (uint poolAmountOut);\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint minAmountOut,\\n        uint maxPrice\\n    )\\n        external\\n        virtual returns (uint tokenAmountOut, uint spotPriceAfter);\\n\\n    function swapExactAmountOut(address tokenIn, uint maxAmountIn, address tokenOut, uint tokenAmountOut, uint maxPrice )\\n        external virtual\\n        returns (uint tokenAmountIn, uint spotPriceAfter);\\n}\\n\\ninterface IBPool is AbstractPool {\\n    function finalize() external virtual;\\n    function bind(address token, uint balance, uint denorm) external virtual;\\n    function rebind(address token, uint balance, uint denorm) external virtual;\\n    function unbind(address token) external virtual;\\n    function isBound(address t) external view returns (bool);\\n    function getCurrentTokens() external view returns (address[] memory);\\n    function getFinalTokens() external view returns(address[] memory);\\n    function getBalance(address token) external view returns (uint);\\n    \\n}\\n\\ninterface MerkleRedeem {\\n    function claimWeek(address _liquidityProvider, uint _week, uint _claimedBalance, bytes32[] memory _merkleProof) external virtual;\\n}\\n\\ninterface WETH {\\n    function deposit() external payable;\\n    function withdraw(uint wad) external;\\n}\\n\\n/**\\n * @dev Claim from MerkleRedeem.sol and pool into BPool.sol for multiple users in single transaction.\\n * \\n * WARNING: This contract is meant to be called using DSProxy only. Calling this contract directly\\n *          might result in loss of funds.\\n * \\n */\\ncontract BClaimActions {\\n\\n    using SafeMath for uint256;\\n    /***\\n        Approximate costs per call per user: Used to reimburse the caller with ETH.\\n     */\\n    uint constant base_gas_cost = 205000;\\n    uint constant cost_per_user = 102000;\\n\\n    constructor() public { }\\n\\n    function multiUserPoolJoin (\\n        ERC20 _token,\\n        WETH _weth,\\n        AbstractPool pool,\\n        address[] memory _users,\\n        uint _max_price\\n    ) public {\\n        uint pooledTokenAmnt = 0;\\n        uint[] memory userAmounts = new uint[](_users.length);\\n        for (uint i = 0; i \\u003c _users.length; i++) {\\n            address user = _users[i];\\n            uint user_bal_balance = _token.balanceOf(user);\\n            if (user_bal_balance \\u003e 0) {\\n                require(_token.transferFrom(user, address(this), user_bal_balance));//, \\\"t-f\\\");\\n                pooledTokenAmnt = pooledTokenAmnt.add(user_bal_balance);\\n            }\\n            userAmounts[i] = user_bal_balance;\\n        }\\n        require(pooledTokenAmnt \\u003e 0);//, \\\"p-a\\\");\\n\\n        _token.approve(address(pool), pooledTokenAmnt);\\n\\n        uint token_payed = 0;\\n        uint gasEth =  (base_gas_cost + (cost_per_user.mul(_users.length))).mul(tx.gasprice);\\n\\n        require (gasEth \\u003e 0);//, \\\"n-g\\\");\\n\\n        // Slippage is checked here by using maxPrice\\n        (token_payed, ) = pool.swapExactAmountOut(address(_token), pooledTokenAmnt, address(_weth), gasEth, _max_price);\\n        _weth.withdraw(gasEth);\\n\\n        uint poolAmountOut = pool.joinswapExternAmountIn(address(_token), pooledTokenAmnt.sub(token_payed), 0);\\n        uint poolAmountOutLeft = poolAmountOut;\\n        \\n        for (uint i = 0; i \\u003c _users.length; i++) {\\n            uint userPoolAmount;\\n            if (i == _users.length - 1) {\\n                userPoolAmount = poolAmountOutLeft;\\n            } else {\\n                userPoolAmount = userAmounts[i].mul(poolAmountOut).div(pooledTokenAmnt);\\n            }\\n            require(pool.transfer(_users[i], userPoolAmount));//, \\\"t-t\\\");\\n            poolAmountOutLeft =  poolAmountOutLeft.sub(userPoolAmount);\\n        }\\n        msg.sender.transfer(gasEth);\\n    }\\n\\n    function multiUserClaimPoolJoin(\\n        MerkleRedeem distribute_contract,\\n        ERC20 _token,\\n        WETH _weth,\\n        AbstractPool pool,\\n        address[] calldata _users,\\n        uint _week,\\n        uint[] calldata _balances,\\n        bytes32[][] calldata _merkleProofs,\\n        uint _max_price\\n    ) external {\\n        // first claim for each user\\n        require(_users.length == _balances.length);//, \\\"a-b\\\");\\n        require(_merkleProofs.length == _users.length);//, \\\"a-m\\\");        \\n        for (uint i = 0; i \\u003c _users.length; i++) {\\n            if (_merkleProofs[i].length \\u003e 0)\\n                distribute_contract.claimWeek(_users[i], _week, _balances[i], _merkleProofs[i]);\\n        }\\n        // then multi pool\\n        multiUserPoolJoin(_token, _weth, pool, _users, _max_price);\\n    }\\n\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract MerkleRedeem\",\"name\":\"distribute_contract\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract WETH\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"contract AbstractPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_week\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_balances\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_merkleProofs\",\"type\":\"bytes32[][]\"},{\"internalType\":\"uint256\",\"name\":\"_max_price\",\"type\":\"uint256\"}],\"name\":\"multiUserClaimPoolJoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract WETH\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"contract AbstractPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_max_price\",\"type\":\"uint256\"}],\"name\":\"multiUserPoolJoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BClaimActions","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a1e31fb6739fa45ea193af0408fbd096444694a9a4e15fef158586ecd1eafee5"}]}