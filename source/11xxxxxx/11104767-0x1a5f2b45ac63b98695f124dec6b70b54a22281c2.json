{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\r\n\r\n   \r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue) public\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) public\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\ninterface tokenRecipient { \r\n    function receiveTokens(address _from, uint256 _value, bytes calldata _extraData) external;\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is StandardToken {\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function _burn(address burner, uint256 _value) internal {\r\n        require(_value > 0);\r\n        require(_value <= balances[burner]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        emit Transfer(burner, address(0), _value);\r\n        emit Burn(burner, _value);\r\n    }\r\n    \r\n    function burn(uint _value) public {\r\n        _burn(msg.sender, _value);\r\n    }\r\n}\r\n\r\ncontract IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function migrator() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setMigrator(address) external;\r\n}\r\n\r\ncontract IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ncontract IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\n\r\ncontract Protocore is BurnableToken, Ownable {\r\n    \r\n    event LiquidityAddition(address indexed dst, uint value);\r\n    event LPTokenClaimed(address dst, uint value);\r\n    \r\n    uint256 public contractStartTimestamp;\r\n    \r\n    address public feeDistributorAddress;\r\n    address public reserveAddress;\r\n    address public devAddress;\r\n    \r\n    uint public reserveFeePercentX100 = 20;\r\n    uint public devFeePercentX100 = 10;\r\n    uint public disburseFeePercentX100 = 100;\r\n    \r\n    uint public liquidityGenerationDuration = 3 days;\r\n    uint public adminCanDrainContractAfter = 4 days;\r\n    \r\n    IUniswapV2Router02 public uniswapRouterV2;\r\n    IUniswapV2Factory public uniswapFactory;\r\n    uint256 public lastTotalSupplyOfLPTokens;\r\n\r\n    address public tokenUniswapPair;\r\n    \r\n    mapping (address => bool) public voidFeeList;\r\n    mapping (address => bool) public voidFeeRecipientList;\r\n    \r\n    uint256 public totalLPTokensMinted;\r\n    uint256 public totalETHContributed;\r\n    uint256 public LPperETHUnit;\r\n\r\n    string public constant name = \"Protocore\";\r\n    string public constant symbol = \"pCORE\";\r\n    uint public constant decimals = 18;\r\n    // there is no problem in using * here instead of .mul()\r\n    uint256 public constant initialSupply = 10000 * (10 ** uint256(decimals));\r\n    \r\n    uint public limitBuyAmount = 50e18;\r\n    bool public isLimitBuyOn = true;\r\n    \r\n    function setLimitBuyAmount(uint _limitBuyAmount) public onlyOwner {\r\n        limitBuyAmount = _limitBuyAmount;\r\n    }\r\n    \r\n    function turnLimitBuyOff() public onlyOwner {\r\n        isLimitBuyOn = false;\r\n    }\r\n    function turnLimitBuyOn() public onlyOwner {\r\n        isLimitBuyOn = true;\r\n    }\r\n    \r\n    function canTransfer(address sender, address recipient, uint amount) public view returns(bool) {\r\n        // if pair is sending (buys are happening)\r\n        if ((isLimitBuyOn) && (sender == tokenUniswapPair) && (amount > limitBuyAmount)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function setFeeDistributor(address _feeDistributorAddress) public onlyOwner {\r\n        feeDistributorAddress = _feeDistributorAddress;\r\n    }\r\n    function setReserveAddress(address _reserveAddress) public onlyOwner {\r\n        reserveAddress = _reserveAddress;\r\n    }\r\n    function setDevAddress(address _devAddress) public onlyOwner {\r\n        devAddress = _devAddress;\r\n    }\r\n    \r\n    function setDisburseFeePercentX100(uint _disburseFeePercentX100) public onlyOwner {\r\n        disburseFeePercentX100 = _disburseFeePercentX100;\r\n    }\r\n    function setReserveFeePercentX100(uint _reserveFeePercentX100) public onlyOwner {\r\n        reserveFeePercentX100 = _reserveFeePercentX100;\r\n    }\r\n    function setDevFeePercentX100(uint _devFeePercentX100) public onlyOwner {\r\n        devFeePercentX100 = _devFeePercentX100;\r\n    }\r\n    \r\n    function editVoidFeeList(address _address, bool _noFee) public onlyOwner {\r\n        voidFeeList[_address] = _noFee;\r\n    }\r\n    function editVoidFeeRecipientList(address _address, bool _noFee) public onlyOwner {\r\n        voidFeeRecipientList[_address] = _noFee;\r\n    }\r\n    \r\n    // -------------- fee approver functions ---------------\r\n    \r\n    function sync() public {\r\n        uint256 _LPSupplyOfPairTotal = ERC20(tokenUniswapPair).totalSupply();\r\n        lastTotalSupplyOfLPTokens = _LPSupplyOfPairTotal;\r\n    }\r\n    \r\n    function calculateAmountsAfterFee(        \r\n        address sender, // unusused maby used future\r\n        address recipient, // unusued maybe use din future\r\n        uint256 amount\r\n        ) private returns (uint256 _amountToReserve, uint256 _amountToDisburse, uint256 _amountToDev) \r\n        {\r\n\r\n            uint256 _LPSupplyOfPairTotal = ERC20(tokenUniswapPair).totalSupply();\r\n\r\n            if(sender == tokenUniswapPair) \r\n                require(lastTotalSupplyOfLPTokens <= _LPSupplyOfPairTotal, \"Liquidity withdrawals forbidden\");\r\n\r\n\r\n            if(sender == feeDistributorAddress  \r\n                || sender == tokenUniswapPair \r\n                || voidFeeList[sender]\r\n                || voidFeeRecipientList[recipient]\r\n                || sender == address(this)\r\n                ) { // Dont have a fee when corevault is sending, or infinite loop\r\n                                     // And when pair is sending ( buys are happening, no tax on it)\r\n                _amountToReserve = 0;\r\n                _amountToDisburse = 0;\r\n                _amountToDev = 0;\r\n            } \r\n            else {\r\n                \r\n                _amountToReserve = amount.mul(reserveFeePercentX100).div(10000);\r\n                _amountToDisburse = amount.mul(disburseFeePercentX100).div(10000);\r\n                _amountToDev = amount.mul(devFeePercentX100).div(10000);\r\n                \r\n            }\r\n\r\n\r\n           lastTotalSupplyOfLPTokens = _LPSupplyOfPairTotal;\r\n        }\r\n    \r\n    // --------------- end fee approver functions ---------------\r\n    \r\n\r\n    function createUniswapPairMainnet() public returns (address) {\r\n        require(tokenUniswapPair == address(0), \"Token: pool already created\");\r\n        tokenUniswapPair = uniswapFactory.createPair(\r\n            address(uniswapRouterV2.WETH()),\r\n            address(this)\r\n        );\r\n        return tokenUniswapPair;\r\n    }\r\n    \r\n    \r\n    \r\n    // Constructors\r\n    constructor (address router, address factory) public {\r\n        totalSupply = initialSupply;\r\n        balances[address(this)] = initialSupply; // Send all tokens to owner\r\n        emit Transfer(address(0), address(this), initialSupply);\r\n        \r\n        contractStartTimestamp = now;\r\n        \r\n        uniswapRouterV2 = IUniswapV2Router02(router != address(0) ? router : 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // For testing\r\n        uniswapFactory = IUniswapV2Factory(factory != address(0) ? factory : 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f); // For testing\r\n        createUniswapPairMainnet();\r\n    }\r\n    \r\n    function transfer(address to, uint amount) public returns (bool) {\r\n        // uint _amountToReserve = amount.mul(reserveFeePercentX100).div(10000);\r\n        // uint _amountToDisburse = amount.mul(disburseFeePercentX100).div(10000);\r\n        // uint _amountToDev = amount.mul(devFeePercentX100).div(10000);\r\n        \r\n        require(canTransfer(msg.sender, to, amount), \"Limit buys are on!\");\r\n        \r\n        (uint _amountToReserve, uint _amountToDisburse, uint _amountToDev) = calculateAmountsAfterFee(msg.sender, to, amount);\r\n        \r\n        \r\n        uint _amountAfterFee = amount.sub(_amountToReserve).sub(_amountToDisburse).sub(_amountToDev);\r\n\r\n        require(super.transfer(feeDistributorAddress, _amountToDisburse), \"Cannot disburse rewards.\");        \r\n        require(super.transfer(reserveAddress, _amountToReserve), \"Cannot send tokens to reserve!\");\r\n        require(super.transfer(devAddress, _amountToDev), \"Cannot transfer dev fee!\");\r\n\r\n        if (feeDistributorAddress != address(0) && _amountToDisburse > 0) {\r\n            tokenRecipient(feeDistributorAddress).receiveTokens(msg.sender, _amountToDisburse, \"\");\r\n        }\r\n        require(super.transfer(to, _amountAfterFee), \"Cannot transfer tokens.\");\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint amount) public returns (bool) {\r\n        \r\n        require(canTransfer(from, to, amount), \"Limit buys are on!\");\r\n        \r\n        require(to != address(0));\r\n        // uint _amountToReserve = amount.mul(reserveFeePercentX100).div(10000);\r\n        // uint _amountToDev = amount.mul(devFeePercentX100).div(10000);\r\n        // uint _amountToDisburse = amount.mul(disburseFeePercentX100).div(10000);\r\n        \r\n        (uint _amountToReserve, uint _amountToDisburse, uint _amountToDev) = calculateAmountsAfterFee(from, to, amount);\r\n        \r\n        \r\n        uint _amountAfterFee = amount.sub(_amountToReserve).sub(_amountToDisburse).sub(_amountToDev);\r\n        \r\n        uint256 _allowance = allowed[from][msg.sender];\r\n    \r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[from] = balances[from].sub(_amountAfterFee);\r\n        balances[to] = balances[to].add(_amountAfterFee);\r\n        \r\n        balances[from] = balances[from].sub(_amountToDisburse);\r\n        balances[feeDistributorAddress] = balances[feeDistributorAddress].add(_amountToDisburse);\r\n        \r\n        balances[from] = balances[from].sub(_amountToDev);\r\n        balances[devAddress] = balances[devAddress].add(_amountToDev);\r\n        \r\n        balances[from] = balances[from].sub(_amountToReserve);\r\n        balances[reserveAddress] = balances[reserveAddress].add(_amountToReserve);\r\n        \r\n        \r\n        allowed[from][msg.sender] = _allowance.sub(amount);\r\n        \r\n\r\n        emit Transfer(from, feeDistributorAddress, _amountToDisburse);\r\n        emit Transfer(from, reserveAddress, _amountToReserve);\r\n        emit Transfer(from, devAddress, _amountToDev);\r\n        emit Transfer(from, to, _amountAfterFee);\r\n        \r\n        if (feeDistributorAddress != address(0) && _amountToDisburse > 0) {\r\n            tokenRecipient(feeDistributorAddress).receiveTokens(msg.sender, _amountToDisburse, \"\");\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    // --------------- Liquidity Generation Event Scripts ---------------\r\n    \r\n    //// Liquidity generation logic\r\n    /// Steps - All tokens tat will ever exist go to this contract\r\n    /// This contract accepts ETH as payable\r\n    /// ETH is mapped to people\r\n    /// When liquidity generationevent is over veryone can call\r\n    /// the mint LP function\r\n    // which will put all the ETH and tokens inside the uniswap contract\r\n    /// without any involvement\r\n    /// This LP will go into this contract\r\n    /// And will be able to proportionally be withdrawn baed on ETH put in\r\n    /// A emergency drain function allows the contract owner to drain all ETH and tokens from this contract\r\n    /// After the liquidity generation event happened. In case something goes wrong, to send ETH back\r\n\r\n\r\n    string public liquidityGenerationParticipationAgreement = \"I agree that the developers and affiliated parties of the Protocore team are not responsible for my funds\";\r\n\r\n    function liquidityGenerationOngoing() public view returns (bool) {\r\n        return contractStartTimestamp.add(liquidityGenerationDuration) > block.timestamp;\r\n    }\r\n    function canAdminDrainContract() public view returns (bool) {\r\n        return contractStartTimestamp.add(adminCanDrainContractAfter) < block.timestamp;\r\n    }\r\n    \r\n    // Emergency drain in case of a bug\r\n    // Adds all funds to owner to refund people\r\n    // Designed to be as simple as possible\r\n    function emergencyDrain24hAfterLiquidityGenerationEventIsDone() public onlyOwner {\r\n        require(canAdminDrainContract(), \"Liquidity generation grace period still ongoing\"); // About 24h after liquidity generation happens\r\n        (bool success, ) = msg.sender.call.value(address(this).balance)(\"\");\r\n        require(success, \"Transfer failed.\");\r\n        emit Transfer(address(this), msg.sender, balances[address(this)]);\r\n        balances[msg.sender] = balances[address(this)];\r\n        balances[address(this)] = 0;\r\n    }\r\n    \r\n    bool public LPGenerationCompleted;\r\n    // Sends all avaibile balances and mints LP tokens\r\n    // Possible ways this could break addressed\r\n    // 1) Multiple calls and resetting amounts - addressed with boolean\r\n    // 2) Failed WETH wrapping/unwrapping addressed with checks\r\n    // 3) Failure to create LP tokens, addressed with checks\r\n    // 4) Unacceptable division errors . Addressed with multiplications by 1e18\r\n    // 5) Pair not set - impossible since its set in constructor\r\n    function addLiquidityToUniswapPROTOCORExWETHPair() public onlyOwner {\r\n        require(liquidityGenerationOngoing() == false, \"Liquidity generation onging\");\r\n        require(LPGenerationCompleted == false, \"Liquidity generation already finished\");\r\n        totalETHContributed = address(this).balance;\r\n        IUniswapV2Pair pair = IUniswapV2Pair(tokenUniswapPair);\r\n        \r\n        //Wrap eth\r\n        address WETH = uniswapRouterV2.WETH();\r\n        IWETH(WETH).deposit.value(totalETHContributed)();\r\n        require(address(this).balance == 0 , \"Transfer Failed\");\r\n        IWETH(WETH).transfer(address(pair),totalETHContributed);\r\n        emit Transfer(address(this), address(pair), balances[address(this)]);\r\n        balances[address(pair)] = balances[address(this)];\r\n        balances[address(this)] = 0;\r\n        pair.mint(address(this));\r\n        totalLPTokensMinted = pair.balanceOf(address(this));\r\n        \r\n        require(totalLPTokensMinted != 0 , \"LP creation failed\");\r\n        LPperETHUnit = totalLPTokensMinted.mul(1e18).div(totalETHContributed); // 1e18x for  change\r\n        \r\n        require(LPperETHUnit != 0 , \"LP creation failed\");\r\n        LPGenerationCompleted = true;\r\n        sync();\r\n    }\r\n    \r\n    mapping (address => uint)  public ethContributed;\r\n    // Possible ways this could break addressed\r\n    // 1) No ageement to terms - added require\r\n    // 2) Adding liquidity after generaion is over - added require\r\n    // 3) Overflow from uint - impossible there isnt that much ETH aviable\r\n    // 4) Depositing 0 - not an issue it will just add 0 to tally\r\n    function addLiquidity(bool agreesToTermsOutlinedInLiquidityGenerationParticipationAgreement) public payable {\r\n        require(liquidityGenerationOngoing(), \"Liquidity Generation Event over\");\r\n        require(agreesToTermsOutlinedInLiquidityGenerationParticipationAgreement, \"No agreement provided\");\r\n        ethContributed[msg.sender] += msg.value; // Overflow protection from safemath is not neded here\r\n        totalETHContributed = totalETHContributed.add(msg.value); // for front end display during LGE. This resets with definietly correct balance while calling pair.\r\n        emit LiquidityAddition(msg.sender, msg.value);\r\n    }\r\n\r\n    // Possible ways this could break addressed\r\n    // 1) Accessing before event is over and resetting eth contributed -- added require\r\n    // 2) No uniswap pair - impossible at this moment because of the LPGenerationCompleted bool\r\n    // 3) LP per unit is 0 - impossible checked at generation function\r\n    function claimLPTokens() public {\r\n        require(LPGenerationCompleted, \"Event not over yet\");\r\n        require(ethContributed[msg.sender] > 0 , \"Nothing to claim, move along\");\r\n        IUniswapV2Pair pair = IUniswapV2Pair(tokenUniswapPair);\r\n        uint256 amountLPToTransfer = ethContributed[msg.sender].mul(LPperETHUnit).div(1e18);\r\n        pair.transfer(msg.sender, amountLPToTransfer); // stored as 1e18x value for change\r\n        ethContributed[msg.sender] = 0;\r\n        emit LPTokenClaimed(msg.sender, amountLPToTransfer);\r\n    }\r\n    \r\n    // --------------- End Liquidity Generation Event Scripts ---------------\r\n    \r\n    // token recovery function\r\n    function transferAnyERC20Token(address _tokenAddress, address _to, uint _amount) public onlyOwner {\r\n        require(_tokenAddress != tokenUniswapPair, \"Admin Cannot transfer out pCORE/WETH LP Tokens from this contract!\");\r\n        require(canAdminDrainContract(), \"Liquidity generation grace period still ongoing\");\r\n        ERC20(_tokenAddress).transfer(_to, _amount);\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LPTokenClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LiquidityAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"LPGenerationCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LPperETHUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"agreesToTermsOutlinedInLiquidityGenerationParticipationAgreement\",\"type\":\"bool\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addLiquidityToUniswapPROTOCORExWETHPair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminCanDrainContractAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canAdminDrainContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"canTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimLPTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createUniswapPairMainnet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFeePercentX100\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disburseFeePercentX100\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_noFee\",\"type\":\"bool\"}],\"name\":\"editVoidFeeList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_noFee\",\"type\":\"bool\"}],\"name\":\"editVoidFeeRecipientList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyDrain24hAfterLiquidityGenerationEventIsDone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethContributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeDistributorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLimitBuyOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTotalSupplyOfLPTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidityGenerationDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidityGenerationOngoing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidityGenerationParticipationAgreement\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveFeePercentX100\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devAddress\",\"type\":\"address\"}],\"name\":\"setDevAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_devFeePercentX100\",\"type\":\"uint256\"}],\"name\":\"setDevFeePercentX100\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disburseFeePercentX100\",\"type\":\"uint256\"}],\"name\":\"setDisburseFeePercentX100\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDistributorAddress\",\"type\":\"address\"}],\"name\":\"setFeeDistributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limitBuyAmount\",\"type\":\"uint256\"}],\"name\":\"setLimitBuyAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserveAddress\",\"type\":\"address\"}],\"name\":\"setReserveAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserveFeePercentX100\",\"type\":\"uint256\"}],\"name\":\"setReserveFeePercentX100\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenUniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalETHContributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLPTokensMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"turnLimitBuyOff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"turnLimitBuyOn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapRouterV2\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voidFeeList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voidFeeRecipientList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Protocore","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f","EVMVersion":"Default","Library":"","LicenseType":"BSD-3-Clause","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7fa63cd0b2b4b99f6c8f9343eda15f2d9047ccae57aa1ea60066af80ed41ac12"}]}