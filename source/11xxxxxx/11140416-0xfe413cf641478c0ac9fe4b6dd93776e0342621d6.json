{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        require(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        require(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        require(token.approve(spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/interface/ISGN.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title SGN interface\r\n */\r\ninterface ISGN {\r\n    // functions\r\n    function updateSidechainAddr(bytes calldata _sidechainAddr) external;\r\n\r\n    function subscribe(uint _amount) external;\r\n\r\n    function redeemReward(bytes calldata _rewardRequest) external;\r\n\r\n    // events\r\n    event UpdateSidechainAddr(address indexed candidate, bytes indexed oldSidechainAddr, bytes indexed newSidechainAddr);\r\n\r\n    event AddSubscriptionBalance(address indexed consumer, uint amount);\r\n\r\n    event RedeemReward(address indexed receiver, uint cumulativeMiningReward, uint serviceReward, uint servicePool);\r\n}\r\n\r\n// File: contracts/lib/interface/IDPoS.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title DPoS interface\r\n */\r\ninterface IDPoS {\r\n    enum ValidatorChangeType { Add, Removal }\r\n\r\n    // functions\r\n    function contributeToMiningPool(uint _amount) external;\r\n\r\n    function redeemMiningReward(address _receiver, uint _cumulativeReward) external;\r\n\r\n    function registerSidechain(address _addr) external;\r\n\r\n    function initializeCandidate(uint _minSelfStake, uint _commissionRate, uint _rateLockEndTime) external;\r\n\r\n    function announceIncreaseCommissionRate(uint _newRate, uint _newLockEndTime) external;\r\n\r\n    function confirmIncreaseCommissionRate() external;\r\n\r\n    function nonIncreaseCommissionRate(uint _newRate, uint _newLockEndTime) external;\r\n\r\n    function updateMinSelfStake(uint256 _minSelfStake) external;\r\n\r\n    function delegate(address _candidateAddr, uint _amount) external;\r\n\r\n    function withdrawFromUnbondedCandidate(address _candidateAddr, uint _amount) external;\r\n\r\n    function intendWithdraw(address _candidateAddr, uint _amount) external;\r\n\r\n    function confirmWithdraw(address _candidateAddr) external;\r\n\r\n    function claimValidator() external;\r\n\r\n    function confirmUnbondedCandidate(address _candidateAddr) external;\r\n\r\n    function slash(bytes calldata _penaltyRequest) external;\r\n\r\n    function validateMultiSigMessage(bytes calldata _request) external returns(bool);\r\n\r\n    function isValidDPoS() external view returns (bool);\r\n\r\n    function isValidator(address _addr) external view returns (bool);\r\n\r\n    function getValidatorNum() external view returns (uint);\r\n\r\n    function getMinStakingPool() external view returns (uint);\r\n\r\n    function getCandidateInfo(address _candidateAddr) external view returns (bool, uint, uint, uint, uint, uint, uint);\r\n\r\n    function getDelegatorInfo(address _candidateAddr, address _delegatorAddr) external view returns (uint, uint, uint[] memory, uint[] memory);\r\n\r\n    function getMinQuorumStakingPool() external view returns(uint);\r\n\r\n    function getTotalValidatorStakingPool() external view returns(uint);\r\n\r\n    // TODO: interface can't be inherited, so VoteType is not declared here\r\n    // function voteParam(uint _proposalId, VoteType _vote) external;\r\n\r\n    // function confirmParamProposal(uint _proposalId) external;\r\n\r\n    // function voteSidechain(uint _proposalId, VoteType _vote) external;\r\n\r\n    // function confirmSidechainProposal(uint _proposalId) external;\r\n\r\n    // events\r\n    event InitializeCandidate(address indexed candidate, uint minSelfStake, uint commissionRate, uint rateLockEndTime);\r\n\r\n    event CommissionRateAnnouncement(address indexed candidate, uint announcedRate, uint announcedLockEndTime);\r\n\r\n    event UpdateCommissionRate(address indexed candidate, uint newRate, uint newLockEndTime);\r\n\r\n    event UpdateMinSelfStake(address indexed candidate, uint minSelfStake);\r\n\r\n    event Delegate(address indexed delegator, address indexed candidate, uint newStake, uint stakingPool);\r\n\r\n    event ValidatorChange(address indexed ethAddr, ValidatorChangeType indexed changeType);\r\n\r\n    event WithdrawFromUnbondedCandidate(address indexed delegator, address indexed candidate, uint amount);\r\n\r\n    event IntendWithdraw(address indexed delegator, address indexed candidate, uint withdrawAmount, uint proposedTime);\r\n\r\n    event ConfirmWithdraw(address indexed delegator, address indexed candidate, uint amount);\r\n\r\n    event Slash(address indexed validator, address indexed delegator, uint amount);\r\n\r\n    event UpdateDelegatedStake(address indexed delegator, address indexed candidate, uint delegatorStake, uint candidatePool);\r\n\r\n    event Compensate(address indexed indemnitee, uint amount);\r\n\r\n    event CandidateUnbonded(address indexed candidate);\r\n\r\n    event RedeemMiningReward(address indexed receiver, uint reward, uint miningPool);\r\n\r\n    event MiningPoolContribution(address indexed contributor, uint contribution, uint miningPoolSize);\r\n}\r\n\r\n// File: contracts/lib/data/Pb.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n// runtime proto sol library\r\nlibrary Pb {\r\n    enum WireType { Varint, Fixed64, LengthDelim, StartGroup, EndGroup, Fixed32 }\r\n\r\n    struct Buffer {\r\n        uint idx;  // the start index of next read. when idx=b.length, we're done\r\n        bytes b;   // hold serialized proto msg, readonly\r\n    }\r\n\r\n    // create a new in-memory Buffer object from raw msg bytes\r\n    function fromBytes(bytes memory raw) internal pure returns (Buffer memory buf) {\r\n        buf.b = raw;\r\n        buf.idx = 0;\r\n    }\r\n\r\n    // whether there are unread bytes\r\n    function hasMore(Buffer memory buf) internal pure returns (bool) {\r\n        return buf.idx < buf.b.length;\r\n    }\r\n\r\n    // decode current field number and wiretype\r\n    function decKey(Buffer memory buf) internal pure returns (uint tag, WireType wiretype) {\r\n        uint v = decVarint(buf);\r\n        tag = v / 8;\r\n        wiretype = WireType(v & 7);\r\n    }\r\n\r\n    // count tag occurrences, return an array due to no memory map support\r\n\t// have to create array for (maxtag+1) size. cnts[tag] = occurrences\r\n\t// should keep buf.idx unchanged because this is only a count function\r\n    function cntTags(Buffer memory buf, uint maxtag) internal pure returns (uint[] memory cnts) {\r\n        uint originalIdx = buf.idx;\r\n        cnts = new uint[](maxtag+1);  // protobuf's tags are from 1 rather than 0\r\n        uint tag;\r\n        WireType wire;\r\n        while (hasMore(buf)) {\r\n            (tag, wire) = decKey(buf);\r\n            cnts[tag] += 1;\r\n            skipValue(buf, wire);\r\n        }\r\n        buf.idx = originalIdx;\r\n    }\r\n\r\n    // read varint from current buf idx, move buf.idx to next read, return the int value\r\n    function decVarint(Buffer memory buf) internal pure returns (uint v) {\r\n        bytes10 tmp;  // proto int is at most 10 bytes (7 bits can be used per byte)\r\n        bytes memory bb = buf.b;  // get buf.b mem addr to use in assembly\r\n        v = buf.idx;  // use v to save one additional uint variable\r\n        assembly {\r\n            tmp := mload(add(add(bb, 32), v)) // load 10 bytes from buf.b[buf.idx] to tmp\r\n        }\r\n        uint b; // store current byte content\r\n        v = 0; // reset to 0 for return value\r\n        for (uint i=0; i<10; i++) {\r\n            assembly {\r\n                b := byte(i, tmp)  // don't use tmp[i] because it does bound check and costs extra\r\n            }\r\n            v |= (b & 0x7F) << (i * 7);\r\n            if (b & 0x80 == 0) {\r\n                buf.idx += i + 1;\r\n                return v;\r\n            }\r\n        }\r\n        revert(); // i=10, invalid varint stream\r\n    }\r\n\r\n    // read length delimited field and return bytes\r\n    function decBytes(Buffer memory buf) internal pure returns (bytes memory b) {\r\n        uint len = decVarint(buf);\r\n        uint end = buf.idx + len;\r\n        require(end <= buf.b.length);  // avoid overflow\r\n        b = new bytes(len);\r\n        bytes memory bufB = buf.b;  // get buf.b mem addr to use in assembly\r\n        uint bStart;\r\n        uint bufBStart = buf.idx;\r\n        assembly {\r\n            bStart := add(b, 32)\r\n            bufBStart := add(add(bufB, 32), bufBStart)\r\n        }\r\n        for (uint i=0; i<len; i+=32) {\r\n            assembly{\r\n                mstore(add(bStart, i), mload(add(bufBStart, i)))\r\n            }\r\n        }\r\n        buf.idx = end;\r\n    }\r\n\r\n    // return packed ints\r\n    function decPacked(Buffer memory buf) internal pure returns (uint[] memory t) {\r\n        uint len = decVarint(buf);\r\n        uint end = buf.idx + len;\r\n        require(end <= buf.b.length);  // avoid overflow\r\n        // array in memory must be init w/ known length\r\n        // so we have to create a tmp array w/ max possible len first\r\n        uint[] memory tmp = new uint[](len);\r\n        uint i; // count how many ints are there\r\n        while (buf.idx < end) {\r\n            tmp[i] = decVarint(buf);\r\n            i++;\r\n        }\r\n        t = new uint[](i); // init t with correct length\r\n        for (uint j=0; j<i; j++) {\r\n            t[j] = tmp[j];\r\n        }\r\n        return t;\r\n    }\r\n\r\n    // move idx pass current value field, to beginning of next tag or msg end\r\n    function skipValue(Buffer memory buf, WireType wire) internal pure {\r\n        if (wire == WireType.Varint) { decVarint(buf); }\r\n        else if (wire == WireType.LengthDelim) {\r\n            uint len = decVarint(buf);\r\n            buf.idx += len; // skip len bytes value data\r\n            require(buf.idx <= buf.b.length);  // avoid overflow\r\n        } else { revert(); }  // unsupported wiretype\r\n    }\r\n\r\n    // type conversion help utils\r\n    function _bool(uint x) internal pure returns (bool v) {\r\n        return x != 0;\r\n    }\r\n\r\n    function _uint256(bytes memory b) internal pure returns (uint256 v) {\r\n        require(b.length <= 32);  // b's length must be smaller than or equal to 32\r\n        assembly { v := mload(add(b, 32)) }  // load all 32bytes to v\r\n        v = v >> (8 * (32 - b.length));  // only first b.length is valid\r\n    }\r\n\r\n    function _address(bytes memory b) internal pure returns (address v) {\r\n        v = _addressPayable(b);\r\n    }\r\n\r\n    function _addressPayable(bytes memory b) internal pure returns (address payable v) {\r\n        require(b.length == 20);\r\n        //load 32bytes then shift right 12 bytes\r\n        assembly { v := div(mload(add(b, 32)), 0x1000000000000000000000000) }\r\n    }\r\n\r\n    function _bytes32(bytes memory b) internal pure returns (bytes32 v) {\r\n        require(b.length == 32);\r\n        assembly { v := mload(add(b, 32)) }\r\n    }\r\n\r\n    // uint[] to uint8[]\r\n    function uint8s(uint[] memory arr) internal pure returns (uint8[] memory t) {\r\n        t = new uint8[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint8(arr[i]); }\r\n    }\r\n\r\n    function uint32s(uint[] memory arr) internal pure returns (uint32[] memory t) {\r\n        t = new uint32[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint32(arr[i]); }\r\n    }\r\n\r\n    function uint64s(uint[] memory arr) internal pure returns (uint64[] memory t) {\r\n        t = new uint64[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint64(arr[i]); }\r\n    }\r\n\r\n    function bools(uint[] memory arr) internal pure returns (bool[] memory t) {\r\n        t = new bool[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = arr[i]!=0; }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/data/PbSgn.sol\r\n\r\n// Code generated by protoc-gen-sol. DO NOT EDIT.\r\n// source: sgn.proto\r\npragma solidity 0.5.17;\r\n\r\n\r\nlibrary PbSgn {\r\n    using Pb for Pb.Buffer;  // so we can call Pb funcs on Buffer obj\r\n\r\n    struct MultiSigMessage {\r\n        bytes msg;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct MultiSigMessage\r\n\r\n    function decMultiSigMessage(bytes memory raw) internal pure returns (MultiSigMessage memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.msg = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder MultiSigMessage\r\n\r\n    struct PenaltyRequest {\r\n        bytes penalty;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct PenaltyRequest\r\n\r\n    function decPenaltyRequest(bytes memory raw) internal pure returns (PenaltyRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.penalty = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder PenaltyRequest\r\n\r\n    struct RewardRequest {\r\n        bytes reward;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct RewardRequest\r\n\r\n    function decRewardRequest(bytes memory raw) internal pure returns (RewardRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.reward = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder RewardRequest\r\n\r\n    struct Penalty {\r\n        uint64 nonce;   // tag: 1\r\n        uint64 expireTime;   // tag: 2\r\n        address validatorAddress;   // tag: 3\r\n        AccountAmtPair[] penalizedDelegators;   // tag: 4\r\n        AccountAmtPair[] beneficiaries;   // tag: 5\r\n    } // end struct Penalty\r\n\r\n    function decPenalty(bytes memory raw) internal pure returns (Penalty memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(5);\r\n        m.penalizedDelegators = new AccountAmtPair[](cnts[4]);\r\n        cnts[4] = 0;  // reset counter for later use\r\n        m.beneficiaries = new AccountAmtPair[](cnts[5]);\r\n        cnts[5] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.nonce = uint64(buf.decVarint());\r\n            }\r\n            else if (tag == 2) {\r\n                m.expireTime = uint64(buf.decVarint());\r\n            }\r\n            else if (tag == 3) {\r\n                m.validatorAddress = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 4) {\r\n                m.penalizedDelegators[cnts[4]] = decAccountAmtPair(buf.decBytes());\r\n                cnts[4]++;\r\n            }\r\n            else if (tag == 5) {\r\n                m.beneficiaries[cnts[5]] = decAccountAmtPair(buf.decBytes());\r\n                cnts[5]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder Penalty\r\n\r\n    struct AccountAmtPair {\r\n        address account;   // tag: 1\r\n        uint256 amt;   // tag: 2\r\n    } // end struct AccountAmtPair\r\n\r\n    function decAccountAmtPair(bytes memory raw) internal pure returns (AccountAmtPair memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.account = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.amt = Pb._uint256(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder AccountAmtPair\r\n\r\n    struct Reward {\r\n        address receiver;   // tag: 1\r\n        uint256 cumulativeMiningReward;   // tag: 2\r\n        uint256 cumulativeServiceReward;   // tag: 3\r\n    } // end struct Reward\r\n\r\n    function decReward(bytes memory raw) internal pure returns (Reward memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.receiver = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.cumulativeMiningReward = Pb._uint256(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.cumulativeServiceReward = Pb._uint256(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder Reward\r\n\r\n}\r\n\r\n// File: contracts/lib/DPoSCommon.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title DPoS contract common Library\r\n * @notice Common items used in DPoS contract\r\n */\r\nlibrary DPoSCommon {\r\n    // Unbonded: not a validator and not responsible for previous validator behaviors if any.\r\n    //   Delegators now are free to withdraw stakes (directly).\r\n    // Bonded: active validator. Delegators have to wait for slashTimeout to withdraw stakes.\r\n    // Unbonding: transitional status from Bonded to Unbonded. Candidate has lost the right of\r\n    //   validator but is still responsible for any misbehaviour done during being validator.\r\n    //   Delegators should wait until candidate's unbondTime to freely withdraw stakes.\r\n    enum CandidateStatus { Unbonded, Bonded, Unbonding }\r\n}\r\n\r\n// File: contracts/SGN.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Sidechain contract of State Guardian Network\r\n * @notice This contract implements the mainchain logic of Celer State Guardian Network sidechain\r\n * @dev specs: https://www.celer.network/docs/celercore/sgn/sidechain.html#mainchain-contracts\r\n */\r\ncontract SGN is ISGN, Ownable, Pausable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 public celerToken;\r\n    IDPoS public dPoSContract;\r\n    mapping(address => uint256) public subscriptionDeposits;\r\n    uint256 public servicePool;\r\n    mapping(address => uint256) public redeemedServiceReward;\r\n    mapping(address => bytes) public sidechainAddrMap;\r\n\r\n    /**\r\n     * @notice Throws if SGN sidechain is not valid\r\n     * @dev Check this before sidechain's operations\r\n     */\r\n    modifier onlyValidSidechain() {\r\n        require(dPoSContract.isValidDPoS(), 'DPoS is not valid');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice SGN constructor\r\n     * @dev Need to deploy DPoS contract first before deploying SGN contract\r\n     * @param _celerTokenAddress address of Celer Token Contract\r\n     * @param _DPoSAddress address of DPoS Contract\r\n     */\r\n    constructor(address _celerTokenAddress, address _DPoSAddress) public {\r\n        celerToken = IERC20(_celerTokenAddress);\r\n        dPoSContract = IDPoS(_DPoSAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Owner drains one type of tokens when the contract is paused\r\n     * @dev This is for emergency situations.\r\n     * @param _amount drained token amount\r\n     */\r\n    function drainToken(uint256 _amount) external whenPaused onlyOwner {\r\n        celerToken.safeTransfer(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Update sidechain address\r\n     * @dev Note that the \"sidechain address\" here means the address in the offchain sidechain system,\r\n         which is different from the sidechain contract address\r\n     * @param _sidechainAddr the new address in the offchain sidechain system\r\n     */\r\n    function updateSidechainAddr(bytes calldata _sidechainAddr) external {\r\n        address msgSender = msg.sender;\r\n\r\n        (bool initialized, , , uint256 status, , , ) = dPoSContract.getCandidateInfo(msgSender);\r\n        require(\r\n            status == uint256(DPoSCommon.CandidateStatus.Unbonded),\r\n            'msg.sender is not unbonded'\r\n        );\r\n        require(initialized, 'Candidate is not initialized');\r\n\r\n        bytes memory oldSidechainAddr = sidechainAddrMap[msgSender];\r\n        sidechainAddrMap[msgSender] = _sidechainAddr;\r\n\r\n        emit UpdateSidechainAddr(msgSender, oldSidechainAddr, _sidechainAddr);\r\n    }\r\n\r\n    /**\r\n     * @notice Subscribe the guardian service\r\n     * @param _amount subscription fee paid along this function call in CELR tokens\r\n     */\r\n    function subscribe(uint256 _amount) external whenNotPaused onlyValidSidechain {\r\n        address msgSender = msg.sender;\r\n\r\n        servicePool = servicePool.add(_amount);\r\n        subscriptionDeposits[msgSender] = subscriptionDeposits[msgSender].add(_amount);\r\n\r\n        celerToken.safeTransferFrom(msgSender, address(this), _amount);\r\n\r\n        emit AddSubscriptionBalance(msgSender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Redeem rewards\r\n     * @dev The rewards include both the service reward and mining reward\r\n     * @dev SGN contract acts as an interface for users to redeem mining rewards\r\n     * @param _rewardRequest reward request bytes coded in protobuf\r\n     */\r\n    function redeemReward(bytes calldata _rewardRequest) external whenNotPaused onlyValidSidechain {\r\n        require(\r\n            dPoSContract.validateMultiSigMessage(_rewardRequest),\r\n            'Validator sigs verification failed'\r\n        );\r\n\r\n        PbSgn.RewardRequest memory rewardRequest = PbSgn.decRewardRequest(_rewardRequest);\r\n        PbSgn.Reward memory reward = PbSgn.decReward(rewardRequest.reward);\r\n        uint256 newServiceReward = reward.cumulativeServiceReward.sub(\r\n            redeemedServiceReward[reward.receiver]\r\n        );\r\n\r\n        require(servicePool >= newServiceReward, 'Service pool is smaller than new service reward');\r\n        redeemedServiceReward[reward.receiver] = reward.cumulativeServiceReward;\r\n        servicePool = servicePool.sub(newServiceReward);\r\n\r\n        dPoSContract.redeemMiningReward(reward.receiver, reward.cumulativeMiningReward);\r\n        celerToken.safeTransfer(reward.receiver, newServiceReward);\r\n\r\n        emit RedeemReward(\r\n            reward.receiver,\r\n            reward.cumulativeMiningReward,\r\n            newServiceReward,\r\n            servicePool\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_celerTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DPoSAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddSubscriptionBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cumulativeMiningReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"serviceReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"servicePool\",\"type\":\"uint256\"}],\"name\":\"RedeemReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"oldSidechainAddr\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"newSidechainAddr\",\"type\":\"bytes\"}],\"name\":\"UpdateSidechainAddr\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"celerToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dPoSContract\",\"outputs\":[{\"internalType\":\"contract IDPoS\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"drainToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_rewardRequest\",\"type\":\"bytes\"}],\"name\":\"redeemReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redeemedServiceReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"servicePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sidechainAddrMap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"subscribe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"subscriptionDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_sidechainAddr\",\"type\":\"bytes\"}],\"name\":\"updateSidechainAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SGN","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004f9254c83eb525f9fcf346490bbb3ed28a81c6670000000000000000000000005216db4d4cb22d1ba38866867c38d8e862974e82","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0ef48f0fa8c2c39f174999979f900f8eed58c0a95e79562343d0db5c5f94678a"}]}