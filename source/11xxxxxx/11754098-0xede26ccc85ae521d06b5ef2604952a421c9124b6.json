{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n   Copyright (c) 2021 LocalCryptos.com\r\n\r\n   Licensed under the Apache License, Version 2.0 (the “License”);\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an “AS IS” BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n*/\r\n// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.7.6;\r\n\r\nabstract contract Token {\r\n    function transfer(address _to, uint _value) public virtual returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public virtual returns (bool success);\r\n    function virtualapprove(address _spender, uint _value) public virtual returns (bool success);\r\n    function approve(address spender, uint256 value) public virtual returns (bool);\r\n}\r\n\r\n/// @title LocalCryptos ETH Escrows\r\n/// @author LocalCryptos\r\ncontract LocalCryptosETHEscrows {\r\n    /***********************\r\n    +   Global settings   +\r\n    ***********************/\r\n\r\n    // Address of the arbitrator (currently always localethereum staff)\r\n    address public arbitrator;\r\n    // Address of the owner (who can withdraw collected fees)\r\n    address public owner;\r\n    address public inviterAddress;\r\n    // Addresses of the relayers (which addresses are allowed to forward signed instructions from parties)\r\n    mapping (address => bool) public relayers;\r\n\r\n    uint32 public requestCancellationMinimumTime;\r\n    // Cumulative balance of collected fees\r\n    uint256 public feesAvailableForWithdraw;\r\n\r\n    /***********************\r\n    +  Instruction types  +\r\n    ***********************/\r\n\r\n    // Called when the buyer marks payment as sent. Locks funds in escrow\r\n    uint8 constant INSTRUCTION_SELLER_CANNOT_CANCEL = 0x01;\r\n    // Buyer cancelling\r\n    uint8 constant INSTRUCTION_BUYER_CANCEL = 0x02;\r\n    // Seller cancelling\r\n    uint8 constant INSTRUCTION_SELLER_CANCEL = 0x03;\r\n    // Seller requesting to cancel. Begins a window for buyer to object\r\n    uint8 constant INSTRUCTION_SELLER_REQUEST_CANCEL = 0x04;\r\n    // Seller releasing funds to the buyer\r\n    uint8 constant INSTRUCTION_RELEASE = 0x05;\r\n    // Either party permitting the arbitrator to resolve a dispute\r\n    uint8 constant INSTRUCTION_RESOLVE = 0x06;\r\n\r\n    /***********************\r\n    +       Events        +\r\n    ***********************/\r\n\r\n    event Created(bytes32 indexed _tradeHash);\r\n    event SellerCancelDisabled(bytes32 indexed _tradeHash);\r\n    event SellerRequestedCancel(bytes32 indexed _tradeHash);\r\n    event CancelledBySeller(bytes32 indexed _tradeHash);\r\n    event CancelledByBuyer(bytes32 indexed _tradeHash);\r\n    event Released(bytes32 indexed _tradeHash);\r\n    event DisputeResolved(bytes32 indexed _tradeHash);\r\n\r\n    struct Escrow {\r\n        // So we know the escrow exists\r\n        bool exists;\r\n        // This is the timestamp in whic hthe seller can cancel the escrow after.\r\n        // It has two special values:\r\n        // 0 : Permanently locked by the buyer (i.e. marked as paid; the seller can never cancel)\r\n        // 1 : The seller can only request to cancel, which will change this value to a timestamp.\r\n        //     This option is avaialble for complex trade terms such as cash-in-person where a\r\n        //     payment window is inappropriate\r\n        uint32 sellerCanCancelAfter;\r\n        // Cumulative cost of gas incurred by the relayer. This amount will be refunded to the owner\r\n        // in the way of fees once the escrow has completed\r\n        uint128 totalGasFeesSpentByRelayer;\r\n    }\r\n\r\n    // Mapping of active trades. The key here is a hash of the trade proprties\r\n    mapping (bytes32 => Escrow) public escrows;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Must be owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyArbitrator() {\r\n        require(msg.sender == arbitrator, \"Must be arbitrator\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Initialize the contract.\r\n    constructor() {\r\n        owner = msg.sender;\r\n        arbitrator = msg.sender;\r\n        inviterAddress = msg.sender;\r\n        requestCancellationMinimumTime = 0 seconds;\r\n    }\r\n\r\n    /// @notice Create and fund a new escrow.\r\n    /// @param _tradeID The unique ID of the trade, generated by localethereum.com\r\n    /// @param _seller The selling party\r\n    /// @param _buyer The buying party\r\n    /// @param _value The amount of the escrow, exclusive of the fee\r\n    /// @param _fee Localethereum's commission in 1/10000ths\r\n    /// @param _paymentWindowInSeconds The time in seconds from escrow creation that the seller can cancel after\r\n    /// @param _expiry This transaction must be created before this time\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    function createEscrow(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint32 _paymentWindowInSeconds,\r\n        uint32 _expiry,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) payable external {\r\n        // The trade hash is created by tightly-concatenating and hashing properties of the trade.\r\n        // This hash becomes the identifier of the escrow, and hence all these variables must be\r\n        // supplied on future contract calls\r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));\r\n        // Require that trade does not already exist\r\n        require(!escrows[_tradeHash].exists, \"Trade already exists\");\r\n        // A signature (v, r and s) must come from localethereum to open an escrow\r\n        bytes32 _invitationHash = keccak256(abi.encodePacked(\r\n            _tradeHash,\r\n            _paymentWindowInSeconds,\r\n            _expiry\r\n        ));\r\n        require(recoverAddress(_invitationHash, _v, _r, _s) == inviterAddress, \"Invitation signature was not valid\");\r\n        // These signatures come with an expiry stamp\r\n        require(block.timestamp < _expiry, \"Signature has expired\");\r\n        // Check transaction value against signed _value and make sure is not 0\r\n        require(msg.value == _value && msg.value > 0, \"Incorrect ether sent\");\r\n        uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0\r\n            ? 1\r\n            : uint32(block.timestamp) + _paymentWindowInSeconds;\r\n        // Add the escrow to the public mapping\r\n        escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);\r\n        emit Created(_tradeHash);\r\n    }\r\n\r\n    uint16 constant GAS_doResolveDispute = 45368;\r\n    /// @notice Called by the arbitrator to resolve a dispute. Requires a signature from either party.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @param _buyerPercent What % should be distributed to the buyer (this is usually 0 or 100)\r\n    function resolveDispute(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address payable _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _buyerPercent\r\n    ) external onlyArbitrator {\r\n        address _signature = recoverAddress(keccak256(abi.encodePacked(\r\n            _tradeID,\r\n            INSTRUCTION_RESOLVE\r\n        )), _v, _r, _s);\r\n        require(_signature == _buyer || _signature == _seller, \"Must be buyer or seller\");\r\n\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        require(_escrow.exists, \"Escrow does not exist\");\r\n        require(_buyerPercent <= 100, \"_buyerPercent must be 100 or lower\");\r\n\r\n        uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer + (GAS_doResolveDispute * uint128(tx.gasprice));\r\n        require(_value - _totalFees <= _value, \"Overflow error\"); // Prevent underflow\r\n        feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw\r\n\r\n        delete escrows[_tradeHash];\r\n        emit DisputeResolved(_tradeHash);\r\n        if (_buyerPercent > 0)\r\n          payable(_buyer).transfer((_value - _totalFees) * _buyerPercent / 100);\r\n        if (_buyerPercent < 100)\r\n          payable(_seller).transfer((_value - _totalFees) * (100 - _buyerPercent) / 100);\r\n    }\r\n\r\n    /// @notice Release ether in escrow to the buyer. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function release(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address payable _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _seller, \"Must be seller\");\r\n        return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Disable the seller from cancelling (i.e. \"mark as paid\"). Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function disableSellerCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _buyer, \"Must be buyer\");\r\n        return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Cancel the escrow as a buyer. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function buyerCancel(\r\n      bytes16 _tradeID,\r\n      address payable _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _buyer, \"Must be buyer\");\r\n        return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Cancel the escrow as a seller. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function sellerCancel(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _seller, \"Must be seller\");\r\n        return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Request to cancel as a seller. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function sellerRequestCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _seller, \"Must be seller\");\r\n        return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    uint16 constant GAS_batchRelayBase = 32720;\r\n    /// @notice Relay multiple signed instructions from parties of escrows.\r\n    /// @param _tradeID List of _tradeID values\r\n    /// @param _seller List of _seller values\r\n    /// @param _buyer List of _buyer values\r\n    /// @param _value List of _value values\r\n    /// @param _fee List of _fee values\r\n    /// @param _maximumGasPrice List of _maximumGasPrice values\r\n    /// @param _v List of signature \"v\" components\r\n    /// @param _r List of signature \"r\" components\r\n    /// @param _s List of signature \"s\" components\r\n    /// @param _instructionByte List of _instructionByte values\r\n    /// @return bool List of results\r\n    function batchRelay(\r\n        bytes16[] memory _tradeID,\r\n        address payable[] memory _seller,\r\n        address payable[] memory _buyer,\r\n        uint256[] memory _value,\r\n        uint16[] memory _fee,\r\n        uint128[] memory _maximumGasPrice,\r\n        uint8[] memory _v,\r\n        bytes32[] memory _r,\r\n        bytes32[] memory _s,\r\n        uint8[] memory _instructionByte\r\n    ) public returns (bool[] memory) {\r\n        bool[] memory _results = new bool[](_tradeID.length);\r\n        uint128 _additionalGas = uint128(relayers[msg.sender] == true ? (GAS_batchRelayBase / _tradeID.length) : 0);\r\n        for (uint8 i=0; i<_tradeID.length; i++) {\r\n            _results[i] = relay(\r\n                _tradeID[i],\r\n                _seller[i],\r\n                _buyer[i],\r\n                _value[i],\r\n                _fee[i],\r\n                _maximumGasPrice[i],\r\n                _v[i],\r\n                _r[i],\r\n                _s[i],\r\n                _instructionByte[i],\r\n                _additionalGas\r\n            );\r\n        }\r\n        return _results;\r\n    }\r\n\r\n    /// @notice Withdraw fees collected by the contract. Only the owner can call this.\r\n    /// @param _to Address to withdraw fees in to\r\n    /// @param _amount Amount to withdraw\r\n    function withdrawFees(address payable _to, uint256 _amount) onlyOwner external {\r\n        // This check also prevents underflow\r\n        require(_amount <= feesAvailableForWithdraw, \"Amount is higher than amount available\");\r\n        feesAvailableForWithdraw -= _amount;\r\n        payable(_to).transfer(_amount);\r\n    }\r\n\r\n    /// @notice Set the arbitrator to a new address. Only the owner can call this.\r\n    /// @param _newArbitrator Address of the replacement arbitrator\r\n    function setArbitrator(address _newArbitrator) onlyOwner external {\r\n        arbitrator = _newArbitrator;\r\n    }\r\n\r\n    /// @notice Change the owner to a new address. Only the owner can call this.\r\n    /// @param _newOwner Address of the replacement owner\r\n    function setOwner(address _newOwner) onlyOwner external {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /// @notice Enable or disable a relayer address. Only the owner can call this.\r\n    /// @param _newRelayer Address of the relayer\r\n    /// @param _enabled Whether the relayer is enabled\r\n    function setRelayer(address _newRelayer, bool _enabled) onlyOwner external {\r\n        relayers[_newRelayer] = _enabled;\r\n    }\r\n\r\n    /// @notice Change the inviter to a new address. Only the owner can call this.\r\n    /// @param _newInviterAddress Address of the inviter address\r\n    function setInviterAddress(address _newInviterAddress) onlyOwner external {\r\n        inviterAddress = _newInviterAddress;\r\n    }\r\n\r\n    /// @notice Change the requestCancellationMinimumTime. Only the owner can call this.\r\n    /// @param _newRequestCancellationMinimumTime Replacement\r\n    function setRequestCancellationMinimumTime(\r\n        uint32 _newRequestCancellationMinimumTime\r\n    ) onlyOwner external {\r\n        requestCancellationMinimumTime = _newRequestCancellationMinimumTime;\r\n    }\r\n\r\n    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\r\n    /// @param _tokenContract Token contract\r\n    /// @param _transferTo Recipient\r\n    /// @param _value Value\r\n    function transferToken(\r\n        Token _tokenContract,\r\n        address _transferTo,\r\n        uint256 _value\r\n    ) onlyOwner external {\r\n        _tokenContract.transfer(_transferTo, _value);\r\n    }\r\n\r\n    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\r\n    /// @param _tokenContract Token contract\r\n    /// @param _transferTo Recipient\r\n    /// @param _transferFrom Sender\r\n    /// @param _value Value\r\n    function transferTokenFrom(\r\n        Token _tokenContract,\r\n        address _transferTo,\r\n        address _transferFrom,\r\n        uint256 _value\r\n    ) onlyOwner external {\r\n        _tokenContract.transferFrom(_transferTo, _transferFrom, _value);\r\n    }\r\n\r\n    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\r\n    /// @param _tokenContract Token contract\r\n    /// @param _spender Spender address\r\n    /// @param _value Value\r\n    function approveToken(\r\n        Token _tokenContract,\r\n        address _spender,\r\n        uint256 _value\r\n    ) onlyOwner external {\r\n        _tokenContract.approve(_spender, _value);\r\n    }\r\n\r\n    /// @notice Relay a signed instruction from a party of an escrow.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _maximumGasPrice Maximum gas price permitted for the relayer (set by the instructor)\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function relay(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address payable _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _maximumGasPrice,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _instructionByte,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        address _relayedSender = getRelayedSender(\r\n            _tradeID,\r\n            _instructionByte,\r\n            _maximumGasPrice,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n        if (_relayedSender == _buyer) {\r\n            // Buyer's instructions:\r\n            if (_instructionByte == INSTRUCTION_SELLER_CANNOT_CANCEL) {\r\n                // Disable seller from cancelling\r\n                return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            } else if (_instructionByte == INSTRUCTION_BUYER_CANCEL) {\r\n                // Cancel\r\n                return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            }\r\n        } else if (_relayedSender == _seller) {\r\n            // Seller's instructions:\r\n            if (_instructionByte == INSTRUCTION_RELEASE) {\r\n                // Release\r\n                return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            } else if (_instructionByte == INSTRUCTION_SELLER_CANCEL) {\r\n                // Cancel\r\n                return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            } else if (_instructionByte == INSTRUCTION_SELLER_REQUEST_CANCEL) {\r\n                // Request to cancel\r\n                return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @notice Increase the amount of gas to be charged later on completion of an escrow\r\n    /// @param _tradeHash Trade hash\r\n    /// @param _gas Gas cost\r\n    function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {\r\n        escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);\r\n    }\r\n\r\n    /// @notice Transfer the value of an escrow, minus the fees, minus the gas costs incurred by relay\r\n    /// @param _to Recipient address\r\n    /// @param _value Value of the transfer\r\n    /// @param _totalGasFeesSpentByRelayer Total gas fees spent by the relayer\r\n    /// @param _fee Commission in 1/10000ths\r\n    function transferMinusFees(\r\n        address payable _to,\r\n        uint256 _value,\r\n        uint128 _totalGasFeesSpentByRelayer,\r\n        uint16 _fee\r\n    ) private {\r\n        uint256 _totalFees = (_value * _fee / 10000) + _totalGasFeesSpentByRelayer;\r\n        // Prevent underflow\r\n        if(_value - _totalFees > _value) {\r\n            return;\r\n        }\r\n        // Add fees to the pot for localethereum to withdraw\r\n        feesAvailableForWithdraw += _totalFees;\r\n        payable(_to).transfer(_value - _totalFees);\r\n    }\r\n\r\n    uint16 constant GAS_doRelease = 12664;\r\n    /// @notice Release escrow to the buyer. This completes it and removes it from the mapping.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doRelease(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address payable _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\r\n            + (relayers[msg.sender] == true\r\n                ? (GAS_doRelease + _additionalGas ) * uint128(tx.gasprice)\r\n                : 0\r\n            );\r\n        delete escrows[_tradeHash];\r\n        emit Released(_tradeHash);\r\n        transferMinusFees(_buyer, _value, _gasFees, _fee);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doDisableSellerCancel = 16568;\r\n    /// @notice Prevents the seller from cancelling an escrow. Used to \"mark as paid\" by the buyer.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doDisableSellerCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        if(_escrow.sellerCanCancelAfter == 0) return false;\r\n        escrows[_tradeHash].sellerCanCancelAfter = 0;\r\n        emit SellerCancelDisabled(_tradeHash);\r\n        if (relayers[msg.sender] == true) {\r\n          increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doBuyerCancel = 12648;\r\n    /// @notice Cancels the trade and returns the ether to the seller. Can only be called the buyer.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doBuyerCancel(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) {\r\n            return false;\r\n        }\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\r\n            + (relayers[msg.sender] == true\r\n                ? (GAS_doBuyerCancel + _additionalGas ) * uint128(tx.gasprice)\r\n                : 0\r\n            );\r\n        delete escrows[_tradeHash];\r\n        emit CancelledByBuyer(_tradeHash);\r\n        transferMinusFees(_seller, _value, _gasFees, 0);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doSellerCancel = 13714;\r\n    /// @notice Returns the ether in escrow to the seller. Called by the seller. Sometimes unavailable.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doSellerCancel(\r\n        bytes16 _tradeID,\r\n        address payable _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) {\r\n            return false;\r\n        }\r\n        if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {\r\n            return false;\r\n        }\r\n        if (relayers[msg.sender] == false && _escrow.sellerCanCancelAfter + 12 hours > block.timestamp) {\r\n            return false;\r\n        }\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\r\n            + (relayers[msg.sender] == true\r\n                ? (GAS_doSellerCancel + _additionalGas ) * uint128(tx.gasprice)\r\n                : 0\r\n            );\r\n        delete escrows[_tradeHash];\r\n        emit CancelledBySeller(_tradeHash);\r\n        transferMinusFees(_seller, _value, _gasFees, 0);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doSellerRequestCancel = 17004;\r\n    /// @notice Request to cancel. Used if the buyer is unresponsive. Begins a countdown timer.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doSellerRequestCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        // Called on unlimited payment window trades where the buyer is not responding\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) {\r\n            return false;\r\n        }\r\n        if(_escrow.sellerCanCancelAfter != 1) {\r\n            return false;\r\n        }\r\n        escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp)\r\n            + requestCancellationMinimumTime;\r\n        emit SellerRequestedCancel(_tradeHash);\r\n        if (relayers[msg.sender] == true) {\r\n          increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @notice Get the sender of the signed instruction.\r\n    /// @param _tradeID Identifier of the trade\r\n    /// @param _instructionByte Identifier of the instruction\r\n    /// @param _maximumGasPrice Maximum gas price permitted by the sender\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @return address\r\n    function getRelayedSender(\r\n      bytes16 _tradeID,\r\n      uint8 _instructionByte,\r\n      uint128 _maximumGasPrice,\r\n      uint8 _v,\r\n      bytes32 _r,\r\n      bytes32 _s\r\n    ) view private returns (address) {\r\n        bytes32 _hash = keccak256(abi.encodePacked(\r\n            _tradeID,\r\n            _instructionByte,\r\n            _maximumGasPrice\r\n        ));\r\n        if(tx.gasprice > _maximumGasPrice) {\r\n            return (address)(0);\r\n        }\r\n        return recoverAddress(_hash, _v, _r, _s);\r\n    }\r\n\r\n    /// @notice Hashes the values and returns the matching escrow object and trade hash.\r\n    /// @dev Returns an empty escrow struct and 0 _tradeHash if not found.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return Escrow\r\n    function getEscrowAndHash(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) view private returns (Escrow memory, bytes32) {\r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(\r\n            _tradeID,\r\n            _seller,\r\n            _buyer,\r\n            _value,\r\n            _fee\r\n        ));\r\n        return (escrows[_tradeHash], _tradeHash);\r\n    }\r\n\r\n    /// @notice Returns an empty escrow struct and 0 _tradeHash if not found.\r\n    /// @param _h Data to be hashed\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @return address\r\n    function recoverAddress(\r\n        bytes32 _h,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) private pure returns (address) {\r\n        bytes memory _prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 _prefixedHash = keccak256(abi.encodePacked(_prefix, _h));\r\n        return ecrecover(_prefixedHash, _v, _r, _s);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"CancelledByBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"CancelledBySeller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"DisputeResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"SellerCancelDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"SellerRequestedCancel\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arbitrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_tradeID\",\"type\":\"bytes16[]\"},{\"internalType\":\"address payable[]\",\"name\":\"_seller\",\"type\":\"address[]\"},{\"internalType\":\"address payable[]\",\"name\":\"_buyer\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_value\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_fee\",\"type\":\"uint16[]\"},{\"internalType\":\"uint128[]\",\"name\":\"_maximumGasPrice\",\"type\":\"uint128[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_s\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_instructionByte\",\"type\":\"uint8[]\"}],\"name\":\"batchRelay\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"buyerCancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"_paymentWindowInSeconds\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_expiry\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"createEscrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"disableSellerCancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"escrows\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"sellerCanCancelAfter\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"totalGasFeesSpentByRelayer\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesAvailableForWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inviterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"relayers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"release\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestCancellationMinimumTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_buyerPercent\",\"type\":\"uint8\"}],\"name\":\"resolveDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"sellerCancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"sellerRequestCancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newArbitrator\",\"type\":\"address\"}],\"name\":\"setArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newInviterAddress\",\"type\":\"address\"}],\"name\":\"setInviterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRelayer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_newRequestCancellationMinimumTime\",\"type\":\"uint32\"}],\"name\":\"setRequestCancellationMinimumTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_transferTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_transferTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_transferFrom\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokenFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LocalCryptosETHEscrows","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5002c724a7f667f48c4e71b9e8bdce94d18e54e3e68ec8e1f9f95295d24ee65c"}]}