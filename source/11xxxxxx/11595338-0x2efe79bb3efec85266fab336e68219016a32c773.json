{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dependencies/open-zeppelin/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport './Context.sol';\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    address msgSender = _msgSender();\\n    _owner = msgSender;\\n    emit OwnershipTransferred(address(0), msgSender);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/AaveGovernanceV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IVotingStrategy} from '../interfaces/IVotingStrategy.sol';\\nimport {IExecutorWithTimelock} from '../interfaces/IExecutorWithTimelock.sol';\\nimport {IProposalValidator} from '../interfaces/IProposalValidator.sol';\\nimport {IGovernanceStrategy} from '../interfaces/IGovernanceStrategy.sol';\\nimport {IAaveGovernanceV2} from '../interfaces/IAaveGovernanceV2.sol';\\nimport {Ownable} from '../dependencies/open-zeppelin/Ownable.sol';\\nimport {SafeMath} from '../dependencies/open-zeppelin/SafeMath.sol';\\nimport {isContract, getChainId} from '../misc/Helpers.sol';\\n\\n/**\\n * @title Governance V2 contract\\n * @dev Main point of interaction with Aave protocol's governance\\n * - Create a Proposal\\n * - Cancel a Proposal\\n * - Queue a Proposal\\n * - Execute a Proposal\\n * - Submit Vote to a Proposal\\n * Proposal States : Pending => Active => Succeeded(/Failed) => Queued => Executed(/Expired)\\n *                   The transition to \\\"Canceled\\\" can appear in multiple states\\n * @author Aave\\n **/\\ncontract AaveGovernanceV2 is Ownable, IAaveGovernanceV2 {\\n  using SafeMath for uint256;\\n\\n  address private _governanceStrategy;\\n  uint256 private _votingDelay;\\n\\n  uint256 private _proposalsCount;\\n  mapping(uint256 => Proposal) private _proposals;\\n  mapping(address => bool) private _authorizedExecutors;\\n\\n  address private _guardian;\\n\\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\\n  );\\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256('VoteEmitted(uint256 id,bool support)');\\n  string public constant NAME = 'Aave Governance v2';\\n\\n  modifier onlyGuardian() {\\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\\n    _;\\n  }\\n\\n  constructor(\\n    address governanceStrategy,\\n    uint256 votingDelay,\\n    address guardian,\\n    address[] memory executors\\n  ) {\\n    _setGovernanceStrategy(governanceStrategy);\\n    _setVotingDelay(votingDelay);\\n    _guardian = guardian;\\n\\n    authorizeExecutors(executors);\\n  }\\n\\n  struct CreateVars {\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 previousProposalsCount;\\n  }\\n\\n  /**\\n   * @dev Creates a Proposal (needs to be validated by the Proposal Validator)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  function create(\\n    IExecutorWithTimelock executor,\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    bool[] memory withDelegatecalls,\\n    bytes32 ipfsHash\\n  ) external override returns (uint256) {\\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\\n    require(\\n      targets.length == values.length &&\\n        targets.length == signatures.length &&\\n        targets.length == calldatas.length &&\\n        targets.length == withDelegatecalls.length,\\n      'INCONSISTENT_PARAMS_LENGTH'\\n    );\\n\\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\\n\\n    require(\\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\\n        this,\\n        msg.sender,\\n        block.number - 1\\n      ),\\n      'PROPOSITION_CREATION_INVALID'\\n    );\\n\\n    CreateVars memory vars;\\n\\n    vars.startBlock = block.number.add(_votingDelay);\\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\\n\\n    vars.previousProposalsCount = _proposalsCount;\\n\\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\\n    newProposal.id = vars.previousProposalsCount;\\n    newProposal.creator = msg.sender;\\n    newProposal.executor = executor;\\n    newProposal.targets = targets;\\n    newProposal.values = values;\\n    newProposal.signatures = signatures;\\n    newProposal.calldatas = calldatas;\\n    newProposal.withDelegatecalls = withDelegatecalls;\\n    newProposal.startBlock = vars.startBlock;\\n    newProposal.endBlock = vars.endBlock;\\n    newProposal.strategy = _governanceStrategy;\\n    newProposal.ipfsHash = ipfsHash;\\n    _proposalsCount++;\\n\\n    emit ProposalCreated(\\n      vars.previousProposalsCount,\\n      msg.sender,\\n      executor,\\n      targets,\\n      values,\\n      signatures,\\n      calldatas,\\n      withDelegatecalls,\\n      vars.startBlock,\\n      vars.endBlock,\\n      _governanceStrategy,\\n      ipfsHash\\n    );\\n\\n    return newProposal.id;\\n  }\\n\\n  /**\\n   * @dev Cancels a Proposal.\\n   * - Callable by the _guardian with relaxed conditions, or by anybody if the conditions of\\n   *   cancellation on the executor are fulfilled\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external override {\\n    ProposalState state = getProposalState(proposalId);\\n    require(\\n      state != ProposalState.Executed &&\\n        state != ProposalState.Canceled &&\\n        state != ProposalState.Expired,\\n      'ONLY_BEFORE_EXECUTED'\\n    );\\n\\n    Proposal storage proposal = _proposals[proposalId];\\n    require(\\n      msg.sender == _guardian ||\\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\\n          this,\\n          proposal.creator,\\n          block.number - 1\\n        ),\\n      'PROPOSITION_CANCELLATION_INVALID'\\n    );\\n    proposal.canceled = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      proposal.executor.cancelTransaction(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n\\n    emit ProposalCanceled(proposalId);\\n  }\\n\\n  /**\\n   * @dev Queue the proposal (If Proposal Succeeded)\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external override {\\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\\n    Proposal storage proposal = _proposals[proposalId];\\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      _queueOrRevert(\\n        proposal.executor,\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n    proposal.executionTime = executionTime;\\n\\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Execute the proposal (If Proposal Queued)\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable override {\\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\\n    Proposal storage proposal = _proposals[proposalId];\\n    proposal.executed = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n    emit ProposalExecuted(proposalId, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   **/\\n  function submitVote(uint256 proposalId, bool support) external override {\\n    return _submitVote(msg.sender, proposalId, support);\\n  }\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    bool support,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external override {\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\n        '\\\\x19\\\\x01',\\n        keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))),\\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\\n      )\\n    );\\n    address signer = ecrecover(digest, v, r, s);\\n    require(signer != address(0), 'INVALID_SIGNATURE');\\n    return _submitVote(signer, proposalId, support);\\n  }\\n\\n  /**\\n   * @dev Set new GovernanceStrategy\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\\n   **/\\n  function setGovernanceStrategy(address governanceStrategy) external override onlyOwner {\\n    _setGovernanceStrategy(governanceStrategy);\\n  }\\n\\n  /**\\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param votingDelay new voting delay in terms of blocks\\n   **/\\n  function setVotingDelay(uint256 votingDelay) external override onlyOwner {\\n    _setVotingDelay(votingDelay);\\n  }\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] memory executors) public override onlyOwner {\\n    for (uint256 i = 0; i < executors.length; i++) {\\n      _authorizeExecutor(executors[i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\\n    for (uint256 i = 0; i < executors.length; i++) {\\n      _unauthorizeExecutor(executors[i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Let the guardian abdicate from its priviledged rights\\n   **/\\n  function __abdicate() external override onlyGuardian {\\n    _guardian = address(0);\\n  }\\n\\n  /**\\n   * @dev Getter of the current GovernanceStrategy address\\n   * @return The address of the current GovernanceStrategy contracts\\n   **/\\n  function getGovernanceStrategy() external view override returns (address) {\\n    return _governanceStrategy;\\n  }\\n\\n  /**\\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\\n   * Different from the voting duration\\n   * @return The voting delay in number of blocks\\n   **/\\n  function getVotingDelay() external view override returns (uint256) {\\n    return _votingDelay;\\n  }\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\\n    return _authorizedExecutors[executor];\\n  }\\n\\n  /**\\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\\n   * @return The address of the guardian\\n   **/\\n  function getGuardian() external view override returns (address) {\\n    return _guardian;\\n  }\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view override returns (uint256) {\\n    return _proposalsCount;\\n  }\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVotes memory object\\n   **/\\n  function getProposalById(uint256 proposalId)\\n    external\\n    view\\n    override\\n    returns (ProposalWithoutVotes memory)\\n  {\\n    Proposal storage proposal = _proposals[proposalId];\\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\\n      id: proposal.id,\\n      creator: proposal.creator,\\n      executor: proposal.executor,\\n      targets: proposal.targets,\\n      values: proposal.values,\\n      signatures: proposal.signatures,\\n      calldatas: proposal.calldatas,\\n      withDelegatecalls: proposal.withDelegatecalls,\\n      startBlock: proposal.startBlock,\\n      endBlock: proposal.endBlock,\\n      executionTime: proposal.executionTime,\\n      forVotes: proposal.forVotes,\\n      againstVotes: proposal.againstVotes,\\n      executed: proposal.executed,\\n      canceled: proposal.canceled,\\n      strategy: proposal.strategy,\\n      ipfsHash: proposal.ipfsHash\\n    });\\n\\n    return proposalWithoutVotes;\\n  }\\n\\n  /**\\n   * @dev Getter of the Vote of a voter about a proposal\\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote memory object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter)\\n    external\\n    view\\n    override\\n    returns (Vote memory)\\n  {\\n    return _proposals[proposalId].votes[voter];\\n  }\\n\\n  /**\\n   * @dev Get the current state of a proposal\\n   * @param proposalId id of the proposal\\n   * @return The current state if the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\\n    require(_proposalsCount >= proposalId, 'INVALID_PROPOSAL_ID');\\n    Proposal storage proposal = _proposals[proposalId];\\n    if (proposal.canceled) {\\n      return ProposalState.Canceled;\\n    } else if (block.number <= proposal.startBlock) {\\n      return ProposalState.Pending;\\n    } else if (block.number <= proposal.endBlock) {\\n      return ProposalState.Active;\\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\\n      return ProposalState.Failed;\\n    } else if (proposal.executionTime == 0) {\\n      return ProposalState.Succeeded;\\n    } else if (proposal.executed) {\\n      return ProposalState.Executed;\\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\\n      return ProposalState.Expired;\\n    } else {\\n      return ProposalState.Queued;\\n    }\\n  }\\n\\n  function _queueOrRevert(\\n    IExecutorWithTimelock executor,\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory callData,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) internal {\\n    require(\\n      !executor.isActionQueued(\\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\\n      ),\\n      'DUPLICATED_ACTION'\\n    );\\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\\n  }\\n\\n  function _submitVote(\\n    address voter,\\n    uint256 proposalId,\\n    bool support\\n  ) internal {\\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\\n    Proposal storage proposal = _proposals[proposalId];\\n    Vote storage vote = proposal.votes[voter];\\n\\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\\n\\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\\n      voter,\\n      proposal.startBlock\\n    );\\n\\n    if (support) {\\n      proposal.forVotes = proposal.forVotes.add(votingPower);\\n    } else {\\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\\n    }\\n\\n    vote.support = support;\\n    vote.votingPower = uint248(votingPower);\\n\\n    emit VoteEmitted(proposalId, voter, support, votingPower);\\n  }\\n\\n  function _setGovernanceStrategy(address governanceStrategy) internal {\\n    _governanceStrategy = governanceStrategy;\\n\\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\\n  }\\n\\n  function _setVotingDelay(uint256 votingDelay) internal {\\n    _votingDelay = votingDelay;\\n\\n    emit VotingDelayChanged(votingDelay, msg.sender);\\n  }\\n\\n  function _authorizeExecutor(address executor) internal {\\n    _authorizedExecutors[executor] = true;\\n    emit ExecutorAuthorized(executor);\\n  }\\n\\n  function _unauthorizeExecutor(address executor) internal {\\n    _authorizedExecutors[executor] = false;\\n    emit ExecutorUnauthorized(executor);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVotingStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IVotingStrategy {\\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IAaveGovernanceV2} from './IAaveGovernanceV2.sol';\\n\\ninterface IExecutorWithTimelock {\\n  /**\\n   * @dev emitted when a new pending admin is set\\n   * @param newPendingAdmin address of the new pending admin\\n   **/\\n  event NewPendingAdmin(address newPendingAdmin);\\n\\n  /**\\n   * @dev emitted when a new admin is set\\n   * @param newAdmin address of the new admin\\n   **/\\n  event NewAdmin(address newAdmin);\\n\\n  /**\\n   * @dev emitted when a new delay (between queueing and execution) is set\\n   * @param delay new delay\\n   **/\\n  event NewDelay(uint256 delay);\\n\\n  /**\\n   * @dev emitted when a new (trans)action is Queued.\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event QueuedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event CancelledAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @param resultData the actual callData used on the target\\n   **/\\n  event ExecutedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall,\\n    bytes resultData\\n  );\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin \\n   **/\\n  function getAdmin() external view returns (address);\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin \\n   **/\\n  function getPendingAdmin() external view returns (address);\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view returns (uint256);\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\\n  /**\\n   * @dev Checks whether a proposal is over its grace period \\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n  /**\\n   * @dev Getter of grace period constant\\n   * @return grace period in seconds\\n   **/\\n  function GRACE_PERIOD() external view returns (uint256);\\n  /**\\n   * @dev Getter of minimum delay constant\\n   * @return minimum delay in seconds\\n   **/\\n  function MINIMUM_DELAY() external view returns (uint256);\\n  /**\\n   * @dev Getter of maximum delay constant\\n   * @return maximum delay in seconds\\n   **/\\n  function MAXIMUM_DELAY() external view returns (uint256);\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external payable returns (bytes memory);\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProposalValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IAaveGovernanceV2} from './IAaveGovernanceV2.sol';\\n\\ninterface IProposalValidator {\\n\\n  /**\\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be created\\n   **/\\n  function validateCreatorOfProposal(\\n    IAaveGovernanceV2 governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Called to validate the cancellation of a proposal\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be cancelled\\n   **/\\n  function validateProposalCancellation(\\n    IAaveGovernanceV2 governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\\n   * @param governance Governance Contract\\n   * @param user Address of the user to be challenged.\\n   * @param blockNumber Block Number against which to make the challenge.\\n   * @return true if user has enough power\\n   **/\\n  function isPropositionPowerEnough(\\n    IAaveGovernanceV2 governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\\n   * @param governance Governance Contract\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return minimum Proposition Power needed\\n   **/\\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns whether a proposal passed or not\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to set\\n   * @return true if proposal passed\\n   **/\\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if enough For-Votes\\n   **/\\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\\n   * @param votingSupply Total number of oustanding voting tokens\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\\n\\n  /**\\n   * @dev Get proposition threshold constant value\\n   * @return the proposition threshold value (100 <=> 1%)\\n   **/\\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\\n\\n  /**\\n   * @dev Get voting duration constant value\\n   * @return the voting duration value in seconds\\n   **/\\n  function VOTING_DURATION() external view returns (uint256);\\n\\n  /**\\n   * @dev Get the vote differential threshold constant value\\n   * to compare with % of for votes/total supply - % of against votes/total supply\\n   * @return the vote differential threshold value (100 <=> 1%)\\n   **/\\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\\n\\n  /**\\n   * @dev Get quorum threshold constant value\\n   * to compare with % of for votes/total supply\\n   * @return the quorum threshold value (100 <=> 1%)\\n   **/\\n  function MINIMUM_QUORUM() external view returns (uint256);\\n\\n  /**\\n   * @dev precision helper: 100% = 10000\\n   * @return one hundred percents with our chosen precision\\n   **/\\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernanceStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IGovernanceStrategy {\\n  /**\\n   * @dev Returns the Proposition Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\\n   * @return Power number\\n   **/\\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the total supply of Outstanding Proposition Tokens\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return total supply at blockNumber\\n   **/\\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the total supply of Outstanding Voting Tokens\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return total supply at blockNumber\\n   **/\\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the Vote Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Vote Power\\n   * @return Vote number\\n   **/\\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n\\n  /**\\n   * @dev Get the AAVE address of strategy\\n   * @return address\\n   **/\\n  function AAVE() external view returns (address);\\n\\n  /**\\n   * @dev Get the Staked AAVE address of strategy\\n   * @return address\\n   **/\\n  function STK_AAVE() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveGovernanceV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IExecutorWithTimelock} from './IExecutorWithTimelock.sol';\\n\\ninterface IAaveGovernanceV2 {\\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\\n\\n  struct Vote {\\n    bool support;\\n    uint248 votingPower;\\n  }\\n\\n  struct Proposal {\\n    uint256 id;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    address[] targets;\\n    uint256[] values;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 executionTime;\\n    uint256 forVotes;\\n    uint256 againstVotes;\\n    bool executed;\\n    bool canceled;\\n    address strategy;\\n    bytes32 ipfsHash;\\n    mapping(address => Vote) votes;\\n  }\\n\\n  struct ProposalWithoutVotes {\\n    uint256 id;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    address[] targets;\\n    uint256[] values;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 executionTime;\\n    uint256 forVotes;\\n    uint256 againstVotes;\\n    bool executed;\\n    bool canceled;\\n    address strategy;\\n    bytes32 ipfsHash;\\n  }\\n\\n  /**\\n   * @dev emitted when a new proposal is created\\n   * @param id Id of the proposal\\n   * @param creator address of the creator\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\\n   * @param startBlock block number when vote starts\\n   * @param endBlock block number when vote ends\\n   * @param strategy address of the governanceStrategy contract\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  event ProposalCreated(\\n    uint256 id,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    address[] targets,\\n    uint256[] values,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    bool[] withDelegatecalls,\\n    uint256 startBlock,\\n    uint256 endBlock,\\n    address strategy,\\n    bytes32 ipfsHash\\n  );\\n\\n  /**\\n   * @dev emitted when a proposal is canceled\\n   * @param id Id of the proposal\\n   **/\\n  event ProposalCanceled(uint256 id);\\n\\n  /**\\n   * @dev emitted when a proposal is queued\\n   * @param id Id of the proposal\\n   * @param executionTime time when proposal underlying transactions can be executed\\n   * @param initiatorQueueing address of the initiator of the queuing transaction\\n   **/\\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\\n  /**\\n   * @dev emitted when a proposal is executed\\n   * @param id Id of the proposal\\n   * @param initiatorExecution address of the initiator of the execution transaction\\n   **/\\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param id Id of the proposal\\n   * @param voter address of the voter\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param votingPower Power of the voter/vote\\n   **/\\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\\n\\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\\n\\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\\n\\n  event ExecutorAuthorized(address executor);\\n\\n  event ExecutorUnauthorized(address executor);\\n\\n  /**\\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param values list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\\n   * @param ipfsHash IPFS hash of the proposal\\n   **/\\n  function create(\\n    IExecutorWithTimelock executor,\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    bool[] memory withDelegatecalls,\\n    bytes32 ipfsHash\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Cancels a Proposal,\\n   * either at anytime by guardian\\n   * or when proposal is Pending/Active and threshold no longer reached\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Queue the proposal (If Proposal Succeeded)\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Execute the proposal (If Proposal Queued)\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable;\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   **/\\n  function submitVote(uint256 proposalId, bool support) external;\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param support boolean, true = vote for, false = vote against\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    bool support,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Set new GovernanceStrategy\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\\n   **/\\n  function setGovernanceStrategy(address governanceStrategy) external;\\n\\n  /**\\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\\n   * Note: owner should be a timelocked executor, so needs to make a proposal\\n   * @param votingDelay new voting delay in seconds\\n   **/\\n  function setVotingDelay(uint256 votingDelay) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] memory executors) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] memory executors) external;\\n\\n  /**\\n   * @dev Let the guardian abdicate from its priviledged rights\\n   **/\\n  function __abdicate() external;\\n\\n  /**\\n   * @dev Getter of the current GovernanceStrategy address\\n   * @return The address of the current GovernanceStrategy contracts\\n   **/\\n  function getGovernanceStrategy() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\\n   * Different from the voting duration\\n   * @return The voting delay in seconds\\n   **/\\n  function getVotingDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) external view returns (bool);\\n\\n  /**\\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\\n   * @return The address of the guardian\\n   **/\\n  function getGuardian() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVotes memory object\\n   **/\\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\\n\\n  /**\\n   * @dev Getter of the Vote of a voter about a proposal\\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote memory object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\\n\\n  /**\\n   * @dev Get the current state of a proposal\\n   * @param proposalId id of the proposal\\n   * @return The current state if the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nfunction getChainId() pure returns (uint256) {\\n  uint256 chainId;\\n  assembly {\\n    chainId := chainid()\\n  }\\n  return chainId;\\n}\\n\\nfunction isContract(address account) view returns (bool) {\\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n  // for accounts without code, i.e. `keccak256('')`\\n  bytes32 codehash;\\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n  // solhint-disable-next-line no-inline-assembly\\n  assembly {\\n    codehash := extcodehash(account)\\n  }\\n  return (codehash != accountHash && codehash != 0x0);\\n}\\n\"\r\n    },\r\n    \"contracts/misc/GovernanceV2Helper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IAaveGovernanceV2} from '../interfaces/IAaveGovernanceV2.sol';\\nimport {IProposalValidator} from '../interfaces/IProposalValidator.sol';\\nimport {IExecutorWithTimelock} from '../interfaces/IExecutorWithTimelock.sol';\\nimport {IGovernanceStrategy} from '../interfaces/IGovernanceStrategy.sol';\\nimport {IGovernanceV2Helper} from './interfaces/IGovernanceV2Helper.sol';\\nimport {SafeMath} from '../dependencies/open-zeppelin/SafeMath.sol';\\n\\n/**\\n * @title Governance V2 helper contract\\n * @dev Allows to easily read data from AaveGovernanceV2 contract\\n * - List of proposals with state\\n * - List of votes per proposal and voters\\n * @author Aave\\n **/\\ncontract GovernanceV2Helper is IGovernanceV2Helper {\\n  using SafeMath for uint256;\\n  uint256 public constant ONE_HUNDRED_WITH_PRECISION = 10000;\\n\\n  function getProposals(\\n    uint256 skip,\\n    uint256 limit,\\n    IAaveGovernanceV2 governance\\n  )\\n    external\\n    override\\n    view\\n    returns (\\n      IAaveGovernanceV2.ProposalWithoutVotes[] memory proposals,\\n      IAaveGovernanceV2.ProposalState[] memory proposalsState,\\n      ProposalStats[] memory proposalsStats\\n    )\\n  {\\n    uint256 count = governance.getProposalsCount().sub(skip);\\n    uint256 maxLimit = limit > count ? count : limit;\\n\\n    proposals = new IAaveGovernanceV2.ProposalWithoutVotes[](maxLimit);\\n    proposalsState = new IAaveGovernanceV2.ProposalState[](maxLimit);\\n    proposalsStats = new ProposalStats[](maxLimit);\\n\\n    for (uint256 i = 0; i < maxLimit; i++) {\\n      proposals[i] = governance.getProposalById(i.add(skip));\\n      uint256 votingSupply = IGovernanceStrategy(proposals[i].strategy).getTotalVotingSupplyAt(\\n        proposals[i].startBlock\\n      );\\n      proposalsState[i] = governance.getProposalState(i.add(skip));\\n      proposalsStats[i] = ProposalStats(\\n        IProposalValidator(address(proposals[i].executor)).getMinimumVotingPowerNeeded(\\n          votingSupply\\n        ),\\n        proposals[i].againstVotes.mul(ONE_HUNDRED_WITH_PRECISION).div(votingSupply).add(\\n          IProposalValidator(address(proposals[i].executor)).VOTE_DIFFERENTIAL()\\n        ),\\n        proposals[i].executionTime > 0\\n          ? IExecutorWithTimelock(proposals[i].executor).GRACE_PERIOD().add(\\n            proposals[i].executionTime\\n          )\\n          : proposals[i].executionTime,\\n        proposals[i].startBlock.sub(governance.getVotingDelay())\\n      );\\n    }\\n\\n    return (proposals, proposalsState, proposalsStats);\\n  }\\n\\n  function getProposal(uint256 id, IAaveGovernanceV2 governance)\\n    external\\n    override\\n    view\\n    returns (\\n      IAaveGovernanceV2.ProposalWithoutVotes memory proposal,\\n      IAaveGovernanceV2.ProposalState proposalState,\\n      ProposalStats memory proposalStats\\n    )\\n  {\\n    proposal = governance.getProposalById(id);\\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\\n      proposal.startBlock\\n    );\\n    proposalState = governance.getProposalState(id);\\n    proposalStats = ProposalStats(\\n      IProposalValidator(address(proposal.executor)).getMinimumVotingPowerNeeded(votingSupply),\\n      proposal.againstVotes.mul(ONE_HUNDRED_WITH_PRECISION).div(votingSupply).add(\\n        IProposalValidator(address(proposal.executor)).VOTE_DIFFERENTIAL()\\n      ),\\n      proposal.executionTime > 0\\n        ? IExecutorWithTimelock(proposal.executor).GRACE_PERIOD().add(proposal.executionTime)\\n        : proposal.executionTime,\\n      proposal.startBlock.sub(governance.getVotingDelay())\\n    );\\n    return (proposal, proposalState, proposalStats);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/interfaces/IGovernanceV2Helper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IAaveGovernanceV2} from '../../interfaces/IAaveGovernanceV2.sol';\\n\\ninterface IGovernanceV2Helper {\\n  struct ProposalStats {\\n    uint256 minimumQuorum;\\n    uint256 minimumDiff;\\n    uint256 executionTimeWithGracePeriod;\\n    uint256 proposalCreated;\\n  }\\n\\n  function getProposals(\\n    uint256 skip,\\n    uint256 limit,\\n    IAaveGovernanceV2 governance\\n  )\\n    external\\n    virtual\\n    view\\n    returns (\\n      IAaveGovernanceV2.ProposalWithoutVotes[] memory proposals,\\n      IAaveGovernanceV2.ProposalState[] memory proposalsState,\\n      ProposalStats[] memory proposalsStats\\n    );\\n\\n  function getProposal(uint256 id, IAaveGovernanceV2 governance)\\n    external\\n    virtual\\n    view\\n    returns (\\n      IAaveGovernanceV2.ProposalWithoutVotes memory proposal,\\n      IAaveGovernanceV2.ProposalState proposalState,\\n      ProposalStats memory proposalStats\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/FlashAttacks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IAaveGovernanceV2} from '../interfaces/IAaveGovernanceV2.sol';\\nimport {IERC20} from './interfaces/IERC20.sol';\\nimport {IExecutorWithTimelock} from '../interfaces/IExecutorWithTimelock.sol';\\n\\n\\ncontract FlashAttacks {\\n\\n  IERC20 internal immutable TOKEN;\\n  address internal immutable MINTER;\\n  IAaveGovernanceV2 internal immutable GOV;\\n\\n  constructor(address _token, address _MINTER, address _governance) {\\n    TOKEN = IERC20(_token);\\n    MINTER = _MINTER;\\n    GOV = IAaveGovernanceV2(_governance);\\n  }\\n\\n  function flashVote(uint256 votePower, uint256 proposalId, bool support) external {\\n    TOKEN.transferFrom(MINTER,address(this), votePower);\\n    GOV.submitVote(proposalId, support);\\n    TOKEN.transfer(MINTER, votePower);\\n  }\\n\\n  function flashVotePermit(uint256 votePower, uint256 proposalId,\\n    bool support,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s) external {\\n    TOKEN.transferFrom(MINTER, address(this), votePower);\\n    GOV.submitVoteBySignature(proposalId, support, v, r, s);\\n    TOKEN.transfer(MINTER, votePower);\\n  }\\n\\n  function flashProposal(uint256 proposalPower, IExecutorWithTimelock executor,\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    bool[] memory withDelegatecalls,\\n    bytes32 ipfsHash) external {\\n    TOKEN.transferFrom(MINTER, address(this),proposalPower);\\n    GOV.create(executor, targets, values, signatures, calldatas, withDelegatecalls, ipfsHash);\\n    TOKEN.transfer(MINTER, proposalPower);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IERC20 {\\n  function totalSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/ExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IExecutorWithTimelock} from '../interfaces/IExecutorWithTimelock.sol';\\nimport {IAaveGovernanceV2} from '../interfaces/IAaveGovernanceV2.sol';\\nimport {SafeMath} from '../dependencies/open-zeppelin/SafeMath.sol';\\n\\n/**\\n * @title Time Locked Executor Contract, inherited by Aave Governance Executors\\n * @dev Contract that can queue, execute, cancel transactions voted by Governance\\n * Queued transactions can be executed after a delay and until\\n * Grace period is not over.\\n * @author Aave\\n **/\\ncontract ExecutorWithTimelock is IExecutorWithTimelock {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override GRACE_PERIOD;\\n  uint256 public immutable override MINIMUM_DELAY;\\n  uint256 public immutable override MAXIMUM_DELAY;\\n\\n  address private _admin;\\n  address private _pendingAdmin;\\n  uint256 private _delay;\\n\\n  mapping(bytes32 => bool) private _queuedTransactions;\\n\\n  /**\\n   * @dev Constructor\\n   * @param admin admin address, that can call the main functions, (Governance)\\n   * @param delay minimum time between queueing and execution of proposal\\n   * @param gracePeriod time after `delay` while a proposal can be executed\\n   * @param minimumDelay lower threshold of `delay`, in seconds\\n   * @param maximumDelay upper threhold of `delay`, in seconds\\n   **/\\n  constructor(\\n    address admin,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay\\n  ) {\\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\\n    _delay = delay;\\n    _admin = admin;\\n\\n    GRACE_PERIOD = gracePeriod;\\n    MINIMUM_DELAY = minimumDelay;\\n    MAXIMUM_DELAY = maximumDelay;\\n\\n    emit NewDelay(delay);\\n    emit NewAdmin(admin);\\n  }\\n\\n  modifier onlyAdmin() {\\n    require(msg.sender == _admin, 'ONLY_BY_ADMIN');\\n    _;\\n  }\\n\\n  modifier onlyTimelock() {\\n    require(msg.sender == address(this), 'ONLY_BY_THIS_TIMELOCK');\\n    _;\\n  }\\n\\n  modifier onlyPendingAdmin() {\\n    require(msg.sender == _pendingAdmin, 'ONLY_BY_PENDING_ADMIN');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Set the delay\\n   * @param delay delay between queue and execution of proposal\\n   **/\\n  function setDelay(uint256 delay) public onlyTimelock {\\n    _validateDelay(delay);\\n    _delay = delay;\\n\\n    emit NewDelay(delay);\\n  }\\n\\n  /**\\n   * @dev Function enabling pending admin to become admin\\n   **/\\n  function acceptAdmin() public onlyPendingAdmin {\\n    _admin = msg.sender;\\n    _pendingAdmin = address(0);\\n\\n    emit NewAdmin(msg.sender);\\n  }\\n\\n  /**\\n   * @dev Setting a new pending admin (that can then become admin)\\n   * Can only be called by this executor (i.e via proposal)\\n   * @param newPendingAdmin address of the new admin\\n   **/\\n  function setPendingAdmin(address newPendingAdmin) public onlyTimelock {\\n    _pendingAdmin = newPendingAdmin;\\n\\n    emit NewPendingAdmin(newPendingAdmin);\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the action Hash\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override onlyAdmin returns (bytes32) {\\n    require(executionTime >= block.timestamp.add(_delay), 'EXECUTION_TIME_UNDERESTIMATED');\\n\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    _queuedTransactions[actionHash] = true;\\n\\n    emit QueuedAction(actionHash, target, value, signature, data, executionTime, withDelegatecall);\\n    return actionHash;\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the action Hash of the canceled tx\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public override onlyAdmin returns (bytes32) {\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    _queuedTransactions[actionHash] = false;\\n\\n    emit CancelledAction(\\n      actionHash,\\n      target,\\n      value,\\n      signature,\\n      data,\\n      executionTime,\\n      withDelegatecall\\n    );\\n    return actionHash;\\n  }\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @return the callData executed as memory bytes\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) public payable override onlyAdmin returns (bytes memory) {\\n    bytes32 actionHash = keccak256(\\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\\n    );\\n    require(_queuedTransactions[actionHash], 'ACTION_NOT_QUEUED');\\n    require(block.timestamp >= executionTime, 'TIMELOCK_NOT_FINISHED');\\n    require(block.timestamp <= executionTime.add(GRACE_PERIOD), 'GRACE_PERIOD_FINISHED');\\n\\n    _queuedTransactions[actionHash] = false;\\n\\n    bytes memory callData;\\n\\n    if (bytes(signature).length == 0) {\\n      callData = data;\\n    } else {\\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n    }\\n\\n    bool success;\\n    bytes memory resultData;\\n    if (withDelegatecall) {\\n      require(msg.value >= value, \\\"NOT_ENOUGH_MSG_VALUE\\\");\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.delegatecall(callData);\\n    } else {\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.call{value: value}(callData);\\n    }\\n\\n    require(success, 'FAILED_ACTION_EXECUTION');\\n\\n    emit ExecutedAction(\\n      actionHash,\\n      target,\\n      value,\\n      signature,\\n      data,\\n      executionTime,\\n      withDelegatecall,\\n      resultData\\n    );\\n\\n    return resultData;\\n  }\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view override returns (address) {\\n    return _admin;\\n  }\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view override returns (address) {\\n    return _pendingAdmin;\\n  }\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view override returns (uint256) {\\n    return _delay;\\n  }\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view override returns (bool) {\\n    return _queuedTransactions[actionHash];\\n  }\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\\n    external\\n    view\\n    override\\n    returns (bool)\\n  {\\n    IAaveGovernanceV2.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\\n\\n    return (block.timestamp > proposal.executionTime.add(GRACE_PERIOD));\\n  }\\n\\n  function _validateDelay(uint256 delay) internal view {\\n    require(delay >= MINIMUM_DELAY, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= MAXIMUM_DELAY, 'DELAY_LONGER_THAN_MAXIMUM');\\n  }\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Executor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {ExecutorWithTimelock} from './ExecutorWithTimelock.sol';\\nimport {ProposalValidator} from './ProposalValidator.sol';\\n\\n/**\\n * @title Time Locked, Validator, Executor Contract\\n * @dev Contract\\n * - Validate Proposal creations/ cancellation\\n * - Validate Vote Quorum and Vote success on proposal\\n * - Queue, Execute, Cancel, successful proposals' transactions.\\n * @author Aave\\n **/\\ncontract Executor is ExecutorWithTimelock, ProposalValidator {\\n  constructor(\\n    address admin,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay,\\n    uint256 propositionThreshold,\\n    uint256 voteDuration,\\n    uint256 voteDifferential,\\n    uint256 minimumQuorum\\n  )\\n    ExecutorWithTimelock(admin, delay, gracePeriod, minimumDelay, maximumDelay)\\n    ProposalValidator(propositionThreshold, voteDuration, voteDifferential, minimumQuorum)\\n  {}\\n}\\n\"\r\n    },\r\n    \"contracts/governance/ProposalValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IAaveGovernanceV2} from '../interfaces/IAaveGovernanceV2.sol';\\nimport {IGovernanceStrategy} from '../interfaces/IGovernanceStrategy.sol';\\nimport {IProposalValidator} from '../interfaces/IProposalValidator.sol';\\nimport {SafeMath} from '../dependencies/open-zeppelin/SafeMath.sol';\\n\\n/**\\n * @title Proposal Validator Contract, inherited by  Aave Governance Executors\\n * @dev Validates/Invalidations propositions state modifications.\\n * Proposition Power functions: Validates proposition creations/ cancellation\\n * Voting Power functions: Validates success of propositions.\\n * @author Aave\\n **/\\ncontract ProposalValidator is IProposalValidator {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override PROPOSITION_THRESHOLD;\\n  uint256 public immutable override VOTING_DURATION;\\n  uint256 public immutable override VOTE_DIFFERENTIAL;\\n  uint256 public immutable override MINIMUM_QUORUM;\\n  uint256 public constant override ONE_HUNDRED_WITH_PRECISION = 10000; // Equivalent to 100%, but scaled for precision\\n\\n  /**\\n   * @dev Constructor\\n   * @param propositionThreshold minimum percentage of supply needed to submit a proposal\\n   * - In ONE_HUNDRED_WITH_PRECISION units\\n   * @param votingDuration duration in blocks of the voting period\\n   * @param voteDifferential percentage of supply that `for` votes need to be over `against`\\n   *   in order for the proposal to pass\\n   * - In ONE_HUNDRED_WITH_PRECISION units\\n   * @param minimumQuorum minimum percentage of the supply in FOR-voting-power need for a proposal to pass\\n   * - In ONE_HUNDRED_WITH_PRECISION units\\n   **/\\n  constructor(\\n    uint256 propositionThreshold,\\n    uint256 votingDuration,\\n    uint256 voteDifferential,\\n    uint256 minimumQuorum\\n  ) {\\n    PROPOSITION_THRESHOLD = propositionThreshold;\\n    VOTING_DURATION = votingDuration;\\n    VOTE_DIFFERENTIAL = voteDifferential;\\n    MINIMUM_QUORUM = minimumQuorum;\\n  }\\n\\n  /**\\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be created\\n   **/\\n  function validateCreatorOfProposal(\\n    IAaveGovernanceV2 governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view override returns (bool) {\\n    return isPropositionPowerEnough(governance, user, blockNumber);\\n  }\\n\\n  /**\\n   * @dev Called to validate the cancellation of a proposal\\n   * Needs to creator to have lost proposition power threashold\\n   * @param governance Governance Contract\\n   * @param user Address of the proposal creator\\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n   * @return boolean, true if can be cancelled\\n   **/\\n  function validateProposalCancellation(\\n    IAaveGovernanceV2 governance,\\n    address user,\\n    uint256 blockNumber\\n  ) external view override returns (bool) {\\n    return !isPropositionPowerEnough(governance, user, blockNumber);\\n  }\\n\\n  /**\\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\\n   * @param governance Governance Contract\\n   * @param user Address of the user to be challenged.\\n   * @param blockNumber Block Number against which to make the challenge.\\n   * @return true if user has enough power\\n   **/\\n  function isPropositionPowerEnough(\\n    IAaveGovernanceV2 governance,\\n    address user,\\n    uint256 blockNumber\\n  ) public view override returns (bool) {\\n    IGovernanceStrategy currentGovernanceStrategy = IGovernanceStrategy(\\n      governance.getGovernanceStrategy()\\n    );\\n    return\\n      currentGovernanceStrategy.getPropositionPowerAt(user, blockNumber) >=\\n      getMinimumPropositionPowerNeeded(governance, blockNumber);\\n  }\\n\\n  /**\\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\\n   * @param governance Governance Contract\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return minimum Proposition Power needed\\n   **/\\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    IGovernanceStrategy currentGovernanceStrategy = IGovernanceStrategy(\\n      governance.getGovernanceStrategy()\\n    );\\n    return\\n      currentGovernanceStrategy\\n        .getTotalPropositionSupplyAt(blockNumber)\\n        .mul(PROPOSITION_THRESHOLD)\\n        .div(ONE_HUNDRED_WITH_PRECISION);\\n  }\\n\\n  /**\\n   * @dev Returns whether a proposal passed or not\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to set\\n   * @return true if proposal passed\\n   **/\\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\\n    external\\n    view\\n    override\\n    returns (bool)\\n  {\\n    return (isQuorumValid(governance, proposalId) &&\\n      isVoteDifferentialValid(governance, proposalId));\\n  }\\n\\n  /**\\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\\n   * @param votingSupply Total number of oustanding voting tokens\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function getMinimumVotingPowerNeeded(uint256 votingSupply)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return votingSupply.mul(MINIMUM_QUORUM).div(ONE_HUNDRED_WITH_PRECISION);\\n  }\\n\\n  /**\\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    IAaveGovernanceV2.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\\n      proposal.startBlock\\n    );\\n\\n    return proposal.forVotes >= getMinimumVotingPowerNeeded(votingSupply);\\n  }\\n\\n  /**\\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\\n   * @param governance Governance Contract\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if enough For-Votes\\n   **/\\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    IAaveGovernanceV2.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\\n      proposal.startBlock\\n    );\\n\\n    return (proposal.forVotes.mul(ONE_HUNDRED_WITH_PRECISION).div(votingSupply) >\\n      proposal.againstVotes.mul(ONE_HUNDRED_WITH_PRECISION).div(votingSupply).add(\\n        VOTE_DIFFERENTIAL\\n      ));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/GovernanceStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {IGovernanceStrategy} from '../interfaces/IGovernanceStrategy.sol';\\nimport {IERC20} from '../interfaces/IERC20.sol';\\nimport {IGovernancePowerDelegationToken} from '../interfaces/IGovernancePowerDelegationToken.sol';\\n\\n/**\\n * @title Governance Strategy contract\\n * @dev Smart contract containing logic to measure users' relative power to propose and vote.\\n * User Power = User Power from Aave Token + User Power from stkAave Token.\\n * User Power from Token = Token Power + Token Power as Delegatee [- Token Power if user has delegated]\\n * Two wrapper functions linked to Aave Tokens's GovernancePowerDelegationERC20.sol implementation\\n * - getPropositionPowerAt: fetching a user Proposition Power at a specified block\\n * - getVotingPowerAt: fetching a user Voting Power at a specified block\\n * @author Aave\\n **/\\ncontract GovernanceStrategy is IGovernanceStrategy {\\n  address override public immutable AAVE;\\n  address override public immutable STK_AAVE;\\n\\n  /**\\n   * @dev Constructor, register tokens used for Voting and Proposition Powers.\\n   * @param aave The address of the AAVE Token contract.\\n   * @param stkAave The address of the stkAAVE Token Contract\\n   **/\\n  constructor(address aave, address stkAave) {\\n    AAVE = aave;\\n    STK_AAVE = stkAave;\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of Proposition Tokens Available for Governance\\n   * = AAVE Available for governance      + stkAAVE available\\n   * The supply of AAVE staked in stkAAVE are not taken into account so:\\n   * = (Supply of AAVE - AAVE in stkAAVE) + (Supply of stkAAVE)\\n   * = Supply of AAVE, Since the supply of stkAAVE is equal to the number of AAVE staked\\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return total supply at blockNumber\\n   **/\\n  function getTotalPropositionSupplyAt(uint256 blockNumber) public view override returns (uint256) {\\n    return IERC20(AAVE).totalSupplyAt(blockNumber);\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of Outstanding Voting Tokens \\n   * @param blockNumber Blocknumber at which to evaluate\\n   * @return total supply at blockNumber\\n   **/\\n  function getTotalVotingSupplyAt(uint256 blockNumber) public view override returns (uint256) {\\n    return getTotalPropositionSupplyAt(blockNumber);\\n  }\\n\\n  /**\\n   * @dev Returns the Proposition Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\\n   * @return Power number\\n   **/\\n  function getPropositionPowerAt(address user, uint256 blockNumber)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return\\n      _getPowerByTypeAt(user, blockNumber, IGovernancePowerDelegationToken.DelegationType.PROPOSITION_POWER);\\n  }\\n\\n  /**\\n   * @dev Returns the Vote Power of a user at a specific block number.\\n   * @param user Address of the user.\\n   * @param blockNumber Blocknumber at which to fetch Vote Power\\n   * @return Vote number\\n   **/\\n  function getVotingPowerAt(address user, uint256 blockNumber)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return _getPowerByTypeAt(user, blockNumber, IGovernancePowerDelegationToken.DelegationType.VOTING_POWER);\\n  }\\n\\n  function _getPowerByTypeAt(\\n    address user,\\n    uint256 blockNumber,\\n    IGovernancePowerDelegationToken.DelegationType powerType\\n  ) internal view returns (uint256) {\\n    return\\n      IGovernancePowerDelegationToken(AAVE).getPowerAtBlock(user, blockNumber, powerType) +\\n      IGovernancePowerDelegationToken(STK_AAVE).getPowerAtBlock(user, blockNumber, powerType);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IERC20 {\\n  function totalSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernancePowerDelegationToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IGovernancePowerDelegationToken {\\n  enum DelegationType {VOTING_POWER, PROPOSITION_POWER}\\n  /**\\n   * @dev get the power of a user at a specified block\\n   * @param user address of the user\\n   * @param blockNumber block number at which to get power\\n   * @param delegationType delegation type (propose/vote)\\n   **/\\n  function getPowerAtBlock(\\n    address user,\\n    uint256 blockNumber,\\n    DelegationType delegationType\\n  ) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"ONE_HUNDRED_WITH_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"contract IExecutorWithTimelock\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"bool[]\",\"name\":\"withDelegatecalls\",\"type\":\"bool[]\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct IAaveGovernanceV2.ProposalWithoutVotes\",\"name\":\"proposal\",\"type\":\"tuple\"},{\"internalType\":\"enum IAaveGovernanceV2.ProposalState\",\"name\":\"proposalState\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minimumQuorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionTimeWithGracePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalCreated\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernanceV2Helper.ProposalStats\",\"name\":\"proposalStats\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"skip\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"getProposals\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"contract IExecutorWithTimelock\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"bool[]\",\"name\":\"withDelegatecalls\",\"type\":\"bool[]\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct IAaveGovernanceV2.ProposalWithoutVotes[]\",\"name\":\"proposals\",\"type\":\"tuple[]\"},{\"internalType\":\"enum IAaveGovernanceV2.ProposalState[]\",\"name\":\"proposalsState\",\"type\":\"uint8[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minimumQuorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDiff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionTimeWithGracePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalCreated\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernanceV2Helper.ProposalStats[]\",\"name\":\"proposalsStats\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GovernanceV2Helper","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}