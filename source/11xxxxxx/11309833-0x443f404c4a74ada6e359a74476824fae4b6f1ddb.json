{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/SupplyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/IArchToken.sol\\\";\\nimport \\\"./lib/SafeMath.sol\\\";\\n\\n/**\\n * @title SupplyManager\\n * @dev Responsible for enacting decisions related to ARCH token supply\\n * Decisions are made via a timelocked propose/accept scheme\\n * Initial proposal length (timelock) is 30 days\\n */\\ncontract SupplyManager {\\n    using SafeMath for uint256;\\n\\n    /// @notice ARCH token\\n    IArchToken public token;\\n\\n    /// @notice Address which may make changes to token supply by calling provided functions\\n    address public admin;\\n\\n    /// @notice The timestamp after which a change may occur\\n    uint256 public changeAllowedAfter;\\n\\n    /// @notice The current time between proposal and acceptance\\n    uint32 public proposalLength = 1 days * 30;\\n\\n    /// @notice The minimum time between proposal and acceptance\\n    uint32 public proposalLengthMinimum = 1 days * 7;\\n\\n    /// @notice New admin proposal\\n    struct AdminProposal {\\n        uint256 eta;\\n        address newAdmin;\\n    }\\n    \\n    /// @notice New mint proposal\\n    struct MintProposal {\\n        uint256 eta;\\n        address destination;\\n        uint256 amount;\\n    }\\n\\n    /// @notice New burn proposal\\n    struct BurnProposal {\\n        uint256 eta;\\n        address source;\\n        uint256 amount;\\n    }\\n\\n    /// @notice New mint cap proposal\\n    struct MintCapProposal {\\n        uint256 eta;\\n        uint16 newCap;\\n    }\\n\\n    /// @notice New waiting period proposal\\n    struct WaitingPeriodProposal {\\n        uint256 eta;\\n        uint32 newPeriod;\\n    }\\n\\n    /// @notice New supply manager proposal\\n    struct SupplyManagerProposal {\\n        uint256 eta;\\n        address newSupplyManager;\\n    }\\n\\n    /// @notice New proposal length proposal\\n    struct ProposalLengthProposal {\\n        uint256 eta;\\n        uint32 newLength;\\n    }\\n\\n    /// @notice Current pending admin proposal\\n    AdminProposal public pendingAdmin;\\n\\n    /// @notice Current pending mint proposal\\n    MintProposal public pendingMint;\\n\\n    /// @notice Current pending burn proposal\\n    BurnProposal public pendingBurn;\\n\\n    /// @notice Current pending mint cap proposal\\n    MintCapProposal public pendingMintCap;\\n\\n    /// @notice Current pending waiting period proposal\\n    WaitingPeriodProposal public pendingWaitingPeriod;\\n\\n    /// @notice Current pending supply manager proposal\\n    SupplyManagerProposal public pendingSupplyManager;\\n\\n    /// @notice Current pending proposal length proposal\\n    ProposalLengthProposal public pendingProposalLength;\\n\\n    /// @notice An event that's emitted when a new admin is proposed\\n    event AdminProposed(address indexed oldAdmin, address indexed newAdmin, uint256 eta);\\n\\n    /// @notice An event that's emitted when an admin proposal is canceled\\n    event AdminCanceled(address indexed proposedAdmin);\\n\\n    /// @notice An event that's emitted when a new admin is accepted\\n    event AdminAccepted(address indexed oldAdmin, address indexed newAdmin);\\n\\n    /// @notice An event that's emitted when a new mint is proposed\\n    event MintProposed(uint256 indexed amount, address indexed recipient, uint256 oldSupply, uint256 newSupply, uint256 eta);\\n\\n    /// @notice An event that's emitted when a mint proposal is canceled\\n    event MintCanceled(uint256 indexed amount, address indexed recipient);\\n\\n    /// @notice An event that's emitted when a new mint is accepted\\n    event MintAccepted(uint256 indexed amount, address indexed recipient, uint256 oldSupply, uint256 newSupply);    \\n\\n    /// @notice An event that's emitted when a new burn is proposed\\n    event BurnProposed(uint256 indexed amount, address indexed source, uint256 oldSupply, uint256 newSupply, uint256 eta);\\n\\n    /// @notice An event that's emitted when a burn proposal is canceled\\n    event BurnCanceled(uint256 indexed amount, address indexed source);\\n\\n    /// @notice An event that's emitted when a new burn is accepted\\n    event BurnAccepted(uint256 indexed amount, address indexed source, uint256 oldSupply, uint256 newSupply);\\n\\n    /// @notice An event that's emitted when a new mint cap is proposed\\n    event MintCapProposed(uint16 indexed oldCap, uint16 indexed newCap, uint256 eta);\\n\\n    /// @notice An event that's emitted when a mint cap proposal is canceled\\n    event MintCapCanceled(uint16 indexed proposedCap);\\n\\n    /// @notice An event that's emitted when a new mint cap is accepted\\n    event MintCapAccepted(uint16 indexed oldCap, uint16 indexed newCap);\\n\\n    /// @notice An event that's emitted when a new waiting period is proposed\\n    event WaitingPeriodProposed(uint32 indexed oldWaitingPeriod, uint32 indexed newWaitingPeriod, uint256 eta);\\n\\n    /// @notice An event that's emitted when a waiting period proposal is canceled\\n    event WaitingPeriodCanceled(uint32 indexed proposedWaitingPeriod);\\n\\n    /// @notice An event that's emitted when a new waiting period is accepted\\n    event WaitingPeriodAccepted(uint32 indexed oldWaitingPeriod, uint32 indexed newWaitingPeriod);\\n\\n    /// @notice An event that's emitted when a new supply manager is proposed\\n    event SupplyManagerProposed(address indexed oldSupplyManager, address indexed newSupplyManager, uint256 eta);\\n\\n    /// @notice An event that's emitted when a supply manager proposal is canceled\\n    event SupplyManagerCanceled(address indexed proposedSupplyManager);\\n\\n    /// @notice An event that's emitted when a new supply manager is accepted\\n    event SupplyManagerAccepted(address indexed oldSupplyManager, address indexed newSupplyManager);\\n\\n    /// @notice An event that's emitted when a new proposal length is proposed\\n    event ProposalLengthProposed(uint32 indexed oldProposalLength, uint32 indexed newProposalLength, uint256 eta);\\n\\n    /// @notice An event that's emitted when a proposal length proposal is canceled\\n    event ProposalLengthCanceled(uint32 indexed proposedProposalLength);\\n\\n    /// @notice An event that's emitted when a new proposal length is accepted\\n    event ProposalLengthAccepted(uint32 indexed oldProposalLength, uint32 indexed newProposalLength);\\n\\n    /**\\n     * @notice Construct a new supply manager\\n     * @param _token The address for the token\\n     * @param _admin The admin account for this contract\\n     */\\n    constructor(address _token, address _admin) {\\n        token = IArchToken(_token);\\n        changeAllowedAfter = token.supplyChangeAllowedAfter();\\n        admin = _admin;\\n    }\\n\\n    /**\\n     * @notice Propose a new token mint\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to be minted\\n     */\\n    function proposeMint(address dst, uint256 amount) external {\\n        uint256 currentSupply = token.totalSupply();\\n        require(msg.sender == admin, \\\"SM::proposeMint: caller must be admin\\\");\\n        require(dst != address(0), \\\"SM::proposeMint: cannot transfer to the zero address\\\");\\n        require(amount <= currentSupply.mul(token.mintCap()).div(1000000), \\\"SM::proposeMint: amount exceeds mint cap\\\");\\n        uint256 eta = block.timestamp.add(proposalLength);\\n        require(eta >= token.supplyChangeAllowedAfter(), \\\"SM::proposeMint: minting not allowed yet\\\");\\n        pendingMint = MintProposal(eta, dst, amount);\\n        emit MintProposed(amount, dst, currentSupply, currentSupply.add(amount), eta);\\n    }\\n\\n    /**\\n     * @notice Cancel proposed token mint\\n     */\\n    function cancelMint() external {\\n        require(msg.sender == admin, \\\"SM::cancelMint: caller must be admin\\\");\\n        require(pendingMint.eta != 0, \\\"SM::cancelMint: no active proposal\\\");\\n        emit MintCanceled(pendingMint.amount, pendingMint.destination);\\n        pendingMint = MintProposal(0, address(0), 0);\\n    }\\n\\n    /**\\n     * @notice Accept proposed token mint\\n     */\\n    function acceptMint() external {\\n        require(msg.sender == admin, \\\"SM::acceptMint: caller must be admin\\\");\\n        require(pendingMint.eta != 0, \\\"SM::acceptMint: no active proposal\\\");\\n        require(block.timestamp >= pendingMint.eta, \\\"SM::acceptMint: proposal eta not yet passed\\\");\\n        address dst = pendingMint.destination;\\n        uint256 amount = pendingMint.amount;\\n        uint256 oldSupply = token.totalSupply();\\n        pendingMint = MintProposal(0, address(0), 0);\\n        require(token.mint(dst, amount), \\\"SM::acceptMint: unsuccessful\\\");\\n        emit MintAccepted(amount, dst, oldSupply, oldSupply.add(amount));\\n    }\\n\\n    /**\\n     * @notice Propose a new token burn\\n     * @param src The address of the account that will burn tokens\\n     * @param amount The number of tokens to be burned\\n     */\\n    function proposeBurn(address src, uint256 amount) external {\\n        require(msg.sender == admin, \\\"SM::proposeBurn: caller must be admin\\\");\\n        require(src != address(0), \\\"SM::proposeBurn: cannot transfer from the zero address\\\");\\n        require(token.allowance(src, address(this)) >= amount, \\\"SM::proposeBurn: supplyManager approval < amount\\\");\\n        uint256 currentSupply = token.totalSupply();\\n        uint256 newSupply = currentSupply.sub(amount);\\n        uint256 eta = block.timestamp.add(proposalLength);\\n        require(eta >= token.supplyChangeAllowedAfter(), \\\"SM::proposeBurn: burning not allowed yet\\\");\\n        pendingBurn = BurnProposal(eta, src, amount);\\n        emit BurnProposed(amount, src, currentSupply, newSupply, eta);\\n    }\\n\\n    /**\\n     * @notice Cancel proposed token burn\\n     */\\n    function cancelBurn() external {\\n        require(msg.sender == admin, \\\"SM::cancelBurn: caller must be admin\\\");\\n        require(pendingBurn.eta != 0, \\\"SM::cancelBurn: no active proposal\\\");\\n        emit BurnCanceled(pendingBurn.amount, pendingBurn.source);\\n        pendingBurn = BurnProposal(0, address(0), 0);\\n    }\\n\\n    /**\\n     * @notice Accept proposed token burn\\n     */\\n    function acceptBurn() external {\\n        require(msg.sender == admin, \\\"SM::acceptBurn: caller must be admin\\\");\\n        require(pendingBurn.eta != 0, \\\"SM::acceptBurn: no active proposal\\\");\\n        require(block.timestamp >= pendingBurn.eta, \\\"SM::acceptBurn: proposal eta not yet passed\\\");\\n        address src = pendingBurn.source;\\n        uint256 amount = pendingBurn.amount;\\n        pendingBurn = BurnProposal(0, address(0), 0);\\n        require(token.burn(src, amount), \\\"SM::acceptBurn: unsuccessful\\\");\\n        uint256 newSupply = token.totalSupply();\\n        emit BurnAccepted(amount, src, newSupply.add(amount), newSupply);\\n    }\\n\\n    /**\\n     * @notice Propose change to the maximum amount of tokens that can be minted at once\\n     * @param newCap The new mint cap in bips (10,000 bips = 1% of totalSupply)\\n     */\\n    function proposeMintCap(uint16 newCap) external {\\n        require(msg.sender == admin, \\\"SM::proposeMC: caller must be admin\\\");\\n        uint256 eta = block.timestamp.add(proposalLength);\\n        pendingMintCap = MintCapProposal(eta, newCap);\\n        emit MintCapProposed(token.mintCap(), newCap, eta);\\n    }\\n\\n    /**\\n     * @notice Cancel proposed mint cap\\n     */\\n    function cancelMintCap() external {\\n        require(msg.sender == admin, \\\"SM::cancelMC: caller must be admin\\\");\\n        require(pendingMintCap.eta != 0, \\\"SM::cancelMC: no active proposal\\\");\\n        emit MintCapCanceled(pendingMintCap.newCap);\\n        pendingMintCap = MintCapProposal(0, 0);\\n    }\\n\\n    /**\\n     * @notice Accept change to the maximum amount of tokens that can be minted at once\\n     */\\n    function acceptMintCap() external {\\n        require(msg.sender == admin, \\\"SM::acceptMC: caller must be admin\\\");\\n        require(pendingMintCap.eta != 0, \\\"SM::acceptMC: no active proposal\\\");\\n        require(block.timestamp >= pendingMintCap.eta, \\\"SM::acceptMC: proposal eta not yet passed\\\");\\n        uint16 oldCap = token.mintCap();\\n        uint16 newCap = pendingMintCap.newCap;\\n        pendingMintCap = MintCapProposal(0, 0);\\n        require(token.setMintCap(newCap), \\\"SM::acceptMC: unsuccessful\\\");\\n        emit MintCapAccepted(oldCap, newCap);\\n    }\\n\\n    /**\\n     * @notice Propose change to the supply change waiting period\\n     * @param newPeriod new waiting period\\n     */\\n    function proposeSupplyChangeWaitingPeriod(uint32 newPeriod) external {\\n        require(msg.sender == admin, \\\"SM::proposeWP: caller must be admin\\\");\\n        uint256 eta = block.timestamp.add(proposalLength);\\n        pendingWaitingPeriod = WaitingPeriodProposal(eta, newPeriod);\\n        emit WaitingPeriodProposed(token.supplyChangeWaitingPeriod(), newPeriod, eta);\\n    }\\n\\n    /**\\n     * @notice Cancel proposed waiting period\\n     */\\n    function cancelWaitingPeriod() external {\\n        require(msg.sender == admin, \\\"SM::cancelWP: caller must be admin\\\");\\n        require(pendingWaitingPeriod.eta != 0, \\\"SM::cancelWaitingPeriod: no active proposal\\\");\\n        pendingWaitingPeriod = WaitingPeriodProposal(0, 0);\\n        emit WaitingPeriodCanceled(pendingWaitingPeriod.newPeriod);\\n    }\\n\\n    /**\\n     * @notice Accept change to the supply change waiting period\\n     */\\n    function acceptSupplyChangeWaitingPeriod() external {\\n        require(msg.sender == admin, \\\"SM::acceptWP: caller must be admin\\\");\\n        require(pendingWaitingPeriod.eta != 0, \\\"SM::acceptWP: no active proposal\\\");\\n        require(block.timestamp >= pendingWaitingPeriod.eta, \\\"SM::acceptWP: proposal eta not yet passed\\\");\\n        uint32 oldPeriod = token.supplyChangeWaitingPeriod();\\n        uint32 newPeriod = pendingWaitingPeriod.newPeriod;\\n        pendingWaitingPeriod = WaitingPeriodProposal(0, 0);\\n        require(token.setSupplyChangeWaitingPeriod(newPeriod), \\\"SM::acceptWP: unsuccessful\\\");\\n        emit WaitingPeriodAccepted(oldPeriod, newPeriod);\\n    }\\n\\n    /**\\n     * @notice Propose change to the supplyManager address\\n     * @param newSupplyManager new supply manager address\\n     */\\n    function proposeSupplyManager(address newSupplyManager) external {\\n        require(msg.sender == admin, \\\"SM::proposeSM: caller must be admin\\\");\\n        uint256 eta = block.timestamp.add(proposalLength);\\n        pendingSupplyManager = SupplyManagerProposal(eta, newSupplyManager);\\n        emit SupplyManagerProposed(token.supplyManager(), newSupplyManager, eta);\\n    }\\n\\n    /**\\n     * @notice Cancel proposed supply manager update\\n     */\\n    function cancelSupplyManager() external {\\n        require(msg.sender == admin, \\\"SM::cancelSM: caller must be admin\\\");\\n        require(pendingSupplyManager.eta != 0, \\\"SM::cancelSM: no active proposal\\\");\\n        emit SupplyManagerCanceled(pendingSupplyManager.newSupplyManager);\\n        pendingSupplyManager = SupplyManagerProposal(0, address(0));\\n    }\\n\\n    /**\\n     * @notice Accept change to the supplyManager address\\n     */\\n    function acceptSupplyManager() external {\\n        require(msg.sender == admin, \\\"SM::acceptSM: caller must be admin\\\");\\n        require(pendingSupplyManager.eta != 0, \\\"SM::acceptSM: no active proposal\\\");\\n        require(block.timestamp >= pendingSupplyManager.eta, \\\"SM::acceptSM: proposal eta not yet passed\\\");\\n        address oldSupplyManager = token.supplyManager();\\n        address newSupplyManager = pendingSupplyManager.newSupplyManager;\\n        pendingSupplyManager = SupplyManagerProposal(0, address(0));\\n        require(token.setSupplyManager(newSupplyManager), \\\"SM::acceptSM: unsuccessful\\\");\\n        emit SupplyManagerAccepted(oldSupplyManager, newSupplyManager);\\n    }\\n\\n    /**\\n     * @notice Propose change to the proposal length\\n     * @param newLength new proposal length\\n     */\\n    function proposeNewProposalLength(uint32 newLength) external {\\n        require(msg.sender == admin, \\\"SM::proposePL: caller must be admin\\\");\\n        require(newLength >= proposalLengthMinimum, \\\"SM::proposePL: length must be >= minimum\\\");\\n        uint256 eta = block.timestamp.add(proposalLength);\\n        pendingProposalLength = ProposalLengthProposal(eta, newLength);\\n        emit ProposalLengthProposed(proposalLength, newLength, eta);\\n    }\\n\\n    /**\\n     * @notice Cancel proposed update to proposal length\\n     */\\n    function cancelProposalLength() external {\\n        require(msg.sender == admin, \\\"SM::cancelPL: caller must be admin\\\");\\n        require(pendingProposalLength.eta != 0, \\\"SM::cancelPL: no active proposal\\\");\\n        emit ProposalLengthCanceled(pendingProposalLength.newLength);\\n        pendingProposalLength = ProposalLengthProposal(0, 0);\\n    }\\n\\n    /**\\n     * @notice Accept change to the proposal length\\n     */\\n    function acceptProposalLength() external {\\n        require(msg.sender == admin, \\\"SM::acceptPL: caller must be admin\\\");\\n        require(pendingProposalLength.eta != 0, \\\"SM::acceptPL: no active proposal\\\");\\n        require(block.timestamp >= pendingProposalLength.eta, \\\"SM::acceptPL: proposal eta not yet passed\\\");\\n        uint32 oldLength = proposalLength;\\n        uint32 newLength = pendingProposalLength.newLength;\\n        pendingProposalLength = ProposalLengthProposal(0, 0);\\n        proposalLength = newLength;\\n        emit ProposalLengthAccepted(oldLength, newLength);\\n    }\\n\\n    /**\\n     * @notice Propose a new admin\\n     * @param newAdmin The address of the new admin\\n     */\\n    function proposeAdmin(address newAdmin) external {\\n        require(msg.sender == admin, \\\"SM::proposeAdmin: caller must be admin\\\");\\n        // ETA set to minimum to allow for quicker changes if necessary\\n        uint256 eta = block.timestamp.add(proposalLengthMinimum);\\n        pendingAdmin = AdminProposal(eta, newAdmin);\\n        emit AdminProposed(admin, newAdmin, eta);\\n    }\\n\\n    /**\\n     * @notice Cancel proposed admin change\\n     */\\n    function cancelAdmin() external {\\n        require(msg.sender == admin, \\\"SM::cancelAdmin: caller must be admin\\\");\\n        require(pendingAdmin.eta != 0, \\\"SM::cancelAdmin: no active proposal\\\");\\n        emit AdminCanceled(pendingAdmin.newAdmin);\\n        pendingAdmin = AdminProposal(0, address(0));\\n    }\\n\\n    /**\\n     * @notice Accept proposed admin\\n     */\\n    function acceptAdmin() external {\\n        require(msg.sender == admin, \\\"SM::acceptAdmin: caller must be admin\\\");\\n        require(pendingAdmin.eta != 0, \\\"SM::acceptAdmin: no active proposal\\\");\\n        require(block.timestamp >= pendingAdmin.eta, \\\"SM::acceptAdmin: proposal eta not yet passed\\\");\\n        address oldAdmin = admin;\\n        address newAdmin = pendingAdmin.newAdmin;\\n        pendingAdmin = AdminProposal(0, address(0));\\n        admin = newAdmin;\\n        emit AdminAccepted(oldAdmin, newAdmin);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IArchToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface IArchToken {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function mint(address dst, uint256 amount) external returns (bool);\\n    function burn(address src, uint256 amount) external returns (bool);\\n    function updateTokenMetadata(string memory tokenName, string memory tokenSymbol) external returns (bool);\\n    function supplyManager() external view returns (address);\\n    function metadataManager() external view returns (address);\\n    function supplyChangeAllowedAfter() external view returns (uint256);\\n    function supplyChangeWaitingPeriod() external view returns (uint32);\\n    function supplyChangeWaitingPeriodMinimum() external view returns (uint32);\\n    function mintCap() external view returns (uint16);\\n    function setSupplyManager(address newSupplyManager) external returns (bool);\\n    function setMetadataManager(address newMetadataManager) external returns (bool);\\n    function setSupplyChangeWaitingPeriod(uint32 period) external returns (bool);\\n    function setMintCap(uint16 newCap) external returns (bool);\\n    event MintCapChanged(uint16 indexed oldMintCap, uint16 indexed newMintCap);\\n    event SupplyManagerChanged(address indexed oldManager, address indexed newManager);\\n    event SupplyChangeWaitingPeriodChanged(uint32 indexed oldWaitingPeriod, uint32 indexed newWaitingPeriod);\\n    event MetadataManagerChanged(address indexed oldManager, address indexed newManager);\\n    event TokenMetaUpdated(string indexed name, string indexed symbol);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\n}\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedAdmin\",\"type\":\"address\"}],\"name\":\"AdminCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"AdminProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"}],\"name\":\"BurnAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"}],\"name\":\"BurnCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"BurnProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"}],\"name\":\"MintAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"MintCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"oldCap\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"newCap\",\"type\":\"uint16\"}],\"name\":\"MintCapAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"proposedCap\",\"type\":\"uint16\"}],\"name\":\"MintCapCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"oldCap\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"newCap\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"MintCapProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"MintProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"oldProposalLength\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"newProposalLength\",\"type\":\"uint32\"}],\"name\":\"ProposalLengthAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"proposedProposalLength\",\"type\":\"uint32\"}],\"name\":\"ProposalLengthCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"oldProposalLength\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"newProposalLength\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"ProposalLengthProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldSupplyManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSupplyManager\",\"type\":\"address\"}],\"name\":\"SupplyManagerAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedSupplyManager\",\"type\":\"address\"}],\"name\":\"SupplyManagerCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldSupplyManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSupplyManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"SupplyManagerProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"oldWaitingPeriod\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"newWaitingPeriod\",\"type\":\"uint32\"}],\"name\":\"WaitingPeriodAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"proposedWaitingPeriod\",\"type\":\"uint32\"}],\"name\":\"WaitingPeriodCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"oldWaitingPeriod\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"newWaitingPeriod\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"WaitingPeriodProposed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptMintCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptProposalLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptSupplyChangeWaitingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptSupplyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelMintCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelProposalLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelSupplyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelWaitingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeAllowedAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingMintCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"newCap\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingProposalLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"newLength\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingSupplyManager\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newSupplyManager\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingWaitingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"newPeriod\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalLength\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalLengthMinimum\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"proposeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"proposeBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"proposeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newCap\",\"type\":\"uint16\"}],\"name\":\"proposeMintCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newLength\",\"type\":\"uint32\"}],\"name\":\"proposeNewProposalLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newPeriod\",\"type\":\"uint32\"}],\"name\":\"proposeSupplyChangeWaitingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSupplyManager\",\"type\":\"address\"}],\"name\":\"proposeSupplyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IArchToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SupplyManager","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000001f3f9d3068568f8040775be2e8c03c103c61f3af00000000000000000000000013d5b8fc84f73fc5a0a5832aa8373044371314d3","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}