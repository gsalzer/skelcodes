{"status":"1","message":"OK","result":[{"SourceCode":"{\"Seed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IOwnershipTransferrable {\\r\\n  function transferOwnership(address owner) external;\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n}\\r\\n\\r\\nabstract contract Ownable is IOwnershipTransferrable {\\r\\n  address private _owner;\\r\\n\\r\\n  constructor(address owner) {\\r\\n    _owner = owner;\\r\\n    emit OwnershipTransferred(address(0), _owner);\\r\\n  }\\r\\n\\r\\n  function owner() public view returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  modifier onlyOwner() {\\r\\n    require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function transferOwnership(address newOwner) override external onlyOwner {\\r\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n    emit OwnershipTransferred(_owner, newOwner);\\r\\n    _owner = newOwner;\\r\\n  }\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c \\u003e= a);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b \\u003c= a);\\r\\n    uint256 c = a - b;\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b \\u003e 0);\\r\\n    uint256 c = a / b;\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract Seed is Ownable {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  uint256 constant UINT256_MAX = ~uint256(0);\\r\\n\\r\\n  string private _name;\\r\\n  string private _symbol;\\r\\n  uint8 private _decimals;\\r\\n\\r\\n  uint256 private _totalSupply;\\r\\n  mapping(address =\\u003e uint256) private _balances;\\r\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n  constructor() Ownable(msg.sender) {\\r\\n    _totalSupply = 1000000 * 1e18;\\r\\n    _name = \\\"Seed\\\";\\r\\n    _symbol = \\\"SEED\\\";\\r\\n    _decimals = 18;\\r\\n\\r\\n    _balances[msg.sender] = _totalSupply;\\r\\n    emit Transfer(address(0), msg.sender, _totalSupply);\\r\\n  }\\r\\n\\r\\n  function name() external view returns (string memory) {\\r\\n    return _name;\\r\\n  }\\r\\n\\r\\n  function symbol() external view returns (string memory) {\\r\\n    return _symbol;\\r\\n  }\\r\\n\\r\\n  function decimals() external view returns (uint8) {\\r\\n    return _decimals;\\r\\n  }\\r\\n\\r\\n  function totalSupply() external view returns (uint256) {\\r\\n    return _totalSupply;\\r\\n  }\\r\\n\\r\\n  function balanceOf(address account) external view returns (uint256) {\\r\\n    return _balances[account];\\r\\n  }\\r\\n\\r\\n  function allowance(address owner, address spender) external view returns (uint256) {\\r\\n    return _allowances[owner][spender];\\r\\n  }\\r\\n\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool) {\\r\\n    _transfer(msg.sender, recipient, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function approve(address spender, uint256 amount) external returns (bool) {\\r\\n    _approve(msg.sender, spender, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\\r\\n    _transfer(sender, recipient, amount);\\r\\n    if (_allowances[msg.sender][sender] != UINT256_MAX) {\\r\\n      _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\r\\n    }\\r\\n    return true;\\r\\n  }\\r\\n  \\r\\n  function _transfer(address sender, address recipient, uint256 amount) internal {\\r\\n    require(sender != address(0));\\r\\n    require(recipient != address(0));\\r\\n\\r\\n    _balances[sender] = _balances[sender].sub(amount);\\r\\n    _balances[recipient] = _balances[recipient].add(amount);\\r\\n    emit Transfer(sender, recipient, amount);\\r\\n  }\\r\\n  \\r\\n  function mint(address account, uint256 amount) external onlyOwner {\\r\\n    _totalSupply = _totalSupply.add(amount);\\r\\n    _balances[account] = _balances[account].add(amount);\\r\\n    emit Transfer(address(0), account, amount);\\r\\n  }  \\r\\n\\r\\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\r\\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\r\\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function _approve(address owner, address spender, uint256 amount) internal {\\r\\n    require(owner != address(0));\\r\\n    require(spender != address(0));\\r\\n\\r\\n    _allowances[owner][spender] = amount;\\r\\n    emit Approval(owner, spender, amount);\\r\\n  }\\r\\n\\r\\n  function burn(uint256 amount) external returns (bool) {\\r\\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n    _totalSupply = _totalSupply.sub(amount);\\r\\n    emit Transfer(msg.sender, address(0), amount);\\r\\n    return true;\\r\\n  }\\r\\n}\\r\\n\"},\"SeedDAO.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./Seed.sol\\\";\\r\\n\\r\\nabstract contract ReentrancyGuard {\\r\\n  bool private _entered;\\r\\n\\r\\n  modifier noReentrancy() {\\r\\n    require(!_entered);\\r\\n    _entered = true;\\r\\n    _;\\r\\n    _entered = false;\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface ISeedStake is IOwnershipTransferrable {\\r\\n  event StakeIncreased(address indexed staker, uint256 amount);\\r\\n  event StakeDecreased(address indexed staker, uint256 amount);\\r\\n  event Rewards(address indexed staker, uint256 mintage, uint256 developerFund);\\r\\n  event MelodyAdded(address indexed melody);\\r\\n  event MelodyRemoved(address indexed melody);\\r\\n\\r\\n  function seed() external returns (address);\\r\\n  function totalStaked() external returns (uint256);\\r\\n  function staked(address staker) external returns (uint256);\\r\\n  function lastClaim(address staker) external returns (uint256);\\r\\n\\r\\n  function addMelody(address melody) external;\\r\\n  function removeMelody(address melody) external;\\r\\n  function upgrade(address owned, address upgraded) external;\\r\\n}\\r\\n\\r\\ncontract SeedDAO is ReentrancyGuard {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  // Proposal fee of 10 SEED. Used to prevent spam\\r\\n  uint256 constant PROPOSAL_FEE = 10 * 1e18;\\r\\n\\r\\n  event NewProposal(uint64 indexed proposal);\\r\\n\\r\\n  event FundProposed(uint64 indexed proposal, address indexed destination, uint256 amount);\\r\\n  event MelodyAdditionProposed(uint64 indexed proposal, address melody);\\r\\n  event MelodyRemovalProposed(uint64 indexed proposal, address melody);\\r\\n  event StakeUpgradeProposed(uint64 indexed proposal, address newStake);\\r\\n  event DAOUpgradeProposed(uint64 indexed proposal, address newDAO);\\r\\n\\r\\n  event ProposalVoteAdded(uint64 indexed proposal, address indexed staker);\\r\\n  event ProposalVoteRemoved(uint64 indexed proposal, address indexed staker);\\r\\n\\r\\n  event ProposalPassed(uint64 indexed proposal);\\r\\n  event ProposalRemoved(uint64 indexed proposal);\\r\\n\\r\\n  enum ProposalType { Null, Fund, MelodyAddition, MelodyRemoval, StakeUpgrade, DAOUpgrade }\\r\\n  struct ProposalMetadata {\\r\\n    ProposalType pType;\\r\\n    // Allows the creator to withdraw the proposal\\r\\n    address creator;\\r\\n    // Used to mark proposals older than 30 days as invalid\\r\\n    uint256 submitted;\\r\\n    // Stakers who voted yes\\r\\n    mapping(address =\\u003e bool) stakers;\\r\\n    // Whether or not the proposal is completed\\r\\n    // Stops it from being acted on multiple times\\r\\n    bool completed;\\r\\n  }\\r\\n\\r\\n  // The info string is intended for an URL to describe the proposal\\r\\n  struct FundProposal {\\r\\n    address destination;\\r\\n    uint256 amount;\\r\\n    string info;\\r\\n  }\\r\\n\\r\\n  struct MelodyAdditionProposal {\\r\\n    address melody;\\r\\n    string info;\\r\\n  }\\r\\n\\r\\n  struct MelodyRemovalProposal {\\r\\n    address melody;\\r\\n    string info;\\r\\n  }\\r\\n\\r\\n  struct StakeUpgradeProposal {\\r\\n    address newStake;\\r\\n    // List of addresses owned by the Stake contract\\r\\n    address[] owned;\\r\\n    string info;\\r\\n  }\\r\\n\\r\\n  struct DAOUpgradeProposal {\\r\\n    address newDAO;\\r\\n    string info;\\r\\n  }\\r\\n\\r\\n  mapping(uint64 =\\u003e ProposalMetadata) public proposals;\\r\\n  mapping(uint64 =\\u003e mapping(address =\\u003e bool)) public used;\\r\\n  mapping(uint64 =\\u003e FundProposal) public _fundProposals;\\r\\n  mapping(uint64 =\\u003e MelodyAdditionProposal) public _melodyAdditionProposals;\\r\\n  mapping(uint64 =\\u003e MelodyRemovalProposal) public _melodyRemovalProposals;\\r\\n  mapping(uint64 =\\u003e StakeUpgradeProposal) public _stakeUpgradeProposals;\\r\\n  mapping(uint64 =\\u003e DAOUpgradeProposal) public _daoUpgradeProposals;\\r\\n\\r\\n  // Address of the DAO we upgraded to\\r\\n  address _upgrade;\\r\\n  // ID to use for the next proposal\\r\\n  uint64 _nextProposalID;\\r\\n  ISeedStake private _stake;\\r\\n  Seed private _SEED;\\r\\n\\r\\n  // Check the proposal is valid\\r\\n  modifier pendingProposal(uint64 proposal) {\\r\\n    require(proposals[proposal].pType != ProposalType.Null);\\r\\n    require(!proposals[proposal].completed);\\r\\n    // Don\\u0027t allow old proposals to suddenly be claimed\\r\\n    require(proposals[proposal].submitted + 30 days \\u003e block.timestamp);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  // Check this contract hasn\\u0027t been replaced\\r\\n  modifier active() {\\r\\n    require(_upgrade == address(0));\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  constructor(address stake) {\\r\\n    _stake = ISeedStake(stake);\\r\\n    _SEED = Seed(_stake.seed());\\r\\n  }\\r\\n\\r\\n  function upgraded() external view returns (bool) {\\r\\n    return _upgrade != address(0);\\r\\n  }\\r\\n\\r\\n  function upgrade() external view returns (address) {\\r\\n    return _upgrade;\\r\\n  }\\r\\n\\r\\n  function stake() external view returns (address) {\\r\\n    return address(_stake);\\r\\n  }\\r\\n\\r\\n  function _createNewProposal(ProposalType pType) internal active returns (uint64) {\\r\\n    // Make sure this isn\\u0027t spam by transferring the proposal fee\\r\\n    require(_SEED.transferFrom(msg.sender, address(this), PROPOSAL_FEE));\\r\\n\\r\\n    // Increment the next proposal ID now\\r\\n    // Means we don\\u0027t have to return a value we subtract one from later\\r\\n    _nextProposalID += 1;\\r\\n    emit NewProposal(_nextProposalID);\\r\\n\\r\\n    // Set up the proposal\\u0027s metadata\\r\\n    ProposalMetadata storage meta = proposals[_nextProposalID];\\r\\n    meta.pType = pType;\\r\\n    meta.creator = msg.sender;\\r\\n    meta.submitted = block.timestamp;\\r\\n    // Automatically vote for the proposal\\u0027s creator\\r\\n    meta.stakers[msg.sender] = true;\\r\\n    emit ProposalVoteAdded(_nextProposalID, msg.sender);\\r\\n\\r\\n    return _nextProposalID;\\r\\n  }\\r\\n\\r\\n  function proposeFund(address destination, uint256 amount, string calldata info) external returns (uint64) {\\r\\n    uint64 proposalID = _createNewProposal(ProposalType.Fund);\\r\\n    _fundProposals[proposalID] = FundProposal(destination, amount, info);\\r\\n    emit FundProposed(proposalID, destination, amount);\\r\\n    return proposalID;\\r\\n  }\\r\\n\\r\\n  function proposeMelodyAddition(address melody, string calldata info) external returns (uint64) {\\r\\n    uint64 proposalID = _createNewProposal(ProposalType.MelodyAddition);\\r\\n    _melodyAdditionProposals[proposalID] = MelodyAdditionProposal(melody, info);\\r\\n    emit MelodyAdditionProposed(proposalID, melody);\\r\\n    return proposalID;\\r\\n  }\\r\\n\\r\\n  function proposeMelodyRemoval(address melody, string calldata info) external returns (uint64) {\\r\\n    uint64 proposalID = _createNewProposal(ProposalType.MelodyRemoval);\\r\\n    _melodyRemovalProposals[proposalID] = MelodyRemovalProposal(melody, info);\\r\\n    emit MelodyRemovalProposed(proposalID, melody);\\r\\n    return proposalID;\\r\\n  }\\r\\n\\r\\n  function proposeStakeUpgrade(address newStake, address[] calldata owned, string calldata info) external returns (uint64) {\\r\\n    uint64 proposalID = _createNewProposal(ProposalType.StakeUpgrade);\\r\\n\\r\\n    // Ensure the SEED token was included as an owned contract\\r\\n    for (uint i = 0; i \\u003c owned.length; i++) {\\r\\n      if (owned[i] == address(_SEED)) {\\r\\n        break;\\r\\n      }\\r\\n      require(i != owned.length - 1);\\r\\n    }\\r\\n    _stakeUpgradeProposals[proposalID] = StakeUpgradeProposal(newStake, owned, info);\\r\\n    emit StakeUpgradeProposed(proposalID, newStake);\\r\\n    return proposalID;\\r\\n  }\\r\\n\\r\\n  function proposeDAOUpgrade(address newDAO, string calldata info) external returns (uint64) {\\r\\n    uint64 proposalID = _createNewProposal(ProposalType.DAOUpgrade);\\r\\n    _daoUpgradeProposals[proposalID] = DAOUpgradeProposal(newDAO, info);\\r\\n    emit DAOUpgradeProposed(proposalID, newDAO);\\r\\n    return proposalID;\\r\\n  }\\r\\n\\r\\n  function addVote(uint64 proposalID) external active pendingProposal(proposalID) {\\r\\n    proposals[proposalID].stakers[msg.sender] = true;\\r\\n    emit ProposalVoteAdded(proposalID, msg.sender);\\r\\n  }\\r\\n\\r\\n  function removeVote(uint64 proposalID) external active pendingProposal(proposalID) {\\r\\n    proposals[proposalID].stakers[msg.sender] = false;\\r\\n    emit ProposalVoteRemoved(proposalID, msg.sender);\\r\\n  }\\r\\n\\r\\n  // Send the SEED held by this contract to what it upgraded to\\r\\n  // Intended to enable a contract like the timelock, if transferred to this\\r\\n  // Without this, it\\u0027d be trapped here, forever\\r\\n  function forwardSEED() public {\\r\\n    require(_upgrade != address(0));\\r\\n    require(_SEED.transfer(_upgrade, _SEED.balanceOf(address(this))));\\r\\n  }\\r\\n\\r\\n  // Complete a proposal\\r\\n  // Takes in a list of stakers so this contract doesn\\u0027t have to track them all in an array\\r\\n  // This would be extremely expensive as a stakers vote weight can drop to 0\\r\\n  // This selective process allows only counting meaningful votes\\r\\n  function completeProposal(uint64 proposalID, address[] calldata stakers) external active pendingProposal(proposalID) noReentrancy {\\r\\n    ProposalMetadata storage meta = proposals[proposalID];\\r\\n\\r\\n    uint256 requirement;\\r\\n    // Only require a majority vote for a funding request/to remove a melody\\r\\n    if ((meta.pType == ProposalType.Fund) || (meta.pType == ProposalType.MelodyRemoval)) {\\r\\n      requirement = _stake.totalStaked().div(2).add(1);\\r\\n\\r\\n    // Require \\u003e66% to add a new melody\\r\\n    // Adding an insecure or malicious melody will cause the staking pool to be drained\\r\\n    } else if (meta.pType == ProposalType.MelodyAddition) {\\r\\n      requirement = _stake.totalStaked().div(3).mul(2).add(1);\\r\\n\\r\\n    // Require \\u003e80% to upgrade the stake/DAO contract\\r\\n    // Upgrading to an insecure or malicious contract risks unlimited minting\\r\\n    } else if ((meta.pType == ProposalType.StakeUpgrade) || (meta.pType == ProposalType.DAOUpgrade)) {\\r\\n      requirement = _stake.totalStaked().div(5).mul(4).add(1);\\r\\n\\r\\n    // Panic in case the enum is expanded and not properly handled here\\r\\n    } else {\\r\\n      require(false);\\r\\n    }\\r\\n\\r\\n    // Make sure there\\u0027s enough vote weight behind this proposal\\r\\n    uint256 votes = 0;\\r\\n    for (uint i = 0; i \\u003c stakers.length; i++) {\\r\\n      // Don\\u0027t allow people to vote with flash loans\\r\\n      if (_stake.lastClaim(stakers[i]) == block.timestamp) {\\r\\n        continue;\\r\\n      }\\r\\n      require(meta.stakers[stakers[i]]);\\r\\n      require(!used[proposalID][stakers[i]]);\\r\\n      used[proposalID][stakers[i]] = true;\\r\\n      votes = votes.add(_stake.staked(stakers[i]));\\r\\n    }\\r\\n    require(votes \\u003e= requirement);\\r\\n    meta.completed = true;\\r\\n    emit ProposalPassed(proposalID);\\r\\n\\r\\n    if (meta.pType == ProposalType.Fund) {\\r\\n      FundProposal memory proposal = _fundProposals[proposalID];\\r\\n      require(_SEED.transfer(proposal.destination, proposal.amount));\\r\\n\\r\\n    } else if (meta.pType == ProposalType.MelodyAddition) {\\r\\n      _stake.addMelody(_melodyAdditionProposals[proposalID].melody);\\r\\n\\r\\n    } else if (meta.pType == ProposalType.MelodyRemoval) {\\r\\n      _stake.removeMelody(_melodyRemovalProposals[proposalID].melody);\\r\\n\\r\\n    } else if (meta.pType == ProposalType.StakeUpgrade) {\\r\\n      StakeUpgradeProposal memory proposal = _stakeUpgradeProposals[proposalID];\\r\\n      for (uint i = 0; i \\u003c proposal.owned.length; i++) {\\r\\n        _stake.upgrade(proposal.owned[i], proposal.newStake);\\r\\n      }\\r\\n\\r\\n      // Register the new staking contract as a melody so it can move the funds over\\r\\n      _stake.addMelody(address(proposal.newStake));\\r\\n\\r\\n      _stake = ISeedStake(proposal.newStake);\\r\\n\\r\\n    } else if (meta.pType == ProposalType.DAOUpgrade) {\\r\\n      _upgrade = _daoUpgradeProposals[proposalID].newDAO;\\r\\n      _stake.transferOwnership(_upgrade);\\r\\n      forwardSEED();\\r\\n\\r\\n    } else {\\r\\n      require(false);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // Voluntarily withdraw a proposal\\r\\n  function withdrawProposal(uint64 proposalID) external active pendingProposal(proposalID) {\\r\\n    require(proposals[proposalID].creator == msg.sender);\\r\\n    proposals[proposalID].completed = true;\\r\\n    emit ProposalRemoved(proposalID);\\r\\n  }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stake\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"proposal\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"DAOUpgradeProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"proposal\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"proposal\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"melody\",\"type\":\"address\"}],\"name\":\"MelodyAdditionProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"proposal\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"melody\",\"type\":\"address\"}],\"name\":\"MelodyRemovalProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"proposal\",\"type\":\"uint64\"}],\"name\":\"NewProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"proposal\",\"type\":\"uint64\"}],\"name\":\"ProposalPassed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"proposal\",\"type\":\"uint64\"}],\"name\":\"ProposalRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"proposal\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"ProposalVoteAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"proposal\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"ProposalVoteRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"proposal\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStake\",\"type\":\"address\"}],\"name\":\"StakeUpgradeProposed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"_daoUpgradeProposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"_fundProposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"_melodyAdditionProposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"melody\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"_melodyRemovalProposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"melody\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"_stakeUpgradeProposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newStake\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"proposalID\",\"type\":\"uint64\"}],\"name\":\"addVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"proposalID\",\"type\":\"uint64\"},{\"internalType\":\"address[]\",\"name\":\"stakers\",\"type\":\"address[]\"}],\"name\":\"completeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwardSEED\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"enum SeedDAO.ProposalType\",\"name\":\"pType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"submitted\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"name\":\"proposeDAOUpgrade\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"name\":\"proposeFund\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"melody\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"name\":\"proposeMelodyAddition\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"melody\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"name\":\"proposeMelodyRemoval\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStake\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"owned\",\"type\":\"address[]\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"}],\"name\":\"proposeStakeUpgrade\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"proposalID\",\"type\":\"uint64\"}],\"name\":\"removeVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgraded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"used\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"proposalID\",\"type\":\"uint64\"}],\"name\":\"withdrawProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SeedDAO","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003875d5b8cd877923b5f014e31139e43ebf25d527","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3b1c0d178642e512cac49570aeb1cc34fd0c49b1f5798a5074df852c1c0d6483"}]}